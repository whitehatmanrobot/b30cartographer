    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Merced compiler
            case BCID_Tool_Compiler_Merced:
                VPROJDeriveDefaultCplrOptionsMERCED(strOption, fDebug, fDebug ? IDS_WIN64MERCEDCON_CPLR_DBG : IDS_WIN64MERCEDCON_CPLR_REL);
                break;

            // the Merced COFF linker
            case BCID_Tool_Linker_Merced:
                VPROJDeriveDefaultWIN64MERCEDLinkOptions(strOption, fDebug, IDS_WIN32CON_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin64MERCEDLib::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the Merced compiler
            case BCID_Tool_Compiler_Merced:
                VPROJDeriveDefaultCplrOptionsMERCED(strOption, fDebug, fDebug ? IDS_WIN64MERCEDLIB_CPLR_DBG : IDS_WIN64MERCEDLIB_CPLR_REL);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if (PackageIdFromBscId(bsc_id) == idAddOnGeneric) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF library manager
            case BCID_Tool_Lib:
                VPROJDeriveDefaultLibOptionsMERCED(strOption, fDebug, IDS_WIN32LIB_LINK);
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsMERCED(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin64MERCEDExe::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_Merced);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin64MERCEDDll::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_Merced);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin64MERCEDCon::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_Merced);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin64MERCEDLib::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_Lib);

    return TRUE;    // success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platx86.cpp ===
//
// Intelx86 Platform
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"     // our standard AFX include
#pragma hdrstop
#include "platx86.h"    // our local header file

IMPLEMENT_DYNAMIC(CProjTypeWin32Exe, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32Dll, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32Lib, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeWin32Con, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeGeneric, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// declare our platform
//
// *** DO NOT TRANSLATE (LOCALIZE) THE PLATFORM STRINGS HERE ***

PlatformInfo g_PlatformInfoWin32x86 =
{
    _T("Win32 (x86)"),          // Official platform name -- DO NOT LOCALIZE!
    win32x86,                   // Unique ID
#if !defined (_ALPHA_) && !defined (_PPC_)
    IDS_WIN32_PLATFORM,         // Localizable description string
#else
    IDS_WIN32X86_PLATFORM,      // Localizable description string
#endif
    IDS_WIN32X86_PLATFORM_SHORT,// Abbreviated localizable description string
    _T("res"),                  // RC extension
#if !defined (_ALPHA_) && !defined (_PPC_)
    PIA_Primary_Platform |      // Primary platform
#else
    0 |                         // Not Primary platform
#endif
    PIA_Allow_WorkingDir |      // Can use a working dir. for debugging
    PIA_Supports_IncCplr |      // Supports inc. cplr.
    PIA_Supports_RTTI |         // Supports RTTI
    PIA_Supports_IncLink|       // Supports ilink
    PIA_Supports_MinBuild |     // Supports minimum build
    PIA_Enable_Language |       // Enable language for RC option
    PIA_Allow_MFCinDLL |        // Supports use of mfc in a dll
    PIA_Allow_ODBC |            // Allow use of mfc ODBC
    PIA_Allow_ProgArgs |        // Executable can use program arguments for Debug etc.
    PIA_Supports_RemoteDbg|     // Supports remote debugging
    PIA_Enable_Stub|            // Allow DOS Stub
    PIA_Supports_ENC|           // Supports Edit & Continue
    PIA_Enable_AllDebugType,    // Allow Debug Types
    NoUseMFC,                   // Default is not using MFC
    _T("")                  // Default output directories
};

// implementation

// pre-installed components
#include "optnbsc.h"
#include "optnrc.h"
#include "optnmtl.h"
#include "optnlib.h"

// derive the linker options by adding in 'common part' + 'config. part' + 'win32 libraries'
void VPROJDeriveDefaultWin32LinkOptionsX86(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_LINK_X86_COMMON, fDebug ? IDS_WIN32_LINK_DBG : IDS_WIN32_LINK_REL, nIDOption);

    CString strXtraLibs;
    BOOL bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS_CORE);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;

    bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;

    bOK = strXtraLibs.LoadString(IDS_OLE2_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
}

void VPROJDeriveDefaultRcOptionsX86(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_RC_COMMON, fDebug ? IDS_WIN32_RC_DBG : IDS_WIN32_RC_REL, nIDOption);
}

void VPROJDeriveDefaultBscMakeOptionsX86(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_BSCMAKE_COMMON, fDebug ? IDS_WIN32_BSCMAKE_DBG : IDS_WIN32_BSCMAKE_REL, nIDOption);
}

void VPROJDeriveDefaultLibOptionsX86(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    // the library manager options have no common, debug or release parts!
    BOOL bOK = strOption.LoadString(nIDOption);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
}

BOOL CProjTypeWin32Exe::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF linker
            case BCID_Tool_Linker_x86:
                VPROJDeriveDefaultWin32LinkOptionsX86(strOption, fDebug, IDS_WIN32EXE_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeGeneric::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    strOption = "";
    return TRUE;
}

BOOL CProjTypeWin32Dll::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF linker
            case BCID_Tool_Linker_x86:
                VPROJDeriveDefaultWin32LinkOptionsX86(strOption, fDebug, IDS_WIN32DLL_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32Con::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF linker
            case BCID_Tool_Linker_x86:
                VPROJDeriveDefaultWin32LinkOptionsX86(strOption, fDebug, IDS_WIN32CON_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric ) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32Lib::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        /*switch*/ (PkgCmpIdFromBscId(bsc_id));
        {
            /*default:*/
                VSASSERT(FALSE, "need default options for one of our own tools!");
                /*break;*/
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsX86(strOption, fDebug, UINT(-1));
                break;

            // the COFF library manager
            case BCID_Tool_Lib:
                VPROJDeriveDefaultLibOptionsX86(strOption, fDebug, IDS_WIN32LIB_LINK);
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsX86(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeWin32Exe::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_x86);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeGeneric::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32Dll::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_x86);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32Con::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_x86);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeWin32Lib::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_Lib);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);

    return TRUE;    // success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platXbox.cpp ===
//
// Intelx86 Platform
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"     // our standard AFX include
#pragma hdrstop
#include "platXbox.h"    // our local header file

IMPLEMENT_DYNAMIC(CProjTypeXboxExe, CProjType)
IMPLEMENT_DYNAMIC(CProjTypeXboxLib, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// declare our platform
//
// *** DO NOT TRANSLATE (LOCALIZE) THE PLATFORM STRINGS HERE ***

PlatformInfo g_PlatformInfoXbox =
{
    _T("Xbox"),          // Official platform name -- DO NOT LOCALIZE!
    xbox,                   // Unique ID
    IDS_XBOX_PLATFORM,      // Localizable description string
    IDS_XBOX_PLATFORM_SHORT,// Abbreviated localizable description string
    _T("res"),                  // RC extension
//    PIA_Primary_Platform |      // Primary platform
    PIA_Allow_WorkingDir |      // Can use a working dir. for debugging
    PIA_Supports_IncCplr |      // Supports inc. cplr.
    PIA_Supports_RTTI |         // Supports RTTI
    PIA_Supports_IncLink|       // Supports ilink
    PIA_Supports_MinBuild |     // Supports minimum build
    PIA_Enable_Language |       // Enable language for RC option
//  PIA_Allow_MFCinDLL |        // Supports use of mfc in a dll
//  PIA_Allow_ODBC |            // Allow use of mfc ODBC
//  PIA_Allow_ProgArgs |        // Executable can use program arguments for Debug etc.
    PIA_Supports_RemoteDbg|     // Supports remote debugging
//  PIA_Enable_Stub|            // Allow DOS Stub
    PIA_Supports_ENC|           // Supports Edit & Continue
    PIA_Enable_AllDebugType,    // Allow Debug Types
    NoUseMFC,                   // Default is not using MFC
    _T("")                  // Default output directories
};

// implementation

// pre-installed components
#include "optnbsc.h"
#include "optnrc.h"
#include "optnmtl.h"
#include "optnlib.h"

// derive the linker options by adding in 'common part' + 'config. part' + 'win32 libraries'
void VPROJDeriveDefaultWin32LinkOptionsXbox(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_LINK_X86_COMMON, fDebug ? IDS_WIN32_LINK_DBG : IDS_WIN32_LINK_REL, nIDOption);

    CString strXtraLibs;
    BOOL bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS_CORE);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;

    bOK = strXtraLibs.LoadString(IDS_WIN32_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;

    bOK = strXtraLibs.LoadString(IDS_OLE2_LIBS);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    strOption += ' '; strOption += strXtraLibs;
}

void VPROJDeriveDefaultRcOptionsXbox(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_RC_COMMON, fDebug ? IDS_WIN32_RC_DBG : IDS_WIN32_RC_REL, nIDOption);
}

void VPROJDeriveDefaultBscMakeOptionsXbox(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    VPROJDeriveDefaultOptions(strOption, IDS_WIN32_BSCMAKE_COMMON, fDebug ? IDS_WIN32_BSCMAKE_DBG : IDS_WIN32_BSCMAKE_REL, nIDOption);
}

void VPROJDeriveDefaultLibOptionsXbox(CString & strOption, BOOL fDebug, UINT nIDOption)
{
    // the library manager options have no common, debug or release parts!
    BOOL bOK = strOption.LoadString(nIDOption);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
}

BOOL CProjTypeXboxExe::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the COFF linker
            case BCID_Tool_Linker_x86:
                VPROJDeriveDefaultWin32LinkOptionsXbox(strOption, fDebug, IDS_WIN32EXE_LINK);
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsXbox(strOption, fDebug, UINT(-1));
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsXbox(strOption, fDebug, UINT(-1));
                break;

            // MakeTypLib compiler
            case BCID_Tool_MkTypLib:
                VPROJDeriveDefaultOptions(strOption, IDS_WIN32_MTL_COMMON, fDebug ? IDS_WIN32_MTL_DBG : IDS_WIN32_MTL_REL, UINT(-1)) ;
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeXboxLib::GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption)
{
    CString strDebugMode, strReleaseMode;
    BOOL    fDebug;

    // init. our debug, release configs.
    BOOL bOK = strDebugMode.LoadString(IDS_DEBUG_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
    bOK = strReleaseMode.LoadString(IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

    fDebug = (strDebugMode == strMode);
    if (!fDebug && (strReleaseMode != strMode))
        return FALSE;   // no a known configuration

    // what type of tool is this?
    if (PackageIdFromBscId(bsc_id) == PackageIdFromBscId(CompId())) // our tool?
    {
        /*switch*/ (PkgCmpIdFromBscId(bsc_id));
        {
            /*default:*/
                VSASSERT(FALSE, "need default options for one of our own tools!");
                /*break;*/
        }
    }
    else if ( bsc_id && (PackageIdFromBscId(bsc_id) == idAddOnGeneric) ) // generic?
    {
        switch (PkgCmpIdFromBscId(bsc_id))
        {
            // the NT resource compiler
            case BCID_Tool_RcCompilerNT:
                VPROJDeriveDefaultRcOptionsXbox(strOption, fDebug, UINT(-1));
                break;

            // the COFF library manager
            case BCID_Tool_Lib:
                VPROJDeriveDefaultLibOptionsXbox(strOption, fDebug, IDS_WIN32LIB_LINK);
                break;

            // the browser database maker
            case BCID_Tool_BscMake:
                VPROJDeriveDefaultBscMakeOptionsXbox(strOption, fDebug, UINT(-1));
                break;

            default:
                VSASSERT(FALSE, "need default options for one of our own tools!");
                break;
        }
    }
    else
        // not a known tool
        return CProjType::GetDefaultToolOptions(bsc_id, strMode, strOption);

    return TRUE;
}

BOOL CProjTypeXboxExe::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnx86, BCID_Tool_Linker_x86);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);
    AddTool(szAddOnGeneric, BCID_Tool_MkTypLib);

    return TRUE;    // success
}

BOOL CProjTypeXboxLib::FInit()
{
    if (!CProjType::FInit())
        return FALSE;   // failed

    // Tools that we can use.
    AddTool(szAddOnGeneric, BCID_Tool_BscMake);
    AddTool(szAddOnGeneric, BCID_Tool_Lib);
    AddTool(szAddOnGeneric, BCID_Tool_RcCompilerNT);

    return TRUE;    // success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platmrcd.h ===
//
// Merced (RISC) Platform
//
// [matthewt]
//
						
#ifndef _INCLUDE_PLATFORM_MERCED_H
#define _INCLUDE_PLATFORM_MERCED_H

#include "merced.h"

// declare out platform
extern	PlatformInfo	g_PlatformInfoWin64MERCED;

// declare our project types
// declare our project types (FOR MERCED)
class CProjTypeWin64MERCEDExe : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin64MERCEDExe)

public:
	CProjTypeWin64MERCEDExe()
		: CProjType(szAddOnx86, BCID_ProjType_MercedExe, /* id */
					IDS_WIN32EXE_PROJTYPE, CProjType::application, /* props */
					szAddOnx86, BCID_Platform_Merced) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageExe | SubsystemWindows | TargetIsDebugable;}
};

class CProjTypeWin64MERCEDDll : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin64MERCEDDll)

public:
	CProjTypeWin64MERCEDDll()
		: CProjType(szAddOnx86, BCID_ProjType_MercedDll, /* id */
					IDS_WIN32DLL_PROJTYPE, CProjType::dynamiclib, /* props */
					szAddOnx86, BCID_Platform_Merced) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageDLL | TargetIsDebugable;}
};

class CProjTypeWin64MERCEDCon : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin64MERCEDCon)

public:
	CProjTypeWin64MERCEDCon()
		: CProjType(szAddOnx86, BCID_ProjType_MercedCon, /* id */
					IDS_WIN32CON_PROJTYPE, CProjType::consoleapp, /* props */
					szAddOnx86, BCID_Platform_Merced) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageExe | SubsystemConsole | TargetIsDebugable;}
	UINT GetUseMFCDefault() {return NoUseMFC;}
};

class CProjTypeWin64MERCEDLib : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin64MERCEDLib)

public:
	CProjTypeWin64MERCEDLib()
		: CProjType(szAddOnx86, BCID_ProjType_MercedLib, /* id */
					IDS_WIN32LIB_PROJTYPE, CProjType::staticlib, /* props */
					szAddOnx86, BCID_Platform_Merced) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD blc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {return ImageStaticLib | TargetIsDebugable;}
};

#endif // _INCLUDE_PLATFORM_ALF_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\prjconfg.h ===
//
// CProjComponentMgr, CProjType
//
// Project component management, ie. target types, tools and option tables
//
// [matthewt]
//

#ifndef _INCLUDE_PRJCONFG_H
#define _INCLUDE_PRJCONFG_H

#include "Vcprojcnvt2.h"

//
// Resource ID ranges for each of the tool packages.
//
// In the absence of a resource loading mechanism that understands the
// context (package) that is to be loaded we need to have unique resource ids
// for those resources belonging to each package. Build add_ons therefore
// have been allocated the following ranges. Additional add_ons should add a new
// range here,
//
// BASE - 0x3000 (12288), UPPER - 0x3fff (16383)
//
// Intelx86	0x3000
// Mac68k	0x3200
// Mips		0x3400
// Alpha	0x3600
// PowerMac	0x3800
// FORTRAN	0x3A00
// PowerPC	0x3B00

// declare our types used up-front
class CPlatform;			// platform (defined in 'prjconfg.h')
class CProjType;			// project type (defined in 'prjconfg.h')
class CProjItem;			// project item (defined in 'projitem.h')
class CBuildTool;			// build tool (defined in 'projtool.h')
class CTargetItem;
/*
R.I.P. for v4.0 with VBA?
class CCustomTool;			// custom build tool (defined in 'projtool.h')
*/
class CProject;				// project (defined in 'project.h')
class COptionHandler;		// tool option handler (defined in 'prjoptn.h')

// Helper function -- probably belongs in some new module PROJUTIL.CPP / PROJUTIL.H.
void GetNewOutputDirName(CProject * pProject, const CString & strNewConfig, CString & strResult);

// declare the global tool option engine (parsing & generation)
class COptionTable;
extern  COptionTable * g_pPrjoptengine;

// functions to munge/extract the project mode from the configuration
void DefaultConfig(CProject * pProject, const CString & strPlatformName, UINT nIDMode, CString & strConfig);

#define HPROJECT DWORD_PTR
#define HCONFIGURATION DWORD_PTR
#define HBLDFILE DWORD_PTR
#define HFILESET DWORD_PTR
#define HFOLDER DWORD_PTR

#define ACTIVE_PROJECT	(HPROJECT)NULL
#define ACTIVE_CONFIG	(HCONFIGURATION)NULL
#define ACTIVE_FILESET	(HFILESET)NULL

#define NO_PROJECT		(HPROJECT)NULL
#define NO_CONFIG		(HCONFIGURATION)NULL
#define NO_FILE			(HBLDFILE)NULL
#define NO_FOLDER		(HFOLDER)NULL

// Target attributes
typedef enum
{
	// Image Types:
	ImageStaticLib		= 0x1,
	ImageDLL			= 0x2,
	ImageExe			= 0x4,
	// Subsystems:
	SubsystemConsole	= 0x8,
	SubsystemWindows	= 0x10,
	// Can we debug the resulting target?
	TargetIsDebugable	= 0x20,
	// Is this an unknown target?
	TargetUnknown		= 0x40,
} TargetAttributes;

typedef enum
{
	unknown_projtype = 0,
	application      = 1,
	dynamiclib       = 2,
	consoleapp       = 3,
	staticlib        = 4,
	sharedlib        = 5,
	exttarget        = 6,
	quickwin         = 7,
	standardgraphics = 8,
} uniq_projtype;

// build system component registration

// component types
#define BLC_ERROR		0x0000
#define BLC_Platform	0x0001
#define BLC_Tool		0x0002
#define BLC_Scanner		0x0003
#define BLC_OptionHdlr	0x0004
#define BLC_TargetType	0x0005
#define BLC_CustomTool	0x0007
#define BLC_OleAddOn	0x0008

#define BLC_Start		BLC_Platform
#define BLC_End			BLC_OleAddOn

// mode of our tool options
#define MOB_Debug		0x1			// debug
#define MOB_Release		0x2			// release

// our CBldSysCmp class ... the base-class for all component manager objects
//
// provides:
// o storing/retrieving of component properties to the system registry 'Visual C++\Build System' key.
// (use REGISTRY_MAPS)

typedef struct
{
	enum {MapBegin, MapEnd, MapData, MapFData} regType;	// type of this registry entry
	UINT  nRegId;	// string resource ID for registry field
	UINT  nRegSubKeyId;	// string resource ID for sub-key
	const TCHAR *szRegField;	// string resource ID for registry field
	const TCHAR *szRegSubKey;	// string resource ID for sub-key
	DWORD dwType;			// type of data, eg. REG_SZ, REG_BINARY etc.
	const void * pvData;	// points to the data
	DWORD cbData;			// size of this data
} CRegistryMap;

// other registry entry type #defines for use by REGISTRY_ENTRY()
#define REG_STRING	(DWORD)(REG_NONE - REG_SZ)	// our own registry type for CStrings
#define REG_BOOL	(DWORD)REG_DWORD

#define NO_SUB_KEY NULL

#define DECLARE_REGISTRY_MAP() \
	static CRegistryMap m_registryMap[]; \
	virtual const CRegistryMap * GetRegistryMap() const {return &m_registryMap[0];}

#define BEGIN_REGISTRY_MAP(theClass, parentClass) \
	CRegistryMap theClass::m_registryMap[] = {\
	{CRegistryMap::MapBegin, 0, 0, NULL, NULL, NULL /* no type */, &parentClass::m_registryMap[0], 0},

#define BEGIN_REGISTRY_MAP_P(theClass) \
	CRegistryMap theClass::m_registryMap[] = {\
	{CRegistryMap::MapBegin, 0, 0, NULL, NULL, NULL /* no type */, NULL /* no base */, 0},

#define REGISTRY_DATA_ENTRY(regid, subkey, regstr, substr, t, var) \
	{CRegistryMap::MapData, regid, subkey, regstr, substr, t, &((theClass*)0)->var, sizeof(((theClass*)0)->var)},

#define REGISTRY_FAKE_DATA_ENTRY(regid, subkey, regstr, substr, t) \
	{CRegistryMap::MapFData, regid, subkey, regstr, substr, t, NULL, 0},

#define END_REGISTRY_MAP() \
	{CRegistryMap::MapEnd, 0, 0, NULL /* no type */, NULL}};

// helpers
LONG RegGetKey(HKEY, LPCTSTR, PHKEY, BOOL fCreate = TRUE);

class CBldrSection;
// callback for builder file 'sections'
// 'pbldsect' is the section data
// 'op' is the callback operation
// callback used for synchronous notification of read/write
typedef BOOL (*PfnSectionCallBack)(CBldrSection * pbldsect, UINT op);

class CBldrSection	// Non-standard COM.
{
public:
	CBldrSection(HPROJECT hBld = ACTIVE_PROJECT) {m_pfn = NULL; m_pch = NULL; m_cch = 0; m_dw = 0; m_hBld = hBld;}

	CString m_strName;			// section name
	
	TCHAR * m_pch;				// char. buffer
	size_t m_cch;				// size of buffer (not used for write)
	// o format of this data is each line zero-terminated with a double terminator
	//   signifying the end of the buffer 

	PfnSectionCallBack m_pfn;	// our callback (if NULL, assume async retrieval)
	DWORD m_dw;					// user-supplied word
	HPROJECT m_hBld;
};

// declare the global configuration manager
class CProjComponentMgr;
class  CBldSysCmp : public CSlob
{
	friend class CProjComponentMgr;

	DECLARE_DYNCREATE(CBldSysCmp)
	DECLARE_SLOBPROP_MAP()
	DECLARE_REGISTRY_MAP()

public:
	CBldSysCmp();

	// get/set the component's and related component's id
	__inline DWORD CompId() {return m_dwId;}
	__inline DWORD RelatedCompId() {return m_dwRelatedId;}

	void SetId(DWORD dwId);
	void SetRelatedId(DWORD dwRelatedId);

	// retrieving of component properties to system registry
	//
	// this will ensure that the component info. is in the registry,
	// any changes in the information in the registry will be copyed to
	// the component
	virtual BOOL SynchronizeWithRegistry();

	virtual BOOL RegDataExists(const CRegistryMap *, HKEY, CString *, LPDWORD, LPDWORD);
 	virtual BOOL LoadRegData(const CRegistryMap *, HKEY, CString *, LPBYTE, DWORD);

	// returns TRUE if this is a fully supported component,
	// FALSE if it is a fake one for compatibility (ie. unknown tools etc.)
	virtual BOOL IsSupported() const { return TRUE; }

	// helpers
	BOOL RegGetDataKey(const CRegistryMap *, PHKEY, BOOL fCreate = TRUE);

	BOOL LoadRegData(UINT nRegId);

	// get our regular and 'UI' component name
	__inline const CString * GetName() const {return &m_strCompName;}

	// get component system registry 'parent' key
	__inline const CString * GetRegKeyName() const {return &g_strRegKey;}

	// get component system registry key
	const TCHAR * GetCompRegKeyName(BOOL fInclAppKey = TRUE);

	// map types (n.b. 32 is a hack, just a number greater than REG_* in winnt.h)
	__inline DWORD MapRegType(DWORD dwType) {return dwType < 32 ? dwType : (DWORD)REG_NONE - dwType;}

	// name of this comp.
	CString m_strCompName;

	// UI name of this comp.
	CString m_strUICompName;

protected:
	// retrieve the registry map entry for the entry with the id, 'nRegId'
	const CRegistryMap * GetRegMapEntry(UINT nRegId);

	// registry keys
	static const CString g_strRegKey;

	CString m_strCompRegKey;
	CString m_strFullCompRegKey;
	BOOL m_fCompRegKeyDirty;

	// id of this bld system component
	DWORD m_dwId;

	// id of the related bld system component
	DWORD m_dwRelatedId;
};

// our CProjComponentMgr class ... the  global project component manager

// generate a component id based on the package and component id (latter is unique to package only)
#define GenerateComponentId(idPackage, idComponent) ((idPackage << 16) | (idComponent & 0xffff))
#define PackageIdFromBscId(bsc_id) (bsc_id >> 16)
#define PkgCmpIdFromBscId(bsc_id) (bsc_id & 0xffff)

class  CProjComponentMgr : public CObject
{
public:
	// create project component manager
	CProjComponentMgr();
	~CProjComponentMgr();

	// initialise (ask packages to register their components)
	BOOL FInit(IVCProjConvert *pConverter);
	void IsInit(BOOL b){m_fInit=b;};
	BOOL IsInit(){return m_fInit;};
	BOOL m_fInit;
	CObList lstArngdPackages;

	// terminate
	void Term();
	void Clean();

	// build system component registration

	// generate package id using the package name
	WORD GenerateBldSysCompPackageId(const TCHAR * szPackageName);

	// package register component
	// pls. note that if no bsc_id passed in it is assumed the component
	// has pre-set it's id.
	BOOL RegisterBldSysComp(CBldSysCmp * pcomp, DWORD bsc_id = (DWORD)-1);

	// lookup a component
	__inline BOOL LookupBldSysComp(DWORD bsc_id, CBldSysCmp *& pcomp)
		{return m_mapBldSysCmps.Lookup(bsc_id, (void *&)pcomp);}

	// get a component type, returns 'BLC_ERROR' if not found
	DWORD BldSysCompType(DWORD bsc_id);
 	DWORD BldSysCompType(CBldSysCmp * pcomp);

	// utility functions
	BOOL GetProjTypefromProjItem(CProjItem * pprojitem, CProjType * & pprojtype);

	//
	// our platform management
	//
	void RegisterPlatform(CPlatform *);
	BOOL DeregisterPlatform(CPlatform *);

	int GetPlatformCount() { return (int)m_lstPlatforms.GetCount(); }
	int GetSupportedPlatformCount();

	const CVCPtrList *GetPlatforms() { return &m_lstPlatforms; }
	void InitPlatformEnum() { m_posPlatform = m_lstPlatforms.GetHeadPosition(); }
	BOOL NextPlatform(CPlatform * & pPlatform)
	{
		if (m_posPlatform == (VCPOSITION)NULL)
			return FALSE;
		pPlatform = (CPlatform *)m_lstPlatforms.GetNext(m_posPlatform);
		return TRUE;
	}

	BOOL LookupPlatformByUniqueId(UINT nUniqueId, CPlatform * & pPlatform);
	CPlatform * GetPrimaryPlatform(BOOL bAllowNonPrimary = TRUE);

	//
	// our project type management
	//
	void RegisterProjType(CProjType * pprojtype);
	BOOL DeregisterProjType(CProjType * pprojtype);

	__inline BOOL LookupProjTypeByName( const TCHAR * pszName, CProjType * & pprojtype)
		{return m_mapProjTypes.Lookup((const TCHAR *) pszName, (void *&)pprojtype);}
	BOOL LookupProjTypeByUIDescription( const TCHAR * pszUIDesc, CProjType * & pprojtype);

	BOOL LookupProjTypeByUniqueId( UINT nUniqueId, CProjType * & pprojtype);
	__inline void InitProjTypeEnum() {m_posProjType = m_lstProjTypes.GetHeadPosition();}
	__inline BOOL NextProjType(CProjType * & pprojtype)
	{
		if (m_posProjType == (VCPOSITION) NULL)	return FALSE;
		pprojtype = (CProjType *)m_lstProjTypes.GetNext(m_posProjType);
		return TRUE;
	}

	//
	// our build tool management
	//
	__inline void InitBuildToolEnum() {m_posTool = m_lstTools.GetHeadPosition();}
	__inline BOOL NextBuildTool(CBuildTool * & ptool)
	{
		if (m_posTool == (VCPOSITION) NULL)	return FALSE;
		ptool = (CBuildTool *)m_lstTools.GetNext(m_posTool);
		return TRUE;
	}

	// Find the tool whose prefix matches the pPrefix. nPrefixLen is the maximum
	// number of characters to match up to.  pprojitem can be used to retrieve
	// only the tools for the current configuration.
	CBuildTool * GetToolFromCodePrefix(CProjItem * pprojitem, const TCHAR *pPrefix, int nPrefixLen);

	//
	// our tool option management
	//
	__inline void InitOptHdlrEnum() {m_posOptHdlr = m_lstOptionHandlers.GetHeadPosition();}
	__inline BOOL NextOptHdlr(COptionHandler * & popthdlr)
	{
		if (m_posOptHdlr == (VCPOSITION) NULL)	return FALSE;
		popthdlr = (COptionHandler *)m_lstOptionHandlers.GetNext(m_posOptHdlr);
		return TRUE;
	}

	void RegisterOptionHandler(COptionHandler * popthdlr);
	BOOL DeregisterOptionHandler(COptionHandler * popthdlr);

	// given a property return the option handler
	// (cached for props belonging to same opt. hdlr)
	UINT m_nPropFirst, m_nPropLast;
	COptionHandler * m_popthdlrCache;
	COptionHandler * FindOptionHandler(UINT idProp);

	// given a property bag we'll set the defaults for the project mode
	// based on the original target type of the property bag
	__inline BOOL SetDefaultDebugToolOptions(CProject * pProject)
		{return SetDefaultToolOptions(MOB_Debug, pProject);}

	__inline BOOL SetDefaultReleaseToolOptions(CProject * pProject)
		{return SetDefaultToolOptions(MOB_Release, pProject);}

	//
	// our unknown project object management
	// ie. unknown option handlers, target types, platforms, tools
	//
	// on destruction of the proj. component manager these will be
	// destroyed as well -> ie. use this to remember objects to clean-up
	// at project facility shutdown time
	__inline void RegisterUnkProjObj(CObject * punkobj)
		{ASSERT_VALID(punkobj); m_lstUnkProjObjs.AddTail(punkobj);}
	__inline BOOL DeregisterUnkProjObj(CObject * punkobj)
		{return DeregisterComponent(m_lstUnkProjObjs, punkobj);}

	// information components might use, such as is MFC or ODBC installed?
	__inline BOOL MFCIsInstalled() {return m_fMFCInstalled;}
	__inline BOOL ODBCIsInstalled() {return m_fODBCInstalled;}

protected:
	BOOL SetDefaultToolOptions(DWORD mode, CProject * pProject);

private:
	// generic component removal
	BOOL DeregisterComponent(CVCPtrList & plst, CObject * ptr);

	// component registration
	CStringArray		m_rgstrAddOns;
	CVCMapDWordToPtr	m_mapBldSysCmps;
	DWORD				m_dwRegisterId;		// current related id. when asking add-ons to register comps.

	// CPlatform registry
	CMapStringToPtr	m_mapPlatforms;		// for quick-lookup -- HASHed on "official name"
	CVCPtrList		m_lstPlatforms;		// ordered list
	VCPOSITION		m_posPlatform;		// current pos for InitPlatformEnum() / NextPlatform()

	// CProjType registry (public)
	CMapStringToPtr	m_mapProjTypes;		// for quick-lookup -- HASH order!
	CVCPtrList		m_lstProjTypes;		// ordered list
	VCPOSITION		m_posProjType;		// current pos for InitProjTypeEnum() / NextProjType()

	// CBuildTool registry (public)
	VCPOSITION		m_posTool;
	CVCPtrList		m_lstTools;

	// COptionHandler registry (private)
	CVCPtrList		m_lstOptionHandlers;
	UINT			m_idOptPropBase;
	VCPOSITION		m_posOptHdlr;

	// unknown object registry
	CVCPtrList		m_lstUnkProjObjs;

	// information components might use
	BOOL			m_fODBCInstalled;	// ODBC Installed?
	BOOL			m_fMFCInstalled;	// MFC Installed?

	CBldrSection		m_bldsection;		// our custom tool builder file section

	// flags used during component registration
	BOOL			m_fRegPrimaryPlatform;
};

extern CProjComponentMgr *g_pPrjcompmgr;

// The CPlatform class embodies a target platform -- an operating system and
// a CPU (e.g., Macintosh (680x0), Win32 (80x86), Win32 (MIPS, ALPHA), etc.
//
// All CPlatform instances in the system are static (i.e., exist even in the
// absence of a project) and register themselves with the CProjComponentMgr.
//
// The ToolInfo struct contains specific information needed for some of the tools
// supported by the platform.
// NOTE:
// It would have been nice if we can put this information in the appropriate
// OptionHandler. Unfortunately, for instance, RC name is defined in the
// Common Linker Option Handler but Mac and Intel have different default
// extensions. Until the OptionHandler supports inheritance, we have to
// settle w/ this ToolInfo struct soluntion.
//
// The PlatformInfo class is used to initialize (construct) a CPlatform object.
//
// Exactly one CPlatform object should be the "primary target platform" (set the
// bPrimaryPlatform field in the PlatformInfo struct to TRUE).  If, when checking
// the registry to find out which platforms are installed, we don't find ANY
// platforms, we will ensure that the "primary target platform" is installed
// anyway (and write information to the registry to indicate this).  Note that
// we will do this only if NO installed platforms are found, so the primary target
// platform is "automatically" installed only if no others are found.

// Bit fields for the Platform attributes.
// This is to hold information similar to PlatformInfo that would be
// wasteful to represent as a new method of CPlatform, ie. information
// of a similar type BOOL can be represented as a bit field value.

#define PIA_Primary_Platform	0x0001	// Is this the primary platform? ie. default platform
#define PIA_Supports_IncLink	0x0002	// Supports an incremental linker?
#define PIA_Allow_WorkingDir	0x0004	// Allow use of a working directory for 'Debug Options'
#define PIA_Enable_Language		0x0008  // Enable Language option for RC
#define PIA_Allow_MFCinDLL		0x0010	// Allow use of mfc in a dll
#define PIA_Supports_RemoteDbg	0x0020	// Supports remote debugging?
#define PIA_Allow_ODBC			0x0040	// Allow use of mfc ODBC
#define PIA_Allow_ProgArgs		0x0080	// Executable can use program arguments for Debug etc.
#define PIA_Enable_Stub			0x0100	// Allow dos stub
#define PIA_Enable_AllDebugType	0x0200	// Enable all debug options (otherwise enable only MS option
#define PIA_Supports_IncCplr	0x0400	// Supports an incremental compiler?
#define PIA_Supports_RTTI		0x0800	// C++ language implementation supports RTTI?
#define PIA_Supports_MinBuild	0x1000	// Support minimum build compiler
#define PIA_Supports_ENC		0x2000	// Support edit & continue

struct ToolInfo
{
	CString		strRCExtension;		// RC extension for specific platform (ie: .res or .rsc)
};

struct PlatformInfo
{
	TCHAR *		szName;				// "Official" name of platform
	UINT		nUniqueId;			// Platform identifier (uniq_platform)
	UINT		nIDUIDesc;			// String ID of UI description of platform
	UINT		nIDUIShortDesc;		// String ID of abbreviated UI description
	TCHAR *		szRCExtension;		// RC extension for specific platform (ie: .res or .rsc)

	DWORD		dwPlatformAttrib;	// The boolean attributes
	UINT		nUseMFCDefault;		// Default use of MFC
	TCHAR *		szOutDirPrefix;		// Default directory prefix
									// (if == NULL then first three chars of UI desc. used)
};


class  CPlatform : public CBldSysCmp
{
	DECLARE_DYNCREATE(CPlatform)
 	DECLARE_REGISTRY_MAP()

private:
	BOOL			m_bSupported;		// is this platform actually supported?

	UINT			m_nUniqueId;		// Unique identifier from uniq_platform (0-255)
	UINT			m_nIDUIDesc;		// String ID of UI description string
	UINT			m_nIDUIShortDesc;	// String ID of abbreviated UI description
										// string (for loading later)

	CString			m_strUIShortDesc;	// Abbreviated description for UI purposes

	ToolInfo		m_rgToolInfo;		// Tool Info structure

	DWORD			m_dwAttributes;		// Boolean attributes
	UINT			m_nUseMFCDefault;	// Default use of MFC

	CString			m_strDefOutDirPrefix;	// Default output directory prefix
	BOOL			m_bBuildable;

public:
	CPlatform() {};
	CPlatform(PlatformInfo *);
	CPlatform(const _TCHAR * lpszName, UINT nUniqueId = unknown_platform); //
	virtual ~CPlatform();

	// from -> CBldSysCmp
	virtual BOOL RegDataExists(const CRegistryMap *, HKEY, CString *, LPDWORD, LPDWORD);
 	virtual BOOL LoadRegData(const CRegistryMap *, HKEY, CString *, LPBYTE, DWORD);
	virtual BOOL IsSupported() const { return m_bSupported; }
		// Returns TRUE if this is a fully supported platform,
		// FALSE if it is a fake one for compatibility
	// <- CBldSysCmp

	__inline BOOL IsPrimaryPlatform() const { return (m_dwAttributes & PIA_Primary_Platform) != 0; }
		// Returns TRUE if this is the "primary" platform (see notes above),
		// FALSE if not.

	__inline void SetBuildable(BOOL bCan) { m_bBuildable = bCan; }
	BOOL GetBuildable() { return m_bBuildable; }
		// Some "supported" paltforms may not be licensed for use.

	__inline const ToolInfo * GetToolInfo() const { return &m_rgToolInfo; }
		// returns a pointer to Tool Information that is specific to
		// the platform

	__inline DWORD GetAttributes() const { return m_dwAttributes; }

	BOOL SupportsODBC() const;

	UINT GetUseMFCDefault();
		// returns the default use of MFC for this platform

	const CString * GetDefOutDirPrefix() const { return &m_strDefOutDirPrefix; }

		// P_ComponentName
		//
		// Returns the "official" name of the platform.  This name is
		// used when:
		//
		//		- writing to the .MAK file
		//		- writing to the registry
		//
		// It is very important that this "official" name NOT be localized;
		// otherwise, localized versions lose compatibility with other .MAK
		// files.  This "official" name should therefore NOT be placed in
		// the .RC file.
		//
		// The form of this name is:
		//
		// "<operating_system> (<cpu>)"
		//
		// For example, "Macintosh (680x0)", "Win32 (80x86)", etc.

	UINT GetUniqueId() const { return (m_nUniqueId & 255); }
		// Returns the unique identifier (0-255) of this platform (see the
		// uniq_platform enum).

	const CString * GetUIDescription() const { return (m_nIDUIDesc) ? &m_strUICompName : &m_strCompName; }
		// Returns the name of the platform as it is represented in the UI
		// (for example, in dialogs).  This string *SHOULD* be placed in
		// the .RC file so it can be localized.  Needless to say, you should
		// be careful not to use this string instead of the "official" string
		// (GetName()).

	BOOL FInit();
		// Initialize this object -- specifically, load strings (which we
		// can't do at construction time since we don't have an instance
		// handle at that time).
};

// Our CProjType class ... contains information specific to a particular type of project,
// ie. project name, type of 'target generating' tool, tool option defaults etc.
class  CProjType : public CBldSysCmp
{
	DECLARE_DYNCREATE(CProjType)

public:
	CProjType() {}
	CProjType(const TCHAR * szPkg, WORD id,
			  UINT nIDType, UINT nUniqTypeId,
			  const TCHAR * szPkgPlatform, WORD idPlatform);
	CProjType(const TCHAR * szPkg, WORD id,
			  UINT nIDType, UINT nUniqTypeId,
			  DWORD bsc_id);
	CProjType(const _TCHAR * lpszType, UINT nUniqTypeId, CPlatform * pPlatform);
	virtual ~CProjType();

	// Warning: these enums are defined in order to maintain projtype
	// compatibility between different drops and versions of the product
	// While you can change the names of these enums, the implementations
	// (could be #defines), or even projtype names, you must not change
	// the order or value of these values and their meaning.
	// Also, how they are packed into an int (type in low byte, platform
	// in 2nd byte), cannot be changed without breaking makefile compatibility.
	// new types can be added at the end, or you can use the unknown type.

	enum uniq_type
	{
		unknown_projtype = 0,
		application = 1,
		dynamiclib = 2,
		consoleapp = 3,
		staticlib = 4,
		sharedlib = 5,
		exttarget = 6,
		quickwin = 7,
		standardgraphics = 8,
		generic = 10,
	 };

	static const _TCHAR * TypeNameFromId[11];

	// CBldSysComp related methods
	// ***************************

	// initialise
	virtual BOOL 	FInit();
	virtual int 	GetAttributes () { VSASSERT(FALSE, "GetAttributes must be overridden"); return 0; }

	// Platform x ProjType Methods
	// ***************************

	static 	CString 		MakeNameFromPlatformAndType(const CString & platform, const CString & type);
	static 	CString 		MakeNameFromPlatformAndType(const _TCHAR * platform, const _TCHAR * type);

	const CString * GetUIDescription() const { return &m_strUICompName; }
	UINT 			GetUniqueId() const { return GetUniqueTypeId() | (GetUniquePlatformId() << 8); }


	// Platform Related Methods
	// ************************

	virtual CPlatform * 	GetPlatform() const { return m_pPlatform; }
	virtual BOOL 				IsSupported() const { return m_pPlatform->IsSupported(); }

	const CString *		GetPlatformName() const { return m_pPlatform->GetName(); }
	const CString * 	GetPlatformUIDescription() const { return m_pPlatform->GetUIDescription(); }
	UINT 				GetUniquePlatformId() const { return (m_pPlatform->GetUniqueId()); }

	// Unique Type Related Methods
	// ***************************

 	// return the name of the type of target for this target type, eg. 'Application'
	virtual const CString * GetTypeName() { return &m_strType; }

	UINT 			GetUniqueTypeId() const { return (m_nUniqueTypeId & 255); }

	// Tools List Related Methods
	// **************************

	// create the list of tools we use
	virtual CVCPtrList *GetToolsList() { return &m_ToolsList; }

	void 		ClearUnknownTools();
	// Find the tool whose prefix matches the pPrefix. nPrefixLen is the maximum number
	// of characters to match up to.
	// pprojitem is used to retrieve the tools for the current configuration.
	CBuildTool * GetToolFromCodePrefix(const TCHAR *pPrefix, int nPrefixLen);
	// add a tool into our list of tool's
	void 		AddTool(const TCHAR * szPckg, WORD idTool);
	void 		AddTool(WORD pckg, WORD idTool);
	void 		AddTool(CBuildTool * pTool);

	// Settings Related Methods
	// ************************

	// default tool options for the target type
	virtual BOOL 	GetDefaultToolOptions(DWORD /*bsc_id*/, const CString & /*strMode*/, CString & /*strOption*/)
						{return FALSE;}	// FUTURE: ask the tool for the default options
	// default project level (i.e. target) options for the target type
	virtual BOOL 	SetDefaultDebugTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC);
	virtual BOOL 	SetDefaultReleaseTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC);
	// returns the default use of MFC for this target type (returns platform default use)
	virtual UINT 	GetUseMFCDefault() { return m_pPlatform->GetUseMFCDefault(); }
	//	Ensure that the tool will build an the project item (debug or release config. mode)
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	// FUTURE: Use wizards to do this in v4.0?
	virtual void 	PerformSettingsWizard(CProjItem * pItem, BOOL fUsingMFC);
	

protected:
	CVCPtrList m_ToolsList;	// List of tools that can be used with us. Source tools are at the front.
							// Schmooze tools are in the back in the order in which they should be
							// invoked during build.
	UINT	m_nIDType;		// string resource ID for target type name
	CString	m_strType;		// our target type name
	CString m_strUIType;
	CPlatform * m_pPlatform;

private:
	UINT	m_nUniqueTypeId; // Unique identifier (see uniq_type enum)
};

class CProjTypeUnknown : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeUnknown)
public:
	CProjTypeUnknown(const _TCHAR * lpszType, UINT nUniqTypeId, CPlatform * pPlatform)
		: CProjType(lpszType, nUniqTypeId, pPlatform) {}

	~CProjTypeUnknown();

	// create the list of tools we use
	BOOL FInit();

	// from -> CBldSysCmp
	BOOL IsSupported() const { return FALSE; }
	// <- CBldSysCmp

	BOOL GetDefaultToolOptions(DWORD, const CString & , CString & ) { return FALSE; }
	int GetAttributes () {return TargetUnknown;}
};

// helper function used to derive tool options that show common part
void  VPROJDeriveDefaultOptions(CString & strOption, UINT nIDCommon, UINT nIDMode, UINT nIDOption);

#endif // _INCLUDE_PRJCONFG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platx86.h ===
//
// Intelx86 Platform
//
// [matthewt]
//
						
#ifndef _INCLUDE_PLATFORM_X86_H
#define _INCLUDE_PLATFORM_X86_H

// declare out platform
extern	PlatformInfo	g_PlatformInfoWin32x86;

// declare our project types
class CProjTypeWin32Exe : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32Exe)

public:
	CProjTypeWin32Exe()
		: CProjType(szAddOnx86, BCID_ProjType_x86Exe, /* id */
					IDS_WIN32EXE_PROJTYPE, CProjType::application, /* props */
					szAddOnx86, BCID_Platform_x86) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageExe | SubsystemWindows | TargetIsDebugable; }
};

// declare our project types
class CProjTypeGeneric : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeGeneric)

public:
	CProjTypeGeneric()
		: CProjType(szAddOnx86, BCID_ProjType_Generic, /* id */
					IDS_GENERIC_PROJTYPE, CProjType::generic, /* props */
					szAddOnx86, BCID_Platform_x86) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();
	int GetAttributes () {  return SubsystemWindows | TargetIsDebugable; }
	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	

};

class CProjTypeWin32Dll : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32Dll)

public:
	CProjTypeWin32Dll()
		: CProjType(szAddOnx86, BCID_ProjType_x86Dll, /* id */
					IDS_WIN32DLL_PROJTYPE, CProjType::dynamiclib, /* props */
 					szAddOnx86, BCID_Platform_x86) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageDLL | TargetIsDebugable; }
};

class CProjTypeWin32Con : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32Con)

public:
	CProjTypeWin32Con()
 		: CProjType(szAddOnx86, BCID_ProjType_x86Con, /* id */
					IDS_WIN32CON_PROJTYPE, CProjType::consoleapp, /* props */
 					szAddOnx86, BCID_Platform_x86) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageExe | SubsystemConsole | TargetIsDebugable; }
	UINT GetUseMFCDefault() { return NoUseMFC; }
};

class CProjTypeWin32Lib : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeWin32Lib)

public:
	CProjTypeWin32Lib()
		: CProjType(szAddOnx86, BCID_ProjType_x86Lib, /* id */
					IDS_WIN32LIB_PROJTYPE, CProjType::staticlib, /* props */
  					szAddOnx86, BCID_Platform_x86) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageStaticLib | TargetIsDebugable; }
};

#endif // _INCLUDE_PLATFORM_X86_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\platXbox.h ===
//
// Xbox Platform
//
//
						
#pragma once

#include "xbox.h"

// declare out platform
extern	PlatformInfo	g_PlatformInfoXbox;

// declare our project types
class CProjTypeXboxExe : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeXboxExe)

public:
	CProjTypeXboxExe()
		: CProjType(szAddOnx86, BCID_ProjType_XboxExe, /* id */
					IDS_XBOXEXE_PROJTYPE, CProjType::application, /* props */
					szAddOnx86, BCID_Platform_Xbox) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageExe | SubsystemWindows | TargetIsDebugable; }
};

class CProjTypeXboxLib : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeXboxLib)

public:
	CProjTypeXboxLib()
		: CProjType(szAddOnx86, BCID_ProjType_XboxLib, /* id */
					IDS_XBOXLIB_PROJTYPE, CProjType::staticlib, /* props */
  					szAddOnx86, BCID_Platform_Xbox) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	BOOL GetDefaultToolOptions(DWORD bsc_id, const CString & strMode, CString & strOption);	
	int GetAttributes () {  return ImageStaticLib | TargetIsDebugable; }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\prjoptn.h ===
//
// COptionTable
//
// Option parsing and re-generation using property bag values.
//
// [matthewt]
//				   

#ifndef _INCLUDE_OPTIONTBL_H										
#define _INCLUDE_OPTIONTBL_H   

class COptionHandler;

// highly efficient manipulation of option string lists
// o uses map for quick check to see if exists
// o uses low-level mem. copy and compare.
// o CProjItem string list prop. aware

// are we the add or subtract component of a pseudo string list prop?
#define ListStr_AddPart(prop) (prop + 1)
#define ListStr_SubPart(prop) (prop + 2)

// NOTE: no duplicates are allowed in the option list

typedef struct tagOptEl {
	BYTE cref;		// ref. count
	int cch;		// # of chars. in pch (incl. '\0')
	TCHAR pch[1];	// space for single terminator
} OptEl;

class  COptionList : public CObject
{
public:
	// ConstrucTORs
	COptionList(TCHAR chJoin = _T(','), BOOL fUseDefJoins = TRUE, BOOL fAllowDupes = FALSE)
		{m_cchStr = 0;m_bAllowDuplicates = fAllowDupes; SetJoinUsage(chJoin, fUseDefJoins);}

	COptionList(const TCHAR * pch, TCHAR chJoin = _T(','), BOOL fUseDefJoins = TRUE, BOOL fAllowDupes = FALSE)
		{m_cchStr = 0;m_bAllowDuplicates = fAllowDupes; SetJoinUsage(chJoin, fUseDefJoins); SetString(pch);}

	__inline void SetJoinUsage(TCHAR chJoin = _T(','), BOOL fUseDefJoins = TRUE)
		{m_strJoin = (CString)chJoin + (fUseDefJoins ? _TEXT(",;\t") : _TEXT(""));}

	// DestrucTOR
	virtual ~COptionList()
		{Empty();}

	void Empty();										// empty
	void GetString(CString & str);						// conversion
	void SetString(const TCHAR * pch);					// conversion
	__inline const COptionList & operator=(COptionList & optlst)
		{Empty(); Append(optlst); return *this;}		// assignment
	void Append(const TCHAR * pch, int cch);			// element append
	void Append(COptionList & optlst);					// list append
	BOOL Subtract(const TCHAR * pch);					// element subtraction (returns FALSE if it didn't exist)
	BOOL Subtract(COptionList & optlst);				// list subtraction (returns FALSE if none existed)
	void Common(COptionList & optlst);					// retrieve common part
	__inline BOOL Exists(const TCHAR * pch)				// existance?
		{VCPOSITION posOurWord; return m_bAllowDuplicates? FALSE : m_mapStrToPtr.Lookup(pch, (void *&)posOurWord);}

	// enumeration
	__inline VCPOSITION GetHeadPosition()
		{return m_lstStr.GetHeadPosition();}
	__inline TCHAR * GetNext(VCPOSITION & pos)
		{return ((OptEl *)m_lstStr.GetNext(pos))->pch;}
	__inline int GetCount()
		{return (int)m_lstStr.GetCount();}

	// form the component parts from 'pch' based on 'this'.
	void Components(const TCHAR * pch, COptionList & optlstAdd, COptionList &optlstSub);

protected:
	// addition/deletion of elements using ref. counting
	void Add(OptEl * poptel);
	BOOL Delete(OptEl * poptel, VCPOSITION posToDelete = (VCPOSITION)NULL);	// if VCPOSITION known pls. use

	CString m_strJoin;					// our join chars
	CMapStringToPtr	m_mapStrToPtr;		// our hash lookup
	CVCPtrList m_lstStr;				// our actual list
	int m_cchStr;						// total length of string (bytes, incl. join char. seps.)
	BOOL m_bAllowDuplicates;
};

// some static buffer sizes
#define MAX_OPT_ARGS	3		// max. of two args. per option

// special IDOPTs that refer to the collection of unknown options
// and unknown strings repsectively, these may be placed in the
// option table 
// these are reserved, start your own IDOPTs from IDOPT_BASE
#define IDOPT_UNKNOWN_OPTION		(UINT)0
#define IDOPT_UNKNOWN_STRING		(UINT)1
#define IDOPT_DERIVED_OPTHDLR		(UINT)2
#define IDOPT_BASE					(UINT)3

// our tool option tables
#define OLD_OPTION_HANDLER(tool) COptHdlr##tool

// I'd like to allocate chunks of memory to CString's internal buffer so that
// a character append will be inexpensive (the generation of an option string does
// this a lot!).
#define OPTSTR_ALLOC_CHUNK	64	// 64 bytes at a time (N.B. must be a power of 2)
#define OPTSTR_ALLOC_EXPON	6	// 64 == 2 ^ 6

__inline void AdjustBuffer(CString & str)
{
	register unsigned int cch = (unsigned int)str.GetLength(); // # chars (will be zero, for initial alloc.)
	
	// are we at a length boundary?
	if ((cch & (OPTSTR_ALLOC_CHUNK-1)) == 0)	// check for no remainder .. can do logical AND if power of 2
	{
		// allocate a new chunk
		(void) str.GetBuffer((int)OPTSTR_ALLOC_CHUNK * ((cch >> OPTSTR_ALLOC_EXPON) + 1));	// set buffer length
		(void) str.ReleaseBuffer(cch);				// set data length, and terminate
	}
}
 
// what type is the option?
typedef enum {single, multiple} OptType;

// what sub-type is the option prop?
typedef enum {boolST, intST, hexST, octST, strST, pathST, dirST} SUBTYPE;

class CDefOptionProp : public CObject
{
public:
	CDefOptionProp() { m_pprop = NULL; }
	~CDefOptionProp() { if (m_pprop != NULL) CProp::DeleteCProp(m_pprop); }

	CDefOptionProp(WORD idProp, int n, SUBTYPE st = intST, OptType ot = single);

	CDefOptionProp(WORD idProp, const char * sz, SUBTYPE st = strST, OptType ot = single);

	CProp *	m_pprop;
	OptType m_opttype;
	SUBTYPE subtypeprop;
};

// our def'n of an option
struct COptStr
{
	UINT			idOption;
	const char *	szOption;
	UINT			rgidArg[MAX_OPT_ARGS];
	OptType			type;
};

// definition of the COptionLookup class
class  COptionLookup : public CObject
{
public:
	~COptionLookup();

	// perform init. now
	BOOL FInit(COptStr *);

	// lookup the option based on ID
	__inline COptStr * Lookup(UINT nID);

	// lookup the option based on first char.
	__inline COptStr * LookupFirst(unsigned char ch, BOOL fCaseSensitive = TRUE);
	__inline COptStr * LookupNext(INT_PTR cchLead);

private:
	// used for lookup 'based on ID'
	UINT		m_idLowest;
	CVCPtrArray	m_ptrIDArray;

	// used for lookup 'based on first char.
	unsigned char	m_chLookup;
	UINT			m_ioptstr;
	CVCPtrArray		m_ptrChArray;
	CVCMapWordToPtr	m_mapChToPtr;

};

// used to optimize lookups for parsing and generation

typedef struct {
	COptStr *	poptstr;
	UINT		ioptstr;
} CLookupEntry;

// I'd like GetAt to return the zero terminator if the index
// is >= GetLength()!
#define NewGetAt(str, ich) ((int)(ich) >= str.GetLength() ? '\0' : str.GetAt((int)(ich)))

// convertion of depth based ids
#define OHStripDepth(x) ((x) & 0x0fff)
#define OHAddDepth(x, d) ((x) | (0x1000 * (d)))
#define OHGetDepth(x) (((x) & 0xf000) / 0x1000)

#define _MAX_SLOB_STACK	5

class  COptionHandler : public CBldSysCmp
{
	DECLARE_DYNAMIC(COptionHandler);

public:
	COptionHandler(CBuildTool * pBuildTool, COptionHandler * popthdlrBase = (COptionHandler *)NULL);
	COptionHandler(const TCHAR * szPkg, WORD id,
				   const TCHAR * szPkgTool, WORD idTool,
				   const TCHAR * szPkgBase, WORD idBase);
	~COptionHandler();

	// called by ctor, dtors of derived classes
	virtual BOOL Initialise();

	// create our default option map
	virtual void CreateOptDefMap() {}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs (logical)
	virtual void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh = OBNone) {VSASSERT(FALSE, "GetSpecialLogicalOptProps must be overridden");}

	// retrieive our min. and max. option prop IDs (logical)
	virtual void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp) {VSASSERT(FALSE, "GetMinMaxLogicalOptProps must be overridden");}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs (actual)
	void GetSpecialOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh = OBNone);

	// case sensitive option string table?
	virtual const BOOL IsCaseSensitive() {VSASSERT(FALSE, "IsCaseSensitive must be overridden"); return TRUE;}

	// what CSlob do we (and all of our base option handlers) refer to ?
 	__inline void SetSlob(CSlob * pSlob, BOOL fRemember = TRUE)
	{
		COptionHandler * popthdlr = GetBaseOptionHandler();
		if (popthdlr != NULL)
			popthdlr->SetSlob(pSlob, fRemember);

		// fRemember if TRUE pushes old onto stack
		if (fRemember)
			m_stkOldSlobs[m_sStk++] = m_pSlob;

		VSASSERT(m_sStk <= 5, "stack size too big");
		m_pSlob = pSlob;
	}

	__inline CSlob* GetSlob() { return m_pSlob; }
	__inline void ResetSlob()
	{
		COptionHandler * popthdlr = GetBaseOptionHandler();
		if (popthdlr != NULL)
			popthdlr->ResetSlob();

		// make sure the SetSlob & ResetSlob calls are matched
		VSASSERT(m_sStk > 0, "Stack size not big enough");
		m_pSlob = m_stkOldSlobs[--m_sStk];
	}
	
	// retrieve our base option handler (if we have one, by default we don't)
	__inline COptionHandler * GetBaseOptionHandler()	{return m_popthdlrBase;}

	// retrieve our root option handler
	__inline COptionHandler * GetRootOptionHandler()
	{
		COptionHandler * popthdlr = GetBaseOptionHandler();
		if (popthdlr == (COptionHandler *)NULL)
			return this;	// we are the root!
		return popthdlr->GetRootOptionHandler();
	}

	// retrieve our option string table
	virtual COptStr * GetOptionStringTable()	{VSASSERT(FALSE, "GetOptionStringTable must be overridden");return (COptStr *)NULL;}

	// get our option lookup
	virtual COptionLookup * GetOptionLookup()	{VSASSERT(FALSE, "GetOptionLookup must be overridden");return (COptionLookup *)NULL;}

	// set out 'base' prop value
	__inline void SetOptPropBase(UINT nPropBase) {m_nPropBase = nPropBase;}

	// get out 'actual' minimum and maximum props
	__inline void GetMinMaxOptProps(UINT & nIDMinProp, UINT & nIDMaxProp)
	{
		nIDMinProp = m_nPropBase; nIDMaxProp = m_nPropBase + GetOptPropRange() - 1;
	}


	// get our 'range' of props required
	__inline const UINT GetOptPropRange()
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return nPropMax - nPropMin + 1;
	}

	// get our 'actual' prop from logical prop
	__inline UINT MapLogical(UINT nOptProp)
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return m_nPropBase + OHStripDepth(nOptProp - nPropMin);
	}

	// get our 'logical' prop from actual prop
 	__inline UINT MapActual(UINT nOptProp)
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return OHAddDepth(nOptProp + nPropMin - m_nPropBase, m_cDepth);
	}

	__inline UINT GetDepth() {return m_cDepth;}

	__inline UINT FirstOptProp()
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return m_nPropBase + OHStripDepth(nPropMin);
	}

	__inline UINT LastOptProp()
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return m_nPropBase + OHStripDepth(nPropMax);
	}

	//
	// add default tool option properties to our map
	//
	void AddDefStrProp(UINT idProp, const char * sz, OptType ot = single);

	void AddDefPathProp(UINT idProp, const char * sz, OptType ot = single);

	void AddDefDirProp(UINT idProp, const char * sz, OptType ot = single);

	void AddDefIntProp(UINT idProp, int n, OptType ot = single);

	void AddDefBoolProp(UINT idProp, BOOL b, OptType ot = single);
																			
	void AddDefHexProp(UINT idProp, BOOL b, OptType ot = single);

	//
	// is this tool option property a default?
	//
	virtual BOOL IsDefaultIntProp(UINT idProp, int & nVal);
	virtual BOOL IsDefaultStringProp(UINT idProp, CString & strVal);
#define IsDefaultBoolProp(idProp, bVal)	IsDefaultIntProp((idProp), (int &)(bVal))
	 
	__inline virtual BOOL AlwaysShowDefault(UINT idProp)	{return FALSE;	/* never always show defaults*/}
	__inline virtual BOOL IsFakeProp(UINT idProp)			{return FALSE;	/* default is no */}

	// retrieve the main-type of this property
	__inline PROP_TYPE GetDefOptionType(UINT idProp)
	{
		CDefOptionProp * pdefopt = NULL;
		m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt);
		if (pdefopt)
			return pdefopt->m_pprop->m_nType;
		return null;
	}

	// retrieve the sub-type of this property
	// eg. subtypes for ints are bool, hex, int, oct
	__inline SUBTYPE GetDefOptionSubType(UINT idProp)
	{
		CDefOptionProp * pdefopt = NULL;
		m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt);
		if (pdefopt)
			return pdefopt->subtypeprop;
		return boolST;
	}

	// retrieve our default tool options from the map
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);

	// get the output directory string id, == -1 if none, that is used to fake (prepend to)
	// this property 'idProp'
	virtual UINT GetFakePathDirProp(UINT idProp) {return (UINT)-1;}

	// an option property in the table has changed
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal) { /* do nothing */ }
	virtual void OnOptionIntPropChange(UINT idProp, int nVal) { /* do nothing */ }

	// conversion of int, oct,hex values into a text form
	// FUTURE (matthewt): I'd like to put this elsewhere, but where?
	BOOL ConvertToStr(UINT idProp, int nVal, CString & strVal);
	BOOL ConvertFromStr(UINT idProp, const TCHAR * pchVal, int & nVal);

	__inline BOOL NeedsSubtypeConversion(UINT idProp)
	{
		CDefOptionProp * pdefopt;
		if (!m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt))	return FALSE;
		return (pdefopt->m_pprop->m_nType == integer);
	}

	__inline BOOL IsListStrProp(UINT idProp)
	{
		CDefOptionProp * pdefopt;
		if (!m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt))	return FALSE;
		return (pdefopt->m_opttype == multiple);
	}

	// joins prop strings together using the chJoin char
	// (only the current property bag will be searched and not the any of the container's (parent's))
	GPT GetListStrProp
	(
		CSlob * pSlob,
		UINT nIDProp,
		CString & strVal,
		BOOL fInherit = TRUE, BOOL fAnti = FALSE,
		char chJoin = ','
	);

 	// add or remove the string from the list
	void MungeListStrProp(UINT nIDProp, const CString & strVal, BOOL fAppend, char chJoin = ' ');

	void SetListStrProp
	(
		CSlob * pSlob,
		UINT nIDExtraProp,
		CString & strVal,
		BOOL fInherit = TRUE, BOOL fAnti = FALSE,
		char chJoin = ','
	);

	__inline void DirtyArg(UINT nAdjProp)
		{m_pdirtyProps->SetAt(nAdjProp, (BYTE)TRUE);}

	// is this property id valid with respect to its deps?
	__inline virtual BOOL CheckDepOK(UINT idProp) {return TRUE; /* always valid */}
	
	// Query whether this slob's faked property value may be different from what the
	// "default" would be for a random slob in the same container.
	// Option handlers can safely return TRUE for all fake properties.  Returning FALSE
	// is an optimization hint to the build engine, which may save time by avoiding
	// queries of the fake property value.
	__inline virtual BOOL SetsFakePropValue(UINT idProp)	{return TRUE;}
		
	// our associated CBuildTool
	CBuildTool * m_pAssociatedBuildTool;

	// our 'current' and 'old' CSlobs stack
	CSlob *	m_pSlob;
	CSlob * m_stkOldSlobs[_MAX_SLOB_STACK];
	unsigned short m_sStk;

protected:
	CVCMapWordToPtr	m_mapDefOptions;	// our default option value map							  
	UINT			m_nPropBase;		// base of our option prop range, determined at run-time
	UINT			m_cDepth;			// our option handler 'depth' == number of 'base' handlers 

private:
	COptionHandler *	m_popthdlrBase;		// our base option handler (if we have one)
	CVCByteArray *		m_pdirtyProps;		// dirty properties
	UINT *				m_pStrListPropIds;	// cache of string list props IDs 
	UINT				m_cStrListPropIds;	// # of entries in this cache
};

// our 'Unknown' option handler
// this will substitute for any other option handler and still
// parse and generate option strings
class COptHdlrUnknown : public COptionHandler
{
	DECLARE_DYNAMIC(COptHdlrUnknown);

public:
	COptHdlrUnknown(CBuildTool * pBuildTool);

	// create our default option map
	void CreateOptDefMap() {/* do nothing*/}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs
	void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour = OBNone);

	// retrieive our min. and max. option prop IDs
	void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp);

	// case sensitive (though this is ignored as we have ignored options'n' strings)
	__inline const BOOL IsCaseSensitive() {return TRUE;}

	// retrieve our option string table
	// (just has two entries, unknown option and unknown string)
	COptStr * GetOptionStringTable();

	// we don't have an option lookup
	__inline COptionLookup * GetOptionLookup()	{return (COptionLookup *)NULL;}
};

// definition of the COptHdlrMapper class
class  COptHdlrMapper
{
public:
	COptHdlrMapper();
	virtual ~COptHdlrMapper();

	//	Return the COptionHandler for this tool
	__inline COptionHandler * GetOptionHandler() {return m_popthdlr;}

	//  Set the COptionHandler for this tool
	__inline void SetOptionHandler(COptionHandler * popthdlr)
		{m_popthdlr = m_popthdlrMapper = popthdlr; m_cDepth = popthdlr->GetDepth();}

	void SetMapperOptionHandler(UINT cDepth);

	// mapping of logical->actual option handler props
	__inline UINT MapLogical(UINT idProp)
	{
		if (OHGetDepth(idProp) != m_cDepth)	SetMapperOptionHandler(OHGetDepth(idProp));
		return m_popthdlrMapper->MapLogical(idProp);
	}

protected:
	COptionHandler * m_popthdlr;		// the tool's option handler

private:
	COptionHandler * m_popthdlrMapper;	// our option handler used to map the props
	UINT m_cDepth;						// our current depth handler
};

// definition of the COptionTable class
class  COptionTable: public CObject
{
public:
	// initialise our option table with
	COptionTable();
	~COptionTable();

	// get/set the COptionHandler that we'll use
	__inline COptionHandler * GetOptionHandler() {return m_popthdlr;}
	__inline void SetOptionHandler(COptionHandler * popthdlr)
	{
 		m_popthdlr = popthdlr; if (m_pSlob && m_popthdlr) m_popthdlr->SetSlob(m_pSlob, FALSE);
	}

	// set the option handler given a package name and component pair
	COptionHandler * SetOptionHandler(const TCHAR * szPkg, WORD id);

	// get/set the CSlob that contains the property bag that contains the tool option values
	// the CSlob must be a CProjItem to support inheritance
	// (but this is not required if inheritance is not wanted)
	__inline CSlob * GetPropertyBag() {return m_pSlob;} 
	__inline void SetPropertyBag(CSlob * pSlob)
	{
 		VSASSERT(pSlob, "Cannot set property bag on NULL slob"); m_pSlob = pSlob; if (m_popthdlr) m_popthdlr->SetSlob(m_pSlob, FALSE);
	}

	// parse a string using the option string table and set the approp.
	// properties in the current CSlob's property bag, returns FALSE if unable
	BOOL ParseString(CString &, OptBehaviour optbeh = OBClear);

private:
	// option 'arg expression' helper & option 'optional part' extraction
	void ExtractOptionArg(char * & pchExpr, size_t & cchExpr);
	void ExtractPart(char * & pchExpr, size_t & cchExpr, char * & pchPart, size_t & cchPart);

	// parsing option string helper functions
	BOOL MatchChoice(size_t &, char *, UINT *);
	BOOL MatchExpression(const char * pchExpr, size_t cchExpr, UINT * pidArg);	// match an expression
	BOOL MatchOption(COptStr * poptstr);	// match an option with the source

	// skip whitespace in the source
	__inline void SkipWhiteSpace()
	{
		while (isspace((unsigned char)NewGetAt(strSrc, ichSrc + cchAdvSrc)))
			cchAdvSrc++;
	}

	// collect characters from the source into the output buffer according to a set of char. filters
	BOOL CollectOptionPart
	(
		CString & strOut,				// the collected option part
		BOOL	  fAlphaNumOnly = FALSE,// allow only alpha-numeric
		BOOL	  fAllowPunct = FALSE,	// don't allow punct.
		BOOL	  fAllowKanji = TRUE,	// allow Kanji characters (required)
		BOOL      fKeepQuotes = FALSE,	// keep the quotes?
		CString   strDelim = ""			// any delimiters (could be empty)
	);

private:
	// our option handler and current CSlob (property bag) 
	COptionHandler * m_popthdlr;
	CSlob * m_pSlob;

	// how should the parsing, generation behave?
	// ie. are we using defaults, showing defaults, setting defaults etc. etc.?
	OptBehaviour m_optbeh;

	//
	// property arg list
	//
	struct {
		UINT	idArg;
		BOOL	fChanged;
		CProp *	pProp;
		OptType type;
	} m_rgProps[MAX_OPT_ARGS];	// our properties to set for each option

	// clear our property arg list
	void ClearPropValList(BOOL fOnlyThoseChanged = FALSE);

	// add a property to our list,
	// set the properties in the list in the current property bag (also for multiple options)
	__inline void AddToPropList(UINT iArg, UINT idArg, CProp * pprop)
	{
		// first delete any existing arg (likely due to matching an optional part)
		if (m_rgProps[iArg].idArg != (UINT)-1 && m_rgProps[iArg].pProp)
			CProp::DeleteCProp(m_rgProps[iArg].pProp);

		m_rgProps[iArg].idArg = idArg;	// our arg id to set
		m_rgProps[iArg].pProp = pprop;	// our property
		m_rgProps[iArg].fChanged = TRUE;	// we changed this arg. recently
	}

	void SetPropValListInPropBag(UINT * poptarg);

	// reset our property list changed flags so we can spot which ones
	// we recently set when we go to back-out
	__inline void NoChangedPropValList()
	{
		for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS ; cArgs++)
			m_rgProps[cArgs].fChanged = FALSE;
	}

	// allowable flag prefixes
	CString			strPrefixes;

	// option string table 'cached' props, and 'cached' case sensitive bool
	UINT	m_nPropMin, m_nPropMax;
	BOOL	m_fCaseSensitive;

	// source to parse/generate 
	CString strSrc;			// our source string
	INT_PTR	ichSrc;				// our current position
	INT_PTR	cchAdvSrc;			// count chars advanced
	INT_PTR	cchAdvSrcToArg;		// count chars advanced to first arg.

	// multiple option data
	BOOL m_fMultipleGen;		// single or multiple?

	// cached data for our multiple option generation
	CPropBag * m_pBagCache;
	UINT m_idArgPropCache;
	OptBehaviour m_optbehCache;

	COptionList m_optlstCache;
	VCPOSITION m_posCache;

	// FUTURE: move this to the stack as locals
	TCHAR * pchArgValue;		// option arg expr. value
	UINT cchArgValue; 			// size of this dynamic buffer
	enum {none, booln, choice, absolute} patArgValue;	// option arg type
};

extern  COptionTable * g_pPrjoptengine;

extern UINT g_nIDOptHdlrUnknown;

#define NO_OPTARGS		{UINT(-1),UINT(-1),UINT(-1)}
#define OPTARGS1(a) 	{a,UINT(-1),UINT(-1)}
#define OPTARGS2(a,b)	{a, b,UINT(-1)}
#define OPTARGS3(a,b,c)	{a, b, c}

// declare the option string table
#define DECL_OPTSTR_TABLE() \
public: \
	void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour = OBNone); \
	void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp); \
	const BOOL IsCaseSensitive(); \
	COptStr * GetOptionStringTable(); \
	COptionLookup * GetOptionLookup(); \
protected: \
	COptionLookup m_optlookup; \
	static COptStr m_poptstr[]; \

// declare the option default map
#define DECL_OPTDEF_MAP() \
private: \
	virtual void CreateOptDefMap();

// define the option string table
// need to provide:-
// o props used for the unknown option/string props (-1 if one doesn't exist)
// o min. and max. props that exist in the option string table
// o whether the parsing of the option string should be case sensitive
#define BEGIN_OPTSTR_TABLE(tool, nIDArg1, nIDArg2, nIDArg3, nIDArg4, fCaseSensitive) \
	void OLD_OPTION_HANDLER(tool)::GetSpecialLogicalOptProps(UINT & nIDUnknownOption, UINT & nIDUnknownString, OptBehaviour optbeh) \
		{ \
			ASSERT_VALID(m_pSlob); \
			nIDUnknownOption = (optbeh & OBAnti) ? (UINT)-1 : (nIDArg1); \
			nIDUnknownString = (optbeh & OBAnti) ? (UINT)-1 : (nIDArg2); \
		} \
	void OLD_OPTION_HANDLER(tool)::GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp) \
		{nIDMinProp = (nIDArg3); nIDMaxProp = (nIDArg4); VSASSERT(nIDMinProp != (UINT)-1 && nIDMaxProp != (UINT)-1, "Min or max prop not set properly");} \
	const BOOL OLD_OPTION_HANDLER(tool)::IsCaseSensitive() \
		{return fCaseSensitive;} \
	COptStr * OLD_OPTION_HANDLER(tool)::GetOptionStringTable() \
		{return (COptStr *)m_poptstr;} \
	COptionLookup * OLD_OPTION_HANDLER(tool)::GetOptionLookup() \
		{return &m_optlookup;} \
	COptStr OLD_OPTION_HANDLER(tool)::m_poptstr[] = {

#define END_OPTSTRTBL() \
	{(UINT)-1, NULL, NO_OPTARGS, single}};

// declare the option handler
#define DEFN_OPTHDLR_HEADER(tool, szPkg, id, szPkgTool, idTool, szPkgBase, idBase)\
class OLD_OPTION_HANDLER(tool) : public COptionHandler { \
public: \
	OLD_OPTION_HANDLER(tool)() : COptionHandler(szPkg, id, szPkgTool, idTool, szPkgBase, idBase) {} \

#define DEFN_OPTHDLR_COMMON(tool, szPkg, id, szPkgTool, idTool) \
	DEFN_OPTHDLR_HEADER(tool, szPkg, id, szPkgTool, idTool, (const TCHAR *)NULL, 0)
#define DEFN_OPTHDLR_PLATFORM(tool, szPkg, id, szPkgTool, idTool, szPkgBase, idBase) \
	DEFN_OPTHDLR_HEADER(tool, szPkg, id, szPkgTool, idTool, szPkgBase, idBase)

#define END_OPTHDLR() };

// this defines the ctor that will create our default option map for the handler
#define BEGIN_OPTDEF_MAP(tool) void OLD_OPTION_HANDLER(tool)::CreateOptDefMap() {

#define OPTDEF_LIST(name, sz) AddDefStrProp(MapLogical(P_##name), sz, multiple);
#define OPTDEF_DIR_LIST(name, sz) AddDefDirProp(MapLogical(P_##name), sz, multiple);

#define OPTDEF_BOOL(name, b) AddDefBoolProp(MapLogical(P_##name), b);
#define OPTDEF_STRING(name, sz) AddDefStrProp(MapLogical(P_##name), sz);
#define OPTDEF_PATH(name, sz) AddDefPathProp(MapLogical(P_##name), sz);
#define OPTDEF_INT(name, n) AddDefIntProp(MapLogical(P_##name), n);
#define OPTDEF_HEX(name, h) AddDefHexProp(MapLogical(P_##name), h);

#define END_OPTDEF_MAP() }

#endif // _INCLUDE_OPTIONTBL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\prjconfg.cpp ===
//
// CProjComponentMgr, CProjType
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop

#include "version.h"	// version info.
#include "schmztl.h"
#include "project.h"
#include "bldpack.h"
#include "bldrcvtr.h"

IMPLEMENT_DYNCREATE(CBldSysCmp, CSlob)
IMPLEMENT_DYNCREATE(CPlatform, CBldSysCmp)
IMPLEMENT_DYNCREATE(CProjType, CBldSysCmp)
IMPLEMENT_DYNAMIC(CProjTypeUnknown, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// define the global tool option engine (parsing & generation)
COptionTable  *g_pPrjoptengine = NULL;

// define the global project configuration manager
CProjComponentMgr *g_pPrjcompmgr = NULL;

// This helper routine attempts to create a unique name for an output
// directory.  This is called when a new configuration is created in
// order to establish unique output directories for that new configuration.
// This routine only checks for collisions with other configurations at
// the CProject level -- if a group in some configuration uses an output
// directory with the same name we propose, this routine doesn't catch that.
// But checking the project level should work in 90%+ of cases since most
// users won't override at the group or file level anyway.
//
// This routine should probably be in some PROJUTIL.CPP file...
void GetNewOutputDirName(CProject * pProject, const CString & strNewConfig, CString & strResult)
{
			int			nNumCfgs, nCfg, nTweak;
			BOOL		bUnique, bDirValid;
	const	CPath *		pProjPath;
			CPath		path;
			CDir		dirProj;
			CProp *		pProp;
			CPropBag *	pPropBag;

	VSASSERT(!strNewConfig.IsEmpty(), "Config name cannot be empty!");

	strResult = strNewConfig;
	// Replace any non-alphanumeric characters with '_'.
	for (int i=0;i<strResult.GetLength();i++)
	{
		#ifdef _MBCS
		if (_ismbblead(strResult[i]))
			i++;	// ignore/allow DBCS characters
		else
		#endif
		if (!IsCharAlphaNumeric(strResult[i]))
		{
			strResult.SetAt(i, _T('_'));
		}
	}

	// Now check to see if the CProject node has this same output directory
	// name (either intermediate or final) for any other configuration.
	nNumCfgs = pProject->GetPropBagCount();
	nTweak = 0;
	pProjPath = pProject->GetFilePath();
	bDirValid = TRUE;
	dirProj = pProject->GetProjDir();

	for (;;)
	{
		bUnique = TRUE;		// Assume

		// First check to see if the name exists on disk -- if so, it's
		// a poor choice for an output directory name.
		if	(
			(bDirValid)
			&&
			(path.CreateFromDirAndFilename(dirProj, strResult))
			&&
			(path.ExistsOnDisk())
			)
		{
			bUnique = FALSE;
		}
		else
		{
			for (nCfg=0 ; nCfg<nNumCfgs ; ++nCfg)
			{
				pPropBag = pProject->GetPropBag(nCfg);

				pProp = pPropBag->FindProp(P_ProjConfiguration);
				VSASSERT(pProp && pProp->m_nType == string, "P_ProjConfiguration missing or has wrong prop type!");

				if ( (pProp == NULL) || (((CStringProp *)pProp)->m_strVal == strNewConfig) )
					continue;	// Don't need to check just-created config

				
				if ((pProp = pPropBag->FindProp(P_OutDirs_Intermediate)) != NULL)
				{
					VSASSERT(pProp->m_nType == string, "P_OutDirs_Intermediate has wrong prop type!");
					if ( ((CStringProp *)pProp)->m_strVal == strResult )
					{
						bUnique = FALSE;
						break;
					}
				}

				if ( (pProp = pPropBag->FindProp(P_OutDirs_Target)) != NULL )
				{
					VSASSERT(pProp->m_nType == string, "P_OutDirs_Target has wrong prop type!");
					if ( ((CStringProp *)pProp)->m_strVal == strResult )
					{
						bUnique = FALSE;
						break;
					}
				}
			}
		}

		if (bUnique)
			break;

		// Tweak the last character of the name to see if that helps.
		// if our tweak digit is 9.
		if (nTweak == 10)
		{
			break;			// Ran out of tweak digits; the user gets what we've got!
		}
		if(nTweak != 0){
			// strip off the last charater. NOTE that it is a digit and so not mb
			strResult=strResult.Left(strResult.GetLength()-1);
		}
		strResult += (TCHAR)('0'+nTweak); // add a digit
		nTweak++;
	}
}

// helper
LONG RegGetKey
(
	HKEY hKey,
	LPCTSTR lpctstr,
	PHKEY phkey,
	BOOL fCreate
)
{
	// either create or just try to open the key
	if (fCreate)
	{
		DWORD dwDisp;
		return RegCreateKeyEx(hKey, lpctstr, 0,
					   	   	   "", REG_OPTION_NON_VOLATILE,
					       	   KEY_ALL_ACCESS, NULL, phkey,
					       	   &dwDisp);
	}
	else
	{
		return RegOpenKeyEx(hKey, lpctstr, 0,
							 KEY_ALL_ACCESS, phkey);
	}
}

// implementation of the CBldSysCmp class

static TCHAR szRegKey[]			= _TEXT("Build System\\Components\\");
static TCHAR szPlatforms[]		= _TEXT("Platforms\\");
static TCHAR szTargets[]		= _TEXT("Targets\\");
static TCHAR szTools[]			= _TEXT("Tools\\");
static TCHAR szVersion[]		= _TEXT("Version");
static TCHAR szCustomList[]		= _TEXT("Custom");
static TCHAR szCustomSection[]	= _TEXT("Custom Tools");

const CString CBldSysCmp::g_strRegKey(szRegKey);

#define theClass CBldSysCmp
BEGIN_SLOBPROP_MAP(CBldSysCmp, CSlob)
	STR_PROP(CompName)
END_SLOBPROP_MAP()
#undef theClass

#define theClass CBldSysCmp
BEGIN_REGISTRY_MAP_P(CBldSysCmp)
END_REGISTRY_MAP()
#undef theClass

CBldSysCmp::CBldSysCmp()
{
	m_dwId = m_dwRelatedId = 0;
}

void CBldSysCmp::SetId(DWORD dwId)
{
	m_dwId = dwId;

	// create our 'default' name?
	if (m_strCompName.IsEmpty())
	{
		sprintf(m_strCompName.GetBuffer(32), "<Component 0x%x>", dwId);
		m_strCompName.ReleaseBuffer();
	}

	m_fCompRegKeyDirty = TRUE;	// our 'cached' key is now dirty
}

void CBldSysCmp::SetRelatedId(DWORD dwRelatedId)
{
	m_dwRelatedId = dwRelatedId;

	m_fCompRegKeyDirty = TRUE;	// our 'cached' key is now dirty
}

BOOL CBldSysCmp::SynchronizeWithRegistry()
{
	const TCHAR * pchKey = GetCompRegKeyName();

	// make sure this key exists
	HKEY hKey;
	if (RegGetKey(HKEY_CURRENT_USER, pchKey, &hKey) != ERROR_SUCCESS)
		return FALSE;	// failed

	// check the version info.
	// major, minor and update version info.
	int iMaj = 0, iMin = 0, iUpd = 0;
	TCHAR * szVerFormat =
#ifndef _SHIP
		_TEXT("%1d.%02d.%04d");	// eg. '3.00.1234'
#else
		_TEXT("%1d.%02d");		// eg. '3.00'
#endif // _SHIP

	DWORD dwType = 0;		// type must be REG_SZ
	TCHAR szVerValue[10];
	DWORD cbData = sizeof(szVerValue) / sizeof(TCHAR);
	if ((RegQueryValueEx(hKey, (LPTSTR)szVersion, NULL, &dwType,
				  		(LPBYTE)szVerValue, &cbData) == ERROR_SUCCESS) &&
		(dwType == REG_SZ) &&			// must be an REG_SZ
		(cbData == 5 || cbData == 10)	// must be '0.00' or '0.00.0000'
	   )
	{
		// got version info. so

#ifndef _SHIP
		// pad with an update version?
		if (cbData == 5)
			_tcscat(szVerValue, _TEXT(".0000"));
#endif

		// and then crack the args
		_stscanf(szVerValue, szVerFormat, &iMaj, &iMin, &iUpd);
	}

	// now write out our data for this component, base component data first
	CVCPtrList mapStack;	// map stack for remembering position in map
	CString strValue;	// name of value in registry
	CString strSubKey;	// name of possible sub-key

	const CRegistryMap * pregmap = GetRegistryMap();
	BOOL fEndOfMap = FALSE;
	while (!fEndOfMap)
	{
		// base map?
		if (pregmap->regType == CRegistryMap::MapBegin)
		{
			if (pregmap->pvData != (const void *)NULL)
			{
				mapStack.AddTail((void *)pregmap);
				pregmap = (const CRegistryMap *)pregmap->pvData;
				continue;	// run down this one
			}
		}
		else
		// end of map?
		if (pregmap->regType == CRegistryMap::MapEnd)
		{
			if (mapStack.IsEmpty())
				fEndOfMap = TRUE;
			else
				pregmap = (const CRegistryMap *)mapStack.RemoveTail();
		}
		else
		{
			HKEY hSubKey = hKey;	// initially subkey is this key!

			// do we have a sub-key?
			if (pregmap->szRegSubKey != NO_SUB_KEY)
			{
				if (RegGetKey(hKey, (LPCTSTR)pregmap->szRegSubKey, &hSubKey) != ERROR_SUCCESS)
					goto NextInRegMap;	// failed goto next one
			}

			// do we have this value resource?
			strValue = (LPCTSTR)pregmap->szRegField;

			LPBYTE lpbData = (LPBYTE)this + (DWORD_PTR)pregmap->pvData;
			
			// make sure we have valid data
			VSASSERT(pregmap->regType == CRegistryMap::MapFData || AfxIsValidAddress(lpbData, pregmap->cbData), "Invalid registry data");

			DWORD dwType, cbData;	// retrieved from registry using RegDataExists()
			if (RegDataExists(pregmap, hSubKey, &strValue, &dwType, &cbData))
			{
				BOOL bOK = LoadRegData(pregmap, hSubKey, &strValue, lpbData, cbData);
				VSASSERT(bOK, "Failed to load registry data!");
  			}

			// do we have a sub-key to close?
			if (pregmap->szRegSubKey != NO_SUB_KEY)
				RegCloseKey(hSubKey);
		}

		NextInRegMap:

		// next reg. map entry
		pregmap++;
	}

	// close the key
	RegCloseKey(hKey);

	return TRUE;		// ok
}

BOOL CBldSysCmp::RegGetDataKey(const CRegistryMap * pregmap, PHKEY phkey, BOOL fCreate)
{
	const TCHAR * pchKey = GetCompRegKeyName();

	// make sure the parent key exists
	HKEY hKey;
	if (RegGetKey(HKEY_CURRENT_USER, pchKey, &hKey, fCreate) != ERROR_SUCCESS)
		return FALSE;	// failed

	BOOL fRet = TRUE;	// success, unless get subkey fails
	*phkey = hKey;		// unless we have a subkey, this is the one we want

	// do we have a sub-key?
	if( pregmap )
	{
	    if (pregmap->szRegSubKey != NO_SUB_KEY)
	    {
		    // do we have this subkey resource?
		    CString strSubKey = pregmap->szRegSubKey;	// name of possible sub-key
    
		    fRet = RegGetKey(hKey, (LPCTSTR)(const TCHAR *)strSubKey, phkey, fCreate) == ERROR_SUCCESS;
		    
		    // always close the parent key
		    RegCloseKey(hKey);
	    }
	}
	else
	{
	    fRet = FALSE;	
	}

	return fRet;	// success
}

BOOL CBldSysCmp::LoadRegData(UINT nRegId)
{
	const CRegistryMap * pregmap = GetRegMapEntry(nRegId);
	VSASSERT(pregmap != (const CRegistryMap *)NULL, "Failed to find reg entry to load reg data from");

	HKEY hDataKey;
	// n.b don't create key if doesn't exist already
	if (!RegGetDataKey(pregmap, &hDataKey, FALSE))
		return FALSE;

	// do we have this value resource?
	CString strValue = pregmap->szRegField;	// name of value in registry

	LPBYTE lpbData = (LPBYTE)this + (DWORD_PTR)pregmap->pvData;
	
	// make sure we have valid data
	VSASSERT(pregmap->regType == CRegistryMap::MapFData || AfxIsValidAddress(lpbData, pregmap->cbData), "Invalid registry data");

	DWORD dwType, cbData;	// retrieved from registry using RegDataExists()
	if (RegDataExists(pregmap, hDataKey, &strValue, &dwType, &cbData))
		LoadRegData(pregmap, hDataKey, &strValue, lpbData, cbData);

	// close the data key
	RegCloseKey(hDataKey);

	return TRUE;	// success
}

const CRegistryMap * CBldSysCmp::GetRegMapEntry(UINT nRegId)
{
	CVCPtrList mapStack;	// map stack for remembering position in map
	const CRegistryMap * pregmap = GetRegistryMap();
	BOOL fEndOfMap = FALSE;
	while (!fEndOfMap)
	{
		// base map?
		if (pregmap->regType == CRegistryMap::MapBegin)
		{
			if (pregmap->pvData != (const void *)NULL)
			{
				mapStack.AddTail((void *)pregmap);
				pregmap = (const CRegistryMap *)pregmap->pvData;
				continue;	// run down this one
			}
		}
		else
		// end of map?
		if (pregmap->regType == CRegistryMap::MapEnd)
		{
			if (mapStack.IsEmpty())
				fEndOfMap = TRUE;
			else
				pregmap = (const CRegistryMap *)mapStack.RemoveTail();
		}
		else
		// found the registry entry we want?
		if (pregmap->nRegId == nRegId)
			//
			// FOUND registry entry
			return pregmap;

		// next reg. map entry
		pregmap++;
	}

	//
	// NO registry entry
	return (const CRegistryMap *)NULL;
}

BOOL CBldSysCmp::RegDataExists
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPDWORD pdwType, LPDWORD pcbData
)
{
	// data in registry?
	BOOL fRet = RegQueryValueEx(hKey, (LPTSTR)(const TCHAR *)*pstrValue, NULL, pdwType,
		   				        (LPBYTE)NULL, pcbData) == ERROR_SUCCESS;

	// make sure we have matching types if we succeeded
	VSASSERT(!fRet || *pdwType == MapRegType(pregmap->dwType), "Reg data type mismatch");
	return fRet;
}

BOOL CBldSysCmp::LoadRegData
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPBYTE lpbData, DWORD cbData
)
{
	VSASSERT(lpbData != (BYTE *)NULL, "forgot to implement 'special' override?");

	DWORD dwType = pregmap->dwType;

	// if we are using REG_STRING then we need to do some CString buffer magic
	// and expand the buffer to the req. size
	CString * pstr = (CString *) (dwType == REG_STRING ? lpbData : NULL);
	if (pstr != (CString *)NULL)
	{
		(void) pstr->GetBuffer(cbData);
		lpbData = (LPBYTE)(const TCHAR *)*pstr;

		dwType = MapRegType(dwType);	// re-map to be a regualar system reg. type
	}

	// load the data
	if (RegQueryValueEx(hKey, (LPTSTR)(const TCHAR *)*pstrValue, NULL, &dwType,
				  		(LPBYTE)lpbData, &cbData) != ERROR_SUCCESS)
		return FALSE;	// failed

	// ensure that we adjust for the correct length (null-terminated string)
	if (pstr != (CString *)NULL)
		(void) pstr->ReleaseBuffer();

	return TRUE;	// ok
}

const TCHAR * CBldSysCmp::GetCompRegKeyName(BOOL fInclAppKey)
{
	if (m_fCompRegKeyDirty)
	{
		DWORD bsc_id = m_dwId;
		CBldSysCmp * pcomp;
		CString str;
	 	TCHAR * pchType=NULL;

		m_strCompRegKey.Empty();
		do
		{
			// get our component name
			if (g_pPrjcompmgr->LookupBldSysComp(bsc_id, pcomp))
				str = *pcomp->GetName();			// component name
			else
				{VSASSERT(FALSE, "Failed to load bld system component"); return _TEXT("<Failed>");}		// failed!

			// get our component type
			if (pcomp->IsKindOf(RUNTIME_CLASS(CPlatform)))
				pchType = szPlatforms;

			else if (pcomp->IsKindOf(RUNTIME_CLASS(CProjType)))
				pchType = szTargets;

			else if (pcomp->IsKindOf(RUNTIME_CLASS(CBuildTool)))
				pchType = szTools;

			else if (pcomp->IsKindOf(RUNTIME_CLASS(COptionHandler)))
				VSASSERT(FALSE, "How did we get an option handler here?");						// shouldn't be here!

			// concat. our component name to *front* of current key
			str += _TEXT("\\");
			str += m_strCompRegKey;

			// concat. our component type to *front* of component name
			m_strCompRegKey = pchType;
			m_strCompRegKey += str;

		} while ((bsc_id = pcomp->RelatedCompId()) != idAddOnGeneric);
		// 'break' out on bsc_id == idAddOnGeneric

		// append the BldSys key ro *front*
		m_strCompRegKey = *GetRegKeyName() + m_strCompRegKey;

		// append the Visual C++ key to *front*
		m_strFullCompRegKey = _T("Software\\Microsoft\\Shared Tools\\"); //072199 ::GetRegistryKeyName();
		m_strFullCompRegKey += _TEXT("\\");
		m_strFullCompRegKey += m_strCompRegKey;

		m_fCompRegKeyDirty = FALSE;	// not dirty anymore.
	}

 	return fInclAppKey ? (const TCHAR *)m_strFullCompRegKey : (const TCHAR *)m_strCompRegKey;
}

// implementation of the CProjComponentMgr class
void DefaultConfig(CProject * pProject, const CString & strPlatformUIDescription, UINT nIDMode, CString & strConfig)
{
	CString strName = pProject->GetFilePath()->GetFileName();
	int iDot = strName.ReverseFind(_T('.'));
	if (iDot > 0)
		strName = strName.Left(iDot);

	CString strMode;
	BOOL bOK = strMode.LoadString(nIDMode);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	strConfig =  strName + _T(" - ") + strPlatformUIDescription + _T(' ') + strMode;
}

CProjComponentMgr::CProjComponentMgr()
{
	// init. enumerator info.
	m_posProjType = (VCPOSITION)NULL;			// no next projtype
	m_posTool = (VCPOSITION)NULL;				// no next build tool

	m_idOptPropBase = PROJ_BUILD_OPTION_FIRST;	// our next option prop id.
	m_nPropFirst = m_nPropLast = (UINT)-1;
	m_popthdlrCache = (COptionHandler *)NULL;

	// retrieve other information about the environment components might use
	CString strKeyName;
	HKEY hKey;

	// do we have ODBC installed?
	m_fODBCInstalled = TRUE;	// default is yes (error in favour of ODBC)

	// do we have MFC installed?
	m_fMFCInstalled = TRUE;		// default is yes (error in favour of MFC)

	strKeyName = _T("Software\\Microsoft\\Shared Tools\\"); //072199 GetRegistryKeyName();
	strKeyName += _TEXT("\\General");
	if (RegOpenKeyEx(HKEY_CURRENT_USER, strKeyName, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType, dwValue, dwValueSize = sizeof(DWORD);
		if (RegQueryValueEx(hKey, _TEXT("MFCInstalled"), NULL, &dwType, (LPBYTE)&dwValue, &dwValueSize) == ERROR_SUCCESS)
		{
			// make sure we get the value we expect
			VSASSERT(dwType == REG_DWORD, "Unexpected reg data type");
			VSASSERT(dwValueSize == sizeof(DWORD), "Unexpected reg data size");
			m_fMFCInstalled = dwValue != 0;
		}
		if (RegQueryValueEx(hKey, _TEXT("ODBCInstalled"), NULL, &dwType, (LPBYTE)&dwValue, &dwValueSize) == ERROR_SUCCESS)
		{
			// make sure we get the value we expect
			VSASSERT(dwType == REG_DWORD, "Unexpected reg data type");
			VSASSERT(dwValueSize == sizeof(DWORD), "Unexpected reg data size");
			m_fODBCInstalled = dwValue != 0;
		}
		RegCloseKey(hKey); // close the key we just opened
	}
	m_fInit = FALSE;
}

CProjComponentMgr::~CProjComponentMgr()
{
 	Clean();
}

void CProjComponentMgr::Clean()
{
	// delete out unknown project objects
	VCPOSITION pos = m_lstUnkProjObjs.GetHeadPosition();
	CObject * pobj;
	while (pos != (VCPOSITION)NULL)
	{
		pobj = (CObject *)m_lstUnkProjObjs.GetNext(pos);
		ASSERT_VALID(pobj);
		delete pobj;	// delete the object
	}
	// make sure the list is now empty
	m_lstUnkProjObjs.RemoveAll();

	// delete our build system components for the packages

	// delete in this order
	CRuntimeClass * rgDTOROrder[] =
	{
		// project types next
		RUNTIME_CLASS(CProjType),

		// then everything else
		RUNTIME_CLASS(CObject)
	};

	CBldSysCmp * pcomp;
	DWORD rkey;
	UINT iDTOROrder = 0;

	while (iDTOROrder < sizeof(rgDTOROrder) / sizeof(CRuntimeClass *))
	{
		CRuntimeClass * pRC = rgDTOROrder[iDTOROrder];

		pos = m_mapBldSysCmps.GetStartPosition();
		while (pos != (VCPOSITION)NULL)
		{
			m_mapBldSysCmps.GetNextAssoc(pos, rkey, (void *&)pcomp);
			if (pcomp->IsKindOf(pRC))
			{
				delete (CBldSysCmp *)pcomp; // delete the component
				m_mapBldSysCmps.RemoveKey(rkey); // remove this one
			}
		}

		iDTOROrder++;
	}
}

extern "C" typedef BOOL(FAR PASCAL *INITPACKAGEPROC)(CObList *);
extern "C" BOOL PASCAL InitPackage(CObList *lstPackages);
CBuildPackage * g_pBuildPackage;

BOOL CProjComponentMgr::FInit(IVCProjConvert *pConverter)
{
	// first off, ask the packages to register their components
	// we'll need to arrange the list of packages ourselves

	CPackage *pBuildPackage;
	pConverter->GetPackage((long **)&pBuildPackage);
	VSASSERT(pBuildPackage, "No build package!  Deep trouble.");
	if (pBuildPackage)
	{
		lstArngdPackages.AddTail(pBuildPackage);
		g_pBuildPackage = (CBuildPackage *)pBuildPackage; // need this for Term();
	}

	InitPackage(&lstArngdPackages); // call CIntelx86AddOn's InitPackage...

	// Now create the OLE servers for NON package based ones
	POSITION pos;
	pos = lstArngdPackages.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);
		(void) pPackage->DoBldSysCompRegister(this, BLC_OleAddOn, m_dwRegisterId);
	}

	// first ask for generic components
	// o platforms
	// o tools not platform specific
	// o builder converters not product specific

	pos = lstArngdPackages.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		POSITION posCurr = pos;
		CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);

		m_dwRegisterId = idAddOnGeneric;	// general

		m_fRegPrimaryPlatform = FALSE;	// use this to check if registered a primary platform
		(void) pPackage->DoBldSysCompRegister(this, BLC_Platform, m_dwRegisterId);

		// registered a primary platform?
		if (m_fRegPrimaryPlatform)
		{
			// move package to head of list
			lstArngdPackages.RemoveAt(posCurr);
			lstArngdPackages.AddHead(pPackage);
		}

		(void) pPackage->DoBldSysCompRegister(this, BLC_Tool, m_dwRegisterId);
		(void) pPackage->DoBldSysCompRegister(this, BLC_OptionHdlr, m_dwRegisterId);
	}

	// now ask each for any other components for each of these platforms
	// o tools
	// o target types (target types will bind to tools)
	// o builder converters
	CPlatform * pPlatform;
	InitPlatformEnum();
	while (NextPlatform(pPlatform))
	{
 		pos = lstArngdPackages.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);

			m_dwRegisterId = pPlatform->CompId();	// for each platform
			(void) pPackage->DoBldSysCompRegister(this, BLC_Tool, m_dwRegisterId);
			(void) pPackage->DoBldSysCompRegister(this, BLC_TargetType, m_dwRegisterId);
		}
	}

	// ask for any tools that may wish to be a part of target type
	CProjType * pProjType;
	InitProjTypeEnum();
	while (NextProjType(pProjType))
	{
		pos = lstArngdPackages.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);
			m_dwRegisterId = pProjType->CompId();	// for each target
			(void) pPackage->DoBldSysCompRegister(this, BLC_Tool, m_dwRegisterId);
		}
	}

	// now ask for the option handlers for each platform (option handlers will bind to tools)
 	InitPlatformEnum();
	while (NextPlatform(pPlatform))
	{
 		pos = lstArngdPackages.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);

			m_dwRegisterId = pPlatform->CompId();	// will bind to a tool
			(void) pPackage->DoBldSysCompRegister(this, BLC_OptionHdlr, m_dwRegisterId);
		}
	}

	int			nCountPlatforms = 0;
	BOOL		bFoundPrimary = FALSE;

	// create our hashed index into the platforms
	// and at the same time FInit() the platforms
	InitPlatformEnum();
	while (NextPlatform(pPlatform))
	{
		if (pPlatform->FInit())
		{
			m_mapPlatforms.SetAt(*(pPlatform->GetName()), pPlatform);

			// count many platforms
			++nCountPlatforms;

			// ensure only one primary platform
			if (pPlatform->IsPrimaryPlatform())
			{
				VSASSERT(!bFoundPrimary, "Found more than one primary platform!");
				bFoundPrimary = TRUE;
			}
		}
	}

	// create our hashed index into the project types
	CProjType* pprojtype;
 	InitProjTypeEnum();
	while (NextProjType(pprojtype))
	{
		m_mapProjTypes.SetAt(*(pprojtype->GetName()), pprojtype);
	}

	return S_OK;
}

void CProjComponentMgr::Term()
{
	POSITION vcpos;
	vcpos = lstArngdPackages.GetHeadPosition();
	while (vcpos)
	{
		CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(vcpos);
		if (pPackage != (CPackage *)g_pBuildPackage)
			delete pPackage;
	}
	lstArngdPackages.RemoveAll();

	Clean();
}

WORD CProjComponentMgr::GenerateBldSysCompPackageId(const TCHAR * szPackageName)
{	
	// szAddOnGeneric is zero
	if (szPackageName == szAddOnGeneric)
		return 0;

	// do we have this package id already?
	INT_PTR iAddOn = m_rgstrAddOns.GetSize();
	while (iAddOn > 0)
	{
		iAddOn--;
		if (_tcscmp((TCHAR *)(const TCHAR *)m_rgstrAddOns[iAddOn], (TCHAR *)szPackageName) == 0)
			return (WORD)(iAddOn + 1);
	}

	// new package id
	return (WORD)(m_rgstrAddOns.Add(szPackageName) + 1);	// zero is reserved
}

int CProjComponentMgr::GetSupportedPlatformCount()
{
	int count = 0;
	VCPOSITION pos = m_lstPlatforms.GetHeadPosition();
	while (pos != NULL)
	{
		if (((CPlatform *)m_lstPlatforms.GetNext(pos))->IsSupported())
			count++;
	}
	return count;
}

BOOL CProjComponentMgr::RegisterBldSysComp(CBldSysCmp * pcomp, DWORD bsc_id)
{
	BOOL fInRegistry = TRUE;

 	// set the id.?
	if (!pcomp->CompId() && bsc_id != (DWORD)-1)
		pcomp->SetId(bsc_id);

	DWORD type = BldSysCompType(pcomp);

	// set the related id.
	if (!pcomp->RelatedCompId())
	{
		// custom tools are always generic
		if (type == BLC_CustomTool)
			pcomp->SetRelatedId(idAddOnGeneric);
		else
			pcomp->SetRelatedId(m_dwRegisterId);
	}

	// make sure we don't already have this
	VSASSERT(!LookupBldSysComp(pcomp->CompId(), pcomp), "Build system component added more than once!");

	// depending on the type of component this is,
	// we'll register in different lists
	switch (type)
	{
		case BLC_Platform:
			RegisterPlatform((CPlatform *)pcomp);
			break;

		case BLC_TargetType:
			RegisterProjType((CProjType *)pcomp);
			break;

		case BLC_Tool:
			break;

		case BLC_OptionHdlr:
			RegisterOptionHandler((COptionHandler *)pcomp);
			fInRegistry = FALSE;		// not in registry!
			break;

		default:
			VSASSERT(FALSE, "Unknown bldsys component");	// unknown bldsys component
			return FALSE;	// failure
	}

	// for quick retrieval use a map of id->component
	m_mapBldSysCmps.SetAt(pcomp->CompId(), pcomp);

	// make sure that the component and system registry are in sync.
	if (fInRegistry && !pcomp->SynchronizeWithRegistry())
		return FALSE;	// failed to sync. with registry

	return TRUE;	// success
}

// get a component type for a component with id, 'bsc_id', returns 'BLC_ERROR' if not found
DWORD CProjComponentMgr::BldSysCompType(DWORD bsc_id)
{
	CBldSysCmp * pcomp;
	// does this component exist in the registry?
	if (!LookupBldSysComp(bsc_id, pcomp))
		return BLC_ERROR;

	return BldSysCompType(pcomp);
}

// get a component type for a component with id, 'bsc_id', returns 'BLC_ERROR' if not found
DWORD CProjComponentMgr::BldSysCompType(CBldSysCmp * pcomp)
{
	// our component type
	DWORD type = BLC_ERROR;

	// depending on the type of component this is,
	// we'll register in different lists
	if (pcomp->IsKindOf(RUNTIME_CLASS(CPlatform)))
		type = BLC_Platform;

	else if (pcomp->IsKindOf(RUNTIME_CLASS(CProjType)))
		type = BLC_TargetType;

	else if (pcomp->IsKindOf(RUNTIME_CLASS(CBuildTool)))
		type = BLC_Tool;

	else if (pcomp->IsKindOf(RUNTIME_CLASS(COptionHandler)))
		type = BLC_OptionHdlr;

	return type;	// return our type
}

// generic object removal
BOOL CProjComponentMgr::DeregisterComponent(CVCPtrList & lst, CObject * ptr)
{
	// remove it from our list
	VCPOSITION pos = lst.Find(ptr);
	if (pos != (VCPOSITION)NULL)
	{
		// remove
		lst.RemoveAt(pos);

		return TRUE;	// ok
	}

	return FALSE; // didn't find it
}

// platform management
void CProjComponentMgr::RegisterPlatform(CPlatform * pPlatform)
{
	ASSERT_VALID(pPlatform);
	if (!pPlatform->FInit())
		return;

	m_mapPlatforms.SetAt(*(pPlatform->GetName()), (void *)pPlatform);

	if (pPlatform->IsPrimaryPlatform())
	{
		m_lstPlatforms.AddHead(pPlatform);
		m_fRegPrimaryPlatform = TRUE;
	}
	else
	{
		m_lstPlatforms.AddTail(pPlatform);
	}
}

BOOL CProjComponentMgr::DeregisterPlatform(CPlatform * pPlatform)
{
	m_mapPlatforms.RemoveKey(*(pPlatform->GetName()));

	return DeregisterComponent(m_lstPlatforms, pPlatform);
}

BOOL CProjComponentMgr::LookupPlatformByUniqueId(UINT nUniqueId, CPlatform * & pPlatform)
{
	pPlatform = (CPlatform *)NULL;	// not found yet

	if (nUniqueId)	// don't match 'unknown' platforms
	{
		CPlatform *	pPlatformEnum;
		InitPlatformEnum();

		while (NextPlatform(pPlatformEnum))
		{
			// have we found a platform with our unique id?
			if (pPlatformEnum->GetUniqueId() == nUniqueId &&
				// do we have one yet, or can this override one 'not-named'
				// (created by unknown exe targets)
				(!pPlatform || (pPlatform->GetName()->CompareNoCase("<Unknown>") == 0))
			)
			{
				pPlatform = pPlatformEnum;
			}
		}
	}

	return pPlatform != (CPlatform *)NULL;
}

// [jimsc 7-16-96] Added the bAllowNonPrimary flag, which defaults to TRUE, to signal
// that if no platform explicitly marked "primary" is found, the first supported
// platform will be returned.  If FALSE, and no primary platforms are found, this
// will return NULL.

CPlatform * CProjComponentMgr::GetPrimaryPlatform(BOOL bAllowNonPrimary /* = TRUE */)
{
	CPlatform *	pPlatform;
	CPlatform *	pFirstSupported = NULL;

	InitPlatformEnum();

	while (NextPlatform(pPlatform))
	{
		if ((pFirstSupported == NULL) && (pPlatform->IsSupported()))
			pFirstSupported = pPlatform;
			
		if (pPlatform->IsPrimaryPlatform())
			return pPlatform;
	}

	// No primary guys were found, so return the first supported platform unless told not to
	return bAllowNonPrimary ? pFirstSupported : NULL;
}

// project type management
void CProjComponentMgr::RegisterProjType(CProjType * pprojtype)
{
	ASSERT_VALID(pprojtype);

	if (!pprojtype->FInit())
		return;

	m_mapProjTypes.SetAt(*(pprojtype->GetName()), pprojtype);
	m_lstProjTypes.AddTail(pprojtype);
}

BOOL CProjComponentMgr::DeregisterProjType(CProjType * pprojtype)
{
	m_mapProjTypes.RemoveKey(*(pprojtype->GetName()));

	return DeregisterComponent(m_lstProjTypes, pprojtype);
}

BOOL CProjComponentMgr::GetProjTypefromProjItem(CProjItem * pProjItem, CProjType * & pProjType)
{
	CString strProjName;

	if (pProjItem->GetStrProp(P_ProjOriginalType, strProjName) != valid)
		return FALSE;	// can't find project type

	if (!LookupProjTypeByName(strProjName, pProjType))
		return FALSE;	// unrecognised project type

	return TRUE;	// ok
}

// Find the tool whose prefix matches the pPrefix. nPrefixLen is the maximum
// number of characters to match up to.  pprojitem can be used to retrieve
// only the tools for the current configuration.
CBuildTool * CProjComponentMgr::GetToolFromCodePrefix(CProjItem * pItem, const TCHAR * pPrefix, int nPrefixLen)
{
	// Project type tool?
	if (pItem != (CProjItem *)NULL)
	{
		CProjType * pprojtype;
		if (!GetProjTypefromProjItem(pItem, pprojtype))
			return FALSE;

		return pprojtype->GetToolFromCodePrefix(pPrefix, nPrefixLen);
	}
	// In master-list or custom-tool list?
	else
	{
		CBuildTool * pTool;
		InitBuildToolEnum();
		while (NextBuildTool(pTool))
		{
			const TCHAR * pc = pTool->m_strToolPrefix;
			int len = lstrlen(pc);
			if (len && !_tcsnicmp(pPrefix, pc, min(nPrefixLen, len)))
				return pTool;
		}
	}

	return (CBuildTool *)NULL;
}

// tool option management
void CProjComponentMgr::RegisterOptionHandler(COptionHandler * popthdlr)
{
	popthdlr->SetOptPropBase(m_idOptPropBase);
	m_idOptPropBase += popthdlr->GetOptPropRange();

	// make sure we don't fall out of our range
	VSASSERT(m_idOptPropBase < PROJ_BUILD_OPTION_PRIVATE_FIRST, "base prop out of range");
	m_lstOptionHandlers.AddTail(popthdlr);

	// initialise this option handler
	popthdlr->Initialise();
}

BOOL CProjComponentMgr::DeregisterOptionHandler(COptionHandler * popthdlr)
{
	return DeregisterComponent(m_lstOptionHandlers, popthdlr);
}

BOOL CProjComponentMgr::SetDefaultToolOptions(DWORD mode, CProject * pProject)
{
	// retrieve the string rep. of this proj. mode
	VSASSERT(mode == MOB_Debug || mode == MOB_Release, "Illegal mode");
	CString strMode;
	BOOL bOK = strMode.LoadString(mode == MOB_Debug ? IDS_DEBUG_CONFIG : IDS_RELEASE_CONFIG);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

	// retrieve the CProjType for the original project type for this project
	CProjType * pProjType;
	if (!GetProjTypefromProjItem((CProjItem *)pProject, pProjType))
		return FALSE;	// can't get the project type for this project item

	// preserve the option handler and current slob for 'option engine'
	COptionHandler * popthdlrOld = g_pPrjoptengine->GetOptionHandler();

	// enumerate through all of our known tools and then ask the project type
	// to provide the default option string
	// we'll then use the tools' option table to parse this string into
	// tool option properties
	CBuildTool * pBuildTool;
	const CVCPtrList *pList = pProjType->GetToolsList ();

	for (VCPOSITION pos = pList->GetHeadPosition (); pos != NULL;)	
	{
		pBuildTool = (CBuildTool *) pList->GetNext(pos);

		// ignore unknown tools
		if (!pBuildTool->IsSupported())
			continue;

		// ignore some tools, such as the pass through tool
		UINT bsc_id = pBuildTool->CompId();

		CString strOption; // don't move this line
		VSASSERT(strOption.IsEmpty(), "Brand-new string not empty?!?");

		// can the tool handle this?
		if (!pBuildTool->GetDefaultToolOptions(pProjType->CompId(), pProjType->GetAttributes(), mode, strOption))
			// no, so default to the target type - must be able to
			pProjType->GetDefaultToolOptions(bsc_id, strMode, strOption);

		// parse the default options into the property bag
		g_pPrjoptengine->SetOptionHandler(pBuildTool->GetOptionHandler());
		g_pPrjoptengine->SetPropertyBag(pProject);

		// clear before parse, behave as if we were reading from file ie.
		// we need "" to allow the setting of empty string props.
		BOOL bOK = g_pPrjoptengine->ParseString(strOption, OBClear | OBNeedEmptyString);
		VSASSERT(bOK, "Failed to parse option string!");
	}

	// reset current option handler
	g_pPrjoptengine->SetOptionHandler(popthdlrOld);

	return TRUE;	// success	
}

BOOL CProjComponentMgr::LookupProjTypeByUniqueId(UINT nUniqueId, CProjType * & pProjType)
{
	InitProjTypeEnum();
	while (NextProjType(pProjType))
	{
		if (nUniqueId==pProjType->GetUniqueId()) 
			return TRUE;
	}

	return FALSE;
}

BOOL CProjComponentMgr::LookupProjTypeByUIDescription(const TCHAR * pszUIDesc, CProjType * & pprojtype)
{
	// FUTURE: implement fast version of this?
	InitProjTypeEnum();
	while (NextProjType(pprojtype))	
	{
		if (!_tcscmp(pszUIDesc,LPCTSTR(*(pprojtype->GetUIDescription()))))
			return TRUE;
	}

	return FALSE;
}

COptionHandler * CProjComponentMgr::FindOptionHandler(UINT idProp)
{
	// quick check to see if could be a tool option!
	if (idProp < PROJ_BUILD_OPTION_FIRST || idProp > PROJ_BUILD_OPTION_LAST)
		return (COptionHandler *)NULL;

	// try our cache first
	if (m_nPropFirst <= idProp && idProp <= m_nPropLast)
		return m_popthdlrCache;

	// look through our list of option handlers
	COptionHandler * popthdlr;	
	UINT nPropLast;

	InitOptHdlrEnum();
	while (NextOptHdlr(popthdlr))
	{
		// N.B. we know that these options are in an ordered list
		// such that they are in prop. id. block' order
		if (idProp <= (nPropLast = popthdlr->LastOptProp()))
		{
			// cache this
			m_nPropFirst = popthdlr->FirstOptProp();
			m_nPropLast = nPropLast;
			m_popthdlrCache = popthdlr;

			return popthdlr;
		}
	}

	return (COptionHandler *)NULL;	// no option handler found, not a tool option
}

#define theClass CPlatform
BEGIN_REGISTRY_MAP(CPlatform, CBldSysCmp)	
END_REGISTRY_MAP()
#undef theClass

CPlatform::CPlatform(PlatformInfo * pInit)
{
	m_bSupported = TRUE;
	m_bBuildable = TRUE;

	m_nIDUIDesc = pInit->nIDUIDesc;
	m_nUniqueId = pInit->nUniqueId;
	m_nIDUIShortDesc = pInit->nIDUIShortDesc;

	// our component name
	m_strCompName = pInit->szName;

	// m_strUIDesc will be set up in FInit() method
	// m_strUIShortDesc will be set up in FInit() method if defined

	// initializing ToolInfo
	m_rgToolInfo.strRCExtension = pInit->szRCExtension;

	// our attributes
	m_dwAttributes = pInit->dwPlatformAttrib;

	// use MFC default
	m_nUseMFCDefault = pInit->nUseMFCDefault;

	VSASSERT(m_nIDUIDesc, "No UI description ID!");
	VSASSERT(m_nUniqueId < 256, "Unique ID too big!");
	
	// load our platform description strings
	BOOL bOK = TRUE;
	if (m_nIDUIDesc)
	{
		bOK = m_strUICompName.LoadString(m_nIDUIDesc);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	}
	if (m_nIDUIShortDesc)
	{
		bOK = m_strUIShortDesc.LoadString(m_nIDUIShortDesc);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	}
	else
		m_strUIShortDesc = m_strCompName.Left(5); // default

	// set up our default output directory
	if (pInit->szOutDirPrefix == (TCHAR *)NULL)
		m_strDefOutDirPrefix = m_strUICompName.Left(3);	// use TLA for default
	else
		m_strDefOutDirPrefix = pInit->szOutDirPrefix;
}

// Special constructor used for generating 'unknown' platforms dynamically
CPlatform::CPlatform(const _TCHAR * lpszName, UINT nUniqueId /* = unknown_platform */)
{
	// our component name
 	m_strCompName = lpszName;

	m_strUIShortDesc = m_strCompName.Left(5); // default
	// all other strings are "" for generic platforms

	m_nUniqueId = nUniqueId;
	// all other values are set to defaults (disabled)
	m_bSupported = FALSE;
	m_nIDUIDesc = 0;
	m_nIDUIShortDesc = 0;
	m_dwAttributes = 0;	

 	// initializing ToolInfo
	m_rgToolInfo.strRCExtension.Empty();

	VSASSERT(m_nUniqueId < 256, "Unique ID too big!");

	g_pPrjcompmgr->RegisterPlatform(this);
}

// Perform platform 'special' registry loading/saving
BOOL CPlatform::RegDataExists
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPDWORD pdwType, LPDWORD pcbData
)
{
	// do the base-class thing
	return CBldSysCmp::RegDataExists(pregmap, hKey, pstrValue, pdwType, pcbData);
}

BOOL CPlatform::LoadRegData
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPBYTE lpbData, DWORD cbData
)
{
	return TRUE;
}

BOOL CPlatform::SupportsODBC() const
{
	return g_pPrjcompmgr->ODBCIsInstalled() && ((GetAttributes() & PIA_Allow_ODBC) != 0);
}

UINT CPlatform::GetUseMFCDefault()
{
	// FUTURE: remove this and just use the GetAttributes() & PIA_AllowMFCInDLL
	return g_pPrjcompmgr->MFCIsInstalled() ? m_nUseMFCDefault : NoUseMFC;
}

BOOL CPlatform::FInit()
{
	if (!m_bSupported) // nothing to do for 'unknown' platforms
		return TRUE;

	// post-ctor initialise the platform here

	return TRUE;
}

CPlatform::~CPlatform()
{
	g_pPrjcompmgr->DeregisterPlatform(this);
}

const _TCHAR * CProjType::TypeNameFromId[] = {	_T("<unknown type>"),
						_T("Application"),
						_T("Dynamic-Link Library"),
						_T("Console Application"),
						_T("Static Library"),
						_T("ASLM Shared Library"),
						_T("External Target"),
						_T("QuickWin Application"),
						_T("Standard Graphics Application"),
						_T(""),
						_T("Generic Project")
						};

CProjType::CProjType(const TCHAR * szPkg, WORD id,
				     UINT nIDType, UINT nUniqTypeId,
			  		 const TCHAR * szPkgPlatform, WORD idPlatform)
{
	this->CProjType::CProjType(szPkg, id, nIDType, nUniqTypeId,
						 GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId(szPkgPlatform), idPlatform));
}

CProjType::CProjType(const TCHAR * szPkg, WORD id,
					   UINT nIDType, UINT nUniqTypeId,
					   DWORD bsc_id)
{
	// set our id.
	SetId(GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId(szPkg), id));

	VSASSERT(nUniqTypeId < 256, "Unique ID too big!");

	// save the our name away
	m_nIDType = nIDType;
	VSASSERT(m_nIDType, "ID type not set!");
	m_nUniqueTypeId = nUniqTypeId & 255;
	VSASSERT(m_nUniqueTypeId < 11, "Unique type ID too big; bump array size and this assert to fix");	// bump array size if this fires

	if (!g_pPrjcompmgr->LookupBldSysComp(bsc_id, (CBldSysCmp *&)m_pPlatform))
		VSASSERT(FALSE, "Failed to find desired bldsys component!");	// failed

	// make sure we got a valid platform
	ASSERT_VALID(m_pPlatform);
	VSASSERT(m_pPlatform->IsKindOf(RUNTIME_CLASS(CPlatform)), "Invalid platform!");

	m_strType = TypeNameFromId[m_nUniqueTypeId];

	// our component name
	m_strCompName = MakeNameFromPlatformAndType(*(m_pPlatform->GetName()), m_strType);
}

// Useful for dynamic creation of CProjTypes
CProjType::CProjType(const _TCHAR * lpszTypeName, UINT nUniqueTypeId, CPlatform * pPlatform)
{
	VSASSERT(nUniqueTypeId < 256, "Unique ID too big!");
	
	m_nIDType = 0;
	m_strType = lpszTypeName;
	m_strUIType = lpszTypeName;
	m_nUniqueTypeId = nUniqueTypeId & 255;
	m_pPlatform = pPlatform;

	// our component name
	m_strCompName = MakeNameFromPlatformAndType(*(m_pPlatform->GetName()), m_strType);

	// register ourselves with the config. manager
	g_pPrjcompmgr->RegisterProjType(this);
}

BOOL CProjType::FInit()
{
	BOOL retval = m_nIDType ? m_strUIType.LoadString(m_nIDType) : TRUE;
	VSASSERT(m_strUIType.GetLength() > 0, "UI type name must not be blank!");
	if (retval)
		m_strUICompName = MakeNameFromPlatformAndType(*(m_pPlatform->GetUIDescription()), m_strUIType);
	if( m_strUIType != "Makefile")
	{
		AddTool(szAddOnGeneric, BCID_Tool_CustomBuild);   
		AddTool(szAddOnGeneric, BCID_Tool_SpecialBuild);   
	}

	return retval;
}

void CProjType::AddTool(const TCHAR * szPckg, WORD idTool)
{
	CBuildTool * pTool = NULL;
	if (!g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId((TCHAR *)szPckg), idTool),
									   (CBldSysCmp *&)pTool))
		VSASSERT(FALSE, "Tool not in list!" );	// failed

	// now add it
	AddTool(pTool);
}

void CProjType::AddTool(WORD pckg, WORD idTool)
{
	CBuildTool * pTool = NULL;
	if (!g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(pckg, idTool), (CBldSysCmp *&)pTool))
		VSASSERT(FALSE, "Tool not in list!");	// failed

	// now add it
	AddTool(pTool);
}

void CProjType::AddTool(CBuildTool * pTool)
{
	// make sure we got a valid tool
	ASSERT_VALID(pTool);
	VSASSERT(pTool->IsKindOf(RUNTIME_CLASS(CBuildTool)), "Tool isn't a CBuildTool!");

	// don't add if already there
	if (m_ToolsList.Find(pTool) != (VCPOSITION)NULL)
		return;

	// FUTURE: remove this ordering when it doesn't matter
	// ie. whe we have a dependency based build engine
	// for the old v2 build engine CSchmoozeTool's must be last

	if (pTool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool)))
	{
		// Find location of CCustomBuildTool or CSpecialBuildTool
		VCPOSITION posSpecial = m_ToolsList.GetHeadPosition();
		while (NULL!=posSpecial)
		{
			// Save posLast which will be the position of pSpecailTool.
			VCPOSITION posLast = posSpecial;

			CBuildTool* pSpecialTool = (CBuildTool*)m_ToolsList.GetNext(posSpecial);
			VSASSERT(NULL!=pSpecialTool, "Failed to find special tool!");
			if (pSpecialTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)) ||
				pSpecialTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool)) )
			{
				// Set posSpecial to position of pSpecialTool and exit loop.
				posSpecial = posLast;
				break;
			}
		}

		if (NULL!=posSpecial)
			m_ToolsList.InsertBefore(posSpecial,pTool);
		else
			m_ToolsList.AddTail(pTool);
	}
	else if (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
	{
		m_ToolsList.AddTail(pTool);
	}
	else if (pTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool)))
	{
		m_ToolsList.AddTail(pTool);
	}
	else
		m_ToolsList.AddHead((CObject *)pTool);
	// FUTURE:
}

CProjType::~CProjType()
{
	CBuildTool * pTool;
	// remove tools, deleting any dynamic ones
	while (!m_ToolsList.IsEmpty())
	{
		pTool = (CBuildTool *)m_ToolsList.RemoveHead();
		if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
			delete pTool;
	}

	// de-register ourselves with the config. manager
	g_pPrjcompmgr->DeregisterProjType(this);
}

void CProjType::ClearUnknownTools()
{
	CBuildTool * pTool;
	// remove tools, deleting any dynamic ones
    VCPOSITION pos = m_ToolsList.GetHeadPosition();
    while (pos != NULL)
	{
		VCPOSITION posCurr = pos;
		pTool = (CBuildTool *)m_ToolsList.GetNext(pos);
		if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
		{
			delete pTool;
			m_ToolsList.RemoveAt(posCurr);
		}
	}
}

BOOL CProjType::SetDefaultDebugTargetOptions(CProject* pProject, CTargetItem * pTarget, BOOL fUseMFC)
{
	pProject->SetIntProp(P_ProjAppWizUseMFC, FALSE);

	// use MFC by default, except console application
	// NOTE: must do this after set default tool option !
	int iUseMFC = fUseMFC ? GetUseMFCDefault() : NoUseMFC;
	pProject->SetIntProp(P_ProjUseMFC, iUseMFC);
	pProject->SetIntProp(P_Proj_ComPlus, FALSE);

	return TRUE;
}

BOOL CProjType::SetDefaultReleaseTargetOptions(CProject* pProject, CTargetItem * pTarget, BOOL fUseMFC)
{
	return SetDefaultDebugTargetOptions(pProject, pTarget, fUseMFC);
}

CBuildTool * CProjType::GetToolFromCodePrefix(const TCHAR * pPrefix, int nPrefixLen)
{
	CBuildTool * pTool;
	VCPOSITION pos = m_ToolsList.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)	
	{
		pTool = (CBuildTool *)m_ToolsList.GetNext(pos);

		const TCHAR * pc = pTool->m_strToolPrefix;
		int len = lstrlen(pc);
		if (len && !_tcsnicmp(pPrefix, pc, min(nPrefixLen, len)))
			return pTool;
	}

	return (CBuildTool *)NULL;
}

void CProjType::PerformSettingsWizard(CProjItem * pItem, BOOL fUsingMFC)
{
	// ensure our configs are ok, ie. inform each tool
	// of this MFC state change

	// what is the config. mode?
	BOOL fDebug;

	pItem->GetIntProp(P_UseDebugLibs, fDebug);

	const CVCPtrList * plistTools = GetToolsList();
	
	// preserve the option handler and current slob for 'option engine'
	COptionHandler * popthdlrOld = g_pPrjoptengine->GetOptionHandler();
	CSlob * pslobOld = g_pPrjoptengine->GetPropertyBag();

	g_pPrjoptengine->SetPropertyBag(pItem);

	// reset
	if( pslobOld )
		g_pPrjoptengine->SetPropertyBag(pslobOld);
	if( popthdlrOld )
		g_pPrjoptengine->SetOptionHandler(popthdlrOld);
}

CString CProjType::MakeNameFromPlatformAndType(const CString & platform, const CString & type)
{
	return platform + _TCHAR(' ') + type;
}

CString CProjType::MakeNameFromPlatformAndType(const _TCHAR * platform, const _TCHAR * type)
{
	return (CString)platform + _TCHAR(' ') + type;
}

// CProjTypeUnknown
// ****************

CProjTypeUnknown::~CProjTypeUnknown()
{
}

BOOL CProjTypeUnknown::FInit()
{
	// Tools that we can use.  Tools are added later dynamically

	return CProjType::FInit();
}

// our tool option helper functions
void VPROJDeriveDefaultOptions(CString & strOption, UINT nIDCommon, UINT nIDMode, UINT nIDOption)
{
	CString	strPart;

	BOOL bOK = strOption.LoadString(nIDCommon);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	if (nIDMode != (UINT)-1)
	{
		bOK = strPart.LoadString(nIDMode);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
		strOption += _T(' '); strOption += strPart;
	}
	if (nIDOption != (UINT)-1)
	{
		bOK = strPart.LoadString(nIDOption);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
		strOption += _T(' '); strOption += strPart;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\prjoptn.cpp ===
//
// COptionTable
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop

#include "prjoptn.h"
#include "targitem.h"
#include "project.h"

IMPLEMENT_DYNAMIC(COptionHandler, CBldSysCmp);
IMPLEMENT_DYNAMIC(COptHdlrUnknown, COptionHandler);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CProjComponentMgr *g_pPrjcompmgr;

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptionList class
#pragma intrinsic(memcpy)

void COptionList::SetString(const TCHAR * pch)
{
	VSASSERT(pch != (const TCHAR *)NULL, "SetString cannot be called with NULL");

	// empty the old one
	Empty();

	const TCHAR * rgchJoin = (const TCHAR *)m_strJoin;

	//
	// Use rgchJoinAndSpace to eliminate spaces surrounding separators.  This is a quick
	// fix to prevent the usability problem of leading and trailing spaces in tokens. (Speed:49).
	//
	// NOTE: This fix will prevent the obscure but legal use of path names with leading spaces.
	//

	// allocate enough to copy grchJoin and append space.
	TCHAR * rgchJoinAndSpace = new TCHAR[_tcslen(rgchJoin)+2];
	_tcscpy(rgchJoinAndSpace,rgchJoin);
	_tcscat(rgchJoinAndSpace,_T(" "));

	// skip leading join chars and spaces.
	while (*pch != _T('\0') && _tcschr(rgchJoinAndSpace, (unsigned int)(int)*pch) != (TCHAR *)NULL)	
		pch++;	// join chars assumed to be SBC

	// anything to do?
	if (*pch == _T('\0'))
	{
		delete [] rgchJoinAndSpace;
		return; // do nothing
	}

	TCHAR chVal, chJoin = m_strJoin[0];
	VSASSERT(chJoin != _T('\0'), "Join character cannot be \0");

	BOOL fQuoted = FALSE;
	const TCHAR * pchWord = pch;
	size_t cch, cchWord = 0;
	do
	{
		chVal = *pch;

		// are we quoted?
		if (chVal == _T('"'))
			fQuoted = !fQuoted;

		// look for a non-quoted join char, or terminator
		if (chVal == _T('\0') || (_tcschr(rgchJoin, chVal) != NULL && (chVal == _T('\t') || !fQuoted)))
		{
			// skip any extra join chars (and spaces) with this one, ie. ' , '
			if (chVal != _T('\0'))
			{
				chVal = *(++pch);	// join chars assumed to be SBC
				while (chVal != _T('\0') && _tcschr(rgchJoinAndSpace, chVal) != NULL)
				{												
					pch++; chVal = *pch;	// join chars assumed to be SBC
				}
			}

			// Remove trailing blanks from pchWord.
			while (0 != cchWord && 0 == _tccmp( _tcsdec(pchWord,pchWord+cchWord),_T(" ")) )
				--cchWord;

			// do we have any word characters?
			if (cchWord != 0)	Append(pchWord, (UINT) cchWord);

			cchWord = 0;	// ready for start of next word
			pchWord = pch;
		}
		else
		{
			// skip non-join char
			cch = _tclen(pch);
			cchWord += cch; pch += cch;
		}
	}
	while (chVal != _T('\0'));

	delete [] rgchJoinAndSpace;
	return;
}

void COptionList::GetString(CString & str)
{
	TCHAR chJoin = m_strJoin[0];
	VSASSERT(chJoin != _T('\0'), "Join character cannot be \0");

	// allocate our buffer
	TCHAR * pch;
	if (!m_cchStr ||	// empty string?
		(pch = new TCHAR[m_cchStr]) == (TCHAR *)NULL
	   )
	{
		str = _TEXT(""); // in case of error
		return;
	}

	TCHAR * pchWord = pch;
	VCPOSITION pos = m_lstStr.GetHeadPosition();
	VSASSERT(pos != (VCPOSITION)NULL, "No options in option list!");
	for (;;)	// we'll break (more efficient!)
	{
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);

		int cch = poptel->cch;
		if( cch > 0 )
		{
		    memcpy(pchWord, poptel->pch, cch);
    
		    if (pos != (VCPOSITION)NULL)
			    pchWord[cch-1] = chJoin;	// join *not* terminate
		    else
			    break;	// terminate!
    
		    pchWord += cch;
		}
	}

	// return string and then delete our local buffer
	str = pch;
	delete [] pch;
}

void COptionList::Empty()
{
	// free-up our string memory
	VCPOSITION pos = m_lstStr.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);
		poptel->cref--;	// decr. the ref. count
		if (poptel->cref == 0)	// if zero, then free-up the element
			delete [] (BYTE *)poptel;
	}
	m_lstStr.RemoveAll();
	m_mapStrToPtr.RemoveAll();
}

void COptionList::Add(OptEl * poptel)
{
	// put this into our list
	poptel->cref++;	// bump. ref. count.
	VCPOSITION posOurWord = m_lstStr.AddTail((void *)poptel);
	m_cchStr += poptel->cch;

	// remember this for quick 'does string exist in list?' query
	// (in the case of dupes, we might nuke the old duplicate but that
	//  doesn't matter, it'll still solve its purpose)
	m_mapStrToPtr.SetAt(poptel->pch, (void *)posOurWord);
}

void COptionList::Append(const TCHAR * pch, int cch)
{
	OptEl * poptel = (OptEl *)new BYTE[sizeof(OptEl) + cch];
	if (poptel == (OptEl *)NULL)	return;

	// initialise with a ref. count of 1
	memcpy(poptel->pch, pch, cch);
	poptel->pch[cch] = _T('\0');
	poptel->cch = cch + 1;
	poptel->cref = 0;

	// can we add, ie. 
	// do we want to check for duplicates?
	if (!Exists(poptel->pch))
		Add(poptel);	// put this into our list
	else
		delete [] (BYTE *)poptel;	// duplicate
}

void COptionList::Append(COptionList & optlst)
{
	VCPOSITION pos = optlst.m_lstStr.GetHeadPosition();
	while (pos != NULL)
	{
		OptEl * poptel = (OptEl *)optlst.m_lstStr.GetNext(pos);
		if (!Exists(poptel->pch))
			Add(poptel);
	}
}

void COptionList::Common(COptionList & optlst)
{
	BOOL bOK = TRUE;
	VCPOSITION pos = m_lstStr.GetHeadPosition(), posCurrent;
	while (pos != (VCPOSITION)NULL)
	{
	 	posCurrent = pos;
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);
		if (!optlst.Exists(poptel->pch))
		{
			bOK = Delete(poptel, posCurrent);
			VSASSERT(bOK, "Failed to delete option!");
		}
	}
}

BOOL COptionList::Delete(OptEl * poptel, VCPOSITION posOurWord)
{
	// pre-loaded position to delete, or found this OptEl?
	if (!posOurWord && !m_mapStrToPtr.Lookup(poptel->pch, (void *&)posOurWord))
		return FALSE;	// no

	// retrieve our optel for this (might be the same)
	poptel = (OptEl *)m_lstStr.GetAt(posOurWord);

	m_lstStr.RemoveAt(posOurWord);
	(void) m_mapStrToPtr.RemoveKey(poptel->pch);

	m_cchStr -= poptel->cch;
	poptel->cref--;	// decr. the ref. count
	if (poptel->cref == 0)	// if zero, then free-up the element
		delete [] (BYTE *)poptel;

	return TRUE;
}

BOOL COptionList::Subtract(const TCHAR * pch)
{
	// does this exist?
	VCPOSITION posOurWord;
	if (!m_mapStrToPtr.Lookup(pch, (void *&)posOurWord))	return FALSE;	// no

	// remove this from our list
	BOOL bOK = Delete((OptEl *)m_lstStr.GetAt(posOurWord), posOurWord);
	VSASSERT(bOK, "Failed to remove item from option list!");

	return TRUE; // ok
}

BOOL COptionList::Subtract(COptionList & optlst)
{
	BOOL fFound = FALSE;

	VCPOSITION pos = optlst.m_lstStr.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		OptEl * poptel = (OptEl *)optlst.m_lstStr.GetNext(pos);
		// removed this from our list?
		if (Delete(poptel))
			fFound = TRUE;
	}

	return fFound;
}

void COptionList::Components(const TCHAR * pch, COptionList & optlstAdd, COptionList & optlstSub)
{
	COptionList optlst(_T(' '), FALSE);

	// set the option string to find components for
	optlst.m_strJoin = m_strJoin;
	optlst.SetString(pch);

	VCPOSITION pos = m_lstStr.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);
		// exist in us?
		if (!optlst.Delete(poptel))		// can do an addition comp.?
			optlstSub.Add(poptel);		// must be a subtract comp.
	}

	// return
	optlstAdd = optlst;
}

CDefOptionProp::CDefOptionProp(WORD idProp, int n, SUBTYPE st, OptType ot)
{
	m_pprop = (st == boolST) ? (CProp *) new CBoolProp(n) : (CProp *) new CIntProp(n);
	subtypeprop = st;
	m_opttype = ot;
}

CDefOptionProp::CDefOptionProp(WORD idProp, const char * sz, SUBTYPE st, OptType ot)
{
	m_pprop = (CProp *) new CStringProp(sz);
	subtypeprop = st;
	m_opttype = ot;
} 

#pragma function(memcpy)

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptionHandler class
COptionHandler::COptionHandler(CBuildTool * pBuildTool, COptionHandler * popthdlrBase)
{
	m_pAssociatedBuildTool = pBuildTool;
	m_popthdlrBase = (COptionHandler *)popthdlrBase;	// no base option handler

	// make sure we got a valid build tool
	ASSERT_VALID(m_pAssociatedBuildTool);

	// Initialize our hierachy depth
	m_cDepth = 0;

	// Init. our slob stack
	m_sStk = 0;

	// assoc. ourselves with the build tool
	m_pAssociatedBuildTool->SetOptionHandler(this);

	// our associated CSlobs
	m_pSlob = (CSlob *)NULL;
}

COptionHandler::COptionHandler
(
	const TCHAR * szPkg, WORD id,
	const TCHAR * szPkgTool, WORD idTool,
	const TCHAR * szPkgBase, WORD idBase
)
{
	// set our id.
	SetId(GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId(szPkg), id));

	// Initialize our hierachy depth
	m_cDepth = 0;

	// Init. our slob stack
	m_sStk = 0;

	// our associated build tool (if we have one)
	m_pAssociatedBuildTool = (CBuildTool *)NULL;
	if (idTool != 0)
	{
		if (!g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId(szPkgTool), idTool),
										   (CBldSysCmp *&)m_pAssociatedBuildTool))
			VSASSERT(FALSE, "Failed to find associated build tool");	// failed

		// make sure we got a valid build tool
		ASSERT_VALID(m_pAssociatedBuildTool);
		VSASSERT(m_pAssociatedBuildTool->IsKindOf(RUNTIME_CLASS(CBuildTool)), "Associated build tool must be a CBuildTool");

		// assoc. ourselves with the build tool
		if(m_pAssociatedBuildTool)
		{
			m_pAssociatedBuildTool->SetOptionHandler(this);
		}
	}

	// our base option handler (if we have one)
	m_popthdlrBase = (COptionHandler *)NULL;
	if (idBase != 0)
	{
		if (!g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId(szPkgBase), idBase),
										   (CBldSysCmp *&)m_popthdlrBase))
			VSASSERT(FALSE, "Failed to find option handler");	// failed

		// make sure we got a valid base option handler
		ASSERT_VALID(m_popthdlrBase);
		VSASSERT(m_popthdlrBase->IsKindOf(RUNTIME_CLASS(COptionHandler)), "Option handler must a COptionHandler");

		// calc. our depth
		COptionHandler * popthdlr = m_popthdlrBase;
		while (popthdlr)
		{
			m_cDepth++;	// inc. depth (we have at least 1)
			popthdlr = popthdlr->GetBaseOptionHandler();
		}

		// If we have a tool then reset the option handler
		// as our depth has now changed. The depth must be
		// in ssync with the option handler in the tool.
		if (idTool != 0)
			m_pAssociatedBuildTool->SetOptionHandler(this);
	}


	// our associated CSlobs
	m_pSlob = (CSlob *)NULL;
}

COptionHandler::~COptionHandler()
{
	WORD key;
	CDefOptionProp * pdefopt;

	// destroy all of our default props for the map
	for (VCPOSITION pos = m_mapDefOptions.GetStartPosition() ; pos != NULL;)
	{
		m_mapDefOptions.GetNextAssoc(pos, key, (void *&)pdefopt);
		delete pdefopt;
	}

	m_mapDefOptions.RemoveAll();

	VSASSERT(m_pdirtyProps, "Dirty props cannot be NULL");
	delete m_pdirtyProps;
	delete [] m_pStrListPropIds;
}

BOOL COptionHandler::Initialise()
{
	// convert all table logical props to actual props
	COptStr	* poptstr = GetOptionStringTable();
	while (poptstr->idOption != (UINT)-1)
	{
		for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS; cArgs++)
		{
			UINT * pidArg = poptstr->rgidArg + cArgs;
			if (*pidArg != (UINT)-1)
				*pidArg = MapLogical(*pidArg);
		}

		poptstr++;	// next
	}

	// create our default option map
	UINT nRange = GetOptPropRange();

	COptionLookup * poptlookup = GetOptionLookup();
	if ((poptlookup == (COptionLookup *)NULL) || GetOptionLookup()->FInit(GetOptionStringTable()))
	{
		// make the map hash size close to a prime no. matching the # of props.
		UINT nHash = (UINT)-1;
		if (nHash > 90)
			nHash = 89;
		else if (nHash > 60)
			nHash = 59;
		else if (nHash > 30)
			nHash = 29;
		if (nHash != (UINT)-1)
			m_mapDefOptions.InitHashTable(nHash);

		// fill the default option map
		CreateOptDefMap();
	}
	
	// create our dirty prop array
	m_pdirtyProps = new CVCByteArray; m_pdirtyProps->SetSize(nRange);
	m_pStrListPropIds = new UINT[nRange];	// max. required

	// create our cache of string list props
	m_cStrListPropIds = 0;
	UINT idPropMin, idPropMax; GetMinMaxOptProps(idPropMin, idPropMax);
	for (UINT idProp = idPropMin; idProp <= idPropMax; idProp++)
		if (IsListStrProp(idProp))
			m_pStrListPropIds[m_cStrListPropIds++] = idProp;

	return TRUE;	// ok
}

void COptionHandler::GetSpecialOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh)
{
	UINT nIDUnkOptB, nIDUnkStrB;
	GetSpecialLogicalOptProps(nIDUnkOpt, nIDUnkStr, optbeh);

	COptionHandler * popthdlr = GetBaseOptionHandler();

	if (nIDUnkOpt != (UINT)-1)
	{
		if (nIDUnkOpt == (UINT)NULL && popthdlr != (COptionHandler *)NULL)
			popthdlr->GetSpecialOptProps(nIDUnkOpt, nIDUnkStrB);
		else
			nIDUnkOpt = MapLogical(nIDUnkOpt);
	}
		
	if (nIDUnkStr != (UINT)-1)
	{
		if (nIDUnkStr == (UINT)NULL && popthdlr != (COptionHandler *)NULL)
			popthdlr->GetSpecialOptProps(nIDUnkOptB, nIDUnkStr);
		else
			nIDUnkStr = MapLogical(nIDUnkStr);
	}
}

//
// add default tool option properties to our map
//
void COptionHandler::AddDefStrProp(UINT idProp, const char * sz, OptType ot)
{
	m_mapDefOptions.SetAt((WORD)idProp, new CDefOptionProp((WORD)idProp, sz, strST, ot));
}

void COptionHandler::AddDefPathProp(UINT idProp, const char * sz, OptType ot)
{
	m_mapDefOptions.SetAt((WORD)idProp, new CDefOptionProp((WORD)idProp, sz, pathST, ot));
}

void COptionHandler::AddDefDirProp(UINT idProp, const char * sz, OptType ot)
{
	m_mapDefOptions.SetAt((WORD)idProp, new CDefOptionProp((WORD)idProp, sz, dirST, ot));
}

void COptionHandler::AddDefIntProp(UINT idProp, int n, OptType ot)
{
	m_mapDefOptions.SetAt((WORD)idProp, new CDefOptionProp((WORD)idProp, n, intST, ot));
}

void COptionHandler::AddDefBoolProp(UINT idProp, BOOL b, OptType ot)
{
	m_mapDefOptions.SetAt((WORD)idProp, new CDefOptionProp((WORD)idProp, b, boolST, ot));
}
																	
void COptionHandler::AddDefHexProp(UINT idProp, BOOL b, OptType ot)
{
	m_mapDefOptions.SetAt((WORD)idProp, new CDefOptionProp((WORD)idProp, b, hexST, ot));
}

GPT COptionHandler::GetDefIntProp(UINT idProp, int & val)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt)) return invalid;

	if (pdefopt->m_pprop->m_nType == string)
	{
		if (!ConvertFromStr(idProp, ((CStringProp *)pdefopt->m_pprop)->m_strVal, val))
			return invalid;
	}
	else
	{
		VSASSERT(pdefopt->m_pprop->m_nType == booln || pdefopt->m_pprop->m_nType == integer, "Can only call GetDefIntProp with bool or int props!");
		val = (pdefopt->m_pprop->m_nType == booln) ?
			   ((CBoolProp *)pdefopt->m_pprop)->m_bVal : ((CIntProp *)pdefopt->m_pprop)->m_nVal;
	}

	return valid;
}

GPT COptionHandler::GetDefStrProp(UINT idProp, CString & val)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt)) return invalid;

	if (pdefopt->m_pprop->m_nType == integer)
	{
		if (!ConvertToStr(idProp, ((CIntProp *)pdefopt->m_pprop)->m_nVal, val))
			return invalid;
	}
	else
	{
		VSASSERT(pdefopt->m_pprop->m_nType == string, "Can only call GetDefStrProp with string props!");
		val = ((CStringProp *)pdefopt->m_pprop)->m_strVal;
	}

	return valid;
}

BOOL COptionHandler::IsDefaultIntProp(UINT idProp, int & nVal)
{
	int nOurVal;
	return (GetDefIntProp(idProp, nOurVal) == valid) &&
		   (nOurVal == nVal);
}

BOOL COptionHandler::IsDefaultStringProp(UINT idProp, CString & strVal)
{
	CString strOurVal;
	if (GetDefStrProp(idProp, strOurVal) != valid)
		return FALSE;

   TCHAR * pch1 = (TCHAR *)(const TCHAR *)strOurVal;
   TCHAR * pch2 = (TCHAR *)(const TCHAR *)strVal;
   BOOL fEscaped = FALSE;
   TCHAR ch1, ch2;
   while ((ch1 = *pch1) != _T('\0') && (ch2 = *pch2) != _T('\0'))
   {
		// case insensitive compare (most likely for tool options)
   		if (_totupper(ch1) != _totupper(ch2))
   		{
			// treat a '\' and an '/' as equivalent if not escaped '\'
			// this is the case for common option args which are filenames
			if (fEscaped ||
				(ch1 != _T('\\') && ch1 != _T('/')) ||
				(ch2 != _T('\\') && ch2 != _T('/'))
			   )
	   			return FALSE;	// failed
   		}

		size_t cch = _tclen(pch1);
		pch1 += cch; pch2 += cch;

   		fEscaped = !fEscaped && (ch1 == _T('\\'));
   }

   return *pch1 == _T('\0') && *pch2 == _T('\0');
}

// conversion of int, oct,hex values into a text form
// FUTURE: I'd like to put this elsewhere, but where?
BOOL COptionHandler::ConvertToStr(UINT idProp, int nVal, CString & strVal)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt)) return FALSE;

	SUBTYPE subtype = pdefopt->subtypeprop;
	int nBase;
	if (subtype == hexST)
	{
		nBase = 16; strVal = "0x";
	}
	else if (subtype == octST)
	{
		nBase = 8; strVal = "0";
	}
	else
	{
		VSASSERT(subtype == intST, "Invalid subtype");
		nBase = 10; strVal = "";
	}

	char	szVal[34];	// max. of 33 chars

	// we use unsigned longs, no negative ints allowed
	strVal += _ultoa((unsigned long)(unsigned int)nVal, szVal, nBase);

	return TRUE;
}

// what terminators do we have?
// o zero terminator ('\0') for regular number strings
// o '>' terminator for option table number strings
#define IsStrTerminator(ch) (ch == _T('\0') || ch == _T('>'))

BOOL COptionHandler::ConvertFromStr(UINT idProp, const TCHAR * pchVal, int & nVal)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup((WORD)idProp, (void *&)pdefopt)) return FALSE;

	SUBTYPE subtype = pdefopt->subtypeprop;
	TCHAR * pch = (TCHAR *)pchVal;

	// strip the prefix
	if (subtype == hexST)
	{
		// we'll allow a leading 'x' (a hack BTW)
		if (*pchVal == _T('x') || *pchVal == _T('X'))
			pch++;
		else if (*pchVal == _T('0') && (*(pchVal+1) == _T('x') || *(pchVal+1) == _T('X')))
			pch += 2;
		else
			subtype = intST;	// no leading hex prefix, we'll assume decimal
	}
	else if (subtype == octST)
	{
		// we'll allow a leading '0' (a hack BTW)
		if (*pchVal == _T('0'))
			pch++;
	}
	else
	{
		VSASSERT(subtype == intST, "Invalid subtype");
		if (*pchVal == _T('+'))
			pch++;	// '+' is a single byte DBC
	}

	UINT iOut = 0;

	// init. the value
	nVal = 0;

	if (subtype == hexST)
	{
		for (; !IsStrTerminator(pch[iOut]); iOut++)
		{
			// check for well-formed hex number
			if (iOut > 7 || !isxdigit((unsigned char)pch[iOut]) || nVal & 0xf0000000)
			{
				// not a hex-digit or 
				// too many hex-digits (only 32-bit, ie. 8 digit hex-numbers supported) or
				// next shift would cause overflow!
				return FALSE;
			}

			nVal <<= 4;
			nVal += (toupper((unsigned char)pch[iOut]) -
					 (isdigit(toupper((unsigned char)pch[iOut])) ? '0' : 'A' - 10));
		}
	}
	else if (subtype == octST)
	{
		for (; !IsStrTerminator(pch[iOut]); iOut++)
		{
			// check for well-formed hex number
			if (iOut > 10 || !isdigit((unsigned char)pch[iOut]) ||
				pch[iOut] == _T('8') || pch[iOut] == _T('9') || nVal & 0xe0000000)
			{
				// we found '8' or '9'
				// too may oct-digits (only 32-bit, ie. 11 digit oct-numbers supported)
				// next shift would cause overflow!
				return FALSE;
			}

			nVal <<= 3;
			nVal += (toupper((unsigned char)pch[iOut]) - '0');
		}
	}
	else
	{
		VSASSERT(subtype == intST, "Invalid subtype");

		for (; !IsStrTerminator(pch[iOut]); iOut++)
		{
			// check for well-formed dec. number
			if (iOut > 9 || !isdigit((unsigned char)pch[iOut]))
			{
				// only want positive numbers
				// too may decimal digits (only 32-bit, ie. 10 digit dec-numbers supported)
				return FALSE;
			}

  			int nDigit = (toupper((unsigned char)pch[iOut]) - '0');
			
			// possible overflow?
			if ((nVal >= 429496729 && nDigit > 5) || (nVal > 429496730))
			{
				// number too big (only 32-bit, max. is 4,294,967,295)
				return FALSE;
			}

			nVal *= 10;
			nVal += nDigit;
		}
	}

	return TRUE;
}

void COptionHandler::MungeListStrProp
(
	UINT nIDProp,
	const CString & strVal,
	BOOL fAppend,
	char chJoin
)
{
	// get our comma-sep list
	CString str;
	m_pSlob->GetStrProp(nIDProp, str);
	COptionList optlst(str, chJoin);

	// perform munge
	optlst.Subtract((const TCHAR *)strVal);
	if (fAppend)
		optlst.Append((const TCHAR *)strVal, (int)strVal.GetLength());

	// set our 'munged' list
	optlst.GetString(str);
	m_pSlob->SetStrProp(nIDProp, str);
}

void COptionHandler::SetListStrProp
(
	CSlob * pSlob,
	UINT nIDExtraProp,
	CString & strVal,
	BOOL fInherit,
	BOOL fAnti,
	TCHAR chJoin
)
{
	// do nothing
	if (pSlob == (CSlob *)NULL)	return;

	CPropBag * pBag = pSlob->GetPropBag();

	// it is easy to set an anti prop
	if (fAnti)
	{
		pBag->SetStrProp(pSlob, ListStr_SubPart(nIDExtraProp), strVal);
	}
	else
	{
		// get the currently existing option list for our parent
		CString strParent; strParent = "";
		CSlob * pSlobParent = ((CProjItem *)pSlob)->GetContainerInSameConfig();
		if (pSlobParent != (CSlob *)NULL)
		{
			(void) GetListStrProp(pSlobParent, nIDExtraProp, strParent, fInherit, fAnti, chJoin);
			((CProjItem *)pSlobParent)->ResetContainerConfig();
		}

		// now figure out what we have subtracted or added
		COptionList optlstParent(strParent, chJoin);
		COptionList optlstAdd(chJoin), optlstSub(chJoin);

		// break into the component parts
		optlstParent.Components(strVal, optlstAdd, optlstSub);

		// we now have our add and subtract, convert back into strings
		CString strAddPart, strSubPart;
		optlstAdd.GetString(strAddPart);
		optlstSub.GetString(strSubPart);

		// set the properties
		pBag->SetStrProp(pSlob, ListStr_AddPart(nIDExtraProp), strAddPart);
		pBag->SetStrProp(pSlob, ListStr_SubPart(nIDExtraProp), strSubPart);
	}

	// inform people of a change to pseudo prop. nIDExtraProp
	pSlob->InformDependants(nIDExtraProp);
}

GPT COptionHandler::GetListStrProp
(
	CSlob * pOrigSlob,
	UINT nIDExtraProp,
	CString & strVal,
	BOOL fInherit,
	BOOL fAnti,
	char chJoin
)
{
	// do nothing?
	if (pOrigSlob == (CSlob *)NULL)	return invalid;

	// clear the buffer ready for concatenation
	strVal = "";
	
	// won't allow inheritance plus anti for string lists
	if (fAnti)	fInherit = FALSE;

	CSlob * pSlob = pOrigSlob;
	CObList obList;
	if (fInherit)
	{
		// we are a CProjItem and we are inheriting!
		// get the prop for each of our ancestor's in elder first order
		while (pSlob != (CSlob *)NULL)
		{
			obList.AddHead(pSlob);
			pSlob = ((CProjItem *)pSlob)->GetContainerInSameConfig();	// get our container
		}
	}
	else
	{
		// we can do a no-inheritance thing!
		obList.AddHead(pSlob);
	}

	// if we are a CProjItem and we are inheriting then do our own thing
	// ie. go through each CSlob in the container hierarchy and append each part to 
	// our options

	COptionList optlstVal(chJoin);
	POSITION pos = obList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		pSlob = (CSlob *)obList.GetNext(pos);

		// CProjGroups don't support tool options!
		if (!pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			CPropBag * pBag = pSlob->GetPropBag();
			CStringProp * pStrProp;

			// disable inheriting so we can do it!
			BOOL fPropInheritOld = ((CProjItem *)pSlob)->EnablePropInherit(FALSE);

			// using string lists
			COptionList optlstSub(chJoin);
			if ((pStrProp = (CStringProp *)pBag->FindProp(ListStr_SubPart(nIDExtraProp))) != (CStringProp *)NULL)
				optlstSub.SetString(pStrProp->m_strVal);

			// if *not* anti,
			// - append our 'add part'
			// - subtract our 'subtract part'
			// else
			// - add our 'subtract part'
			if (fAnti) /* anti-option */
			{
				CString strParent;
				CSlob * pSlobParent = ((CProjItem *)pSlob)->GetContainerInSameConfig();
				if (pSlobParent != (CSlob *)NULL)
				{
					(void) GetListStrProp(pSlobParent, nIDExtraProp, strParent, TRUE, FALSE);
					((CProjItem *)pSlobParent)->ResetContainerConfig();
				}

				// remove from the subtract option anything that
				// doesn't exist in our parent's list
				COptionList optlstParent(strParent, chJoin);
				optlstSub.Common(optlstParent);
				optlstVal.Append(optlstSub);
			}
			else /* not anti-option */
			{
				COptionList optlstAdd(chJoin);
				if ((pStrProp = (CStringProp *)pBag->FindProp(ListStr_AddPart(nIDExtraProp))) != (CStringProp *)NULL)
					optlstAdd.SetString(pStrProp->m_strVal);

				if (fInherit)	optlstVal.Subtract(optlstSub);	// no subtract, if no inherit
				optlstVal.Append(optlstAdd);
			}

			// re-set inheriting to old value
			((CProjItem *)pSlob)->EnablePropInherit(fPropInheritOld);
		}

		// only need to do this if we we'rere a got container
		// (ie. we're not the first node in this list)
		if (pSlob != pOrigSlob)
			((CProjItem *)pSlob)->ResetContainerConfig();
	}
	
	if (!fAnti && IsFakeProp(nIDExtraProp))
	{
		CString strAdd;

		SetSlob (pOrigSlob);
		GetDefStrProp (nIDExtraProp, strAdd);
		COptionList optlstAdd (strAdd);
		ResetSlob();

		optlstVal.Append (optlstAdd);
	} 
	// we need to convert our string list into a usable string
	// this will ensure all our join chars are chJoin
	optlstVal.GetString(strVal);
	
	return valid;
}

BOOL CompareProps(const CProp *, const CProp *); // Rvw: defined in projitem.cpp

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptHdlrUnknown class
// mechanism to allow for unknown option handlers

// we use this to retrieve a unique option property value each
// time an 'Uknown' option handler is CTORed
UINT g_nIDOptHdlrUnknown = 0;

// small option string table used to parse and generate uknown option lists
static COptStr g_poptstrOptHdlrUknown[] = {
	IDOPT_UNKNOWN_STRING,	"",		NO_OPTARGS, single,
	(UINT)-1,				NULL,	NO_OPTARGS, single
};

#define P_UnkHdkr_UnkStr_AddL	0
#define P_UnkHdlr_UnkStr_SubL	1

COptHdlrUnknown::COptHdlrUnknown(CBuildTool * pBuildTool) : COptionHandler(pBuildTool)
{
	// our base
	SetOptPropBase(PROJ_OPT_UNKNOWN + g_nIDOptHdlrUnknown);

	// we'll be using 2 off from this base
	// logical prop 0 is unknown string (add component)	== P_UnkHdkr_UnkStr_AddL
	// logical prop 1 is unknown string (subtract component) == P_UnkHdlr_UnkStr_SubL
	g_nIDOptHdlrUnknown += 2;

	VSASSERT(g_nIDOptHdlrUnknown <= 100, "Option handler list too long; bump up if it really needs to be bigger"); // 100 should be plenty (allow for 50 unknown tools)

	Initialise();
}	

void COptHdlrUnknown::GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh)
{
	ASSERT_VALID(m_pSlob);

	nIDUnkOpt = (UINT) -1;
	nIDUnkStr = (optbeh & OBAnti) ? P_UnkHdlr_UnkStr_SubL : P_UnkHdkr_UnkStr_AddL;
}

// retrieive our min. and max. option prop IDs
void COptHdlrUnknown::GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp)
{
	nIDMinProp = P_UnkHdkr_UnkStr_AddL; nIDMaxProp = P_UnkHdlr_UnkStr_SubL;
}

COptStr * COptHdlrUnknown::GetOptionStringTable()
{
	return (COptStr *)g_poptstrOptHdlrUknown;
}

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptHdlrMapper class
COptHdlrMapper::COptHdlrMapper()
{
}

COptHdlrMapper::~COptHdlrMapper()
{
}

// get the right mapper option handler (used by COptHdlrMapper::MapLogical())
void COptHdlrMapper::SetMapperOptionHandler(UINT cDepth)
{
	UINT cStep = m_popthdlr->GetDepth() - cDepth;  
	m_popthdlrMapper = m_popthdlr;
	while (cStep--)
		m_popthdlrMapper = m_popthdlrMapper->GetBaseOptionHandler();

	m_cDepth = cDepth;
}

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptionLookup class
// optimized lookup for the options
COptionLookup::~COptionLookup()
{
	WORD		keyDummy;
	CLookupEntry *	pentry;
	VCPOSITION pos = m_mapChToPtr.GetStartPosition();

	while (pos != (VCPOSITION)NULL)
	{
		 m_mapChToPtr.GetNextAssoc(pos, keyDummy, (void *&)pentry);
		 delete pentry;
	}
}

BOOL COptionLookup::FInit(COptStr * poptstr)
{
	COptStr	* poptstrOur = poptstr;

	//
	// create our lookup struct. for 'based on ID'
	//

	// what is the lowest ID we have in this table?
	m_idLowest = UINT_MAX;	// this is the highest
	while (poptstrOur->idOption != (UINT)-1)
	{
		// no need to do these!
		if (poptstrOur->idOption != IDOPT_UNKNOWN_OPTION &&
	    	poptstrOur->idOption != IDOPT_UNKNOWN_STRING)				
		{
			if (poptstrOur->idOption < m_idLowest)	m_idLowest = poptstrOur->idOption;
		}
		poptstrOur++;
	}

	// now using this lowest ID as the base create our
	// pointer array
	poptstrOur = poptstr;
	while (poptstrOur->idOption != (UINT)-1)
	{
		// no need to do these
		if (poptstrOur->idOption != IDOPT_UNKNOWN_OPTION &&
	    	poptstrOur->idOption != IDOPT_UNKNOWN_STRING)				
		{
			m_ptrIDArray.SetAtGrow(poptstrOur->idOption - m_idLowest, (void *)poptstrOur);
		}
		poptstrOur++;
	}

	// free up any extra
	m_ptrIDArray.FreeExtra();

	//
	// create our lookup struct. for 'based on char'
	//

	// init. our lookup char.
	m_chLookup = _T('\0');

	// now use an insertion sort to alphabetically sort our options (on first letter only)

	int iChArray = 0;
	unsigned char ch;

	poptstrOur = poptstr;

	while (poptstrOur->idOption != (UINT)-1)
	{
		// don't do this for our special ones!
		if (poptstrOur->idOption == IDOPT_UNKNOWN_OPTION ||
		    poptstrOur->idOption == IDOPT_UNKNOWN_STRING)
		{
			poptstrOur++;
			continue;
		}

		COptStr * poptstr;

		ch = (unsigned char)*(poptstrOur->szOption);

		iChArray = 0;
		while (iChArray <= m_ptrChArray.GetUpperBound())
		{
			poptstr = (COptStr *)m_ptrChArray[iChArray];

			// UNICODE ALERT:             
 			if ((unsigned char)*(poptstr->szOption) > ch)
				break; // break-out here

			iChArray++;
		}

		// insert at this position
		m_ptrChArray.InsertAt(iChArray, (void *)poptstrOur);
		poptstrOur++;
	}

	// free up any extra
	m_ptrChArray.FreeExtra();

	// now go through our list once more and for each first char.
	// put it's index into our map

	CLookupEntry * pentry = (CLookupEntry *)NULL;
	iChArray = 0; ch = _T('\0');	// last char.

	m_mapChToPtr.InitHashTable(53);	// prime no. >= 26 * 2 (alpha letters upper+lower)
	while (iChArray <= m_ptrChArray.GetUpperBound())
	{
		// don't do this for our special ones!
		if (poptstrOur->idOption == IDOPT_UNKNOWN_OPTION ||
		    poptstrOur->idOption == IDOPT_UNKNOWN_STRING)
		{
			iChArray++;
			continue;
		}

		COptStr * poptstr;

		poptstr = (COptStr *)m_ptrChArray[iChArray];

		// UNICODE ALERT:             
		// N.B. guaranteed to hit on first iteration
		if ((unsigned char)*(poptstr->szOption) != ch)
		{
			// fill in 'first char'
			pentry = new CLookupEntry;
			pentry->poptstr = poptstr;
			pentry->ioptstr = (UINT)-1;	// by default next is not available

			ch = (unsigned char)*(poptstr->szOption);
			m_mapChToPtr.SetAt((WORD)ch, (void *)pentry);
		}
		else if (pentry != (CLookupEntry *)NULL)
		{
			// fill in 'next char'
			pentry->ioptstr = iChArray;
			pentry = (CLookupEntry *)NULL;
		}

 		iChArray++;
	}

	return TRUE;
}

inline COptStr * COptionLookup::Lookup(UINT nID)
{
	// no need to do these!
	if (nID == IDOPT_UNKNOWN_OPTION ||
    	nID == IDOPT_UNKNOWN_STRING)
	{
		VSASSERT(FALSE, "Should not be doing lookup for unknown option or unknown string via Lookup!");
		return (COptStr *)NULL;
	}
	
	// must be within our bounds
	if ((nID >= m_idLowest) && (m_ptrIDArray.GetUpperBound() >= (int)(nID - m_idLowest)))
		return (COptStr *)m_ptrIDArray[nID - m_idLowest];

	return (COptStr *)NULL;	 // not found
}

inline COptStr * COptionLookup::LookupFirst(unsigned char ch, BOOL fCaseSensitive)
{
	CLookupEntry * pentry;

	if (m_mapChToPtr.Lookup((WORD)ch, (void *&)pentry) ||
		(!fCaseSensitive &&
		 m_mapChToPtr.Lookup((WORD)(isupper(ch) ? tolower(ch) : toupper(ch)), (void *&)pentry)))
	{
		// remember our char. plus first position
		m_chLookup = ch; m_ioptstr = pentry->ioptstr;
		return pentry->poptstr;
	}

	return (COptStr *)NULL;
}

inline COptStr * COptionLookup::LookupNext(INT_PTR cchLead)
{
	// no lookup entry, or no next one to lookup
	if (m_ioptstr == (UINT)-1)	return (COptStr *)NULL;

	COptStr * poptstr = (COptStr *)m_ptrChArray[m_ioptstr];

	// is this next one valid?
	TCHAR * pch = (TCHAR *)poptstr->szOption;
	TCHAR ch = *pch;
	if (ch == m_chLookup ||
		((isupper(ch) ? tolower(ch) : toupper(ch)) == m_chLookup))
	{
		if ((int)++m_ioptstr > m_ptrChArray.GetUpperBound())
			m_ioptstr = (UINT)-1;
	}
	else
		m_ioptstr = (UINT)-1;	// no longer available

	// check the lead char. minimum
	if (poptstr)
	{
		int cchThisLead = 0;
		while (*pch != _T('\0') && *pch != _T('%'))
		{
			cchThisLead++;
			pch++;	// N.B. no Kanjii in tool option specifications
		}

		if (cchLead > cchThisLead)
			poptstr = (COptStr *)NULL;
	}
                          
	return poptstr;
}

// implementation of the COptionTable class

COptionTable::COptionTable()
{
	// init. our arg property list index
	for (UINT i = 0 ; i < MAX_OPT_ARGS ; i++)
		m_rgProps[i].idArg = (UINT)-1;

	// our list string cache
	m_pBagCache = (CPropBag *)NULL;

	// our default option prefixes
	strPrefixes = "/-";

	// our arg. value allocated to be 64
	pchArgValue = new char [cchArgValue = 64];

	// set up our default option behaviour
	m_optbeh = OBNone;
}

COptionTable::~COptionTable()
{
	// delete our arg property list
	ClearPropValList();

	// delete our arg. value if we had one
	if (pchArgValue != (TCHAR *)NULL)
		delete [] pchArgValue;
}


// set the option handler given a package name and component pair
COptionHandler * COptionTable::SetOptionHandler(const TCHAR * szPkg, WORD idOptHdlr)
{
	// generate this option handler's component id
	DWORD bsc_idOptHdlr = GenerateComponentId(g_pPrjcompmgr->GenerateBldSysCompPackageId(szPkg), idOptHdlr);
	
	// look it up
	COptionHandler * popthdlr;
	if (!g_pPrjcompmgr->LookupBldSysComp(bsc_idOptHdlr, (CBldSysCmp * &)popthdlr))
		popthdlr = (COptionHandler *)NULL;

	VSASSERT(popthdlr->IsKindOf(RUNTIME_CLASS(COptionHandler)), "Option handler must be a COptionHandler");

	// set this option handler?
	if (popthdlr != (COptionHandler *)NULL)
		SetOptionHandler(popthdlr);

	// return it
	return popthdlr;
}

BOOL COptionTable::ParseString(CString & strOption, OptBehaviour optbeh)
{
	VSASSERT(m_popthdlr, "Option handler NULL!");

	// set our option flags
	m_optbeh = optbeh;

	// can't have set defaults for root CSlob's
	if (m_pSlob->GetContainer() == (CSlob *)NULL)
		m_optbeh &= ~OBSetDefault;

	// don't clear props for anti-options!
	if (m_optbeh & OBAnti)
		m_optbeh &= ~OBClear;

 	// set the prop. bag usage
	int idOldBag = ((CProjItem *)m_pSlob)->UsePropertyBag((m_optbeh & OBBasePropBag) ? BaseBag : CurrBag);

	// create our unknown option/string buffers
	CString	strUnknownOption, strUnknownString, strPart;
	UINT nIDUnknownOption, nIDUnknownString;
	m_popthdlr->GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, m_optbeh);

	// We want to append to any previously-read options/strings for this projitem
	// N.B. AppWizard depends on this behavior!

	// append any previous unknown strings/options if we are not clearing
	// ie. this might be multiple Add/Subtract lines in the makefile
	// (AppWizard generates .MAKs like this)
	if (!(m_optbeh & OBClear))
	{
		// don't want inheritance enabled for this
		OptBehaviour optbehOld = ((CProjItem *)m_pSlob)->GetOptBehaviour();
		((CProjItem *)m_pSlob)->SetOptBehaviour((OptBehaviour)(optbehOld & ~OBInherit));

		if (nIDUnknownOption != (UINT)-1 &&
			m_pSlob->GetStrProp(nIDUnknownOption, strUnknownOption) == valid && !strUnknownOption.IsEmpty()
		   )
			strUnknownOption += _T(' ');

		if (nIDUnknownString != (UINT)-1 &&
			m_pSlob->GetStrProp(nIDUnknownString, strUnknownString) == valid && !strUnknownString.IsEmpty()
		   )
			strUnknownString += _T(' ');

		((CProjItem *)m_pSlob)->SetOptBehaviour(optbehOld);
	}

	TCHAR chSrc, chPrefix = _T(' ');
	BOOL fReturn = TRUE;	// default is to pass

	// reset for this new option string
	strSrc = strOption; ichSrc = 0;

	// break out on parse completion, ie. found terminator (chSrc == _T('\0'))
	for (;;)
	{
		// skip any leading whitespace
		cchAdvSrc = 0; SkipWhiteSpace(); ichSrc += cchAdvSrc;

		// reset our advancement pointers
		cchAdvSrc = cchAdvSrcToArg = 0;

		chSrc = NewGetAt(strSrc, ichSrc);

		// parsed all of the source?
		if (chSrc == _T('\0'))	break;

		BOOL fStringTrash = TRUE;	// default is 'it is trash!'

		// are we on a option prefix?
		BOOL fHasPrefix = strPrefixes.Find(chSrc) != -1;
		if (fHasPrefix)
		{
			// remember this prefix
			chPrefix = chSrc;

			// yes, this is an option
			BOOL		fFoundMatch = FALSE;

			ichSrc++;	// move over prefix

			// our option to try and parse with
			COptStr * poptstr;

			// our current fast-lookup object (one for each option handler)
			COptionLookup * poptlookup;

			// for each of our option handler lookup objects do this
			COptionHandler * popthdlrOld = m_popthdlr;	// start off at ourselves

			while (!fFoundMatch && m_popthdlr != (COptionHandler *)NULL)
			{
				// cache some values from this option handler
				m_popthdlr->GetMinMaxOptProps(m_nPropMin, m_nPropMax);
				m_fCaseSensitive = m_popthdlr->IsCaseSensitive();

				// get our fast-lookup object
				poptlookup = m_popthdlr->GetOptionLookup();

				// yes, so try to match each of our options
				poptstr = poptlookup ?
						  poptlookup->LookupFirst(NewGetAt(strSrc, ichSrc), m_fCaseSensitive) : (COptStr *)NULL;

				// we share the lookup list with our base + derived option tables
				// is this a valid option string?
				INT_PTR cchMinLead = 0;
				while (!fFoundMatch && poptstr != (COptStr *)NULL)
				{
					fFoundMatch = MatchOption(poptstr);

					// did we find a match?
					if (fFoundMatch)
					{
						// yes, advance our source pointer
						ichSrc += cchAdvSrc;
					}
					else
					{
						if (cchAdvSrcToArg > cchMinLead)	cchMinLead = cchAdvSrcToArg;

						// no, get next option to try to match
						// (only get those options with *more* leading chars
						// we could match, ie. not /F% if we match /FI%)
						poptstr = poptlookup->LookupNext(cchMinLead);
					}

					cchAdvSrc = cchAdvSrcToArg = 0;	// reset our advancement pointers
				}

				m_popthdlr = m_popthdlr->GetBaseOptionHandler(); // get our base-handler
			}

			m_popthdlr = popthdlrOld;

			// did we find a match? ie. is this option trash?
			fStringTrash = !fFoundMatch;

			if (fStringTrash && nIDUnknownOption != (UINT)-1)
			{
				// collect together the unknown option
				strPart = ""; CollectOptionPart(strPart, FALSE, TRUE, FALSE, TRUE);

				// append part, terminate with a space
				AdjustBuffer(strUnknownOption);
				strUnknownOption += chPrefix;
				strUnknownOption += strPart;
				strUnknownOption += _T(' ');

				ichSrc += cchAdvSrc;	// advance our source pointer
				fStringTrash = FALSE;	// processed as 'option' string trash
			}
		}
		
		// is this just string trash?
		if (fStringTrash)
		{
			// collect together the trash (note: any collection of characters)
			strPart = ""; CollectOptionPart(strPart, FALSE, TRUE, TRUE, TRUE);
			ichSrc += cchAdvSrc;	// advance our source pointer

			// must have at least an unknown string unless we're Anti
			VSASSERT((nIDUnknownString != (UINT)- 1) || (m_optbeh & OBAnti), "Must have at least an unknown string unless we're Anti");
			if (nIDUnknownString != (UINT)-1)
			{
				// append part, terminate with a space
				AdjustBuffer(strUnknownString);
				if (fHasPrefix)	strUnknownString += chPrefix;
			  	strUnknownString += strPart;
				strUnknownString += _T(' ');
			}
		}
	}

	// set the unknown option property, and
	// set the unknown string property
	if (nIDUnknownOption != (UINT)-1)
		m_pSlob->SetStrProp(nIDUnknownOption, strUnknownOption);

	if (nIDUnknownString != (UINT)-1)
		m_pSlob->SetStrProp(nIDUnknownString, strUnknownString);

   	// reset the prop. bag usage
 	(void) ((CProjItem *)m_pSlob)->UsePropertyBag(idOldBag);

	return fReturn;	// success or failure?
}

BOOL COptionTable::CollectOptionPart
(
	CString &	strOut,			// the collected option part
	BOOL		fAlphaNumOnly,	// allow only alpha-numeric
	BOOL		fAllowPunct,	// allow punctuation
	BOOL		fAllowKanji,	// allow Kanji characters
	BOOL		fKeepQuotes,	// keep the quotes?
	CString		strDelim		// any delimiters (could be empty)
)
{
	BOOL			fQuoted, fEscaped;
	INT_PTR			ichFirst, cchAdvSrcOrig;
	TCHAR			* pchSrc, ch;

	// figure first char.
	ichFirst = ichSrc + cchAdvSrc; cchAdvSrcOrig = cchAdvSrc;

CollectOptionPart:

	fEscaped = FALSE;
	pchSrc = (TCHAR *)(const TCHAR *)strSrc + ichSrc + cchAdvSrc; 

	// move over the first quote if we have one
	fQuoted = (*pchSrc == _T('"'));
	if (fQuoted)
	{	
		// we're a quoted string
		pchSrc++; cchAdvSrc++;
		if (!fKeepQuotes)
		{
			ichFirst++; cchAdvSrcOrig++;
		}
	}

	// check for '/OPTION" /' where we are parsing
	// a partial typed string, we'll assume that whitespace
	// followed by an option delimiter is not a valid arg.
	INT_PTR ichLeadWhiteSpace = cchAdvSrc;	// assume whitespace for quoted

	// the end of the option part is
	// o whitespace (if not quoted) or null terminator
	// o a double-quote (if not escaped)
	// o a non alpha-numeric if fAlphaNumOnly = TRUE
	// o a punctuation character ~= '=' and ~= ',' not a flag prefix
	// o we hit a delimiter
	while ((ch = *pchSrc) != _T('\0'))
	{
		int cch = (int)_tclen(pchSrc); pchSrc += cch;

		// allow only alpha-numeric
		if (fAlphaNumOnly)
		{
			if (!isalnum(ch) && ch != _T('-') && ch != _T('+'))
				break;
		}
		// allow all alpha
		else if (isalpha(ch))
		{
			ichLeadWhiteSpace = 0;
		}
		else
		{
	#ifdef _MBCS
			if (!fAllowKanji && (_ismbbkana(ch) || _ismbblead(ch)))
				break;
	#endif

			// currently parsing a quoted string?
			if (fQuoted)
			{
				// yes
				// FUTURE: do we allow escaped 'quotes' in tool options?
				if (/*!fEscaped &&*/ ch == _T('"'))
					break;

				if (ichLeadWhiteSpace)
				{
					if (!_istspace(ch))
					{
						if (strPrefixes.Find(ch) != -1)
						{
							// back-up to the quote before the whitespace
							cchAdvSrc = ichLeadWhiteSpace;
							break;	// break here, we found '/OPTION"   /'
						}

				 		ichLeadWhiteSpace = 0;
					}
				}
			}
			else
			{
				//no
				// allow punctuation inside a quoted string!
				if (!fAllowPunct && ispunct(ch))
				{
					// FUTURE (matthewt): when we process '=' for defines correctly
					// then maybe we want to split the args, for now treat
					// as one arg.
					if (ch == _T('=') || ch == _T(','))
						break;

					if (strPrefixes.Find(ch) != -1)
						break;
				}

				if (_istspace(ch) || strDelim.Find(ch) != -1)
					break;	// break here, we found option delimiter (incls. whitespace)
			}
		}

		cchAdvSrc += cch;

		// do we have '\\' at the end of our string?
		if (fEscaped && fQuoted && ch == _T('\\') && *pchSrc == _T('"'))
			// skip back over the last one (ie. ignore it)
			cchAdvSrcOrig++;

		fEscaped = !fEscaped && ch == _T('\\');
	}

	INT_PTR cchOut = cchAdvSrc - cchAdvSrcOrig;

 	// eat the final quote if we have one
	if (fQuoted && ch == _T('"'))
	{
		// we're a quoted string
		cchAdvSrc++;
		if (fKeepQuotes)	cchOut++;
	}

	// do it for the 2nd half of an arg., eg. /D foo="bar"
	if (!fQuoted && ch == _T('='))
	{
		// we're an equals sign
		cchAdvSrc++;

		// keep the quotes (if they exist) for second half of assignment
		// (ignore return of FALSE - we don't care if empty)
		fKeepQuotes = TRUE;
		goto CollectOptionPart;	// next half
	}

	// have we actually found any characters?
	if (!cchOut)
	{
		// do we need to have a quoted empty string
		// in order to succeed?
		if ((m_optbeh & OBNeedEmptyString) && !fQuoted)
			return FALSE;

		strOut = "";
	}
	else
	{
		VSASSERT(ichFirst >= 0 && cchOut > 0, "CollectOptionPart parse error");
		strOut += strSrc.Mid((int)ichFirst, (int)cchOut);
	}

	return TRUE;	// got a match
}

void COptionTable::ExtractOptionArg(char * & pchExpr, size_t & cchExpr)
{
	char	chExpr = *pchExpr;
	TCHAR *	pch = NULL;
	size_t	cchArg = 0;

	// argument value pattern?
	//
	patArgValue = none;

	if (chExpr == _T('T') || chExpr == _T('F') ||
		chExpr == _T('t') || chExpr == _T('f'))
	{
		// booln arg
		pch = pchExpr++; cchArg++; // move over booln arg.
		patArgValue = booln;
	}
	else
	if (chExpr == _T('{') ||
		chExpr == _T('<'))
	{
		// what is our terminator char?
		TCHAR chTerm = chExpr == _T('{') ? _T('}') : _T('>');

		// choice or absolute arg
		pch = ++pchExpr; cchExpr--; // skip over '{' or '<'
		patArgValue = chExpr == _T('{') ? choice : absolute;

		char	chExpr;
		char	* pch2 = NULL;
									  
		// extract our '<...>' or '{...}' chunk
		chExpr = *pchExpr; pch2 = pchExpr;
		while (chExpr != chTerm)
		{
			chExpr = *pchExpr;	// we want' to stop just after the '}' or '>'!
			pchExpr = _tcsinc(pchExpr);
		}
		cchArg = pchExpr - pch2;
	}

	cchExpr -= cchArg;

	// ensure that the arg buffer is big enough
	// for debug purposes only, the option table arg
	// 'chunks' are static
	VSASSERT(cchArg < cchArgValue, "arg buffer not big enough");
	_tcsncpy(pchArgValue, pch, cchArg); 
	pchArgValue[cchArg] = _T('\0');	// terminate
}

void COptionTable::ExtractPart(char * & pchExpr, size_t & cchExpr, char * & pchPart, size_t & cchPart)
{
	UINT	cBrackets = 1;		// used to count brackets
	char	chExpr;

	cchPart = 0;	// init. the count of chars in the part
	pchPart = ++pchExpr; cchExpr--;	// skip the '[', and remember the position

	// search for the corresponding close bracket
	while (TRUE)
	{
		chExpr = *pchExpr;
		VSASSERT(chExpr != _T('\0'), "Must be able to find the part we want!");	// must be able to find one!

		if (chExpr == _T('['))	cBrackets++;	// bump up bracket count
		else
		if (chExpr == _T(']'))	cBrackets--;	// bump down bracket count

		// have we found the match?
		if (cBrackets == 0)
			break;	// yes, so break-out of here

		size_t	cch = _tclen(pchExpr);
		cchPart += cch; pchExpr += cch; cchExpr -= cch;
	}

	pchExpr++; cchExpr--;	// terminate on the ']'
}

BOOL COptionTable::MatchChoice(size_t &nChoiceMatch, char * pchChoice, UINT * pidArg)
{
	INT_PTR cchChoice;
	INT_PTR cchAdvSrcKeep;
	char * pchStart;

	// signal any kind of match
	nChoiceMatch = 0;	// no match

	for (size_t nChoice = 1 ; /* we'll break out! */ ; nChoice++ /* next choice */)
	{
		pchStart = pchChoice;

		// find our choice expression
		while (*pchChoice != _T('|') && *pchChoice != _T('}'))
			pchChoice = _tcsinc(pchChoice);

		// do we have a choice to match?
		cchChoice = (int)(pchChoice - pchStart);
		if (cchChoice)
		{
			cchAdvSrcKeep = cchAdvSrc;
			if (MatchExpression(pchStart, cchChoice, pidArg))
			{
				nChoiceMatch = nChoice;		// matched, or last resort match (cchAdvSrc == cchAdvSrcKeep)

				if (cchAdvSrc != cchAdvSrcKeep)	return TRUE;	// matched option

				// this choice matched no chars, ie. was purely arg matching
				// we will use this nChoice if no other option matches
			}
			cchAdvSrc = cchAdvSrcKeep; 	// no match
		}
		// this is an empty option
		// we will use this nChoice if no other option matches
		else
			nChoiceMatch = nChoice;	// last resort match	

		// skip over the '|'
		if (*pchChoice++ == _T('}'))
			return (nChoiceMatch != 0);	// no match possible?
										// ran out of choices, maybe last resort choice?
	}

	return TRUE;
}

BOOL COptionTable::MatchExpression(const char * pchExprConst, size_t cchExpr, UINT * pidArg)
{
	size_t cch;
	UINT cArgs = 0;
	char * pchExpr = (char *)pchExprConst;
	unsigned char chExpr; // expression character

	CString	strOut; // output string
    
    char * pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our source                                        
                               
	// have we finished this pattern? we will break out on failure (return)
	while (cchExpr != 0)
	{
  		chExpr = *pchExpr;

 		// do we have an argument specified?
		if (chExpr == _T('%'))
		{
			// increment the number of args. found
			// first?
			if (++cArgs == 1)
				cchAdvSrcToArg = cchAdvSrc;	// remember the adv. src. to arg.

			cch = _tclen(pchExpr);
			pchExpr += cch; cchExpr -= cch; // move over arg. spec.
			chExpr = *pchExpr;

			// argument value?
			ExtractOptionArg(pchExpr, cchExpr);

			// argument index
			//
			UINT	iArg;		// our arg. index
			UINT	idArgProp;	// our arg. property
								  
			chExpr = *pchExpr;
			VSASSERT(isdigit(chExpr), "Must be an arg. index!");	// must be an arg. index!
			iArg = chExpr - '1';
			idArgProp = pidArg[iArg];	// retrieve this arg's property #
			cch = _tclen(pchExpr);
 			pchExpr += cch; cchExpr -= cch;	// move over arg. index

			BOOL fFake = m_popthdlr->IsFakeProp(idArgProp);
			BOOL fAlwaysShowDefault = m_popthdlr->AlwaysShowDefault(idArgProp);

			// what type of property is this?
			// we want to match in the source the property value
			switch (m_popthdlr->GetDefOptionType(idArgProp) /* property type */)
			{
				case ::integer:
				{
					int nVal;

					// do we want to match an choice?
					if (patArgValue == choice)
					{
						size_t uVal;

						// match a choice in the string
						if (!MatchChoice(uVal, pchArgValue, pidArg))
						{
							// for 0th choices we might have used subtract
							if (!(m_optbeh & OBAnti) || _tcsncmp(pchSrc, _TEXT("<none>"), 6))
								return FALSE;	// no match, failed to find choice

							cchAdvSrc += 6;	// skip over

							// consume this source
							pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        

							uVal = 0;	// 0th
						}

						nVal = (int)uVal;
					}
					// do we want to set an absolute?
					else if (patArgValue == absolute)
					{
						// convert this absolute into a numeric to suit
						// the subtype of this integer 
					   	BOOL bOK = m_popthdlr->ConvertFromStr(idArgProp, pchArgValue, nVal);
						VSASSERT(bOK, "Failed to convert prop from option string!");
					}
					else
					{
						// just match an integer in the string
						if (!CollectOptionPart(strOut, TRUE) || strOut.IsEmpty())
							return FALSE;	// no match, failed to collect

						// got a match, consume this source
						pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        

						// do the conversion from a string into an integer
						// based on the sub-type
					   	if (!m_popthdlr->ConvertFromStr(idArgProp, strOut, nVal))
						{
							// couldn't convert due to bad numeric format
							// use existing value if one exists!
							CProp * pProp = m_pSlob->GetPropBag()->FindProp(idArgProp);
							if (pProp == (CProp *)NULL)
							{
								AddToPropList(iArg, idArgProp, NULL);
								break;	// doesn't exist, ignore ie. no pass, no fail
							}
							nVal = ((CIntProp *)pProp)->m_nVal;
						}
					}

					// don't set defaults, or fake props
					BOOL fSet;
					if (fFake)
						fSet = fAlwaysShowDefault;
					else
						fSet = fAlwaysShowDefault || (m_optbeh & OBSetDefault);

					if (!fSet && m_popthdlr->IsDefaultIntProp(idArgProp, nVal))
						break;

					CIntProp *	ppropInt = new CIntProp(nVal);
					AddToPropList(iArg, idArgProp, ppropInt);
					break;
				}
				
				case ::booln:
				{
					BOOL	bVal;
					BOOL	fSoftBool = FALSE;

					// do we want to match an choice?
					if (patArgValue == choice)
					{	
						size_t	nVal;

						// match a choice in the string
						if (!MatchChoice(nVal, pchArgValue, pidArg))
							return FALSE;	// no match, failed to find choice

						// got a match, consume this source
						pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source 
						                                       
						// match an choice in the string
						bVal = (nVal == 1) ? FALSE : TRUE;	// convert to a booln
					}
					else
					{
						VSASSERT(patArgValue == booln, "Illegal arg value");
						// just set the property based in the booln arg value
						bVal = *pchArgValue == _T('T');
						if( !bVal )
						{
							fSoftBool = (*pchArgValue == _T('t'));
							bVal = fSoftBool;
						}
					}

					// don't set defaults, or fake props
					BOOL fSet;
					if (fFake)
						fSet = fAlwaysShowDefault;
					else
						fSet = fAlwaysShowDefault || (m_optbeh & OBSetDefault);

					if (!fSet && m_popthdlr->IsDefaultBoolProp(idArgProp, bVal))
						break;

					// do we need to invert the integer value?
					// FUTURE: don't do this for softbool values (remove when per-prop remove in .PRJ)
					if ((m_optbeh & OBAnti) && !fSoftBool) 
						bVal = !bVal;	// invert

					CBoolProp *	ppropBool = new CBoolProp(bVal);
					AddToPropList(iArg, idArgProp, ppropBool);
					break;
				}

				case ::string:
				{
					if (!CollectOptionPart(strOut))
						return FALSE;	// no match, failed to collect

					// got a match, consume this source
					pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        

					// don't set defaults, or fake props
					BOOL fSet;
					if (fFake)
						fSet = fAlwaysShowDefault;
					else
						fSet = fAlwaysShowDefault || (m_optbeh & OBSetDefault);

					if (!fSet && m_popthdlr->IsDefaultStringProp(idArgProp, strOut))
						break;

					CStringProp * ppropString = new CStringProp(strOut);
					AddToPropList(iArg, idArgProp, ppropString);
					break;
				}
					 
				case ::longint:	// not yet needed!
				case ::number:
					break;

				default:
					VSASSERT(FALSE, "Unhandled expression char");
					break;
			}
		}
		// do we have an open bracket (optional part)?
		else if (chExpr == _T('['))
		{
			char * pchPart;
			size_t cchPart;

			// extract the optional part
			ExtractPart(pchExpr, cchExpr, pchPart, cchPart);

			// don't bother matching empty optional parts
			if (cchPart != 0)
			{
				NoChangedPropValList();	// reset, so we recognise args to back-out
				if (MatchExpression(pchPart, cchPart, pidArg))
					// got a match, consume this source
				    pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        
				else
					// back-out args set in no match optional part
					ClearPropValList(TRUE);
			}

			// continue, this is matching an optional part
		}
		// is this a 'just' whitespace candidate?
		// only do this for 'single whitespace expressions'
		else if (cchExpr == 1 && chExpr == _T(' '))
		{
			size_t cchAdvSrcOrig = cchAdvSrc;

			SkipWhiteSpace();	// skip any  whitespace
			pchExpr++; cchExpr--;	// skip over this space in the expression
			pchSrc += (cchAdvSrc - cchAdvSrcOrig);	// advance our source
		}
		// else should just try to match this
		else
		{
			if (_tccmp(pchExpr, pchSrc) != 0)	// not a char. match
			{
				unsigned char chSrc = *pchSrc;

				// did this not match 'cos of only case insensitivity
				if (m_fCaseSensitive || (toupper(chExpr) != toupper(chSrc)))
					return FALSE;
			}

			cch = _tclen(pchExpr);
			pchExpr += cch; cchExpr -= cch;

			cch = _tclen(pchSrc);
			pchSrc += cch; cchAdvSrc += cch;
		}

		// continue trying to match source and expression
	}
	return TRUE;	// successful match
}

BOOL COptionTable::MatchOption(COptStr * poptstr)
{
	BOOL	fMatched;

	// what type of option it this? single or multiple?
 	m_fMultipleGen = (poptstr->type == multiple);

	// can we match this expression?
	fMatched = MatchExpression(poptstr->szOption, _tcslen(poptstr->szOption), poptstr->rgidArg);

	// must terminate in a whitespace or EOS
	unsigned char	chTerm = NewGetAt(strSrc, ichSrc + cchAdvSrc);

	fMatched = fMatched && (chTerm == _T('\0') || _istspace(chTerm));
	
	if (fMatched)	
		// yes, so set up these properties in our bag
		SetPropValListInPropBag(poptstr->rgidArg);

	// clear our property-value list (may be empty)
	ClearPropValList();

	return fMatched;
}

void COptionTable::ClearPropValList(BOOL fOnlyThoseChanged)
{
	for (WORD cArgs = 0 ; cArgs < MAX_OPT_ARGS ; cArgs++)
		if (m_rgProps[cArgs].idArg != (UINT)-1 && 
		    (!fOnlyThoseChanged || m_rgProps[cArgs].fChanged)
		   )
		{
			if (m_rgProps[cArgs].pProp)
				CProp::DeleteCProp(m_rgProps[cArgs].pProp);
			m_rgProps[cArgs].idArg = (UINT)-1;
		}
}

BOOL RemoveMultiOptionFromString(CString *strOptList, CString strOpt)
{
	CString strSub, strNew = _T("");
	CString str = *strOptList;
	int	 pos = -1;
	BOOL bFound = FALSE;

	while(!str.IsEmpty())
	{
		pos = str.Find(",");
		if(pos)
		{
			strSub = str.Left(pos);
			str = str.Right(str.GetLength() - pos - 1);
		}
		else
		{
			strSub = str;
			str = _T("");
		}
		if(strSub != strOpt)
		{
			if(!strNew.IsEmpty())
				strNew += _T(',');
			strNew += strSub;
		}
		else
			bFound = TRUE;
	}

	if(bFound)
		*strOptList = strNew;
	return bFound;
}

void COptionTable::SetPropValListInPropBag(UINT * poptarg)
{
	CPropBag * 	ppropbag = m_pSlob->GetPropBag();
	CProp * ppropExisting; 

	for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS ; cArgs++, poptarg++)
	{
		UINT	idArg = m_rgProps[cArgs].idArg;
		BOOL	fExists = (ppropExisting = ppropbag->FindProp(*poptarg)) != (CProp *)NULL;

		// has this arg. been set?
		if (idArg == (UINT)-1)
		{
			UINT	idOptArg = *poptarg;

			// should we clear the arg? we need to do this for args that exist for the option
			// but which have not been set
			if (idOptArg != (UINT)-1)
			{
				// yes, clear it, but for multiple options just append an empty prop. value
				if (m_fMultipleGen)
				{
					// get the prop value
					CString	strVal;

					// set to retrieve subtract if anti-option
					BOOL fPropAntiOld = ((CProjItem *)m_pSlob)->EnableAntiProps(m_optbeh & OBAnti);

					// get the existing comma sep. list of args if *we* have one
					// ie. we only want to do this for *our* propbag (not the parents)
					if (ppropbag->FindProp(ListStr_AddPart(idOptArg)) ||
						ppropbag->FindProp(ListStr_SubPart(idOptArg)))
					{
						(void) m_pSlob->GetStrProp(idOptArg, strVal);

						// append a sep
						strVal += _T(',');
					}

					// append a comma sep
					m_pSlob->SetStrProp(idOptArg, strVal); 

					(void) ((CProjItem *)m_pSlob)->EnableAntiProps(fPropAntiOld);
				}
				// remove this prop if we have one
				else if (fExists)
				{
					// delete this from the current property bag (it exists!)
					ppropbag->RemovePropAndInform(idOptArg, m_pSlob);
				}
			}

			continue;
		}

		CProp *	pprop = m_rgProps[cArgs].pProp;

		// if we have NULL here then ignore
		// we want to use the previous existing value (if one exists)
		if (pprop == (CProp *)NULL)
			continue;

		// dirty this prop we are about to set

		// for string list props we need to delete the components
		// *not* the pseudo prop
		if (m_fMultipleGen && m_popthdlr->IsListStrProp(idArg))
		{
			m_popthdlr->DirtyArg(ListStr_AddPart(idArg) - m_nPropMin);
			m_popthdlr->DirtyArg(ListStr_SubPart(idArg) - m_nPropMin);
		}
		else
		{
			m_popthdlr->DirtyArg(idArg - m_nPropMin);
		}

		// what is the property type?
		// don't set property values if current property has this value!
		switch (pprop->m_nType /* property type */)
		{	
			case ::integer:
				VSASSERT(!m_fMultipleGen, "Integer can only handle single");	// only for single options
				if (!fExists ||
					(((CIntProp *)pprop)->m_nVal != ((CIntProp *)ppropExisting)->m_nVal)
				   )
				{
					m_pSlob->SetIntProp(idArg, ((CIntProp *)pprop)->m_nVal); 
				}
				break;

			case ::booln:
				VSASSERT(!m_fMultipleGen, "Booln can only handle single");	// only for single options
				if (!fExists ||
					(((CBoolProp *)pprop)->m_bVal != ((CBoolProp *)ppropExisting)->m_bVal)
				   )
				{
					m_pSlob->SetIntProp(idArg, ((CBoolProp *)pprop)->m_bVal); 
				}
				break;

			case ::string:
			{
				// if we are a multiple option, append using comma seps.
				if (m_fMultipleGen)
				{	
					// the option sep. list
					CString	strVal;

					// set to retrieve subtract if anti-option
//					BOOL fPropAntiOld = ((CProjItem *)m_pSlob)->EnableAntiProps(m_optbeh & OBAnti);

					// get the existing comma sep. list of args if *we* have one
					// and append to that
					if (m_pSlob->GetStrProp(idArg, strVal) == valid)
					{
						if (!strVal.IsEmpty())
							strVal += _T(',');
						if (!(m_optbeh & OBAnti))
							strVal += ((CStringProp *)pprop)->m_strVal;
						else
						{	//remove from m_strVal
						
							if(RemoveMultiOptionFromString(&strVal, ((CStringProp *)pprop)->m_strVal))
							{	
							// 1) Find prop in	m_strVal
							// if (found)
							//		remove from m_strVal
				
							}
							else
							{
								BOOL fPropAntiOld = ((CProjItem *)m_pSlob)->EnableAntiProps(m_optbeh & OBAnti);
							//	set antiprop
							//  do oldway
							//  set back anti
								if (m_pSlob->GetStrProp(idArg, strVal) == valid)
								{
									if (!strVal.IsEmpty())
										strVal += _T(',');
									strVal += ((CStringProp *)pprop)->m_strVal;
									m_pSlob->SetStrProp(idArg, strVal); 
									(void) ((CProjItem *)m_pSlob)->EnableAntiProps(fPropAntiOld);
									break;
								}
							}
						}

						m_pSlob->SetStrProp(idArg, strVal); 
					}

//					(void) ((CProjItem *)m_pSlob)->EnableAntiProps(fPropAntiOld);
				}
				else
				{
					// anti-option only for multiple string lists
					if (m_optbeh & OBAnti)
						break;

					if (!fExists ||
						(((CStringProp *)pprop)->m_strVal != ((CStringProp *)ppropExisting)->m_strVal)
					   )
					{
						m_pSlob->SetStrProp(idArg, ((CStringProp *)pprop)->m_strVal); 
					}
				}

				break;
			}

			case ::longint:	// not yet needed!
			case ::number:
				break;

			default:
				VSASSERT(FALSE, "Unhandled option type");
				break;
		} 
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projdep.h ===
///////////////////////////////////////////////////////////////////////////////
//
//	CProjectDependency
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

class CProjectDependency : public CProjItem
{
	DECLARE_SERIAL (CProjectDependency)

public:
	CProjectDependency();
	virtual ~CProjectDependency(); 

	virtual GPT GetStrProp(UINT nIDProp, CString & val);

	// hooks to add as a dependent on the target we reference so we track changes in target name
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	 	
	virtual BOOL UsesSourceTool() { return TRUE; }

	virtual void FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem);
 
	// .MAK reading
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);
	__inline CTargetItem * GetProjectDep() { return m_pTarget; }

//protected:
	
	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

private:
	// Makefile reading/writing support
	static const TCHAR *pcDepPrefix;

	BOOL IsDepComment(CObject*& pObject);

	CTargetItem*	m_pTarget;	// Target we depend upon
	CString m_strName;			// Name of target
	DECLARE_SLOBPROP_MAP()
};

class CProjDepInfo {
public:
	CProjectDependency *	pProjDep;
	CString					strProject;
	CString					strTarget;
};

extern CVCPtrList g_lstprojdeps;

CProjDepInfo * AddDep(CProjectDependency *pProjectDep);
BOOL RemoveDep(CProjectDependency *pProjDep);
BOOL RemoveAllReferences(CString strProj);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projdep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//	CProjectDependency
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "targitem.h"
#include "project.h"
#include "bldrcvtr.h"
#include "makread.h"
#include "projdep.h"

IMPLEMENT_SERIAL (CProjectDependency, CProjItem, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define theClass CProjectDependency
BEGIN_SLOBPROP_MAP(CProjectDependency, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

CVCPtrList g_lstprojdeps;

CProjDepInfo * AddDep(CProjectDependency *pProjectDep)
{
	// Could be coming from the Undo slob. If so, it wont be in the list.
	CProjDepInfo *pDepInfo;
	CString strProject;
	CString strSub;
	pProjectDep->GetProject()->GetName(strProject);
	pProjectDep->GetStrProp(P_ProjItemName, strSub);

	VCPOSITION pos = g_lstprojdeps.GetHeadPosition();
	BOOL bFound = FALSE;
	while (pos != NULL)
	{
		pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->pProjDep == pProjectDep )
		{
			bFound = TRUE;
			break;
		}
	}
	if( bFound == FALSE )
	{
		pDepInfo = new CProjDepInfo;
		pDepInfo->pProjDep = pProjectDep;
		pDepInfo->strTarget = strSub;
		pDepInfo->strProject = strProject;
		g_lstprojdeps.AddTail( pDepInfo );
		return pDepInfo;
	}
	return NULL;
}

BOOL RemoveAllReferences( CString strProj ) 
{
	VCPOSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		VCPOSITION oldPos = pos;
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->strProject == strProj || pDepInfo->strTarget == strProj )
		{
			g_lstprojdeps.RemoveAt( oldPos );
			delete pDepInfo;
		}
	}
	return FALSE;
}

BOOL RemoveDep(  CProjectDependency *pProjDep  )
{
	VCPOSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		VCPOSITION oldPos = pos;
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->pProjDep == pProjDep )
		{
			g_lstprojdeps.RemoveAt( oldPos );
			delete pDepInfo;
			return TRUE;
		}
	}
	return FALSE;
}

CProjectDependency::CProjectDependency() 
{
	m_pTarget = NULL;
}

CProjectDependency::~CProjectDependency()
{
	DeleteContents();

	// Make sure that if we are really going away
	// that if there is an active project (we could
	// be on the clipboard) does not have us on its
	// dependancy list
	CProject* pProject = GetProject();
	if (pProject)
		pProject->RemoveDependant(this);

	// now remove the pointer from the global collection
	VCPOSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->pProjDep == this ){
			pDepInfo->pProjDep = NULL;
			break;
		}
	}
}

GPT CProjectDependency::GetStrProp(UINT idProp, CString& val)
{
	// is this a fake prop?
	
	if (idProp == P_ProjItemName)	// yes
	{
		if (m_pTarget != NULL)
			m_strName = val = m_pTarget->GetTargetName();
		else
			val = m_strName;  // as read from project file
		return valid;
	}
	
 	// no, pass on to base class
	return CProjItem::GetStrProp(idProp, val);
}

// Target name prefix written to the makefile
const TCHAR *CProjectDependency::pcDepPrefix = _TEXT("Project_Dep_Name ");
 
// Reads target name comments and sets up the config recs accordingly. Also
// registers the target with the target manager.
BOOL CProjectDependency::IsDepComment(CObject *&pObject)
{
	// If this is not a makefile comment then give up now!
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
		return FALSE;

	CMakComment *pMc = (CMakComment*) pObject;

	// Skip over any initial white space
	TCHAR *pc, *pcEnd;
	pc = pMc->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// We should have the target name prefix at the front of
	// the comment
	if (_tcsnicmp(pcDepPrefix, pc, _tcslen(pcDepPrefix)) != 0)
		return FALSE;

	// Ok, we found the prefix so skip over it.
	pc += _tcslen(pcDepPrefix);
	SkipWhite(pc);

	// Get the quoted fileset name
	if (!GetQuotedString(pc, pcEnd))
		return FALSE;

	*pcEnd = _T('\0');


	CProjDepInfo * pProjDepInfo = new CProjDepInfo;
	pProjDepInfo->pProjDep = this;

	CString strProject = GetTargetName();
	int iDash = strProject.Find(_T(" - "));
	if (iDash > 0)
		strProject = strProject.Left(iDash);
	pProjDepInfo->strProject = strProject;

	CString strName = pc;
	pProjDepInfo->strTarget = strName;
	m_strName = strName;

	g_lstprojdeps.AddTail(pProjDepInfo);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjectDependency::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
//	Read in this item and  a makfile reader. 
//
	CObject *pObject = NULL;
	CPath cpFile;
	
	TRY
	{
		// The next element better be a comment marking our start:
		pObject = mr.GetNextElement ();
		ASSERT (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)));

		delete pObject;

		m_cp = EndOfConfigs;
	   	for (pObject = mr.GetNextElement(); !IsEndToken(pObject); pObject = mr.GetNextElement())
	   	{
			// set the target we reference (m_pcr) by reading in P_TargetRefName
			if (IsDepComment(pObject)){
				delete (pObject); pObject = NULL;
				continue;
			}
 
			// make sure we set which target this target reference is contained in
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				// read in the configuration information
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}

	   		delete (pObject); pObject = NULL;
		}				 
	}
	CATCH ( CException, e)
	{
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	// do the rest of the move
	(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

	return TRUE;	// success
}

// Return a container-less, symbol-less, clone of 'this'
CSlob* CProjectDependency::Clone()
{
	CSlob * pClone = CProjItem::Clone(); // call base class to create clone
	VSASSERT(pClone->IsKindOf (RUNTIME_CLASS (CProjItem)), "Can only clone into a CProjItem!");
	
	// Set up the clones target reference
	CString strTarget;
	GPT gptRet = GetStrProp(P_TargetRefName, strTarget);
	VSASSERT(gptRet == valid, "Failed to get P_TargetRefName!");
	BOOL bSuccess = pClone->SetStrProp(P_TargetRefName, strTarget);
	VSASSERT(bSuccess, "Failed to set P_TargetRefName!");

 	return pClone;
}

BOOL CProjectDependency::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// removing from a project?
	if (fFromPrj)
	{
		// the item is being removed from the project
		// (most likely to be moved onto the undo slob)
		// so we need to remove us as a dependant of the project
		GetProject()->RemoveDependant(this);
	}

	// do the base-class thing
	return CProjItem::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged);
}

BOOL CProjectDependency::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// moving into a project?
	if (fToPrj)
	{
		// we are being added to the project
		// so we need to add ourselves as a dependant of the project
		GetProject()->AddDependant(this);
		
		(VOID)::AddDep(this);
	}
	if( pContainer == NULL )
	{
		// find it on the list and remove it.
		::RemoveDep(this);
	}

	// do the base-class thing
	return CProjItem::PostMoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged);
}

///////////////////////////////////////////////////////////////////////////////
void CProjectDependency::FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem)
{
	if (fo & flt_ExcludeProjDeps)
		fAddItem = FALSE;
	else
		fAddItem = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projitem.cpp ===
//	PROJITEM.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop

#include "optncplr.h"
#include "targitem.h"
#include "dirmgr.h"
#include "project.h"
#include "makread.h"
#include "projdep.h"

IMPLEMENT_SERIAL (CProjItem, CProjSlob, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CFileItem, CProjItem, SLOB_SCHEMA_VERSION)
IMPLEMENT_DYNAMIC (CConfigurationRecord, CObject)

extern BOOL ConvertMacros(CString& rstrVal);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
const LPCTSTR g_pszUIDllName = _T("vcprojcnvtd.dll");
#else
const LPCTSTR g_pszUIDllName = _T("vcprojcnvt.dll");
#endif

// this variable is part of a MAJOR HACK involving the BuildCmds Macro and
// unsupported platforms in makefiles. find a betterr work around for this problem ASAP
// olympus bug #1103 for details.
CBuildTool *g_pBuildTool=NULL;

// 04-10-96 jimsc This is used by SuckMacro, but ReadMakeFile has to set it in project.cpp
CBuildTool *g_pLastTool = NULL;

//
// Helper function that test for a container being non-NULL or that the
// undo slob is recording(which mean that the undo slob could be the container)
//
static __inline BOOL CouldBeContainer(CSlob* pContainer)
{
	return (NULL!=pContainer || theUndoSlob.IsRecording());
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------- CConfigurationRecord ------------------------------
//
///////////////////////////////////////////////////////////////////////////////
CConfigurationRecord::CConfigurationRecord
(
	const CConfigurationRecord * pBaseRecord, 
	CProjItem * pOwner
) :
// increase the size of the hash table for project-level,
// these bags have the most props, to a more efficient value
// than the default of 17 and reduce for CfileItems and CDepItems
  m_BasePropBag(pOwner->GetBagHashSize()),
  m_CurrPropBag(pOwner->GetBagHashSize())
{
	// Owner project item
	m_pOwner = pOwner;

	// Record linkage
	m_pBaseRecord = pBaseRecord;
	#ifdef _DEBUG
	if (pBaseRecord) ASSERT_VALID (pBaseRecord);
	#endif
	// default is *NO* attributes which are dirty
	m_iAttrib = 0;
	m_fAttribDirty = TRUE;

	// Config rec is not valid for the owning item by default
	m_fValid = FALSE;

	// Actions list is allocated on demand..
	m_pActions = (CBuildActionList *)NULL;

	// TODO: REVIEW: don't new this until we need it !
	m_pClonePropBag = new CPropBag(pOwner->GetBagHashSize());

	m_pToolsMap = NULL;
}

CConfigurationRecord::~CConfigurationRecord()
{
	// delete our actions and actions list
	if (m_pActions)
	{
		VCPOSITION pos = m_pActions->GetHeadPosition();
		while (pos != (VCPOSITION)NULL)
		{
			CBuildAction * pAction = (CBuildAction *)m_pActions->GetNext(pos);

			// must not be bound, unless it's an unknown tool
			// we *just* directly added these, so we can *just* directly
			// delete them, no CBuildAction::UnAssign or CBuildAction::Assign used!
			VSASSERT(pAction->m_pTool == (CBuildTool *)NULL ||
				   pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)), "The only tools left assigned to actions at this point should be derived from CUnknownTool");
			delete pAction;
		}
		delete m_pActions;
	}
	
	if( m_pClonePropBag )
		delete m_pClonePropBag;
	
	if (m_pToolsMap)
	{
		VCPOSITION pos = m_pToolsMap->GetHeadPosition();
		while (pos)
		{
			CToolsMap * pToolMap = (CToolsMap * )m_pToolsMap->GetNext(pos);
			delete pToolMap;
		}
		delete m_pToolsMap;
	}
}

CBuildActionList * CConfigurationRecord::GetActionList()
{
	if (m_pActions == (CBuildActionList *)NULL)
		m_pActions = new CBuildActionList;
	return m_pActions;
}

BOOL CConfigurationRecord::IsSupported()
{
	CProjType * pprojtype;
	
	if (!g_pPrjcompmgr->LookupProjTypeByName(GetOriginalTypeName(), pprojtype))
		return FALSE;

	return pprojtype->IsSupported();
}

CString &CConfigurationRecord::GetConfigurationName () const
{
	VSASSERT (m_pBaseRecord, "Base record not set properly on config record");
	const CPropBag * pBag = ((CConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjConfiguration);
	VSASSERT (pProp, "Failed to find P_ProjConfiguration property");
	VSASSERT (pProp->m_nType == string, "P_ProjConfiguration property not a string as expected!");
	return pProp->m_strVal;
}

void CConfigurationRecord::GetProjectName (CString &strProject) const
{
	VSASSERT (m_pBaseRecord, "Base record not set properly on config record");
	CProject * pProject = (CProject *)m_pBaseRecord->m_pOwner;
	VSASSERT(pProject, "Project not set properly on config record");
	const CPropBag * pBag = ((CConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjConfiguration);
	VSASSERT (pProp, "Failed to find P_ProjConfiguration property");
	VSASSERT (pProp->m_nType == string, "P_ProjConfiguration property not a string as expected!");

	strProject = (const char *)((CStringProp *)pProp)->m_strVal;
	int iDash = strProject.Find(_T(" - "));
	if (iDash > 0)
  	  strProject = strProject.Left(iDash);

	return ;
}

void CConfigurationRecord::GetConfigurationDescription ( CString &strDescription ) const
{
	VSASSERT (m_pBaseRecord, "Base record not set properly on config record");
	const CPropBag * pBag = ((CConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjConfiguration);
	VSASSERT (pProp, "Failed to find P_ProjConfiguration property");
	VSASSERT (pProp->m_nType == string, "P_ProjConfiguration property not a string as expected!");
	strDescription = pProp->m_strVal;

    strDescription = (const char *)((CStringProp *)pProp)->m_strVal;
	int nSep = strDescription.Find(_T(" - "));
	strDescription = strDescription.Right(strDescription.GetLength() - nSep - 3 );

	return;
}

CString &CConfigurationRecord::GetOriginalTypeName() const
{
	VSASSERT (m_pBaseRecord, "Base record not set properly on config record");
	const CPropBag * pBag = ((CConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	// format is '<Platform> <ProjType>'
	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjOriginalType);
	VSASSERT (pProp, "Failed to find P_ProjConfiguration property");
	VSASSERT (pProp->m_nType == string, "P_ProjConfiguration property not a string as expected!");

	return pProp->m_strVal;
}

BOOL CConfigurationRecord::GetExtListFromToolName(CString strTool, CString *strExt)
{
	if (m_pToolsMap == NULL)
		return FALSE;

	CToolsMap * pToolMap;
	for (VCPOSITION pos = m_pToolsMap->GetHeadPosition(); pos != NULL;)
	{
		pToolMap = (CToolsMap *)m_pToolsMap->GetNext(pos);

		if(pToolMap->IsExternalTool())
			continue; //return FALSE;
		if(strTool == ((CBuildTool *)(pToolMap->m_pBuildTool))->GetToolName())
		{
			*strExt = pToolMap->m_strExtensions;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CConfigurationRecord::SetExtListFromToolName(CString strTool, CString strExt)
{
	if (m_pToolsMap == NULL)
		return FALSE;

	CToolsMap * pToolMap;
	for (VCPOSITION pos = m_pToolsMap->GetHeadPosition(); pos != NULL;)
	{
		pToolMap = (CToolsMap *)m_pToolsMap->GetNext(pos);

		if(pToolMap->IsExternalTool())
			continue; // return FALSE;
		if(strTool == ((CBuildTool *)(pToolMap->m_pBuildTool))->GetToolName())
		{
			pToolMap->m_strExtensions = strExt;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CConfigurationRecord::SetBuildToolsMap()
{
	CProjType* pProjType = m_pOwner->GetProjType();
	if (pProjType != NULL)
	{

		CBuildTool * pTool;
		const CVCPtrList * plistTools = pProjType->GetToolsList();
		for (VCPOSITION pos = plistTools->GetHeadPosition(); pos != NULL;)
		{
			pTool = (CBuildTool *)plistTools->GetNext(pos);
			CToolsMap * pToolMap = new CToolsMap();
			pToolMap->m_pBuildTool = pTool;
			pTool->GetDefaultExtList(&(pToolMap->m_strExtensions));
			if (m_pToolsMap == NULL)
				m_pToolsMap = new CVCPtrList();
			m_pToolsMap->AddTail(pToolMap);
		}
	}
	return TRUE;
}

int CConfigurationRecord::GetTargetAttributes()
{
	BOOL			fForce = FALSE;

	// do we need to force ourselves into the same config.?
	if (m_pOwner->GetActiveConfig() != this)
	{
		m_pOwner->ForceConfigActive(this);
 		fForce = TRUE;
	}

	// are our target attributes dirty?
	if (m_fAttribDirty)
	{
		m_iAttrib = 0;

		// for an internal project
		// cache our target attributes
		CProjType * pProjType = m_pOwner->GetProjType(); VSASSERT(pProjType != (CProjType *)NULL, "Invalid project type!");
		m_iAttrib = pProjType->GetAttributes();
		CPlatform *pPlatform = pProjType->GetPlatform();
		if (!pPlatform->IsSupported() || !pPlatform->GetBuildable())
			m_iAttrib &= ~TargetIsDebugable;        

		m_fAttribDirty = FALSE;
	}


	if (fForce)
		m_pOwner->ForceConfigActive();

	return m_iAttrib;	// return the attributes
}

void CConfigurationRecord::BagCopy(UINT idBagSrc, UINT idBagDest, UINT nPropMin, UINT nPropMax, BOOL fInform)
{
	CPropBag * pBagSrc = GetPropBag(idBagSrc), * pBagDest = GetPropBag(idBagDest);
	VSASSERT(pBagSrc != NULL, "Cannot copy from a NULL bag!");
	VSASSERT(pBagDest != NULL, "Cannot copy to a NULL bag!");

	CProp * ppropSrc, * ppropDest;

	// need to make sure we are in the right config in case of inform
	if (fInform)
		m_pOwner->SetManualBagSearchConfig(this);

	// copy from our source to the destination the props in
	// our range by either adding or replacing prop. values
	POSITION pos = pBagSrc->GetStartPosition();
	while (pos != NULL)
	{
		BOOL fDifferent = TRUE;

		UINT id;
		// get the next prop from our source
		pBagSrc->GetNextAssoc(pos, id, ppropSrc);

		// make range checkes against minimum and maximum props
		if ((nPropMin != -1 && id < nPropMin) ||
			(nPropMax != -1 && id > nPropMax))
			continue;

		// get the equiv. in our destination
		ppropDest = pBagDest->FindProp(id);

		// make sure the types are the same if found in both bags
		VSASSERT(ppropDest == (CProp *)NULL || ppropSrc->m_nType == ppropDest->m_nType, "Property type mismatch found");

		// do the copy (FUTURE: no Undo)
		switch (ppropSrc->m_nType)
		{
			case integer:
				if (ppropDest != (CProp *)NULL)
				{
					// exists in destination, just do in-place set and check for equivalence
					fDifferent = ((CIntProp*)ppropDest)->m_nVal != ((CIntProp*)ppropSrc)->m_nVal;
					((CIntProp*)ppropDest)->m_nVal = ((CIntProp*)ppropSrc)->m_nVal;
				}
				else
				{
					// doesn't exist, add the prop.
					pBagDest->AddProp(id, new CIntProp(((CIntProp*)ppropSrc)->m_nVal));
				}
				break;

			case string:
				if (ppropDest != (CProp *)NULL)
				{
					// exists in destination, just do in-place set and check for equivalence
					fDifferent = ((CStringProp*)ppropDest)->m_strVal != ((CStringProp*)ppropSrc)->m_strVal;
					((CStringProp*)ppropDest)->m_strVal = ((CStringProp*)ppropSrc)->m_strVal;
				}
				else
				{
					// doesn't exist, add the prop.
					pBagDest->AddProp(id, new CStringProp(((CStringProp*)ppropSrc)->m_strVal));
				}
				break;
		
			default:
				VSASSERT(FALSE, "Unhandled prop type");
				break;
		}

		if (fInform && fDifferent)
		{
			m_pOwner->InformDependants(id);

			// got an option handle for this?
			COptionHandler * popthdlr = g_pPrjcompmgr->FindOptionHandler(id);
			if (popthdlr != (COptionHandler *)NULL)
			{
				popthdlr->SetSlob(m_pOwner);

				// integer changes
				if (ppropSrc->m_nType == integer)
					popthdlr->OnOptionIntPropChange(id, ((CIntProp*)ppropSrc)->m_nVal);

				// string changes
				else if (ppropSrc->m_nType == string)
					popthdlr->OnOptionStrPropChange(id, ((CStringProp*)ppropSrc)->m_strVal);

				// reset the option handler CSlob
				popthdlr->ResetSlob();
			}
		}
	}

	// remove from our destination all those props. not copied
	pos = pBagDest->GetStartPosition();
	while (pos != NULL)
	{
		UINT id;
		// get the next prop in our destination
		pBagDest->GetNextAssoc(pos, id, ppropSrc);

		// make range checkes against minimum and maximum props
		if ((nPropMin != -1 && id < nPropMin) ||
			(nPropMax != -1 && id > nPropMax))
			continue;

		// not in our source bag, so delete (it exists!)
		if (!pBagSrc->FindProp(id) && pBagDest->FindProp(id))
		{
			if (fInform)
			{
				// m_pOwner->InformDependants(id);

				// review: should this also be deferred until after prop is changed

				// got an option handle for this?
				COptionHandler * popthdlr = g_pPrjcompmgr->FindOptionHandler(id);
				if (popthdlr != (COptionHandler *)NULL)
				{
					popthdlr->SetSlob(m_pOwner);

					// integer changes
					if (ppropSrc->m_nType == integer)
						popthdlr->OnOptionIntPropChange(id, 0);

					// string changes
					else if (ppropSrc->m_nType == string)
						popthdlr->OnOptionStrPropChange(id, "");

					// reset the option handler CSlob
					popthdlr->ResetSlob();
				}
			}

			pBagDest->RemoveProp(id);

			// defer inform until after prop is actually changed
			if (fInform)
			{
				m_pOwner->InformDependants(id);
			}
		}
	}

	// restore to previous state
	if (fInform)
		m_pOwner->ResetManualBagSearchConfig();
}

#ifdef _DEBUG
void CConfigurationRecord::AssertValid() const
{
	// should point to top level record
	VSASSERT(m_pBaseRecord == m_pBaseRecord->m_pBaseRecord, "Config record should point to top level record");
}

void CConfigurationRecord::Dump (CDumpContext &DC) const
{
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------	CProjItem ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
#define theClass CProjItem
BEGIN_SLOBPROP_MAP(CProjItem, CProjSlob)
END_SLOBPROP_MAP()
#undef theClass

const CString & CProjItem::GetTargetName() { return GetTarget()->GetTargetName(); }

void CProjItem::DeleteContents()
{
	// delete all its children
	// NOTE: We cannot use a normal GetHeadPosition, GetNext loop here,
	// as removing one item may result in removing another item in the list
	// This situation occurs when we remove a file item and this results in
	// the removal of the corresponding dependency container
	CObList * pContentList = GetContentList();
	if (pContentList)
	{
		while (!pContentList->IsEmpty())
		{
 	    	// any contained slobs should also be items..
			CProjItem * pItem = (CProjItem *) pContentList->GetHead();
			VSASSERT(pItem != NULL, "NULL pointer in content list!");
			ASSERT_VALID(pItem);
			RemoveDependant(pItem);

			// delete
			pItem->MoveInto(NULL);
		}
	}

	// delete our configuration records
	int nIndex, nSize = GetPropBagCount();
	for (nIndex = 0; nIndex < nSize; nIndex++)
		delete (CConfigurationRecord *)m_ConfigArray[nIndex];

	m_ConfigArray.RemoveAll();
	m_ConfigMap.RemoveAll();

	m_pActiveConfig = NULL;
}
///////////////////////////////////////////////////////////////////////////////
CProjItem::CProjItem ()	: m_ConfigMap (3)
{
	m_ConfigMap.InitHashTable(3);

	// our current 'owner' project is undefined currently!
	m_pOwnerProject = (CProject *)NULL;

	// our current 'owner' target is undefined currently!
	m_pOwnerTarget = (CTargetItem *)NULL;

	// by default prop search uses inheritance
	// by default prop search uses default
	// by default we are not anti-options
	// no manual bag find
	m_optbeh = OBInherit | OBShowDefault;

	// by default we are not figuring a dep!
	m_fPropsDepFigure = FALSE;

	// default is outside config switches
	m_cp = EndOfConfigs;

	// no active or forced configuration
	m_pActiveConfig = m_pForcedConfig = NULL;

	// no manual config rec. by deault
	m_pManualConfigRec = NULL;

	// not getting a list string using ::GetStrProp
 	m_fGettingListStr = FALSE;

	// Default is to use the current property bag for each config. rec.
	m_idBagInUse = CurrBag;

    m_pArchyHandle = NULL;
}

///////////////////////////////////////////////////////////////////////////////
CProjItem::~CProjItem()
{
}

///////////////////////////////////////////////////////////////////////////////
CTargetItem * CProjItem::GetTarget()
{
	// do we have one cached?
	if (m_pOwnerTarget != (CTargetItem *)NULL)
		return m_pOwnerTarget;

	// no, so try to find it given the active target
	CConfigurationRecord * pcr = GetActiveConfig();
	CProject * pProject = GetProject();
	if (pcr == (CConfigurationRecord *)NULL || pProject == (CProject *)NULL)
		return (CTargetItem *)NULL;

	// the active one
	return pProject->GetTarget(pcr->GetConfigurationName());
}
///////////////////////////////////////////////////////////////////////////////
// Removes project item from view 
BOOL CProjItem::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	return TRUE;	// success
}

// Alters the containment and fixes configs. of item,
// but not 'officially' in or out-of project
BOOL CProjItem::MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	BOOL fRefreshDeps = FALSE;

	CTargetItem * pTarget = GetTarget();
	CProject * pProject = GetProject();

	// moving from a project?
	if ((fFromPrj) && (pProject != NULL))
	{
 
		VSASSERT(pTarget != NULL, "Project item not connected to a target!  Deep trouble.");

		// set the project to into each valid config. for this target
		const CVCPtrArray * pCfgArray = pTarget->GetConfigArray();
		INT_PTR iSize = pCfgArray->GetSize();
		for (int i = 0; i < iSize; i++)
		{
			CConfigurationRecord * pcr = (CConfigurationRecord *)pCfgArray->GetAt(i);

			if ( pcr->IsValid())
			{
				// FUTURE: optimize by only doing this if its moving to a new target...
				
				// un-assign actions to each of this items configurations
				// *OR* if we going into an undo then un-bind actions from the build instance
				if (fPrjChanged || (!CouldBeContainer(pContainer) && !fToPrj))
					CBuildAction::UnAssignActions(this, (CVCPtrList *)NULL, pcr, CouldBeContainer(pContainer));
				else if (!fToPrj)
					CBuildAction::UnBindActions(this, (CVCPtrList *)NULL, pcr, TRUE /* CouldBeContainer(pContainer) */ );

			}
		}

		// removing item altogether from project?
		// and project not being created/destroyed?
		if ((!fToPrj || fPrjChanged) && GetProject()->m_bProjectComplete)
		{
			// if we're removing a project item from the project we need to 
			// isolate it from the container
			IsolateFromProject(); // Rvw: overkill for drag & drop
		}
	}	

	// fix our 'cached' containment
	// so that any notifies from below work
	// moved to a project?
	if (fToPrj)
	{
		// Search for our new 'owner' project correctly
		CSlob * pSlob = pContainer;
		CTargetItem * pNewTarg = NULL;
		while (!pSlob->IsKindOf(RUNTIME_CLASS(CProject)))
		{
			// can we find the target 'owner'?
			if (pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)))
				pNewTarg = (CTargetItem *)pSlob;

			// must be able to find a project 'owner'
			pSlob = pSlob->GetContainer();
			VSASSERT(pSlob != (CSlob *)NULL, "No owner!");
		}

		if ((pNewTarg==NULL) && (IsKindOf(RUNTIME_CLASS(CTargetItem))))
			pNewTarg = (CTargetItem *)this; // hey, we are the target

		// Cache our notion of the 'owner' project
		SetOwnerProject((CProject *)pSlob, pNewTarg);
	}
	// else from a project

	// alter our containment
	// if pContainer == NULL then this will *delete*
	// ourselves, do *not* access object data from here
	// on out in this situation
	if (!CSlob::SetSlobProp(P_Container, pContainer))
		return FALSE;

	// fix our 'cached' containment
	// so that any notifies from below work
	// moved to a project?
	if (fToPrj)
	{
		// moving to a project by removing from a project or undo'ing?
		// yes, then match the new container's configurations.
		// (This may require the deletion of some)
		if (fFromPrj || fPrjChanged || (pOldContainer == NULL) || pOldContainer == &theUndoSlob)
			CloneConfigs((const CProjItem *)pContainer);
	}
	// else from a project into something else
	else if (theUndoSlob.IsRecording())
	{
		// *Not* a project item -> *No* owner project -> *No* owner target,
		// most likely contained in the undo CSlob, or some such thing
		VSASSERT((pContainer == (CSlob *)NULL) || pContainer == &theUndoSlob || pContainer->IsKindOf(RUNTIME_CLASS(CClipboardSlob)), "Bad state");
		SetOwnerProject(NULL, NULL);
	}

	return TRUE;	// success
}

// Make item item 'officially' in or out-of project    
BOOL CProjItem::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// moving into the project?
	if (fToPrj)
	{
		CTargetItem * pTarget = GetTarget();
		CProject * pProject = GetProject();

		VSASSERT(pTarget!=NULL, "No target?  Deep trouble.");
		VSASSERT(pProject!=NULL, "No project?  Deep trouble.");
		if ((pTarget==NULL) || (pProject==NULL))
			return FALSE; // can happen with bogus makefile

		// Set the project to into each valid config. for this target
		const CVCPtrArray * pCfgArray = pTarget->GetConfigArray();
		INT_PTR iSize = pCfgArray->GetSize();
		for (int i = 0; i < iSize; i++)
		{
			CConfigurationRecord * pcr = (CConfigurationRecord *)pCfgArray->GetAt(i);

			if ( pcr->IsValid())
			{
				// assign actions to each of the items configurations or
				// *OR* if we coming in from an undo then re-bind to the build instance
				if (((!CouldBeContainer(pOldContainer)) && (!fFromPrj)) || fPrjChanged)
					CBuildAction::AssignActions(this, (CVCPtrList *)NULL, pcr, CouldBeContainer(pOldContainer));

				else if (!fFromPrj)
					CBuildAction::BindActions(this, (CVCPtrList *)NULL, pcr, CouldBeContainer(pOldContainer));

			}
		}
	}

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::GetMoniker(CString& cs) 
{
	GetStrProp (P_ProjItemName, cs);
}
///////////////////////////////////////////////////////////////////////////////
int CProjItem::CompareMonikers (CString& str1, CString& str2)
{
	return _tcsicmp ((const char *)str1, (const char *)str2);
}	
///////////////////////////////////////////////////////////////////////////////
const CPath *CProjItem::GetFilePath() const
{
	return NULL;
} 
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetFile (const CPath *pPath, BOOL bCaseApproved /* = FALSE */)
{
	TRACE ( "CProjItem::SetFile() called for non-File class %s\n", 
												GetRuntimeClass()->m_lpszClassName );
	return FALSE;
}

// FUTURE: move these into bldrfile.cpp
const TCHAR *CProjItem::EndToken = _TEXT ("End");
const TCHAR *CProjItem::pcFileMacroName = _TEXT ("SOURCE");
const TCHAR *CProjItem::pcFileMacroNameEx = _TEXT ("$(SOURCE)"); 	

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
const CProjItem::PropWritingRecord CProjItem::nMakeFileProps[] = {
	{P_ProjUseMFC,	 			_TEXT("Use_MFC"),				integer, PropRead | PropWrite | All},
	{P_UseDebugLibs,	 		_TEXT("Use_Debug_Libraries"),	integer, PropRead | PropWrite | All},
	{P_OutDirs_Target, 			_TEXT("Output_Dir"),			string, PropRead | PropWrite | All},
	{P_OutDirs_Intermediate,	_TEXT("Intermediate_Dir"),		string, PropRead | PropWrite | All},
	{P_Proj_TargDefExt,	 		_TEXT("Target_Ext"),			string, PropRead | PropWrite | Project},
	{P_Proj_CmdLine,			_TEXT("Cmd_Line"),				string, PropRead | PropWrite | Project},
	{P_Proj_RebuildOpt,			_TEXT("Rebuild_Opt"),			string, PropRead | PropWrite | Project},
	{P_Proj_CleanLine,			_TEXT("Clean_Line"),			string, PropRead | PropWrite | Project},
	{P_Proj_Targ,				_TEXT("Target_File"),			string, PropRead | PropWrite | Project},
	{P_Proj_BscName,			_TEXT("Bsc_Name"),				string, PropRead | PropWrite | Project},
	{P_Proj_ComPlus,			_TEXT("ComPlus"),				integer, PropRead | PropWrite | Project},
	{P_ProjItemOrgPath,			_TEXT("RelativePath"),			string, Project | NotPerConfig },
	{P_Proj_UserToolsName,		_TEXT("User_Tools_Name"),		string, PropRead | PropWrite | Project},
	{P_ItemExcludedFromBuild,	_TEXT("Exclude_From_Build"),	integer, PropRead | PropWrite | File | TargetRef},
	{P_ItemExcludedFromScan,	_TEXT("Exclude_From_Scan"),	integer, PropRead | PropWrite | File | Group | NotPerConfig},
	{P_ProjClsWzdName,			_TEXT("Classwizard_Name"),		string, PropRead | PropWrite | Project},
	{P_GroupDefaultFilter,		_TEXT("Default_Filter"),	string, PropRead | PropWrite | Group | NotPerConfig },
	{P_Proj_PerConfigDeps,		_TEXT("AllowPerConfigDependencies"),	integer, PropRead | PropWrite | Project | NotPerConfig },
	{P_Proj_IgnoreExportLib,	_TEXT("Ignore_Export_Lib"),		integer, PropRead | PropWrite | Project },
	{P_ItemIgnoreDefaultTool,	_TEXT("Ignore_Default_Tool"),		integer, PropRead | PropWrite | File },
	{P_ItemCustomBuildExt,		_TEXT("Custom_Build_Extension"),	string, PropRead | PropWrite | File | NotPerConfig},
	{P_ItemCustomBuildTime,		_TEXT("Custom_Build_Time"),			string, PropRead | PropWrite | File},
	{P_ItemBuildTool,			_TEXT("Build_Tool"),				string, PropRead | PropWrite | File},

// Scc
	{P_ProjSccProjName,			_TEXT("Scc_ProjName"),	string, PropRead | PropWrite | NotPerConfig | Project},
	{P_ProjSccRelLocalPath,		_TEXT("Scc_LocalPath"),	string, PropRead | PropWrite | NotPerConfig | Project},

// NB: if you add or remove any Writeable props here, you MUST also
// update the constant nWriteableProps constant below:
#define nWriteableProps (25)

// we should eliminate this redundancy, put in a marker item or put the two types of props in separate arrays

	// Really, these are project only.  Also, they are not per config, so 
	// they would not be written out properly.  However, they are only read in:
	{P_ProjMarkedForScan,		_TEXT("Marked_For_Scan"),		integer, PropRead | Project | NotPerConfig },
	{P_ProjMarkedForSave,		_TEXT("Marked_For_Save"),		integer, PropRead | Project | NotPerConfig },
	{P_ProjHasNoOPTFile,		_TEXT("Has_No_OPT_File"),		integer, PropRead | Project | NotPerConfig },
	{P_TargetRefName,		_TEXT("Target_Ref_Name"),		string, PropRead | TargetRef },
	{P_Proj_TargDir,	 		_TEXT("Target_Dir"),			string, PropRead | Project},	// only needed for conversions (ignored)
	{P_ConfigDefaultDebugExe,	_T("Debug_Exe"),				string, PropRead | Target },	// this one IS per config
// NB: if you add or remove any Read-only props here, you MUST also
// update the constant nReadOnlyProps constant below:
#define nReadOnlyProps (6) // should be eliminated, as above
	{P_END_MAP, NULL, null},
};

// FUTURE: move these into bldfile.cpp
const TCHAR *CProjItem::pcPropertyPrefix 	= _TEXT("PROP ");
const TCHAR *CProjItem::pcADD 				= _TEXT("ADD ");
const TCHAR *CProjItem::pcSUBTRACT			= _TEXT("SUBTRACT ");
const TCHAR *CProjItem::pcBASE				= _TEXT("BASE ");

// Consider: use this elsewhere
static CString & StripTrailingSlash(CString & str)
{
	int len = str.GetLength();
	_TCHAR * pchStart = str.GetBuffer(len);
	_TCHAR * pchEnd = pchStart + len;
	if (len > 1)
	{
		pchEnd = _tcsdec(pchStart, pchEnd);
		if ((pchEnd > pchStart) && ((*pchEnd =='/') || (*pchEnd == '\\')))
		{
			*pchEnd = 0;
			len = (int)(pchEnd - pchStart);
		}
	}

	str.ReleaseBuffer(len);
	return str;
}

BOOL CProjItem::GetOutDirString
(
	CString & str,
	CString * pstrValue, /* = NULL */
	BOOL bAllowItemMacro, /* = FALSE */
	BOOL fRecurse /* = FALSE */
)
{
	VSASSERT(!bAllowItemMacro, "bAllowItemMacro = true no longer supported"); // no longer supported

	// default is target prop for project
	UINT PropId = P_OutDirs_Target;

	CProjItem * pItem = GetProject();
	VSASSERT(pItem != (CProjItem *)NULL, "No project!  Deep trouble.");

	BOOL fForced = FALSE;

	// are we not a project or target item?
	if (this != pItem && this != GetTarget())
	{
		// no
		PropId = P_OutDirs_Intermediate;

		// can we get the property?
		if (GetPropBag()->FindProp(PropId))
		{
			// if (!bAllowItemMacro)
			return FALSE;

			// yes so use us!
			// pItem = (CProjItem *)this;
		}
		else
		{
			// try to get it from our parent project instead
			// (base-record *is* project config. record)
			VSASSERT(GetActiveConfig(), "No active config?!?  Deep trouble.");
			if (pItem->GetActiveConfig() != GetActiveConfig()->m_pBaseRecord)
			{
				pItem->ForceConfigActive((CConfigurationRecord *)GetActiveConfig()->m_pBaseRecord);
				fForced = TRUE;
			}
		}
	}

	BOOL fRet = pItem->GetOutDirString(str, PropId, pstrValue, TRUE, fRecurse);

	if (fForced) // restore original config.?
		pItem->ForceConfigActive();

	return fRet;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::GetOutDirString
(
	CString & str,
	UINT PropId,
	CString * pstrValue, /* = NULL */
	BOOL bMacro, /* = TRUE */
	BOOL fRecurse /* = FALSE */
)
{	
	// the rest are output directory related
	// find one somewhere in the hierarchy
	CProjItem * pItem = this;

	CProp * pprop = pItem->GetPropBag()->FindProp(PropId);
	while (fRecurse && pprop == (CProp *)NULL)
	{
		// *chain* the proper. config.
		CProjItem * pItemOld = pItem;
		pItem = (CProjItem *)pItem->GetContainerInSameConfig();
		if (pItemOld != (CProjItem *)this)
			pItemOld->ResetContainerConfig();

		if (pItem == (CProjItem *)NULL)
			break;	// not found in hierarchy

		pprop = pItem->GetPropBag()->FindProp(PropId);
	}

	// reset the last container we found
	if (pItem != (CProjItem *)NULL && pItem != (CProjItem *)this)
		pItem->ResetContainerConfig();

	// did we get one? fail if this isn't the target level
	if (pprop == (CProp *)NULL && !IsKindOf(RUNTIME_CLASS(CProject)))
		return FALSE;	// failure

	if (pstrValue)
	{
		// get the value
		CString strOutDir = pprop == (CProp *)NULL ? _TEXT("") : ((CStringProp *)pprop)->m_strVal;

		if (strOutDir.IsEmpty())
		{
			*pstrValue = _T('.');
		}
		else
		{
			strOutDir.TrimLeft();
			pstrValue->GetBuffer(strOutDir.GetLength() + 3);
			pstrValue->ReleaseBuffer(0);

			const TCHAR * pch = (const TCHAR *)strOutDir;

			// prepend ".\\" if not absolute or UNC path or already relative
			if ((pch[0] != _T('\\')) && 
				(pch[0] != _T('/')) &&
				(!(pch[0] == _T('.') && pch[1] == _T('\\'))) &&
				(!IsDBCSLeadByte (pch[0]) && (pch[1] != _T(':'))) || (IsDBCSLeadByte (pch[0])) 
				)
			{
				*pstrValue += _T(".\\");
			}

			*pstrValue += strOutDir;
			StripTrailingSlash(*pstrValue);
		}
	}

	str.GetBuffer(13); str.ReleaseBuffer(0);

	if (bMacro) str += _T("$(");

	// get the output directory macro name
	str += PropId == P_OutDirs_Intermediate ? _T("INTDIR") : _T("OUTDIR");

	if (bMacro) str += _T(')');

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SubstOutDirMacro(CString & str, const CConfigurationRecord * pcr)
{
	// substitute for $(OUTDIR) macro if nessessary

	if (pcr==NULL)	// this is not optional
		return FALSE;

	int nFndLoc;
	CString strOutDirMacro, strOutDirValue;
	BOOL retval = FALSE;
	if (pcr != GetActiveConfig())
		SetManualBagSearchConfig((CConfigurationRecord *)pcr);

	if (GetOutDirString(strOutDirMacro, &strOutDirValue))
	{
		nFndLoc = str.Find(strOutDirMacro);
		if (nFndLoc != -1)
		{
			str = str.Left(nFndLoc) + strOutDirValue + str.Mid(nFndLoc + strOutDirMacro.GetLength());
			retval = TRUE;
		}
	}

	if (pcr != GetActiveConfig())
		ResetManualBagSearchConfig();

	return retval;
}

			///////////////////////////////////////////////////////////////////////////////
// FUTURE (karlsi): move into class CProp::operator==
BOOL CompareProps(const CProp * pProp1, const CProp * pProp2)
{
	if ((pProp1==NULL) || (pProp2==NULL))
		return (pProp1==pProp2);

	VSASSERT(pProp1->m_nType==pProp2->m_nType, "Property type mismatch");

	switch (pProp1->m_nType)
	{
		case integer:
			return (((CIntProp *)pProp1)->m_nVal==((CIntProp *)pProp2)->m_nVal);
		case booln:
			return (((CBoolProp *)pProp1)->m_bVal==((CBoolProp *)pProp2)->m_bVal);
		case string:
			return (((CStringProp *)pProp1)->m_strVal==((CStringProp *)pProp2)->m_strVal);
		default:
			VSASSERT(0, "Unhandled prop type");	// other types not implemented
	};

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::IsPropComment (CObject *&pObject)
{
	// Pls. note that this will digest props regardless of whether or not they are
	// in the prop bag or not....
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
		return FALSE; 

	BOOL retval = FALSE; // assume failure

	CMakComment * pMakComment = (CMakComment *)pObject;

	// get the comment and skip leading whitespace
	TCHAR * pc = pMakComment->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// look for the 'Begin Custom Build' prefix
	if (_tcsnicmp(g_pcBeginCustomBuild, pc, _tcslen(g_pcBeginCustomBuild)) == 0)
	{
		CProject * pProject = GetProject();
		if (pProject->m_bConvertedDS6 || pProject->m_bConvertedDS5x || pProject->m_bConvertedDS4x)
		{
			CString strExt = GetFilePath()->GetExtension();
			if (strExt.CompareNoCase(_T(".idl"))==0) // REVIEW
			{
				SetIntProp(P_ItemIgnoreDefaultTool, TRUE);
			}
		}

		// read in the custom build rule
		BOOL fRet = CCustomBuildTool::DoReadBuildRule(this, pc);

		delete pObject; pObject = (CObject *)NULL;
		return fRet;
	}

	// look for the 'Begin Special Build Tool' prefix
	if (_tcsnicmp(g_pcBeginSpecialBuildTool, pc, _tcslen(g_pcBeginSpecialBuildTool)) == 0)
	{
		// read in the custom build rule
		BOOL fRet = CSpecialBuildTool::DoReadBuildRule(this, pc,(m_cp == EndOfConfigs));

		delete pObject; pObject = (CObject *)NULL;
		return fRet;
	}

	// look for the 'PROP' prefix
	if (_tcsnicmp(pcPropertyPrefix, pc, 4) != 0)
		return FALSE;

	int i, j, k, nConfigs=0;
	CString str;
	TCHAR *pcEnd;

	// Get the property name and look for it in the nMakeFileProps array:
	pc += 4;
	SkipWhite (pc);

	// check if BASE property
	BOOL fUseBase = _tcsnicmp(pcBASE, pc, 5) == 0; 
	if (fUseBase)
	{
		// skip over the "BASE" keyword
		pc += 5; SkipWhite(pc);
	}

 	// set the prop. bag usage
	int idOldBag = UsePropertyBag(fUseBase ? BaseBag : CurrBag);

	BOOL bBlankProp = FALSE;
	GetMakToken(pc, pcEnd);
 	bBlankProp = (*pcEnd == _T('\0'));
	*pcEnd = _T('\0');

	for (i=0; nMakeFileProps[i].idProp != P_END_MAP; i++)
	{
		if (!(nMakeFileProps[i].nRdWrt & PropRead)) continue;
		if ( _tcsicmp (nMakeFileProps[i].pPropName, pc) ==0 ) break;
	}
	if (nMakeFileProps[i].idProp != P_END_MAP )
	{
 		if (bBlankProp)
			pc = pcEnd;
		else
			pc = ++pcEnd;
        
        // Get the end of the prop line
        while (*pcEnd)
            pcEnd = _tcsinc(pcEnd);        

		if (m_cp == EndOfConfigs)
		{
			// global across *all configs* so
			// make sure we have all of our configs matching the project
			CreateAllConfigRecords();

			nConfigs = GetPropBagCount();
		}

		switch (nMakeFileProps[i].type)
		{
			case string:
			{
                // We strip quotes around the property, this is only
                // for compatability with previous makefiles, and should
                // not really be needed here.
                // FUTURE (colint): Delete this when we have a v2 bld convtr
                // that does this, and when most internal v3 makefiles have
                // been saved out to not have surrounding quotes!
                if (*pc == _T('"'))
                {
                    pc++;
                    if (*_tcsdec(pc, pcEnd) == _T('"'))
                        *(--pcEnd) = _T('\0');
                    else
                        VSASSERT(FALSE, "unmatched quotes");
                }

				// copy the string arg. between quotes into buffer
				str = pc;

				// may need to re-relativize paths if converted project
				if (GetProject()->m_bConvertedDS4x)
				{
					int id = nMakeFileProps[i].idProp;
					if ((id == P_OutDirs_Target) || (id == P_OutDirs_Intermediate) || (id == P_Proj_TargDir))
					{
						// Use special workspace dir (not actual wkspCDir)
						if ((!str.IsEmpty()) && (str[0] != _T('\\')) && (str[0] != _T('/')) && ((str.GetLength() < 2) || (str[1] != _T(':'))))
						{
							// REVIEW: should really add a temp filename here
							VSASSERT(g_pConvertedProject, "Global converted project pointer not set up properly for 4.X conversion");
							VSASSERT(*(LPCTSTR)g_pConvertedProject->GetWorkspaceDir(), "Workspace for 4.X conversion project not set up properly");
							CPath pathDir;
							pathDir.SetAlwaysRelative();
							if (pathDir.CreateFromDirAndFilename(g_pConvertedProject->GetWorkspaceDir(), str))
							{
								if (_tcsicmp((LPCTSTR)pathDir, (LPCTSTR)GetProject()->GetWorkspaceDir())==0)
									str = ".";
								else
									pathDir.GetRelativeName(GetProject()->GetWorkspaceDir(), str);
							}
						}
					}
				}
				if ((m_cp == EndOfConfigs) && !(nMakeFileProps[i].nRdWrt & NotPerConfig))
				{
					for (k=0; k < nConfigs; k++)
					{
						// Force config. active, set prop, and then restore.
						ForceConfigActive((CConfigurationRecord *)m_ConfigArray[k]);
						SetStrProp(nMakeFileProps[i].idProp, str);
						ForceConfigActive();
					}
				}
				else
				{
					VSASSERT((m_cp == EndOfConfigs) || !(nMakeFileProps[i].nRdWrt & NotPerConfig), "Malformed project file");
					SetStrProp ( nMakeFileProps[i].idProp, str );
				}
				str.Empty ();
				break;
			}

			case integer:
			case booln:
			{
				BOOL b = FALSE;
				j = atoi (pc);

				// using MFC property?
   				if (nMakeFileProps[i].idProp == P_ProjUseMFC)
				{
					// adjust...
					// do we have a use of MFC by AppWiz (LSB3 set)
					b = j & 0x4; j &= 0x3;
				}
										    
				if ((m_cp == EndOfConfigs) && !(nMakeFileProps[i].nRdWrt & NotPerConfig))
				{
					for (k=0; k < nConfigs; k++)
					{
						// Force config. active, set prop, and then restore.
						ForceConfigActive((CConfigurationRecord *)m_ConfigArray[k]);

						SetIntProp(nMakeFileProps[i].idProp, j);

						if (nMakeFileProps[i].idProp == P_ProjUseMFC)
							SetIntProp(P_ProjAppWizUseMFC, b);

						ForceConfigActive();
					}
				}
				else
				{
					VSASSERT((m_cp == EndOfConfigs) || !(nMakeFileProps[i].nRdWrt & NotPerConfig), "Malformed project file");
					SetIntProp(nMakeFileProps[i].idProp, j);

					if (nMakeFileProps[i].idProp == P_ProjUseMFC)
						SetIntProp(P_ProjAppWizUseMFC, b);
				}
			 	break;
			}

			default:
				VSASSERT (FALSE, "Unsupported type"); // Other types not supported.
				break;

		}
	}

	// we'll just ignore those props that we don't recognise
	// rather than flag the .MAK as unreadable	
	retval = TRUE; // indicate success

   	// reset the prop. bag usage
 	UsePropertyBag(idOldBag);

	delete pObject; pObject = (CObject *)NULL;

	return retval;
}

///////////////////////////////////////////////////////////////////////////////
BOOL  CProjItem::IsEndToken (CObject *& pToken )
{
	if (pToken->IsKindOf ( RUNTIME_CLASS (CMakEndOfFile)))
	{
		delete (pToken); pToken = NULL;
		AfxThrowFileException (CFileException::generic);
	}
	
	if (!pToken->IsKindOf ( RUNTIME_CLASS (CMakComment))) return FALSE;

	const TCHAR *pc = ((CMakComment *) pToken)->m_strText;
	SkipWhite (pc);
	if ( _tcsnicmp ( pc, EndToken, (sizeof(EndToken) -1) / sizeof(TCHAR)) == 0) 
	{
		delete (pToken); pToken = NULL;
		return TRUE;
	}
	return FALSE; 
}
///////////////////////////////////////////////////////////////////////////////
CRuntimeClass *CProjItem::GetRTCFromNamePrefix (const TCHAR *pcPrefix)
{
	// Skip over the "Begin":
	SkipWhite    (pcPrefix);
	SkipNonWhite (pcPrefix);
	SkipWhite    (pcPrefix);

	if ( *pcPrefix == '\0')
		return NULL;

 	// Get the runtime class by looking at the name.
 	if (_tcsnicmp(pcPrefix, _TEXT ("Source File"), 11) == 0)
		return RUNTIME_CLASS ( CFileItem );
 	else if (_tcsnicmp(pcPrefix, _TEXT ("Time Custom Build Step"), 17) == 0)
		return RUNTIME_CLASS ( CTimeCustomBuildItem );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Group"), 5) == 0)
		return RUNTIME_CLASS ( CProjGroup );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Project Dependency"), 18) == 0)
		return RUNTIME_CLASS ( CProjectDependency );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Project"), 7) == 0)
		return RUNTIME_CLASS ( CProject );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Target"), 6) == 0)
		return RUNTIME_CLASS ( CTargetItem );
 
 	TRACE ( "CProjItem::GetRTCFromNamePrefix got unknown prefix %s\n",
						pcPrefix );
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SuckDescBlk(CMakDescBlk *pDescBlk)
{
	BOOL retVal = TRUE;
	BOOL bOldInherit;
	CString str = pDescBlk->m_strTool;

	// get a project type
	CProjType * pprojtype = GetProjType();
	int len = str.GetLength();

	// ignore blk if pseudo-rule for OUTDIR/INTDIR/INTDIR_SRC
	if ((len >= 6) && (!str.Mid(2,4).Compare(_T("TDIR"))))
		return TRUE;

	if ( ( (_tcsicmp(_T("ALL"), pDescBlk->m_strTargets) == 0) ||
		   (_tcsicmp(_T("CLEAN"), pDescBlk->m_strTargets) == 0) )  && 
		 pprojtype->IsSupported()
	   )
		return TRUE;

	if ((len == 0) && (len = pDescBlk->m_strTargets.Find(_T('_'))) > 0)
	{
		// FUTURE: consider handling this in ParseDescBlk instead
		// also look for a "Fake" target of the form TOOLPREFIX_xxx
		str = pDescBlk->m_strTargets.Left(len);
		VSASSERT(len==str.GetLength(), "Size mismatch");
	}

	INT_PTR i = 0, nMax = m_cp == EndOfConfigs ? GetPropBagCount() : 1;

	// bounds for iteration
	// iterate through all configs if m_cp == EndOfConfigs
	if (m_cp == EndOfConfigs)
	{ 
		// global across *all configs* so
		// make sure we have all of our configs matching the project
		CreateAllConfigRecords();
	
	 	(void) ForceConfigActive((CConfigurationRecord *)m_ConfigArray[0]);
	}

	// nothing to do unless unsupported projtype-specific block
	TRY
	{
		for (;;) // iterate through configs if necessary based on m_cp
		{
			// get a tool for the prefix?
			CBuildTool * pTool = len > 0 ? pprojtype->GetToolFromCodePrefix(str, len) : (CBuildTool *)NULL;

 			// get the action list
			VSASSERT(GetActiveConfig(), "No active config?!?");
			CBuildActionList * pActions = GetActiveConfig()->GetActionList();

			// currently got a tool?
			// FUTURE: support multiple actions per-item
			CBuildTool * pCurrentTool = (CBuildTool *)NULL;
			if (!pActions->IsEmpty() && !IsKindOf(RUNTIME_CLASS(CProject)))
				pCurrentTool = ((CBuildAction *)pActions->GetHead())->BuildTool();

			// preserve this tool-specific block
			// o we recognise the block as for an unknown tool, or
			// o we don't have a tool already for the block
			if ((!pTool || pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool))))
			{
				// if don't already have a tool, then use the current one
				// else create it
				if (!pCurrentTool)
				{
					if (!pTool)
					{
						// try to get an unknown tool
						const TCHAR * pchPrefix = len > 0 ? (const TCHAR *)str : _TEXT("UNK");
						pTool = pprojtype->GetToolFromCodePrefix(pchPrefix, 3);
						
						if( (_tcsicmp(pchPrefix,"BuildCmds") == 0) && (pTool == NULL) ){
							pTool = g_pBuildTool;
						} 
						
						if (pTool == (CBuildTool *)NULL)
						{
							// no, unknown one, create new projtype-specific 'unknown' tool
							pTool = new CUnknownTool(*pprojtype->GetPlatformName(), pchPrefix);
							pprojtype->AddTool(pTool);
						}
					}

					// add an action if we don't already have one for this tool...
					if (!pActions->Find(pTool))
					{
						// explicitly add an action for this tool
						CBuildAction * pAction;
						pAction = new CBuildAction(this, pTool, FALSE, GetActiveConfig());
						pActions->AddTail(pAction);
					}
				}
				else
				{
					// use the current tool
					pTool = pCurrentTool;
				}

				// read in the raw-data for this descriptor block

				if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) && ( _tcsicmp(_T("ALL"), pDescBlk->m_strTargets) != 0))
				{
					str.Empty();
					bOldInherit = EnablePropInherit(FALSE);
					if (GetStrProp(((CUnknownTool *)pTool)->GetUnknownPropId(), str)!=valid)
						str.Empty();

					// make sure a blank line precedes the build rule
					int len1 = str.GetLength();
					VSASSERT(len1==0 || len1 >= 4, "Blank line needed before build rule");
					if ((len1==0) || ((len1 >= 4) && (_tcscmp((LPCTSTR(str) + len1 - 4), _T("\r\n\r\n"))!=0)))
						str += _T("\r\n");

					str += pDescBlk->m_strRawData;
					SetStrProp(((CUnknownTool *)pTool)->GetUnknownPropId(), str);
					EnablePropInherit(bOldInherit);
				}
			}

			// repeat for next config, if necessary
			if (++i >= nMax) break;

			ForceConfigActive();
			ForceConfigActive((CConfigurationRecord *)m_ConfigArray[i]);
		}
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	ForceConfigActive();
	return retVal;
}

enum { ONOPTION, ONPATH, NOTFOUND };


///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SuckMacro(CMakMacro * pMacro, const CDir & BaseDir, BOOL bCaseApproved /*=FALSE*/)
{
//	Examine a macro and figure out what its for.  Either its the dependencies
//	macro (in which case it starts with DEP) or it belongs to some tool, in 
//  which case we can get the tool from the macro's prefix:
//  for a tool

	const TCHAR * pMacName = pMacro->m_strName;

	// ignore OUTDIR and INTDIR macros
	if ((_tcsnicmp(_TEXT("OUTDIR"), pMacName, 6) == 0) ||
	    (_tcsnicmp(_TEXT("INTDIR"), pMacName, 6) == 0)
	   )
	{
		return TRUE;	// ok
	}

	BOOL retVal = TRUE;
	BOOL fPerConfig = m_cp != EndOfConfigs;

	TRY
	{	
		// dependency macro?
		if (_tcsnicmp(_TEXT("USERDEP_"), pMacName, 8) == 0) // user-defined dependency
		{
			// scanned or missing dependency?
			UINT depType = DEP_UserDefined;
			pMacName += (8 * sizeof(TCHAR));

			// if we haven't got any actions then this must be for an unknown tool
			VSASSERT(GetActiveConfig(), "No active config?!?  Project must not be set up properly yet");
			CBuildActionList * pActions = GetActiveConfig()->GetActionList();
			if (pActions->IsEmpty())
			{
				CBuildTool * pTool;

				// search for tool prefix
				TCHAR * pUnderScore = _tcschr(pMacName, _T('_'));
				int index = pUnderScore != (TCHAR *)NULL ? (int)(pUnderScore - pMacName) : -1;

				// found the tool prefix?
				CProjType *	pprojtype = GetProjType();

				TCHAR * pchPrefix;
				if (index == -1)
				{
					// we'll have to default to 'UNK' (unknown)
					pchPrefix = _TEXT("UNK");
					index = 3;
				}
				else
				{
					// we'll get the tool for the tool-prefix
					pchPrefix = (TCHAR *)pMacName;
				}

				// no tool?
				pTool = pprojtype->GetToolFromCodePrefix(pchPrefix, 3);
				
				if (pTool == (CBuildTool *)NULL)
				{
					// create new projtype-specific 'unknown' tool
					pTool = new CUnknownTool(*pprojtype->GetPlatformName(), pchPrefix);
					pprojtype->AddTool(pTool);
					g_pLastTool = pTool;
				}

				// make sure we have this tool in our action-list if it's unknown
				if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) &&
					!pActions->Find(pTool)
				   )
				{
					// explicitly add an action for this tool
					CBuildAction * pAction;
					VSASSERT(GetActiveConfig(), "No active config?  Project must not be set up properly yet");
					pAction = new CBuildAction(this, pTool, FALSE, GetActiveConfig());
					pActions->AddTail(pAction);
				}
			}

			CConfigurationRecord * pcrDest;

			// We're going to want this across all configs
			if (!fPerConfig)
				CreateAllConfigRecords();	// make sure we have all of the configs...

			// FUTURE: handle more than one tool on this source file
			VSASSERT(pActions->GetCount() == 1, "Can only have one tool on a source file at a time");	  
			CBuildAction * pAction = (CBuildAction *)pActions->GetHead();

			// Parse the dependants list to get our file name and dependents:

			// This is the accepted way to get a mungeable pointer a CString's
			// data.  Note we never call ReleaseBuffer:
			TCHAR * pBase = pMacro->m_strValue.GetBuffer (1);	

			// Squirrel away the length of the deps string, since we'll be 
			// writing all over it:
			const TCHAR * pDepEnd =  (const TCHAR *)pMacro->m_strValue + pMacro->m_strValue.GetLength();
	
			// possible token start and end
			TCHAR * pTokenEnd = max(pBase, (TCHAR *) pDepEnd-1);
			
			// generic buffer	
			CString str;

			for ( ; pTokenEnd < pDepEnd; pBase = _tcsinc (pTokenEnd) )
			{
				// skip whitespace
		  		SkipWhite (pBase);

				TCHAR * pTokenStart = pBase;

				// skip lead-quote?
				if (pBase[0] == _T('"'))
					pBase++;

				// get .mak token
				GetMakToken(pTokenStart, pTokenEnd);

				// back-up over end-quote?
				if (*(pTokenEnd - 1) == _T('"'))
					*(pTokenEnd - 1) = _T('\0');
				else
					*pTokenEnd = _T('\0'); 

				// get our dependency from this string
				BOOL fDepIsPerConfig = TRUE;	// we want the first one, so pretend per-config

				// per-configuration
				if (fPerConfig)
				{
					// Add user-defined dep to configuration record.
					CString strDeps;
					if (invalid == GetStrProp(P_UserDefinedDeps, strDeps) )
						strDeps.Empty();
					strDeps += pBase;
					strDeps += _T("\r\n");
					SetStrProp(P_UserDefinedDeps, strDeps);
				}
				else
				{
					INT_PTR nSize = m_ConfigArray.GetSize();
					
					CProjTempConfigChange projTempConfigChange(GetProject());

					// add this dep. to all configs.
					for (int nConfig = 0; nConfig < nSize; nConfig++)
					{
						pcrDest = (CConfigurationRecord *)m_ConfigArray[nConfig];

						// Get dep list to copy to
						projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcrDest->m_pBaseRecord);

						// Should we do this?
						VSASSERT(GetActiveConfig(), "No active config?  Project must not be set up properly yet");
						if( !GetTarget() )
							continue;

						if( !GetTarget()->GetActiveConfig() || !GetTarget()->GetActiveConfig()->IsValid() )
							continue;

						CBuildActionList * pActions = GetActiveConfig()->GetActionList();
						if (!pActions->IsEmpty())
						{
							// FUTURE: handle more than one tool on this source file
							VSASSERT(pActions->GetCount() == 1, "Only one tool at a time can be supported for a file");	  
							CBuildAction * pAction = (CBuildAction *)pActions->GetHead();

							// Add user-defined dep to configuration record.
							CString strDeps;
							if (invalid == GetStrProp(P_UserDefinedDeps, strDeps) )
								strDeps.Empty();
							strDeps += pBase;
							strDeps += _T("\r\n");
							SetStrProp(P_UserDefinedDeps, strDeps);
						}
					}
				}
			}
		}
		else if (_tcsnicmp(_TEXT("NODEP_"), pMacName, 6) == 0 ||	// missing dependency
			_tcsnicmp(_TEXT("DEP_"), pMacName, 4) == 0)			// scanned dependency
		{
			// specifically want to just skip these
		}
		// tool macro or some tool option macro?
		else
		{
			// probably a tool definition or tool macro, or some random macro
			CBuildTool * pTool = NULL;
			int index = pMacro->m_strName.Find(_T('_'));
			INT_PTR i = 0, nMax = fPerConfig ? 1 : GetPropBagCount();

			// tool macro?
			if (index == -1 && IsKindOf(RUNTIME_CLASS(CProject)))
			{
				for (;;) // iterate through configs if necessary based on m_cp
				{
					if (!fPerConfig)
						ForceConfigActive((CConfigurationRecord *)m_ConfigArray[i]);

					// tool definition; extract tool name
					CProjType * pprojtype = GetProjType();
					pTool = pprojtype->GetToolFromCodePrefix( pMacName, lstrlen(pMacName) );
					if ( pTool == NULL )
					{
						// create new projtype-specific 'unknown' tool
						pTool = new CUnknownTool(*pprojtype->GetPlatformName(),
										pMacro->m_strName, pMacro->m_strValue);

						pprojtype->AddTool(pTool);
						g_pLastTool = pTool;
					}

					// repeat for next config, if necessary
					if (++i >= nMax)
						break;
				}
			}
	 		else if (index != -1)
			{
				for (;;) // iterate through configs if necessary based on m_cp
				{
					if (!fPerConfig)
						ForceConfigActive((CConfigurationRecord *)m_ConfigArray[i]);

					if ((pTool = GetProjType()->GetToolFromCodePrefix(pMacName, index)) != NULL)
					{
						g_pLastTool = pTool;	// save most recently used tool
					}
					else
					{
						pTool = g_pLastTool;	// worst-case default
					}

					// found macro for some tool?
					if (pTool)
					{
						VSASSERT(GetActiveConfig(), "No active config?  Project must not be set up properly yet");
						CBuildActionList * pActions = GetActiveConfig()->GetActionList();

						// make sure we have this tool in our action-list if it's unknown
						if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) &&
							!pActions->Find(pTool)
						   )
						{
							// explicitly add an action for this tool
							CBuildAction * pAction;
							pAction = new CBuildAction(this, pTool, FALSE, GetActiveConfig());
							pActions->AddTail(pAction);
						}

						if (!pTool->ReadToolMacro(pMacro, this))
							AfxThrowFileException(CFileException::generic);
					}

					// repeat for next config, if necessary
					if (++i >= nMax)
						break;
				}
			}
			else if( (_tcsicmp(pMacName,"BuildCmds") == 0) && (g_pBuildTool != NULL) 
					&& g_pBuildTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) ){
				// append the whole macro to the unknow prop in the last tool!
				g_pBuildTool->ReadToolMacro(pMacro,this);
			}
		}
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	ForceConfigActive();

	return retVal;	// success?
}
///////////////////////////////////////////////////////////////////////////////

BOOL CProjItem::IsAddSubtractComment (CObject *&pObject)
{
	if ( !pObject->IsKindOf ( RUNTIME_CLASS (CMakComment))) return FALSE; 
	TCHAR *pc, *pcOld=NULL;
	CBuildTool *pbt;
	BOOL bRetval = FALSE, bSubtract;
	BOOL bBase = FALSE;
	int i, nRepCount = 1;

	pc = ((CMakComment *) pObject)->m_strText.GetBuffer (1);
	SkipWhite (pc);

	// Look for the ADD or SUBTRACT prefix:
	if (  _tcsnicmp(pcADD, pc, 4) == 0 ) 
	{
		bSubtract = FALSE;
		pc += 4;
	}
	else if	(  _tcsnicmp(pcSUBTRACT, pc, 9) == 0 ) 
	{
		bSubtract = TRUE;
		pc += 9;
	}
	else return FALSE;

	SkipWhite (pc);

	// Check for BASE flag
	if (!_tcsnicmp(pcBASE, pc, 5))
	{
		bBase = TRUE;
		pc += 5;	// skip past base flag
		SkipWhite (pc);
	}
	
	// global across *all configs* so
	// make sure we have all of our configs matching the project
	CreateAllConfigRecords();

	if (m_cp == EndOfConfigs)
	{
		// FUTURE (karlsi): this is not very efficient, since we have to
		// reparse the same line n times.  Ideally, we could
		// defer this to when we set the properties, except
		// different configs might have different tools, and it
		// might get tricky. Reevaluate for V5.

		nRepCount = GetPropBagCount();
		pcOld = pc;	// save char pointer for each iteration
	}

	for (i = 0; i < nRepCount; i++)
	{
		if (m_cp == EndOfConfigs)
		{
			pc = pcOld;	// restore pointer to tool code-prefix

			// force config active
			ForceConfigActive((CConfigurationRecord *)m_ConfigArray[i]);
		}

		// Ask the current project type which one of its tools
		// matches the tool code-prefix.
		CProjType * pprojtype = GetProjType(); 
		g_pBuildTool = pbt = pprojtype->GetToolFromCodePrefix(pc, lstrlen (pc));
		

		if (pbt != NULL)
		{
			// Skip to start of flags to end of string
			while (*pc != _T('\0') && !_istspace(*pc))
				pc = _tcsinc(pc);	// next MBC character
	
			bRetval = pbt->ProcessAddSubtractString(this, pc, bSubtract, bBase);

			// FUTURE (karlsi): Do we want to allow/ignore failures
			//         when m_cp == EndOfConfigs?
			if (!bRetval)
			{
				// reset config.?
				if (m_cp == EndOfConfigs)
					ForceConfigActive();

				break; // quit if fails for any Config
			}
		}

		// reset config.?
		if (m_cp == EndOfConfigs)
			ForceConfigActive();
	}

	delete pObject;	pObject = NULL;

	// Something went wrong, but this token was for us:
	if (!bRetval)
	{
		VSASSERT(GetProject(), "Something went wrong in project load");
		if (GetProject() && (!GetProject()->m_bProjConverted))
			AfxThrowFileException (CFileException::generic);
	}
	return TRUE;	

}

///////////////////////////////////////////////////////////////////////////////
// (throw CFileException if unknown confiugration)
void CProjItem::ReadConfigurationIfDef(CMakDirective *pmd, BOOL bCheckProj /* = FALSE */)
{
	// N.B. FUTURE (karlsi): Currently we don't handle nested switches
	TCHAR *pstart, *pend;

	if (pmd->m_dtyp == CMakDirective::DTYP_ENDIF)
	{
		if (bCheckProj)
		{
			VSASSERT(IsKindOf(RUNTIME_CLASS(CProject)), "Should only be calling this part of ReadConfigurationIfDef if we're a project");
			CString strProject;
			CProject * pProject;
			CProject::InitProjectEnum();
			while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
			{
				pProject->m_cp = EndOfConfigs;
			}
		}
		else
		{
			m_cp = EndOfConfigs;
		}
	}
	else if (pmd->m_dtyp == CMakDirective::DTYP_ELSEIF ||
			 pmd->m_dtyp == CMakDirective::DTYP_IF)
	{
		// Skip over "$(CFG)" part
		pstart	= pmd->m_strRemOfLine.GetBuffer(1);
		if (!GetQuotedString (pstart, pend) ||
			_tcsncmp ( _TEXT("$(CFG)"), pstart, 6) != 0)
			AfxThrowFileException (CFileException::generic);

		pstart =_tcsinc(pend);
		if (!GetQuotedString(pstart, pend))
			AfxThrowFileException (CFileException::generic);

		*pend = _T('\0');

		// put the whole project into this configuration
		if (bCheckProj)
		{
			VSASSERT(IsKindOf(RUNTIME_CLASS(CProject)), "Should only be calling this part of ReadConfigurationIfDef if we're a project");
			CString strProject;
			BOOL bFoundProject = FALSE;
			CProject * pProject = (CProject *)this;
			CProject::InitProjectEnum();
			while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
			{
				if (!bFoundProject)
				{
					int i;
					CConfigurationRecord* pcr;
					int size = pProject->GetPropBagCount();
					for (i=0; i < size; i++)
					{
						pcr = (CConfigurationRecord*) pProject->GetConfigArray()->GetAt(i);
						VSASSERT(pcr, "NULL config record in config array!");
						if (pcr->GetConfigurationName().CompareNoCase(pstart) == 0)
						{
							bFoundProject = TRUE;
							g_pActiveProject = pProject;
							break;
						}
					}
				}
				pProject->m_cp = (pmd->m_dtyp == CMakDirective::DTYP_IF) ? 
						FirstConfig : MiddleConfig;									 
			}

			VSASSERT(bFoundProject, "No project?!?");
			if (!bFoundProject)
				AfxThrowFileException (CFileException::generic);

			g_pActiveProject->SetActiveConfig(pstart);
		}
		else	
		{
			GetProject()->SetActiveConfig(pstart);
			m_cp = (pmd->m_dtyp == CMakDirective::DTYP_IF) ? 
					FirstConfig : MiddleConfig;									 
		}

	}
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::InformDependants(UINT idChange, DWORD_PTR dwHint)
{
	CSlob::InformDependants(idChange, dwHint);

	//
	// Inform other non-CSlob, dependents here ....
	//
	CProject * pProject = GetProject();

	if (idChange == P_ProjUseMFC &&	pProject->m_bProjectComplete)
	{
		// we need to make sure we have the right setup
		// for an MFC project
		CProjType * pprojtype = pProject->GetProjType();
		int val;
		if (pprojtype != (CProjType *)NULL &&
			pProject->GetIntProp(P_ProjUseMFC, val)
		   )
		{
			pprojtype->PerformSettingsWizard(this, val);
		}
	}

	// 
	// Inform other, non-CSlob, dependents here ....
	//
	if (m_idBagInUse == CurrBag)
	{
		// inform any associated actions so that they may add/remove inputs and outputs?
		// or that the file may become a part of the build
		if (idChange == P_ItemExcludedFromBuild)
		{
		}
  		
		// inform our actions that their output state is likely to have changed?
 		// (many output files are derived from the output directories and/or remote target)
		else if (idChange == P_OutDirs_Target || idChange == P_OutDirs_Intermediate ||
				 idChange == P_TargetName || idChange == P_RemoteTarget)
		{
			CProject * pProject = GetProject();
			// only inform if the project is complete, ie. not constructing/destructing
			if (pProject != (CProject *)NULL && pProject->m_bProjectComplete)
			{
				// FUTURE:
				// this is a hack for project-level custom-build steps
				// informing that the inputs (.objs) to the .exe has changed
				// will remove the .exe and then re-create, we need
				// to re-affix the project-level custom-build step thus...
				CBuildTool * pTool;
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild), (CBldSysCmp *&)pTool);

				CVCPtrList lstSelectTools;
				lstSelectTools.AddTail(pTool);

				// Special build tool to handle pre-link/post-build.
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild), (CBldSysCmp *&)pTool);
				lstSelectTools.AddTail(pTool);

				// un-assign any project-level custom build tool
				CBuildAction::UnAssignActions(pProject, &lstSelectTools, (CConfigurationRecord  *)NULL, FALSE);

				// try to re-assign any project-level custom build tool
				CBuildAction::AssignActions(pProject, &lstSelectTools, (CConfigurationRecord  *)NULL, FALSE);

			}
		}

		// configuration name changes may need to be forwarded to targets/target references displaying
		// the configuration name that has changed
		else if (idChange == P_ProjConfiguration && GetProject() && GetProject()->m_bProjectComplete)
		{
			CString strConfig;
			GPT gptVal = GetStrProp(P_ProjConfiguration, strConfig);
			VSASSERT(gptVal == valid, "P_ProjConfiguration is required property!");
		}

		// break else here... to test for SN_ALL

		// re-assign custom build actions changes
		if (idChange == P_CustomCommand || idChange == P_CustomOutputSpec ||	// semantic change
			idChange == P_UserDefinedDeps ||

			idChange == SN_ALL ||												// global change

			idChange == P_TargetName ||											// target name (binding)
			idChange == P_OutDirs_Target ||										// target output (binding)
			idChange == P_PreLink_Command ||
			idChange == P_PostBuild_Command ||
			idChange == P_RemoteTarget											// target output (binding)
		   )
		{
			CProject * pProject = GetProject();

			if (pProject != (CProject *)NULL && pProject->m_bProjectComplete)	// project complete
			{
				CBuildTool * pTool = NULL;
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild), (CBldSysCmp *&)pTool);

				CVCPtrList lstSelectTools;
				lstSelectTools.AddTail(pTool);

				// Special build tool to handle pre-link/post-build.
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild), (CBldSysCmp *&)pTool);
				lstSelectTools.AddTail(pTool);

				// un-assign any custom build tool
				CBuildAction::UnAssignActions(this, &lstSelectTools, (CConfigurationRecord  *)NULL, FALSE);

				// try to re-assign a custom build tool
				CBuildAction::AssignActions(this, &lstSelectTools, (CConfigurationRecord  *)NULL, FALSE);

				// possible target-name change
				if (idChange == P_TargetName)
				{
					CString strConfig;
					GPT gptVal = GetStrProp(P_ProjConfiguration, strConfig);
					VSASSERT(gptVal == valid, "P_ProjConfiguration is required property!");
				}
			}
		}

		// break else here... to test for SN_ALL

		// global action changes
 		// (SN_ALL or builder filename change)
		if (idChange == SN_ALL ||				// global change
			idChange == P_BldrFileName ||
			idChange == P_Proj_TargDefExt		// default target extension
		   )
		{
			COptionHandler * pOptHdlr;
			CVCPtrList lstTool;	 

			g_pPrjcompmgr->InitOptHdlrEnum();
			while (g_pPrjcompmgr->NextOptHdlr(pOptHdlr))
			{
				CBuildTool * pTool = pOptHdlr->m_pAssociatedBuildTool;

				// affects the outputs?
				if (pTool != (CBuildTool *)NULL && (idChange == SN_ALL))
					lstTool.AddTail(pTool);
			}

			VCPOSITION pos = lstTool.GetHeadPosition();
			while (pos != (VCPOSITION)NULL)
				// local, only affects outputs of those actions interested in tool
				((CBuildTool *)lstTool.GetNext(pos))->InformDependants(P_ToolOutput, (DWORD_PTR)this);
		}
	}

	if (idChange == P_ItemIgnoreDefaultTool)
	{
		VSASSERT(IsKindOf(RUNTIME_CLASS(CFileItem)), "Can only ignore default tool on files");
		if (GetProject() && GetProject()->m_bProjectComplete)
		{
			CConfigurationRecord * pcr = (CConfigurationRecord *)GetActiveConfig()->m_pBaseRecord;
			CBuildAction::UnAssignActions(this, NULL, pcr);
			CBuildAction::AssignActions(this, NULL, pcr);
		}
	}
}

CSlob * CProjItem::GetContainerInSameConfig()
{
	CProjItem * pItem = (CProjItem *)GetContainer();
	if (pItem != (CSlob *)NULL)
	{
		// if we have a manual than our containe uses the same manual,
		// else it uses our current if it needs to

		CConfigurationRecord * pRec = (CConfigurationRecord *)NULL;

		// use the same manual config. if we have one
		if (m_pManualConfigRec != (CConfigurationRecord *)NULL)
			pRec = m_pManualConfigRec;

		// don't do anything if we don't need to
		else
		{
			VSASSERT(GetActiveConfig(), "No active config?  Something not initialized properly");
			if (pItem->GetActiveConfig(TRUE)->m_pBaseRecord != GetActiveConfig()->m_pBaseRecord)
				pRec = m_pActiveConfig;
		}

		pItem->SetManualBagSearchConfig(pRec);
	}
	return pItem;
}

void CProjItem::SetCurrentConfigAsBase(COptionHandler * popthdlr)
{
	CConfigurationRecord * pRec = GetActiveConfig();
	VSASSERT(pRec != (CConfigurationRecord *)NULL, "No active config?  Item wasn't initialized properly");

	while (popthdlr != (COptionHandler *)NULL)
	{
		UINT nMinProp, nMaxProp ;
		popthdlr->GetMinMaxOptProps (nMinProp, nMaxProp) ;
		pRec->BagCopy(CurrBag, BaseBag, nMinProp, nMaxProp);
		// get the base-handler
		popthdlr = popthdlr->GetBaseOptionHandler();
	}
}

///////////////////////////////////////////////////////////////////////////////
// GetPropBag
////////////////////////////////////////////////////////////////////////////////
int CProjItem::GetPropBagCount() const
{
	const CVCPtrArray * pCfgArray = GetConfigArray();
	return (int) pCfgArray->GetSize();
}

CPropBag* CProjItem::GetPropBag(int nBag)
{
	// look for the *current* property bag?
	if (nBag == -1) /* get current */
	{
		CConfigurationRecord *pcr;
		pcr = GetActiveConfig(TRUE);
		if (pcr)
		{
			return (pcr->GetPropBag(m_idBagInUse));	// our prop bag for current active config
		}
		return(NULL);
	}

	// get a particular property bag (using index)
	CConfigurationRecord *pcr;
	VSASSERT(nBag >= 0, "No prop bag in use!");
	if (nBag > m_ConfigArray.GetUpperBound())
		return (CPropBag *)NULL ;

	pcr = (CConfigurationRecord *)m_ConfigArray[nBag];
	return pcr->GetPropBag(m_idBagInUse);
}

CPropBag * CProjItem::GetPropBag(const CString & strBagName)
{
	CConfigurationRecord * pcr = ConfigRecordFromConfigName(strBagName); 
	return pcr != (CConfigurationRecord *)NULL ? pcr->GetPropBag(m_idBagInUse) : (CPropBag *)NULL;
};
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::ConfigurationChanged(const CConfigurationRecord *pcr )
{
	POSITION pos;
#ifdef _DEBUG
	void * pv;
#endif
	BOOL retVal = FALSE; // return true if and only if "new" cr added
	CProjItem *	pProjItem;
	CConfigurationRecord * pcrNew;
	CString strType, strName;

	VSASSERT (pcr, "Cannot pass NULL to ConfigurationChanged");
	VSASSERT (pcr->m_pBaseRecord == pcr, "Can only pass top level config record to ConfigurationChanged" ); // pcr should be top level!

	// FUTURE (karlsi): Change subproject and warn if there's state if they don't
	// have a matching config.

	// This is where items other than projects find out that there's a new
	// config:  They're told to switch to a config they don't know about,
	// so they create it:
	if (!m_ConfigMap.Lookup((void *) pcr, (void *&) m_pActiveConfig))
	{
		strType = pcr->GetOriginalTypeName();
		strName = pcr->GetConfigurationName();
		pcrNew = ConfigRecordFromConfigName(strName, FALSE, FALSE);
		if ((pcrNew) && (pcrNew->GetOriginalTypeName()==strType))
		{
			// matched by name & projtype, so reuse this one
			m_pActiveConfig = pcrNew;
			m_ConfigMap.RemoveKey((void*)m_pActiveConfig->m_pBaseRecord); // readded for new base below
			m_pActiveConfig->m_pBaseRecord = pcr->m_pBaseRecord;
		}
		else
		{
			m_pActiveConfig = new CConfigurationRecord (pcr, this);
			INT_PTR x = m_ConfigArray.Add(m_pActiveConfig);
			VSASSERT(((CConfigurationRecord *)m_ConfigArray[x])->GetConfigurationName()==pcr->GetConfigurationName(), "Name mismatch on config!");
			retVal = TRUE;
		}
		VSASSERT(!m_ConfigMap.Lookup((void *)m_pActiveConfig->m_pBaseRecord, (void *&)pv), "Config record not in config map!");
		m_ConfigMap.SetAt((void *)m_pActiveConfig->m_pBaseRecord, m_pActiveConfig);
		VSASSERT(m_ConfigMap.GetCount()==m_ConfigArray.GetSize(), "Config map/array size mismatch!");
	}
	ASSERT_VALID (m_pActiveConfig);

	// notify all of our children of this change
	// don't do this if we don't have a content list
	if (
		!GetContentList()
	   )
		return retVal;

	for (pos = GetHeadPosition(); pos != NULL; )
	{
		pProjItem = (CProjItem *)GetNext(pos);
		BOOL bChildAdded = pProjItem->ConfigurationChanged(pcr);
	}
	return retVal;

}
///////////////////////////////////////////////////////////////////////////////
// make sure we have all of our configs matching the project
void CProjItem::CreateAllConfigRecords()
{
	CTargetItem *pTarget = GetTarget();
	CProject *pProject = GetProject();
	const CVCPtrArray * pCfgArray = NULL;
	BOOL fUseProjectConfig = FALSE;

	if (pTarget != NULL && pTarget != this && pProject != this)
	{
		pCfgArray = pTarget->GetConfigArray();
	}
	else if (pProject != NULL)
	{
		pCfgArray = pProject->GetConfigArray();
		fUseProjectConfig = TRUE;
	}

	if (pCfgArray != NULL)
	{
		INT_PTR icfg, size = pCfgArray->GetSize();
		for (icfg = 0; icfg < size; icfg++)
		{
			CConfigurationRecord * pcr = (CConfigurationRecord *)pCfgArray->GetAt(icfg);
			if (fUseProjectConfig || pcr->IsValid())
				(void)ConfigRecordFromBaseConfig((CConfigurationRecord *)pcr->m_pBaseRecord, TRUE);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
CConfigurationRecord * CProjItem::GetActiveConfig(BOOL bCreate /* = FALSE */)
{
	// return a forced configuration?
	if (m_pForcedConfig != (CConfigurationRecord *) NULL)
		return m_pForcedConfig;

	if (m_pManualConfigRec)
	{
		CConfigurationRecord * pRec;
		if (m_ConfigMap.Lookup( 
				(void  *) m_pManualConfigRec->m_pBaseRecord,
				(void *&) pRec
				))
			return pRec;
	}

	// do we have a matching config. with our owner project?
	// (compare base records)
	CProjItem * pItem = GetProject();
	
	// Is this item in a project, if not then it doesn't have
	// an active config
	if (pItem == NULL)
		return NULL;

	if (pItem != this)
	{
		CConfigurationRecord * pcrItem = pItem->GetActiveConfig(bCreate);
		if (!m_pActiveConfig || pcrItem != m_pActiveConfig->m_pBaseRecord)
		{
			if (pcrItem != NULL)
			{
				// get a config. record, create if needs be
				m_pActiveConfig = ConfigRecordFromBaseConfig(pcrItem, bCreate);
				if (bCreate)
				{
					VSASSERT(m_pActiveConfig, "Active config not set!  Bad initialization");
					ASSERT_VALID(m_pActiveConfig);
				}
			} 
			else
			{
				m_pActiveConfig = NULL;
			}
		}
	}

	// return the active configuration...
	return m_pActiveConfig;
}
///////////////////////////////////////////////////////////////////////////////
CConfigurationRecord* CProjItem::ConfigRecordFromBaseConfig
(
	CConfigurationRecord *	pcrBase,
	BOOL					fCreate /* = FALSE */
)
{
	CConfigurationRecord * pcr;

	// not found matching?
	if (!m_ConfigMap.Lookup((void *)pcrBase, (void *&)pcr))
	{
		// create?
		if (fCreate)
		{
			CString strType = pcrBase->GetOriginalTypeName();
			CString strName = pcrBase->GetConfigurationName();

			pcr = ConfigRecordFromConfigName(strName);
			if (pcr && pcr->GetOriginalTypeName() == strType)
			{
				// matched by name & projtype, so reuse this one
				m_ConfigMap.RemoveKey((void*)pcr->m_pBaseRecord); // readded for new base below
				pcr->m_pBaseRecord = pcrBase;
			}
			else
			{			
				// not  matched, so create a new one
				pcr = new CConfigurationRecord(pcrBase, this);
				INT_PTR ipcr = m_ConfigArray.Add(pcr);
				VSASSERT(((CConfigurationRecord *)m_ConfigArray[ipcr])->GetConfigurationName() == pcrBase->GetConfigurationName(), "Config name mismatch");
			}

			// add this into our config. map (it's already in our array)
#ifdef _DEBUG
			void * pv;
#endif // _DEBUG
			VSASSERT(!m_ConfigMap.Lookup((void *)pcr->m_pBaseRecord, (void *&)pv), "Config record not in config map!");
			m_ConfigMap.SetAt((void *)pcr->m_pBaseRecord, pcr);

			VSASSERT(m_ConfigMap.GetCount() == m_ConfigArray.GetSize(), "Config map/array size mismatch");
		}
		else
			pcr = (CConfigurationRecord *)NULL;
	}

	return pcr;
}
///////////////////////////////////////////////////////////////////////////////
CConfigurationRecord *CProjItem::ConfigRecordFromConfigName
(
	const TCHAR *	pszConfig,
	BOOL			fCreate /* = FALSE */,
	BOOL fMatchExact /* = TRUE */
)
{
	CString strConfigToMatch, strConfig;
	TCHAR * pszChar;
	CConfigurationRecord * pcrMatch = NULL;
	if (!fMatchExact)
	{
		TCHAR * pszChar = _tcsstr(pszConfig, _T(" - "));
		if (pszChar != NULL)
		{
			strConfigToMatch = pszChar + 3;
		}
		else
		{
			fMatchExact = TRUE;
		}
	}
	int size = GetPropBagCount();
	for (int i = 0; i < size; i++)
	{
		CConfigurationRecord * pcr = (CConfigurationRecord *)m_ConfigArray[i];
		strConfig = pcr->GetConfigurationName();
		if (strConfig.CompareNoCase(pszConfig) == 0)
			return pcr;

		if ((!fMatchExact) && (pcrMatch == NULL))
		{
			pszChar = _tcsstr(strConfig, _T(" - "));
			if ((pszChar != NULL) && (strConfigToMatch.CompareNoCase(pszChar + 3) == 0))
			{
				// found possible match
				pcrMatch = pcr;
			}
		}
	}

	if (pcrMatch != NULL)
		return pcrMatch;

	// not found, so create?
	if (fCreate)
	{
		// must have one in project, so create one based on this project's config.
		return ConfigRecordFromBaseConfig(GetProject()->ConfigRecordFromConfigName(pszConfig), TRUE);
	}

	return NULL;
}

CProjType * CProjItem::GetProjType ()
{
	CProject * pProject = GetProject();
	VSASSERT(pProject != (CProject *)NULL, "Project not set!");
	
	CConfigurationRecord * pcr = GetActiveConfig();
	if (pcr == (CConfigurationRecord *)NULL)
		return (CProjType *)NULL;	// no current configuration -> no project type!

	VSASSERT(pcr->m_pBaseRecord, "Config record not initialized properly");

	CStringProp * pProp = (CStringProp *) ((CConfigurationRecord *)pcr->m_pBaseRecord)
						 ->GetPropBag(CurrBag)->FindProp (P_ProjOriginalType);
	if (pProp==NULL)
		return NULL;

	VSASSERT(pProp->m_nType == string, "Expected string prop!"); 

	// ignore return
	CProjType * pprojtype;
	if (!g_pPrjcompmgr->LookupProjTypeByName(pProp->m_strVal, pprojtype))
		return (CProjType *)NULL;

	return pprojtype;
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::FlattenSubtree (CObList &rObList, int fo) 
{
 	BOOL fAddItem = FALSE, fAddContent = FALSE;

	FlattenQuery(fo, fAddContent, fAddItem);

	// If we have items contained then flatten each of these as well
	if (fAddContent && GetContentList())
	{
		POSITION pos;
 		for (pos = GetHeadPosition(); pos != (POSITION)NULL;)
		{
			CProjItem * pProjItem = (CProjItem *) GetNext (pos);
			if (!(fo & flt_ExpandSubprojects) && pProjItem->IsKindOf(RUNTIME_CLASS(CProject)))
				continue;

			pProjItem->FlattenSubtree(rObList, fo);
		}
	}

	if ((fo & flt_OnlyTargRefs) && !IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return;	// only include target references!

	// Add the item if we need to
	if (fAddItem)
		rObList.AddTail(this);
}

void CProjItem::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	fAddContent = FALSE;
	fAddItem = FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// CanContain - our internal (within VPROJ) CanAdd method
 
BOOL CProjItem::CanContain(CSlob* pSlob)
{
	// Must override
	VSASSERT(FALSE, "CanContain must be overridden");
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
GPT CProjItem::GetIntProp(UINT idProp, int& val)
{
//#pragma message ("ALERT! : projitem.cpp : Including P_QA_ProjItemType hook for QA...")
	// return to QA what the type of this project item is
	if (idProp == P_QA_ProjItemType)
	{
		if (IsKindOf(RUNTIME_CLASS(CProject)))
			val = QA_TypeIs_Target;
		else if (IsKindOf(RUNTIME_CLASS(CProjGroup)))
			val = QA_TypeIs_Group;
		else if (IsKindOf(RUNTIME_CLASS(CFileItem)))
			val = QA_TypeIs_File;
		else 
			VSASSERT(FALSE, "unrecognized type!");

		return valid;	// success
	}

	GPT gpt;
	// want to handle special case here:
	if (idProp == P_ItemOptState || idProp == P_ItemOptChanged)
	{
		if (IsKindOf (RUNTIME_CLASS (CProject)) || IsKindOf (RUNTIME_CLASS (CFileItem)) || 
			IsKindOf (RUNTIME_CLASS (CProjGroup)) || IsKindOf (RUNTIME_CLASS (CTargetItem)))
		{
			gpt = CSlob::GetIntProp (P_ItemOptState, val);
			if (gpt == invalid)
				val = 1;
			else 
			{
				if (idProp == P_ItemOptState)
					val = val & 0x7fffffff; // masking off the highest bit
				else
					val = (val & 0x80000000) ? 1 : 0; // get the highest bit
			}
			return valid;
		}
		else
			return invalid;
	}

	if (idProp == P_ItemExcludedFromScan)
	{
		// not per config and not valid by default
		// override to do anything special
		val = FALSE;
		return invalid;
	}

	if ((idProp == P_Proj_PerConfigDeps) && (GetProject() != NULL))
	{
		val = GetProject()->m_bProj_PerConfigDeps;
		return valid;
	}

	// get the option handler
	COptionHandler * popthdlr = g_pPrjcompmgr->FindOptionHandler(idProp);

	if (popthdlr != (COptionHandler *)NULL)
	{
		// if we have an option handler for this prop we must be an option
		// check it's dependencies
		if (!(m_optbeh & OBNoDepCheck))
		{
			BOOL fCheckDepOK;

			// the DepCheck needs to view the whole 'context' ie.
			// the tool options with inheritance
			// prevent the DepCheck() recursing
			OptBehaviour optbehOld = m_optbeh;
			m_optbeh |= OBInherit | OBShowDefault | OBNoDepCheck;
		
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			fCheckDepOK = popthdlr->CheckDepOK(idProp);
			popthdlr->ResetSlob();

			m_optbeh = optbehOld;

			// is this an invalid option?
			if (!fCheckDepOK)	return invalid;
		}
	}

	// usual CSlob property behaviour
	// ask the base-class to actual find the prop.
	gpt = CSlob::GetIntProp(idProp, val);

	// do we want to supply this ourselves?
	if (gpt == invalid && (idProp == P_ItemExcludedFromBuild))
	{
		val = FALSE; gpt = valid;	// valid and FALSE by default
	}

	// does this property exist for this CSlob?
	if (gpt == invalid)
	{
		// are we not at the root and inheriting?
		if (m_optbeh & OBInherit)
		{
			// automatically detect if we need to do a manual config?
			// we don't need to if we already have a manual config rec. to use
			CProjItem * pContainer = (CProjItem *) GetContainerInSameConfig();
			while (pContainer != (CSlob *)NULL)
			{
				// yes, so let's search in our container CSlob if we have one
				OptBehaviour optbehOld = pContainer->m_optbeh;
 				int idOldBag = pContainer->UsePropertyBag(UsePropertyBag());

				// make them use our option behaviour, but return any context sensitive
				// information such as defaults .. we'll do the inheritance chaining here!
				pContainer->m_optbeh = (OptBehaviour)((m_optbeh | OBBadContext | OBNoDepCheck) & ~OBInherit);

				GPT gptContainer = pContainer->GetIntProp(idProp, val);

				pContainer->m_optbeh = optbehOld;
 	   			(void) pContainer->UsePropertyBag(idOldBag);

				if (gptContainer == valid)
				{
					pContainer->ResetContainerConfig();
					return valid;
				}

				// chain our config.
				// look in the next container
				CProjItem * pNextContainer = (CProjItem *) pContainer->GetContainerInSameConfig();
				pContainer->ResetContainerConfig();
				pContainer = pNextContainer;
			}
		}

		//
		// *** base-case ***
		//
		// right context?
		if (!(m_optbeh & OBBadContext))
		{
			if (popthdlr != (COptionHandler *)NULL)
			{
				// make sure the option handling refers to us!
				popthdlr->SetSlob(this);

				// we need to find this in our default property map
				// ask our helper which map it is in

				// always show fake props, if inheriting
				if (((m_optbeh & OBInherit) && popthdlr->IsFakeProp(idProp)) ||
					(m_optbeh & OBShowDefault))
				{
					OptBehaviour optbehOld = m_optbeh;

					m_optbeh |= OBShowDefault;
					gpt = popthdlr->GetDefIntProp(idProp, val);
					m_optbeh = optbehOld;
				}
				
				// reset the option handler CSlob
				popthdlr->ResetSlob();
			}
		}
	}

 	// mustn't be OBAnti, the option handler takes care of this
	VSASSERT((m_optbeh & OBAnti) == 0, "Bad state for m_optbeh.  Option handler should handle this case.");

	return gpt;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetIntProp(UINT idProp, int val)
{
	BOOL fOk;

	if ((idProp == P_Proj_PerConfigDeps) && (GetProject() != NULL))
	{
		GetProject()->m_bProj_PerConfigDeps = val;
	}

	// mustn't be OBAnti, the option handler takes care of this for integer props
	VSASSERT((m_optbeh & OBAnti) == 0, "Mustn't be OBAnti.  Those belong to option handler");

	// need to do special handling here
	int valTemp = 0;
	GPT gpt;
	if (idProp == P_ItemOptState)
	{
		gpt = GetIntProp (P_ItemOptChanged, valTemp);
		if (gpt == valid)
		{
			val = valTemp ? 0x80000000 | val : val; // set the high bit if valTemp is set
			fOk = CSlob::SetIntProp(P_ItemOptState, val);
		}
		else
		{
			VSASSERT (FALSE, "Invalid value for P_ItemOptState!");
			return FALSE;
		}
	}
	else if (idProp == P_ItemOptChanged)
	{
		gpt = GetIntProp (P_ItemOptState, valTemp);
		if (gpt == valid)
		{
			val = val ? 0x80000000 | valTemp : valTemp;
			fOk = CSlob::SetIntProp(P_ItemOptState, val);
		}
		else
		{
			VSASSERT (FALSE, "Invalid value for P_ItemOptState!");
			return FALSE;
		}
	}
	else
	{
		fOk = CSlob::SetIntProp(idProp, val);
	}

	if (fOk && idProp == P_ItemExcludedFromBuild)
	{
		// FUTURE: Do THIS?
		// Finally, we want to mark the item's project to suggest
		// a relink.  Do this by specifying the last build flags
		// string to be empty:
		CProject * pProject = GetProject();
		VSASSERT(pProject != (CProject *)NULL, "Project not set!  Item in bad state.");

		// broadcast to our option handlers
		COptionHandler * popthdlr;
		g_pPrjcompmgr->InitOptHdlrEnum();
		while (g_pPrjcompmgr->NextOptHdlr(popthdlr))
		{
			// inform of this option change
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			popthdlr->OnOptionIntPropChange(P_ItemExcludedFromBuild, val);

			// reset the option handler CSlob
			popthdlr->ResetSlob();
		}
	}

	// get the option handler for the prop
	COptionHandler * popthdlr;
	if (fOk && ((popthdlr = g_pPrjcompmgr->FindOptionHandler(idProp)) != (COptionHandler *)NULL))
	{
		// inform of this option change
		// make sure the option handling refers to us!
		popthdlr->SetSlob(this);
		popthdlr->OnOptionIntPropChange(idProp, val);

		// reset the option handler CSlob
		popthdlr->ResetSlob();
	}

	return fOk;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetStrProp(UINT idProp, const CString & str)
{
	// get the option handler for this prop
	COptionHandler * popthdlr = g_pPrjcompmgr->FindOptionHandler(idProp);

	BOOL fIsListStrProp = (popthdlr != (COptionHandler *)NULL) && popthdlr->IsListStrProp(idProp);

	// only string lists and unk. opt. hdlr strings are available as anti-options
	VSASSERT ((m_optbeh & OBAnti) == 0 || fIsListStrProp || popthdlr->IsKindOf(RUNTIME_CLASS(COptHdlrUnknown)), "Only string lists and unk. opt. hdlr strings are available as anti-options!");

	if (popthdlr != (COptionHandler *)NULL)
	{
		// do we to do a type conversion ourselves?
		// ie. does the CSlob *not* support this tool option type?
		if (popthdlr->NeedsSubtypeConversion(idProp))
		{	
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);

			int nVal;

			BOOL fRet;

			// is this the empty string? if so we want
			// to nuke it from our property bag
			if (str.IsEmpty())
			{
				CPropBag * pPropBag = GetPropBag();
				VSASSERT(pPropBag != (CPropBag *)NULL, "Failed to get property bag!");

				pPropBag->RemoveProp(idProp);
				fRet = TRUE;
			}
			else if (!popthdlr->ConvertFromStr(idProp, str, nVal))
			{
				// no change, inform dependants of this
				InformDependants(idProp);
				fRet = FALSE;
			}
			else
				fRet = SetIntProp(idProp, nVal);

			// reset option handler CSlob
			popthdlr->ResetSlob();
			
			return fRet;
		}
 	}

	// setting the output directories?
	if (idProp == P_OutDirs_Target || idProp == P_OutDirs_Intermediate)
	{
		// if we're setting the output dirs props to an empty string, remove
		// the prop if it exists, only if we're a child that way the removal
		// will reset the prop to inherit from the parent
		if (m_pContainer != (CSlob *)NULL && str.IsEmpty())
		{
			GetPropBag()->RemovePropAndInform(idProp, this);
			return TRUE; 
		}
	}

	BOOL fOk = FALSE;

	// do we have a list of strings for this property?
	if (fIsListStrProp)
	{
		// figure add and subtract string props
		popthdlr->SetListStrProp(this, idProp, (CString &)str, m_optbeh & OBInherit, m_optbeh & OBAnti);
		fOk = TRUE;
	}
	else
	{
		fOk = CSlob::SetStrProp(idProp, str);
	}

	// inform of this option change
	if (fOk && popthdlr != (COptionHandler *)NULL)
	{
		// make sure the option handling refers to us!
		popthdlr->SetSlob(this);
		popthdlr->OnOptionStrPropChange(idProp, str);

		// reset option handler CSlob
		popthdlr->ResetSlob();
	}

	return fOk;
}
///////////////////////////////////////////////////////////////////////////////
GPT CProjItem::GetStrProp(UINT idProp, CString& val)
{
	// fake prop that is actually maintained by the Scc Manager
	if (idProp == P_SccStatus)
	{
		VSASSERT(FALSE, "P_SccStatus should be handled by Scc manager!");
		return invalid;
	}

	if (idProp == P_Title) // alias
		return GetStrProp(P_ProjItemName, val);

	// get the option handler for this prop
	COptionHandler * popthdlr = g_pPrjcompmgr->FindOptionHandler(idProp);

	// are we a string list prop?
	BOOL fIsListStrProp = (popthdlr != (COptionHandler *)NULL) && popthdlr->IsListStrProp(idProp);

	// only string lists and unk. opt. hdlr strings are available as anti-options
	VSASSERT ((m_optbeh & OBAnti) == 0 || fIsListStrProp || popthdlr->IsKindOf(RUNTIME_CLASS(COptHdlrUnknown)), "Only string lists and unk. opt. hdlr strings are available as anti-options");
	
	if (popthdlr != (COptionHandler *)NULL)
	{
		// do we to do a type conversion ourselves?
		// ie. does the CSlob *not* support this tool option type?
		if (popthdlr->NeedsSubtypeConversion(idProp))
		{	
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			GPT gptRet;

			// is this a valid prop?
			int nVal;
			if (GetIntProp(idProp, nVal) != valid)
			{
				gptRet = invalid;	
			}
			else
			{
				// is this a default, ie. not in any bag?
				OptBehaviour optbehOld = m_optbeh;
				m_optbeh &= ~OBShowDefault;
				GPT gpt = GetIntProp(idProp, nVal);
				m_optbeh = optbehOld;

				if (gpt != valid)
				{
					val = "";	// for defaults return the empty string
					gptRet = valid;
				}
				else
					gptRet = popthdlr->ConvertToStr(idProp, nVal, val) ? valid : invalid;		
			}

			// reset the option handler CSlob
			popthdlr->ResetSlob();

			return gptRet;
		}

	 	// if we have a default option map this must be an option
		// check it's dependencies
		if (!(m_optbeh & OBNoDepCheck))
		{
			BOOL fCheckDepOK;

			// the DepCheck needs to view the whole 'context' ie.
			// the tool options with inheritance
			// prevent the DepCheck() recursing
			OptBehaviour optbehOld = m_optbeh;
			m_optbeh |= OBInherit | OBShowDefault | OBNoDepCheck;

			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			fCheckDepOK = popthdlr->CheckDepOK(idProp);
			popthdlr->ResetSlob();

			m_optbeh = optbehOld;

			// is this an invalid option?
			if (!fCheckDepOK)	return invalid;
		}
	}

  	GPT gpt = invalid;	// default is the prop. find is invalid

	// do we have a list of strings for this property?
	// if so then we'll want to show this list
	if (fIsListStrProp && !m_fGettingListStr)
	{
		SUBTYPE st = popthdlr->GetDefOptionSubType(idProp);

		// join our directory string lists with ';'
		TCHAR chJoin = st == dirST ? _T(';') : _T(',');

		// show add and/or subtract props combined for this
		m_fGettingListStr = TRUE;
		gpt = popthdlr->GetListStrProp(this, idProp, val, m_optbeh & OBInherit, m_optbeh & OBAnti, chJoin);
		m_fGettingListStr = FALSE;
	}
	else
	{
		// usual CSlob property behaviour
		// ask the base-class to actual find the prop.
		gpt = CSlob::GetStrProp(idProp, val);
	}

	// does this property exist for this CSlob?
	if (gpt == invalid)
	{
		// fake prop for custom build description .. <- no inheritance!
		if ((m_optbeh & OBShowDefault) && idProp == P_CustomDescription)
		{
			// let the new project system handle the name
			return invalid;
		}

		// are we not at the root and inheriting?
		if (m_optbeh & OBInherit)
		{
			// automatically detect if we need to do a manual config?
			// we don't need to if we already have a manual config rec. to use
			CProjItem * pContainer = (CProjItem *) GetContainerInSameConfig();
			while (pContainer != (CSlob *)NULL)
			{
				// yes, so let's search in our container CSlob if we have one
				OptBehaviour optbehOld = pContainer->m_optbeh;
				int idOldBag = pContainer->UsePropertyBag(UsePropertyBag());

				// make them use our option behaviour, but return any context sensitive
				// information such as defaults .. we'll do the inheritance chaining here!
				pContainer->m_optbeh = (OptBehaviour)((m_optbeh | OBBadContext | OBNoDepCheck) & ~OBInherit);

				GPT gptContainer = pContainer->GetStrProp(idProp, val);

				pContainer->m_optbeh = optbehOld;
   				(void) pContainer->UsePropertyBag(idOldBag);

				if (gptContainer == valid)
				{
					pContainer->ResetContainerConfig();
					return valid;
				}

				// chain our config.
				// look in the next container
				CProjItem * pNextContainer = (CProjItem *) pContainer->GetContainerInSameConfig();
				pContainer->ResetContainerConfig();
				pContainer = pNextContainer;
			}
		}

		//
		// *** base-case ***
		//
		// right context?
		if (!(m_optbeh & OBBadContext))
		{
			if (popthdlr != (COptionHandler *)NULL)
			{
				// make sure the option handling refers to us!
				popthdlr->SetSlob(this);

				// we need to find this in our default property map
				// ask our helper which map it is in

				// always show fake props, if inheriting
				if (((m_optbeh & OBInherit) && popthdlr->IsFakeProp(idProp)) ||
					(m_optbeh & OBShowDefault))
				{
					OptBehaviour optbehOld = m_optbeh;

					m_optbeh |= OBShowDefault;
					gpt = popthdlr->GetDefStrProp(idProp, val);
					m_optbeh = optbehOld;
				}

				// reset the option handler CSlob
				popthdlr->ResetSlob();
			}
			// show the defaults for non-tool option props?
			else if (m_optbeh & OBShowDefault)
			{
				// only have target directory for project
				// don't have intermediate directories for groups
				if (idProp == P_OutDirs_Target || idProp == P_OutDirs_Intermediate)
				{
					val = ""; // default is nothing for the int/trg directories
					gpt = valid;
				}
			}
		}
	}

	return gpt;
}

GPT CProjItem::GetConvertedStrProp(UINT idProp, CString& val)
{
	GPT gptRet = GetStrProp(idProp, val);
	if (gptRet == valid)
		::ConvertMacros(val);
	return gptRet;
}

void CProjItem::SetOwnerProject(CProject * pProject, CTargetItem * pTarget)
{
	m_pOwnerProject = pProject;
	m_pOwnerTarget = pTarget;
	
	// repeat for all children*
	if (GetContentList())
	{
		POSITION pos;
	 	for (pos=GetHeadPosition(); pos!=NULL;)
	  	{
			// Any contained slobs should also be items:
			((CProjItem *)GetNext(pos))->SetOwnerProject(pProject, pTarget);
		}
	}
}

void CProjItem::IsolateFromProject()
{
	// update each config record
	UINT nIndex, nSize = GetPropBagCount();

	// copying into a non-projitem, so remove any links to Project
	for (nIndex = 0; nIndex < nSize; nIndex++)
	{
		// copy important pieces from project base record
		CConfigurationRecord * pcr = (CConfigurationRecord *)m_ConfigArray[nIndex];
		ForceConfigActive(pcr);

		theUndoSlob.Pause();	// don't record SetStrProp within SetSlopProp
		SetStrProp(P_ProjConfiguration,	pcr->m_pBaseRecord->GetConfigurationName());
		SetStrProp(P_ProjOriginalType, pcr->m_pBaseRecord->GetOriginalTypeName());
		theUndoSlob.Resume();
		
		// now set ourselves as our own Base record
		m_ConfigMap.RemoveKey((void*)pcr->m_pBaseRecord);
		pcr->m_pBaseRecord = pcr;
		m_ConfigMap.SetAt((void *)pcr->m_pBaseRecord, (void *)pcr);

		// reset config.
		ForceConfigActive();
	}

	// repeat for all children*
	if (GetContentList())
	{
		POSITION pos;
	 	for (pos=GetHeadPosition(); pos!=NULL;)
	  	{
			// Any contained slobs should also be items:
			((CProjItem *)GetNext(pos))->IsolateFromProject();
		}
	}
}

BOOL CProjItem::SetSlobProp(UINT idProp, CSlob * val)
{
	// only interested in container property changes
	if (idProp != P_Container)
		// pass on to the base-class
		return CSlob::SetSlobProp(idProp, val);

	// old container?
	CSlob * pOldContainer = m_pContainer; 

	// REVIEW: this currently happens during UNDO.  Bogus Undo record
	if (pOldContainer == val)
		return TRUE; // nothing to do

	// from a project?
	BOOL fFromPrj = m_pContainer && m_pContainer->IsKindOf(RUNTIME_CLASS(CProjItem)) && (((CProjItem *)m_pContainer)->GetProject() != NULL);

	// into a project?
	BOOL fToPrj = val && val->IsKindOf(RUNTIME_CLASS(CProjItem));

	BOOL fPrjChanged = FALSE;
	if (fFromPrj && fToPrj)
	{
		fPrjChanged = (((CProjItem *)val)->GetProject() != ((CProjItem *)m_pContainer)->GetProject());
	}
	// pre-move item
	if (!PreMoveItem(val, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	// do the 'containment' part of the move
	if (!MoveItem(val, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	// pos-move item, only call if not deleted!
	// ie. not deleted if moving to another container or
	// we're recording if, and hence moving into the undo slob.
	if (CouldBeContainer(val) &&
		!PostMoveItem(val, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
const CString CProjItem::EndOfBagsRecord = "\x08\x14\x53\x53\x42\x52"; // :-)

///////////////////////////////////////////////////////////////////////////////
//
//	Override CSlob's serialize function to save only private properties:

BOOL CProjItem::SerializePropMapFilter(int nProp)
{
	return ::IsPropPrivate (nProp);
}

///////////////////////////////////////////////////////////////////////////////
// Return a container-less, symbol-less, clone of 'this'
CSlob* CProjItem::Clone()
{
	CSlob * pClone = CSlob::Clone(); // call base class to creat clone
	VSASSERT(pClone->IsKindOf (RUNTIME_CLASS (CProjItem)), "Can only clone CProjItem objects");

	((CProjItem*)pClone)->SetFile(GetFilePath());

	if (GetProject() != NULL)
		((CProjItem *)pClone)->IsolateFromProject();

	return pClone;
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::CloneConfigs(const CProjItem * pItem)
{
//	We have moved into a new project tree and need to adopt its configurations
//	We'll enumerate throught the new parents configurations and create new
//	configs for any we don't have, and delete any configurations that the 
//	parent doesn't support.
//
//	We say one our configurations matches a parent configuration if its based
//	on the same project type and has the same name.
//
//	In the special case that we have no configurations, just blindly copy the
//	parent's:

	if (GetPropBagCount() == 0)
	{
		UINT nSize = pItem->GetPropBagCount();

		// create the new configuration records
		for (UINT nIndex = 0; nIndex < nSize; nIndex++)
		{
			const CConfigurationRecord * pcr = (CConfigurationRecord *) pItem->m_ConfigArray[nIndex];
			ASSERT_VALID(pcr);
			ASSERT_VALID(pcr->m_pBaseRecord);

			ConfigurationChanged(pcr->m_pBaseRecord);

			// validate newly-created CR
			pcr = (CConfigurationRecord *)m_ConfigArray[nIndex]; 
			ASSERT_VALID(pcr);
			ASSERT_VALID(pcr->m_pBaseRecord);													
		}
		VSASSERT(GetPropBagCount()==pItem->GetPropBagCount(), "Not all property bags were created!"); // make sure they all got created

		// Finally, make sure we have the same active config:
		if (pItem->m_pActiveConfig)	// May be null during desrialize
		{		
			ConfigurationChanged(pItem->m_pActiveConfig->m_pBaseRecord);
			ASSERT_VALID (m_pActiveConfig);
		}
		else
		{
			m_pActiveConfig = NULL; // don't leave as bogus value
		}
	}
	else
	{
		// if we got here we must be undo/redo'ing, dragging/dropping or cloning
		// if (!theUndoSlob.InUndoRedo())
		{
			// Configuration Matching. This is only used by cut/paste & drag/drop
			
			// For drag and drop the configurations should be identical
			// so we check this here!
			// However, for clipboard cut/paste,
			// the configurations will not necessarily match identically
			// and we will have to be somewhat cleverer than we already are. 

			int nIndex, nSize = pItem->GetPropBagCount();
			const CConfigurationRecord *pcr;

			for (nIndex = 0; nIndex < nSize; nIndex++)
			{
				pcr = (const CConfigurationRecord*)pItem->m_ConfigArray[nIndex];
				ASSERT_VALID (pcr);
				ASSERT_VALID (pcr->m_pBaseRecord);

				// look for matching config
				if (ConfigurationChanged(pcr->m_pBaseRecord))
				{
					// FUTURE: try for partial match
					// Last cr in m_ConfigArray is new
					// try to initialize based on projtype
				}
			}

			// Delete any unreferenced configs and reorder, if necessary
			FixConfigs(pItem);
			
			// Finally, make sure we have the same active config:
			if (pItem->m_pActiveConfig)	// May be null during desrialize
			{
				ConfigurationChanged (pItem->m_pActiveConfig->m_pBaseRecord);
				ASSERT_VALID (m_pActiveConfig);
			}
  		}
	}
	VSASSERT(GetPropBagCount()==pItem->GetPropBagCount(), "Not all property bags were created!");
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::FixConfigs(const CProjItem * pItem)
{
// Garbage collection

	// delete any unneeded source configs
	CVCPtrList deathRow;
	CConfigurationRecord * pcr;
	const CConfigurationRecord * pcrBase;
	int nSize = GetPropBagCount();
	for (int nIndex = 0; nIndex < nSize; nIndex++)
	{
		// look up the base config for pItem that matches each entry
		// by name.  If the base configs do not match, then this is
		// an unneeded entry that should be deleted.

		pcr = (CConfigurationRecord *)m_ConfigArray[nIndex];
		ASSERT_VALID (pcr);
		ASSERT_VALID (pcr->m_pBaseRecord);

		pcrBase = ((CProjItem *)pItem)->ConfigRecordFromConfigName(pcr->GetConfigurationName());
		if (!pcrBase || pcr->m_pBaseRecord != pcrBase->m_pBaseRecord)
		{
			// this one needs to be deleted
			deathRow.AddTail((void *)pcr->m_pBaseRecord);
		}
	}

	while (!deathRow.IsEmpty())
		DeleteConfigFromRecord((CConfigurationRecord *)deathRow.RemoveHead(), FALSE);

	VSASSERT(GetPropBagCount()==pItem->GetPropBagCount(), "Not all property bags are present!");

	// Now reorder remaining configs, if necessary, based on pItem
	nSize = pItem->GetPropBagCount();
	VSASSERT(nSize==GetPropBagCount(), "Not all property bags are present!"); // consistency check
	for (nIndex = 0; nIndex < nSize; nIndex++)
	{	
		pcrBase = ((CConfigurationRecord *)pItem->m_ConfigArray[nIndex])->m_pBaseRecord;
		m_ConfigMap.Lookup((void*)pcrBase, (void *&)pcr);
		m_ConfigArray[nIndex] = pcr;
	}
	
	//	Repeat for all children:
	if (GetContentList ())
	{
		POSITION pos;
		for (pos=GetHeadPosition(); pos!=NULL;)
		{
			// Any contained slobs should also be cleaned up
			((CProjItem *)GetNext(pos))->FixConfigs(pItem);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::DeleteConfigFromRecord (CConfigurationRecord *prec, BOOL bChildren)
{
//	Delete the configuration and tell our kids to do the same.  Note that
//  subprojects that get called for a parents config will do nothing since
// 	they won't find prec.

	// Notify target items about config deletions
	if (this->IsKindOf(RUNTIME_CLASS(CTargetItem)) ||
		this->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
 		InformDependants(SN_DESTROY_CONFIG, (DWORD_PTR)prec);
	}
 
	if (bChildren && GetContentList())
	{
		for (POSITION pos = GetHeadPosition(); pos != (POSITION)NULL;)
			((CProjItem *) GetNext (pos))->DeleteConfigFromRecord (prec);
	}

	// We may not have the config rec that we want to delete, in which case we
	// don't do anything (however we do still recurse to our children just above,
	// in case they have the config rec).
	CConfigurationRecord *pMyRec;
	if (m_ConfigMap.Lookup(prec, (void *&) pMyRec))
	{
		ASSERT_VALID(pMyRec);
		VSASSERT(pMyRec->m_pBaseRecord == prec, "Inconsistent config records!");

		// remove from both Map and Array
		int i = 0;
		int size = GetPropBagCount();

		m_ConfigMap.RemoveKey(prec);
		while (i < size)
		{
			if (pMyRec == m_ConfigArray.GetAt(i))
			{
				m_ConfigArray.RemoveAt(i);
				break;	// stop if found
			}

			i++;
		}

		// if we're deleting our current active then 
		// set it to NULL which will cause ::GetActiveConfig()
		// to re-figure it out
		if (m_pActiveConfig == pMyRec)
			m_pActiveConfig = (CConfigurationRecord *)NULL;

		delete pMyRec;
	}
}

///////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void CProjItem::AssertValid () const
{
	CProjItem * ncthis = (CProjItem *)this; // Brute force since we're const.

	// validate base component
	CObject::AssertValid();

	// validate content list
	if (ncthis->GetContentList()) ASSERT_VALID (ncthis->GetContentList());

	// validate our path
	if (GetFilePath ()) ASSERT_VALID (GetFilePath());
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::Dump (CDumpContext &DC) const
{
	//ASSERT_VALID(this);
	CObject *pObject;
	CConfigurationRecord *pcr;
	void *pv;
	TCHAR buf[257]; buf[256]=0;
	CProjItem *ncthis = (CProjItem *) this; // Brute force since we're const.

	if (DC.GetDepth () > 1) DC << 
	"************************************************************************";

	_snprintf ( buf, 256, "Dump of %s at %p:"
		" File path = \"%s\"",
		(const char *) GetRuntimeClass()->m_lpszClassName, (void *) this,
		(GetFilePath ()) ? ((const char *) *GetFilePath ()) : " (no file) " );
	DC << buf;

	int i;
	int size = GetPropBagCount();
	if (!size)	DC << 	"ConfigArray is empty\n";
	else
	{
		_snprintf ( buf, 256, "Config array has %i entries. Active is %p",
				size, (void *)((CProjItem *)this)->GetActiveConfig());
		DC << buf;	
		for (i =0; i < size; i++)
		{
			DC << (CConfigurationRecord *)m_ConfigArray[i];
		}
	}
	if (m_ConfigMap.IsEmpty ())	 DC << 	"ConfigMap is empty\n";
	else
	{
		_snprintf ( buf, 256, "Config map has %i entries. Active is %p",
				m_ConfigMap.GetCount (), (void *) ((CProjItem *)this)->GetActiveConfig());
		DC << buf;	
		for (VCPOSITION pos = m_ConfigMap.GetStartPosition (); pos != NULL;)
		{
			m_ConfigMap.GetNextAssoc ( pos, pv, (void *&) pcr );
			DC << pcr;
		}
	}

	if (ncthis->GetContentList()) 
	{
		if (ncthis->GetContentList()->IsEmpty()) 
									DC << "Contents list is empty.";
		else
		{
			DC << "Contents list:";
			for (POSITION pos = ncthis->GetContentList()->GetHeadPosition(); pos != NULL;)
			{
				pObject = ncthis->GetContentList()->GetNext (pos);
				if (DC.GetDepth () > 1)	pObject->Dump ( DC );
				else
				{
					_snprintf (buf, 256, "     a %s at %p",
				 		(const char *) pObject->GetRuntimeClass()->m_lpszClassName,
						(void *) pObject);
					DC << buf; 
				}
			}
		}
	}
}
#endif

void CProjItem::CopyCommonProps(CProjItem * pSrcItem, const CString & strTarget)
{
    CConfigurationRecord * pcrSrc = pSrcItem->ConfigRecordFromConfigName(strTarget, FALSE, FALSE);
    CConfigurationRecord * pcrDest = GetActiveConfig();
	if( pcrSrc == NULL ){
		// this is a sanity check since ConfigR...gName() can return NULL
		// if it does return NULL then there is no configuration to copy.
		// this should be ok.
		return;
	}

    CPropBag * pBagSrc = pcrSrc->GetPropBag(m_idBagInUse);
    CPropBag * pBaseBagSrc = pcrSrc->GetPropBag(BaseBag);
    CPropBag * pBagDest = pcrDest->GetPropBag(m_idBagInUse);
    CPropBag * pBaseBagDest = pcrDest->GetPropBag(BaseBag);

    // Copy all of the properties here
    //pBagDest->Clone(this, pBagSrc, FALSE);

    // Now we have to check for string list properties and potentially munge
    // the copied versions so that we only copy common settings!
    CProp * ppropSrc, * ppropBaseSrc, * ppropDest, * ppropBaseDest;

    POSITION pos = pBagSrc->GetStartPosition();
    while (pos != NULL)
    {
        UINT id;
		BOOL bInform;
        pBagSrc->GetNextAssoc(pos, id, ppropSrc);

		switch (ppropSrc->m_nType)

		{
			case integer:
				//
				// Inform dependants if setting P_ItemExcludedFromBuild to TRUE and
				// proprety for P_ItemExcludedFromBuild wasn't previously in pBagDest.
				// This is needed because CProjItem::GetIntProp has a hack to return
				// P_ItemExcludedFromBuild as TRUE when the proprety doesn't exist.  This
				// causes AssignActions to do an AddRefRef that needs to be undone.
				//
				bInform = P_ItemExcludedFromBuild==id && 
					NULL==pBagDest->FindProp(P_ItemExcludedFromBuild) &&
					((CIntProp *)ppropSrc)->m_nVal;

				pBagDest->SetIntProp(this, id, ((CIntProp *)ppropSrc)->m_nVal);

				if (bInform)
					InformDependants(id);
				break;

			case string:
			{
				COptionHandler * popthdlr = g_pPrjcompmgr->FindOptionHandler(id);
				BOOL fIsListStrProp = (popthdlr != (COptionHandler *)NULL) && popthdlr->IsListStrProp(id-1);
				if (!fIsListStrProp)
 					pBagDest->SetStrProp(this, id, ((CStringProp *)ppropSrc)->m_strVal);
 				else
				{
					// Ok now we may need to start munging to get correct props

					// Get all of our properties from the various bags
					ppropBaseSrc = pBaseBagSrc->FindProp(id);
					ppropDest = pBagDest->FindProp(id);
					ppropBaseDest = pBaseBagDest->FindProp(id);

					CString strNewProp;
					if (ppropDest)
					{
						// Work out the differences we need to apply to the destination bag
						COptionList optlstAdd, optlstSub;
						COptionList optlist;
						optlist.SetString(((CStringProp *)ppropBaseSrc)->m_strVal);

						optlist.Components(((CStringProp *)ppropSrc)->m_strVal, optlstAdd, optlstSub);

						// Apply the differences to the base prop val in the destination bag
						COptionList optlstDest;
						optlstDest.SetString(((CStringProp *)ppropDest)->m_strVal);
						optlstDest.Subtract(optlstSub);
						optlstDest.Append(optlstAdd);

						// Get the new prop string
						optlstDest.GetString(strNewProp);
					}
					else
						strNewProp = ((CStringProp *)ppropSrc)->m_strVal;

					// set the prop value
					pBagDest->SetStrProp(this, id, strNewProp);
				}
                break;
			}

			default:
				VSASSERT(FALSE, "Unhandled case");
				break;
		}
    }
}

int CProjItem::CompareSlob(CSlob * pCmpSlob)
{
	VSASSERT(pCmpSlob->IsKindOf(RUNTIME_CLASS(CProjItem)), "Can only compare CProjItem slobs!");

	// Put Groups at the start of this container
	if (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return 1;

	if (IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return -1;

	// Put subprojects at the start of this container
	if (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return 1;

	if (IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return -1;

	CString strExt, strCmpExt; 
	BOOL bCmpIsFileItem = (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CFileItem)));
	BOOL bIsFileItem = (IsKindOf(RUNTIME_CLASS(CFileItem)));
	if (bCmpIsFileItem)
		strCmpExt = ((CFileItem *)pCmpSlob)->GetFilePath()->GetExtension();
	if (bIsFileItem)
		strExt = GetFilePath()->GetExtension();

	// Put .lib files last and don't sort them alphabetically
	if (bIsFileItem && (strExt.CompareNoCase(".lib")==0))
		return 1;

	if (bCmpIsFileItem && (strCmpExt.CompareNoCase(".lib")==0))
		return -1;

	// Put .obj files last and don't sort them alphabetically
	if (bIsFileItem && (strExt.CompareNoCase(".obj")==0))
		return 1;

	if (bCmpIsFileItem && (strCmpExt.CompareNoCase(".obj")==0))
		return -1;

	// Everything else is sorted based on their P_Title property, i.e alphabetically

	int retval = CProjSlob::CompareSlob(pCmpSlob);

	// as a tie breaker, use the absolute path to at least get consistency
	if (retval == 0)
	{
		VSASSERT(GetFilePath() != NULL, "File path not initialized properly!");
		VSASSERT(((CProjItem *)pCmpSlob)->GetFilePath() != NULL, "File path not initialized properly!");
		retval = _tcsicmp((LPCTSTR)*GetFilePath(), (LPCTSTR)*((CProjItem *)pCmpSlob)->GetFilePath());
	}
	VSASSERT(retval != 0, "Two compared items can never be equal!"); // should never be equal
	return retval;
}

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------	CFileItem ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
#define theClass CFileItem
BEGIN_SLOBPROP_MAP(CFileItem, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

CFileItem::CFileItem () 
{
	// our file path
	m_pFilePath = NULL;

	// display name dirty to begin with
	m_fDisplayName_Dirty = TRUE;
}

BOOL CFileItem::SetIntProp(UINT idProp, int val)
{
	// which prop are we setting?
	switch (idProp)
	{
		case P_ItemExcludedFromBuild:
			break;

		case P_ItemIgnoreDefaultTool:
		{
			BOOL retval = CProjItem::SetIntProp(idProp, val);
			if (retval && GetProject() && GetProject()->m_bProjectComplete)
			{
				CConfigurationRecord * pcr = GetActiveConfig();
				CBuildAction::UnAssignActions(this, (CVCPtrList *)NULL, (CConfigurationRecord *)pcr->m_pBaseRecord);
				CBuildAction::AssignActions(this, (CVCPtrList *)NULL, (CConfigurationRecord *)pcr->m_pBaseRecord);
			}
			return retval;
		}
		break;
		default:
			break;
	}

	// pass on to base-class
	return CProjItem::SetIntProp(idProp, val);
}

BOOL CFileItem::SetStrProp(UINT idProp, const CString & str)
{
	if (idProp == P_ProjItemOrgPath)
	{
		if (str.IsEmpty())
		{
			GetMoniker(m_strOrgPath);  // default
			return TRUE;
		}

		// UNDONE: much further validation needed here!!!

		m_strOrgPath = str;
		InformDependants(idProp);
		GetProject()->DirtyProject();
		return TRUE;
	}
	return CProjItem::SetStrProp(idProp, str);
}

GPT CFileItem::GetStrProp(UINT idProp, CString& val)
{
	// is this a fake prop?
	switch (idProp)
	{
		case P_ProjItemName:	// yes
			if (m_fDisplayName_Dirty)
			{
				VSASSERT(m_pFilePath != NULL, "FilePath not initialized!");
				m_strDisplayName = m_pFilePath->GetFileName();
				m_fDisplayName_Dirty = FALSE;
			}
			val = m_strDisplayName;
			return valid;

		case P_ProjItemOrgPath:
		case P_FakeProjItemOrgPath:
			VSASSERT(m_pFilePath != NULL, "FilePath not initialized!");
			if (m_strOrgPath.IsEmpty())
				GetMoniker(m_strOrgPath);

			val = m_strOrgPath;
			return valid;

		case P_FileName:
		case P_ProjItemFullPath:
			VSASSERT(m_pFilePath != NULL, "FilePath not initialized!");
			val = (const TCHAR*) m_pFilePath->GetFullPath();
			return valid;

		// not allowed for file items
		case P_OutDirs_Target:
			if ((m_optbeh & OBShowMacro) && (GetProject()->GetOutDirString(val)))
				return valid; // config doesn't matter since always "$(OUTDIR)"
			else
				return invalid;

		case P_OutDirs_Intermediate:
			{
				// must only use INTDIR Macro, never INTDIR_SRC if defined
				if ((m_optbeh & OBShowMacro) && (GetOutDirString(val)))
					return valid;
				break;
			}
		default:
			break;
	}

	// no, pass on to base class
	return CProjItem::GetStrProp(idProp, val);
}

GPT CFileItem::GetIntProp(UINT idProp, int& val)
{
	// is this a fake prop?
	switch (idProp)
	{
		case P_ItemExcludedFromBuild:
		{
			// If this is an external target then all files are excluded from the build
			CProject * pProject = GetProject();

			// FUTURE: the top half of this 'if' may be redundant
            CProjType * pProjType;
            if (m_pForcedConfig != (CConfigurationRecord *) NULL)
            {
                pProject->ForceConfigActive((CConfigurationRecord *)m_pForcedConfig->m_pBaseRecord);
				pProjType = pProject->GetProjType();
                pProject->ForceConfigActive();
			}
            else
                pProjType = /*pProject->*/GetProjType();
			// fall through 
		}

		case P_ItemIgnoreDefaultTool:
		{
			GPT retval = CProjItem::GetIntProp(idProp, val);
			if (retval != valid)
			{
				val = 0;
				retval = valid;	// always valid if not excluded
			}
			return retval;
		}
		break;
		default:
			break;
	}

	// no, pass on to base class
	return CProjItem::GetIntProp(idProp, val);
}

// Return a container-less, symbol-less, clone of 'this'
CSlob * CFileItem::Clone()
{
	// call base class to create clone
	CSlob * pClone = CProjItem::Clone();
	VSASSERT(pClone->IsKindOf(RUNTIME_CLASS(CFileItem)), "Can only clone CFileItem objects!");

	return pClone;
}

//////////////////////////////////////////////////////////////////////////
BOOL CFileItem::SetFile(const CPath *pPath, BOOL bCaseApproved /*=FALSE*/) 
{
	// need to refresh this cache
	m_fDisplayName_Dirty = TRUE;

	// keep copy of old file path
	const CPath* pFilePathOld = m_pFilePath;

	BOOL bChanged = (pFilePathOld != pPath);

	// release a ref. to the old file
	if (bChanged)
	{
		if (pFilePathOld)
			delete pFilePathOld;
		if (pPath)
		{
			m_pFilePath = new CPath(*pPath);

			// invalidate cached relative path
			m_strMoniker.Empty();
			if ((GetProject()!= NULL) && (GetProject()->m_bProjectComplete))
			{
				m_strOrgPath.Empty();
				GetProject()->DirtyProject();
			}
			if ( (GetProject()!= NULL) && GetProject()->m_bConvertedDS4x)
			{
				m_strOrgPath.Empty();
			}


			((CPath *)GetFilePath())->SetAlwaysRelative();

			// this kind of gyration only works because we're not allowed to change the project after it is
			// loaded while still doing conversion.  Otherwise, the hack below would easily become outdated...
			// We're also making the basic assumption that if we find an .rc file, then there will be at least
			// one buildable one per config.  If not, oh, well, we're going to end up with additional resource
			// includes that we wouldn't otherwise have added.  Small bug.
			if (GetProject() && !GetProject()->m_bHaveODLFiles)
			{
				CString strODL = _T(".odl");
				CString strIDL = _T(".idl");
				CString strExt = GetFilePath()->GetExtension();
				strExt.MakeLower();
				GetProject()->m_bHaveODLFiles = (strODL == strExt || strIDL == strExt);
			}
		}
		else
			m_pFilePath = NULL;
	}

	return m_pFilePath != (const CPath*)NULL;	// success?
}
///////////////////////////////////////////////////////////////////////////////
const CPath *CFileItem::GetFilePath() const
{
	return m_pFilePath;
} 
///////////////////////////////////////////////////////////////////////////////
BOOL CFileItem::MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// moving into or out of the project?
	// project not being created/destroyed?
	VSASSERT((CProjItem *)(fToPrj ? pContainer : pOldContainer) != (CProjItem *)NULL, "Bad state for moving an item!");

	return CProjItem::MoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged);
}

BOOL CFileItem::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
 	if (!CProjItem::PostMoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;
 
	if (IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)))	// nothing more to do for build events
		return TRUE;

	// moving into or out of the project?
	// project not being created/destroyed?
	CProjItem * pProjCntr = (CProjItem *)(fToPrj ? pContainer : pOldContainer);
	VSASSERT(pProjCntr != (CProjItem *)NULL, "No container!");

	if ((fFromPrj || fToPrj) && pProjCntr->GetProject()->m_bProjectComplete)
	{
		// Send out 'addition' or 'deletion' of file notification
		if (fFromPrj && fToPrj)
		{
			VSASSERT(pOldContainer != pContainer, "Cannot move out of and into same container!");
			if (fPrjChanged)
			{
				VSASSERT(((CProjContainer *)pOldContainer)->GetTarget()!=((CProjContainer *)pContainer)->GetTarget(), "Cannot move out of and into same container!");
				
				// invalidate the moniker beacuse it changed projects.
				if( fPrjChanged ){
					m_strOrgPath.Empty();
					m_strMoniker.Empty();
				}
			}
			else
			{
				VSASSERT(((CProjContainer *)pOldContainer)->GetTarget()==((CProjContainer *)pContainer)->GetTarget(), "Cannot move out of and into same container!");
				// REVIEW: do nothing in this case
			}
		}
	}

	return TRUE;	// sucess
}
///////////////////////////////////////////////////////////////////////////////
void CFileItem::FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem)
{
	if (fo & flt_OnlyCustomStep)
		return;

	if (fo & flt_RespectItemExclude)
	{
		// get excluded from and convert into fAddItem by negating
		GetIntProp(P_ItemExcludedFromBuild, fAddItem);
		fAddItem = !fAddItem;
	}
	else
		fAddItem = TRUE;
}
///////////////////////////////////////////////////////////////////////////////
void CFileItem::GetMoniker( CString& cs )
{
	if (m_strMoniker.IsEmpty())
	{
		// Get the file's name relative to its project directory:
		const CPath *pPath = GetFilePath ();	
		VSASSERT (pPath, "Path not initialized!");
		if (!pPath->GetAlwaysRelative()) // this could fail if shared from SCC, etc.
			((CPath *)pPath)->SetAlwaysRelative(); // needed for GetRelativeName() call

		if (!pPath->GetRelativeName(GetProject()->GetWorkspaceDir(), m_strMoniker))
			{
				m_strMoniker = *pPath;
			}

		VSASSERT(!m_strMoniker.IsEmpty(), "Unable to get moniker!");
	}

	cs = m_strMoniker;
}

///////////////////////////////////////////////////////////////////////////////
//	Read in this file from the makefile reader
//

struct Pair {
	CObject *pObject;
	CConfigurationRecord *pcr;
	CBuildTool *pTool;
};


BOOL CFileItem::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
	CVCPtrList ListMacros;
	BOOL bPerConfigDeps = TRUE, bPerConfigDesc = TRUE;
	TCHAR *pBase, *pTokenEnd;
	CObject *pObject = NULL;
	Pair *pPair;

	TRY
	{
		// The next element better be a comment marking our start:
		pObject = mr.GetNextElement ();
		VSASSERT (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)), "Malformed project file");

		delete pObject;

		// The next item should be a macro with our file name:
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakMacro))
				||
			((CMakMacro*) pObject)->m_strName.CompareNoCase (pcFileMacroName)
			)  AfxThrowFileException (CFileException::generic);

		// This is the accpeted way to get a mungable pointer a CString's
		// data.  Note we never call ReleaseBuffer:

		pBase =	((CMakMacro*) pObject)->m_strValue.GetBuffer (1);	
		SkipWhite (pBase);
		GetMakToken (pBase, pTokenEnd);

		*pTokenEnd = _T('\0');

		CPath cpFile;
		m_strOrgPath = pBase;

		// translate $(MACRO_NAME) here.
		CString strBase = pBase;
#if 0
		if( !ReplaceEnvVars(strBase) ){
			strBase = pBase;
		}
#endif

		if (pBase == pTokenEnd ||
			!cpFile.CreateFromDirAndRelative (BaseDir, strBase))
			AfxThrowFileException (CFileException::generic);

		// preserve relative path if it begins with "..\"
		// if ((pBase[0] == _T('.')) && (pBase[1] == _T('.')))
		cpFile.SetAlwaysRelative();

		if (!SetFile(&cpFile, TRUE))
			AfxThrowFileException (CFileException::generic);

		delete pObject;

		m_cp = EndOfConfigs;
	   	for (pObject = mr.GetNextElement(); !IsEndToken(pObject); pObject = mr.GetNextElement())
	   	{
			if (IsPropComment(pObject) || IsAddSubtractComment(pObject))
				continue;

			if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				const TCHAR * pMacName = (const TCHAR *)((CMakMacro *)pObject)->m_strName;
				
				// Per-config deps.?
				if (_tcsnicmp("DEP_", pMacName, 4) == 0 ||
					_tcsnicmp("NODEP_", pMacName, 6) == 0 ||
					_tcsnicmp(_TEXT("USERDEP_"), pMacName, 8) == 0) // user-defined dependency
				{
					if (m_cp == EndOfConfigs)
						bPerConfigDeps = FALSE;
				}

				// Got a tool macro, store it away for later processing, after
				// we have created all the actions
				pPair = new Pair;
				pPair->pObject = pObject;
				pPair->pcr = GetActiveConfig();
				pPair->pTool = g_pBuildTool;
				ListMacros.AddTail( pPair );

				pObject = (CObject *)NULL;
				continue;
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				// Got a tool desc. block macro, store it away for later processing, after
				// we have created all the actions
				if (m_cp == EndOfConfigs)
					bPerConfigDesc = FALSE;

				pPair = new Pair;
				pPair->pObject = pObject;
				pPair->pcr = GetActiveConfig();
				pPair->pTool = NULL;
				ListMacros.AddTail( pPair );

				pObject = (CObject *)NULL;
				continue;
			}

			if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				// Setup this configuration
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}

	   		delete pObject; pObject = (CObject *)NULL;
		}				 

		// Make sure we got a file name:
		VSASSERT (GetFilePath () != NULL, "Failed to get file path!");

		// Do rest of the move
		(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

		//
		// Process tool macros now
		//
 		CConfigurationRecord * pcr;
		CProject * pProject = GetProject();
		CProjTempConfigChange projTempConfigChange(pProject);

		while( !ListMacros.IsEmpty() )
		{
			pPair =(Pair *)ListMacros.RemoveHead();
			pObject = pPair->pObject;
			pcr = pPair->pcr;
			g_pBuildTool = pPair->pTool;
			delete pPair;

			// Make sure we're in the right configuration
			projTempConfigChange.ChangeConfig((CConfigurationRecord *)pcr->m_pBaseRecord);

			// Descriptor block or macro?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				if (!bPerConfigDeps)
					m_cp = EndOfConfigs;
				else
					m_cp = FirstConfig;

				if (!SuckMacro((CMakMacro *)pObject, BaseDir, TRUE))
					AfxThrowFileException(CFileException::generic);
			}
			else
			{
				if (!bPerConfigDesc)
					m_cp = EndOfConfigs;
				else
					m_cp = FirstConfig;

				if (!SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException(CFileException::generic);				
			}
				
			delete pObject; pObject = (CObject *)NULL;
		}
	}
	CATCH ( CException, e)
	{
		// free the object that we were working on when the exception occured.
		if (pObject != (CObject *)NULL)
		{
	   		delete pObject; pObject = (CObject *)NULL;
		}

		// free all Tool macros that we hadn't processed yet.
		while( !ListMacros.IsEmpty() )
		{
			pPair = (Pair *)ListMacros.RemoveHead();
			delete pPair->pObject;
			delete pPair;
		}
		
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projcntr.cpp ===
//
//	PROJCNTR.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop

#include "targitem.h"
#include "project.h"
#include "makread.h"
#include "VCProjConvert.h"

IMPLEMENT_SERIAL (CProjContainer, CProjItem, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CTimeCustomBuildItem, CFileItem, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CProjGroup, CProjContainer, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CProjContainer ------------------------------
//                                 
///////////////////////////////////////////////////////////////////////////////
//
//
#define theClass CProjContainer
BEGIN_SLOBPROP_MAP(CProjContainer, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

CProjContainer::CProjContainer ()
{
}

CProjContainer::~CProjContainer ()
{
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands
// not terribly efficient;  Avoid except when necessary
// optimized for an already sorted list
void CProjContainer::SortContentList()
{
	INT_PTR nCount = m_objects.GetCount();
	if (nCount < 2)
		return;  // nop

	CObList OldList; OldList.AddTail(&m_objects);
	m_objects.RemoveAll();

	m_objects.AddHead(OldList.RemoveHead());  // just insert the first element
	BOOL bAdded;
	CProjItem * pItem;
	CProjItem * pCompItem;
	POSITION pos, curPos;
	while (!OldList.IsEmpty())
	{
		bAdded = FALSE;
		pItem = (CProjItem *)OldList.RemoveHead();
		pos = m_objects.GetTailPosition();
		while (pos != NULL)
		{
			curPos = pos;
			pCompItem = (CProjItem *)m_objects.GetPrev(pos);
			if (pItem->CompareSlob(pCompItem) >= 0)
			{
				m_objects.InsertAfter(curPos, pItem);
				bAdded = TRUE;
				break;
			}
		}
		if (!bAdded)
		{
			m_objects.AddHead(pItem);
		}
	}
	VSASSERT(m_objects.GetCount() == nCount, "Count mismatch!");
	OldList.RemoveAll();
};

CProjGroup *CProjContainer::AddNewGroup (const TCHAR * pszName /* = NULL */, const TCHAR * pszFilter /* = NULL */)
{
	CProjGroup *pGroup;

	if (pszName)
		pGroup = new CProjGroup(pszName);
	else
		pGroup = new CProjGroup;

	CProjContainer * pContainer = this;
	if (pContainer->IsKindOf(RUNTIME_CLASS(CProject)))
	{
		CTargetItem *pTarget;
		pTarget = GetTarget();
		pContainer = (CProjContainer *)pTarget;
	}
	pGroup->MoveInto(pContainer);

	if ((pszFilter) && (*pszFilter))
	{
		CString strFilter = pszFilter;
		pGroup->SetStrProp(P_GroupDefaultFilter, strFilter);
	}

	return pGroup;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjContainer::ReadInChildren(CMakFileReader& mr, const CDir &BaseDir)
{
//	Helper function to read in children from make file.  
	CObject *pObject = NULL;
	CProjItem *pItem = NULL, *pTemp;
	CRuntimeClass *pRTC;
	CMakComment *pMC;

	CProject * pProject = GetProject();

	TRY
    {
		do
		{
			pObject = mr.GetNextElement ();
			VSASSERT(pObject, "NULL object in element list!");

			if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
			{
				if ((pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) &&
					(((CMakDirective *)pObject)->m_dtyp == CMakDirective::DTYP_ENDIF))
						continue;	// orphan ENDIF might be okay

				AfxThrowFileException (CFileException::generic);
			}
			pMC = (CMakComment *) pObject;

			// Done if this is the end marker:
			if (IsEndToken (pObject)) break;

			// Figure out what kind of item this is supposed to be
			// and create it:
			pRTC = GetRTCFromNamePrefix(((CMakComment *) pObject)->m_strText);

			if (pRTC == NULL)
			{  
				delete (pObject);
				pObject = NULL;
				continue;
			}

			pItem = (CProjItem *) pRTC->CreateObject();

			CSlob * pContainer = this;

			// for v2 projects, put group into the target
			if ((pProject->m_bConvertedVC20) && (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))))
			{
				VSASSERT(pProject==this, "Not in the correct project?!?");
				pContainer = pProject->GetActiveTarget();
				VSASSERT(pContainer, "No active target!");
				CString strFilter = "cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90";
				pItem->SetStrProp(P_GroupDefaultFilter, strFilter);
			}

			// make sure this is something that belongs in us
			if (!CanContain(pItem))
				AfxThrowFileException (CFileException::generic);

			pTemp = pItem; pItem = NULL;

			// do a part of the move, ie. just fix up the containment structure
			(void)pTemp->PreMoveItem(pContainer, FALSE, TRUE, FALSE);
			(void)pTemp->MoveItem(pContainer, (CSlob *)NULL, FALSE, TRUE, FALSE);

			mr.UngetElement (pObject);
			pObject = NULL;

			// preserve the current config. while we read in each child
			// to ensure that the child doesn't have the side-effect of 
			// changing this
			CConfigurationRecord * pcrProject = pProject->GetActiveConfig();

			// read in the item data
			// (item will do the post-move)
			if (!pTemp->ReadFromMakeFile (mr, BaseDir))
				AfxThrowFileException (CFileException::generic);

			// preserve the current config.

			(void) pProject->SetActiveConfig(pcrProject);

		} while (TRUE);
 	}
	CATCH (CException, e)
	{
		if (pObject) delete (pObject);
		if (pItem) 	 delete (pItem);
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CProjGroup --------------------------------
//                                 
///////////////////////////////////////////////////////////////////////////////
//
//
#define theClass CProjGroup
BEGIN_SLOBPROP_MAP(CProjGroup, CProjContainer)
	STR_PROP(GroupName)
END_SLOBPROP_MAP()
#undef theClass

CProjGroup::CProjGroup ()
{
	m_strGroupName = CVCProjConvert::s_strSourceFilesString;
}

CProjGroup::CProjGroup (const TCHAR * pszName)
{
	m_strGroupName = pszName;
}

void CProjGroup::GetMoniker (CString& cs)
{
	VSASSERT (!m_strGroupName.IsEmpty(), "Project group name not initialized properly!");
	cs = m_strGroupName;
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands
///////////////////////////////////////////////////////////////////////////////
BOOL CProjGroup::ReadInChildren(CMakFileReader& mr, const CDir &BaseDir)
{
//	Helper function to read in children from make file.  
	CObject *pObject = NULL;
	CProjItem *pItem = NULL, *pTemp;
	CRuntimeClass *pRTC;
	CMakComment *pMC;

	// Get the target to which this belongs, which is the first
	// target
	CProject * pProject = GetProject();
	CProjItem * pContainer = (CProjItem *)GetContainer();
	CTargetItem* pTarget = (CTargetItem *)GetTarget();
	CSlob * pSlob = (CSlob *)this;
;			
#if 1	// UNDONE: remove once we keep V2 groups
	if (pContainer->IsKindOf(RUNTIME_CLASS(CProject)))	// VC 2.0 makefile
	{
		CString strTargetName;
		((CProject *)pContainer)->InitTargetEnum();
		((CProject *)pContainer)->NextTargetEnum(strTargetName, pTarget);
		pSlob = (CSlob *)pTarget;
	}
#endif

	CSlob * pSavedSlob = pSlob;
	TRY
    {
		do
		{
			pSlob = pSavedSlob;
			pObject = mr.GetNextElement ();
			VSASSERT (pObject, "NULL object in elements list!");

			if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
					AfxThrowFileException (CFileException::generic);
			pMC = (CMakComment *) pObject;

			// done if this is the end marker
			if (IsEndToken (pObject)) break;

			// figure out what kind of item this is supposed to be and create it
			pRTC = GetRTCFromNamePrefix(((CMakComment *) pObject)->m_strText);

			if (pRTC == NULL)
			{  
				delete (pObject);
				pObject = NULL;
				continue;
			}

			pItem = (CProjItem *) pRTC->CreateObject();

			// make sure this is something that belongs in us
			if (!CanContain(pItem))
			{
				// REVIEW: possible for VC20 projects also?
				if ((pProject->m_bConvertedDS4x) && (pTarget->CanContain(pItem)))
				{
					pSlob = pTarget; // meant to add this to the target instead!
				}
				else
				{
						AfxThrowFileException (CFileException::generic);
				}
			}
			pTemp = pItem; pItem = NULL;


			// do a part of the move, ie. just fix up the containment structure
			// move into the target rather than the group, we'll delete this group
			// after we've finished reading the VC++ 2.0 makefile
			(void)pTemp->PreMoveItem(pSlob, FALSE, TRUE, FALSE);
			(void)pTemp->MoveItem(pSlob, (CSlob *)NULL, FALSE, TRUE, FALSE);

			mr.UngetElement (pObject);
			pObject = NULL;

			// preserve the current config. while we read in each child
			// to ensure that the child doesn't have the side-effect of 
			// changing this
			CConfigurationRecord * pcrProject = GetProject()->GetActiveConfig();

			// read in the item data
			if (!pTemp->ReadFromMakeFile (mr, BaseDir))
				AfxThrowFileException (CFileException::generic);

			// preserve the current config.
			(void) GetProject()->SetActiveConfig(pcrProject);

		} while (TRUE);
	}
	CATCH (CException, e)
	{
		if (pObject) delete (pObject);
		if (pItem) 	 delete (pItem);
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}

GPT CProjGroup::GetStrProp ( UINT idProp, CString &str )
{
	// special per-item props
	if (idProp == P_GroupDefaultFilter || idProp == P_FakeGroupFilter)
	{
		str = m_strDefaultExtensions;
		return valid;
	}
	// P_ProjItemName is a fake prop that just maps to P_GroupName.
	return CProjContainer::GetStrProp ((idProp == P_ProjItemName || idProp == P_FakeProjItemName) ? P_GroupName : idProp, str);
}

BOOL CProjGroup::SetStrProp ( UINT idProp,  const CString &str )
{
	BOOL bRetval;
	BOOL bNameChanged = FALSE;
	CString strChanged;
	if (idProp == P_ProjItemName || idProp == P_GroupName) 
	{
		if (str.IsEmpty())
		{
			InformDependants(P_ProjItemName);
			return FALSE;
		}
	}

	// special per-item props
	if (idProp == P_GroupDefaultFilter)
	{
		m_strDefaultExtensions = str;
		return TRUE;
	}

	// P_ProjItemName is a fake prop that just maps to P_GroupName.
	bRetval = CProjContainer::SetStrProp ((idProp == P_ProjItemName) ? P_GroupName : idProp, (bNameChanged) ? strChanged : str);

	return bRetval;
}

BOOL CProjGroup::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
//	Read in this item and any childred from a makfile reader.  The make
//  comment is the first line of our stuff:
//
	TCHAR *pBase;
	CObject *pObject = NULL;
	CString str;

	TRY
    {
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
				AfxThrowFileException (CFileException::generic);

		// Get our name from the comment:
		pBase =	((CMakComment*) pObject)->m_strText.GetBuffer (1);	

		// Skip over the "Begin":
		SkipWhite    (pBase);
		SkipNonWhite (pBase);
		SkipWhite    (pBase);
		// Skip over the Group declaration
		SkipNonWhite (pBase);
		SkipWhite    (pBase);
		

		// Make sure its quoted, and then shave the quotes off:
		if (*pBase++ != _T('"') ||
			((CMakComment*) pObject)->
				m_strText[((CMakComment*) pObject)->m_strText.GetLength()-1] != _T('"'))
		    AfxThrowFileException (CFileException::generic);

		m_cp = EndOfConfigs;
		str = pBase;
		str.ReleaseBuffer ( str.GetLength () - 1 );
		SetStrProp(P_ProjItemName, str);
		delete (pObject); pObject = NULL; 

		for (pObject = mr.GetNextElement (); pObject;pObject = mr.GetNextElement ())
	   	{
			if (IsPropComment(pObject))
				continue;
			else if (IsAddSubtractComment(pObject))
				continue;
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				SuckMacro((CMakMacro *)pObject, BaseDir);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				if (!SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException (CFileException::generic);
			}
			// Comment marks start of children:
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment))) 
			{
				VSASSERT(m_cp==EndOfConfigs, "Parsing error on reading the make file!");
				mr.UngetElement ( pObject );
				pObject = NULL;
				break;
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakEndOfFile))) 
			{
				AfxThrowFileException (CFileException::generic);
			}

	   		delete (pObject); pObject = NULL;
		}				 

		// Read in children:
		if (!ReadInChildren(mr, BaseDir))
 			AfxThrowFileException (CFileException::generic);

		// preserve the current config.
		// REVIEW(kperry) what is this doing ? Should this be a set active config of
		// the config above ? I don't understand.
		(void) GetProject()->GetActiveConfig();
	}
	CATCH ( CException, e)
	{
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	// do the rest of the move
	(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

	return TRUE;	// success
}

BOOL CProjGroup::CanContain(CSlob* pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CFileItem)))
		return TRUE;

	if (pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
	{
		// need to ensure we're not dropping into a descendent
		const CSlob * pContainer;
		for (pContainer = GetContainer(); pContainer != NULL; pContainer = pContainer->GetContainer())
		{
			if (pContainer==pSlob)
				return FALSE;	// can't contain our parent
			else if (!pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup)))
				return TRUE;	// done if we've checked all groups
		}
		return TRUE; // okay if no container
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CTimeCustomBuildItem --------------------------------
//                                 
///////////////////////////////////////////////////////////////////////////////
//
//
#define theClass CTimeCustomBuildItem
BEGIN_SLOBPROP_MAP(CTimeCustomBuildItem, CFileItem)
END_SLOBPROP_MAP()
#undef theClass


CTimeCustomBuildItem::CTimeCustomBuildItem ()
{
	Init(NULL);
}

CTimeCustomBuildItem::CTimeCustomBuildItem(const TCHAR * pszName)
{
	Init(pszName);
}

void CTimeCustomBuildItem::Init(const TCHAR* pszName)
{
	m_strName = pszName;
	
	// our file path
	m_pFilePath = NULL;
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands

BOOL CTimeCustomBuildItem::MakeNameUnique(CString & strName)
{
	CProject *pProject;
	CObList ol;
	POSITION pos;
	CTimeCustomBuildItem *pGroup;
	BOOL	bCollision;
	int i = 1;
	CString str;

	pProject = GetProject ();
	if (!pProject) return FALSE;
	pProject->FlattenSubtree (ol, flt_Normal | flt_ExcludeDependencies);
	str = strName;
	CString fmt, key;
	fmt.LoadString (IDS_GROUP_CUSTOMIZER);
	key.LoadString (IDS_GROUP_CUSTOMIZER_KEY);
	
	do
	{
		bCollision = FALSE;

		for (pos = ol.GetHeadPosition (); pos != NULL && !bCollision; )
		{
			pGroup = (CTimeCustomBuildItem *) ol.GetNext (pos);
			if (!pGroup->IsKindOf ( RUNTIME_CLASS ( CTimeCustomBuildItem )))
				continue;

			if (pGroup != this && CompareMonikers (pGroup->m_strName, str) == 0)
				bCollision = TRUE;
		}		

		if ( bCollision )
		{
			int n;

			// If it already ends in "No. #", strip it before adding it again
			if (((n = strName.Find(LPCTSTR(key))) > 0)
				&& (n > (strName.GetLength() - (key.GetLength() + 2))))
				strName = strName.Left(n);

			TCHAR * pc = str.GetBuffer (256);

			// Make sure there is enough space for the customizer:
			if (strName.GetLength () > 255 - fmt.GetLength() -1 ) 
						strName.ReleaseBuffer (255 - fmt.GetLength() -1 );
			_snprintf ( pc, 
						255, 
						(const TCHAR *) fmt, 
						(const TCHAR *) strName,
						i );
			pc[255] = 0;							 
			str.ReleaseBuffer ();
 			i++; 
		}

	} while (bCollision);

	// Look at i to see if there ever was a collision:
	if (i > 1) 
		strName = str;

	return (i > 1);
}

GPT CTimeCustomBuildItem::GetStrProp ( UINT idProp, CString &str )
{
	// special per-item props
	if (idProp == P_ItemCustomBuildTime)
	{
		str = m_strCustomBuildTime;
		return valid;
	}

	return CFileItem::GetStrProp(idProp, str);
}


BOOL CTimeCustomBuildItem::SetStrProp(UINT idProp,  const CString &str)
{
	BOOL bNameChanged = FALSE;
	CString strChanged;
	if (idProp == P_ProjItemName || idProp == P_GroupName) 
	{
		if (str.IsEmpty())
		{
			InformDependants(P_ProjItemName);
			return FALSE;
		}
	}

	if (idProp == P_ItemCustomBuildTime)
	{
		m_strCustomBuildTime = str;
	}

	// If we're changing the group's name, make sure it's still unique:
	if (((idProp == P_ProjItemName) || (idProp == P_GroupName)) && (m_strName.Compare(str)))
	{
		strChanged = str;
		m_strName = str;
		bNameChanged = MakeNameUnique(strChanged);
	}

	return CFileItem::SetStrProp(idProp, (bNameChanged) ? strChanged : str);
}

///////////////////////////////////////////////////////////////////////////////
void CTimeCustomBuildItem::FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem)
{
	if (fo & flt_RespectItemExclude)
	{
		// get excluded from and convert into fAddItem by negating
		GetIntProp(P_ItemExcludedFromBuild, fAddItem);
		fAddItem = !fAddItem;
	}
	else
		fAddItem = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projprop.h ===
// Sushi Project Properties

#ifndef __PROJPROP__
#define __PROJPROP__

//
// CSlob notitifications
//
// Disable passing on of OnInform messages
#define SN_HOLD_UPDATES 8
// Re-enable OnInform messages. Assume property based caches must be refreshed.
#define SN_RELEASE_UPDATES 9
// Re-enable OnInform messages. Do not update cached info or set dirty state.
#define SN_RELEASE_UPDATES_NO_CHANGES 10
#define SN_PARENT_PROPERTY 11	// Some property of a parents parent changed.
#define SN_SAVED        12		// Slob was just serialized
// Filename that slob is saved in has changed
// (not a property since its not undoable)
#define SN_FILE_NAME    13
#define SN_LOADED       14		// Slob was just deserialized
#define SN_DIRTY        15		// Slob state force to clean
#define SN_CLEAN        16		// Slob state forced to dirty
#define SN_NEW_TREE     17		// Slob's tree has moved, ie the Slob's container
#define SN_DESTROY_OPTNODE	18	// Destroying an option tree node
#define SN_DESTROY_CONFIG   19  // Destroying a config

//
//	Special properties for build items (should be move to PROPS.H).
//	These are deivded into two sets: private props that get written into the
//	OPT file and public props that go in the .bld file:
//
#define PROJ_PROPS						1500
#define PROJ_PRIVATE_FIRST				PROJ_PROPS

#define P_BuildExcluded       			PROJ_PROPS + 2		// Per-config (currently NYI)
#define P_BuildFrozen       			PROJ_PROPS + 3		// Per-config (currently NYI)
#define P_BuildLocked					PROJ_PROPS + 4		// Per-config (currently NYI)
#define P_ExtOpts_CmdLine				PROJ_PROPS + 5		// Per-config, ext. makefiles only
#define P_ExtOpts_RebuildOpt			PROJ_PROPS + 6		// Per-config, ext. makefiles only
#define P_ExtOpts_Targ					PROJ_PROPS + 7		// Per-config, ext. makefiles only
#define P_ExtOpts_BscName				PROJ_PROPS + 8		// Per-config, ext. makefiles only
#define P_ExtOpts_Platform				PROJ_PROPS + 9		// Per-config, ext. makefiles only	// "Win32 (80x86), "Macintosh (680x0), etc.
//#define P_ExtOpts_ClsWzdName			PROJ_PROPS + 10		// Per-config, ext. makefiles only
#define P_ProjActiveConfiguration		PROJ_PROPS + 11		// Only CProject object has this
#define P_Caller						PROJ_PROPS + 12		// Per-config
#define P_Args							PROJ_PROPS + 13		// Per-config
#define P_PromptForDlls					PROJ_PROPS + 14  	// Per-config
#define P_RemoteTarget					PROJ_PROPS + 15		// Per-config
#define P_WorkingDirectory				PROJ_PROPS + 16		// Per-config
#define P_ItemOptState					PROJ_PROPS + 17  	// Per-config
#define P_ExtOpts_WorkingDir			PROJ_PROPS + 18 	// Per-config, ext. makefiles only

#define P_HasExternalDeps				PROJ_PROPS + 31		// This mean that we should create an external dep folder.

#define	P_DebugRemote					PROJ_PROPS + 32		// Is this remote?
#define	P_DebugRemoteHost				PROJ_PROPS + 33		// Remote machine to use
#define	P_DebugAttach					PROJ_PROPS + 34		// Should we Attach or Launch?
#define	P_DebugDebug					PROJ_PROPS + 35
#define	P_DebugNative					PROJ_PROPS + 36		// Should we Debug native?

#define PROJ_PRIVATE_LAST				PROJ_PROPS + 49

//
// Properties in this range are NOT per configuration.
//
#define PROJ_NOT_PER_CONFIG_FIRST		PROJ_PROPS + 50

#define P_GroupName						PROJ_NOT_PER_CONFIG_FIRST + 0
#define P_GroupDefaultFilter			PROJ_NOT_PER_CONFIG_FIRST + 1
#define P_TargetName					PROJ_NOT_PER_CONFIG_FIRST + 2	

#define P_ProjSccProjName				PROJ_NOT_PER_CONFIG_FIRST + 3
#define P_ProjSccRelLocalPath			PROJ_NOT_PER_CONFIG_FIRST + 4
#define P_ItemExcludedFromScan			PROJ_NOT_PER_CONFIG_FIRST + 5

#define P_Proj_PerConfigDeps			PROJ_NOT_PER_CONFIG_FIRST + 6

#define PROJ_NOT_PER_CONFIG_LAST		PROJ_PROPS + 75

//
// Properties in this range are PER CONFIGURATION
// (meaning they go into property bags).
//
#define PROJ_PER_CONFIG_FIRST		PROJ_PROPS + 76

#define P_ProjConfiguration			PROJ_PER_CONFIG_FIRST + 0	// Only CProject object has this
#define P_ProjOriginalType			PROJ_PER_CONFIG_FIRST + 1	// Only CProject object has this
#define P_OutDirs_Intermediate		PROJ_PER_CONFIG_FIRST + 2
#define P_OutDirs_Target			PROJ_PER_CONFIG_FIRST + 3
#define P_ItemExcludedFromBuild		PROJ_PER_CONFIG_FIRST + 4 	// All CProjItems have this
#define P_GroupHasPerGroupFlags		PROJ_PER_CONFIG_FIRST + 5	// Only CProjGroup objects have this
#define P_ProjUseMFC				PROJ_PER_CONFIG_FIRST + 6	// Only CProject object has this
#define P_UseDebugLibs				PROJ_PER_CONFIG_FIRST + 7	// Only CProject object has this
#define P_Proj_CmdLine				PROJ_PER_CONFIG_FIRST + 8	// Only CProject object has this (on external targets)
#define P_Proj_RebuildOpt			PROJ_PER_CONFIG_FIRST + 9	// Only CProject object has this (on external targets)
#define P_Proj_Targ					PROJ_PER_CONFIG_FIRST + 10	// Only CProject object has this (on external targets)
#define P_Proj_BscName				PROJ_PER_CONFIG_FIRST + 11	// Only CProject object has this (on external targets)
//#define P_Proj_WorkingDir           PROJ_PER_CONFIG_FIRST + 12  // Only CProject object has this
#define P_ProjClsWzdName			PROJ_PER_CONFIG_FIRST + 12  // Only CProject object has this
#define P_Proj_TargDefExt			PROJ_PER_CONFIG_FIRST + 13	// Only CProject object has this
#define P_Proj_TargDir				PROJ_PER_CONFIG_FIRST + 14	// Only CProject object has this
#define P_Proj_IgnoreExportLib		PROJ_PER_CONFIG_FIRST + 15	// Only CProject object has this (on dll based targets)
#define P_ItemIgnoreDefaultTool		PROJ_PER_CONFIG_FIRST + 16
#define P_ItemCustomBuildExt		PROJ_PER_CONFIG_FIRST + 17
#define P_ItemCustomBuildTime		PROJ_PER_CONFIG_FIRST + 18
#define P_Proj_CleanLine			PROJ_PER_CONFIG_FIRST + 19
#define P_Proj_ComPlus				PROJ_PER_CONFIG_FIRST + 20	// Only CProject object has this (on external targets)
#define P_ItemBuildTool				PROJ_PER_CONFIG_FIRST + 21
#define P_Proj_UserToolsName		PROJ_PER_CONFIG_FIRST + 22
#define P_ConfigDefaultDebugExe     PROJ_PER_CONFIG_FIRST + 24	// fall-back debug exe to use if P_Caller is invalid
#define P_ItemDeployMode			PROJ_PER_CONFIG_FIRST + 25
#define P_ItemDeployType			PROJ_PER_CONFIG_FIRST + 26
#define P_Proj_CmdLineOutputs		PROJ_PER_CONFIG_FIRST + 27	// Only CProject object has this (on external targets)

#define NoUseMFC					0 // not using MFC
#define UseMFCInLibrary				1 // using MFC by static link eg. nafxcwd.lib
#define UseMFCInDll					2 // using MFC in shared DLL eg. mfc300d.dll
#define UseMFCDefault				UseMFCInDll // default

#define DoNotDeploy					0	// Do not deploy this file
#define Deploy						1	// deploy this file
#define DeloyAsDependency			2	// This is a dependancy to a deployed output
#define DoNotDeloyAsDependency		3	// This is a dependancy to a deployed output

#define PROJ_PER_CONFIG_UNKNOWN			PROJ_PROPS + 150
#define PROJ_PER_CONFIG_LAST			PROJ_PROPS + 399
#define PROJ_OPT_UNKNOWN				PROJ_PROPS + 400

// Build system option handler components are allocated a property range
// where all ids in the range are >= PROJ_BUILD_OPTION_FIRST and < PROJ_BUILD_OPTION_PRIVATE_FIRST
// There are PROJ_BUILD_OPTION_RANGE props that can be allocated
#define PROJ_BUILD_OPTION_FIRST			PROJ_OPT_UNKNOWN + 100
#define PROJ_BUILD_OPTION_PRIVATE_FIRST 0x8000
#define PROJ_BUILD_OPTION_RANGE			PROJ_BUILD_OPTION_PRIVATE_FIRST - PROJ_BUILD_OPTION_FIRST
// Deferred tool option props.
// 0 = Don't defer, 1 = Defer, 2 = Never build
#define P_DeferredMecr					PROJ_BUILD_OPTION_PRIVATE_FIRST + 0
#define P_NoDeferredBscmake				PROJ_BUILD_OPTION_PRIVATE_FIRST + 1
#define PROJ_BUILD_OPTION_PRIVATE_LAST	PROJ_BUILD_OPTION_PRIVATE_FIRST + 99

#define PROJ_BUILD_OPTION_LAST			PROJ_BUILD_OPTION_FIRST + PROJ_BUILD_OPTION_RANGE + 100 

//
// General properties
//
#define PROJ_GENERAL					PROJ_BUILD_OPTION_LAST + 1

//
// Tool Component Props
//
#define P_CompName					PROJ_GENERAL + 0
#define P_ToolExeName				PROJ_GENERAL + 1
#define P_ToolMenuText				PROJ_GENERAL + 2
#define P_ToolPerProject			PROJ_GENERAL + 3
#define P_ToolInternal				PROJ_GENERAL + 4
#define P_ToolInput					PROJ_GENERAL + 5
#define P_ToolOutput				PROJ_GENERAL + 6
#define P_ToolCommand				PROJ_GENERAL + 7
#define P_ToolPrefix				PROJ_GENERAL + 8
#define P_CustomDescription			PROJ_GENERAL + 9
#define P_CustomOutputSpec			PROJ_GENERAL + 10
#define P_CustomCommand				PROJ_GENERAL + 11
#define P_CustomMacros              PROJ_GENERAL + 12

// Support custom build step dependencies
#define P_UserDefinedDeps			PROJ_GENERAL + 13

// Pre-link command step		 NOTE: needed only for conversion
#define P_PreLink_Description       PROJ_GENERAL + 14
#define P_PreLink_Command           PROJ_GENERAL + 15

// Post-build command step		 NOTE: needed only for conversion
#define P_PostBuild_Description     PROJ_GENERAL + 16
#define P_PostBuild_Command         PROJ_GENERAL + 17

#define PROJ_BUILD_TOOL_FIRST		P_CompName
#define PROJ_BUILD_TOOL_LAST		P_PostBuild_Command

#define PROJ_GENERAL_LAST			PROJ_GENERAL + 99

#if PROJ_BUILD_TOOL_LAST > PROJ_GENERAL_LAST
#error PROJ_BUILD_TOOL_LAST > PROJ_GENERAL_LAST
#endif

//
// Faked properties
//
#define PROJ_FAKE					PROJ_GENERAL_LAST + 1
#define P_ProjItemName				PROJ_FAKE + 0
#define P_ProjItemIconWell			PROJ_FAKE + 1
#define P_ProjItemIconIdx			PROJ_FAKE + 2
#define P_ProjItemFullPath			PROJ_FAKE + 3
#define P_ProjItemDate				PROJ_FAKE + 4
#define P_ProjAppWizUseMFC			PROJ_FAKE + 7
#define P_ItemOptChanged			PROJ_FAKE + 8
#define P_BldrFileName				PROJ_FAKE + 9

//
// Target reference name
#define P_TargetRefName				PROJ_FAKE + 10

//
// Tools property page
#define P_ItemTools					PROJ_FAKE + 11
#define P_ItemSettings				PROJ_FAKE + 12
#define P_ItemInput					PROJ_FAKE + 13
#define P_ItemOutput				PROJ_FAKE + 14
#define P_ItemDependency			PROJ_FAKE + 15

#define P_ProjItemOrgPath			PROJ_FAKE + 16
#define P_FakeProjItemOrgPath		PROJ_FAKE + 17
#define P_FakeProjItemName			PROJ_FAKE + 18
#define P_FakeGroupFilter			PROJ_FAKE + 19

#ifdef _DEBUG
// These props are used to support the "project info" prop pages (debug only).
#define P_D_Target					PROJ_FAKE + 90
#define P_D_PropList				PROJ_FAKE + 91
#define P_D_PropType				PROJ_FAKE + 92
#define P_D_PropValue				PROJ_FAKE + 93
#define P_D_PropBag					PROJ_FAKE + 94
#endif

// These props are used exclusively by QA to inquire about project item props.
#define P_QA_ProjItemType			PROJ_FAKE + 95
#define QA_TypeIs_Target			0
#define QA_TypeIs_Group				1
#define QA_TypeIs_File				2

#define PROJ_FAKE_LAST				PROJ_FAKE + 99

//
// Scecial props that get read in, but never written:
//
#define P_ProjMarkedForScan			PROJ_FAKE_LAST + 1
#define P_ProjMarkedForSave			PROJ_FAKE_LAST + 2
#define P_ProjHasNoOPTFile			PROJ_FAKE_LAST + 3
#define P_TargNeedsDepUpdate		PROJ_FAKE_LAST + 4

// Helper functions for determining what kind of prop something is:
__inline BOOL IsPropPrivate(int nProp)
{
	// o in our private range?
	// o one of our tool option private props?
	if ((nProp >= PROJ_PRIVATE_FIRST && nProp <= PROJ_PRIVATE_LAST) ||
		(nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST && nProp <= PROJ_BUILD_OPTION_PRIVATE_LAST))
		return TRUE;	// private

	return FALSE; // public
}

__inline BOOL IsPropPublic(int nProp)
{
	// is this not in  our private range?
	if (nProp > PROJ_PRIVATE_LAST && nProp <= PROJ_GENERAL_LAST)
	{
		// make sure it's not a tool option private prop!
		if (nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST && nProp <= PROJ_BUILD_OPTION_PRIVATE_LAST)
			return FALSE;	// private!

		return TRUE;	// public
	}

	return FALSE;	// private
}

#endif // __PROJPROP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\project.h ===
///////////////////////////////////////////////////////////////////////////////
//
// PROJECT.H
//                                                                             
///////////////////////////////////////////////////////////////////////////////
#ifndef __PROJECT_H__
#define __PROJECT_H__


#ifndef __PROJITEM__
#include "projitem.h"
#endif

extern  BOOL	g_bInProjClose;

// All CProject 'exported' functions to other packages should be
// virtual so that cross-DLL function calling indirects through
// the object VTABLE ptr
#define EXPORTED virtual

class CBuildPackage;
class CTempMaker;
class CPlatform;

///////////////////////////////////////////////////////////////////////////////

class CToolsMap
{
public:
	CToolsMap() {
	m_pBuildTool = NULL;
	m_strExtensions = "";
	m_bExternalTool = FALSE;
	}
	~CToolsMap() {}

	CString GetExtensions() {return m_strExtensions;}
	BOOL IsExternalTool(){return m_bExternalTool;}

	void * m_pBuildTool;
	CString m_strExtensions;
	BOOL m_bExternalTool;
};


///////////////////////////////////////////////////////////////////////////////
class  CProject : public CProjContainer
{
	friend class CBuildPackage;
	friend class CProjectView;
	friend class CBldSysIFace;
	friend class CProjTempConfigChange;
	friend class CProjDeferDirty;
	friend class CProjOptionsDlg;
	friend class CProjItem;

//
//	Top level project class.  May be more than one if there are subprojects.
//
	DECLARE_SERIAL (CProject)

public:
	// constructor
	CProject ();

	// destroy contents
	void Destroy();

	// destructor
	virtual ~CProject();

// CSlob methods:
	// Special CloneConfigs method.  As a subproject, the project tries
	// to switch to a compatible configuration:
	virtual void CloneConfigs ( const CProjItem *pItem ) {}

	// Hook GetIntProp & GetStrProp to provide some defaults.
	virtual GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString& val);

	// We want to hook into the SetStrProp so we can catch configuration changes.
	virtual BOOL SetStrProp(UINT idProp, const CString& val);

	// This is our internal CanAdd method, and tells us what we can
	// add to this slob container
	// In this case we can add CProjGroup's but nothing else.
	virtual BOOL CanContain(CSlob* pSlob);	

	// File I/O and creation:
	// Fills out a new project:
	BOOL InitNew (const CVCPtrList * pProjTypeList); // Uses a temporary file.
	BOOL InitFromFile (const char *pFileName, BOOL bLoadOPTFile = TRUE);

	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);

	// Describes how we flatten a project node
	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);

public:
	CDir & GetWorkspaceDir() { return m_ProjDir; }
	CDir & GetProjDir(CConfigurationRecord * pcr = NULL);
	const CPath* GetFilePath() const;

// Other API:
	// Get the project's toolset
	EXPORTED INT GetProjectToolset();

	// Returns or'ed together ProjAttribtues (get this from the 
	// CProjType)
	EXPORTED int GetTargetAttributes ();

	// Read makefile.  Assume file name has already been set:
	enum ReadMakeResults
	{
		ReadExternal,
		ReadInternal,
		ReadError,
		ReadExportedMakefile,
	};

	// .MAK reading
	ReadMakeResults ReadMakeFile (BOOL& bProjectDirty);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);
	
	// Read comments listing what configurations there are and
	// what project types they reference.  Also read our the current active
	// configuration back in:
	BOOL ReadConfigurationHeader(CMakFileReader& mr);

public:		
	// Set the value of m_bProjWasReadOnly by checking the .MAK file
	// on disk to see if it's read-only or not.
	void		RecheckReadOnly() { m_bProjWasReadOnly = GetFilePath()->IsReadOnlyOnDisk(); }

	void GetName(CString &strName ){ 
		CConfigurationRecord * pcr = GetActiveConfig();
		if(pcr)
			pcr->GetProjectName(strName);
	};

	// delete configuration named strName, and changed the active configuration
	// to strNewConfig.
	// strNewConfig configuration must already exist in the configuration map.
	BOOL	DeleteConfig ( const CString& strName , const CString& strNewConfig = "");

	// Create a new congugration.  Note that creation is a three step process:
	// 1. Create new config.  2. Initizlize new configs type and so on.
	// 2. Make new config active (even if you'll deactivate immediadly)
	BOOL 	CreateConfig ( const CString& strName );

	// Return the platform object corresponding to the current target.
	EXPORTED CPlatform * GetCurrentPlatform();


	// The Configuration manager api
	//
	// Set the currently active target configuration
	// If 'fQuite' is TRUE then no UI changes will be apparent.
	CConfigurationRecord * SetActiveConfig(CConfigurationRecord *, BOOL fQuite = TRUE);
	CConfigurationRecord * SetActiveConfig(const CString& strConfigName, BOOL fQuite = TRUE);

	// The Target manager api
	//
	// Get the target item associated with a given target name
 	CTargetItem* GetTarget(const TCHAR * pchTargetName);

	// Get the target item corresponding to the currently selected config
	CTargetItem* GetActiveTarget();

	// Register a target with the target manager. This is used during
	// project loading only
	BOOL RegisterTarget(const CString& strTargetName, CTargetItem* pTarget);

	// De-register a target with the target manager.
	BOOL DeregisterTarget(const CString& strTargetName, CTargetItem* pTarget);

	// Creates a new target (actually creates a new config and a new
	// CTargetItem)
	BOOL CreateTarget(const CString& strTargetName, CProjType* pProjType, const CString& strMirrorFrom = _T(""));

	// Deletes an existing target
	BOOL DeleteTarget(const CString& strTargetName);

	CConfigurationRecord * FindTargetConfig(CString & strTargetName);

	// Target enumeration
	void InitTargetEnum() { m_posTarget = m_TargetMap.GetStartPosition(); }
	BOOL NextTargetEnum(CString& strTargetName, CTargetItem* & pTarget)
	{
		if (m_posTarget == (POSITION)NULL)
			return FALSE;
		m_TargetMap.GetNextAssoc(m_posTarget, strTargetName, (void* &)pTarget);

		// 2173: need to get name with correct case preserved
		FindTargetConfig(strTargetName);

		return TRUE;
	}

	BOOL NextTargetEnum(CTargetItem* & pTarget)
	{
		if (m_posTarget == (POSITION)NULL)
			return FALSE;

		CString strDummy;
		m_TargetMap.GetNextAssoc(m_posTarget, strDummy, (void* &)pTarget);
		return TRUE;
	}
	int GetTargetCount() { return (int)m_TargetMap.GetCount(); }

protected:
	CConfigurationRecord *CreateConfigRecordForConfig( const CString & strConfig);
	DECLARE_SLOBPROP_MAP()

public:

    // Project dirty flag access functions
	__inline void DirtyProject()
	{
		if ((!m_bProjectDirty) && (m_bOkToDirty) && (!g_bInProjClose))
			DirtyProjectEx();
		m_bDirtyDeferred = !m_bProjectDirty;
	}
	__inline void CleanProject() { m_bProjectDirty = m_bDirtyDeferred = FALSE; }
	__inline BOOL IsOkToDirty() { return (m_bOkToDirty && !g_bInProjClose); }
	__inline BOOL IsDirtyDeferred() { return m_bDirtyDeferred; }
	__inline void SetOkToDirtyProject(BOOL bOk = TRUE) { m_bOkToDirty = bOk; }

	static void InitProjectEnum();
	static const CProject * NextProjectEnum(CString & strBuilder, BOOL bOnlyLoaded = TRUE);
	static void GlobalCleanup();
	__inline BOOL IsLoaded() const { return m_bProjectComplete; /* REVIEW */ }

	const CString & GetTargetName();
	__inline void SetTargetName(const CString & str) { m_strTargetName = str; }

	BOOL GetMatchingConfigName(CProject * pMatchProject, CString &strMatched, BOOL bInvalid);

	void SetBuildToolsMap();

protected:
	BOOL ConvertDirs();

private:
	BOOL IsCustomBuildMacroComment(CObject* pObject);
	BOOL ReadCustomBuildMacros(CMakFileReader& mr);
	virtual void DirtyProjectEx();


    // The project dirty flag. Corresponds to old project doc dirty flag
protected:
    BOOL    m_bProjectDirty:1;    // Is this project object dirty??

public:
	CDir			m_ActiveTargDir;	// Used ???

	CString		m_strProjItemName;			// used  ???
	CString		m_strProjSccProjName;
	CString		m_strProjSccRelLocalPath;

	// our configuration information
	CString		m_strProjActiveConfiguration;	// used  ???
	CString		m_strProjDefaultConfiguration; // CFG= line from makefile
	CString		m_strProjStartupConfiguration; // Primary/Supported cfg from makefile

	// TRUE if the .MAK file was read-only last time we checked.  Of
	// course, its state may have changed; call RecheckReadOnly()
	// to update this variable with a check of the file on disk.
	BOOL		m_bProjWasReadOnly:1;

	// Makefile errored during open due to requirement to use MFC and MFC is not installed
	BOOL		m_bGotUseMFCError:1;
	
	// .MAK reading (conversion of old VC++ 2.0 projects)
	BOOL m_bConvertedVC20:1;
	// .MAK reading (conversion of old DS 4.x projects)
	BOOL m_bConvertedDS4x:1;
	// .DSP reading (conversion of old DS 5.x projects)
	BOOL m_bConvertedDS5x:1;
	// .DSP reading (conversion of old DS 6.0 projects)
	BOOL m_bConvertedDS6:1;
	// .DSP reading (conversion of old DS 6.1 projects)
	BOOL m_bConvertedDS61:1;

	// Makefile has been freshly converted from an external makefile
	BOOL m_bProjExtConverted:1;

	// Makefile has been freshly converted from an 'old' makefile version
	BOOL m_bProjConverted:1;

	// Special properties that are only set when read in from the makefile.
	BOOL m_bProj_PerConfigDeps:1;

	BOOL m_bProjectComplete:1;
	BOOL m_bPrivateDataInitialized:1;

	BOOL m_bHaveODLFiles:1;

private:	
	BOOL    m_bDirtyDeferred:1;   // Mark dirty, but do it "later"
    BOOL    m_bOkToDirty:1;       // Ok to dirty project

	CDir				m_ProjDir;
	CPath*				m_pFilePath;		// path for .mak file.
	CString				m_strTargetName;
	int					m_nDeferred;		// ref counting

	CRITICAL_SECTION	m_critSection;	// Used for CProjTempConfigChange. 

	// This map contains the names of targets and the corresponding
	// CTargetItem ptrs.
	CMapStringToPtr		m_TargetMap;	// REVIEW this is nuts. 
	POSITION			m_posTarget;
	CString				m_strRelPath;	// name as we want to write it in the .dsw

public:
	static POSITION		m_posProjects;
	static CObList		m_lstProjects;
	int m_nProjType;
};	  


class  CProjDeferDirty 
{
public:
	CProjDeferDirty(CProject * pProject)
		{
			m_pProject = pProject;
			if (m_pProject!=NULL)
			{
				
				m_pProject->m_nDeferred++;
				m_bWasOk = m_pProject->IsOkToDirty();
				m_pProject->SetOkToDirtyProject(FALSE);
			}

		}
	~CProjDeferDirty()
		{
			if (m_pProject!=NULL)
			{
				m_pProject->SetOkToDirtyProject(m_bWasOk);
				if ((--(m_pProject->m_nDeferred)==0) && (m_bWasOk) && (m_pProject->IsDirtyDeferred()))
					m_pProject->DirtyProject();
			}
		}
private:
	CProject * m_pProject;
	BOOL m_bWasOk;
};

// This object is to used whenever the project's configuration needs to be changed
// temporarily. Do not call SetActiveConfig directly, unless you want to permanently 
// change the active configuration. Declare a local instance of this object and call
// 'ChangeConfig' on it. The destructor of this object will restore the original config
// back. The primary purpose of this is to make the calls to SetActiveConfig thread safe.

class  CProjTempConfigChange 
{
public:
	CProjTempConfigChange(CProject *pProject);
	// Will Release critical section and reset to original config.
	~CProjTempConfigChange();

	VOID ChangeConfig(CConfigurationRecord *);
	VOID ChangeConfig(const CString& strName);

	// Resets config to the original one, still holds the crit section.
	VOID Reset();	

	// releases critical section, if bReset is TRUE also resets to original config.
	VOID Release(BOOL bReset = TRUE); 

	CProject * m_pProject;

private:
	CConfigurationRecord * m_pcrOriginal;
	BOOL m_bCritSection ; // Do we have the critical section currently.
};


// This object is used when the active project needs to be temporarly changed
// usually during the build of a sub project.

class  CProjTempProjectChange 
{
public:
	CProjTempProjectChange (CProject *pProject);
	~CProjTempProjectChange ();

	VOID Release (); 

	CProject *m_pPrevProject;
};

extern CProject *g_pActiveProject;
extern CProject *g_pConvertedProject;

#endif // __PROJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projitem.h ===
/////////////////////////////////////////////////////////////////////////////
	//
	// PROJITEM.H
	//                                                                             
///////////////////////////////////////////////////////////////////////////////
//
//	Rough hierarchy tree:
//
/*
	CProjItem	+
				|
				+-- CFileItem   +-- CTimeCustomBuildItem
				|               +-- CTargetReference
				|
				+--	CProjContainer	+
									|
									+-- CProject
									+--	CProjGroup

	CProjViewItem is the base class for all items displayed in the shell's
	project view.		


*/
#ifndef __PROJITEM__
#define __PROJITEM__

#include "engine.h"

class CTargetItem;

class COptionHandler;

class CProjItem;
class CFileItem;

class CProjContainer;
class CProject;
class CProjGroup;
class CTimeCustomBuildItem;

class CBuildTool;
class CSchmoozeTool;
class CToolDirectory;

class CProjectView;

// Makread.h:
class CMakComment;
class CMakMacro;
class CMakDescBlk;
class CMakDirective;
class CMakError;
class CMakEndOfFile;
class CMakFileReader;
class CNameMunger;

// Config stuff:
class CProjType;


typedef CTimeCustomBuildItem * LPCUSTOMBUILDEVENT;

///////////////////////////////////////////////////////////////////////////////    
// Property bag to extract from Configuration record?
#define BaseBag		0
#define CloneBag	1
#define CurrBag		2

class  CConfigurationRecord : public CObject
{
	DECLARE_DYNAMIC (CConfigurationRecord);

public:
	//
	// Construction and destruction
	//
	CConfigurationRecord(const CConfigurationRecord * pBaseRecord, CProjItem * pItemOwner);
	~CConfigurationRecord();

	//
	// Record linkage
	//
	const CConfigurationRecord * m_pBaseRecord;

	//
	// Configuration record information retrieval
	//
	CString &GetConfigurationName () const;
	void GetConfigurationDescription (CString &) const;
	void GetProjectName (CString &) const;
	CString &GetOriginalTypeName  () const;

	// Get the target attributes of an internal/external project target
	int GetTargetAttributes();

	//
	// Configuration record property management
	//

	// Return a pointer to a particular bag in the config. record
	// FUTURE: On demand creation of property bags?
	__inline CPropBag * GetPropBag(UINT idBag)
		{
			if( idBag == BaseBag )
				return &m_BasePropBag;
			else if( idBag == CloneBag )
				return m_pClonePropBag;
			else 
				return &m_CurrPropBag;
		}

	// Copy the properties from one bag to another.
	// By default it will do a full bag copy.
	//
	// If nPropMin is -1 the lowest prop. id in the source bag will be used.
	// If nPropMax is -1 the highest prop. id in the source bag will be used.
	// ie. if nPropMax is not supplied, and nPropMin is 50 then all props in source
	// with property id <= 50 will be copied to the destination.
	//
	// If nPropMin == nPropMax then a single prop. will be copied.
	//
	// NOT UNDOABLE
	// NOT UNDOABLE
	// NOT UNDOABLE
	void BagCopy(UINT idBagSrc, UINT idBagDest,
				 UINT nPropMin = -1, UINT nPropMax = -1,
				 BOOL fInform = FALSE);

	//
	// Access functions to determine if this config rec is valid for the
	// owning item/set the validity of this config rec for the owning item.
	//
	__inline void SetValid(BOOL fValid) { m_fValid = fValid; }
	__inline BOOL IsValid() { return m_fValid; }

	BOOL IsSupported();

	BOOL SetBuildToolsMap();
	CVCPtrList * GetBuildToolsMap() {return m_pToolsMap;}
	BOOL GetExtListFromToolName(CString strTool, CString *strExt);
	BOOL SetExtListFromToolName(CString strTool, CString strExt);
	//
	// Action CSlob management
	//
	CBuildActionList * GetActionList();

	CProjItem *	m_pOwner;	// Owner of this project item

	// list of tools associated with this project and user defined extentions
	// for those tools
	CVCPtrList *	m_pToolsMap;

protected:
friend class CProjItem;
friend class CProject;

private:
	// Is this config rec valid for the owning item?
	BOOL			m_fValid:1;
	CBuildActionList *m_pActions;	// Our CBuildActions that attach to this item

	// A form of attribute caching
	int				m_iAttrib;
	BOOL			m_fAttribDirty:1;

	// Our property bags for this configuration
	// for each type of property bag,
	// o base
	// o cloned
	// o current
	CPropBag		m_BasePropBag;
	CPropBag	*	m_pClonePropBag;	// this guy is only needed when settings dialog is up.
	CPropBag		m_CurrPropBag;
	
public:
#ifdef _DEBUG
	virtual void AssertValid () const;
	virtual void Dump (CDumpContext &DC) const;
#endif
};

///////////////////////////////////////////////////////////////////////////////   
 
// definition of option behaviour
typedef WORD OptBehaviour;
#define OBNone				0x0000	// none of below
#define OBSetDefault		0x0001	// set defaults in the property bag (PARSE ONLY, NOT ROOT CProjItems)
#define OBAnti				0x0002	// string represents the 'un-set' options
#define OBClear				0x0004	// clear out the property bag of options not set (PARSE ONLY, NOT with Anti)
#define OBShowDefault 		0x0008	// show option defaults (GENERATE ONLY)
#define OBShowFake			0x0010	// show option fakes (GENERATE ONLY)
#define OBInherit			0x0020	// generate a string for a CSlob using option inheritance (GENERATE ONLY)
#define OBNeedEmptyString	0x0040	// parse/generate a string with empty strings ""
#define OBNoDepCheck		0x0080	// are we performing a dep. check using CProjItem::CheckDepOK()?
#define OBBadContext		0x0100	// are we in a bad context, ie. don't use defs. etc.
#define OBBasePropBag		0x0200  // use the base property bag instead of the current  one for parse/generate
#define OBShowMacro			0x0400	// $(macro) instead of value (GENERATE ONLY)

class  CProjItem : public CProjSlob 
{
//
//	Notes on CProjItem as it relates to CSlob:
//
//		A ProjItems container is simply the item to the left in the 
//		the File pane of the explorer.  This is the only dependency of
//		the ProjItem (in the CSlob sense).  Thus, AddDependent and
//		RemoveDependent should never need to be called.  
//
//		Perhaps the CSlobView should be a dependent as well, so it can
//		selectuvely reapint.
//
//
//		Only CProjContainer and its derived classes have a content list.
//
//
//	Property bag and configuartion tracking:
//		Each project has a CVCMapPtrToPtr which maps configurations in the item's
//		project to configuration records.  (For the project themselves, the keys
//		are always 0)  
//	  
	DECLARE_SERIAL (CProjItem)

public:
	CProjItem ();
	virtual ~CProjItem ();

	// Derived classes chould call this when they delete.
	virtual void DeleteContents();		
	//
	//	Get item's moniker.  This must (along with the item's runtime class)
	//	be unique within its container.  Does not have to be user readable:
	//
	virtual void GetMoniker (CString&);
	//
	//	Compare two monikers to see if they're equal.  (Basically case 
	//	insensitive string compare):
	//
    static int CompareMonikers (CString&, CString&);

	//  Get filename associated with this item:
	virtual const CPath *GetFilePath () const; 
	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);

	//
	//	Override CSlob's method:
	virtual void InformDependants (UINT idChange, DWORD_PTR dwHint = 0);

	//
	// Containment
	//

	// Sets the owner project of this project item
	// and, returns the owner project of this project item
	__inline void SetProject(CProject * pProject) {m_pOwnerProject = pProject;}  
	__inline CProject * GetProject() {return m_pOwnerProject;}

	// Sets the owner target of this project item
	// and, returns the owner target of this project item
	__inline void SetTarget(CTargetItem * pTarget) {m_pOwnerTarget = pTarget;}  
	CTargetItem * GetTarget();
	const CString & GetTargetName();

	// Hook into the containment changes for this item
	// Note, derived classes should hook into the
	// PreMoveItem(), MoveItem() and PostMoveItem() methods
	BOOL SetSlobProp(UINT idProp, CSlob * val);	
	
	// Derived project items can call/override this behaviour
	//
	// 'pContainer' is the new container of the project item
	// 'fToPrj' is TRUE if the move is to a project
	// 'fFromPrj' is TRUE if the move is from a project

	// Removes project item from view
	// Note, can alter the destination 
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// Alters the containment and fixes configs. of item,
	// but not 'officially' in or out-of project
	virtual BOOL MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// Make item item 'officially' in or out-of project,    
	// adds project item to view
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	//	List the items child in order, followed by the item.
	enum FlattenOptions 
	{
		flt_Normal			   		= 0,
		flt_ExpandSubprojects  		= 1,
		flt_ExcludeProjects    		= 2,
		flt_OnlyProjects       		= 4,
		flt_RespectItemExclude 		= 8,
		flt_ExcludeDependencies		= 16,
		flt_RespectTargetExclude 	= 32,
		flt_ExcludeGroups			= 64,
		flt_ExcludeProjDeps 		= 128,
		flt_OnlyTargRefs			= 256,
		flt_TargetInclude			= 512,
		flt_OnlyCustomStep			= 1024
	};
	void FlattenSubtree ( CObList& rObList, int fo );
	virtual void FlattenQuery (int fo, BOOL& fAddContent, BOOL& fAddItem);

	static const CString EndOfBagsRecord;

	// Do we want to search our container's property pages/bags
	// if the prop. cannot be found in our own?
	// return the old inherit flag.
	__inline BOOL EnablePropInherit(BOOL fEnable = TRUE) 
	{
		BOOL fWasInherit = m_optbeh & OBInherit;
		if (fEnable)
			m_optbeh |= OBInherit;
		else	 
			m_optbeh &= ~OBInherit;
		return fWasInherit;
	}

	//	Do we want to use option defaults?
	__inline BOOL UseOptionDefaults(BOOL fEnable = TRUE)
	{
		BOOL fWasDefaults = m_optbeh & OBShowDefault;
		if (fEnable)
			m_optbeh |= OBShowDefault;
		else	 
			m_optbeh &= ~OBShowDefault;
		return fWasDefaults;
	}

	//	Do we want to provide an 'anti-' value for the property?
	__inline BOOL EnableAntiProps(BOOL fEnable = TRUE)
	{
		BOOL fWasAnti = m_optbeh & OBAnti;
		if (fEnable)
			m_optbeh |= OBAnti;
		else	 
			m_optbeh &= ~OBAnti;
		return fWasAnti;
	}

	// Set the option behaviour 'en masse'
	__inline OptBehaviour SetOptBehaviour(OptBehaviour optbeh)
	{
		OptBehaviour optbehOld = m_optbeh; m_optbeh = optbeh; return optbehOld;
	}

	__inline OptBehaviour GetOptBehaviour()
	{
		return m_optbeh;
	}

	// Getting container's to match our config.
	// Use if you are likely to be called when the configs.
	// across related CProjItems might not match
	virtual CSlob * GetContainerInSameConfig();

	// Must reset the container we got from GetContainer...() after using it
#define ResetContainerConfig ResetManualBagSearchConfig

	// Set manual bag config. to be used
	__inline void ResetManualBagSearchConfig()
	{
		VSASSERT(!m_stkOldConfigRec.IsEmpty(), "Reset called before set!");		
		m_pManualConfigRec = (CConfigurationRecord *)m_stkOldConfigRec.RemoveTail();
	}

	__inline void SetManualBagSearchConfig(CConfigurationRecord * pRec)
	{
		m_stkOldConfigRec.AddTail(m_pManualConfigRec);
		m_pManualConfigRec = pRec;
	}

	// Get a pointer to our configuration array, which is ordered
	// to minimize diffs.  Use for iterating through configs.
	__inline const CVCPtrArray *GetConfigArray() const
		{return  &m_ConfigArray;}

	// Get a pointer to our configuration map for quick lookup
	// N.B. Do not use for iteration (slow!).  Use GetConfigArray() instead.
	__inline const CVCMapPtrToPtr *GetConfigMap() const 
		{return &m_ConfigMap;}

	// Force a configuration to be the active one, irrespective of the owner
	// project's current configuration.
	__inline void ForceConfigActive(CConfigurationRecord * pConfig = (CConfigurationRecord *)NULL /* reset */)
	{
		m_pForcedConfig = pConfig;
	}

	// Force a configuration (based on the base config record in the top project)
	// to be the active one, irrespective of the owner project's current configuration.
	__inline void ForceBaseConfigActive(CConfigurationRecord * pConfig)
	{
		VSASSERT(pConfig != (CConfigurationRecord *)NULL, "Cannot force NULL config active!");
		m_ConfigMap.Lookup((void *)pConfig, (void *&)m_pForcedConfig);
	}

	// Get the active configiguration (create if necessary).
	CConfigurationRecord * GetActiveConfig(BOOL fCreate = FALSE);

	// Make sure we have all of our configs matching the project.
	void CProjItem::CreateAllConfigRecords();

	// Get a matching configuration for a name, or for a base config. record,
	// 'fCreate' if TRUE will create if does not already exist.
	CConfigurationRecord * ConfigRecordFromConfigName(const TCHAR * pszConfig, BOOL fCreate = FALSE, BOOL fMatchExact = TRUE);
	CConfigurationRecord * ConfigRecordFromBaseConfig(CConfigurationRecord * pcrBase, BOOL fCreate = FALSE);

	// Pointer to the active configuration (tracks owner project's config.)
	CConfigurationRecord * m_pActiveConfig;

	// Pointer to a forced configuration    
	CConfigurationRecord * m_pForcedConfig;

// FUTURE
//
// TO REMOVE AND REPLACE with GENERIC property bag handling

	// Reset the current default configuration or the current configuration 
	__inline void SetCurrentConfigAsBase()
		{
			VSASSERT(GetActiveConfig(), "No active config!  Something not initialized properly!");
			GetActiveConfig()->BagCopy(CurrBag, BaseBag);
		}

	// Copying the current config to the default for a particular tool only
	void SetCurrentConfigAsBase(COptionHandler * popthdlr);

// FUTURE


	__inline int UsePropertyBag(UINT idBag = (UINT)-1)
	{
		int idOldBag = m_idBagInUse;
		if (idBag != (UINT)-1)
			m_idBagInUse = idBag;
		return idOldBag;
	}

	virtual CProjType * GetProjType();

	//	Override of CSlob's get props.	Do this to allow imp. of CPropBag hierarchy
	//	N.B. The only prop types we require so far are integer, string.
	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString& val);
	virtual GPT GetConvertedStrProp(UINT idProp, CString& val);

	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetStrProp(UINT idProp, const CString& val);

	//	These are stubbed for now :-) [matthewt]
	virtual GPT GetDoubleProp(UINT idProp, double& val)	{VSASSERT(FALSE, "GetDoubleProp must be overridden"); return invalid;}
	virtual	GPT GetLongProp(UINT idProp, long& val)		{VSASSERT(FALSE, "GetLongProp must be overridden"); return invalid;}
	virtual GPT GetSlobProp(UINT idProp, CSlob*& val)	{VSASSERT(FALSE, "GetSlobProp must be overridden"); return invalid;}
	virtual GPT GetRectProp(UINT idProp, CRect& val)	{VSASSERT(FALSE, "GetRectProp must be overridden"); return invalid;}
	virtual GPT GetPointProp(UINT idProp, CPoint& val)	{VSASSERT(FALSE, "GetPointProp must be overridden"); return invalid;}

	// Property bag handling methods for base, clone and current.
	virtual int GetBagHashSize(){ return( 53 ); }

	//	Override the CPropBag query so that we can handle configuration props
	virtual int GetPropBagCount() const;

	//	FUTURE: implement these using a generic GetConfigRec()
	virtual CPropBag * GetPropBag(int nBag = -1);
	virtual CPropBag * GetPropBag(const CString & strBagName);

	//  Override CSlob's serialize filter fn to save only private props:
	virtual BOOL SerializePropMapFilter(int nProp);

	//	Our container's configuration has changed
	virtual BOOL ConfigurationChanged(const CConfigurationRecord *pBaseRecord);

	// .MAK reading and writing
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	// Helper functions to parse a string, replacing $(OUTDIR) with actual value
	BOOL SubstOutDirMacro(CString & str, const CConfigurationRecord * pcr);

	// Helper functions to generate appropriate $(OUTDIR) macro string
	virtual BOOL GetOutDirString(CString & str, CString * pstrValue = NULL, BOOL bMacro = FALSE, BOOL fRecurse = FALSE);
	BOOL GetOutDirString(CString & str, UINT PropId, CString * pstrValue = NULL, BOOL bMacro = TRUE, BOOL fRecurse = FALSE);

	// Write out the !ifdef / !elseif / !endif block for a configuration block:
	enum ConfigPosition { FirstConfig, MiddleConfig, EndOfConfigs };
	// Read in a configuration ifdef and force ourself into that configuration:
	void ReadConfigurationIfDef(CMakDirective *pmd, BOOL bCheckProj = FALSE);
							// (throw CFileException if unknown configuration)

	// See if this is a comment holding a prop value.  If so, digest it _and_
	// delete it and set pObject= NULL 
	BOOL IsPropComment (CObject *&pObject);
						// (throw CFileException)

	// See if this is a comment hodling an ADD/SUBTRACT line for some tool.
	// If it is, digest it _and_ delete it and set pObject= NULL

	static const TCHAR *pcADD;
	static const TCHAR *pcSUBTRACT;
	static const TCHAR *pcBASE;
	
	// Return the file name macro:
	static const TCHAR *GetFileNameMacro() {return pcFileMacroNameEx;}

	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();
	
	// called when removing an item from the project
	void IsolateFromProject();
	void SetOwnerProject(CProject * pProject, CTargetItem * pTarget);

    void CopyCommonProps(CProjItem * pItemSrc, const CString & strTarget);
	virtual int CompareSlob(CSlob *pCmpSlob);
	LPVOID m_pArchyHandle;

public:
	// Helpers for makefile reading writing.  These return the three letter item
	// type (e.g. "SRC" from a file item) or get the runtime class given
	// an item type:
	 
	static CRuntimeClass *GetRTCFromNamePrefix (const TCHAR *);
	static const TCHAR *EndToken;			// "END"
	static const TCHAR *pcFileMacroName;		// "SOURCE"
	static const TCHAR *pcFileMacroNameEx;		// " $(SOURCE) "

	// Is this the END mak token?  Retruns true if it is. Also NULL the
	// pointer and deletes the object. Throws a file exception if its a MakEndOfFile:
	static BOOL  IsEndToken (CObject *& pToken );
								 // (throw CFileException)

	// Read in anything we need from inference rules / build rules
	BOOL SuckDescBlk(CMakDescBlk *pDescBlk);

	// Dispatch a macro to the appropriate tool and set our options.  If its the
	// DEPS macro, then setup our depencies list:
	BOOL SuckMacro(CMakMacro *pMacro, const CDir &BaseDir, BOOL bCaseApproved = FALSE);

	BOOL IsAddSubtractComment (CObject *&pObject);
						// (throw CFileException)

	enum PropWritingOptions
	{
		PropRead = 0x01,
		PropWrite = 0x02,
		Project = 0x04,
		Group = 0x08,
		File = 0x10,
		Target = 0x20,
		TargetRef = 0x40,
		All = 0x7c,
		NotPerConfig = 0x80
	};
	struct PropWritingRecord
	{
		UINT idProp;
		const TCHAR *pPropName;
		PROP_TYPE type;
		int nRdWrt;
	};
	static const PropWritingRecord nMakeFileProps[];
	static const TCHAR *pcPropertyPrefix;
	
	virtual BOOL CanContain(CSlob* pSlob);

	void DeleteConfigFromRecord (CConfigurationRecord *prec, BOOL bChildren = TRUE);

	// Copy the configuration structure of another item:
	virtual void CloneConfigs (const CProjItem *pItem);

public:
	//	Used to keep track of config state for makefile reading/writing
	//  REVIEW(kperry): since we only ever deal with one projitem at a time, this could probably be made static.
	ConfigPosition m_cp;


protected:
	//	Configuration record map and array
	CVCMapPtrToPtr m_ConfigMap;
 	CVCPtrArray m_ConfigArray;

	BOOL m_fGettingListStr:1; // Hack to stop recursing for ::GetStrProp on a list string

	//	Property bag searching heuristics
	BOOL m_fPropsDepFigure:1;	//	Property search is figuring deps?
	OptBehaviour m_optbeh;	//	Property search behaviour
	// note OptBehaviour is a WORD ! put beside another word for packing.

	//	Pointer to config. we wish to match for manual bag search:
	CConfigurationRecord * m_pManualConfigRec;

	//	A stack of cached record ptrs. so that we
	//	can nest the calls to SetManualBagSearch...
	CObList m_stkOldConfigRec;
	
	// our current 'owner' project, maybe '(CProject *)NULL' if none
	CProject *	m_pOwnerProject;

	// our current 'owner' target, maybe '(CTargetItem *)NULL', if none
	CTargetItem * m_pOwnerTarget;

private:	
	UINT m_idBagInUse;	// property bag to use

	// Remove any unreferenced configuration records and impose the config
	// ordering of a supplied CProjItem on this item and all its children.
	// (Used only in CloneConfigs)
	void FixConfigs(const CProjItem * pOrderedItem);

	DECLARE_SLOBPROP_MAP()

#ifdef _DEBUG
	virtual void AssertValid () const;
	virtual void Dump (CDumpContext &DC) const;
#endif
};

///////////////////////////////////////////////////////////////////////////////

class  CFileItem : public CProjItem 
{
	DECLARE_SERIAL (CFileItem)

public:
	CFileItem();
	virtual ~CFileItem()
	{
		if (NULL != m_pFilePath)
			delete m_pFilePath;

		DeleteContents();
	}

	virtual void GetMoniker (CString&);
	const CPath* GetFilePath() const;

	// Property bag handling methods for base, clone and current.
	virtual int GetBagHashSize(){ return( 3 ); }

	// Property storage and retrieval
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetIntProp(UINT nIDProp, int val);
	virtual GPT GetStrProp(UINT nIDProp, CString & val);
	virtual	GPT GetIntProp(UINT idProp, int& val);

	// Sending out add/delete file notifications
	virtual BOOL MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	
	// Setting and retrieving the filename
	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);

	// .MAK reading
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	// Flattening of projitems in a tree.
	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);

	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

public:
	const CPath*   m_pFilePath;	// our filename path

private:
	BOOL m_fDisplayName_Dirty:1;		// when to cache?
	CString	m_strMoniker;			// cached relative path of fileitem
	CString m_strDisplayName;		// cache our display name
	CString m_strOrgPath;			// name as we want to write it in the .dsp

	DECLARE_SLOBPROP_MAP()
};

///////////////////////////////////////////////////////////////////////////////
class CProjContainer : public CProjItem 
{
//
//	Notes on CProjContainer as it relates to CSlob:
//
//		The add file/remove file functionality comes through the 
//		CSlob::Add and CSlob::Remove functions.
//
//		Only CProjContainer and its derived classes have a content list.
//
//
	DECLARE_SERIAL (CProjContainer)

public:
	CProjContainer ();
	virtual ~CProjContainer ();

private:	
	CObList		m_objects;	// Actual list of contained ProjItems.

public:
	// Create a new group with the standard name and add it.
	CProjGroup *AddNewGroup (const TCHAR * pszName = NULL, const TCHAR * pszFilter = NULL);

	//	CSlob content access method:
	virtual CObList *GetContentList() { return &m_objects; };
	void SortContentList();

public:
	virtual BOOL ReadInChildren(CMakFileReader& mr, const CDir &BaseDir);
private:
	DECLARE_SLOBPROP_MAP()
};
///////////////////////////////////////////////////////////////////////////////
class CProjGroup : public CProjContainer 
{
//
//	Represents one those group items.  Never contains a resource conatiner or
//	group, but can contain CProject's and other groups:
//
//	Basically, the same thing as a CProjContainer.
//
	DECLARE_SERIAL (CProjGroup)

	virtual void GetMoniker (CString&);

public:
	// Special Reading code for groups, as we should only see groups in old v2
	// makefiles and so this code is part of the v2 to v3 conversion code
	virtual BOOL ReadInChildren(CMakFileReader& mr, const CDir &BaseDir);

	CProjGroup ();
	CProjGroup (const TCHAR * pszName);
	virtual ~CProjGroup () { DeleteContents ();};

	virtual GPT GetStrProp ( UINT idProp, CString &str );
	virtual BOOL SetStrProp ( UINT idProp,  const CString &str );

	// .MAK reading and writing
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	virtual BOOL CanContain(CSlob* pSlob);

	virtual void	FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
		{ fAddContent = TRUE; fAddItem = ((fo & flt_ExcludeGroups)==0); }

public:
	CString	m_strGroupName;
	CVCPtrList m_DeathRow;	// list of Slobs to be delete during a Drop
	CString m_strDefaultExtensions;  // P_GroupDefaultFilter

	DECLARE_SLOBPROP_MAP()
};


///////////////////////////////////////////////////////////////////////////////

class CTimeCustomBuildItem : public CFileItem
{
//
//	Represents one those custom build step items. 
//
//
	DECLARE_SERIAL(CTimeCustomBuildItem)

protected:
	// Groups must have unique names within a project.  Functions will munge
	// this items name to make it unique if needed:
	BOOL MakeNameUnique(CString & strName);

	void Init(const TCHAR* pszName);	// c'tor helper

public:
	CTimeCustomBuildItem();
	CTimeCustomBuildItem(const TCHAR * pszName);

	virtual GPT GetStrProp(UINT idProp, CString &str);
	virtual BOOL SetStrProp(UINT idProp,  const CString &str);
	virtual BOOL CanContain(CSlob* pSlob) { return FALSE; }

	virtual void FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem);

private:
	CString	m_strName;
	CString m_strCustomBuildTime;

	DECLARE_SLOBPROP_MAP()
};
 
#endif  // __PROJITEM__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projtool.cpp ===
//
//	PROJTOOL.CPP
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop

#include "targitem.h"
#include "bldrfile.h"
#include "projtool.h"
#include "schmztl.h"
#include "project.h"

IMPLEMENT_DYNCREATE(CBuildTool, CBldSysCmp)
IMPLEMENT_DYNAMIC(CCustomBuildTool, CBuildTool)
IMPLEMENT_DYNAMIC(CUnknownTool, CBuildTool)
IMPLEMENT_DYNAMIC(CSpecialBuildTool, CBuildTool)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL ReplaceMsDevMacros( CString &str );
extern CProjComponentMgr *g_pPrjcompmgr;
extern BOOL ConvertMacros(CString& rstrVal);

///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////
BOOL FileNameMatchesExtension(const CPath * pPath, const  TCHAR * pExtensions)
{
	if (pPath == (const CPath *)NULL)	return FALSE;

	const TCHAR * pExtNext = pExtensions;
	const TCHAR * pFileExt = pPath->GetExtension();
	if (*pFileExt) pFileExt++;
		// GetExtension() returns pointer to '.'

	INT_PTR n = _tcslen (pFileExt);

	if (n)
	{
		while (*pExtNext != _T('\0'))

		{
			pExtNext = pExtensions;
			while (*pExtNext != _T(';') && *pExtNext != _T(',') && *pExtNext != _T('\0'))
				pExtNext = _tcsinc ((TCHAR *) pExtNext );

			// skip over the optional '*.'
			if (pExtensions[0] == _T('*') && pExtensions[1] == _T('.'))
				pExtensions += 2;
			else if (pExtensions[0] == _T('.'))
				pExtensions += 1;

			// compare extensions in case-insensitive fashion
			if ((n == (pExtNext - pExtensions)) &&			// check for ext. length equivalence
				_tcsnicmp (pFileExt, pExtensions, n) == 0)	// check for ext. string equivalence
				return TRUE;

			pExtensions = pExtNext + 1;	// skip over the sep.
		}
	}

	return FALSE;
}

enum SpecialBuildToolType
{
	InvalidSpecialBuildTool = -1,
	PreLinkDescId = 0,
	PreLinkCmdsId,
	PostBuildDescId,
	PostBuildCmdsId,
	MaxSpecialBuildToolId
};

const TCHAR* s_ppszSpecialBuildToolMacroName[] = 
{	_T("PreLink_Desc"),
	_T("PreLink_Cmds"),
	_T("PostBuild_Desc"),
	_T("PostBuild_Cmds"),
};

const int s_pSpecialBuildToolProp[] =
{
	P_PreLink_Description,
	P_PreLink_Command,
	P_PostBuild_Description,
	P_PostBuild_Command,
};

static BOOL IsSpecialBuildTool( const CString& strName, int& idtype )
{
	idtype = 0;

	while (idtype < MaxSpecialBuildToolId)
	{
		if ( 0 == strName.CompareNoCase(s_ppszSpecialBuildToolMacroName[idtype]) )
		{
			return TRUE;
		}

		idtype++;
	}
	idtype = InvalidSpecialBuildTool;
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CBuildTool --------------------------------
//
///////////////////////////////////////////////////////////////////////////////

#define theClass CBuildTool
BEGIN_SLOBPROP_MAP(CBuildTool, CBldSysCmp)
	STR_PROP(ToolPrefix)
	STR_PROP(ToolInput)
END_SLOBPROP_MAP()
#undef theClass

#define theClass CBuildTool
BEGIN_REGISTRY_MAP(CBuildTool, CBldSysCmp)	
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLPREFIX, NO_SUB_KEY, "Macro_Prefix", NO_SUB_KEY, REG_STRING, m_strToolPrefix)
	REGISTRY_DATA_ENTRY(IDS_REG_TOOLINPUT, NO_SUB_KEY, "Input_Spec", NO_SUB_KEY, REG_STRING, m_strToolInput)
END_REGISTRY_MAP()
#undef theClass

CBuildTool::CBuildTool()
{
	m_strName = _TEXT("");
	m_strToolInput = _TEXT("");
	m_strToolPrefix = _TEXT("");
	m_popthdlr = (COptionHandler *)NULL;
	m_fTargetTool = FALSE;
}

CBuildTool::~CBuildTool()
{
}

void CBuildTool::FInit()
{
	// FUTURE: figure this out properly based on input and
	// output file sets, for now use CSchmoozeTool until
	// we delete this class
	m_fTargetTool = IsKindOf(RUNTIME_CLASS(CSchmoozeTool));
}

void CBuildTool::AddAction(CBuildAction* pAction)
{
	// don't care if I set this more than once
	m_BuildActions.SetAt(static_cast<void*>(pAction), static_cast<void*>(NULL));
}

void CBuildTool::RemoveAction(CBuildAction* pAction)
{
	// don't care if I actually removed this or not
	m_BuildActions.RemoveKey(static_cast<void*>(pAction));
}

#if 0
BOOL ReplaceEnvVars(CString &string)
{
	// replace $(ENV_VARIABLES)
	int i,j;
	char value[256];
	CString newString;

	i = string.Find( "$(" );
	while( i != -1 ){
		// copy the characters up to the $( into the new string.
		newString += string.Left( i );

		// skip the $( 
		CString temp;
		temp = string.Right( string.GetLength() - (i + 2) );

		// find the variable for lookup
		j = temp.Find( ")" );
		if( j != -1 ) {
			CString token;
			token = temp.Left( j );
			if( GetEnvironmentVariable( token, value, 255 ) ){
				newString += value;
			}
			// skip past the env variable and search for the next.
			string = string.Right( string.GetLength() - (i+j+3) );
			i = string.Find( "$(" );
		} else {
			// open without close !!! kill the end of the command line
			// this will likely cause a build failure
			string = "";
			return FALSE;
		}
	}
	newString += string;
	string = newString;
	return TRUE;
}
#endif

// default tool options for the tool for the target type component, 'bsc_id', or
// for any target type with attributes
BOOL CBuildTool::GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption)
{
	return FALSE;	// didn't retrieve default options
}

// Does this tool operate on this file?
BOOL CBuildTool::AttachToFile(const CPath* pPath, CProjItem * pItem)
{
	// is this a target oriented tool? if so then only attach to a target ...
	if (m_fTargetTool)
		return pItem && (pItem->GetTarget() == pItem);

	VSASSERT(pItem, "No item to attach to!");
	if (pItem)
	{
		CProject *pProject = pItem->GetProject();
		CConfigurationRecord *pCurrentConfig = (CConfigurationRecord*)pProject->GetActiveConfig()->m_pBaseRecord;
		CString strAdditionalExt;
		CString strExtensionList = m_strToolInput;

		if(pCurrentConfig->GetExtListFromToolName(GetToolName(), &strAdditionalExt))
			strExtensionList = strAdditionalExt;
		
		// this is a source oriented tool, so only attach to a file if it's in our input set
		return pPath && FileNameMatchesExtension(pPath, strExtensionList /*m_strToolInput*/); 
	}
	return(FALSE);
}

BOOL CBuildTool::ProcessAddSubtractString
(
	CProjItem * pItem,
	const TCHAR * pstr,
	BOOL fSubtract,
	BOOL fBaseBag /* = FALSE */
)
{
	g_pPrjoptengine->SetOptionHandler(GetOptionHandler());
	g_pPrjoptengine->SetPropertyBag ( pItem );

	OptBehaviour optbeh = OBSetDefault | OBNeedEmptyString;
	if (fSubtract)	
		optbeh |= OBAnti;
	if (fBaseBag) 
		optbeh |= OBBasePropBag;

	CString str = pstr;

	return g_pPrjoptengine->ParseString ( str, optbeh );
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CCustomBuildTool ----------------------------
//
///////////////////////////////////////////////////////////////////////////////

const TCHAR g_pcBeginCustomBuild[] = _TEXT("Begin Custom Build");
const TCHAR g_pcEndCustomBuild[] = _TEXT("End Custom Build");
const TCHAR g_pcCustomDescSep[] = _TEXT(" - ");

CCustomBuildTool::CCustomBuildTool()
{
	m_fTargetTool = FALSE;
	m_strName = _TEXT("cmd.exe");

	// create ourselves a simple option handler
	SetOptionHandler(new COptHdlrUnknown(this));
}

CCustomBuildTool::~CCustomBuildTool()
{
	delete GetOptionHandler();
}

CCustomBuildTool::eStrPropTypes CCustomBuildTool::HasCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString * pstrProp /* = NULL */, BOOL fDefault /* = TRUE */)
{
	// get the tool string prop, don't use inheritance!
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	OptBehaviour optbeh;
	if (pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		optbeh = (OptBehaviour) (optbehOld | OBInherit);
	else
		optbeh = (OptBehaviour) (optbehOld & ~OBInherit);

	// use defaults?
	if (!fDefault) optbeh &= ~OBShowDefault;

	(void)pItem->SetOptBehaviour(optbeh);

	CString strNewLine;
	BOOL fRet = pItem->GetStrProp(idProp, strNewLine);

	(void)pItem->SetOptBehaviour(optbehOld);

	if (pstrProp)
		*pstrProp = _T("");
	if (!fRet)
		return eStrPropNone;
	else if (strNewLine.IsEmpty())
		return eStrPropEmpty;
	else
	{
		if (pstrProp)
			*pstrProp = strNewLine;
		return eStrPropHasValue;
	}
}

BOOL CCustomBuildTool::GetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & strTab, BOOL fDefault /* = TRUE */)
{
	// get the prop.
	strTab.Empty();  // make sure this starts off empty

	CString strNewLine;
	eStrPropTypes propType = HasCustomBuildStrProp(pItem, idProp, &strNewLine, fDefault);
	if (propType == eStrPropNone)
		return FALSE;

	int i=0;
	int last = strNewLine.GetLength();
	while( i < last ){
		if( strNewLine[i] == _T('\r') ) {
			if( (i+1)<last && strNewLine[i+1] == _T('\n') ){
				strTab += _T('\t');
				i++;
			}
			else {
				strTab += strNewLine[i];
			}
		} else {
			strTab += strNewLine[i];
		}
		i++;
	}

	return TRUE;
}

BOOL CCustomBuildTool::ConvertCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & strTab, BOOL fDefault /* = TRUE */)
{
	// get the prop.
	strTab.Empty();  // make sure this starts off empty

	CString strNewLine;
	eStrPropTypes propType = HasCustomBuildStrProp(pItem, idProp, &strNewLine, fDefault);
	if (propType == eStrPropNone)
		return FALSE;

	int i=0;
	int last = strNewLine.GetLength();
	while( i < last ){
		if( strNewLine[i] == _T('\r') ) {
			if( (i+1)<last && strNewLine[i+1] == _T('\n') ){
				strTab += _T(';');
				i++;
			}
			else {
				strTab += strNewLine[i];
			}
		} else {
			strTab += strNewLine[i];
		}
		i++;
	}
	::ConvertMacros(strTab);

	return TRUE;
}

BOOL CCustomBuildTool::SetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str)
{
	int i=0;
	CString strNew;
	while( i < str.GetLength() ){
		if( str[i] == _T('\t') ){
			strNew += _T("\r\n");
		}
		else {
			strNew += str[i];
		}
		i++;
	}
	return pItem->SetStrProp(idProp, strNew);
}

BOOL CCustomBuildTool::AttachToFile(const CPath* pPath, CProjItem * pItem)
{
	// attach only if the command and output file string props. are non-empty
	CString str;
	CProject *pProject = pItem->GetProject();
	CConfigurationRecord *pCurrentConfig = (CConfigurationRecord*)pProject->GetActiveConfig()->m_pBaseRecord;
	CString strExtensionList = m_strToolInput;

	if(pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)))
	{
		CString strCustTool = _TEXT("cmd.exe");
		pItem->SetStrProp(P_ItemBuildTool, strCustTool);
	}

	// non-empty command prop?
	if (HasCustomBuildStrProp(pItem, P_CustomCommand) != eStrPropHasValue ||

		// non-empty output prop?
		HasCustomBuildStrProp(pItem, P_CustomOutputSpec) != eStrPropHasValue)

		return FALSE;	// no

	return TRUE;	// yes
}

BOOL CCustomBuildTool::DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude)
{
	CObject * pObject = NULL;	// builder file element

	BOOL fRet = FALSE;	// only success if we find custom build end

    // Are we reading for an unknown platform
    BOOL fUnknown = !pItem->GetProject()->GetProjType()->IsSupported();

	// is this a build event
	BOOL fBuildEvent = pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem));

	// get our custom description from the prelude text
	// skip text
	pchCustomPrelude += (_tcslen(g_pcBeginCustomBuild) * sizeof(TCHAR));

	// do we have a description?
	if (*pchCustomPrelude != _T('\0'))
	{
		// skip over " - "
		int cSep = lstrlen(g_pcCustomDescSep);
		if (_tcsnicmp(pchCustomPrelude, g_pcCustomDescSep, cSep) == 0)
		{
			CString strPrelude(pchCustomPrelude + cSep * sizeof(TCHAR));
			SetCustomBuildStrProp(pItem, P_CustomDescription, strPrelude);
		}
	}

    CString strUnknownMacros;   // Raw macro strings for unknown platform

	TRY
	{
	   	for(pObject = g_buildfile.m_pmr->GetNextElement(!fBuildEvent);pObject;
			pObject = g_buildfile.m_pmr->GetNextElement(!fBuildEvent))
 	   	{
			// process this builder file element

			// premature EOF?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
				break;

			// look for the custom build end
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
			{
				CMakComment * pMakComment = (CMakComment *)pObject;

				// get the comment and skip leading whitespace
				TCHAR * pch = pMakComment->m_strText.GetBuffer(1);
				SkipWhite(pch);

				if (_tcsnicmp(g_pcEndCustomBuild, pch, _tcslen(g_pcEndCustomBuild)) == 0)
				{
					fRet = TRUE;
					break;
				}
			}
			// is this the description block?
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				CMakDescBlk * pMakDescBlk = (CMakDescBlk *)pObject;
				
				// read in the output
				CString str;

				GetCustomBuildStrProp(pItem, P_CustomOutputSpec, str);

				// strip quotes?
				if( str.GetLength() > 0 )
					str += _T('\t');

				if (pMakDescBlk->m_strTargets.IsEmpty())
					str.Empty();
				else if (pMakDescBlk->m_strTargets[0] == _T('"'))
			    	str += pMakDescBlk->m_strTargets.Mid(1, pMakDescBlk->m_strTargets.GetLength() - 2);
				else
					str += pMakDescBlk->m_strTargets;
				
				if (!str.IsEmpty())
				{
					// replace bad macros here
					if( ReplaceMsDevMacros( str ) ){
						// Dirty the project object
						pItem->GetProject()->DirtyProject();
					}
				}

				SetCustomBuildStrProp(pItem, P_CustomOutputSpec, str);

				// convert the string list into a '\t' sep'd one
				COptionList optlst(_T('\t'), FALSE,TRUE);
				POSITION pos = pMakDescBlk->m_listCommands.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CString str = pMakDescBlk->m_listCommands.GetNext(pos);

					// replace bad macros here
					if( ReplaceMsDevMacros( str ) ){
						// Dirty the project object
						pItem->GetProject()->DirtyProject();
					}

					TCHAR * pch = (TCHAR *)(const TCHAR *)str;
					TCHAR * pchStart = pch;
					int cch = str.GetLength();

					// skip leading whitespace
					SkipWhite(pch);
					cch -= (int)(pch - pchStart);

					if (_tcsnicmp(pch, _TEXT("$(BuildCmds)"), cch) == 0)
						break;

					// skip leading '@'?
					if (*pch == _T('@'))
					{
						pch++;
						cch -= sizeof(TCHAR);
					}

					optlst.Append(pch, (int)cch);
				}

				// set this property
				optlst.GetString(str);

				// anything?
				if (!str.IsEmpty())
					SetCustomBuildStrProp(pItem, P_CustomCommand, str);
			}
			// is this the macros ... we're going to read in 'BuildCmds=' if there is one
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				CMakMacro * pMacro = (CMakMacro *)pObject;

				if (_tcsicmp(pMacro->m_strName, _TEXT("BuildCmds")) == 0)
				{
					// read in the output
					CString str;

					// convert the string list into a '\t' sep'd one
					COptionList optlst(_T('\t'), FALSE,TRUE);

					// possible token start and end
					TCHAR * pBase = pMacro->m_strValue.GetBuffer(1);
					TCHAR * pMakEnd = pBase + pMacro->m_strValue.GetLength();	
					TCHAR * pTokenEnd = max(pBase, (TCHAR *)pMakEnd - 1);
					
					while (pTokenEnd < pMakEnd)
					{
						// skip whitespace
		  				SkipWhite(pBase);

						TCHAR * pTokenStart = pBase;

						// olympus 2020 (briancr)
						// Instead of calling GetMakToken, which will delimit
						// each token at any white space and cause the build
						// commands to be broken at each space, we'll find the
						// end of the token right here. The end of the token
						// is a tab or end of string.
						BOOL bInQuotes = FALSE;
						pTokenEnd = pTokenStart;

						while (*pTokenEnd) {
							// toggle quote flag
							if (*pTokenEnd ==  _T('"')) {
								bInQuotes = ~bInQuotes;
							}
							else if (*pTokenEnd == _T('\t')) {
								if (!bInQuotes) {
									break;
								}
							}
							pTokenEnd = _tcsinc ((char *) pTokenEnd);
						}  
						#ifdef _DEBUG
						if (bInQuotes && !*pTokenEnd) TRACE ("Unmatched quotes while getting token in DoReadBuildRule\n");
						#endif 

						// end olympus 2020 fix

						// skip leading '@'?
						if (*pTokenStart == _T('@'))
						{
							pTokenStart++;
						}

						optlst.Append(pTokenStart, (UINT)(pTokenEnd - pTokenStart));

						// next token
						pBase = _tcsinc(pTokenEnd);
					}

					// set this property
					optlst.GetString(str);

					// anything?
					if (!str.IsEmpty())
						SetCustomBuildStrProp(pItem, P_CustomCommand, str);
				}
				
				if (fUnknown)
				{
                    CString strMacro = pMacro->m_strName + _TEXT("=") + pMacro->m_strValue + _T("\r\n");

                    if (strUnknownMacros.IsEmpty())
                        strUnknownMacros = strMacro;
                    else
                        strUnknownMacros += strMacro;
				}
			}	

	   		delete pObject; pObject = (CObject *)NULL;
		}

        if (fUnknown)
            SetCustomBuildStrProp(pItem, P_CustomMacros, strUnknownMacros);
						 
		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	CATCH (CException, e)
	{
		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	END_CATCH

	return fRet;	// ok
}

// fix for speed bugs #4039 and 4307
// MsDevDir is an environment variable.
// environment variables are case insensitive.
// nmake is case sensitive. therefore our makefiles
// did not work from nmake in 4.0
// This routine touppers the bogus macro
BOOL ReplaceMsDevMacros( CString &str ){
	int nBegin = 0;
	int nEnd;
	int rValue = FALSE;
	CString strMsdev("MSDevDir");
	CString strRemoteTarget("RemoteTargetPath");
	int nLength = str.GetLength();

	// loop until end of string
	for(;;){
		CString strMacro;

		// find the beging of a macro
		while ( nBegin < (nLength-1) ) {
		    if( str[nBegin] == _T('$') && str[nBegin+1] == _T('(') ){
				nBegin+=2;
				break;
			}
			nBegin++;
		}
	
		if( nBegin >= nLength-1 ) return rValue;
	
   		nEnd = nBegin;
		// find the end of a macro
		while ( str[nEnd] != _T(')')  ) {
			strMacro += str[nEnd];
			nEnd++;
			if( nEnd>= nLength )
				return rValue;
		}

		// compare and replace if equal
		if( strMacro == strMsdev ){
			CString strUpper("MSDEVDIR");
			rValue = TRUE;
			int i;
			for( i=0; nBegin < nEnd; i++ ){
				str.SetAt(nBegin,strUpper[i]);
				nBegin++;
			}
		}
		if( strMacro == strRemoteTarget ) {
			CString strUpper("REMOTETARGETPATH");
			rValue = TRUE;
			int i;
			for( i=0; nBegin < nEnd; i++ ){
				str.SetAt(nBegin,strUpper[i]);
				nBegin++;
			}
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CUnknownTool ------------------------------
//
///////////////////////////////////////////////////////////////////////////////

UINT g_nIDToolUnknown = PROJ_PER_CONFIG_UNKNOWN;

CUnknownTool::CUnknownTool
(
	const TCHAR * lpszPlatform,
	const TCHAR * lpszPrefix,
	const TCHAR * lpszExeName /* = NULL */
)
{
	m_nIDUnkStr = g_nIDToolUnknown++;
	VSASSERT(g_nIDToolUnknown <= (PROJ_PER_CONFIG_LAST), "g_nIDToolUnknown out of range; reset PROJ_PER_CONFIG_LAST if new value is valid");

	m_strName = _TEXT("unknown.exe");
	m_strToolPrefix = lpszPrefix;

	SetOptionHandler(new COptHdlrUnknown(this));
}

CUnknownTool::~CUnknownTool()
{
	delete GetOptionHandler();
}

///////////////////////////////////////////////////////////////////////////////
BOOL CUnknownTool::AttachToFile(const CPath* pPath, CProjItem * pItem)
{
	// attach done in CProjItem::SuckMacro
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// function called to read a tool builder macro line
// ie. one of the form '<tool prefix>_FOOBAR = '
// for the unknown tool we'll preserve these...
BOOL CUnknownTool::ReadToolMacro(CMakMacro * pMacro, CProjItem * pItem)
{
	// don't inherit while getting prop.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	(void)pItem->SetOptBehaviour((OptBehaviour)(optbehOld & ~OBInherit));

	// collect all of our macro's raw-data
	if (pItem->GetStrProp(GetUnknownPropId(), m_strBuffer) != valid)
		m_strBuffer = _TEXT("");

	// append raw-data
	m_strBuffer += pMacro->m_strRawData;

	// set
	pItem->SetStrProp(GetUnknownPropId(), m_strBuffer);
	
	(void)pItem->SetOptBehaviour(optbehOld);

	return TRUE;	// ok
}

///////////////////////////////////////////////////////////////////////////
// Makefile reading and writing for a generic tool
///////////////////////////////////////////////////////////////////////////

const TCHAR g_pcBeginSpecialBuildTool[] = _TEXT("Begin Special Build Tool");
const TCHAR g_pcEndSpecialBuildTool[] = _TEXT("End Special Build Tool");

class COptHdlrSpecialTool : public COptionHandler
{
	DECLARE_DYNAMIC(COptHdlrSpecialTool);

public:
	COptHdlrSpecialTool(CBuildTool * pBuildTool);

	// create our default option map
	void CreateOptDefMap() {/* do nothing*/}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs
	void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh = OBNone)
	{
		nIDUnkOpt = (UINT) -1;
		nIDUnkStr = (UINT)0;
	}

	// retrieive our min. and max. option prop IDs
	void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp)
	{
		nIDMinProp = P_PreLink_Description;
		nIDMaxProp = P_PostBuild_Command;
	}

	// case sensitive (though this is ignored as we have ignored options'n' strings)
	__inline const BOOL IsCaseSensitive() {return TRUE;}

	// retrieve our option string table
	// (just has two entries, unknown option and unknown string)
	COptStr * GetOptionStringTable(){ return poptstrOptHdlrUknown; }

	// we don't have an option lookup
	__inline COptionLookup * GetOptionLookup()	{return (COptionLookup *)NULL;}

private:
	static COptStr poptstrOptHdlrUknown[];
};

COptStr COptHdlrSpecialTool::poptstrOptHdlrUknown[] = {
	IDOPT_UNKNOWN_STRING,	"",		NO_OPTARGS, single,
	(UINT)-1,				NULL,	NO_OPTARGS, single
};

IMPLEMENT_DYNAMIC(COptHdlrSpecialTool, COptionHandler);

COptHdlrSpecialTool::COptHdlrSpecialTool(CBuildTool * pBuildTool) : COptionHandler(pBuildTool)
{
	// our base
	SetOptPropBase(P_PreLink_Description);

	Initialise();
}	

CSpecialBuildTool::CSpecialBuildTool()
{
	m_fTargetTool = FALSE;
	m_strName = _TEXT("special.exe");

	// create ourselves a simple option handler
	SetOptionHandler(new COptHdlrSpecialTool(this));
}

CSpecialBuildTool::~CSpecialBuildTool()
{
	delete GetOptionHandler();
}

BOOL CSpecialBuildTool::AttachToFile(const CPath* pPath, CProjItem * pItem)
{
	// attach only if the command string props. are non-empty and pItem is a project or target.
	if ( !(pItem->IsKindOf(RUNTIME_CLASS(CProject)) || pItem->IsKindOf(RUNTIME_CLASS(CTargetItem))))
		return FALSE;

	// Allow inheritance.
	OptBehaviour optbehOld = pItem->GetOptBehaviour();
	pItem->SetOptBehaviour((OptBehaviour)(optbehOld | OBInherit));

	CString strPreCmds;
	CString strPostCmds;

	BOOL bAttached = ( pItem->GetStrProp(s_pSpecialBuildToolProp[PreLinkCmdsId], strPreCmds) && !strPreCmds.IsEmpty() )
		|| ( pItem->GetStrProp(s_pSpecialBuildToolProp[PostBuildCmdsId], strPostCmds) && !strPostCmds.IsEmpty() );

	// Restore original behavior.
	pItem->SetOptBehaviour(optbehOld);

	return bAttached;
}

BOOL CSpecialBuildTool::DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude, BOOL bAllConfigs)
{
	CObject * pObject = NULL;	// builder file element

	BOOL fRet = FALSE;	// only success if we find custom build end

    // Are we reading for an unknown platform
    BOOL fUnknown = !pItem->GetProject()->GetProjType()->IsSupported();

	// is this a build event?
	BOOL fBuildEvent = pItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem));

    CString strUnknownMacros;   // Raw macro strings for unknown platform

	TRY
	{
	   	for(pObject = g_buildfile.m_pmr->GetNextElement(!fBuildEvent);pObject;
			pObject = g_buildfile.m_pmr->GetNextElement(!fBuildEvent))
 	   	{
			// process this builder file element

			// premature EOF?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
				break;

			// look for the custom build end
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
			{
				CMakComment * pMakComment = (CMakComment *)pObject;

				// get the comment and skip leading whitespace
				TCHAR * pch = pMakComment->m_strText.GetBuffer(1);
				SkipWhite(pch);

				if (_tcsnicmp(g_pcEndSpecialBuildTool, pch, _tcslen(g_pcEndSpecialBuildTool)) == 0)
				{
					fRet = TRUE;
					break;
				}
			}
			// is this the description block?
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				//
				// Not sure what to do.
				VSASSERT(0, "Dunno what to do with a CMakDescBlk here");
			}
			// is this the macros ... we're going to read in 'BuildCmds=' if there is one
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				CMakMacro * pMacro = (CMakMacro *)pObject;
				int idtype;

				if (IsSpecialBuildTool(pMacro->m_strName, idtype))
				{
					// Process special project build tool.
					CString str = pMacro->m_strValue;
					if (!pMacro->m_strValue.IsEmpty())
					{
						if ( bAllConfigs )
						{
							pItem->CreateAllConfigRecords();
							int	nConfigs = pItem->GetPropBagCount();
							int k;

							for (k=0; k < nConfigs; k++)
							{
								// global across *all configs* so
								// make sure we have all of our configs matching the project

								// Force config. active, set prop, and then restore.
								pItem->ForceConfigActive((CConfigurationRecord *)(*pItem->GetConfigArray())[k]);
								pItem->SetStrProp(s_pSpecialBuildToolProp[idtype], pMacro->m_strValue);
								pItem->ForceConfigActive();
							}
						}
						else
						{
							pItem->SetStrProp(s_pSpecialBuildToolProp[idtype], pMacro->m_strValue);
						}
					}
				}
				
				if (fUnknown)
				{
                    CString strMacro = pMacro->m_strName + _TEXT("=") + pMacro->m_strValue + _T("\r\n");

                    if (strUnknownMacros.IsEmpty())
                        strUnknownMacros = strMacro;
                    else
                        strUnknownMacros += strMacro;
				}
			}	

	   		delete pObject; pObject = (CObject *)NULL;
		}

		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	CATCH (CException, e)
	{
		if (pObject != (CObject *)NULL)
			delete pObject;
	}
	END_CATCH

	return fRet;	// ok
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\project.cpp ===
//
//	PROJECT.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop

#include "projdep.h"
#include "project.h"
#include "targitem.h"
#include "bldrfile.h"	// our CBuildFile
#include "optncplr.h"
#include "optnmtl.h"		// so we can automatically add /mktyplib203
#include "optnrc.h"
#include "optnlib.h"
#include "optnbsc.h"
#include "dirmgr.h"

IMPLEMENT_SERIAL (CProject, CProjContainer, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CProjComponentMgr *g_pPrjcompmgr;
UINT g_nNextIncompatibleVersion = 700;
extern CBuildPackage * g_pBuildPackage; // defined in prjconfig.cpp
extern CBuildTool *g_pLastTool;  // defined in projitem.cpp

// default extension for builder file
#define BUILDER_EXT	".dsp"

// REVIEW: find a better home for these

CProject * g_pConvertedProject = NULL;
BOOL g_bInProjClose=FALSE;

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CProject ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
//
//	Top level project class.  May be more than one if there are subprojects.
//

#define theClass CProject
BEGIN_SLOBPROP_MAP(CProject, CProjContainer)
	STR_PROP(ProjActiveConfiguration)
	STR_PROP (ProjItemName)
END_SLOBPROP_MAP()
#undef theClass

BOOL ConvertPropPaths(CProjItem * pItem, UINT idIncludes, BOOL bIsDir = TRUE, BOOL bSubstComma = TRUE)
{
	BOOL retval = FALSE;
	CPath path;
	CDir dir;
	path.SetAlwaysRelative();
	CString strIncludes;
	if ((pItem->GetStrProp(idIncludes, strIncludes) == valid) && (!strIncludes.IsEmpty()))
	{
		// convert include paths
		BOOL bChanged = FALSE;
		CString strNewIncludes;
		LPTSTR pOldInclude = strIncludes.GetBuffer(0);
		LPTSTR pszInclude = _tcstok(pOldInclude, _T(",;"));
		while (pszInclude != NULL && *pszInclude != _T('\0'))
		{
			CString strOldPath = pszInclude;
			CString strNewPath;
			BOOL bRelative = ((*pszInclude != _T('\\')) && (*pszInclude != _T('/'))	&& (pszInclude[1] != _T(':')));
			// try to re-relativize this path;
			if (bRelative && (!bIsDir) && (_tcspbrk(pszInclude, _T("\\/"))==NULL))
			{
				// REVIEW: don't treat simple filenames as relative
				bRelative = FALSE;
			}
			BOOL bUsesMacro = (_tcspbrk(pszInclude, _T("$")) != NULL);
			if (bRelative && (!bUsesMacro))
			{
				if (bIsDir)
				{
					LPCTSTR pchLast = _tcsdec(pszInclude, pszInclude + _tcslen(pszInclude));
					if (*pchLast != _T('\\') && *pchLast != _T('/'))
						strOldPath += _T('\\');
					strOldPath += _T('a'); // dummy file name
				}
				if ((path.CreateFromDirAndFilename(g_pConvertedProject->GetWorkspaceDir(), strOldPath)) && (path.GetRelativeName(pItem->GetProject()->GetWorkspaceDir(), strNewPath)) && (strNewPath != strOldPath))
				{
					bChanged = TRUE;
					if (bIsDir)
					{
						int newlen = strNewPath.GetLength() - 2; // remove '\\a" again
						VSASSERT(newlen > 0, "Dummy path went back to empty!");
						strNewIncludes += strNewPath.Left(newlen);
					}
					else
					{
						strNewIncludes += strNewPath;
					}
				}
				else
				{
					strNewIncludes += pszInclude;
				}
			}
			// validate full paths too to avoid disappointment
			else if (bIsDir && (!bUsesMacro) && (strOldPath.GetLength() > 2 /* avoid 'c:' and '\' cases */) && (dir.CreateFromString(strOldPath)))
			{
				// VC6 #26261: make sure we don't add gratuitous drive letter
				if (_tcsnicmp((LPCTSTR)dir, (LPCTSTR)g_pConvertedProject->GetWorkspaceDir(), 3)==0)
				{
					strNewPath = LPCTSTR(dir) + 2; // strip off drive letter
				}
				else
				{
					strNewPath = dir;
				}
				bChanged =  bChanged || (strOldPath.CompareNoCase(strNewPath) != 0);
				strNewIncludes += strNewPath;
			}
			else
			{
				strNewIncludes += pszInclude;
			}
			
			pszInclude = _tcstok(NULL, _T(",;"));
			if (pszInclude != NULL)
			{
				if (bSubstComma)
					strNewIncludes += _T(',');
				else
					strNewIncludes += _T(';');
			}
		}
		
		strIncludes.ReleaseBuffer(-1);
		if (bChanged)
		{
			retval = TRUE;
			pItem->SetStrProp(idIncludes, strNewIncludes);
		}
	}
	return retval;
}

BOOL CProject::ConvertDirs()
{
	BOOL retval = FALSE;
	VSASSERT(m_bConvertedVC20 || m_bConvertedDS4x, "Should only be here for 2.0 and 4.X conversions");
	if (m_bConvertedVC20 || m_bConvertedDS4x)
	{
		COptionHandler * popthdlr = NULL;
		g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler), (CBldSysCmp *&)popthdlr);
		if( popthdlr == NULL )
		    return retval;

		UINT idCplrIncludes = popthdlr->MapLogical(P_CplrIncludes);
		UINT idOutputCod = popthdlr->MapLogical(P_OutputDir_Cod);
		UINT idOutputSbr = popthdlr->MapLogical(P_OutputDir_Sbr);
		UINT idOutputPch = popthdlr->MapLogical(P_OutputDir_Pch);
		UINT idOutputObj = popthdlr->MapLogical(P_OutputDir_Obj);
		UINT idOutputPdb = popthdlr->MapLogical(P_OutputDir_Pdb);

		g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_MkTypLib), (CBldSysCmp *&)popthdlr);
		UINT idMTLIncludes = popthdlr->MapLogical(P_MTLIncludes);
		UINT idMTLOutputTlb = popthdlr->MapLogical(P_MTLOutputTlb);
		UINT idMTLOutputInc = popthdlr->MapLogical(P_MTLOutputInc);

		g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_RcCompiler), (CBldSysCmp *&)popthdlr);
		UINT idResIncludes = popthdlr->MapLogical(P_ResIncludes);
		UINT idOutNameRes = popthdlr->MapLogical(P_OutNameRes);

		CObList list;
		FlattenSubtree(list, flt_Normal | flt_ExcludeGroups | flt_ExcludeDependencies | flt_RespectTargetExclude);

		POSITION pos = list.GetHeadPosition();
		CProjItem* pItem;
		while (pos != NULL)
		{
			pItem = (CProjItem *)list.GetNext(pos);
			OptBehaviour optbehOld = pItem->GetOptBehaviour();
			pItem->SetOptBehaviour((OptBehaviour)(optbehOld & ~(OBInherit|OBShowDefault|OBShowFake) | OBShowMacro));

			// call helper function to do the actual work
			// compiler props
			retval = ConvertPropPaths(pItem, idCplrIncludes) || retval;
			retval = ConvertPropPaths(pItem, idOutputCod) || retval;
			retval = ConvertPropPaths(pItem, idOutputSbr) || retval;
			retval = ConvertPropPaths(pItem, idOutputPch) || retval;
			retval = ConvertPropPaths(pItem, idOutputObj) || retval;
			retval = ConvertPropPaths(pItem, idOutputPdb) || retval;

			// mtl props
			retval = ConvertPropPaths(pItem, idMTLIncludes) || retval;
			retval = ConvertPropPaths(pItem, idMTLOutputTlb, FALSE) || retval;
			retval = ConvertPropPaths(pItem, idMTLOutputInc, FALSE) || retval;

			// res props
			retval = ConvertPropPaths(pItem, idResIncludes) || retval;
			retval = ConvertPropPaths(pItem, idOutNameRes, FALSE) || retval;

			// REVIEW: other props to convert?

			if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
			{
				// project-level only properties

				// linker props
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker), (CBldSysCmp *&)popthdlr);
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_OutName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_LibPath), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_UsePDBName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_DefName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_ImpLibName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_MapName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_LinkDelayNoBind), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_LinkDelayUnLoad), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_LinkDelayLoadDLL), FALSE) || retval;

				// lib props
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Lib), (CBldSysCmp *&)popthdlr);
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_DefNameLib), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_OutNameLib), FALSE) || retval;

				// bscmake props
				g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_BscMake), (CBldSysCmp *&)popthdlr);
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_BscMakeOutputFilename), FALSE) || retval;

				// REVIEW: other props to convert?
			}
			pItem->SetOptBehaviour(optbehOld);
		}
	}
	return retval;  // TRUE iff anything changed
}

CProject::CProject()
{
	// our current project is us!
	m_pOwnerProject = this;

	m_pFilePath = NULL;
 	m_bPrivateDataInitialized = FALSE;
	m_bProjectComplete = FALSE;
	m_bProjWasReadOnly = FALSE;
	m_bProjConverted = FALSE;
	m_bConvertedVC20 = FALSE;
	m_bConvertedDS4x = FALSE;
	m_bConvertedDS5x = FALSE;
	m_bConvertedDS6 = FALSE;
	m_bConvertedDS61 = FALSE;
	m_bGotUseMFCError = FALSE;
	m_bProjExtConverted = FALSE;
    m_bOkToDirty = TRUE;
    m_bProjectDirty = FALSE;
	m_bDirtyDeferred = FALSE;
	m_nDeferred = 0;
	m_bProj_PerConfigDeps = FALSE;
	m_bHaveODLFiles = FALSE;

 	if (m_lstProjects.IsEmpty()) // init these only for the first project
	{
		g_nIDOptHdlrUnknown = 10; // 0 is reserved fir CCustomBuildTool
		g_nIDToolUnknown = PROJ_PER_CONFIG_UNKNOWN;
	}
	m_lstProjects.AddTail((CObject *)this);

	::InitializeCriticalSection(&m_critSection);
}
///////////////////////////////////////////////////////////////////////////////
void CProject::Destroy()
{
	static bool bWalkedList = false;

	// destroying our project
	BOOL bOldComplete = m_bProjectComplete;
	m_bProjectComplete = FALSE;
 	m_strProjActiveConfiguration.Empty();
	m_strProjDefaultConfiguration.Empty();
	m_strProjStartupConfiguration.Empty();

	m_bOkToDirty = FALSE; // can't do this from here on...

	if( m_bConvertedDS4x && !bWalkedList )
	{
		bWalkedList = true;
		m_bConvertedDS4x = FALSE;

		// may also need to delete temp projects
		POSITION pos = CProject::m_lstProjects.GetTailPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			CProject * pProject = (CProject *)CProject::m_lstProjects.GetPrev(pos);
			if (pProject->m_bConvertedDS4x)
			{
				delete pProject;
			}
		}
	}
	
	// delete each of the targets which in turn will delete their contents
	CString strConfigName; CTargetItem * pTarget; HCONFIGURATION hConfig;
	POSITION pos;
	while ((pos = m_TargetMap.GetStartPosition()) != (POSITION)NULL)
	{
		m_TargetMap.GetNextAssoc(pos, strConfigName, (void* &)pTarget);
        hConfig = g_BldSysIFace.GetConfig(strConfigName, (HPROJECT)this);
        g_BldSysIFace.DeleteConfig(hConfig, (HPROJECT)this);
	}

	// now delete any configs that might not have been registered (read failed early)
	int n = GetPropBagCount();
	CConfigurationRecord * pcr;
	while (n-- > 0)	// work backwards so array is intact
	{
		pcr = (CConfigurationRecord*) m_ConfigArray[n];
		VSASSERT(pcr, "NULL config record in config array!");

		// Perform the delete...
		DeleteConfigFromRecord(pcr);
	}

	// finished destroying
	// restore previous state
	m_bProjectComplete = bOldComplete;
}
///////////////////////////////////////////////////////////////////////////////
CProject::~CProject ()
{
	if (m_lstProjects.GetCount()==1) // don't do this unless this is the last project!
		g_bInProjClose = TRUE;

	// ** DATA **
	// destroy the contents of the project
	Destroy();

	// ** OTHER DATA **
	// we cannot allow dynamic async. sections to remain registered
	
	// UNDONE: make this per-builder
	CBldrSection * pbldsect;
	g_BldSysIFace.InitSectionEnum();
	CString strName;
	while ((pbldsect = g_BldSysIFace.GetNextSection(strName)) != (CBldrSection *)NULL)
	{
		// dynamic async. sections?
		if (pbldsect->m_pfn == NULL && pbldsect->m_hBld == (HPROJECT)this) // This section must be from this project
		{
			g_BldSysIFace.DeregisterSection((const CBldrSection *)pbldsect);

			if (pbldsect->m_pch != (TCHAR *)NULL)
				free(pbldsect->m_pch);

			delete pbldsect;
		}
  	}

	POSITION pos = m_lstProjects.Find((CObject *)this);
	VSASSERT(pos != NULL, "Failed to find ourself in the projects list!");
	m_lstProjects.RemoveAt(pos);
	// reset pos to make sure it's still valid
	m_posProjects = m_lstProjects.GetHeadPosition();

	if (m_posProjects == NULL)
		GlobalCleanup();	// only do this for the last project

	if (this == g_pActiveProject)
	{
		CProject * pProject;
		g_pActiveProject = NULL;  	// we may no longer have an active project!
		POSITION pos = m_lstProjects.GetHeadPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			pProject = (CProject *)m_lstProjects.GetNext(pos);
			if (pProject != NULL)
			{
				ASSERT_VALID(pProject);
				if (pProject->IsLoaded())
				{
					HCONFIGURATION hConfig = g_BldSysIFace.GetActiveConfig((HPROJECT)pProject);
					if (hConfig==NO_CONFIG)
					{
						CTargetItem * pTargetItem;
						CString strTargetName;
						pProject->InitTargetEnum();
						pProject->NextTargetEnum(strTargetName, pTargetItem);
						hConfig = g_BldSysIFace.GetConfig(strTargetName, (HPROJECT)pProject);
						VSASSERT (hConfig, "No active config!");
					}
					g_BldSysIFace.SetActiveConfig(hConfig, (HPROJECT)pProject);
					break;
				}
				else
				{
					g_pActiveProject = pProject; // at least we have one
				}
			}
		}
	}

	::DeleteCriticalSection(&m_critSection);

	if (m_pFilePath)
	{
		delete m_pFilePath;
		m_pFilePath = NULL;
	}
	//ReleaseInterface();
	g_bInProjClose = FALSE;

}

// this static function gets called only after all CProjects have been destroyed and deleted
void CProject::GlobalCleanup()
{
    // Clear out all unknown tools from all projtypes
    CProjType * pprojtype;
    g_pPrjcompmgr->InitProjTypeEnum();
    while (g_pPrjcompmgr->NextProjType(pprojtype))
        pprojtype->ClearUnknownTools();

}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::SetFile(const CPath *pPath, BOOL  /* = FALSE */)
{
	VSASSERT(pPath != (const CPath *)NULL, "SetFile cannot be called with a NULL path");
	VSASSERT(pPath->IsInit(), "SetFile requires an initialized path");

	if (m_pFilePath)
	{
		delete m_pFilePath;
		m_pFilePath = NULL;
	}

	m_pFilePath = new CPath(*pPath);

	if (m_pFilePath != NULL)
	{
		// get new title as well
		m_strProjItemName = GetFilePath()->GetFileName();

		// init m_ProjDir here as well
		BOOL bOK = m_ProjDir.CreateFromPath(*GetFilePath());
		VSASSERT(bOK, "Failed to create project directory path!");

		m_ActiveTargDir = m_ProjDir;
		return TRUE;
	}

	return FALSE;
}

const CPath *CProject::GetFilePath() const
{
	return m_pFilePath;
} 
///////////////////////////////////////////////////////////////////////////////
void CProject::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	if ((fo & flt_ExcludeProjects))
	{
		fAddItem = FALSE;
	}
	else
		fAddItem = TRUE;

	// Always consider contents regardless of whether we consider the
	// project node itself
	fAddContent = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::InitNew(const CVCPtrList * plstProjType)
{
	if (plstProjType != (const CVCPtrList *)NULL)
	{
		VCPOSITION pos = plstProjType->GetHeadPosition();
		VSASSERT(pos != (VCPOSITION)NULL, "must have at least one projtype!");

		HCONFIGURATION hDebugTarg, hReleaseTarg;

		// create a pair of targets for each target type
		while (pos != NULL)
		{
			CProjType * pProjType = (CProjType *)plstProjType->GetNext(pos);
			(void) g_BldSysIFace.AddDefaultConfigs
					(
						(const TCHAR *)*pProjType->GetPlatformName(),	// 'official' name of this target's platform
						(const TCHAR *)*pProjType->GetTypeName(),		// 'official' name of this target type
						hDebugTarg, hReleaseTarg,						// our new targets
						FALSE											// we're using 'official' names
					);
		}
	}

	m_bProjectComplete = TRUE;	// project is now ok to use...

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////

void CProject::SetBuildToolsMap()
{
	const CVCPtrArray * pCfgArray = GetConfigArray();
	INT_PTR cCfgs = pCfgArray->GetSize();
	for (int i=0; i < cCfgs; i++)
	{
		CConfigurationRecord *pConfiguration = (CConfigurationRecord *)pCfgArray->GetAt(i);
		pConfiguration->SetBuildToolsMap();
	}
}

///////////////////////////////////////////////////////////////////////////////

BOOL CProject::InitFromFile (const char *pFileName, BOOL /* bLoadOPTFile  = TRUE */)
{
//	Read in the supplied makefile.  We dont' know yet if its internal or
//  external, and we won't know until we call ReadMakeFile (which looks for
//	the signature string).  If it is an internal file, load silently, regards
//  of whether or not the OPT file has been found.  If its external, and there
//  is a OPT file, also load silently, since presumably this file has been used
//  as external before.  If its an external makefile and there's no OPT, then
//  as if we should import:

	CPath NewPath;
	ReadMakeResults rmr = ReadInternal;
	g_pConvertedProject = NULL;
	CString strMsg;
	CString	strCmdLine;		// holds command line for .exe on command line proj
	CWaitCursor wc ;		// Wait cursor while load is in progress
	BOOL	bProjectDirty = FALSE ;
	CPath::ResetDirMap(); // clear cache for new project
	
	// Dirty until load successfully:
    DirtyProject();

	if (!NewPath.Create (pFileName) || !SetFile (&NewPath) ) return FALSE;
	InformDependants (SN_FILE_NAME);

	{
		rmr = ReadMakeFile (bProjectDirty);

		if (rmr == ReadExportedMakefile)
		{
			// if we opened an exported makefile, try again with the new filename
			rmr = ReadMakeFile(bProjectDirty);
		}

		if (rmr == ReadError)
			return FALSE;
		else if (rmr == ReadExternal)
		{
			// come up with a name for this project
			CString strProjectName;
			NewPath.GetBaseNameString(strProjectName);
 			SetTargetName(strProjectName);
			VSASSERT(GetPropBagCount() == 0, "Property bags should be cleaned up by now");

			m_bProjConverted = m_bConvertedVC20 = FALSE;

 			// Put up the platforms dialog if we have more than one
			// platform installed on the system
			CStringList lstPlatforms;
 			if (g_pPrjcompmgr->GetSupportedPlatformCount() > 1)
			{
				CProjTempProjectChange projTempProjectChange (NULL);
				return FALSE;
			}
			else
			{
				// Create external targets for the primary platform
				CPlatform* pPlatform = g_pPrjcompmgr->GetPrimaryPlatform();
				const CString * pstrPlatformName = pPlatform->GetUIDescription();
				lstPlatforms.AddTail(*pstrPlatformName);
			}

			// Reading an external makefile
			HCONFIGURATION hDebugTarg = NO_CONFIG;
			HCONFIGURATION hReleaseTarg;
			CString strTypeName;
			BOOL bOK = strTypeName.LoadString(IDS_EXTTARG_PROJTYPE);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

            // Create all the external targets
			CString strPlatformName;
			POSITION pos = lstPlatforms.GetHeadPosition();
			while (pos != NULL)
			{
				strPlatformName = lstPlatforms.GetNext(pos);
			
				// Add debug and release targets
				(void) g_BldSysIFace.AddDefaultConfigs
						((const TCHAR *) strPlatformName,
						(const TCHAR *)strTypeName,
						hDebugTarg, hReleaseTarg,
						TRUE, TRUE, TRUE, hDebugTarg
						);
			}

			// Add the external makefile as a file in the wrapper internal
			// makefile.
			HPROJECT hProj = (HPROJECT)g_pActiveProject;
			HFILESET hFileSet = g_BldSysIFace.GetFileSet(hProj, hDebugTarg);
			g_BldSysIFace.AddFile(hFileSet, &NewPath, FALSE);
			NewPath.ChangeExtension(".dsp");
			SetFile(&NewPath);
			InformDependants (SN_FILE_NAME);

			// Mark project so that we will immediately save it
			m_bProjConverted = TRUE;
			bProjectDirty = TRUE;

			// Flag that the current project was created by converting
			// an external makefile
			m_bProjExtConverted = TRUE;
 		}
		else if (rmr == ReadInternal)
		{
		}
		else
		{
			VSASSERT(FALSE, "Unhandled case in InitFromFile");
			return FALSE;
		}

		RecheckReadOnly();	// See if the .MAK file is read-only
	}

    CleanProject();

	// we can set the project to dirty by now
	if (bProjectDirty)
	{
		// set project as dirty
        DirtyProject();
	}

	CString str, strProjects;
	if (m_bConvertedDS4x)
	{
		CProject * pProject;
		CProject::InitProjectEnum();
		while ((pProject = (CProject *)CProject::NextProjectEnum(str, FALSE)) != NULL)
		{
			// only consider the recently converted ones
			if (pProject->m_bConvertedDS4x)
			{
				pProject->m_bProjectComplete = TRUE;	// projects are now ok to use...
				strProjects += '\t';
				strProjects += *pProject->GetFilePath();
				strProjects += '\n';
			}
		}
	}
	else
	{
 		m_bProjectComplete = TRUE;	// project is now ok to use...
		strProjects += '\t';
		strProjects += *GetFilePath();
		strProjects += '\n';
	}

	// skip this dialog when doing minor conversion from 5.x
	if ((m_bProjConverted) && (rmr == ReadInternal) && (!m_bConvertedDS5x) && (!m_bConvertedDS6) 
		&& (!m_bConvertedDS61))
	{
		CProjTempProjectChange projTempProjectChange (NULL);
	}
	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Obtain the toolset for this projects platform type.
INT CProject::GetProjectToolset()
{
	CDirMgr * pDirMgr = GetDirMgr();
	CProjType * pProjType;
	INT nToolset;

	// Get the toolset for the current project platform
	g_pPrjcompmgr->LookupProjTypeByName(GetActiveConfig()->GetOriginalTypeName(), pProjType);

	// If the current toolset is unsupported then we pick the primary platform as a default
	if (!pProjType->IsSupported())
	{
		CPlatform * pPlatform = g_pPrjcompmgr->GetPrimaryPlatform();
		nToolset = pDirMgr->GetPlatformToolset(*(pPlatform->GetName()));
	}
	else
		nToolset = pDirMgr->GetPlatformToolset(*(pProjType->GetPlatformName()));

	return nToolset;
}

///////////////////////////////////////////////////////////////////////////////
CProject::ReadMakeResults CProject::ReadMakeFile (BOOL &bProjectDirty)
{
//	Open the project's makefile and try to read it in as an internal makefile.
//	The makefile reader determines this by looking for our special header in
//	the file.
	g_pLastTool = NULL;
	static UINT idConvReply;

	BOOL bRetval = TRUE, bOkAsInternal = FALSE;
	const CPath *pPath = GetFilePath();
	VSASSERT (pPath, "Project file path required");
	CObject *pObject = NULL;
	CString strMsg, str, str1, str2, str3, strDSSig;
	ReadMakeResults rmr = ReadInternal;

	CMakFileReader mr;

	// FUTURE: remove this when move to CBuildFile in bldrfile.cpp
	g_buildfile.m_pmr = &mr;
	
	CFileException excptFile;
	if (!mr.Open(*pPath, CFile::modeRead | CFile::shareDenyWrite, &excptFile))
	{
		// If e.m_cause == CFileException::none, we didn't even get to the open,
		// meaning the path is bad somehow...

		CProjTempProjectChange projTempProjectChange (NULL);
		rmr = ReadError;
	}
	else																
	{
		try
		{
			pObject = mr.GetNextElement();
			VSASSERT (pObject, "NULL element in CMakFileReader object!");

			// Skip over "Microsoft Developer Studio Project File" signature
			BOOL bOK = strDSSig.LoadString (IDS_DSPROJ_SIG_STRING);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
			if ((pObject->IsKindOf(RUNTIME_CLASS(CMakComment))) &&
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)strDSSig, strDSSig.GetLength()) == 0))
			{
				// UNDONE: check/assert that the package id is 4
				delete pObject;
				pObject = mr.GetNextElement();
				VSASSERT (pObject, "NULL element in CMakFileReader object!");
			}

			// look for a comment with the signature string
			// to see if it is a Dolphin or Olympus makefile
			// or an Orion project file
			bOK = str.LoadString (IDS_MAKEFILE_SIG_STRING);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
            bOK = str1.LoadString (IDS_BUILDPRJ_SIG_STRING);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
            bOK = str2.LoadString (IDS_OLD_MAKEFILE_SIG_STRING);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
            bOK = str3.LoadString (IDS_EXPORT_SIG_STRING);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
			if ((!pObject->IsKindOf(RUNTIME_CLASS(CMakComment))) ||
				 ((_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str, str.GetLength()) != 0) && 
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str1, str1.GetLength()) != 0) && 
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str2, str2.GetLength()) != 0) && 
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str3, str3.GetLength()) != 0))
			   )
			{
				// Either not a VC makefile at all or is pre-V2.0
				// TODO: give a better error message about why we can't convert here... (pre-V2.0)
				rmr = ReadError;
				AfxThrowFileException (CFileException::generic);
			}
			else if (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str3, str3.GetLength()) == 0)
			{
				CDir dir;
				CPath path;
				dir.CreateFromPath(*pPath);
				bOK = path.CreateFromDirAndFilename(dir, ((const TCHAR *)((CMakComment *)pObject)->m_strText) + str3.GetLength());
				VSASSERT(bOK, "Failed to create path!");
				delete pObject;
				pObject = (CObject *)NULL;
				if (!path.ExistsOnDisk())
				{
					// file doesn't exist, so give up
					CProjTempProjectChange projTempProjectChange (NULL);
					rmr = ReadExternal;
				}
				else
				{
					SetFile(&path, TRUE);
					InformDependants (SN_FILE_NAME);
					rmr = ReadExportedMakefile;
				}
			}
			else
			{
				//
				// A Dolphin or Olympus makefile
				//

				// FUTURE: UNICODE
				BOOL bV4xSigString = !(_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str, str.GetLength())); 
				BOOL bNewSigString = !(_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str1, str1.GetLength())); 
 				TCHAR * pend;
				UINT fileVer = strtoul ((const TCHAR *)((CMakComment *)pObject)->m_strText
									    + ((bNewSigString ? str1 : (bV4xSigString ? str : str2)).GetLength () / sizeof (TCHAR)), &pend, 10);
				
				// Makefile version parsing. Makefile versions can be of two formats
				// 1. Release format, the version number is of the form "m.nn"
				// 2. Internal format, the version number if of the form mnnii
				// where m = major version number
				//       n = minor version number
				//       i = internal version number
				// We must have the correct major version number but allow a lower
				// limit on the minor & internal version numbers
 				UINT nMajor, nMinor, nFormat;
				BOOL bFutureFormat = FALSE;

				if ((*pend)==_T('.'))
				{
					// Release format makefile version number as it contains a period
					// So get the major and minor versions and check the validity
					nMajor = fileVer;
					nMinor = strtoul(++pend, NULL, 10);
					bOkAsInternal = ( (10000*nMajor+100*nMinor) >= nLastCompatibleMakefile);
  				}
				else
				{
					// Internal format makefile version number. So get the major version
					// number and compare it no the last compatible makefile version.
					nMajor = fileVer / 10000;
					nMinor = fileVer / 100 - (nMajor * 100);
 					bOkAsInternal = (fileVer >= nLastCompatibleMakefile);
 				}
				nFormat = nMajor * 10000 + nMinor * 100;
				bFutureFormat = ((nFormat > nVersionNumber) && (nFormat >= (g_nNextIncompatibleVersion * 100))); // defaults to 700
				bOkAsInternal = bOkAsInternal && !bFutureFormat;

				m_bConvertedVC20 = FALSE;
				m_bConvertedDS4x = FALSE;
				m_bConvertedDS5x = FALSE;
				m_bConvertedDS6 = FALSE;
				m_bConvertedDS61 = FALSE;

				if (nMajor > 6 && !bFutureFormat)
				{
					// not a THING we can do about converting anything past VC6X...
				}
				else if ((nMajor >= 2) && (nMajor <= 6))
				{
					g_pActiveProject = NULL;
					// Prepare to convert
					// VC++ 2.0/4.0 makefile
					if (nMajor == 2)
						m_bConvertedVC20 = TRUE;
					else if (nMajor < 5)
						m_bConvertedDS4x = TRUE;
					else if (nMajor == 5)
						m_bConvertedDS5x = TRUE;
					else if (nMajor == 6)
					{
						if (nMinor == 0)
							m_bConvertedDS6 = TRUE;
						else
							m_bConvertedDS61 = TRUE;
					}

					// Flag bOkAsInternal as TRUE, we are converting!!
					m_bProjConverted = bOkAsInternal = TRUE;

					// we'll need this later...
					g_pConvertedProject = (CProject *)this;
				}
				else if (bFutureFormat)
				{
					// give error if trying to load with old product
					VSASSERT(!bOkAsInternal, "Trying to load with old product");
					rmr = ReadError;
				}

				// Ok this is the latest and greatest makefile format
				if (!bOkAsInternal)
 					AfxThrowFileException (CFileException::generic);
 
				delete (pObject); pObject = (CObject *)NULL;
				VSASSERT(bOkAsInternal, "How'd we get here without a signature?");	// ok as internal (we saw a signature)

				// Read in configurations:
				if (!ReadConfigurationHeader(mr))
				{
					if (m_bConvertedDS5x || m_bConvertedDS6 || m_bConvertedDS61)
						rmr = ReadError; // don't try to wrap
					AfxThrowFileException(CFileException::generic);
				}

				VSASSERT(this == g_pActiveProject, "Current project must be active project during project load");

				// we'll break when we hit the '# Project' delimiter or EOF
				for (;;)
				{
					if (pObject)
					{
						delete pObject;
						pObject = (CObject *)NULL;
					}

					pObject = mr.GetNextElement();
					VSASSERT (pObject != (CObject *)NULL, "NULL element in CMakFileReader object!");

					// reached end of builder file prematurely?
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
	                	AfxThrowFileException(CFileException::generic);

					// read in our sections
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
					{
						const TCHAR * pchComment = (const TCHAR *)((CMakComment *)pObject)->m_strText;

						// got the '# Project' comment?
						if (GetRTCFromNamePrefix(pchComment) == GetRuntimeClass())
							break;
					}
				}

				mr.UngetElement(pObject); pObject = (CObject *)NULL;
				
				// Read in the bulk of the makefile
				if (!ReadFromMakeFile (mr, GetWorkspaceDir()))
		        	AfxThrowFileException (CFileException::generic);

				// Read in our sections
				// We'll break when we hit EOF
				for (;;)
				{
					if (pObject)
					{
						delete pObject;
						pObject = (CObject *)NULL;
					}

					pObject = mr.GetNextElement();
					VSASSERT (pObject != (CObject *)NULL, "NULL element in CMakFileReader object!");

					// reached end of builder file?
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
	                	break;

					// read in our sections
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
					{
						const TCHAR * pchComment = (const TCHAR *)((CMakComment *)pObject)->m_strText;

						// got a '# Section <name>' comment?
						// FUTURE: replace this with the szSectionMark in bldrfile.cpp when move there
						if (!_tcsnicmp(pchComment, _TEXT("Section"), 7))
							if (!g_buildfile.ReadSectionForNMake((const TCHAR *)(pchComment + 8)))
								AfxThrowFileException(CFileException::generic);
					}
				}

				if (pObject)
				{
					delete pObject;
					pObject = (CObject *)NULL;
				}

				CProject * pProject = GetProject();
				VSASSERT(pProject == this, "How could we not have the current project have itself as its project?");
				CString strProj;
				if (m_bConvertedDS4x)
				{
					CProject::InitProjectEnum();
					pProject = (CProject *)CProject::NextProjectEnum(strProj, FALSE);
				}
				do {
					const CVCPtrArray * pCfgArray = pProject->GetConfigArray();
					INT_PTR icfg, size = pCfgArray->GetSize();
					if ((pProject->m_bConvertedDS6) || (pProject->m_bConvertedDS61) ||
						(pProject->m_bConvertedDS5x) || (pProject->m_bConvertedDS4x) || m_bConvertedVC20)
					{
						CStringList lststrPlatforms;
						CString strPlatformName;
						bOK = strPlatformName.LoadString(IDS_V4_MACPMC_PLATFORM);
						VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
						lststrPlatforms.AddTail(strPlatformName);
						bOK = strPlatformName.LoadString(IDS_V4_MIPS_PLATFORM);
						VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
						lststrPlatforms.AddTail(strPlatformName);
						bOK = strPlatformName.LoadString(IDS_V2_MAC68K_PLATFORM);
						VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
						lststrPlatforms.AddTail(strPlatformName);
						bOK = strPlatformName.LoadString(IDS_V2_MACPPC_PLATFORM);
						VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
						lststrPlatforms.AddTail(strPlatformName);
						bOK = strPlatformName.LoadString(IDS_V4_PPC_PLATFORM);
						VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
						lststrPlatforms.AddTail(strPlatformName);

						BOOL bFoundSupported = FALSE;
						CString strEmpty;
						icfg = size;
						while (icfg-- > 0)
						{
							CConfigurationRecord * pcr = (CConfigurationRecord *)pCfgArray->GetAt(icfg);
							CString strOriginalName = pcr->GetConfigurationName();
							CString strDebugness = strOriginalName;
							CProjType * pprojtype = NULL;
							CString strOrgType = pcr->GetOriginalTypeName();
							g_pPrjcompmgr->LookupProjTypeByName(strOrgType, pprojtype);
							if (pprojtype->IsSupported())
							{
								bFoundSupported = TRUE;
								continue;
							}

							int index = strOriginalName.Find(_T(" - "));
							if (index != -1)
								strDebugness = strOriginalName.Mid(index + 3);
							POSITION pos = lststrPlatforms.GetHeadPosition();
							while (pos != NULL)
							{
								strPlatformName = lststrPlatforms.GetNext(pos);
								int nLength = strPlatformName.GetLength();
								if 	((_tcsncmp((LPCTSTR)strPlatformName, (LPCTSTR)strOrgType, nLength)==0) ||
									 (_tcsncmp((LPCTSTR)strPlatformName, (LPCTSTR)strDebugness, nLength)==0))
								{
									// delete old configs
									HCONFIGURATION hConfig = g_BldSysIFace.GetConfig(strOriginalName, (HPROJECT)pProject);
									VSASSERT(hConfig != NO_CONFIG, "Need at least one config before we can delete one here.");
									g_BldSysIFace.DeleteConfig(hConfig, (HPROJECT)pProject);
									break;
								}
							}
						}
					}

					size = pCfgArray->GetSize();
					VSASSERT(m_bProjConverted || (size != 0), "Problem during conversion");
					
					if ((size == 0) && (m_bProjConverted))
					{
						// we deleted everything on conversion!
						rmr = ReadError;
						AfxThrowFileException (CFileException::generic);
					}

					for (icfg = 0; icfg < size; icfg++)
					{
						CConfigurationRecord * pcr = (CConfigurationRecord *)pCfgArray->GetAt(icfg);
						CProjTempConfigChange projTempConfigChange(pProject);
						projTempConfigChange.ChangeConfig(pcr);

						// Post-'read custom build' assignment for target-level
						// we couldn't do this during the read because we hadn't set
						// up our targets as we were reading in the project-level blurb....
						// we'll fix this for v4.0 ;-)
						// we'll send this one, we only need one, P_CustomCommand or P_CustomOutputSpec
						// both are supported by custom build
						pProject->InformDependants(P_CustomCommand); 

						if (m_bConvertedVC20 || pProject->m_bConvertedDS4x)
						{
							// Set minimum build and/or MRE deps flags for compiler
							COptionHandler * popthdlr;
							g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler),
																 (CBldSysCmp *&)popthdlr);

							if (m_bConvertedVC20)
								pProject->SetIntProp(popthdlr->MapLogical(P_Enable_MR), TRUE);

							pProject->SetIntProp(popthdlr->MapLogical(P_Enable_FD), TRUE);

							// convert include paths for subprojects
							if (pProject->m_bConvertedDS4x)
								pProject->ConvertDirs();

							// Enable the /mktylib203 flag.
							g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_MkTypLib),
															 (CBldSysCmp *&)popthdlr);

							pProject->SetIntProp(popthdlr->MapLogical(P_MTLMtlCompatible), TRUE);
						}

						if (m_bConvertedVC20 || pProject->m_bConvertedDS4x || m_bConvertedDS5x)
						{
							// V5 -> V6 conversion goes here

							COptionHandler * popthdlr;
							g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler),
																 (CBldSysCmp *&)popthdlr);

							// Check what kind of debug info is allowed by platform
							CPlatform * pPlatform = pProject->GetCurrentPlatform();
							DWORD dwAttrib = pPlatform->GetAttributes();
							BOOL fEnc = dwAttrib & PIA_Supports_ENC;
							if( fEnc )
							{
								// set ENC options for debug targets
								int val;
								// only set for debug configs  (check for /Od)
								if ((pProject->GetIntProp(popthdlr->MapLogical(P_Optimize), val) == valid) && (val == 1))
								{
									UINT nId = popthdlr->MapLogical(P_DebugInfo);
									if ((pProject->GetIntProp(nId, val) == valid) && (val == DebugInfoPdb))
									{
										// also not compatible with /dlp (internal)
										if ((pProject->GetIntProp(popthdlr->MapLogical(P_Enable_dlp), val) != valid) || (val == 0))
										{
											pProject->SetIntProp(nId, DebugInfoENC);
										}
									}
								}
							}
						}
					}
				} while (m_bConvertedDS4x && ((pProject = (CProject *)CProject::NextProjectEnum(strProj, FALSE)) != NULL));

				// Post-'read bulk' VC++ 2.0 conversion?
				// Convert VC++ 2.x target names 
				if (m_bConvertedVC20)
				{
					// Ok. Loop through all targets and turn the v2 names into v3 names.
					// The conversion algorithm, goes like this,
					// v3 names are of the form
					// <project name> - <platform> <debugness bit>
					// so we get the project name from the base name of the v2 makefile.
					// The platform we can determine from the config mgr.
					// Finally we take the original v2 name, strip hyphens from it, and
					// then try to strip a platform name from the front, and the remaining
					// string we set as the debugness bit

					// Get the project name from the makefiles base name
					CString strProjectName;
					pPath->GetBaseNameString(strProjectName);


					// Load the old v2 platform names for later
					CStringList lststrPlatforms;
					CString strPlatformName;
					
					// (WinslowF) When I remove MIPS targets, I commented the following line.
					// We still might need this string to remove MIPS target from impot makefile.
					// If so, you might wannt to take the commnts out of this string in Vproj.rc
					// and resource.h as well.
					bOK = strPlatformName.LoadString(IDS_V2_WIN32X86_PLATFORM);
					VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
					lststrPlatforms.AddTail(strPlatformName);
					bOK = strPlatformName.LoadString(IDS_V2_WIN3280X86_PLATFORM);
					VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
					lststrPlatforms.AddTail(strPlatformName);
					bOK = strPlatformName.LoadString(IDS_V2_WIN32_PLATFORM);
					VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
					lststrPlatforms.AddTail(strPlatformName);
					
					// Loop through all the targets and rename each of them
					const CVCPtrArray * pCfgArray = GetProject()->GetConfigArray();
					INT_PTR icfg, size = pCfgArray->GetSize();
					for (icfg = 0; icfg < size; icfg++)
					{
						CConfigurationRecord * pcr = (CConfigurationRecord *)pCfgArray->GetAt(icfg);
						CProjTempConfigChange projTempConfigChange(this);
						projTempConfigChange.ChangeConfig(pcr);

						// The original v2 target name
						CString strOriginalName = pcr->GetConfigurationName();
 					
						// Get the new platform name
						CPlatform * pPlatform = GetCurrentPlatform();
						CString strPlatform = *(pPlatform->GetUIDescription());

						// If we recognise an old v2 platform name at the front of the old
						// v2 target name then we strip it off
						CString strDebugness = strOriginalName;
						POSITION pos = lststrPlatforms.GetHeadPosition();
						while (pos != NULL)
						{
							strPlatformName = lststrPlatforms.GetNext(pos);
							int nLength = strPlatformName.GetLength();
							if (!strPlatformName.Compare(strDebugness.Left(nLength)))
							{
								strDebugness = strDebugness.Right(strOriginalName.GetLength() - nLength);
								break;
							}
						}

						// If there is a space at the start of the v2 target name then remove it
						if (!strDebugness.IsEmpty() && strDebugness[0] == _T(' '))
							strDebugness = strDebugness.Right(strDebugness.GetLength() - 1);

						// Construct the new name from the basename of the makefile, the new platform name,
						// and the remaining portion of the old v2 target name
						CString strNewName = strProjectName + _T(" - ") + strPlatform + _T(" ") + strDebugness;

						CTargetItem* pTarget = GetTarget(strOriginalName);
						SetTargetName(strProjectName);
						VSASSERT(pTarget != NULL, "No target for the project!");
						if (pTarget != NULL)
							pTarget->SetTargetName(strProjectName);

						// There are some consistency requirements for VC 4.0 projects that were not
						// meaningful in VC 2.0 projects. For example debug MFC requires debug CRT's
						// but there were no debug CRT's in VC 2.0. We call PerformWizardSettings 
						// to do the validity checking and make the neccessary changes.

						int iUseMFC;
						GetIntProp(P_ProjUseMFC, iUseMFC);
					
						GetProjType()->PerformSettingsWizard(this, iUseMFC);
					}

					m_bProjConverted = TRUE;

					// we want to dirty the project because it is not "silent convert"
					bProjectDirty = TRUE;
				}

				// Post-'read bulk' VC++ 4.x, 5.x, or 6.x conversion?
				if (m_bConvertedDS4x || m_bConvertedDS5x || m_bConvertedDS6 || m_bConvertedDS61)
				{
					m_bProjConverted = TRUE;

					// we want to dirty the project because it is not "silent convert"
					bProjectDirty = TRUE;
				}
			}

			mr.Close();
			if (m_bProjConverted)
			{
				CPath newPath = *pPath;
				newPath.ChangeExtension(BUILDER_EXT);
				SetFile(&newPath, TRUE);
				InformDependants (SN_FILE_NAME);
			}
		}
		catch (CFileException* pEx)
		{
			UNUSED_ALWAYS(pEx);

			if (pObject)
			{
				delete pObject;
			}

			mr.Abort();	// Safely close the reader.

			// restore the project to an empty state
			// since we may try to read in an old OPT file
			// for it and use the project as an external project
			Destroy();

			bRetval = FALSE;
		}
	}

	if ((rmr != ReadError) && (rmr != ReadExportedMakefile))
	{
		if (!bRetval || !bOkAsInternal)
		{
			// If we failed to load this project because the
			// project uses mfc and we haven't got mfc installed
			// and the user explicitly said don't load it, then
			// flag the problem as a read error
			// OTHERWISE
			// we flag the problem as being the makefile is
			// external (and will later try to load it as such)
			if (bOkAsInternal && m_bGotUseMFCError)
				rmr = ReadError;
			else if (rmr != ReadExternal)
			{
				// don't offer to wrap unless converted .mak
 				rmr = m_bProjConverted ? ReadExternal : ReadError;
			}
		}
		else if (m_bGotUseMFCError)
		{
			bProjectDirty = TRUE;
		}
	}

	return rmr;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
	CObject *pObject = NULL;
	CString str;
	CProject * pProject;
	if (m_bConvertedDS4x)
	{
		CProject * pProject;
		CProject::InitProjectEnum();
		while ((pProject = (CProject *)CProject::NextProjectEnum(str, FALSE)) != NULL)
		{
			pProject->m_cp = EndOfConfigs;
		}
	}
	else
	{
		m_cp = EndOfConfigs;
	}
	
	pProject = (CProject *)this;

	TRY
    {
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
				AfxThrowFileException (CFileException::generic);

 		delete (pObject); pObject = NULL;

		for (pObject = mr.GetNextElement (); pObject!=NULL; pObject = mr.GetNextElement ())
	   	{

			if (pProject->IsPropComment(pObject))
				continue;
			else if (pProject->IsAddSubtractComment(pObject))
				continue;
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakDirective)))
			{
				pProject->ReadConfigurationIfDef((CMakDirective *)pObject, m_bConvertedDS4x);
				if (m_bConvertedDS4x)
					pProject = g_pActiveProject;	// may have changed
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakMacro)))
			{
				if (!pProject->SuckMacro ((CMakMacro *) pObject, BaseDir))
					AfxThrowFileException (CFileException::generic);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				if (!pProject->SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException (CFileException::generic);
			}
			else if (pProject->IsCustomBuildMacroComment(pObject)) {
				pProject->ReadCustomBuildMacros(mr);
			}
			// Comment marks start of children:
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
			{
				VSASSERT( pProject->m_cp==EndOfConfigs, "Malformed project file");
				if( pProject->m_cp != EndOfConfigs )
					AfxThrowFileException (CFileException::generic);

				mr.UngetElement ( pObject );
				pObject = NULL;
				break;
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakEndOfFile)))
			{
				AfxThrowFileException (CFileException::generic);
			}

	   		delete (pObject); pObject = NULL;
		}

		// Pre-'read bulk' VC++ 2.0 conversion?
		if (m_bConvertedVC20)
		{
   			CConfigurationRecord* pcr;
			CString strTargetName;
			CTargetItem* pNewTarget = NULL;

			// All the remaining configs are also mapped to the
			// newly created target node, i.e. they are mirrors
			INT_PTR iNumConfig = m_ConfigArray.GetSize();
			for (INT_PTR i = 0 ; i < iNumConfig; i++)
			{
				pcr = (CConfigurationRecord *) m_ConfigArray[i] ;
				strTargetName = pcr->GetConfigurationName();

				if (i == 0)
				{
					pNewTarget = new CTargetItem();
					pNewTarget->MoveInto(this);
				}

				// force the target into it's own config.
				CProjTempConfigChange projTempConfigChange(this);
				projTempConfigChange.ChangeConfig(strTargetName);
				CConfigurationRecord * pcrProject = GetActiveConfig();
								
				pNewTarget->GetActiveConfig()->SetValid(TRUE);
		
			 	// assign the build actions
				CBuildAction::AssignActions(pNewTarget, (CVCPtrList *)NULL, pcrProject);

				// reset the project config.
				projTempConfigChange.Release();

				// Register this target with the project target manager
				RegisterTarget(strTargetName, pNewTarget);
			}
		}

		g_pActiveProject = (CProject *)this;

		// read in children from the makefile
		if (!ReadInChildren(mr, BaseDir))
			AfxThrowFileException (CFileException::generic);

		g_pActiveProject = (CProject *)this;

		CProjTempConfigChange projTempConfigChange(this);

		projTempConfigChange.Reset();

		pProject = (CProject *)this;
		CString strProject;
		if (m_bConvertedDS4x)
		{
			CProject::InitProjectEnum();
			pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE);
			VSASSERT(pProject, "Failed to find at least one project in the projects list");
		}
		do {
			CProjTempConfigChange projTempConfigChange(pProject);
			g_pActiveProject = pProject;
			CTargetItem* pTarget = pProject->GetActiveTarget();

			// custom build assignment (post-project read!)
			CBuildTool * pTool;
			g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild), (CBldSysCmp *&)pTool);
			CVCPtrList lstSelectTools;
			lstSelectTools.AddTail(pTool);

			// special build tool(pre-link/post-build steps)
			g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild), (CBldSysCmp *&)pTool);
			lstSelectTools.AddTail(pTool);
			CTimeCustomBuildItem *pPreEvent=NULL;
			CTimeCustomBuildItem *pPostEvent=NULL;

			// perform some post-read target processing
			CString strTargetName;
			pProject->InitTargetEnum();
			while (pProject->NextTargetEnum(strTargetName, pTarget))
			{
				CConfigurationRecord * pcrTarget = pProject->ConfigRecordFromConfigName(strTargetName);
				projTempConfigChange.ChangeConfig(pcrTarget);

				CBuildAction::UnAssignActions(pProject, &lstSelectTools, (CConfigurationRecord  *)NULL, TRUE);
				CBuildAction::AssignActions(pProject, &lstSelectTools, (CConfigurationRecord  *)NULL, TRUE);
	
				// is this makefile wanting to use MFC?
				if (!g_pPrjcompmgr->MFCIsInstalled())
				{
					// trying to use MFC?
					int fUseMFC;
					CProject * pProject = pTarget->GetProject();
					if (pProject->GetIntProp(P_ProjUseMFC, fUseMFC) == valid && fUseMFC)
					{
						// flag this error
						BOOL bOldGotUseMFCError = pProject->m_bGotUseMFCError;
						pProject->m_bGotUseMFCError = TRUE;

						// best of luck!
						pProject->SetIntProp(P_ProjUseMFC, FALSE);
					}
				}
			}
		} while (m_bConvertedDS4x && ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL));

 	}
	CATCH (CException, e)
	{
		g_pActiveProject = (CProject *)this;
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	g_pActiveProject = (CProject *)this;

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::ReadConfigurationHeader  ( CMakFileReader& mr )
{

//	Look through the configuration header area and try to figure out what
//  configurations there and, along with there project type.  This function
//  leaves us in the last defined configuration:

	CMakDirective *pmd = NULL;
	const TCHAR *pc;
	TCHAR *pstart, *pend;
	CString str, strCfg, strBase, strTarget, strProjName;
	CMapStringToPtr mapTargTypes;
	UINT uniqueId;
	CString strDefaultConfig, strSupportedConfig;
	BOOL bSetDefaultConfig = FALSE;
	BOOL bFoundSupportedConfig = FALSE;
	BOOL bFoundUnsupportedConfig = FALSE;
	BOOL bFoundBuildableConfig = FALSE;
	CPath pathProjFileName;
	CString strProjBaseName;
	CProjType * pSupportedProjType = NULL;
	
	pathProjFileName.CreateFromDirAndFilename(m_ProjDir, m_strProjItemName);
	pathProjFileName.GetBaseNameString(strProjBaseName);
	
	TRY
	{
		// Look for a message directive whose first non-blank is a quote:
		// directives:
		for (;;)
		{
			pmd = (CMakDirective *) mr.GetNextElement ();
			if ((((CMakMacro*)pmd)->IsKindOf ( RUNTIME_CLASS (CMakMacro)))
				&&
				(!((CMakMacro*)pmd)->m_strName.Compare("CFG")))
			{
				// set default config
				if (!m_bConvertedDS4x) // may not be valid if converting		
					m_strProjDefaultConfiguration = ((CMakMacro*)pmd)->m_strValue;
			}
			if (((CMakComment*)pmd)->IsKindOf ( RUNTIME_CLASS (CMakComment))
				&&
					(!((CMakComment*)pmd)->m_strText.Left(9).Compare(_T("TARGTYPE "))))
					{
						str = ((CMakComment*)pmd)->m_strText.Mid(9); // rest of line
						pstart = str.GetBuffer(1);

						if (GetQuotedString (pstart, pend))
						{
							*(pend++) = 0;	// nul terminate
							strTarget = pstart;	// target-type name
#ifdef _WIN64
							mapTargTypes.SetAt(strTarget, (void *)_ttoi64(pend));
#else
							// BUGBUG(MikhailA): why the base is 0 ???
							mapTargTypes.SetAt(strTarget, (void *)(INT_PTR)(_tcstoul(pend, NULL, 0)));
#endif
						}
						else 
							VSASSERT(0, "TARGTYPE makefile comments must be quoted");
						str.Empty();
					}
			if (pmd->IsKindOf ( RUNTIME_CLASS (CMakDirective))
				&&
				pmd->m_dtyp	== CMakDirective::DTYP_MESSAGE
				&&
				!pmd->m_strRemOfLine.IsEmpty ()
				)
			{
				pc = pmd->m_strRemOfLine;
				SkipWhite (pc);
              			if (*pc == _T('"'))  break;
			}
			if (pmd->IsKindOf ( RUNTIME_CLASS (CMakEndOfFile)))
				AfxThrowFileException (CFileException::generic);
			delete (pmd); pmd = NULL;
		}
		
		if (m_bConvertedVC20)
		{
			// come up with a name for this project
			const CPath* ppathProj = GetFilePath();
			CString strProjectName;
			ppathProj->GetBaseNameString(strProjectName);
 			SetTargetName(strProjectName);
		}
		
		BOOL bUsedThisProject = FALSE;
		CProject * pBestFitForThisProject = NULL;
		BOOL bFoundGoodMatch = FALSE;
		BOOL bDelConfigsPrompted = FALSE;
		// Try to read in configs until we see something that's not
		// a message directive.  Each config message line has the config
		// name in the first quoted string and the config orginal type
		// in the second string:
		do
		{
			if (pmd->m_strRemOfLine.GetLength() > 1 )
			{
				// Config name:
				pstart =  pmd->m_strRemOfLine.GetBuffer (1);
				if (!GetQuotedString (pstart, pend ))
					AfxThrowFileException (CFileException::generic);

				*pend = _T('\0');
				strCfg = pstart;
				CProject * pProject = (CProject *)this;
				
				if (m_bConvertedDS4x)
				{
					// if not the current project, create new one to match
					// Form the whole configuration name
					int nFirst = strCfg.Find(_T(" - "));
					VSASSERT(nFirst != -1, "Malformed config name");
					if (nFirst < 1)
						AfxThrowFileException(CFileException::generic);

					// strip out project name for this config
					CString strTarget = strCfg.Left(nFirst);
					CPath pathProj; //, pathProjMak;
					pathProj.CreateFromDirAndFilename(GetWorkspaceDir(), strTarget);
					BOOL bDirExists = (pathProj.ExistsOnDisk() && (!FileExists(pathProj)));

					// If the project we are converting has the same name as the .mak
					// don't try to create the .dsp in the sub-dir even if one exists.
					BOOL bFoundMatchingMak = (strTarget.CompareNoCase(strProjBaseName)==0);
					if (bFoundMatchingMak)
					{
						bDirExists = FALSE;		// REVIEW: remove this test?
					}

					if (TRUE)
					{
						// this might be a subproject config so create a new one
						CString strProject = pathProj;

						// put project in subdir if it exists
						if (bDirExists)
						{
							strProject +=  _T('\\');
							strProject += strTarget;
							pathProj.Create(strProject);
						}
						pathProj.ChangeExtension(_T(BUILDER_EXT));
						// pathProjMak = pathProj; pathProjMak.ChangeExtension(".mak");
						BOOL bFound = FALSE;
						CProject::InitProjectEnum();
						VSASSERT(!strTarget.IsEmpty(), "Malformed config name");

						if (strTarget.CompareNoCase(strProjName)==0)
						{
							// matches the 'main' project
							bFound = TRUE;
						}
						else
						{
							// first see if we already have a project with this name
							while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
							{
								if ((*(pProject->GetFilePath()) == pathProj) ||
									(strTarget.CompareNoCase(strProject)==0))
								{
									if (pProject->m_bConvertedDS4x)
									{
										bFound = TRUE;
										break;
									}
									else
									{
										CProjTempProjectChange projTempProjectChange (NULL);
										AfxThrowFileException(CFileException::generic);
									}
								}
							}
						
							if (!bFound)
							{
								pProject = (CProject *)g_BldSysIFace.CreateProject(pathProj);
								VSASSERT(pProject != NULL, "Unable to create the project");
								if (!pProject)
								{
									AfxThrowFileException(CFileException::generic);
								}
	
								pProject->m_bConvertedDS4x = TRUE;
								pProject->m_bProjConverted = TRUE;
								pProject->m_strProjDefaultConfiguration = strCfg;
								pProject->m_strProjStartupConfiguration.Empty();
								pProject->m_bProjectComplete = FALSE;  // not done yet!								
								pProject->SetTargetName(strTarget);
								if ((pBestFitForThisProject == NULL) || ((!bDirExists) && (!bFoundGoodMatch)) || bFoundMatchingMak)
								{
									bFoundGoodMatch = bFoundMatchingMak || !bDirExists;
									// worst case we just use the first one
									pBestFitForThisProject = pProject;
								}
							}
						}
					}
					else
					{
						VSASSERT(0, "dead code");
					}
					// REVIEW: any other tests necessary?
				}
				g_pActiveProject = pProject;
				if (!pProject->CreateConfig(strCfg))
					AfxThrowFileException(CFileException::generic);

				if (((!bSetDefaultConfig) && ((pProject==this) || (pProject==pBestFitForThisProject))) /* || (m_bConvertedDS4x && !bUsedThisProject) */) // if no valid CFG= read, use first one
				{
					strDefaultConfig = strCfg;
					bSetDefaultConfig = TRUE;
				}

				// Orginal config name:
				pstart = _tcsinc ( pend );
				if (!GetQuotedString (pstart, pend ))
								AfxThrowFileException (CFileException::generic);
				*pend = _T('\0');
			   	strBase = pstart;
				uniqueId = 0;

				CProjType * pProjType = NULL;
				if ((!g_pPrjcompmgr->LookupProjTypeByName (strBase, (CProjType *&) pProjType)) || (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown))))
				{
					if (pProjType==NULL || !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown)))
					{
						// Unrecognized ProjType string so try mapping by UniqueId
						if (!mapTargTypes.Lookup(strBase, (void * &)uniqueId) ||
							!g_pPrjcompmgr->LookupProjTypeByUniqueId(uniqueId, (CProjType *&)pProjType))
						{
							// try to get the platform from the unique id
							CPlatform * pPlatform = NULL;
							if ((uniqueId >> 8) & 255)
								g_pPrjcompmgr->LookupPlatformByUniqueId(((uniqueId >> 8) & 255), pPlatform);

							//
						 	// unknown platform and/or project type so create
							// it to avoid trashing makefile
							//

							// derive platfrom and type names from available information
							int index;

							// 1) By default, strip up to first whitespace or last ')'
							if (((index = strBase.Find(_T(')')))) == -1)
								index = strBase.FindOneOf(_T(" \t"));
							else
								index++;

							CString strType = strBase.Mid(index+1); // default

							if (pPlatform==NULL)
							{
								CString strPlatform = strBase.Left(index);
								pPlatform = new CPlatform(strPlatform, (uniqueId>>8) & 255);
								// Register dynamic platform so deleted on exit
								g_pPrjcompmgr->RegisterUnkProjObj(pPlatform);
							}
							pProjType = new CProjTypeUnknown(strType, uniqueId & 255, pPlatform);
							// Register dynamic projtype so deleted on exit
							g_pPrjcompmgr->RegisterUnkProjObj(pProjType);

							// update name in case it changed
							strBase = *pProjType->GetName();
						}
						else
						{
							// must update to new (supported) targtype name
							// ignore id if either byte is 0
							VSASSERT(uniqueId & 255, "Bad value for uniqueId"); VSASSERT(uniqueId>>8, "Bad value for uniqueId");
							strBase = *pProjType->GetName();
						}
					}
				}
				else if (pProjType && pProjType->GetPlatform() && pProjType->GetPlatform()->GetBuildable())
					bFoundBuildableConfig = TRUE;

				if ((m_bConvertedDS5x || m_bConvertedDS6 || m_bConvertedDS61))
				{	// must allow makefile projects still
					// don't support a particular project type in DevStudio anymore
					CString strTmp = strBase.Left(4);
					if (strTmp.GetLength() == 4)
					{
						strTmp.MakeLower();
						int nCRC = (int)strTmp[0] + (int)strTmp[1] + (int)strTmp[2] + (int)strTmp[3];
						if (nCRC == 418 && strTmp[0] == _T('j'))
							AfxThrowFileException (CFileException::generic);
					}
				}
				// note if we read at least one (un)supported target
				if (pProjType->IsSupported())
				{
					bFoundSupportedConfig = TRUE;
					
					if (pSupportedProjType == NULL)
						pSupportedProjType = pProjType;

					// note the first supported config (default, if supported)
					if (((pProject == this) || (pProject==pBestFitForThisProject)) && ((strSupportedConfig.IsEmpty()) || (strCfg==m_strProjDefaultConfiguration)))
						strSupportedConfig = strCfg;
				}
				else
				{
					bFoundUnsupportedConfig = TRUE;
				}

				// note the first Primary platform we encounter (if any)
				if (pProjType->GetPlatform()->IsPrimaryPlatform() &&
					(pProject->m_strProjStartupConfiguration.IsEmpty() ||	strCfg == pProject->m_strProjDefaultConfiguration))
				{
					pProject->m_strProjStartupConfiguration = strCfg;
				}

				// make this configuration active
				pProject->SetStrProp (P_ProjOriginalType, strBase);
 				pProject->SetStrProp (P_ProjActiveConfiguration, strCfg);
			}

			delete (pmd); pmd = NULL;
			pmd = (CMakDirective *) mr.GetNextElement ();
			VSASSERT(pmd, "NULL element in CMakFileReader object!");

		} while (pmd->IsKindOf ( RUNTIME_CLASS (CMakDirective)) &&
				 pmd->m_dtyp == CMakDirective::DTYP_MESSAGE);

		if (m_bConvertedDS4x && !bUsedThisProject)
		{
			if (!pBestFitForThisProject)
			{
				VSASSERT(0, "Trouble in converting 4.X project");
				AfxThrowFileException(CFileException::generic);
			}
			strSupportedConfig.Empty();
			strDefaultConfig = pBestFitForThisProject->m_strProjDefaultConfiguration;
			SetTargetName(pBestFitForThisProject->GetTargetName());
			// copy pBestFitForThisProject to this and delete
			const CVCPtrArray & ppcr = *pBestFitForThisProject->GetConfigArray();
			CConfigurationRecord * pcr;

			{
				CProjTempConfigChange projTempConfigChange(pBestFitForThisProject);

				CString strConfig, strType;
				INT_PTR ccr = ppcr.GetSize();
				for (INT_PTR icr = 0; icr < ccr; icr++)
				{
					pcr = (CConfigurationRecord *)ppcr[icr];
					projTempConfigChange.ChangeConfig(pcr);
					strConfig = pcr->GetConfigurationName();
			
					if ((!CreateConfig(strConfig)) || (pBestFitForThisProject->GetStrProp(P_ProjOriginalType, strType)!=valid))
						AfxThrowFileException(CFileException::generic);
					// make this configuration active
					SetStrProp (P_ProjOriginalType, strType);
 					SetStrProp (P_ProjActiveConfiguration, strConfig);

					if (strSupportedConfig.IsEmpty() && m_pActiveConfig->IsSupported())
						strSupportedConfig = strConfig;

				}
			}
			pBestFitForThisProject->m_bConvertedDS4x = FALSE;
			delete pBestFitForThisProject;
		}

		// make sure we saw at least one projtype we can support
		if (!bFoundSupportedConfig)
		{
			VSASSERT(bFoundUnsupportedConfig, "Found no project types we can support");
			CProjTempProjectChange projTempProjectChange (NULL);
		}

		// Last things are the !ERROR and the !ENDIF.  Don't need them, so
		// skip unitl we hit comments:
		while (!pmd->IsKindOf ( RUNTIME_CLASS (CMakComment))
				&&
			   !pmd->IsKindOf ( RUNTIME_CLASS (CMakEndOfFile)))
		{
			delete (pmd); pmd = NULL;
			pmd = (CMakDirective *) mr.GetNextElement ();
		}
		// Put the comment back:
		mr.UngetElement ( pmd );

		// valid CFG= if read, else use default
		if (m_strProjDefaultConfiguration.IsEmpty() ||
			(!ConfigRecordFromConfigName(m_strProjDefaultConfiguration)))
		{
			if (strDefaultConfig.IsEmpty())
				m_strProjDefaultConfiguration = strSupportedConfig;
			else
				m_strProjDefaultConfiguration = strDefaultConfig;
			VSASSERT(ConfigRecordFromConfigName(m_strProjDefaultConfiguration), "Failed to find config record for config name");
		}

		if (m_strProjStartupConfiguration.IsEmpty())
		{
			m_strProjStartupConfiguration = strSupportedConfig;
			// could still be empty; use m_strProjDefaultConfiguration if so
		}
	}
	CATCH (CException, e)
	{
		g_pActiveProject = (CProject *)this;
		strBase.Empty(); strCfg.Empty(); str.Empty(); strTarget.Empty();
		strDefaultConfig.Empty(); strSupportedConfig.Empty();
		mapTargTypes.RemoveAll();
		if (pmd) delete (pmd);
		return FALSE;
	}
	END_CATCH
	g_pActiveProject = (CProject *)this;
	mapTargTypes.RemoveAll();
	VSASSERT (bSetDefaultConfig, "Unable to set default config");
	VSASSERT (GetActiveConfig(), "No active config!");
	VSASSERT (!m_ConfigMap.IsEmpty(), "No configs!");
	VSASSERT (m_ConfigArray.GetSize(), "No configs!");
	VSASSERT (m_ConfigArray.GetSize()==m_ConfigMap.GetCount(), "Mismatch between config array and config map!");
	ASSERT_VALID (this);
	SetBuildToolsMap();

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
GPT CProject::GetIntProp(UINT idProp, int& val)
{
	// If this isn't a prop we're interested in, just
	// return what our parent does.
	if (idProp != P_NoDeferredBscmake &&
		idProp != P_DeferredMecr)
		return CProjContainer::GetIntProp(idProp, val);

	// See if this is in our prop bag.
	GPT gpt = CProjContainer::GetIntProp(idProp, val);

	if (GetCurrentPlatform()->GetUniqueId() == unsupported)
		gpt = invalid;		// don't understand this project type anymore

	// If the return value wasn't 'valid', the prop isn't
	// in the prop bag (only place it could be).  Return
	// 0 by default, meaning that BSCMAKEs are NOT deferred.
	if (gpt != valid)
		val = 0;

	return valid;
}
///////////////////////////////////////////////////////////////////////////////
GPT CProject::GetStrProp(UINT idProp, CString& val)
{
	if (idProp == P_ProjItemOrgPath || idProp == P_FakeProjItemOrgPath) {
		if (m_strRelPath.IsEmpty())
		{
			CPath pathProj, pathWks;
			CDir dirWks;
			dirWks.CreateFromCurrent();
			const CPath * pPath = GetFilePath();
			VSASSERT(pPath, "No project file path?!?");
			if (pPath)
			{
				pathProj = *pPath;
				pathProj.SetAlwaysRelative(TRUE);
				pathProj.GetRelativeName(dirWks, m_strRelPath);
			}
		}
		val = m_strRelPath;
		return valid;
	}
	else if (idProp == P_ProjSccProjName) {
		val = m_strProjSccProjName;
		return valid;
	}
	else if (idProp == P_ProjSccRelLocalPath) {
		val = m_strProjSccRelLocalPath;
		return valid;
	}
	else if (idProp == P_ProjItemFullPath)
	{
		const CPath * pPath = GetFilePath();

		if (pPath != NULL)
		{
			val = pPath->GetFullPath();
			return valid;
		}
		return invalid;
	}
	else if ((idProp==P_OutDirs_Intermediate) || (idProp==P_OutDirs_Target))
		{
			CString valDummy;
			return (GetOutDirString(valDummy, idProp, &val)) ? valid : invalid;
		}

	// At this point, we're only interested in a couple of props.  If
	// this isn't one of those, return what our base class does.
	if (idProp != P_Caller && 
		idProp != P_PromptForDlls &&
		idProp != P_WorkingDirectory &&
		idProp != P_Args && 
		idProp != P_RemoteTarget &&
        idProp != P_Proj_Targ &&
        idProp != P_ExtOpts_Targ
	   )
		return CProjContainer::GetStrProp(idProp, val);

	// See if this is in our prop bag.
	GPT gpt = CProjContainer::GetStrProp(idProp, val);

	// do we want to fake P_ExtOpts_Targ/P_Proj_Targ?
    if (gpt == invalid && (idProp == P_Proj_Targ || idProp == P_ExtOpts_Targ))
    {
        CPath TargetPath = *GetFilePath();
        TargetPath.ChangeExtension(_T(".exe"));
        val = TargetPath.GetFileName();
        return valid;
    }

	// do we want to fake P_Caller?
	//
	// * internal project *
	// -> shouldn't happen to * exe project *
	// This is expensive for them 'cos we hit the disk to
	// look at the executable in GetTargetAttributes().
	// I figure its more important to track the internal project
	// target (this can change more with output directories etc.)
	//
	// o pick the target name if .EXE
	if (gpt == invalid && idProp == P_Caller)
	{
		// HACK - by default, set this check box
		int nVal;
		CString strVal;
		GPT gpt = CProjContainer::GetIntProp(P_PromptForDlls, nVal);
		if (gpt == invalid) {
 			CProjContainer::SetIntProp(P_PromptForDlls, 1);
		}
		gpt = CProjContainer::GetIntProp(P_DebugAttach, nVal);
		if (gpt == invalid) {
			CProjContainer::SetIntProp(P_DebugAttach,0);
		}
		gpt = CProjContainer::GetIntProp(P_DebugRemote, nVal);
		if (gpt == invalid) {
			CProjContainer::SetIntProp(P_DebugRemote,0);
		}
		gpt = CProjContainer::GetStrProp(P_DebugRemoteHost, strVal);
		if (gpt == invalid) {
			CProjContainer::SetStrProp(P_DebugRemoteHost, "");
		}
		gpt = CProjContainer::GetIntProp(P_DebugNative, nVal);
		if (gpt == invalid) {
			CProjContainer::SetIntProp(P_DebugNative,0);
		}


		// let's see if we've got a valid default squirreled away in the dsp file...
		CString strDebugExe;
		if (CProjContainer::GetStrProp(P_ConfigDefaultDebugExe, strVal) == valid && !strVal.IsEmpty())
		{
			CProjContainer::SetStrProp(P_Caller, strVal);
			val = strVal;
			return valid;
		}

		// only use the target if we think it is an .EXE
		if (GetTargetAttributes() & ImageExe)
		{
			CPath path;	
			COptionHandler * popthdlr;

			g_pPrjcompmgr->LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker),
													 (CBldSysCmp *&)popthdlr);
			CString strOutput;
			GetStrProp(popthdlr->MapLogical(P_OutName), strOutput);
			if (!strOutput.IsEmpty())
			{
				path.CreateFromDirAndFilename(GetWorkspaceDir(), strOutput);
				val = path.GetFullPath();
				return valid;
			}
			
		}
	}

	// If the return value wasn't 'valid', the prop isn't
	// in the prop bag (only place it could be).  Return
	// an empty string by default.
	if (gpt != valid)
		val = "";

	return valid;
}


///////////////////////////////////////////////////////////////////////////////
BOOL CProject::SetStrProp(UINT idProp, const CString& val)
{
	// Cached property bag pointer
	CConfigurationRecord *pcr = NULL;

	// Property bag list
	switch( idProp )
	{
		case P_ProjActiveConfiguration:
		{
			// is this different to our current config.?
			if (m_strProjActiveConfiguration.CompareNoCase(val) != 0)
			{
				// do we have this configuration?
				if ((pcr = ConfigRecordFromConfigName(val)) == NULL)
				{
					// we must be initialising the project
					pcr = CreateConfigRecordForConfig(val);
 				}

				// set ourselves in this config. (update the view)
				SetActiveConfig(pcr, FALSE);
			}
		}
		break;

		case P_ProjSccProjName:
		{
			if (((m_strProjSccProjName.IsEmpty()) && (!val.IsEmpty()))
				|| ((!m_strProjSccProjName.IsEmpty()) && (val.IsEmpty())))
			{
			// these scc props are write once for sharability, but
			// this seems too severe.
			// can be changed to empty, perhaps a stepping stone to a real change.
				m_strProjSccProjName = val;
				DirtyProject();
			}
			return TRUE; //??
		}
		break;
		case P_ProjSccRelLocalPath:
		{
			if (((m_strProjSccRelLocalPath.IsEmpty()) && (!val.IsEmpty()))
				|| ((!m_strProjSccRelLocalPath.IsEmpty()) && (val.IsEmpty())))
			{
			// these scc props are write once for sharability, but
			// this seems too severe.
			// can be changed to empty, perhaps a stepping stone to a real change.
				m_strProjSccRelLocalPath = val;
				DirtyProject();
			}
			return TRUE; //??
		}
		break;
		// is the target file name changing?
		case P_ExtOpts_Targ:
		case P_Proj_Targ:
		{
			// Cannot set the property to an empty string, as we must fake it.
			CString temp = val;
			temp.TrimLeft();
			temp.TrimRight();
			if (temp.IsEmpty())
			{
				CPropBag * pBag = GetPropBag();
				VSASSERT(pBag != (CPropBag *)NULL, "No property bag!");

				pBag->RemoveProp(idProp);
				InformDependants(P_ProjItemFullPath);

				return TRUE;
			}

			InformDependants(P_ProjItemFullPath);
		}
		break;
		case P_Proj_CleanLine:
		case P_Proj_CmdLine:
		{
			int i=0;
			CString strNew;
			int len = val.GetLength();
			while( i < len ){
				if( val[i] == _T('\t') ){
					strNew += _T("\r\n");
				}
				else {
					strNew += val[i];
				}
				i++;
			}
			return CProjContainer::SetStrProp(idProp, strNew);
		}
		break;

	}

	// do the base-class (CProjContainer) thing
	return CProjContainer::SetStrProp(idProp, val);
}

CConfigurationRecord *CProject::CreateConfigRecordForConfig(
												const CString & strConfig)
{
	//	Create a configuration record for the supplied name:
	if (ConfigRecordFromConfigName (strConfig) != NULL) return NULL;

	CConfigurationRecord *pcr = new CConfigurationRecord (0, this);
	pcr->m_pBaseRecord = pcr;	// Record is base for itself.

	m_ConfigArray.Add(pcr);
	m_ConfigMap.SetAt ( pcr, pcr );

	// Set the new configuration as active:
	pcr->GetPropBag(CurrBag)->SetStrProp ( this, P_ProjConfiguration, (CString &) strConfig);
	return pcr;
}

BOOL CProject::DeleteConfig ( const CString& strName, const CString& strNewConfig)
{
//	Nuke this configuration.  Note that this is not undoable, so the caller
//  needs to flush the undo stack after doing this.  Also, we don't say
//	anything about subprojects.

	// Find the configuration record to delete?
	CConfigurationRecord * pcr;
	if ((pcr = ConfigRecordFromConfigName(strName)) == (CConfigurationRecord *)NULL)
		return FALSE;

	// killing the active configuration?
	BOOL fKillingActive = pcr == GetActiveConfig();

	// Perform the delete...
	DeleteConfigFromRecord(pcr);

	// Set the active configuration to something other than this deleted one
	if (!m_ConfigMap.IsEmpty())
	{
		VSASSERT(m_ConfigArray.GetSize(), "No configs!");
		VSASSERT(m_ConfigArray.GetSize() == m_ConfigMap.GetCount(), "Config map/array mismatch");

		// Switch if we killed current....
		if (fKillingActive)
		{
			// If not got one to set as the current, then use first
			if (strNewConfig.IsEmpty())
			{
				SetStrProp(P_ProjActiveConfiguration, ((CConfigurationRecord *)m_ConfigArray[0])->GetConfigurationName());
			}
			else
			{
				SetStrProp(P_ProjActiveConfiguration, strNewConfig);
			}
		}

		// Changed the configuration property
		InformDependants (P_ProjConfiguration);
	}

	return TRUE;
}

BOOL CProject::CreateConfig(const CString& strName)
{
	BOOL fOK = FALSE;

	// Create a config. and make it the active one.
	CConfigurationRecord * pcrNewConfig = CreateConfigRecordForConfig(strName);
	if (pcrNewConfig == NULL)
		return FALSE;

 	m_pActiveConfig = pcrNewConfig;

	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// IDE support functions:
int CProject::GetTargetAttributes()
{
    // BruceMa 11-05-98
    // There is a chance the debugger got a notification and is calling
    // in to get project attributes.  If the project is not complete yet
    // then just say we don't know
    if (!m_bProjectComplete)
    {
        return TargetUnknown;
    }

    
	// get the target attributes from the cache for the current config.
	CConfigurationRecord * pConfig = (CConfigurationRecord *)GetActiveConfig();
	VSASSERT(pConfig, "No active config!");
	return pConfig->GetTargetAttributes();
}

// the pMatchProject is the parent project or active config
// the this is the subproject or nonactive project
BOOL CProject::GetMatchingConfigName(CProject * pMatchProject, CString &strMatched, BOOL bInvalid)
{
	strMatched.Empty();

 	// Get a project pointer
	if (pMatchProject == (CProject *)ACTIVE_PROJECT )
		pMatchProject = g_pActiveProject;

	if(pMatchProject == NULL)
		return FALSE;
	
	// Get the name of the active config to match
	CString strMatchingDescription;
	CString strProjName;

	CConfigurationRecord * pcrMatch = pMatchProject->GetActiveConfig();
	if (pcrMatch==NULL) // can happen during project creation
		return FALSE;
	pcrMatch->GetConfigurationDescription(strMatchingDescription);

	// Get the fileset name
	CConfigurationRecord * pcr = GetActiveConfig();
	if(pcr == NULL)
		return FALSE;
	pcr->GetProjectName(strProjName);

	// Form the fileset name
	strMatched = strProjName + " - " + strMatchingDescription;

	// Lookup the fileset name in the target list
	if (!g_BldSysIFace.GetConfig(strMatched,NO_PROJECT))
	{
		// No configuration of the fileset that matches the current default project's
		// configuration, so we just pick a configuration that does exist for the fileset
		if (bInvalid)
		{
			CString strNoMatch;
			BOOL bOK = strNoMatch.LoadString(IDS_NO_MATCHING_CONFIG);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
 			strMatched = strProjName + _T(" - ") + strNoMatch;
			return FALSE;
		}
		else
		{
			INT_PTR nSize = m_ConfigArray.GetSize();
			// loop thru the configs to find a good match

			strMatched.Empty();
			int nLongest = 0;
			int nMatchLen = strMatchingDescription.GetLength();
			for (INT_PTR nConfig = 0; nConfig < nSize; nConfig++)
			{
				pcr = (CConfigurationRecord *)m_ConfigArray[nConfig];
				CString strDescription;
				pcr->GetConfigurationDescription( strDescription );

				int nMax = strDescription.GetLength();
				if( nMax > nMatchLen )
					nMax = nMatchLen;

				// how many characters match 
				int i=0;
				while( i < nMax && strDescription[i] == strMatchingDescription[i] ){
					i++;
				}

				//     if this is longer than the longest so far,
				//			this is our new longest
				if( (i > nLongest) || strMatched.IsEmpty() ){
					nLongest = i;
					strMatched = pcr->GetConfigurationName();
				}
			}
			return FALSE;
		}
	}
 
	return TRUE;
}

CPlatform * CProject::GetCurrentPlatform()
{
	return (CPlatform *)GetProjType()->GetPlatform();
}

BOOL CProject::CanContain(CSlob* pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)) ||
		pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)) )
		return TRUE;

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// SetActiveConfig()
///////////////////////////////////////////////////////////////////////////////
CConfigurationRecord * CProject::SetActiveConfig(CConfigurationRecord * pcr, BOOL /*fQuite*/)
{
	::EnterCriticalSection(&m_critSection);

	// make sure this is compatible with us, ie. a project-level config. rec.
	VSASSERT(pcr != (const CConfigurationRecord *)NULL, "NULL config record passed to SetActiveConfig!");
	VSASSERT(pcr->m_pBaseRecord == pcr, "Cannot set the active config to something we don't recognize");

	CConfigurationRecord * pcrOldActive = m_pActiveConfig;
	m_pActiveConfig = pcr;

	::LeaveCriticalSection(&m_critSection);
	return pcrOldActive;	// success, return old active configuration
}

CConfigurationRecord * CProject::SetActiveConfig(const CString& strConfigName, BOOL fQuite)
{
	CString strTarget = strConfigName;
	CConfigurationRecord * pcr = FindTargetConfig(strTarget);
	if (pcr != NULL)
		return SetActiveConfig(pcr, fQuite);	// success?

	VSASSERT (FALSE, "No config record to match config name!");
	return (CConfigurationRecord *)NULL;	// failure
}

///////////////////////////////////////////////////////////////////////////////
// FindTargetConfig() - Find the configuration matching the input string
//						and fix up the case to match the actual config name
///////////////////////////////////////////////////////////////////////////////
CConfigurationRecord * CProject::FindTargetConfig(CString & strTargetName)
{
	CConfigurationRecord * pcr;
	int i, cSize = GetPropBagCount();
	for (i = 0; i < cSize; i++)
	{
		pcr = (CConfigurationRecord *)m_ConfigArray[i];
		if (pcr->GetConfigurationName().CompareNoCase(strTargetName) == 0)
		{
			strTargetName = pcr->GetConfigurationName();
			return pcr;
		}
	}
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// CProjTempConfigChange - used to temporarily change config of the project
//	                       in a thread-safe manner.
///////////////////////////////////////////////////////////////////////////////

CProjTempConfigChange::CProjTempConfigChange(CProject *pProject)
{
	VSASSERT(pProject != NULL, "Cannot set active project to NULL!");
	::EnterCriticalSection(&pProject->m_critSection);
	m_bCritSection = TRUE;
	m_pProject = pProject;
	m_pcrOriginal = pProject->m_pActiveConfig;
}

CProjTempConfigChange::~CProjTempConfigChange( )
{
	Release();
}

// Release resets the original configuration and frees up the critical section
void CProjTempConfigChange::Release(BOOL bReset /* = TRUE*/)
{
	if (m_bCritSection)
	{
		if (bReset)
			Reset();

		m_bCritSection = FALSE;
		::LeaveCriticalSection(&m_pProject->m_critSection);
	}
}

// Reset just sets the config back to the original. We still hold the
// critical section though.
void CProjTempConfigChange::Reset()
{
	VSASSERT(m_bCritSection, "Cannot reset active project while not under critical section!");
	ChangeConfig(m_pcrOriginal);
}


void CProjTempConfigChange::ChangeConfig(CConfigurationRecord *pcr)
{
	VSASSERT(m_bCritSection, "Cannot change config while not under critical section!");
	m_pProject->SetActiveConfig(pcr);
}

void CProjTempConfigChange::ChangeConfig(const CString& strConfigName)
{
	VSASSERT(m_bCritSection, "Cannot change config while not under critical section!");
	m_pProject->SetActiveConfig(strConfigName);
}

///////////////////////////////////////////////////////////////////////////////
// CProjTempProjectChange - used to temporarily change the active project
///////////////////////////////////////////////////////////////////////////////

CProjTempProjectChange::CProjTempProjectChange (CProject *pProject)
{

	m_pPrevProject = g_pActiveProject;
	g_pActiveProject = pProject;
}

CProjTempProjectChange::~CProjTempProjectChange ()
{
	Release ();
}

// Release resets the original project
void CProjTempProjectChange::Release ()
{
	g_pActiveProject = m_pPrevProject;
	m_pPrevProject = NULL; // probably doesn't matter, but what the hell...
}

///////////////////////////////////////////////////////////////////////////////
// GetTarget()
///////////////////////////////////////////////////////////////////////////////
CTargetItem* CProject::GetTarget(const TCHAR * pchTargetName)
{
	// Find the target item corresponding to a target name
	CTargetItem* pTarget;
	CString strKey = pchTargetName;
	strKey.MakeUpper();		// Case insensitive lookup
	if (!m_TargetMap.Lookup(strKey, (void* &)pTarget))
		return NULL;
	else
		return pTarget;
}

///////////////////////////////////////////////////////////////////////////////
// GetActiveTarget()
///////////////////////////////////////////////////////////////////////////////
CTargetItem* CProject::GetActiveTarget()
{
	CConfigurationRecord * pcr = GetActiveConfig();
	if (pcr == NULL)
		return NULL;

	return GetTarget(pcr->GetConfigurationName());
}

///////////////////////////////////////////////////////////////////////////////
// RegisterTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::RegisterTarget(const CString& strTargetName, CTargetItem* pTarget)
{
	// Check we have a configuration that matches the target
	int i;
	CConfigurationRecord* pcr;
	BOOL bFoundConfig = FALSE;
	int size = GetPropBagCount();
	for (i=0; i < size; i++)
	{
		pcr = (CConfigurationRecord*) m_ConfigArray[i];
		VSASSERT(pcr, "Bad config record in config array!");
		if (pcr->GetConfigurationName().CompareNoCase(strTargetName) == 0)
			bFoundConfig = TRUE;
	}
	if (!bFoundConfig)
		return FALSE;

	// Check the target item node
	ASSERT_VALID(pTarget);
	
	// Add this target to the target map
	CString strKey = strTargetName;
	strKey.MakeUpper();		// Case insensitive lookup
	m_TargetMap.SetAt(strKey, pTarget);

	// Make sure that this target is known by the build system interface
	g_BldSysIFace.GetConfig(strTargetName, (HPROJECT)this);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// DeregisterTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::DeregisterTarget(const CString& strTargetName, CTargetItem* /*pTarget*/)
{
	// Remove the target from the target map
	CString strKey = strTargetName;
	strKey.MakeUpper();		// Case insensitive lookup
 	return m_TargetMap.RemoveKey(strKey);
}

///////////////////////////////////////////////////////////////////////////////
// CreateTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::CreateTarget(const CString& strTargetName, CProjType* pProjType, const CString& strMirrorFrom /* = _T("") */)
{
	// Create the configuration for this target
	BOOL bRetVal = CreateConfig(strTargetName);

	CTargetItem* pTarget;
	if (strMirrorFrom.IsEmpty())
	{
		// Create the target item node for this target and
		// move it into the project tree
		pTarget = new CTargetItem();
	}
	else
	{
		// Mirroring a target
		pTarget = GetTarget(strMirrorFrom);
	}

	VSASSERT(pTarget != NULL, "No target?!?");

	// make this the target's config. current
	CProjTempConfigChange projTempConfigChange(this);
	projTempConfigChange.ChangeConfig(strTargetName);	

	SetStrProp(P_ProjOriginalType, *pProjType->GetName());

	if (strMirrorFrom.IsEmpty())
	{
		// move this new target into the project
		// (this will un-assign the build actions)
		pTarget->MoveInto(this);
	}
	else
	{
		// already got the target in the project, no
		// need for a move
	}

	// make this config. valid
	CConfigurationRecord * pcrTarg = pTarget->GetActiveConfig(TRUE);	// create
	VSASSERT(pcrTarg != NULL, "No target for active config?!?");
	pcrTarg->SetValid(TRUE);

	// reset the project's config.
	projTempConfigChange.Release();

	return RegisterTarget(strTargetName, pTarget);
}

///////////////////////////////////////////////////////////////////////////////
// DeleteTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::DeleteTarget(const CString& strTargetName)
{
	// Delete a target, by first removing any references
	// to the target, and by removing the target item node
	// itself

	// If we only have 1 valid config for this target item
	// then we can remove the target item, otherwise not
	HCONFIGURATION hConfig = g_BldSysIFace.GetConfig(strTargetName, (HPROJECT)this);
	HCONFIGURATION hConfigNew = NO_CONFIG;
	int nTargets = 0;
	CTargetItem* pTarget = GetTarget(strTargetName);
	VSASSERT(pTarget != NULL, "No CTargetItem for specified target name");
	const CVCPtrArray* pConfigArray = pTarget->GetConfigArray();
	INT_PTR nSize = pConfigArray->GetSize();
	for (INT_PTR i = 0; i < nSize; i++)
	{
		CConfigurationRecord* pcr = (CConfigurationRecord*)pConfigArray->GetAt(i);
		if (pcr->IsValid())
		{
			nTargets++;
			if (hConfigNew == NO_CONFIG)
			{
				// remember the target other than to be delted one
				CString strConfigName = pcr->GetConfigurationName();
				hConfigNew = g_BldSysIFace.GetConfig(strConfigName, (HPROJECT)this);
				if (hConfigNew == hConfig)
					hConfigNew = NO_CONFIG;	
			}
		}
	} 
	
	// make this the target's config. current
	CProjTempConfigChange projTempConfigChange(this);
	CConfigurationRecord * pcrOld = GetActiveConfig();

	projTempConfigChange.ChangeConfig(strTargetName);
	CConfigurationRecord * pcrProj = GetActiveConfig();

	if (nTargets == 1)
	{
		// Remove any dependencies on this fileset
		CProject * pProject;
		POSITION pos1 = m_lstProjects.GetHeadPosition();  // use our own private pos pointer
		while (pos1 != NULL)
		{
			pProject = (CProject *)m_lstProjects.GetNext(pos1);
			if ((pProject == NULL) || (!pProject->IsLoaded()))
			{
				continue ;
			}

			// Search the project tree for any nodes to delete
			CObList ol;
			int fo = CProjItem::flt_OnlyTargRefs;
			pProject->FlattenSubtree(ol, fo);

			POSITION pos = ol.GetHeadPosition();
			while (pos != NULL)
			{
				CProjectDependency * pProjDep = (CProjectDependency *)ol.GetNext(pos);
				
				// Is this a dependency on the fileset we are deleting if so then remove
				// the dependency
				if (pProjDep->GetProjectDep() == pTarget)
					pProjDep->MoveInto(NULL);
			}
		}
 
		// move this old target out of the project
		// (this will un-assign the build actions)
		pTarget->MoveInto(NULL);
	}
	else
	{
		// un-assign the build actions for this mirored target
		CBuildAction::UnAssignActions(pTarget, (CVCPtrList *)NULL, pcrProj);
	}

	// Reset only if pcrOld is not NULL, it might have been deleted already.
	projTempConfigChange.Release(pcrOld != (const CConfigurationRecord *)NULL);

	BOOL bRetVal = DeregisterTarget(strTargetName, pTarget);

	// If the delete operation succeeded then save the target
	// so other packages can be notified.
	HCONFIGURATION hSaveTarget;
	if (m_bProjectComplete)
		hSaveTarget = g_BldSysIFace.GetConfig(strTargetName, (HPROJECT)this);

	// Delete the configuration associated with this target
	bRetVal = bRetVal && DeleteConfig(strTargetName, "");

	// If we have deleted the default config then set the default config
	// to be a different one
	if (!m_strProjDefaultConfiguration.CompareNoCase(strTargetName))
	{
		CString strActiveProject;
		GetStrProp(P_ProjActiveConfiguration, strActiveProject);
		m_strProjDefaultConfiguration = strActiveProject;
	}

	return bRetVal;
}

void CProject::DirtyProjectEx()
{
	VSASSERT(!m_bProjectDirty, "Can only call DirtyProjectEx if project not already dirty");
	m_bOkToDirty = TRUE;
	m_bProjectDirty = TRUE;
}

CDir & CProject::GetProjDir(CConfigurationRecord * pcr)
{
    if (pcr == NULL)
        pcr = GetActiveConfig();

    // Make sure we are dealing with a base config record
    pcr = (CConfigurationRecord *)pcr->m_pBaseRecord;

	CTargetItem * pTarget = GetTarget(pcr->GetConfigurationName());
	if (pTarget != (CTargetItem *)NULL)
	{
		const TCHAR * pchTargDir = (const TCHAR *)pTarget->GetTargDir();
		if (*pchTargDir != _T('\0'))
		{
			m_ActiveTargDir.CreateFromString(pchTargDir);
			return m_ActiveTargDir;
		}
	}

	m_ActiveTargDir = m_ProjDir;

	// it is reset by specific target, init in SetFile w/ m_ProjDir
	return m_ActiveTargDir;  
}

BOOL CProject::IsCustomBuildMacroComment(CObject* pObject)
{
	// the object must be a comment
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment))) {
		return FALSE;
	}
	CMakComment* pMakComment = (CMakComment *)pObject;

	// get the comment text and remove leading white space
	TCHAR* pc = pMakComment->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// look for the 'Begin Custom Macros' prefix
	CString strBeginMacros;
	BOOL bOK = strBeginMacros.LoadString(IDS_MAK_CUSTOM_BEGIN);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	if (_tcsnicmp(strBeginMacros, pc, strBeginMacros.GetLength()) == 0) {
		return TRUE;
	}
	return FALSE;
}

BOOL CProject::ReadCustomBuildMacros(CMakFileReader& mr)
{
	// we can just ignore these macros because they're only
	// written out to satisfy nmake

	// read until we hit a comment (should be 'End Custom Macros')
	for (CObject* pObject = mr.GetNextElement();
		!pObject->IsKindOf(RUNTIME_CLASS(CMakComment));
		pObject = mr.GetNextElement()) {
		delete pObject;
	}

	// verify the ending comment is 'End Custom Macros'
	CMakComment* pMakComment = (CMakComment *)pObject;

	// get the comment text and remove leading white space
	TCHAR* pc = pMakComment->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// look for the 'End Custom Macros' prefix
	BOOL bResult = FALSE;
	CString strEndMacros;
	BOOL bOK = strEndMacros.LoadString(IDS_MAK_CUSTOM_END);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	if (_tcsnicmp(strEndMacros, pc, strEndMacros.GetLength()) == 0) {
		bResult = TRUE;
	}

	delete pObject;
	return bResult;
}

POSITION CProject::m_posProjects = NULL;
CObList CProject::m_lstProjects;

void CProject::InitProjectEnum()
{
	m_posProjects = m_lstProjects.GetHeadPosition();
}

const CProject * CProject::NextProjectEnum(CString & strProject, BOOL bOnlyLoaded /* = TRUE */)
{
	// FUTURE: handle bOnlyLoaded flag

	// serious hack
	BOOL bNoName = FALSE;
	if (strProject.Compare(_T("<no name>"))==0)
		bNoName = TRUE;
	else
		strProject.Empty();

	const CProject * pProject;
	while (m_posProjects!=NULL)
	{
		pProject = (const CProject *)m_lstProjects.GetNext(m_posProjects);
		if ((pProject != NULL) && (!bOnlyLoaded || pProject->IsLoaded()))
		{
			if (!bNoName) // hack: fails during destruction
			{
				// pProject->GetStrProp(P_ProjItemName, strProject);
				strProject = ((CProject *)pProject)->GetTargetName();
			}

			return pProject;
		}
	}
	
	return (const CProject *)NULL;
}

const CString & CProject::GetTargetName() { return m_strTargetName; }

//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\schmztl.h ===
//
//	SCHMZTL.H
//
//		Definition of classes for tracking buidld tools.

#ifndef _SCHMZTL_H_
#define _SCHMZTL_H_

class  CSchmoozeTool : public CBuildTool
{
	DECLARE_DYNAMIC (CSchmoozeTool)

public:
	CSchmoozeTool()
	{
		m_strName = _TEXT("schmooze.exe");
	}
	~CSchmoozeTool() {}
};

#endif // _SCHMZTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vcprojcnvt.rc
//
#include "..\ui_dll\resdll\resource.h"

#define IDR_VCPROJCONVERT               103

#define IDS_TEMPLATE_FILES_FILTER       1580
#define IDS_GROUP_CUSTOMIZER            1445
#define IDS_GROUP_CUSTOMIZER_KEY        1446
#define IDS_SOURCE_FILES_FILTER         1566
#define IDS_NO_MATCHING_CONFIG          1421

#define IDS_WIN64MERCED_PLATFORM        1784
#define IDS_WIN64MERCED_PLATFORM_SHORT  1785
#define IDS_WIN32ALPHAEXE_CPLR_DBG      15753
#define IDS_WIN32ALPHA_MTL_COMMON       15754
#define IDS_WIN32ALPHAEXE_CPLR_REL      15755
#define IDS_WIN32ALPHADLL_CPLR_DBG      15756
#define IDS_WIN32ALPHADLL_CPLR_REL      15757
#define IDS_WIN32ALPHACON_CPLR_DBG      15758
#define IDS_WIN32ALPHACON_CPLR_REL      15759
#define IDS_WIN32ALPHALIB_CPLR_DBG      15760
#define IDS_WIN32ALPHALIB_CPLR_REL      15761
#define IDS_WIN32_LINK_ALPHA_COMMON     15763
#define IDS_WIN32ALPHA_PLATFORM         15766
#define IDS_WIN32ALPHA_PLATFORM_SHORT   15767
#define IDS_WIN32EXE_PROJTYPE           15801
#define IDS_WIN32DLL_PROJTYPE           15802
#define IDS_WIN32CON_PROJTYPE           15803
#define IDS_WIN32LIB_PROJTYPE           15804
#define IDS_WIN32X86_PLATFORM           15814
#define IDS_WIN32EXE_CPLR_DBG           15817
#define IDS_WIN32EXE_CPLR_REL           15818
#define IDS_WIN32DLL_CPLR_DBG           15819
#define IDS_WIN32DLL_CPLR_REL           15820
#define IDS_WIN32CON_CPLR_DBG           15821
#define IDS_WIN32CON_CPLR_REL           15822
#define IDS_WIN32LIB_CPLR_DBG           15823
#define IDS_WIN32LIB_CPLR_REL           15824
#define IDS_WIN32_MTL_COMMON            15825
#define IDS_WIN32_MTL_DBG               15826
#define IDS_WIN32_MTL_REL               15827
#define IDS_WIN32_PLATFORM              15828
#define IDS_WIN32X86_PLATFORM_SHORT     15829
#define IDS_WIN32CON_LINK               15830
#define IDS_WIN32DLL_LINK               15831
#define IDS_WIN32LIB_LINK               15832
#define IDS_WIN32EXE_LINK               15833
#define IDS_WIN32_CPLR_COMMON           15863
#define IDS_WIN32_CPLR_DBG              15864
#define IDS_WIN32_CPLR_REL              15865
#define IDS_WIN32_LINK_X86_COMMON       15866
#define IDS_WIN32_RC_COMMON             15867
#define IDS_WIN32_RC_DBG                15868
#define IDS_WIN32_RC_REL                15869
#define IDS_WIN32_LINK_DBG              15870
#define IDS_WIN32_LINK_REL              15871
#define IDS_WIN32_BSCMAKE_DBG           15872
#define IDS_WIN32_BSCMAKE_REL           15873
#define IDS_WIN32_BSCMAKE_COMMON        15874
#define IDS_WIN64MERCEDEXE_CPLR_DBG     15897
#define IDS_WIN64MERCED_MTL_COMMON      15898
#define IDS_WIN64MERCEDEXE_CPLR_REL     15899
#define IDS_WIN64MERCEDDLL_CPLR_DBG     15900
#define IDS_WIN64MERCEDDLL_CPLR_REL     15901
#define IDS_WIN64MERCEDCON_CPLR_DBG     15902
#define IDS_WIN64MERCEDCON_CPLR_REL     15903
#define IDS_WIN64MERCEDLIB_CPLR_DBG     15904
#define IDS_WIN64MERCEDLIB_CPLR_REL     15905
#define IDS_WIN32_LINK_MERCED_COMMON    15907
#define IDS_MAKEFILE_SIG_STRING         16026
#define IDS_OLD_MAKEFILE_SIG_STRING     16064
#define IDS_REG_TOOLINPUT               16097
#define IDS_EXTTARG_PROJTYPE            16202
#define IDS_GENERIC_PROJTYPE            16203
#define IDS_WIN32_LIBS                  16209
#define IDS_OLE2_LIBS                   16210
#define IDS_ODBC_LIBS                   16214
#define IDS_WIN32_LIBS_CORE             16215
#define IDS_REG_TOOLPREFIX              16216
#define IDS_V2_WIN32X86_PLATFORM        16240
#define IDS_V2_MAC68K_PLATFORM          16241
#define IDS_V2_WIN32_PLATFORM           16242
#define IDS_V2_MACPPC_PLATFORM          16243
#define IDS_MAK_CUSTOM_BEGIN            16251
#define IDS_MAK_CUSTOM_END              16252
#define IDS_EXPORT_SIG_STRING           16253
#define IDS_BUILDPRJ_SIG_STRING         16254
#define IDS_V2_WIN3280X86_PLATFORM      16288
#define IDS_V4_MACPMC_PLATFORM          16295
#define IDS_V4_POWERMAC_PLATFORM        16299
#define IDS_V4_MIPS_PLATFORM            16296
#define IDS_V4_PPC_PLATFORM             16297
#define IDS_XBOX_PLATFORM               16300
#define IDS_XBOX_PLATFORM_SHORT         16301
#define IDS_XBOXEXE_PROJTYPE            16302
#define IDS_XBOXLIB_PROJTYPE            16303
#define IDS_DEBUG_CONFIG                20001
#define IDS_RELEASE_CONFIG              20002
#define IDS_DSPROJ_SIG_STRING           20035

#ifndef _APS_NEXT_RESOURCE_VALUE
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\projtool.h ===
//
//	PROJTOOL.H
//
//		Definition of classes for tracking buidld tools.

#ifndef _PROJTOOL_H_
#define _PROJTOOL_H_

//#include "bldapi.h"

// Note: NMAKE /A currently doesn't properly handle multiple targets on the
// LHS of a dependency/build rule (eg. A B C : deps).  Remove this if fixed.
//#define _NMAKE_LHS_BUG 1

#include "projitem.h"
#include "prjoptn.h"
#include "engine.h"

class CBuildTool;

class CNameMunger;

// Helper functions used by tools (in PROJTOOL.CPP):
BOOL  FileNameMatchesExtension(const CPath *pPath, const TCHAR *pExtensions);

#if 0
BOOL ReplaceEnvVars(CString &string);
#endif

///////////////////////////////////////////////////////////////////////////////
//
//	Build tool classes:
//
//	We divide build tools into two types: "Source Tools" which take a single 
//	input and produce intermediate files as output (e.g. C compiler)  and 
//  "Schmooze tools" which take several intermediate files and produce a 
//  the final targets.

class  CBuildTool : public CBldSysCmp, public COptHdlrMapper
{
	DECLARE_DYNCREATE(CBuildTool)
	DECLARE_SLOBPROP_MAP()
	DECLARE_REGISTRY_MAP()

public:
	CBuildTool();
	virtual ~CBuildTool();

	// Init.
	void FInit();

	// default tool options for the tool for the target type component, 'bsc_id', or
	// for any target type with attributes
	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption);

	//
	// \/ Build system engine interface API 
	//

	// Interaction with per-action 'tool-supplied' data and build system
	// events
	virtual void AddAction(CBuildAction* pAction);
	virtual void RemoveAction(CBuildAction* pAction);

protected:
	CVCMapPtrToPtr m_BuildActions;

public:
	// Does this tool operate on this file?
	virtual BOOL AttachToFile(const CPath* pPath, CProjItem * pItem);

	virtual CString GetToolName(){return m_strName;}

	virtual CString GetDefaultExtList(CString *strExt)
	{
		*strExt = m_strToolInput;
		return m_strToolInput;
	}

	CString m_strToolPrefix;	// our nmake macro prefix
	CString m_strToolInput;		// our input spec.
	CString m_strName;			// our too name

	// Is this target a oriented tool?
	BOOL m_fTargetTool;

	//
	// /\ Build system engine interface API 
	//

	virtual BOOL ProcessAddSubtractString
	( 
		CProjItem * pItem,
		const TCHAR * pstr,
		BOOL fSubtract,
		BOOL fBaseBag = FALSE
	);

	// Ensure that the tool will build an the project item (debug or release config. mode)
	// Likely to entail doing such things as munging tool options, eg. the libs for linker
	// FUTURE: Use wizards to do this in v4.0?
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC) {return FALSE;}

	// builder file reading
	//
	// function called to read a tool builder macro line
	// ie. one of the form '<tool prefix>_FOOBAR = '
	// return FALSE if an error occurred, this will abort builder reading
	virtual BOOL ReadToolMacro(CMakMacro * pMacro, CProjItem * pItem) {return TRUE; /* ok */}
};

extern UINT g_nIDToolUnknown;

// 
// Custom build tool (derived from the generic CBuildTool)
//

extern const TCHAR g_pcBeginCustomBuild[];
extern const TCHAR g_pcEndCustomBuild[];

typedef struct tagMACROINFO {
	CString strName;
	CString strValue;
} MACROINFO;

class CCustomBuildTool : public CBuildTool
{
	DECLARE_DYNAMIC(CCustomBuildTool)

public:
	CCustomBuildTool();
	virtual ~CCustomBuildTool();

	// -> from CBuildTool
	BOOL AttachToFile(const CPath* pPath, CProjItem * pItem);

	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption) { return TRUE; } // nothing interesting to do for custom build
	// <- from CBuildTool

	// read our custom build step from the builder file
	static BOOL DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude);

	// get and set custom build properties
	enum eStrPropTypes 
	{ 
		eStrPropNone,		// strProp not found at all
		eStrPropEmpty,		// strProp present, but empty
		eStrPropHasValue	// strProp present and non-empty
	};
	static BOOL SetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str);
	static BOOL GetCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str, BOOL fDefault = TRUE);
	static BOOL ConvertCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString & str, BOOL fDefault = TRUE);
	static eStrPropTypes HasCustomBuildStrProp(CProjItem * pItem, UINT idProp, CString * pstrProp = NULL, BOOL fDefault = TRUE);
};

// 
// Unknown tools (derived from the generic CBuildTool)
//
class CUnknownTool : public CBuildTool
{
	DECLARE_DYNAMIC(CUnknownTool)

public:

	CUnknownTool() {};
	CUnknownTool(const TCHAR * lpszPlatform, const TCHAR * lpszPrefix, const TCHAR * lpszExeName = NULL);
	virtual ~CUnknownTool();

	// from -> CBldSysCmp
	BOOL IsSupported() const { return FALSE; }
	// <- CBldSysCmp

	// -> from CBuildTool
 	BOOL AttachToFile(const CPath* pPath, CProjItem * pItem);
	// <- from CBuildTool

	__inline UINT GetUnknownPropId() const {return m_nIDUnkStr;}

	// builder file reading
	//
	// function called to read a tool builder macro line
	// ie. one of the form '<tool prefix>_FOOBAR = '
	// for the unknown tool we'll preserve these...
	BOOL ReadToolMacro(CMakMacro * pMacro, CProjItem * pItem);

private:
	CString m_strBuffer;
	UINT m_nIDUnkStr;
};


// 
// Special build tool (derived from the generic CBuildTool)
//

extern const TCHAR g_pcBeginSpecialBuildTool[];
extern const TCHAR g_pcEndSpecialBuildTool[];

class CSpecialBuildTool : public CBuildTool
{
	DECLARE_DYNAMIC(CSpecialBuildTool)

public:
	CSpecialBuildTool();
	virtual ~CSpecialBuildTool();

	// Similar to custom build tool.
	BOOL AttachToFile(const CPath* pPath, CProjItem * pItem);

	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption) { return TRUE; } // nothing interesting to do for special build
	// <- from CBuildTool

	// read our custom build step from the builder file
	static BOOL DoReadBuildRule(CProjItem * pItem, TCHAR * pchCustomPrelude, BOOL bAllConfigs = FALSE);
};


///////////////////////////////////////////////////////////////////////////////
#endif // _PROJTOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\targitem.h ===
//
//	CTargetItem
//
//	This is a projitem that represents a target, that is something
//	which is buildable, e.g. an exe, dll, or lib.
//
//	[colint]
//				   

#ifndef _TARGETITEM_H										
#define _TARGETITEM_H
#include "projitem.h"

///////////////////////////////////////////////////////////////////////////////
class CTargetItem : public CProjContainer 
{
//
//	Represents a target. It is the same as a CProjContainer
//	except that conceptually it can have operations applied
//	to it that are normally only applied to the CProject,
//	e.g. build.
//
	DECLARE_SERIAL (CTargetItem)

protected:

public:
	CTargetItem ();
	virtual ~CTargetItem ();

	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString &str);
	virtual BOOL SetStrProp(UINT idProp,  const CString &str);

	// allowing/disallowing global registry access to this target registry
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// .MAK reading
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);

	virtual BOOL CanContain(CSlob* pSlob);
	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);
	
	__inline const CString& GetTargDir() { return m_strTargDir; }
	__inline void SetTargDir(CString &strTargDir) { m_strTargDir = strTargDir; }
	__inline const CString & GetTargetName() { return m_strTargetName; }
	__inline void SetTargetName(const CString & str) { m_strTargetName = str; }

public:
	// Makefile reading/writing support
	static const TCHAR *pcNamePrefix;

	BOOL IsNameComment(CObject*& pObject);

	// Properties
	CString m_strTargetName;
	CString m_strTargDir;                   // save per target directory

	DECLARE_SLOBPROP_MAP()
};

#endif // _TARGETITEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\vcprojcnvt.cpp ===
// vcprojcnvt.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f vcprojcnvtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "vcprojcnvt2.h"
#include "VCProjConvert.h"
#include "project.h"
#include "register.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_VCProjConvert, CVCProjConvert)
END_OBJECT_MAP()

class CVcprojcnvtApp : public CWinApp
{
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVcprojcnvtApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

};

CVcprojcnvtApp theApp;

void __cdecl dummyDumper(void * pvData, size_t nBytes)
{
}
									


BOOL CVcprojcnvtApp::InitInstance()
{
	if (FAILED(_Module.Init(ObjectMap, m_hInstance, &LIBID_VCPROJCNVTLib)))
        return FALSE;
	_CrtSetDumpClient(dummyDumper);

	return TRUE;
}

int CVcprojcnvtApp::ExitInstance()
{
	if (g_pPrjcompmgr)
	{
		g_pPrjcompmgr->Term();
		delete g_pPrjcompmgr;
		g_pPrjcompmgr = NULL;
	}

	if (g_pPrjoptengine)
	{
		delete g_pPrjoptengine;
		g_pPrjoptengine = NULL;
	}

	g_pActiveProject = NULL;
	g_nIDOptHdlrUnknown = 0;
	//	g_prjoptengine
	_CrtSetDumpClient(dummyDumper);
	_CrtSetReportMode(0,0);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
extern "C"
STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.DllGetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// VSDllRegisterServer - Adds entries to the system registry

static LPOLESTR g_wszAlternateRegistryRoot = NULL;

_ATL_REGMAP_ENTRY g_rm[] = {
	{L"REGROOTBEGIN",NULL },
	{L"REGROOTEND", NULL },
	{0,0}
};

STDAPI VSDllRegisterServer(LPOLESTR wszAlternateRegistryRoot)
{
	if( wszAlternateRegistryRoot == NULL ) // Dovii NoProvii
		wszAlternateRegistryRoot = L"Software\\Microsoft\\VisualStudio\\7.0";

    // registers object, typelib and all interfaces in typelib
	g_wszAlternateRegistryRoot = wszAlternateRegistryRoot;

	CComBSTR bstrRootBegin;
	CComBSTR bstrRootEnd;
	HRESULT hr = GetRegRootStrings( g_wszAlternateRegistryRoot, &bstrRootBegin, &bstrRootEnd );
	g_rm[0].szData = bstrRootBegin.m_str;
	g_rm[1].szData = bstrRootEnd.m_str;
    hr = _Module.DllRegisterServer();
	g_wszAlternateRegistryRoot = NULL;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
	HRESULT hr= VSDllRegisterServer(L"Software\\Microsoft\\VisualStudio\\7.0");
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// VSDllUnregisterServer - Removes entries from the system registry

STDAPI VSDllUnregisterServer(LPOLESTR wszAlternateRegistryRoot)
{
	if( wszAlternateRegistryRoot == NULL ) // Dovii NoProvii
		wszAlternateRegistryRoot = L"Software\\Microsoft\\VisualStudio\\7.0";

    // registers object, typelib and all interfaces in typelib
	g_wszAlternateRegistryRoot = wszAlternateRegistryRoot;

	CComBSTR bstrRootBegin;
	CComBSTR bstrRootEnd;
	HRESULT hr = GetRegRootStrings( g_wszAlternateRegistryRoot, &bstrRootBegin, &bstrRootEnd );
	g_rm[0].szData = bstrRootBegin.m_str;
	g_rm[1].szData = bstrRootEnd.m_str;
    hr = _Module.DllUnregisterServer();
	g_wszAlternateRegistryRoot = NULL;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
	HRESULT hr= VSDllUnregisterServer(L"Software\\Microsoft\\VisualStudio\\7.0");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\VCProjConvert.h ===
// VCProjConvert.h : Declaration of the CVCProjConvert

#ifndef __VCPROJCONVERT_H_
#define __VCPROJCONVERT_H_

#include "resource.h"       // main symbols
#include "bldpack.h"

extern _ATL_REGMAP_ENTRY g_rm[];

/////////////////////////////////////////////////////////////////////////////
// CVCProjConvert
class ATL_NO_VTABLE CVCProjConvert : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVCProjConvert, &CLSID_VCProjConvert>,
	public CPackage,
	public IVCProjConvert
{
public:
	CVCProjConvert()
	{
		m_bInit = false;
	}
	~CVCProjConvert();

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {
		return _Module.UpdateRegistryFromResource( IDR_VCPROJCONVERT, bRegister, g_rm );
	}

BEGIN_COM_MAP(CVCProjConvert)
	COM_INTERFACE_ENTRY(IVCProjConvert)
END_COM_MAP()

// IVCProjConvert
public:
	STDMETHOD(Initialize)(BSTR bstrSourceFilesString);
	STDMETHOD(GetPackage)(long **pPackage);
	STDMETHOD(OpenProject)(BSTR bstrProjectPath, IUnknown *pProjEngine, IUnknown *pUnkSP);
	STDMETHOD(GetProject)(IDispatch **ppDisp);
	STDMETHOD(get_HasProjectDependencies)( VARIANT_BOOL *pbHasDeps );
	STDMETHOD(get_ProjectDependenciesCount)( long *plNumDeps );
	STDMETHOD(GetNextProjectDependency)( BSTR* pbstrProject, BSTR* pbstrDependentProject );
	STDMETHOD(ResetProjectDependencyEnum)();

// CPackage
	BOOL DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id);
protected:
	bool m_bInit;
	CComPtr<VCProject> m_pProject;
	// map of project dependencies
	CVCMapStringToString m_Dependencies;
	VCPOSITION m_DependencyEnumPos;

public:
	static CString s_strSourceFilesString;	// the one, the only, UI string this DLL needs...

protected:
	void AddFolders(VCProject *pProject, CSlob *pSlob);
	void AddSubFolders(VCFilter *pFilter, CSlob *pSlob);
	void AddFolderForFile(VCProject *pProject, CSlob *pSlob, VCFile *pFile, VCFilter **ppFilter = NULL);
	COptStr * GetOptStrForTool(LPCTSTR szTool,  COptionHandler * &popthdlr, long& lItem);
	void SetToolSettings(CProjItem *pFileItem, CProject* pProject, LPCTSTR szTool, VCFileConfiguration *pFileConfig, VCConfiguration *pConfig);
	void SetLinkerDefSettings(CProjItem *pFileItem, VCFileConfiguration *pFileConfig);
	void SetToolObject(VCFileConfiguration *pFileConfig, LPCTSTR szTool, IVCToolImpl **ppTool);
	void SetToolObject(VCConfiguration *pConfig, LPCTSTR szTool, IVCToolImpl **ppTool);
	void SetToolSetting(IVCToolImpl *pTool,  IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase);
	bool GetConfigName(CString& strTargetName, CString& strConfigName, BOOL bFileConfig = FALSE );
	bool SplitOutV2ConfigName(UINT idPlatform, CString& strTargetName, CString& strConfigName, BOOL bFileConfig = FALSE);
	BOOL IsToolMatch(IVCToolImpl *pTool, LPCTSTR szTool, bool bLinkerAllowed);
	BOOL SetCLToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase);
	BOOL SetLNKToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase);
	BOOL SetLIBToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler);
	BOOL SetMIDLToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandle, bool bIsBaser);
	BOOL SetRCToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase);
	BOOL SetBSCToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer, CComVariant& varVal, 
		COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler);
	BOOL AddCustomBuildEventItem(CProjItem *pItem, VCConfiguration *pFileConfiguration);
	BOOL AddCustomBuildItem(CProjItem *pItem, VCCustomBuildTool* pCustomBuildTool, VCFileConfiguration *pFileConfig, VCConfiguration *pConfig);
	HRESULT CreateEmptyProject(CProject* pProject, int num_project, BSTR bstrProjectPath, IUnknown* pUnkSP, 
		VCProjectEngine* pProjEngine, VCProject** ppNewProject);
	void AddRelevantPlatforms(CProject* pProject, CStringList& lststrPlatforms, VCProject* pNewProject);
	bool IsUnsupportedProject(CProject* pProject);
	void SetConfigurationType(CProjType* pProjType, VCConfiguration* pConfig);
	void AddNewConfiguration(CString& strTargetName, CString& strConfigName, VCProject* pNewProject, BOOL bCheckForExisting,
		VCConfiguration** ppNewConfig);
	void GetConfig(CString& strTargetName, CString& strConfigName, IVCCollection* pConfigs, VCConfiguration** ppNewConfig);
	void CreatePlatformsList(CStringList& lststrPlatforms);
	void DoMakefileProjectProperties( CProject* pProject, VCProject* pNewProject, VCConfiguration *pConfig );
	void DoGenericAndSpecialCaseProperties(CProject* pProject, VCConfiguration* pConfig);
	void HandleEvent(CProject* pProject, VCConfiguration* pConfig, UINT idCmd, UINT idDesc, 
		CString& strEventName);
	void DoStyleSheetFixups(VCProject* pNewProject, VCConfiguration* pConfig);
	void DoSharedFileDelete(VCConfiguration* pConfig);
	bool RemoveSymbols(IVCPropertyContainer* pPropContainer, long idProp, BSTR bstrSeparatorList, BSTR bstrSymbols);
	void ClearBoolProperty(IVCPropertyContainer* pPropContainer, long idProp, VARIANT_BOOL bDefault);
	void ClearIntProperty(IVCPropertyContainer* pPropContainer, long idProp, long nDefault);
	int	 FindFirstSeparator(CStringW& strList, CStringW& strSeparatorList, int nStartIdx);
	int	 GetNextItem(CStringW& strList, int nStartIdx, int nMaxIdx, CStringW& strSeparator, CStringW& strItem);
	int	 GetNextQuotedItem(CStringW& strList, int nStartIdx, int nMaxIdx, int nSep, int nLastQuote,
		BOOL bOddQuote, CStringW& strSeparator, CStringW& strItem);
	bool RemoveItem(CStringW& strList, CStringW& strItem, CStringW& strSeparatorList);
	int	 FindItem(CStringW& rstrItems, CStringW& rstrFindItem, CStringW& strSeparator, int nStart);
	void RemoveMultiples(CStringW& strList, CStringW& strSeparatorList);
	void HandleFileProperties(CProject* pProject, VCProject* pNewProject);
	HRESULT GetNamedProjectConfiguration(CString& strTarget, VCProject* pNewProject, 
		VCConfiguration** ppNewConfig);
	HRESULT GetNamedFileConfiguration(CString& strTarget, VCFile* pFile, VCFileConfiguration** ppNewFileConfig);
	HRESULT DoATLProjectConversionHack(VCProject* pNewProject, bool bHasRelease, bool bHasReleaseMinSize);
	BOOL DoSpecialLinkerProps(IVCToolImpl* pTool, IVCPropertyContainer* pPropContainer, COptionHandler* pOptHandler, 
		CProjItem* pFileItem);
	BOOL DoSpecialMidlProps(IVCToolImpl* pTool, COptionHandler* pOptHandler, CProjItem* pFileItem);
	BOOL DoSpecialUnknownStringProps(IVCToolImpl* pTool, IVCPropertyContainer* pPropContainer, COptionHandler* pOptHandler, 
		CProjItem* pFileItem);
	BOOL DoUnknownStringProp(IVCPropertyContainer* pPropContainer, COptionHandler* pOptHandler, CProjItem* pFileItem, 
		long nOptionID);
	void DoUnknownStringPropHelper(CProjItem* pProjItem, UINT nIDUnknown, IVCPropertyContainer* pPropContainer, 
		long nOptionID);
	void GetUnknownToken(CString& rstrString, CString& rstrOpt, int& rnIdx);
	void CleanupDirSpec(CString& strDir);

	BOOL PropertyIsDifferent(CComBSTR& bstrOld, CComBSTR& bstrNew, BOOL bBlankOK = FALSE);
	BOOL PropertyIsDifferent(CComBSTR& bstrOld, BSTR bstrNew, BOOL bBlankOK = FALSE);
	VARIANT_BOOL ConvertToBoolValue(long lVal);
	BOOL EnumIsTrue(long lVal);
	void AddExtraOption(IVCPropertyContainer* pPropContainer, long propID, long lVal, BSTR bstrOption);
	void AddAdditionalOptions(IVCPropertyContainer* pPropContainer, long propID, BSTR bstrOption);
	void SetBoolProperty(IVCPropertyContainer* pPropContainer, long propID, long lVal, BOOL bFlipIt = FALSE);
	void SetStrProperty(IVCPropertyContainer* pPropContainer, long propID, BSTR bstrNewVal, BOOL bBlankOK = FALSE);
	void SetMultiStrProperty(IVCPropertyContainer* pPropContainer, long propID, BSTR bstrNewVal, bool bIsBase);
	void SetEnumProperty(IVCPropertyContainer* pPropContainer, long propID, long nNewValue);
	void SetIntProperty(IVCPropertyContainer* pPropContainer, long propID, long nNewValue, BOOL bZeroOK = FALSE);

	void SetPtrToMember1(IVCPropertyContainer* pPropContainer, long lVal);
	void SetPtrToMember2(IVCPropertyContainer* pPropContainer, long lVal);
	void SetDebugInfo(VCCLCompilerTool* pCompiler, long lVal);
	void SetOptimization(VCCLCompilerTool* pCompiler, long lVal);
	void SetOptimizeX(VCCLCompilerTool* pCompiler, long lVal);
	void SetCodeGenFavor(VCCLCompilerTool* pCompiler, UINT idOption, long lVal);
	void SetStringPooling(VCCLCompilerTool* pCompiler, long lVal);
	void SetAsmOptions(VCCLCompilerTool* pCompiler, CProjItem* pProjItem, COptionHandler* pOptHandler, long lVal);
	void SetListBsc(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, 
		COptionHandler* pOptHandler, UINT idOption, long lVal);
	void SetAutoPCH(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer,
		COptionHandler* pOptHandler, CProjItem* pProjItem, long lVal);
	void SetCreatePCH(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer, 
		COptionHandler* pOptHandler, CProjItem* pProjItem, long lVal);
	void SetUsePCH(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer, 
		COptionHandler* pOptHandler, CProjItem* pProjItem, long lVal);
	void SetStackCheck(IVCPropertyContainer* pPropContainer, long lVal);
	void SetPreprocess1(VCCLCompilerTool* pCompiler, UINT idOption, long lVal);
	void SetPreprocess2(VCCLCompilerTool* pCompiler, CProjItem* pProjItem, long lVal);
	void SetTreatFileAs(VCCLCompilerTool* pCompiler, UINT idOption, long lVal);
	void SetProcOptimize(VCCLCompilerTool* pCompiler, long lVal);
	void SetCallConvention(VCCLCompilerTool* pCompiler, long lVal);
	void SetRuntimeChecks(VCCLCompilerTool* pCompiler, long lVal, basicRuntimeCheckOption newOpt);
	void SetByteAlign(VCCLCompilerTool* pCompiler, long lVal);
	void SetRuntimeLib(VCCLCompilerTool* pCompiler, long lVal);
	void SetOldEH(VCCLCompilerTool* pCompiler, long lVal);
	void SetLinkShowProgress(VCLinkerTool* pLinker, long lVal);
	void SetUsePDB(IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, COptionHandler* pOptHandler, 
		long lVal);
	void SetMapGen(IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, COptionHandler* pOptHandler, 
		long lVal);
	void SetLinkerSubSystem(IVCPropertyContainer* pPropContainer, long lVal);
	void SetLinkerLargeAddressAwareness(IVCPropertyContainer* pPropContainer, long lVal);
	void SetLinkerVersion(IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, 
		COptionHandler* pOptHandler, long lVal);
	void SetLinkerDriver(IVCPropertyContainer* pPropContainer, long lVal);
	void SetLinkerAlign(IVCPropertyContainer* pPropContainer, long lVal);
	void SetLinkerFixed(IVCPropertyContainer* pPropContainer, long lVal);
	void SetLinkIncremental(VCLinkerTool* pLinkTool, BOOL bSetIt);
	void SetMidlOutput(IVCPropertyContainer* pPropContainer, long lPropID, BSTR bstrVal);
	void SetMidlStublessProxy(IVCPropertyContainer* pPropContainer, long lVal);
	void SetMidlChar(IVCPropertyContainer* pPropContainer, long lVal);
	void SetMidlClient(IVCPropertyContainer* pPropContainer, long lVal);
	void SetMidlServer(IVCPropertyContainer* pPropContainer, long lVal);
};

#endif //__VCPROJCONVERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D43DAED5_3FCF_11D3_8D52_00C04F8ECDB6__INCLUDED_)
#define AFX_STDAFX_H__D43DAED5_3FCF_11D3_8D52_00C04F8ECDB6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxdisp.h>

#include "resource.h"
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <afxole.h> // mfc's ole stuff

#include <vcpb2.h> // for new build project stuff
#include <VCProjectPrivateTypelib.h>

#include "vsassert.h"

#include <vccoll.h>
#include <vccolls.h>
#include <path.h> // vc\ide\include\path.h
#include <slob.h>

// this has to be included here because projprop.h #defines one of the member
// names and hoses us if we include it afterwards
#include "dte.h"

#include "projbld2.h"
#include "projprop.h"
#include "util.h"
#include "prjconfg.h"
#include "bldiface.h"

// type of dependency
#define DEP_UserDefined	0x7		// Never scanned or modified except by user.

extern "C" {
#include "limits.h"
};
				    
#include "resource.h"
#include "projtool.h"
#include "intelx86.h"

extern CComModule _Module;

// transport layer information flags
#define TFL_NIL		0x0000			// Nil value
#define TFL_LOCAL	0x0001			// Local TL (else remote)
#define TFL_CFGABLE	0x0002			// Configurable (else not)

#define CHECK_POINTER_NULL(pObj) \
	if ((pObj) == NULL) \
		return E_POINTER;

#define RETURN_ON_FAIL_OR_NULL(hr, pObj) \
	if (FAILED(hr)) \
		return hr; \
	else if ((pObj) == NULL) \
		return E_FAIL;

#define RETURN_ON_FAIL_OR_NULL2(hr1, pObj, hr2) \
	if (FAILED(hr1)) \
		return hr2; \
	else if ((pObj) == NULL) \
		return hr2;

#define RETURN_ON_FAIL(hr) \
	if (FAILED(hr)) \
		return hr;

#define RETURN_INVALID_ON_NULL(pObj) \
	if ((pObj) == NULL) \
	{ \
		/* VSASSERT(FALSE, "Returning E_INVALIDARG!"); */ \
		return E_INVALIDARG; \
	}

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D43DAED5_3FCF_11D3_8D52_00C04F8ECDB6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\VCProjConvert.cpp ===
// VCProjConvert.cpp : Implementation of CVCProjConvert
#include "stdafx.h"
#include "Vcprojcnvt2.h"
#include "VCProjConvert.h"
#include "optnbsc.h"
#include "optncplr.h"
#include "optnlib.h"
#include "optnmtl.h"
#include "optnrc.h"
#include "targitem.h"
#include "x86optn.h"
#include "mcdoptn.h"
#include "axpoptn.h"
#include <prjids.h>
#include "project.h"
#include "projdep.h"
#include <initguid.h>
#include <vcguid.h>
#include <vccolls.h>

CString CVCProjConvert::s_strSourceFilesString;	// the one, the only, UI string this DLL needs...

// forward declaration
BOOL ConvertMacros(CString& rstrVal);

/////////////////////////////////////////////////////////////////////////////
// CVCProjConvert
BOOL CVCProjConvert::DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id)
{
	static int nOffset = 0;
	VSASSERT(pcompmgr, "No component manager!");
	if (!pcompmgr)
		return E_POINTER;

	// what is the hook?
	switch (blc_type)
	{
		case BLC_Tool:
			// only for platform 0 (generic platform)
			if (blc_id != 0)	break;

			// our 'generic' tools
			pcompmgr->RegisterBldSysComp(new CRCCompilerTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_RcCompiler));
			pcompmgr->RegisterBldSysComp(new CRCCompilerNTTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_RcCompilerNT));
			pcompmgr->RegisterBldSysComp(new CMkTypLibTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_MkTypLib));
			pcompmgr->RegisterBldSysComp(new CLibTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_Lib));
			pcompmgr->RegisterBldSysComp(new CBscmakeTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_BscMake));
			pcompmgr->RegisterBldSysComp(new CCCompilerTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_Compiler));
			pcompmgr->RegisterBldSysComp(new CLinkerTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_Linker));
			pcompmgr->RegisterBldSysComp(new CLinkerNTTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_LinkerNT));
			pcompmgr->RegisterBldSysComp(new CCustomBuildTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild));
			pcompmgr->RegisterBldSysComp(new CSpecialBuildTool, GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild));
			break;

		case BLC_OptionHdlr:
			// only for platform 0 (generic platform)
			if (blc_id != 0)	break;

			// our 'generic' option handlers
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(CompilerCommon));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(LinkerCommon));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(LinkerNT));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(ResCompiler));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(ResCompilerNT));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(BscMake));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(Lib));
			pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(MkTypLib));
			break;

		case BLC_TargetType:
			// do this for all registered platforms
			if (blc_id == 0)	break;

			nOffset++;
 			break;
		default:
			break;
	}

	// nothing left to register
	return FALSE;
}

STDMETHODIMP CVCProjConvert::GetPackage(long **ppPackage)
{
	CHECK_POINTER_NULL(ppPackage);
	*ppPackage = reinterpret_cast<long *>(static_cast<CPackage *>(this)); // not an interface; don't want to change devtools.dll
	return S_OK;
}

STDMETHODIMP CVCProjConvert::Initialize(BSTR bstrSourceFilesString)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = E_FAIL;
	if (g_pPrjoptengine && g_pPrjcompmgr)
		m_bInit = true; // assume have been init'd in a former "life"
	if (!m_bInit)
	{
		s_strSourceFilesString = bstrSourceFilesString;
		VSASSERT(g_pPrjcompmgr == NULL, "Component manager already initialized!");
		VSASSERT(g_pPrjoptengine == NULL, "Option engine already initialized!");
		g_pPrjoptengine = new COptionTable;
		g_pPrjcompmgr = new CProjComponentMgr;
		if (g_pPrjcompmgr && g_pPrjoptengine)
		{
			hr = g_pPrjcompmgr->FInit(static_cast<IVCProjConvert *>(this));
			if (SUCCEEDED(hr))
				m_bInit = true;
		}
	}
	return hr;
}

CVCProjConvert::~CVCProjConvert()
{
	g_BldSysIFace.CloseProject(ACTIVE_PROJECT, WorkspaceClose);
}

STDMETHODIMP CVCProjConvert::OpenProject(BSTR bstrProjectPath, IUnknown *pProjEngineUnk, IUnknown *pUnkSP )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	CComQIPtr<VCProjectEngine> pProjEngine = pProjEngineUnk;
	RETURN_INVALID_ON_NULL(pProjEngineUnk);

	if (g_pPrjcompmgr == NULL)
		return E_NOINTERFACE; // not the best error return code, but it means roughly that we haven't been initialized well.

	if (g_pPrjoptengine == NULL)
		return E_NOINTERFACE; // see last comment

	CProject * pOldProject = g_pActiveProject;
	CProject * pProject;
	CDir dirOld; 
	dirOld.CreateFromCurrent();
	try 
	{
		// Create the project object
		pProject = new CProject;
		g_pActiveProject = pProject;
		CString pchProjPath = bstrProjectPath;

		CPath path;

		if (!pchProjPath.IsEmpty() && path.Create(pchProjPath))
		{
			// set the current directory to match the pathname 
			if( !_tcsicmp( path.GetExtension(), ".mdp") ) {
				path.ChangeExtension(".mak");
				pchProjPath = (const TCHAR *)path;
			}

			CDir currentDir; currentDir.CreateFromPath(path);
			currentDir.MakeCurrent();
		}

		// create new one or create and open from storage?
		// open an existing document 
		if (!pProject->InitFromFile (pchProjPath, FALSE))
 			goto CreationError;

		// if this was a 2.0 project, reject it
		if( pProject->m_bConvertedVC20 )
			return VCPROJ_E_UNSUPPORTED_PROJ_FILE;

		// return a pointer to this newly created project

		// NOT SO FAST... now we have to take this project and create a NEW one in the real place...
		// walk the list of projects, since 4.x project files could've caused more than one project
		// to be loaded
		int num_project = 1;
		int num_unsupported_projects = 0;
		POSITION proj_pos = CProject::m_lstProjects.GetHeadPosition();
		while( proj_pos )
		{
			// get next project
			pProject = static_cast<CProject*>(CProject::m_lstProjects.GetNext( proj_pos ));

			// skip if this is a project type we don't support anymore
			if( IsUnsupportedProject( pProject ) )
			{
				num_unsupported_projects++;
				continue;
			}

			CComQIPtr<VCProject> pNewProject;

			HRESULT hr = CreateEmptyProject(pProject, num_project, bstrProjectPath, pUnkSP, pProjEngine, 
				&pNewProject);
			RETURN_ON_FAIL(hr);

			if (pNewProject)
			{
				// set member project pointer (only for the first project)
				if( num_project == 1 )
					m_pProject = pNewProject;

				// Source Code Control strings
				pNewProject->put_SccProjectName( CComBSTR( pProject->m_strProjSccProjName ) );
				pNewProject->put_SccLocalPath( CComBSTR( pProject->m_strProjSccRelLocalPath ) );

				// create a list of old (no longer valid) platforms
				CStringList lststrPlatforms;
				CreatePlatformsList(lststrPlatforms);

				// add the platforms
				AddRelevantPlatforms(pProject, lststrPlatforms, pNewProject);

				// get configs
				bool bHasRelease = false;
				bool bHasReleaseMinSize = false;

				pProject->InitTargetEnum();
				CString strTargetName;
				CTargetItem *pTarget;
				while (pProject->NextTargetEnum(strTargetName, pTarget))
				{
					CString strTarg = strTargetName;
					strTarg.MakeLower();

					// iterate through the list of invalid platforms, comparing this target
					// name to them
					bool bInvalidTarget = false;
					POSITION pos = lststrPlatforms.GetHeadPosition();
					while( pos != NULL && !bInvalidTarget)
					{
						CString strPlatformName = lststrPlatforms.GetNext( pos );
						if( _tcsstr( (LPCTSTR)strTarg, (LPCTSTR)strPlatformName ) )
							bInvalidTarget = true;	// if we found it, ignore this config (target)
					}
					if( bInvalidTarget )
						continue;
					
					// we made it here, this must be a target for a valid 7.0 platform...

					CString strConfigName;
					if (!GetConfigName(strTargetName, strConfigName))
						return E_FAIL;

					// is this config "Release"?
					if( _tcsicmp( strConfigName, "Release" ) == 0 )
						bHasRelease = true;
					// is this config "Release MinSize"?
					else if( _tcsicmp( strConfigName, "Release MinSize" ) == 0 )
						bHasReleaseMinSize = true;

					CComQIPtr<VCConfiguration> pConfig;
					AddNewConfiguration(strTargetName, strConfigName, pNewProject, num_project != 1, &pConfig);

					if (pConfig)
					{
						CConfigurationRecord* pcr;
						pcr = pProject->ConfigRecordFromConfigName(strTargetName);
						pProject->ForceConfigActive(pcr);

						CProjType * pProjType;
						g_pPrjcompmgr->LookupProjTypeByName(pProject->GetActiveConfig()->GetOriginalTypeName(), pProjType);
						if( pProjType )
						{
							SetConfigurationType(pProjType, pConfig);

							DoGenericAndSpecialCaseProperties(pProject, pConfig);

							if (pProjType->GetUniqueTypeId() != CProjType::generic)
							{
								// Now do the rest of the tools
								const CVCPtrList * pol = pProjType->GetToolsList ();
								for (VCPOSITION pos = pol->GetHeadPosition(); pos != NULL;)
								{
									CBuildTool * pSrcTool = (CBuildTool *)pol->GetNext (pos);
									CString strToolName;
									strToolName = pSrcTool->GetToolName();
									if (!strToolName.IsEmpty())
										SetToolSettings(pProject, pProject, strToolName, NULL, pConfig);
								}
								DoStyleSheetFixups(pNewProject, pConfig);
								DoSharedFileDelete(pConfig);
							}
							ConfigurationTypes cfgType;
							pConfig->get_ConfigurationType( &cfgType );
							if( cfgType == typeUnknown || cfgType == typeGeneric )
							{
								DoMakefileProjectProperties( pProject, pNewProject, pConfig );
							}
						}
						pProject->ForceConfigActive();
					}
				}
				// get files
				HandleFileProperties(pProject, pNewProject);

				hr = DoATLProjectConversionHack(pNewProject, bHasRelease, bHasReleaseMinSize);
				RETURN_ON_FAIL(hr);

				// get all folders (just in case we missed some
				AddFolders(pNewProject, pProject);
			}
			if (num_project > 1)	// we have to do the assigns here; only the first project will get them handled properly
			{
				CComQIPtr<IVCBuildableItem> spBldableProject = pNewProject;
				if (spBldableProject)
					spBldableProject->AssignActions(VARIANT_TRUE);
				CComQIPtr<IVCProjectImpl> spProjectImpl = pNewProject;
				if (spProjectImpl)
					spProjectImpl->put_IsConverted(VARIANT_TRUE);
			}

			num_project++;
		}
		// if there were unsupported projects, put up an error message
		// if there are no valid projects, we have failed
		if( num_project == 0 )
		{
			throw "No valid projects!";
		}

		// if we had an unsupported project
		if( num_project == 1 && num_unsupported_projects > 0 )
		{
			CComQIPtr<IVCProjectEngineImpl> pProjEngineImpl = pProjEngine;
			if( pProjEngineImpl )
				pProjEngineImpl->DoFireReportError( CComBSTR( L"This project type is not supported" ), E_FAIL, L"VC.ProjectConversionProblems" );
			throw "unsupported project type";
		}
		// if we had one or more unsupported projects in a multiple project 4.x
		// project file
		else if( num_project > 1 && num_unsupported_projects > 0 )
		{
			CComQIPtr<IVCProjectEngineImpl> pProjEngineImpl = pProjEngine;
			if( pProjEngineImpl )
				pProjEngineImpl->DoFireReportError( CComBSTR( L"This project contains sub-projects whose type is not supported" ), E_FAIL, L"VC.ProjectConversionProblems" );
		}

		// if we have more than one project, check for project dependencies
		else if( num_project > 1 )
		{
			VCPOSITION pos = g_lstprojdeps.GetHeadPosition();
			while( pos != NULL )
			{
				// get the dependency info
				CProjDepInfo* pProjDep = (CProjDepInfo*)g_lstprojdeps.GetNext( pos );
				CString strProject = pProjDep->strProject;
				CString strTarget = pProjDep->strTarget;

				// add it to our dependency map
				m_Dependencies.SetAt( strProject, strTarget );
			}
		}

		// clean up!!!
		g_pActiveProject = pOldProject;

		// Delete the project object
		pProject->Destroy();
		delete pProject;
		CProject::m_lstProjects.RemoveAll();
		
		return S_OK;
	}
	catch (...)
	{
		goto CreationError;
	}

CreationError:

	g_pActiveProject = pOldProject;

	// Delete the project object
	pProject->Destroy();
	delete pProject;
	CProject::m_lstProjects.RemoveAll();

	g_pActiveProject = pOldProject;
 
	// set back the current directory since it fails to open
	dirOld.MakeCurrent();

	return VCPROJ_E_BAD_PROJ_FILE;
}

STDMETHODIMP CVCProjConvert::GetProject( IDispatch **ppDisp )
{
	CHECK_POINTER_NULL( ppDisp );
	CComQIPtr<IDispatch> pDisp = m_pProject;
	*ppDisp = pDisp.Detach();
	return S_OK;
}

STDMETHODIMP CVCProjConvert::get_HasProjectDependencies( VARIANT_BOOL *pbHasDeps )
{
	if( m_Dependencies.IsEmpty() )
		*pbHasDeps = VARIANT_FALSE;
	else
		*pbHasDeps = VARIANT_TRUE;

	return S_OK;
}

STDMETHODIMP CVCProjConvert::get_ProjectDependenciesCount( long *plNumDeps )
{
	*plNumDeps = (long)m_Dependencies.GetCount();
	return S_OK;
}

STDMETHODIMP CVCProjConvert::GetNextProjectDependency( BSTR* pbstrProject, BSTR* pbstrDependentProject )
{
	CVCString strProject, strDepProject;
	m_Dependencies.GetNextAssoc( m_DependencyEnumPos, strProject, strDepProject );
	*pbstrProject = strProject.AllocSysString();
	*pbstrDependentProject = strDepProject.AllocSysString();
	return S_OK;
}

STDMETHODIMP CVCProjConvert::ResetProjectDependencyEnum()
{
	m_DependencyEnumPos = m_Dependencies.GetStartPosition();
	return S_OK;
}


HRESULT CVCProjConvert::CreateEmptyProject(CProject* pProject, int num_project, BSTR bstrProjectPath,
	IUnknown* pUnkSP, VCProjectEngine* pProjEngine, VCProject** ppNewProject)
{
	CHECK_POINTER_NULL(ppNewProject);
	HRESULT hr = S_OK;
	CComPtr<IDispatch> pDisp;
	CProjType *pProjType = pProject->GetProjType(); 
	CComQIPtr<VCProject> spNewProj;

	// synthesize the full project path and name
	CStringW strName = bstrProjectPath;
	int pos = strName.ReverseFind( L'.' ) + 1;
	strName.Delete( pos, strName.GetLength() - pos );
	strName += L"vcproj";

	// if this is not the first project
	if( (num_project > 1)  && pUnkSP )
	{
		// get the project path & name
		CString strProjPath;
		CString strProjName;
		strProjPath= (const TCHAR*)(pProject->GetWorkspaceDir());
		pProject->GetName( strProjName );

		// get the dte object
		CComQIPtr<IServiceProvider> pServiceProvider = pUnkSP;
		if( !pServiceProvider )
			return E_NOINTERFACE;
		CComQIPtr<_DTE> pDTE;
		hr = pServiceProvider->QueryService(SID_SDTE, IID__DTE, (void **)&pDTE);
		RETURN_ON_FAIL_OR_NULL(hr, pDTE);
		// get the solution object
		CComPtr<IDispatch> pDispSolution;
		hr = pDTE->get_Solution( (Solution**)&pDispSolution );
		CComQIPtr<_Solution> pSolution = pDispSolution;
		RETURN_ON_FAIL_OR_NULL2(hr, pSolution, E_NOINTERFACE);
		// add the project from the wizards' template
		CComPtr<IDispatch> pDispProject;

		// get the path to the template file
		CComPtr<IVsShell> pVsShell;
		HRESULT hr = pServiceProvider->QueryService(SID_SVsShell, IID_IVsShell, (void**)&pVsShell);
		RETURN_ON_FAIL_OR_NULL(hr, pVsShell);
		CComVariant varVirtualRegistryRoot;
		hr = pVsShell->GetProperty( VSSPROPID_VirtualRegistryRoot, &varVirtualRegistryRoot );
		RETURN_ON_FAIL(hr);
		CString strVCKey( varVirtualRegistryRoot.bstrVal );
		strVCKey += "\\Setup\\VC";
		CRegKey key;
		if( key.Open( HKEY_LOCAL_MACHINE, strVCKey, KEY_READ ) != ERROR_SUCCESS )
			return E_FAIL;
		TCHAR szValue[2048];
		DWORD dwCount = 2048;
		// DEPRECATED LONG lRes = key.QueryValue( szValue, _T("ProductDir"), &dwCount );
		LONG lRes = key.QueryStringValue( _T("ProductDir"), szValue, &dwCount );
		key.Close();
		if( lRes != ERROR_SUCCESS )
			return E_FAIL;
		CComBSTR bstrVal = szValue;
		bstrVal += "\\VCWizards\\default.vcproj";

		// Create the project from template
		pSolution->AddFromTemplate( bstrVal, CComBSTR( strProjPath ), CComBSTR( strProjName ), VARIANT_FALSE, (Project**)&pDispProject );
		CComQIPtr<_Project> pProj = pDispProject;
		if( !pProj )
			return E_NOINTERFACE;

		// get the vc project
		pDispProject = NULL;
		pProj->get_Object( &pDispProject );
		spNewProj = pDispProject;

 		// give it the correct name
 		spNewProj->put_Name( CComBSTR( strProjName ) );
		CComQIPtr<IVCBuildableItem> spBldableProj = spNewProj;
		if (spBldableProj)	// actions got assigned during AddFromTemplate, but they don't make sense there
			spBldableProj->UnAssignActions(VARIANT_FALSE);
	}
	else
	{
		CString strProjName;
		pProject->GetName( strProjName );
		hr = pProjEngine->CreateProject( CComBSTR( strProjName ), &pDisp );
		spNewProj = pDisp;
  		spNewProj->put_ProjectFile( CComBSTR( strName ) );
	}

	*ppNewProject = spNewProj.Detach();
	return hr;
}

void CVCProjConvert::AddRelevantPlatforms(CProject* pProject, CStringList& lststrPlatforms, 
	VCProject* pNewProject)
{
	// get platforms
	CString strTargetName;
	CTargetItem *pTarget;
	pProject->InitTargetEnum();
	while (pProject->NextTargetEnum(strTargetName, pTarget))
	{
		CComBSTR bstrPlatform;
		// strTargetName is in form : "<projectname> - <platform-name> <configuration>"
		int i, j;
		i = strTargetName.Find(_T(" - "));
		if (i > 0)
		{
			j = strTargetName.Find(_T(" "), i+3);
			if (j > 0)
			{
				bstrPlatform = strTargetName.Mid(i + 3, j - i - 3);
				CString strTarg = bstrPlatform;
				strTarg.MakeLower();

				// iterate through the list of invalid platforms, comparing this target
				// name to them
				bool bInvalidTarget = false;
				if (strTarg != _T("win32"))	// most likely correct case is win32, so check it first
				{
					POSITION pos = lststrPlatforms.GetHeadPosition();
					while( pos != NULL && !bInvalidTarget)
					{
						CString strPlatformName = lststrPlatforms.GetNext( pos );
						if( _tcsstr( (LPCTSTR)strTarg, (LPCTSTR)strPlatformName ) )
						{
							// if we found it, ignore this config (target)
							bInvalidTarget = true;
							break;
						}
					}
				}
				if( bInvalidTarget )
					continue;

				HRESULT hr = pNewProject->AddPlatform(bstrPlatform);
				VSASSERT(SUCCEEDED(hr), "Failed to add a platform to the project!");
			}
		}
	}
}

bool CVCProjConvert::IsUnsupportedProject(CProject* pProject)
{
	CString strTargetName;
	CTargetItem *pTarget;

	// get the first target and check it's platform
	pProject->InitTargetEnum();
	pProject->NextTargetEnum(strTargetName, pTarget);
	CComBSTR bstrPlatform;
	// strTargetName is in form : "<projectname> - <platform-name> <configuration>"
	int i, j;
	i = strTargetName.Find(_T(" - "));
	if (i > 0)
	{
		j = strTargetName.Find(_T(" "), i+3);
		if (j > 0)
		{
			bstrPlatform = strTargetName.Mid(i + 3, j - i - 3);
			CString strTarg = bstrPlatform;
			strTarg.MakeLower();

			if (strTarg.GetLength() != 4)
				return false;

			int nCRC = (int)strTarg[0] + (int)strTarg[1] + (int)strTarg[2] + (int)strTarg[3];
			if (nCRC == 418 && strTarg[0] == _T('j'))
				return true;
		}
	}
	return false;
}
void CVCProjConvert::SetConfigurationType(CProjType* pProjType, VCConfiguration* pConfig)
{
	ConfigurationTypes configType = typeUnknown;
	switch (pProjType->GetUniqueTypeId())
	{
	case CProjType::application:
	case CProjType::consoleapp:
		configType = typeApplication;
		break;
	case CProjType::dynamiclib:
	case CProjType::sharedlib:
		configType = typeDynamicLibrary;
		break;
	case CProjType::staticlib:
		configType = typeStaticLibrary;
		break;
	case CProjType::generic:
		configType = typeGeneric;
		break;
	default:
	// case CProjType::exttarget:
	// case CProjType::quickwin:
	// case CProjType::unknown_projtype:
	// case CProjType::standardgraphics:
		configType = typeUnknown;
		break;
	}

	pConfig->put_ConfigurationType(configType);
}

void CVCProjConvert::GetConfig(CString& strTargetName, CString& strConfigName, IVCCollection* pConfigs, 
	VCConfiguration** ppNewConfig)
{
	*ppNewConfig = NULL;
	if (pConfigs)
	{
		GetConfigName(strTargetName, strConfigName, TRUE);
		CComBSTR bstrProjConfig = strConfigName;
		CComPtr<IDispatch> pDispConfig;
		pConfigs->Item(CComVariant(bstrProjConfig), &pDispConfig);
		CComQIPtr<VCConfiguration> pConfig = pDispConfig;
		*ppNewConfig = pConfig.Detach();
	}
}

void CVCProjConvert::AddNewConfiguration(CString& strTargetName, CString& strConfigName, 
	VCProject* pNewProject, BOOL bCheckForExisting, VCConfiguration** ppNewConfig)
{
	CComPtr<IDispatch> pDispConfigs;
	pNewProject->get_Configurations(&pDispConfigs);
	CComQIPtr<IVCCollection> pConfigs = pDispConfigs;
	if (bCheckForExisting)
	{
		GetConfig(strTargetName, strConfigName, pConfigs, ppNewConfig);
		if (*ppNewConfig)
			return;
	}
	
	CComBSTR bstrConfig = strConfigName;
	HRESULT hr = pNewProject->AddConfiguration(bstrConfig);
	VSASSERT(SUCCEEDED(hr), "Failed to add a configuration to the project!");
	GetConfig(strTargetName, strConfigName, pConfigs, ppNewConfig);
}

void CVCProjConvert::CreatePlatformsList(CStringList& lststrPlatforms)
{
	CString strPlatformName;
	BOOL bOK = strPlatformName.LoadString(IDS_V4_POWERMAC_PLATFORM);
	VSASSERT(bOK, "Failed to load string from string table!  Are resources initialized properly?");
	strPlatformName.MakeLower();
	lststrPlatforms.AddTail(strPlatformName);
	bOK = strPlatformName.LoadString(IDS_V4_MIPS_PLATFORM);
	VSASSERT(bOK, "Failed to load string from string table!  Are resources initialized properly?");
	strPlatformName.MakeLower();
	lststrPlatforms.AddTail(strPlatformName);
	bOK = strPlatformName.LoadString(IDS_V2_MAC68K_PLATFORM);
	VSASSERT(bOK, "Failed to load string from string table!  Are resources initialized properly?");
	strPlatformName.MakeLower();
	lststrPlatforms.AddTail(strPlatformName);
	bOK = strPlatformName.LoadString(IDS_V2_MACPPC_PLATFORM);
	VSASSERT(bOK, "Failed to load string from string table!  Are resources initialized properly?");
	strPlatformName.MakeLower();
	lststrPlatforms.AddTail(strPlatformName);
	bOK = strPlatformName.LoadString(IDS_V4_PPC_PLATFORM);
	VSASSERT(bOK, "Failed to load string from string table!  Are resources initialized properly?");
	strPlatformName.MakeLower();
	lststrPlatforms.AddTail(strPlatformName);
}


void CVCProjConvert::DoMakefileProjectProperties( CProject* pProject, VCProject* pNewProject, VCConfiguration *pConfig )
{
	// get the makefile project props
	CString strCmdLine, strRebuildOpt, strOutput, strBsc;
	pProject->GetStrProp( P_Proj_CmdLine, strCmdLine );
	pProject->GetStrProp( P_Proj_RebuildOpt, strRebuildOpt);
	pProject->GetStrProp( P_Proj_Targ, strOutput );
	pProject->GetStrProp( P_Proj_BscName, strBsc );

	// synthesize the clean command line
	CString strRebuildCmdLine = strCmdLine + " " + strRebuildOpt;

	// set the props in the new config's NMake tool
	CComPtr<IDispatch> pDispTools;
	CComQIPtr<IVCCollection> pTools;
	pConfig->get_Tools( &pDispTools );
	pTools = pDispTools;
	// only one tool in a makefile config (and this is a one-based collection)
	CComPtr<IDispatch> pDispTool;
	pTools->Item( CComVariant( 1 ), &pDispTool );
	CComQIPtr<VCNMakeTool> pNMakeTool = pDispTool;
	if( pNMakeTool )
	{
		if (!strCmdLine.IsEmpty())
			pNMakeTool->put_BuildCommandLine( CComBSTR( strCmdLine ) );
		if (!strRebuildCmdLine.IsEmpty())
			pNMakeTool->put_ReBuildCommandLine( CComBSTR( strRebuildCmdLine ) );
		if (!strOutput.IsEmpty())
			pNMakeTool->put_Output( CComBSTR( strOutput ) );
	}

	pNewProject->put_Keyword(L"MakeFileProj");
	if (pNewProject && !strBsc.IsEmpty())
	{
		// Since we're in project load, we cannot use the standard methods for determining whether it is OK to
		// add the file.  Instead, we have to go index into the file collection ourselves.  Sigh.
		CComBSTR bstrBsc = strBsc;
		CComPtr<IDispatch> spDispFiles;
		if (FAILED(pNewProject->get_Files(&spDispFiles)))
			return;
		CComQIPtr<IVCCollection> spFiles = spDispFiles;
		if (spFiles == NULL)
			return;

		CComPtr<IDispatch> spDispFile;
		spFiles->Item(CComVariant(bstrBsc), &spDispFile);
		if (spDispFile != NULL)
			return;		// already there

		pNewProject->AddFile(bstrBsc, &spDispFile);	// wasn't there, so add it
	}
}

void CVCProjConvert::DoGenericAndSpecialCaseProperties(CProject* pProject, VCConfiguration* pConfig)
{
	// do generic config properties...
	CString strOutDirs;
	pProject->GetConvertedStrProp(P_OutDirs_Target, strOutDirs);
	pConfig->put_OutputDirectory(CComBSTR(strOutDirs));
	pProject->GetConvertedStrProp(P_OutDirs_Intermediate, strOutDirs);
	pConfig->put_IntermediateDirectory(CComBSTR(strOutDirs));

	// set the config's use of MFC
	int iUseMFC;
	if (pProject->GetIntProp(P_ProjUseMFC, iUseMFC) == valid)
	{
		useOfMfc useMfc = useMfcStdWin;
		switch (iUseMFC)
		{
		case NoUseMFC:
			useMfc = useMfcStdWin;
			break;
		case UseMFCInLibrary:
			useMfc = useMfcStatic;
			break;
		case UseMFCInDll:
			// fall thru
		default:	// same as UseMFCInDll
			useMfc = useMfcDynamic;
			break;
		}

		pConfig->put_UseOfMFC(useMfc);
	}

	// Special case 1: Init runtime lib settings for cl tool differently based on
	// P_UseDebugLibs. This must be done before any other cl settings are processed
	// since they override this setting.
	BOOL fDebugLib = FALSE;
	pProject->GetIntProp(P_UseDebugLibs, fDebugLib);
	CComPtr<IVCToolImpl> pTool;
	CString strTool = "cl.exe";
	SetToolObject(pConfig, strTool, &pTool);
	if (pTool)
	{
		CComQIPtr<VCCLCompilerTool> pClTool = pTool;
		if (pClTool != NULL)
		{
			if( fDebugLib )
				pClTool->put_RuntimeLibrary(rtSingleThreadedDebug);
			else
				pClTool->put_RuntimeLibrary(rtSingleThreaded);

			long lItem = 0;
			COptionHandler* pOptHandler;
			GetOptStrForTool(strTool, pOptHandler, lItem);
			if (pOptHandler)
			{
				CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
				pOptHandler->SetSlob(pProject);
				int nVal = 0;
//				gptRet = pOptHandler->GetDefIntProp(pOptHandler->MapLogical(P_Optimize_Y), nVal);
//				if (gptRet == valid)
//					SetBoolProperty(spPropContainer, VCCLID_OmitFramePointers, nVal);
				GPT gptRet = pOptHandler->GetDefIntProp(pOptHandler->MapLogical(P_Optimize_P), nVal);
				if (gptRet == valid)
					SetBoolProperty(spPropContainer, VCCLID_ImproveFloatingPointConsistency, nVal);
				gptRet = pOptHandler->GetDefIntProp(pOptHandler->MapLogical(P_InlineControl), nVal);
				if (gptRet == valid)
					SetEnumProperty(spPropContainer, VCCLID_InlineFunctionExpansion, nVal);
				gptRet = pOptHandler->GetDefIntProp(pOptHandler->MapLogical(P_StringPool), nVal);
				if (gptRet == valid)
					SetStringPooling(pClTool, nVal);
				gptRet = pOptHandler->GetDefIntProp(pOptHandler->MapLogical(P_IncLinking), nVal);
				if (gptRet == valid)
					SetBoolProperty(spPropContainer, VCCLID_EnableFunctionLevelLinking, nVal);
				pOptHandler->ResetSlob();
			}
		}
	}
	// Special case 2: init incremental link settings for link tool differently
	// based on P_UseDebugLibs.  
	// Special case 3: init /pdb for link tool
	// Both must be done before any other link settings are processed since they override these settings.
	pTool.Release();
	strTool = _T("link.exe");
	SetToolObject(pConfig, strTool, &pTool);
	if (pTool)
	{
		CComQIPtr<VCLinkerTool> pLinkTool = pTool;
		if (pLinkTool != NULL)
		{
			SetLinkIncremental(pLinkTool, fDebugLib);
			long lItem = 0;
			COptionHandler* pOptHandler;
			GetOptStrForTool(strTool, pOptHandler, lItem);
			if (pOptHandler)
			{
				CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
				pOptHandler->SetSlob(pProject); 
				BOOL bUsePDB = fDebugLib;
				if (pProject->GetIntProp(pOptHandler->MapLogical(P_UsePDB), bUsePDB) != valid)
					bUsePDB = fDebugLib;
				SetUsePDB(spPropContainer, pProject, pOptHandler, bUsePDB);
				
				BOOL bIgnoreLib = FALSE;
				pProject->GetIntProp(pOptHandler->MapLogical(P_IgnoreExportLib), bIgnoreLib);
				if(bIgnoreLib)
				{
					SetBoolProperty(spPropContainer, VCLINKID_IgnoreImportLibrary, bIgnoreLib);
				}
				pOptHandler->ResetSlob();
			}
		}
	}

	// Now do their custom build events
	CString strPreLink = "Before the Linker";
	CString strPostBuild = "Post Build";

	HandleEvent(pProject, pConfig, P_PreLink_Command, P_PreLink_Description, strPreLink);
	HandleEvent(pProject, pConfig, P_PostBuild_Command, P_PostBuild_Description, strPostBuild);
}

void CVCProjConvert::HandleEvent(CProject* pProject, VCConfiguration* pConfig, UINT idCmd, UINT idDesc, 
	CString& strEventName)
{
	CString strCommand;
	CString strDesc;
	pProject->GetConvertedStrProp(idCmd,strCommand);
	// replace tabs (used as separators in vc 5/6) with newlines
	strCommand.Replace( '\t', '\n' );

	if(!strCommand.IsEmpty())
	{
		pProject->GetConvertedStrProp(idDesc, strDesc);
		CComPtr<IVCToolImpl> pTool;
		SetToolObject(pConfig, strEventName, &pTool);
		if (pTool)
		{
			CComQIPtr<IVCBuildEventToolInternal> pBuildEventTool = pTool;
			if (pBuildEventTool != NULL)
			{
				if (!strCommand.IsEmpty())
					pBuildEventTool->put_CommandLineInternal(CComBSTR(strCommand));
				if (!strDesc.IsEmpty())
					pBuildEventTool->put_DescriptionInternal(CComBSTR(strDesc));
			}
		}
	}
}

void CVCProjConvert::RemoveMultiples(CStringW& strList, CStringW& strSeparatorList)
{
	if (strList.IsEmpty())
		return;

	CStringW strOut;
	CStringW strItem;
	bool bFirstElem = true;

	int nNextIdx = 0;
	strList.TrimLeft();
	strList.TrimRight();
	int nMaxIdx = strList.GetLength();
	int nFoundIdx = 0;
	while (nNextIdx >= 0)
	{
		nNextIdx = GetNextItem(strList, nNextIdx, nMaxIdx, strSeparatorList, strItem);
		nFoundIdx = FindItem(strOut, strItem, strSeparatorList, 0);
		if (nFoundIdx >= 0)		// already there
			continue;
		if (!bFirstElem)
		{
			if (!strSeparatorList.IsEmpty())
				strOut += strSeparatorList.GetAt(0);
		}
		else
			bFirstElem = false;
		strOut += strItem;
	}

	if (strOut.IsEmpty())
		strList.Empty();
	else
		strList = strOut;
}

// this function handles clearing properties that have been set on the config that should have been taken as defaults
// from an applied style sheet
void CVCProjConvert::DoStyleSheetFixups(VCProject* pNewProject, VCConfiguration* pConfig)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
	if (spPropContainer == NULL)
		return;		// not a whole lot we can do...

	// let's start with the MFC style sheets
	useOfMfc useMFC = useMfcStdWin;
	HRESULT hr = pConfig->get_UseOfMFC(&useMFC);
	if (hr == S_OK)
	{
		switch(useMFC)
		{
		case useMfcStdWin:
			RemoveSymbols(spPropContainer, VCLINKID_AdditionalDependencies, L" ", 
				L"kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib");
			break;
		case useMfcStatic:
			ClearBoolProperty(spPropContainer, VCCLID_ExceptionHandling, VARIANT_TRUE /* to match mfcstatic.vcstyle */);
			break;
		case useMfcDynamic:
			RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_AFXDLL");
			ClearBoolProperty(spPropContainer, VCCLID_ExceptionHandling, VARIANT_TRUE /* to match mfcdynamic.vcstyle */);
		}
		if (useMFC != useMfcStdWin)
			pNewProject->put_Keyword(L"MFCProj");
	}

	// do we see an aspect of the character set style sheet?
	if (RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_UNICODE"))
		pConfig->put_CharacterSet(charSetUnicode);
	else if (RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_MBCS"))
		pConfig->put_CharacterSet(charSetMBCS);

	// do we see an aspect of the use of ATL style sheet?
	bool bIsAtl = true;
	if (RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_ATL_STATIC_REGISTRY"))
		pConfig->put_UseOfATL(useATLStatic);
	else if (RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_ATL_DLL"))
		pConfig->put_UseOfATL(useATLDynamic);
	else
		bIsAtl = false;
	if (bIsAtl)
		pNewProject->put_Keyword(L"AtlProj");

	// do we see the ATL min CRT stuff?
	bool bRemove = RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_ATL_MIN_CRT");
	pConfig->put_ATLMinimizesCRunTimeLibraryUsage(bRemove ? VARIANT_TRUE : VARIANT_FALSE);
	ClearBoolProperty(spPropContainer, VCCLID_ExceptionHandling, bRemove ? VARIANT_FALSE : VARIANT_TRUE);
	ClearIntProperty(spPropContainer, VCCLID_Optimization, bRemove ? optimizeMinSpace : optimizeMaxSpeed);

	// now, let's get rid of DLL style sheet elements
	ConfigurationTypes configType = typeApplication;
	hr = pConfig->get_ConfigurationType(&configType);
	if (hr == S_OK)
	{
		if (configType == typeDynamicLibrary || configType == typeApplication)
		{
			CComVariant varLinkDLL;
			if (spPropContainer->GetLocalProp(VCLINKID_LinkDLL, &varLinkDLL) == S_OK)	// this was set one way or another
			{
				if (varLinkDLL.boolVal)
					configType = typeDynamicLibrary;
				else
					configType = typeApplication;
			}
			else	// might be there (or not) due to fake prop info.  Argh.
			{
				CComBSTR bstrFile;
				if (spPropContainer->GetStrProperty(VCLINKID_OutputFile, &bstrFile) == S_OK)
				{
					CString strFile = bstrFile;
					CPath pathFile;
					if (pathFile.Create(strFile))
					{
						CString strExt = pathFile.GetExtension();
						strExt.MakeLower();
						if (strExt.IsEmpty())
						{}	// do nothing
						else if (strExt == _T(".exe"))
							configType = typeApplication;
						else if (strExt == _T(".dll") || strExt == _T(".ocx"))
							configType = typeDynamicLibrary;
					}
				}
			}
			pConfig->put_ConfigurationType(configType);
			if (configType == typeDynamicLibrary)
				RemoveSymbols(spPropContainer, VCCLID_PreprocessorDefinitions, L";,", L"_WINDLL");
			spPropContainer->Clear(VCLINKID_LinkDLL);
		}

	}
}

// This function handles deleting the PCH file, if any, that the config might have created.  It also deletes
// the linker PDB file, if any.  This causes the project to be out of date, but isn't as harsh an edit as 
// doing a 'clean' on the config would have been.
void CVCProjConvert::DoSharedFileDelete(VCConfiguration* pConfig)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
	if (spPropContainer == NULL)
		return;

	CComPtr<IDispatch> spDisp;
	if (FAILED(pConfig->get_Tools(&spDisp)))
		return;

	CComQIPtr<IVCCollection> spTools = spDisp;
	if (spTools == NULL)
		return;

	spDisp.Release();
	spTools->Item(CComVariant(L"VCCLCompilerTool"), &spDisp);
	CComQIPtr<VCCLCompilerTool> spCL = spDisp;

	spDisp.Release();
	spTools->Item(CComVariant(L"VCLinkerTool"), &spDisp);
	CComQIPtr<VCLinkerTool> spLinker = spDisp;


	CComBSTR bstrPCH;
	CString strPCH;
	if (spCL && SUCCEEDED(spCL->get_PrecompiledHeaderFile(&bstrPCH)) && bstrPCH.Length() > 0)
	{
		if (SUCCEEDED(spPropContainer->Evaluate(bstrPCH, &bstrPCH)) && bstrPCH.Length() > 0)
			strPCH = bstrPCH;
	}

	CComBSTR bstrPDB;
	CString strPDB;
	if (spLinker && SUCCEEDED(spLinker->get_ProgramDatabaseFile(&bstrPDB)) && bstrPDB.Length() > 0)
	{
		if (SUCCEEDED(spPropContainer->Evaluate(bstrPDB, &bstrPDB)) && bstrPDB.Length() > 0)
			strPDB = bstrPDB;
	}

	if (strPCH.IsEmpty() && strPDB.IsEmpty())	// if they're both empty strings, then nothing more to do
		return;

	// we now know that there is supposed to be a PCH and/or PDB file there...
	CComBSTR bstrProjDir;
	if (FAILED(spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir)) || bstrProjDir.Length() == 0)
		return;

	CString strProjDirTmp = bstrProjDir;
	int nLen = strProjDirTmp.GetLength();
	if (strProjDirTmp[nLen-1] != _T('/') && strProjDirTmp[nLen-1] != _T('\\'))
		strProjDirTmp += _T("/");
	strProjDirTmp += _T("foo");	// need to have this be a file, not the directory.  sigh.
	CPath pathProjDirTmp;
	if (!pathProjDirTmp.Create(strProjDirTmp))
		return;

	CDir dirProj;
	if (!dirProj.CreateFromPath(pathProjDirTmp))
		return;

	if (!strPCH.IsEmpty())
	{
		CPath pathPCH;
		if (pathPCH.CreateFromDirAndFilename(dirProj, strPCH))
			::DeleteFile((const char *) pathPCH);	// don't care if it exists or not...
	}

	if (!strPDB.IsEmpty())
	{
		CPath pathPDB;
		if (pathPDB.CreateFromDirAndFilename(dirProj, strPDB))
			::DeleteFile((const char *) pathPDB);	// don't care if it exists or not...
	}
}

bool CVCProjConvert::RemoveSymbols(IVCPropertyContainer* pPropContainer, long idProp, BSTR bstrSeparatorList, BSTR bstrSymbols)
{
	CComBSTR bstrExistingProp;
	HRESULT hr = pPropContainer->GetStrProperty(idProp, &bstrExistingProp);
	if (hr != S_OK)
		return false;		// nothing to do

	CStringW strExistingList = bstrExistingProp;
	CStringW strRemoveList = bstrSymbols;
	CStringW strSeparatorList = bstrSeparatorList;
	CStringW strItem;
	int nMaxIdx = strRemoveList.GetLength();
	int nNextIdx = 0;
	bool bFoundIt = false;
	while (nNextIdx >= 0)
	{
		nNextIdx = GetNextItem(strRemoveList, nNextIdx, nMaxIdx, strSeparatorList, strItem);
		if (RemoveItem(strExistingList, strItem, strSeparatorList))
			bFoundIt = true;
	}

	strExistingList.TrimLeft();
	strExistingList.TrimRight();
	if (strExistingList.IsEmpty())
		pPropContainer->Clear(idProp);
	else
	{
		CComBSTR bstrNewList = strExistingList;
		pPropContainer->SetStrProperty(idProp, bstrNewList);
	}

	return bFoundIt;
}

void CVCProjConvert::ClearBoolProperty(IVCPropertyContainer* pPropContainer, long idProp, VARIANT_BOOL bDefault)
{
	VARIANT_BOOL bPropVal = VARIANT_FALSE;
	HRESULT hr = pPropContainer->GetBoolProperty(idProp, &bPropVal);
	if (hr != S_OK)
		return;		// nothing needs to be done

	if (bPropVal == bDefault)
		pPropContainer->Clear(idProp);
}

void CVCProjConvert::ClearIntProperty(IVCPropertyContainer* pPropContainer, long idProp, long nDefault)
{
	long nPropVal = 0;
	HRESULT hr = pPropContainer->GetIntProperty(idProp, &nPropVal);
	if (hr != S_OK)
		return;		// nothing needs to be done

	if (nPropVal == nDefault)
		pPropContainer->Clear(idProp);
}

int CVCProjConvert::FindFirstSeparator(CStringW& strList, CStringW& strSeparatorList, int nStartIdx)
{
	int cSeparators = strSeparatorList.GetLength();
	if (cSeparators == 0)	// no separators means give back first char of list
		return 0;
	else if (cSeparators == 1)
		return strList.Find(strSeparatorList, nStartIdx);

	// got here; means we have the potential for multiple separator possibilities
	int nMinSep = -1, nThisSep = -1;
	for (int idx = 0; idx < cSeparators; idx++)
	{
		nThisSep = strList.Find(strSeparatorList.GetAt(idx), nStartIdx);
		if (nThisSep >= 0 && ((nThisSep < nMinSep) || (nMinSep < 0)))
			nMinSep = nThisSep;
	}

	return nMinSep;
}

int CVCProjConvert::GetNextItem(CStringW& strList, int nStartIdx, int nMaxIdx, CStringW& strSeparator, CStringW& strItem)
{
	strItem.Empty();
	if (nStartIdx < 0)
		return nStartIdx;
	else if (nStartIdx >= nMaxIdx)
		return -1;

	int nSep = FindFirstSeparator(strList, strSeparator, nStartIdx);
	if (nSep >= 0)
	{
		int nQuote = strList.Find(L'"', nStartIdx);
		if (nQuote >= nStartIdx && nQuote < nSep)	// need to get outside the quoted string
			return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, TRUE, strSeparator, strItem);
		strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
		nSep++;
		return nSep;
	}

	if (nStartIdx < nMaxIdx)
		strItem = strList.Right(nMaxIdx-nStartIdx);

	return -1;
}

int CVCProjConvert::GetNextQuotedItem(CStringW& strList, int nStartIdx, int nMaxIdx, int nSep, int nLastQuote,
	BOOL bOddQuote, CStringW& strSeparator, CStringW& strItem)
{
	if (bOddQuote)
	{
		int nQuote = strList.Find(L'"', nLastQuote+1);
		if (nQuote < nSep)	// doesn't matter that we found a quote
		{
			strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
			nSep++;
			return nSep;
		}
		else
			return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, FALSE, strSeparator, strItem);
	}
	else	// even quote
	{
		nSep = FindFirstSeparator(strList, strSeparator, nLastQuote+1);
		if (nSep >= 0)
		{
			int nQuote = strList.Find(L'"', nLastQuote+1);
			if (nQuote > nLastQuote && nQuote < nSep)	// still need to get outside the quoted string
				return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, TRUE, strSeparator, strItem);
			strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
			nSep++;
			return nSep;
		}

		if (nStartIdx < nMaxIdx)
			strItem = strList.Right(nMaxIdx-nStartIdx);
		
		return -1;
	}
}

bool CVCProjConvert::RemoveItem(CStringW& strList, CStringW& strItem, CStringW& strSeparatorList)
{
	int nFoundIdx = FindItem(strList, strItem, strSeparatorList, 0);
	if (nFoundIdx < 0)
		return false;		// not there

	int nLen = strList.GetLength();
	int nItemLen = strItem.GetLength();
	CStringW strLeft, strRight;
	if (nFoundIdx == 0)
	{
		if (nLen > nItemLen)
			strList = strList.Right(nLen-nFoundIdx-nItemLen-1);
		else
			strList.Empty();
	}
	else if (nFoundIdx + nItemLen == nLen)
		strList = strList.Left(nFoundIdx-1);
	else
	{
		strLeft = strList.Left(nFoundIdx-1);
		strRight = strList.Right(nLen-nFoundIdx-nItemLen);
		strList = strLeft + strRight;
	}

	return true;
}

int CVCProjConvert::FindItem(CStringW& rstrItems, CStringW& rstrFindItem, CStringW& strSeparator, int nStart)
{
	nStart = rstrItems.Find(rstrFindItem, nStart);
	if (nStart < 0)
		return nStart;

	int nItemLen = rstrItems.GetLength();
	int nLen = rstrFindItem.GetLength();

	if (nStart > 0 && nStart + nLen < nItemLen && strSeparator.Find(rstrItems[nStart-1]) < 0)
		return FindItem(rstrItems, rstrFindItem, strSeparator, nStart+nLen);

	else if (nItemLen > nStart +  nLen && strSeparator.Find(rstrItems[nStart+nLen]) < 0)
		return FindItem(rstrItems, rstrFindItem, strSeparator, nStart+nLen);

	return nStart;
}

void CVCProjConvert::SetLinkIncremental(VCLinkerTool* pLinkTool, BOOL bSetIt)
{
	linkIncrementalType oldLinkIncremental = linkIncrementalDefault;
	pLinkTool->get_LinkIncremental(&oldLinkIncremental);
	if (bSetIt && oldLinkIncremental != linkIncrementalYes)
		pLinkTool->put_LinkIncremental(linkIncrementalYes);
	else if (!bSetIt && oldLinkIncremental != linkIncrementalNo)
		pLinkTool->put_LinkIncremental(linkIncrementalNo);
}
								
void CVCProjConvert::HandleFileProperties(CProject* pProject, VCProject* pNewProject)
{
	g_pActiveProject = pProject;
	HBLDFILE hFile = NULL;

	g_BldSysIFace.InitFileEnum((HPROJECT)pProject);

	while (SUCCEEDED((hFile = g_BldSysIFace.GetNextFile())) && hFile != (HBLDFILE)NO_FILE )
	{
		CFileItem *pFileItem = (CFileItem *)hFile;
		if (pFileItem == NULL)
			continue;

		CSlob* pSlobParent = pFileItem->GetContainer();

		CComPtr<VCFilter> pFilter;
		if (pSlobParent && pSlobParent->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			AddFolderForFile(pNewProject, pSlobParent, NULL, &pFilter);
		}

		if (pFileItem->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)))
		{
			// Go through all configs and set properties per config per file
			g_BldSysIFace.InitConfigEnum((HPROJECT)pProject);
			HCONFIGURATION hConfig;
			CString strTarget;
			while (hConfig = g_BldSysIFace.GetNextConfig(strTarget, (HPROJECT)pProject))
			{
				CComPtr<VCConfiguration> pConfig;
				GetNamedProjectConfiguration(strTarget, pNewProject, &pConfig);

				CConfigurationRecord * pcr = g_BldSysIFace.GetConfigRecFromConfigI(hConfig, 
					(HPROJECT)pProject);
				pProject->ForceConfigActive(pcr);
				AddCustomBuildEventItem(pFileItem, pConfig);
  				pProject->ForceConfigActive();
			} // while next config
		}
		else
		{
			const CPath *path = pFileItem->GetFilePath();
			CDir dir = pProject->GetWorkspaceDir();
			CString strRelPath;
			path->GetRelativeName( dir, strRelPath );
			CComBSTR bstrPath( strRelPath );
			CComPtr<IDispatch> pDispFile;
			HRESULT hr = S_OK;
			if (pFilter)
			{
				hr = pFilter->AddFile(bstrPath, &pDispFile);
			}
			else
			{
				hr = pNewProject->AddFile(bstrPath, &pDispFile);
			}
			CComQIPtr<VCFile> pFile = pDispFile;
			VSASSERT(SUCCEEDED(hr) && pFile, "Returned 'file' isn't a file!");
			if (pFileItem && pFile)
			{
				//case P_ItemExcludedFromScan:
				//case P_ItemCustomBuildExt:
				// do configuration-unspecific properties...

// 				CString strRelPath;
// 				pFileItem->GetConvertedStrProp(P_ProjItemOrgPath, strRelPath);
// 				CComBSTR bstrRelPath = strRelPath;
// 				pFile->put_RelativePath(bstrRelPath);

				// Go through all configs and set properties per config per file
				g_BldSysIFace.InitConfigEnum((HPROJECT)pProject);
				HCONFIGURATION hConfig;
				CString strTarget;
				while (hConfig = g_BldSysIFace.GetNextConfig(strTarget, (HPROJECT)pProject))
				{
					CComPtr<VCFileConfiguration> pFileConfig;
					GetNamedFileConfiguration(strTarget, pFile, &pFileConfig);

					CString strTool;
					// get this target's config record
					CConfigurationRecord * pcr = 
						g_BldSysIFace.GetConfigRecFromConfigI(hConfig, (HPROJECT)pProject);
					pProject->ForceConfigActive(pcr);
					
					pFileItem->GetStrProp(P_ItemBuildTool, strTool);
					if (!strTool.IsEmpty())
					{
						SetToolSettings(pFileItem, pProject, strTool, pFileConfig, NULL);
					}

					const CPath* pPath = pFileItem->GetFilePath();
					VSASSERT(pPath != NULL, "File item has no path!  Was it added to the project correctly originally?");
					if (pPath)
					{
						CString strExt = pPath->GetExtension();
						strExt.MakeLower();
						if (strExt == _T(".def"))
							SetLinkerDefSettings(pFileItem, pFileConfig);
					}
  					pProject->ForceConfigActive();
				} // while next config
			}
		}
	}  // while next file
}

HRESULT CVCProjConvert::GetNamedProjectConfiguration(CString& strTarget, VCProject* pNewProject, 
	VCConfiguration** ppNewConfig)
{
	CHECK_POINTER_NULL(ppNewConfig);
	*ppNewConfig = NULL;

	CComPtr<IDispatch> pDispConfigs;
	HRESULT hr = pNewProject->get_Configurations(&pDispConfigs);
	CComQIPtr<IVCCollection> pConfigs = pDispConfigs;
	RETURN_ON_FAIL_OR_NULL(hr, pConfigs);

	CString strConfigName;
	if (!GetConfigName(strTarget, strConfigName, TRUE))
		return E_FAIL;
	CComBSTR bstrConfig = strConfigName;

	CComPtr<IDispatch> pDispConfig;
	hr = pConfigs->Item(CComVariant(bstrConfig), &pDispConfig);
	CComQIPtr<VCConfiguration> pConfig = pDispConfig;
	RETURN_ON_FAIL_OR_NULL(hr, pConfig);

	*ppNewConfig = pConfig.Detach();
	return hr;
}

HRESULT CVCProjConvert::GetNamedFileConfiguration(CString& strTarget, VCFile* pFile, 
	VCFileConfiguration** ppNewFileConfig)
{
	CHECK_POINTER_NULL(ppNewFileConfig);
	*ppNewFileConfig = NULL;

	CComPtr<IDispatch> pDispFileConfigs;
	HRESULT hr = pFile->get_FileConfigurations(&pDispFileConfigs);
	CComQIPtr<IVCCollection> pFileConfigs = pDispFileConfigs;
	RETURN_ON_FAIL_OR_NULL(hr, pFileConfigs);

	CString strConfigName;
	if (!GetConfigName(strTarget, strConfigName, TRUE))
		return E_FAIL;
	CComBSTR bstrConfig = strConfigName;

	CComPtr<IDispatch> pDispFileConfig;
	hr = pFileConfigs->Item(CComVariant(bstrConfig), &pDispFileConfig);
	CComQIPtr<VCFileConfiguration> pFileConfig = pDispFileConfig;
	RETURN_ON_FAIL_OR_NULL(hr, pFileConfig);

	*ppNewFileConfig = pFileConfig.Detach();
	return hr;
}

// HACK for ATL project conversion:
// ATL 5/6 projects don't have a "Release" config, so "Release
// MinSize" should be copied into "Release"...
// if there was no "Release" config, but there was a "Release MinSize"...
HRESULT CVCProjConvert::DoATLProjectConversionHack(VCProject* pNewProject, bool bHasRelease, 
	bool bHasReleaseMinSize)
{
	HRESULT hr = S_OK;

 	if( !bHasRelease && bHasReleaseMinSize )
	{
		// copy Release MinSize into Release
		// get the configs collection
		CComPtr<IDispatch> pDisp;
		HRESULT hr = pNewProject->get_Configurations( &pDisp );
		CComQIPtr<IVCCollection> pCollection = pDisp;
		RETURN_ON_FAIL_OR_NULL2(hr, pCollection, E_NOINTERFACE);
		
		// assume the platform is "Win32"
		CComBSTR bstrNewCfgName = L"Release|Win32";
		CComBSTR bstrOldCfgName = L"Release MinSize|Win32";
		// look up these names in the config collections
		CComPtr<IDispatch> pDispNewCfg;
		CComVariant varIdx = bstrNewCfgName;
		hr = pCollection->Item( varIdx, &pDispNewCfg );
		CComQIPtr<VCConfiguration> pNewCfg = pDispNewCfg;
		RETURN_ON_FAIL_OR_NULL2(hr, pNewCfg, S_OK);
		varIdx = bstrOldCfgName;
		CComPtr<IDispatch> pDispOldCfg;
		hr = pCollection->Item( varIdx, &pDispOldCfg );
		CComQIPtr<VCConfiguration> pOldCfg = pDispOldCfg;
		RETURN_ON_FAIL_OR_NULL(hr, pOldCfg);
		// copy the config
		hr = pOldCfg->CopyTo( pDispNewCfg );
	}

	return hr;
}

// TODO: Consider doing a get_parent kind of thing to add filters, and then do AddFolder at end to make sure we got them all

void CVCProjConvert::AddFolders(VCProject *pProject, CSlob * pSlob)
{
	CObList *obList = pSlob->GetContentList();
	POSITION pos, pos2;
	CSlob * pSlobT, *pSlobG;

	pos = obList->GetHeadPosition();
	while (pos)
	{
		pSlobT = (CSlob *)obList->GetNext(pos);
		if (pSlobT && pSlobT->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		{
			CObList *obList2 = pSlobT->GetContentList();
			pos2 = obList2->GetHeadPosition();
			while (pos2)
			{
				pSlobG = (CSlob *)obList2->GetNext(pos2);
				if (pSlobG && pSlobG->IsKindOf(RUNTIME_CLASS(CProjGroup)))
				{
					CComPtr<IDispatch> pDispFilter;
					CComQIPtr<VCFilter> pFilter;
					CProjGroup *pGroup = (CProjGroup *)pSlobG;
					if (pGroup->m_strDefaultExtensions != _T("bev"))
					{
						CComBSTR bstrFilterName = pGroup->m_strGroupName;

						// check if this folder already exists 
						CComPtr<IDispatch> pDispColl;
						pProject->get_Filters( &pDispColl );
						VSASSERT( pDispColl, "Can't get Filters collection from Filter object!" );
						CComQIPtr<IVCCollection> pColl = pDispColl;
						VSASSERT( pColl, "Filters collection doesn't support IVCCollection. How in the world did this happen?" );
						CComPtr<IDispatch> pDispItem;
						pColl->Item( CComVariant( bstrFilterName ), &pDispItem );
						if( !pDispItem )
						{
							pProject->AddFilter(bstrFilterName, &pDispFilter);
							pFilter = pDispFilter;
						}
						if (pFilter)
						{
							CComBSTR bstrFilters = pGroup->m_strDefaultExtensions;
							pFilter->put_Filter(bstrFilters);
							AddSubFolders(pFilter, pSlobG);
						}
					}
				}
			}
		}
	}

}
void CVCProjConvert::AddSubFolders(VCFilter *pFilter, CSlob * pSlob)
{
	CObList *obList = pSlob->GetContentList();
	POSITION pos;
	CSlob * pSlobT;

	pos = obList->GetHeadPosition();
	while (pos)
	{
		pSlobT = (CSlob *)obList->GetNext(pos);
		if (pSlobT && pSlobT->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			CComPtr<IDispatch> pDispFilter;
			CComQIPtr<VCFilter> pFilterNew;
			CProjGroup *pGroup = (CProjGroup *)pSlobT;
			CComBSTR bstrFilterName = pGroup->m_strGroupName;

			// check if this folder already exists 
			CComPtr<IDispatch> pDispColl;
			pFilter->get_Filters( &pDispColl );
			VSASSERT( pDispColl, "Can't get Filters collection from Filter object!" );
			CComQIPtr<IVCCollection> pColl = pDispColl;
			VSASSERT( pColl, "Filters collection doesn't support IVCCollection. How in the world did this happen?" );
			CComPtr<IDispatch> pDispItem;
			pColl->Item( CComVariant( bstrFilterName ), &pDispItem );
			if( !pDispItem )
			{
				pFilter->AddFilter(bstrFilterName, &pDispFilter);
				pFilterNew = pDispFilter;
			}
			if (pFilterNew)
			{
				CComBSTR bstrFilters = pGroup->m_strDefaultExtensions;
				pFilterNew->put_Filter(bstrFilters);
				AddSubFolders(pFilterNew, pSlobT);
			}
		}
	}

}

void CVCProjConvert::AddFolderForFile(VCProject *pProject, CSlob *pSlob, VCFile *pFile, VCFilter **ppFilter)
{
	if (pSlob && pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
	{
		CProjGroup *pGroup = (CProjGroup *)pSlob;
		CComBSTR bstrFilterName = pGroup->m_strGroupName;
		CString strDefaultExtensions;
		pGroup->GetStrProp(P_GroupDefaultFilter, strDefaultExtensions);
		CComBSTR bstrFilters = strDefaultExtensions;
		
		CSlob *pSlobT = pSlob->GetContainer();
		CComPtr<IDispatch> pDispFilter;
		CComQIPtr<VCFilter> pFilterNew;
		if (pSlobT && pSlobT->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			CComPtr<VCFilter> pFilterParent;
			AddFolderForFile(pProject, pSlobT, NULL, &pFilterParent);
			if (pFilterParent)
			{
				// check if this folder already exists
				CComPtr<IDispatch> pDispColl;
				pFilterParent->get_Filters( &pDispColl );
				VSASSERT( pDispColl, "Can't get Filters collection from Filter object!" );
				CComQIPtr<IVCCollection> pColl = pDispColl;
				VSASSERT( pColl, "Filters collection doesn't support IVCCollection. How in the world did this happen?" );
				CComPtr<IDispatch> pDispItem;
				pColl->Item( CComVariant( bstrFilterName ), &pDispItem );
				if( !pDispItem )
					pFilterParent->AddFilter(bstrFilterName, &pDispFilter);
				else 
					pDispFilter = pDispItem;
			}
		}
		else
		{
			// check if this folder already exists
			CComPtr<IDispatch> pDispColl;
			pProject->get_Filters( &pDispColl );
			VSASSERT( pDispColl, "Can't get Filters collection from Project object!" );
			CComQIPtr<IVCCollection> pColl = pDispColl;
			VSASSERT( pColl, "Filters collection doesn't support IVCCollection. How in the world did this happen?" );
			CComPtr<IDispatch> pDispItem;
			pColl->Item( CComVariant( bstrFilterName ), &pDispItem );
			if( !pDispItem )
				pProject->AddFilter(bstrFilterName, &pDispFilter);
			else
				pDispFilter = pDispItem;
		}
		pFilterNew = pDispFilter;
		if (pFilterNew)
		{
			pFilterNew->put_Filter(bstrFilters);
			if (ppFilter)
				pFilterNew.CopyTo(ppFilter);
			if (pFile)
			{
				CComQIPtr<IVCFilterImpl> pFilterImpl = pFilterNew; // TODO: Need File::MoveTo()
				if (pFilterImpl)
				{
					pFilterImpl->AddItem(pFile);
				}
			}
		}
	}
}

COptStr * CVCProjConvert::GetOptStrForTool(LPCTSTR szTool, COptionHandler * &popthdlr, long & lItem)
{
	long lItemT = 0;
	g_pPrjcompmgr->InitOptHdlrEnum();
	while (g_pPrjcompmgr->NextOptHdlr(popthdlr) && popthdlr)
	{
		if (popthdlr->m_pAssociatedBuildTool && popthdlr->m_pAssociatedBuildTool->GetToolName() == szTool)
		{
			if (lItem == lItemT)
			{
				COptStr * poptStr;
				poptStr = popthdlr->GetOptionStringTable();
				lItem++;
				return (poptStr);
			}
		lItemT++;
		}
	}
	return NULL;
}

// we're here to set the /DEF switch for the configuration; the last non-excluded from build .def file wins
// NOTE: we're assuming that we got called because the tool associated with a file was the linker and that
// should only be true for .def files.  If some other such case shows up, then we need to do some extra
// checking here.  Otherwise, it isn't worth taking the time to determine that the extension is, indeed, .def.
void CVCProjConvert::SetLinkerDefSettings(CProjItem *pFileItem, VCFileConfiguration *pFileConfig)
{
	if (pFileItem == NULL || pFileConfig == NULL)
	{
		VSASSERT(FALSE, "Trying to set the def file on a non-file item");	// shouldn't be here, then...
		return;
	}

	BOOL bExcludedFromBuild = FALSE;
	pFileItem->GetIntProp(P_ItemExcludedFromBuild, bExcludedFromBuild);
	if (bExcludedFromBuild)
		return;		// nothing to do, then

	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = pFileConfig;
	if (spFileCfgImpl == NULL)
	{
		VSASSERT(FALSE, "File config isn't what it's supposed to be!");
		return;
	}

	CComPtr<IDispatch> spDispProjCfg;
	spFileCfgImpl->get_Configuration(&spDispProjCfg);
	CComQIPtr<VCConfiguration> spProjCfg = spDispProjCfg;
	VSASSERT(spProjCfg != NULL, "Project config either doesn't exist or isn't what it's supposed to be!");
	if (spProjCfg == NULL)
		return;

	CComPtr<IDispatch> spDispTools;
	spProjCfg->get_Tools(&spDispTools);
	CComQIPtr<IVCCollection> spTools = spDispTools;
	VSASSERT(spTools != NULL, "Tool list not initialized in project engine!");
	if (spTools == NULL)
		return;

	CComPtr<IDispatch> spDispTool;
	spTools->Item(CComVariant(L"VCLinkerTool"), &spDispTool);
	CComQIPtr<VCLinkerTool> spTool = spDispTool;
	if (spTool == NULL)
		return;

	CPath path = *(pFileItem->GetFilePath());
	path.SetAlwaysRelative();
	CDir projDir = pFileItem->GetProject()->GetWorkspaceDir();
	CString strDefFile;
	BOOL bOK = path.GetRelativeName(projDir, strDefFile);
	VSASSERT(bOK, "Unable to get relative path name for def file!");

	CComBSTR bstrDefFile = strDefFile;
	spTool->put_ModuleDefinitionFile(bstrDefFile);
}

void CVCProjConvert::SetToolSettings(CProjItem *pFileItem, CProject* pProject, LPCTSTR szTool, 
	VCFileConfiguration *pFileConfig, VCConfiguration *pConfig)
{
	OptBehaviour optOld = pFileItem->SetOptBehaviour(OBShowMacro);
	CComPtr<IVCToolImpl> pTool;
	CComQIPtr<IVCPropertyContainer> spPropContainer;
	bool bIsBase = false;
	if (pFileConfig)
	{
		SetToolObject(pFileConfig, szTool, &pTool);
		BOOL bExcludedFromBuild = FALSE;
		pFileItem->GetIntProp(P_ItemExcludedFromBuild, bExcludedFromBuild);
		if (bExcludedFromBuild)
			pFileConfig->put_ExcludedFromBuild(VARIANT_TRUE);
		spPropContainer = pFileConfig;
	}
	else if (pConfig)
	{
		SetToolObject(pConfig, szTool, &pTool);
		spPropContainer = pConfig;
		bIsBase = true;
	}

	if (pTool)
	{
		CComQIPtr<VCCustomBuildTool> pCustomBuild = pTool;
		if (pCustomBuild)
		{
			AddCustomBuildItem(pFileItem, pCustomBuild, pFileConfig, pConfig);
		}
		else
		{
			COptionHandler *pOptHandler;
			long lItem = 0;
			COptStr * poptStr = GetOptStrForTool(szTool, pOptHandler, lItem);
			while (poptStr && pOptHandler)
			{
				pOptHandler->SetSlob(pFileItem); 
				while (poptStr->idOption != (UINT)-1)
				{
					if (poptStr->rgidArg[0] != -1)
					{
						UINT idOption = poptStr->rgidArg[0];
						CString strVal;
						int intVal;
						GPT gptRet;
						CComVariant var;
						PROP_TYPE pType = pOptHandler->GetDefOptionType(idOption);
						if (pType == null)
						{
							SUBTYPE subtype = pOptHandler->GetDefOptionSubType(idOption);
							switch (subtype)
							{
							case boolST:
								pType = integer;
								break;
							case  intST:
								pType = integer;
								break;
							case  hexST:
								pType = integer; 
								break;
							case  octST:
								pType = integer;
								break;
							case  strST:
								pType = string;
								break;
							case  pathST:
								pType = string;
								break;
							case  dirST:
								pType = string;
								break;
							default: // null
								pType = null;
								break;
							}
						}
						switch (pType)
						{
						case string:
							gptRet = pFileItem->GetConvertedStrProp(idOption, strVal);
							if (gptRet == invalid && bIsBase)
							{
								gptRet = pOptHandler->GetDefStrProp(idOption, strVal);
								if (gptRet == valid)
									::ConvertMacros(strVal);
							}
							var = strVal;
							break;
						default:
							gptRet = pFileItem->GetIntProp(idOption, intVal);
							var = intVal;
							break;
						}
						if (gptRet == valid)
						{
							SetToolSetting(pTool, spPropContainer, var, poptStr, pFileItem, pOptHandler, bIsBase);
						}
					}
					poptStr++;
				}
				BOOL bHandled = DoSpecialLinkerProps(pTool, spPropContainer, pOptHandler, pFileItem);
				if (!bHandled)
					bHandled = DoSpecialMidlProps(pTool, pOptHandler, pFileItem);
				if (!bHandled)
					DoSpecialUnknownStringProps(pTool, spPropContainer, pOptHandler, pFileItem);
				pOptHandler->ResetSlob();
				poptStr = GetOptStrForTool(szTool, pOptHandler, lItem); // next Opt table
			}

			CString strIntDir, strDummy;
			if (pFileConfig && pProject != pFileItem && pFileItem->GetOutDirString(strDummy, P_OutDirs_Intermediate, &strIntDir))
			{
				CString strProjIntDir;
				if (pProject->GetOutDirString(strDummy, P_OutDirs_Intermediate, &strProjIntDir)  && strIntDir != strProjIntDir)
				{
					// hmmm.  first cut says they're different.  verify
					CleanupDirSpec(strIntDir);
					CleanupDirSpec(strProjIntDir);
					if (strIntDir != strProjIntDir)		// definitely different
					{
						CComPtr<IDispatch> spDispTool;
						if (SUCCEEDED(pFileConfig->get_Tool(&spDispTool)))
						{
							CComBSTR bstrIntDir = strIntDir;
							CComQIPtr<VCCLCompilerTool> spCLTool = spDispTool;
							if (spCLTool)
								spCLTool->put_ObjectFile(bstrIntDir);
							CComQIPtr<VCResourceCompilerTool> spRCTool = spDispTool;
							if (spRCTool)
								spRCTool->put_ResourceOutputFileName(bstrIntDir);
							CComQIPtr<VCMidlTool> spMidlTool = spDispTool;
							if (spMidlTool)
								spMidlTool->put_OutputDirectory(bstrIntDir);
						}
					}
				}
			}
		}
	}

	pFileItem->SetOptBehaviour(optOld);
}

void CVCProjConvert::CleanupDirSpec(CString& strDir)
{
	strDir.TrimLeft();
	strDir.TrimRight();
	if (strDir.IsEmpty())
		return;	// not a whole lot we can do

	int nLen = strDir.GetLength();
	if (nLen == 2 && (strDir  == _T(".\\") || strDir == _T("./")))
	{
		strDir = _T("./");	// leave it looking like this
		return;
	}
	else if (nLen == 1 && (strDir == _T("\\") || strDir == _T("/")))
	{
		strDir = _T("/");	// more or less leave it alone
		return;
	}
	if (nLen == 2 && (strDir[0] == _T('\\') || strDir[0] == _T('/')))
		return;		// not much else we can do here...

	if (strDir[nLen-1] == _T('/'))
		return;		// looks good

	if (strDir[nLen-1] == _T('\\'))
	{
		nLen--;
		strDir = strDir.Left(nLen);		// want to trail a forward slash, not a back one
	}
	else if (strDir[nLen-1] == _T(')'))		// ah.  macro.
		return;		// leave it alone

	strDir += _T("/");
}

BOOL CVCProjConvert::DoSpecialLinkerProps(IVCToolImpl* pTool, IVCPropertyContainer* pPropContainer, COptionHandler* pOptHandler, 
	CProjItem* pFileItem)
{
	CComQIPtr<VCLinkerTool> spLinkTool = pTool;
	if (spLinkTool != NULL)
	{
		pOptHandler->SetSlob(pFileItem); 
		UINT nIDUnknownOption, nIDUnknownString;
		pOptHandler->GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, OBInherit);
		if (nIDUnknownString != (UINT)-1)
		{
			CProject* pProj = pFileItem->GetProject();
			if (pProj != NULL)
			{
				CString strUnknown;
				GPT gptRet = pProj->GetConvertedStrProp(nIDUnknownString, strUnknown);
				if (gptRet == valid)
				{
					CStringW strUnknownW = strUnknown, strSeparator = L" ";
					RemoveMultiples(strUnknownW, strSeparator);
					CComBSTR bstrUnknown = strUnknownW;
					SetStrProperty(pPropContainer, VCLINKID_AdditionalDependencies, bstrUnknown);
				}
				gptRet = pProj->GetConvertedStrProp(nIDUnknownOption, strUnknown);
				if (gptRet == valid)
				{
					int nStringIdx = 0;
					while (nStringIdx >= 0)
					{
						CString strOpt;
						GetUnknownToken(strUnknown, strOpt, nStringIdx);
						if (strOpt.IsEmpty())
						{}	// nothing to do
						else if (_tcsnicmp(strOpt, _T("/opt:ref"), 8) == 0)
							spLinkTool->put_OptimizeReferences(optReferences);
						else if (_tcsnicmp(strOpt, _T("/opt:noref"), 10) == 0)
							spLinkTool->put_OptimizeReferences(optNoReferences);
						else if (_tcsnicmp(strOpt, _T("/opt:win98"), 10) == 0)
							spLinkTool->put_OptimizeForWindows98(optWin98Yes);
						else if (_tcsnicmp(strOpt, _T("/opt:nowin98"), 12) == 0)
							spLinkTool->put_OptimizeForWindows98(optWin98No);
						else if (_tcsnicmp(strOpt, _T("/opt:noicf"), 10) == 0)
							spLinkTool->put_EnableCOMDATFolding(optNoFolding);
						else if (_tcsnicmp(strOpt, _T("/opt:icf"), 8) == 0)
						{
							CString strOpt2 = strOpt.Right(strOpt.GetLength()-8);
							if (!strOpt2.IsEmpty())
							{
								if (strOpt2[0] == _T(','))
								{
									strOpt2 = strOpt.Right(strOpt.GetLength()-1);
									strOpt2.TrimRight();
									long lVal = atoi(strOpt2);
									if (lVal == 2)
										spLinkTool->put_EnableCOMDATFolding(optFolding);
									else if (lVal != 0)
									{
										CComBSTR bstrOpt = strOpt;
										AddAdditionalOptions(pPropContainer, VCLINKID_AdditionalOptions, bstrOpt);
									}
								}
								else
									spLinkTool->put_EnableCOMDATFolding(optFolding);
							}
							else
								spLinkTool->put_EnableCOMDATFolding(optFolding);
						}
						else if (_tcsnicmp(strOpt, _T("/base:"), 6) == 0)	// table lookups don't like this one for some reason...
						{
							strOpt = strOpt.Right(strOpt.GetLength()-6);
							strOpt.TrimRight();
							CComBSTR bstrOpt = strOpt;
							SetStrProperty(pPropContainer, VCLINKID_BaseAddress, bstrOpt);
						}
						// looking to see more of these unknown props show up...
					}
				}
			}
		}
		pOptHandler->ResetSlob();
		return TRUE;	// was linker tool
	}

	return FALSE;	// was not linker tool
}

void CVCProjConvert::GetUnknownToken(CString& rstrString, CString& rstrOpt, int& rnIdx)
{
	int nLen = rstrString.GetLength();
	if (rnIdx >= nLen-1)
	{
		rnIdx = -1;
		return;
	}

	int nEnd = rnIdx;
	BOOL bInSingleQuotes = FALSE, bInDoubleQuotes = FALSE;
	BOOL bDone = FALSE;
	for (nEnd = rnIdx; nEnd < nLen && !bDone; nEnd++)
	{
		if (rstrString[nEnd] == _T('"'))
			bInDoubleQuotes = !bInDoubleQuotes;
		else if (rstrString[nEnd] == _T('\''))
			bInSingleQuotes = !bInSingleQuotes;
		else if (bInSingleQuotes || bInDoubleQuotes)
			continue;

		bDone = _istspace(rstrString[nEnd]);
	}

	if (nEnd > rnIdx + 1)
		rstrOpt = rstrString.Mid(rnIdx, nEnd-1);	// don't want that trailing space if there (and don't want to index past end if not)
	else
		rstrOpt.Empty();

	rnIdx = nEnd;
	while (rnIdx < nLen && _istspace(rstrString[rnIdx]))	// skip over any white space between/after options
		rnIdx++;
	if (rnIdx == nLen)
		rnIdx = -1;
}

BOOL CVCProjConvert::DoSpecialMidlProps(IVCToolImpl* pTool, COptionHandler* pOptHandler, CProjItem* pFileItem)
{
	CComQIPtr<VCMidlTool> spMidlTool = pTool;
	if (spMidlTool != NULL)
	{
		pOptHandler->SetSlob(pFileItem); 
		UINT nIDUnknownOption, nIDUnknownString;
		pOptHandler->GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, OBInherit);
		if (nIDUnknownString != (UINT)-1)
		{
			CProject* pProj = pFileItem->GetProject();
			if (pProj != NULL)
			{
				CString strUnknown;
				GPT gptRet = pProj->GetConvertedStrProp(nIDUnknownString, strUnknown);
				if (gptRet == valid)
				{
					if (strUnknown.Find(_T("/win64")) >= 0)
						spMidlTool->put_TargetEnvironment(midlTargetWin64);
					else	// 'old' default...
						spMidlTool->put_TargetEnvironment(midlTargetWin32);
				}
			}
		}
		CComBSTR bstrTlb;
		HRESULT hr2 = spMidlTool->get_TypeLibraryName(&bstrTlb);
		if (hr2 != S_OK)
		{
			CString strProj, strBase;
			GPT gpt = pFileItem->GetStrProp(P_ProjItemName, strProj);
			if (gpt == valid && !strProj.IsEmpty())
			{
				CPath pathProj;
				pathProj.Create(strProj);
				pathProj.GetBaseNameString(strBase);
			}

			if (!strBase.IsEmpty())
			{
				CProjItem* pItem = pFileItem;
				CString strVal;
				GPT gpt = pItem->GetConvertedStrProp(P_OutDirs_Target, strVal);
				while (gpt != valid)
				{
					// *chain* the proper. config.
					CProjItem * pItemOld = pItem;
					pItem = (CProjItem *)pItem->GetContainerInSameConfig();
					if (pItemOld != pOptHandler->GetSlob())
						pItemOld->ResetContainerConfig();

					VSASSERT(pItem != (CSlob *)NULL, "No valid container found with P_OutDirs_Target set!");
					gpt = pItem->GetConvertedStrProp(P_OutDirs_Target, strVal);
				}

				// reset the last container we found
				if (pItem != pOptHandler->GetSlob())
					pItem->ResetContainerConfig();

				if (!strVal.IsEmpty())
				{
					// If the output directory doesn't end in a forward slash
					// or a backslash, append one.
					const TCHAR * pchT = (const TCHAR *)strVal + strVal.GetLength();
					pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

					if (*pchT != _T('/') && *pchT != _T('\\'))
						strVal += _T('/');
				}

				strVal += strBase + _TEXT(".tlb") ;
				bstrTlb = strVal;
				spMidlTool->put_TypeLibraryName(bstrTlb);
			}
		}
		// for ODL files, we need to make sure that /h is set or the first time the 
		// user builds, they may get their <projname>.h file overwritten.
		CComBSTR bstrHeader;
		hr2 = spMidlTool->get_HeaderFileName(&bstrHeader);
		if (hr2 != S_OK)
		{
			const CPath* pPath = pFileItem->GetFilePath();
			VSASSERT(pPath != NULL, "File item not initialized properly");
			if (pPath)
			{
				CString strExt = pPath->GetExtension();
				strExt.MakeLower();
				if (strExt == _T(".odl"))
				{
					CString strFile;
					pPath->GetBaseNameString(strFile);
					strFile += _T("_h.h");
					bstrHeader = strFile;
					spMidlTool->put_HeaderFileName(bstrHeader);
				}
			}
		}
		pOptHandler->ResetSlob();
		return TRUE;	// was MIDL tool
	}
	return FALSE;	// was not MIDL tool
}

BOOL CVCProjConvert::DoSpecialUnknownStringProps(IVCToolImpl* pTool, IVCPropertyContainer* pPropContainer,
	COptionHandler* pOptHandler, CProjItem* pFileItem)
{
	// NOTE: linker and MIDL handle the unknown string prop individually
	CComQIPtr<VCCLCompilerTool> spCLTool = pTool;
	if (spCLTool)
		return DoUnknownStringProp(pPropContainer, pOptHandler, pFileItem, VCCLID_AdditionalOptions);

	CComQIPtr<VCLibrarianTool> spLibTool = pTool;
	if (spLibTool)
		return DoUnknownStringProp(pPropContainer, pOptHandler, pFileItem, VCLIBID_AdditionalOptions);

	CComQIPtr<VCResourceCompilerTool> spRCTool = pTool;
	if (spRCTool)
		return DoUnknownStringProp(pPropContainer, pOptHandler, pFileItem, VCRCID_AdditionalOptions);

	CComQIPtr<VCBscMakeTool> spBscTool = pTool;
	if (spBscTool)
		return DoUnknownStringProp(pPropContainer, pOptHandler, pFileItem, VCBSCID_AdditionalOptions);

	return FALSE;
}

BOOL CVCProjConvert::DoUnknownStringProp(IVCPropertyContainer* pPropContainer, COptionHandler* pOptHandler, 
	CProjItem* pFileItem, long nOptionID)
{
	pOptHandler->SetSlob(pFileItem); 
	UINT nIDUnknownOption, nIDUnknownString;
	pOptHandler->GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, OBInherit);
	if (nIDUnknownString != (UINT)-1)
	{
		CProject* pProj = pFileItem->GetProject();
		if (pProj != NULL)
		{
			DoUnknownStringPropHelper(pProj, nIDUnknownString, pPropContainer, nOptionID);
			DoUnknownStringPropHelper(pProj, nIDUnknownOption, pPropContainer, nOptionID);
		}
	}
	pOptHandler->ResetSlob();

	return TRUE;
}

void CVCProjConvert::DoUnknownStringPropHelper(CProjItem* pProjItem, UINT nIDUnknown, IVCPropertyContainer* pPropContainer,
	long nOptionID)
{
	CString strUnknown;
	GPT gptRet = pProjItem->GetConvertedStrProp(nIDUnknown, strUnknown);
	if (gptRet == valid && !strUnknown.IsEmpty())
	{
		CComBSTR bstrUnknown = strUnknown;
		AddAdditionalOptions(pPropContainer, nOptionID, bstrUnknown);
	}
}

typedef struct {
	LPOLESTR	wszToolShortName;
	LPCTSTR		szOldToolName;
} MPNEW2OLDTOOLNAME;

static MPNEW2OLDTOOLNAME srgmpNew2OldToolName[] = {
		L"VCCLCompilerTool", "cl.exe",
		L"VCResourceCompilerTool"	, "rc.exe",
		L"VCLinkerTool"	, "link.exe",
		L"VCMIDLTool"	, "midl.exe",
		L"VCBscMakeTool", "BSC",
		L"VCCustomBuildTool", "cmd.exe",
		L"VCLibrarianTool"	, "lib.exe",
		L"VCPreBuildEventTool", "Pre Build",
		L"VCPreLinkEventTool", "Before the Linker",
		L"VCPostBuildEventTool", "Post Build",
		L"VCLibrarianTool", "link.exe"
};

void CVCProjConvert::SetToolObject(VCConfiguration *pConfig, LPCTSTR szTool, IVCToolImpl **ppTool)
{
	// check to see if default case is ok
	if (pConfig)
	{
		CComPtr<IDispatch> pDispTools;
		CComQIPtr<IVCCollection> pTools;
		pConfig->get_Tools(&pDispTools);
		pTools = pDispTools;
		long lTools;
		pTools->get_Count(&lTools);
		while (lTools > 0)
		{
			CComPtr<IDispatch> pDispTool;
			pTools->Item(CComVariant(lTools), &pDispTool);
			CComQIPtr<IVCToolImpl> pTool = pDispTool;
			if (pTool && IsToolMatch(pTool, szTool, true))
			{
				pTool.CopyTo(ppTool);
				return;
			}
			lTools--;
		}
	}
}

void CVCProjConvert::SetToolObject(VCFileConfiguration *pFileConfig, LPCTSTR szTool, IVCToolImpl **ppTool)
{
	// check to see if default case is ok
	bool bFound = false;
	CComPtr<IDispatch> pDispTool;
	CComQIPtr<IVCToolImpl> pTool;
	*ppTool = NULL;
	if (pFileConfig)
	{
		pFileConfig->get_Tool(&pDispTool);
		pTool = pDispTool;
		if (IsToolMatch(pTool, szTool, false))
		{
			bFound = true;
			pFileConfig->put_Tool(pDispTool);
			pTool.CopyTo(ppTool);
		}
		else
		{
			CString strLinker = _T("link.exe");
			bFound = (strLinker == szTool);
			if (bFound)
				pTool.CopyTo(ppTool);
		}
	}
	if (!bFound) 
	{ // find tool in configs...
		CComQIPtr<IVCFileConfigurationImpl> pFileConfigImpl = pFileConfig;
		if (pFileConfigImpl)
		{
			CComPtr<IDispatch> pDispConfiguration;
			HRESULT hr = pFileConfigImpl->get_Configuration(&pDispConfiguration);
			CComQIPtr<VCConfiguration> pConfiguration = pDispConfiguration;
			if (pConfiguration)
			{
				CComPtr<IDispatch> pDispTools;
				hr = pConfiguration->get_Tools(&pDispTools);
				CComQIPtr<IVCCollection> pTools = pDispTools;
				if (pTools)
				{
					long lcTools;
					pTools->get_Count(&lcTools);
					while (lcTools > 0 && !bFound)
					{
						CComPtr<IDispatch> pDispTool;
						pTools->Item(CComVariant(lcTools), &pDispTool);
						CComQIPtr<IVCToolImpl> pTool = pDispTool;
						if (pTool)
						{
							if (IsToolMatch(pTool, szTool, false))
							{
								bFound = true;
								pFileConfig->put_Tool(pDispTool);
								pDispTool.Release();	// want to reuse
								pFileConfig->get_Tool(&pDispTool);
								CComQIPtr<IVCToolImpl> pToolImpl = pDispTool;
								pToolImpl.CopyTo(ppTool);
							}
						}
						lcTools--;
					}
				}

			}
			
		}
	}
	VSASSERT(bFound, "Failed to find correct tool for file!");
}

BOOL CVCProjConvert::IsToolMatch(IVCToolImpl *pTool, LPCTSTR szTool, bool bLinkerAllowed)
{
	if (!bLinkerAllowed)
	{
		CString strLinker = _T("link.exe");
		if (strLinker == szTool)
			return FALSE;
	}

	if (pTool)
	{
		CComBSTR bstrToolName;
		pTool->get_ToolShortName(&bstrToolName);
		for (int i = 0; i < sizeof(srgmpNew2OldToolName) / sizeof(MPNEW2OLDTOOLNAME); i++)
		{
			if (bstrToolName == srgmpNew2OldToolName[i].wszToolShortName &&  
				_tcscmp(srgmpNew2OldToolName[i].szOldToolName, szTool) == 0)
				return TRUE;
		}
	}
	return FALSE;
}

void CVCProjConvert::SetToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr * pOptStr, CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase)
{

	if (SetCLToolSetting(pTool, pPropContainer, varVal, pOptStr, pProjItem, pOptHandler, bIsBase))
		return;
	if (SetLNKToolSetting(pTool, pPropContainer, varVal, pOptStr, pProjItem, pOptHandler, bIsBase))
		return;
	if (SetLIBToolSetting(pTool, pPropContainer, varVal, pOptStr, pProjItem, pOptHandler))
		return;
	if (SetMIDLToolSetting(pTool, pPropContainer, varVal, pOptStr, pProjItem, pOptHandler, bIsBase))
		return;
	if (SetRCToolSetting(pTool, pPropContainer, varVal, pOptStr, pProjItem, pOptHandler, bIsBase))
		return;
	if (SetBSCToolSetting(pTool, pPropContainer, varVal, pOptStr, pProjItem, pOptHandler))
		return;
}

BOOL CVCProjConvert::SetCLToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr * pOptStr,  CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase)
{
	CComQIPtr<VCCLCompilerTool> pCompiler = pTool;
	if (pCompiler && pPropContainer)
	{
		switch (pOptStr->idOption)
		{
		case IDOPT_CPLRNOLOGO: // IDOPT_CPLRNOLOGO, "nologo%T1", OPTARGS1(P_CplrNoLogo), single,
			SetBoolProperty(pPropContainer, VCCLID_SuppressStartupBanner, varVal.lVal);
			break;
		case IDOPT_MSEXT: // IDOPT_MSEXT, "Z%{e|a}1", OPTARGS1(P_MSExtension), single, 
			SetBoolProperty(pPropContainer, VCCLID_DisableLanguageExtensions, varVal.lVal);	// apears to be stored as bool, not enum...
			break;
		case IDOPT_TURN_OFF_WARNINGS: // IDOPT_TURN_OFF_WARNINGS,	"w%<1>1", OPTARGS1(P_WarningLevel), single,
		case IDOPT_WARN: // IDOPT_WARN, "W%{0|1|2|3|4}1", OPTARGS1(P_WarningLevel), single,
			SetEnumProperty(pPropContainer, VCCLID_WarningLevel, varVal.lVal);
			break;
		case IDOPT_WARNASERROR: // IDOPT_WARNASERROR,	"WX%T1", OPTARGS1(P_WarnAsError), single,
			SetBoolProperty(pPropContainer, VCCLID_WarnAsError, varVal.lVal);
			break;
		case IDOPT_ENABLE_MR: // IDOPT_ENABLE_MR,	"Gm%{-|}1", OPTARGS1(P_Enable_MR), single,
			SetBoolProperty(pPropContainer, VCCLID_MinimalRebuild, EnumIsTrue(varVal.lVal));
			break;
		case IDOPT_ENABLE_INCR: // IDOPT_ENABLE_INCR,	"Gi%{-|}1", OPTARGS1(P_Enable_Incr), single,
			break;	// don't bother converting this one
		case IDOPT_PTRMBR1: // IDOPT_PTRMBR1, "vm%{b|g}1", OPTARGS1(P_PtrMbr1), single,
			SetPtrToMember1(pPropContainer, varVal.lVal);
			break;
		case IDOPT_PTRMBR2: // IDOPT_PTRMBR2, "vm%{v|s|m}1", OPTARGS1(P_PtrMbr2), single,
			SetPtrToMember2(pPropContainer, varVal.lVal);
			break;
		case IDOPT_VTORDISP: // IDOPT_VTORDISP, "vd%{1|0}1", OPTARGS1(P_VtorDisp), single,DisableConstructionDisplacements
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/vd0");	// apears to be stored as bool, not enum...
			break;
		case IDOPT_ENABLE_RTTI: // IDOPT_ENABLE_RTTI,	"GR%{-|}1", OPTARGS1(IDOPT_ENABLE_RTTI), single,
			SetBoolProperty(pPropContainer, VCCLID_RuntimeTypeInfo, varVal.lVal);
			break;
		case IDOPT_DEBUGINFO: // IDOPT_DEBUGINFO,	"Z%{d|7|i|I}1", OPTARGS1(P_DebugInfo), single, 
			SetDebugInfo(pCompiler, varVal.lVal);
			break;
		case IDOPT_OPTIMIZE: // IDOPT_OPTIMIZE, "O%{d|2|1}1", OPTARGS1(P_Optimize), single,
			SetOptimization(pCompiler, varVal.lVal);
			break;
		case IDOPT_OPT_X: // IDOPT_OPT_X, "Ox%T1%<4>2", OPTARGS2(P_Optimize_X, P_Optimize), single,
			SetOptimizeX(pCompiler, varVal.lVal);
			break;
		case IDOPT_OPT_A: // IDOPT_OPT_A, "Oa%T1%<4>2", OPTARGS2(P_Optimize_A, P_Optimize), single, AliasingWithinFunctions
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/Oa");
			break;
		case IDOPT_OPT_W: // IDOPT_OPT_W, "Ow%T1%<4>2", OPTARGS2(P_Optimize_W, P_Optimize), single, AliasingAcrossFunctions
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/ow");
			break;
		case IDOPT_OPT_G: // IDOPT_OPT_G, "Og%T1%<4>2", OPTARGS2(P_Optimize_G, P_Optimize), single, GlobalOptimizations
			SetBoolProperty(pPropContainer, VCCLID_GlobalOptimizations, varVal.lVal);
			break;
		case IDOPT_OPT_I: // IDOPT_OPT_I, "Oi%T1%<4>2", OPTARGS2(P_Optimize_I, P_Optimize), single, EnableIntrinsicFunctions
			SetBoolProperty(pPropContainer, VCCLID_EnableIntrinsicFunctions, varVal.lVal);
			break;
		case IDOPT_OPT_T: // IDOPT_OPT_T, "Ot%T1%<4>2", OPTARGS2(P_Optimize_T, P_Optimize), single,
		case IDOPT_OPT_S: // IDOPT_OPT_S, "Os%T1%<4>2", OPTARGS2(P_Optimize_S, P_Optimize), single, FavorSizeOrSpeed // see favorSizeOrSpeedOption enum
			SetCodeGenFavor(pCompiler, pOptStr->idOption, varVal.lVal);
			break;
		case IDOPT_OPT_P: // IDOPT_OPT_P, "Op%{-|}1", OPTARGS1(P_Optimize_P), single, ImproveFloatingPointConsistency
			SetBoolProperty(pPropContainer, VCCLID_ImproveFloatingPointConsistency, varVal.lVal);
			break;
		case IDOPT_OPT_Y: // IDOPT_OPT_Y, "Oy%{-|}1", OPTARGS1(P_Optimize_Y), single, OmitFramePointers
			SetBoolProperty(pPropContainer, VCCLID_OmitFramePointers, varVal.lVal);
			break;
		case IDOPT_INLINECTRL: // IDOPT_INLINECTRL,	"Ob%{0|1|2}1", OPTARGS1(P_InlineControl), single, InlineFunctionExpansion
			SetEnumProperty(pPropContainer, VCCLID_InlineFunctionExpansion, varVal.lVal);
			break;
		case IDOPT_STRPOOL: // IDOPT_STRPOOL, "G%{f|F}1", OPTARGS1(P_StringPool), single, StringPooling 	// see stringPoolOption enum
			SetStringPooling(pCompiler, varVal.lVal);
			break; 
		case IDOPT_INCLINK: // IDOPT_INCLINK, "Gy%T1", OPTARGS1(P_IncLinking), single,
			SetBoolProperty(pPropContainer, VCCLID_EnableFunctionLevelLinking, varVal.lVal);
			break;
		case IDOPT_CPLRIGNINC: // IDOPT_CPLRIGNINC,	"X%T1", OPTARGS1(P_CplrIgnInCPath), single, IgnoreStandardIncludePath
			SetBoolProperty(pPropContainer, VCCLID_IgnoreStandardIncludePath, varVal.lVal);
			break;
		case IDOPT_CPLRINCLUDES: // IDOPT_CPLRINCLUDES,	"I[ ]%1", OPTARGS1(P_CplrIncludes), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCCLID_AdditionalIncludeDirectories, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_FORCEINCLUDES: // IDOPT_FORCEINCLUDES,	"FI%1", OPTARGS1(P_ForceIncludes), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCCLID_ForcedIncludeFiles, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_UNDEFINE: // IDOPT_UNDEFINE, "u%T1", OPTARGS1(P_Undefine), single,
			SetBoolProperty(pPropContainer, VCCLID_UndefineAllPreprocessorDefinitions, varVal.lVal);
			break;
		case IDOPT_MACROS: // IDOPT_MACROS, "D[ ]%1", OPTARGS1(P_MacroNames), multiple,
			{ // "WIN32,NDEBUG,_WINDOWS,_AFXDLL,_MBCS"
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCCLID_PreprocessorDefinitions, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_UNDEFMACROS: // IDOPT_UNDEFMACROS,	"U[ ]%1", OPTARGS1(P_UndefMacros), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCCLID_UndefinePreprocessorDefinitions, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_LISTASM: // IDOPT_LISTASM, "FA%{%f1%f2|cs%t1%t2|c%t1%f2|s%f1%t2}3",	OPTARGS3(P_AsmListHasMC, P_AsmListHasSrc, P_ListAsm), single,
			SetAsmOptions(pCompiler, pProjItem, pOptHandler, varVal.lVal);
			break;
		case IDOPT_OUTDIR_COD: // IDOPT_OUTDIR_COD,	"Fa%1", OPTARGS1(P_OutputDir_Cod), single, AssemblerListingLocation
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCCLID_AssemblerListingLocation, varVal.bstrVal);
			}
			break;
		case IDOPT_LISTBSCNOLCL: // IDOPT_LISTBSCNOLCL,	"Fr%T1%t2[%3]", OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
		case IDOPT_LISTBSC: // IDOPT_LISTBSC, "FR%T1%f2[%3]", OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
			SetListBsc(pCompiler, pPropContainer, pProjItem, pOptHandler, pOptStr->idOption, varVal.lVal);
			break;
		case IDOPT_PCHNAME: // IDOPT_PCHNAME, "Fp%1", OPTARGS1(P_OutputDir_Pch), single, PrecompiledHeaderFile
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCCLID_PrecompiledHeaderFile, varVal.bstrVal);
			}
			break;
		case IDOPT_AUTOPCH: // IDOPT_AUTOPCH, "YX%T1[%2]", OPTARGS2(P_AutoPch, P_AutoPchUpTo), single,
			SetAutoPCH(pCompiler, pPropContainer, pOptHandler, pProjItem, varVal.lVal);
			break;
		case IDOPT_PCHCREATE: // IDOPT_PCHCREATE,	"Yc%T1[%2]", OPTARGS2(P_PchCreate, P_PchCreateUptoHeader),	single,
			SetCreatePCH(pCompiler, pPropContainer, pOptHandler, pProjItem, varVal.lVal);
			break;
		case IDOPT_PCHUSE: // IDOPT_PCHUSE, "Yu%T1[%2]", OPTARGS2(P_PchUse, P_PchUseUptoHeader), single,
			SetUsePCH(pCompiler, pPropContainer, pOptHandler, pProjItem, varVal.lVal);
			break;
		case IDOPT_OUTDIR_OBJ: // IDOPT_OUTDIR_OBJ,	"Fo%1", OPTARGS1(P_OutputDir_Obj), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCCLID_ObjectFile, varVal.bstrVal);
			}
			break;
		case IDOPT_OUTDIR_PDB: // IDOPT_OUTDIR_PDB,	"Fd%1", OPTARGS1(P_OutputDir_Pdb), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCCLID_ProgramDataBaseFileName, varVal.bstrVal);
			}
			break;
		case IDOPT_STACK_PROBE: // IDOPT_STACK_PROBE,	"Ge%T1", OPTARGS1(P_StackProbe), single, ForceStackCheck
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/Ge");
			break;
		case IDOPT_STACK_PROBE_THOLD: // IDOPT_STACK_PROBE_THOLD,	"Gs%1", OPTARGS1(P_StackProbeTHold), single,
			SetStackCheck(pPropContainer, varVal.lVal);
			break;
		case IDOPT_MAXLEN_EXTNAME: // IDOPT_MAXLEN_EXTNAME, "H%1", OPTARGS1(P_MaxLenExtNames), single,
			break;	// obsolete
		case IDOPT_USECHAR_AS_UNSIGNED: // IDOPT_USECHAR_AS_UNSIGNED,	"J%T1", OPTARGS1(P_UseChasAsUnsigned), single,
			SetBoolProperty(pPropContainer, VCCLID_DefaultCharIsUnsigned, varVal.lVal);
			break;
		case IDOPT_EMBED_STRING: // IDOPT_EMBED_STRING, "V%1", OPTARGS1(P_EmbedString), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				CComBSTR bstrVal = varVal.bstrVal;
				if (bstrVal.Length())
				{
					CComBSTR bstrVal2 = L"/V ";
					bstrVal2 += varVal.bstrVal;
					AddAdditionalOptions(pPropContainer, VCCLID_AdditionalOptions, bstrVal2);
				}
			}
			break;
		case IDOPT_NO_DEFLIB_NAME: // IDOPT_NO_DEFLIB_NAME, "Zl%T1", OPTARGS1(P_NoDefLibNameInObj), single,
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/Z1");
			break;
		case IDOPT_PREP_COMMENTS: // IDOPT_PREP_COMMENTS, "C%T1", OPTARGS1(P_PrepPreserveComments), single,
			SetBoolProperty(pPropContainer, VCCLID_KeepComments, varVal.lVal);
			break;
		case IDOPT_PREPROCESS_WO_LINES: // IDOPT_PREPROCESS_WO_LINES,	"EP%T1", OPTARGS1(P_PreprocessWOLines), single,
		case IDOPT_PREPROCESS: // IDOPT_PREPROCESS, "E%T1", OPTARGS1(P_Preprocess), single,
			SetPreprocess1(pCompiler, pOptStr->idOption, varVal.lVal);
			break;
		case IDOPT_PREPROCESS_TO_FILE: // IDOPT_PREPROCESS_TO_FILE,	"P%T1", OPTARGS1(P_PrepprocessToFile), single,
			SetPreprocess2(pCompiler, pProjItem, varVal.lVal);
			break;
		case IDOPT_ENABLE_FD: // IDOPT_ENABLE_FD,	"FD%{-|}1", OPTARGS1(P_Enable_FD), single,
			break;	// user isn't allowed to unset this...
		case IDOPT_ENABLE_FC: // IDOPT_ENABLE_FC, "FC%T1", OPTARGS1(P_Enable_FC), single,
			// Don't want /FC to be in the property set, but carry it forward if the user had it
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/FC");
			break;
		case IDOPT_COM_EmitMergedSource: // IDOPT_COM_EmitMergedSource,	"Fx%T1", OPTARGS1(P_COM_EmitMergedSource), single,
			SetBoolProperty(pPropContainer, VCCLID_ExpandAttributedSource, varVal.lVal);
			break;

		case IDOPT_STACKSIZE: // IDOPT_STACKSIZE, "F%1", OPTARGS1(P_StackSize), single,
			break;
		case IDOPT_ENABLE_DLP: // IDOPT_ENABLE_DLP, "dlp%{-|}1",	OPTARGS1(P_Enable_dlp), single,
			// Don't want this to be in the property set, but carry it forward if the user had it
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/dlp");
			break;
		case IDOPT_GEN_FUNC_PROTO: // IDOPT_GEN_FUNC_PROTO, "Zg%T1", OPTARGS1(P_GenFuncProto), single,
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/Zg");
			break;
		case IDOPT_CHECK_SYNTAX: // IDOPT_CHECK_SYNTAX, "Zs%T1", OPTARGS1(P_CheckSyntax), single,
			AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, varVal.lVal, L"/Zs");
			break;
		case IDOPT_UNKNOWN_OPTION: //  IDOPT_UNKNOWN_OPTION,	"", NO_OPTARGS, single, PostMiscellaneous
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				AddAdditionalOptions(pPropContainer, VCCLID_AdditionalOptions, varVal.bstrVal);
			}
			break;
		case IDOPT_COMPILE_ONLY: // IDOPT_COMPILE_ONLY,	"c%T1", OPTARGS1(P_CompileOnly), single,
			break;	// don't care WHAT the user sets this to, we're throwing it anyway...
		case IDOPT_TREATFILEAS_CPP1: // IDOPT_TREATFILEAS_CPP1,	"Tp%T1", OPTARGS1(P_TreatFileAsCPP1), single,	
		case IDOPT_TREATFILEAS_CPP2: // IDOPT_TREATFILEAS_CPP2,	"TP%T1", OPTARGS1(P_TreatFileAsCPP2), single,	
		case IDOPT_TREATFILEAS_C1: // IDOPT_TREATFILEAS_C1,	"Tc%T1", OPTARGS1(P_TreatFileAsC1), single,
		case IDOPT_TREATFILEAS_C2: // IDOPT_TREATFILEAS_C2,	"TC%T1", OPTARGS1(P_TreatFileAsC2), single,
			SetTreatFileAs(pCompiler, pOptStr->idOption, varVal.lVal);
			break;
		case IDOPT_COM_HresultKnowledge: // IDOPT_COM_HresultKnowledge,	"noHRESULT%{|-}1",	OPTARGS1(P_COM_HresultKnowledge),	single,
			// SetBoolProperty(pPropContainer, VCCLID_SuppressIntrinsicHRESULTSupport, EnumIsTrue(varVal.lVal), TRUE /* flip it*/);	 -- no longer supported
			break;
 		case IDOPT_CPUX86: // IDOPT_CPUX86, "G%{3|4|5|6|B}1", OPTARGS1(P_Cpux86), single, // OptimizeForProcessor see ProcessorOptimizeOption enum
			SetProcOptimize(pCompiler, varVal.lVal);
			break;
		case IDOPT_CALLCONV_ALPHA: // IDOPT_CALLCONV_ALPHA,	"G%{d}1", OPTARGS1(P_CallConvAlpha), single,
		case IDOPT_CALLCONV_MERCED: // IDOPT_CALLCONV_MERCED,	"G%{d}1", OPTARGS1(P_CallConvMerced), single,
		case IDOPT_CALLCONV: // IDOPT_CALLCONV, "G%{d|r|z}1", OPTARGS1(P_CallConv), single, CallingConvention // see callingConventionOption enum
			SetCallConvention(pCompiler, varVal.lVal);
			break;
		case IDOPT_GZ: // IDOPT_GZ, "GZ%T1", OPTARGS1(P_GZ), single, Enable runtime checks (/RTC1)
			SetRuntimeChecks(pCompiler, varVal.lVal, runtimeBasicCheckAll);
			break;
		case IDOPT_BYTE_MERCED: // IDOPT_BYTE_MERCED,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignMerced), single,
		case IDOPT_BYTE_ALPHA: // IDOPT_BYTE_ALPHA,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignAlpha), single,
		case IDOPT_BYTE: // IDOPT_BYTE, "Zp%{2|4|8|16|[1]}1", OPTARGS1(P_ByteAlign), single, StructMemberAlignment see structMemberAlignOption enum
			SetByteAlign(pCompiler, varVal.lVal);
			break;
		case IDOPT_THREAD_MERCED: // IDOPT_THREAD_MERCED,	"M%{L|T|D}1", OPTARGS1(P_ThreadMerced), single,
		case IDOPT_THREAD_ALPHA: // IDOPT_THREAD_ALPHA,	"M%{L|T|D}1", OPTARGS1(P_ThreadAlpha), single,
			if (varVal.lVal)
				varVal.lVal += 3;
			// fall through
		case IDOPT_THREAD: // IDOPT_THREAD, "M%{Ld|Td|Dd|L|T|D}1",	OPTARGS1(P_Thread), single, RuntimeLibrary runtimeLibraryOption
			SetRuntimeLib(pCompiler, varVal.lVal);
			break;

		case IDOPT_FLOATPOINT: // IDOPT_FLOATPOINT,	"FP%{i87|i|a|c87|c}1", OPTARGS1(P_FloatPoint), single,
			break;	// nuke obsolete compiler option now...

// run-time checks
		case IDOPT_ENABLE_EH: // IDOPT_ENABLE_EH,	"GX%{-|}1", OPTARGS1(P_Enable_EH), single,  enables synchronous exception 
			SetOldEH(pCompiler, varVal.lVal);
			break;
		case IDOPT_CPP_RTC: // IDOPT_CPP_RTC, "RTC%{1|2}1", OPTARGS1(P_RTC), single,	
			SetRuntimeChecks(pCompiler, varVal.lVal, runtimeBasicCheckAll);
			break;
		case IDOPT_CPP_RTC_StackFrame: // IDOPT_CPP_RTC_StackFrame,	"RTCs%T1%<3>2", OPTARGS2(P_RTC_StackFrame, P_RTC),	single, 
			SetRuntimeChecks(pCompiler, varVal.lVal, runtimeCheckStackFrame);
			break;
		case IDOPT_CPP_RTC_MemoryAccess: // IDOPT_CPP_RTC_MemoryAccess,	"RTCm%T1%<3>2", OPTARGS2(P_RTC_MemoryAccess, P_RTC),	single,
			break;	// option does not exist in VC7 compiler
		case IDOPT_CPP_RTC_MemoryLeaks: // IDOPT_CPP_RTC_MemoryLeaks,	"RTCl%T1%<3>2", OPTARGS2(P_RTC_MemoryLeaks, P_RTC),	single,
			break;	// option does not exist in VC7 compiler
		case IDOPT_CPP_RTC_SmallerType: // IDOPT_CPP_RTC_SmallerType,	"RTCc%T1%<3>2", OPTARGS2(P_RTC_SmallerType, P_RTC),	single,	
			SetBoolProperty(pPropContainer, VCCLID_SmallerTypeCheck, varVal.lVal);
			break;
		case IDOPT_CPP_RTC_VectorNew: // IDOPT_CPP_RTC_VectorNew,	"RTCv%T1%<3>2", OPTARGS2(P_RTC_VectorNew, P_RTC),	single,	
			break;	// option does not exist in VC7 compiler
		case IDOPT_GTVALUE_MERCED: // IDOPT_GTVALUE_MERCED, "Gt%1", OPTARGS1(P_GtvalueMerced), single,
		case IDOPT_GTVALUE_ALPHA: // IDOPT_GTVALUE_ALPHA, "Gt%1", OPTARGS1(P_GtvalueAlpha), single,
			break;	// option does not exist in VC7 compiler (Intel only)
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CVCProjConvert::SetLNKToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr * pOptStr, CProjItem *pProjItem, COptionHandler *pOptHandler, bool bIsBase)
{
	CComQIPtr<VCLinkerTool> pLinker = pTool;
	if (pLinker)
	{
		if (pProjItem->IsKindOf(RUNTIME_CLASS(CFileItem)))	// no switches to translate for files associated with the linker...
			return TRUE;

		switch (pOptStr->idOption)
		{
		case IDOPT_UNKNOWN_STRING: //  IDOPT_UNKNOWN_STRING,	"", NO_OPTARGS, single,
			{
				CStringW strUnknownW = varVal.bstrVal, strSeparator = L" ";
				RemoveMultiples(strUnknownW, strSeparator);
				CComBSTR bstrUnknown = strUnknownW;
				SetStrProperty(pPropContainer, VCLINKID_AdditionalDependencies, bstrUnknown);
			}
			break;
		case IDOPT_LINKNOLOGO: //  IDOPT_LINKNOLOGO,	"nologo%T1", OPTARGS1(P_LinkNoLogo), single,
			SetBoolProperty(pPropContainer, VCLINKID_SuppressStartupBanner, varVal.lVal);
			break;
		case IDOPT_DERIVED_OPTHDLR: //  IDOPT_DERIVED_OPTHDLR,	"", NO_OPTARGS, single,
			break;
		case IDOPT_LINKVERBOSE: //  IDOPT_LINKVERBOSE,	"verbose%T1", OPTARGS1(P_LinkVerbose), single, // ShowProgress  see linkProgressOption enum
			SetLinkShowProgress(pLinker, varVal.lVal);
			break;
		case IDOPT_DLLGEN: //  IDOPT_DLLGEN, "dll%T1", OPTARGS1(P_GenDll), single,
			SetBoolProperty(pPropContainer, VCLINKID_LinkDLL, varVal.lVal);
			break;
		case IDOPT_PROFILE: //  IDOPT_PROFILE, "profile%T1", OPTARGS1(P_Profile), single,
			break;	// option has been deprecated
		case IDOPT_USEPDBNONE: //  IDOPT_USEPDBNONE,	"pdb: // none%F1", OPTARGS1(P_UsePDB), single,
			break;	// PDB:NONE no longer supported
		case IDOPT_INCREMENTALLINK: //  IDOPT_INCREMENTALLINK, "incremental: // %{no|yes}1",	OPTARGS1(P_IncrementalLink), single,
			SetLinkIncremental(pLinker, EnumIsTrue(varVal.lVal));
			break;
		case IDOPT_USEPDB: //  IDOPT_USEPDB, "pdb: // %T1%2", OPTARGS2(P_UsePDB, P_UsePDBName), single,
			SetUsePDB(pPropContainer, pProjItem, pOptHandler, varVal.lVal);
			break;
		case IDOPT_MAPGEN: //  IDOPT_MAPGEN, "m[ap]%T1[: // %2]", OPTARGS2(P_GenMap, P_MapName), single,
			SetMapGen(pPropContainer, pProjItem, pOptHandler, varVal.lVal);
			break;
		case IDOPT_DEBUG: //  IDOPT_DEBUG, "debug%T1", OPTARGS1(P_GenDebug), single,
			SetBoolProperty(pPropContainer, VCLINKID_GenerateDebugInformation, varVal.lVal);
			break;
		case IDOPT_DEBUGTYPE: //  IDOPT_DEBUGTYPE,	"debugtype: // %{cv|coff|both}1",	OPTARGS1(P_DebugType), single,
			break;	// obsolete property

		case IDOPT_SUBSYSTEM: // IDOPT_SUBSYSTEM,	"subsystem:%{windows|console}1",OPTARGS1(P_SubSystem), single, SubSystem see subSystemOption enum
			SetLinkerSubSystem(pPropContainer, varVal.lVal);
			break;
		case IDOPT_MACHINETYPE: //  IDOPT_MACHINETYPE, "machine: // %{I386|IX86|M68K|ALPHA|MPPC}1",	OPTARGS1(P_MachineType),	single,
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal == 1 ? 2 : 1, L"/MACHINE:I386");
			break;
		case IDOPT_LARGEADDRESS:	// IDOPT_LARGEADDRESS,	"largeaddressaware%{:no|}1", OPTARGS(P_LargeAddress), single,
			SetLinkerLargeAddressAwareness(pPropContainer, varVal.lVal);
			break;
		case IDOPT_NODEFAULTLIB: //  IDOPT_NODEFAULTLIB,	"nod[efaultlib]: // %1", OPTARGS1(P_NoDefaultLibs), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCLINKID_IgnoreDefaultLibraryNames, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_EXALLLIB: //  IDOPT_EXALLLIB, "nod[efaultlib]%T1", OPTARGS1(P_ExAllLibs), single,
			SetBoolProperty(pPropContainer, VCLINKID_IgnoreAllDefaultLibraries, varVal.lVal);
			break;
		case IDOPT_INCLUDESYM: //  IDOPT_INCLUDESYM,	"include: // %1", OPTARGS1(P_IncludeSym), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCLINKID_ForceSymbolReferences, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_DEFNAME: //  IDOPT_DEFNAME, "def: // %1", OPTARGS1(P_DefName), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_ModuleDefinitionFile, varVal.bstrVal);
			}
			break;
		case IDOPT_FORCE: //  IDOPT_FORCE, "force%T1", OPTARGS1(P_Force), single,
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal, L"/FORCE");
			break;
		case IDOPT_OUT: //  IDOPT_OUT, "out: // %1", OPTARGS1(P_OutName), single,	
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_OutputFile, varVal.bstrVal);
			}
			break;
		case IDOPT_IMPLIB: //  IDOPT_IMPLIB, "implib: // %1", OPTARGS1(P_ImpLibName), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_ImportLibrary, varVal.bstrVal);
			}
			break;
		case IDOPT_LAZYPDB: //  IDOPT_LAZYPDB, "pdbtype: // %{sept|con}1", OPTARGS1(P_LazyPdb), single,  UseSeparateTypes
			break;	// this switch is going away in VC7
		case IDOPT_LIBPATH: //  IDOPT_LIBPATH, "libpath: // %1", OPTARGS1(P_LibPath), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCLINKID_AdditionalLibraryDirectories, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_DELAY_NOBIND: //  IDOPT_DELAY_NOBIND,	"delay: // nobind%T1", OPTARGS1(P_LinkDelayNoBind), single,	
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal, L"/DELAY:NOBIND");
			break;
		case IDOPT_DELAY_UNLOAD: //  IDOPT_DELAY_UNLOAD,	"delay: // unload%T1", OPTARGS1(P_LinkDelayUnLoad), single,	
			SetBoolProperty(pPropContainer, VCLINKID_SupportUnloadOfDelayLoadedDLL, varVal.lVal);
			break;
		case IDOPT_RESONLY_DLL:	//	IDOPT_RESONLY_DLL,	"noentry%T1", OPTARGS1(P_ResOnlyDLL), single,
			SetBoolProperty(pPropContainer, VCLINKID_ResourceOnlyDLL, varVal.lVal);
			break;
		case IDOPT_DELAY_LOAD_DLL: //  IDOPT_DELAY_LOAD_DLL,"delayload: // %1", OPTARGS1(P_LinkDelayLoadDLL), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCLINKID_DelayLoadDLLs, varVal.bstrVal, bIsBase);
			}
			break; 
		case IDOPT_VIRTUAL_DEVICE_DRIVER:	//	IDOPT_VIRTUAL_DEVICE_DRIVER, "vxd%T1", OPTARGS1(P_VirtualDeviceDriver), single,
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal, L"/VXD");
			break;
		case IDOPT_EXE_DYNAMIC:	// IDOPT_EXE_DYNAMIC, "exetype:dynamic%T1",	OPTARGS1(P_ExeDynamic),	single,
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal, L"/EXETYPE:DYNAMIC");
			break;
		case IDOPT_DRIVER:	//	IDOPT_DRIVER, "driver%{:junk||:uponly|:wdm}%1", OPTARGS1(P_Driver), single,
			SetLinkerDriver(pPropContainer, varVal.lVal);
			break;
		case IDOPT_50COMPAT:	// 	IDOPT_50COMPAT, "link50compat%T1", OPTARGS(P_Link50Compat),	single,
			break;	// don't bother to convert
		case IDOPT_ALIGN:	// IDOPT_ALIGN,	"align:%1",	OPTARGS(P_Align), single,
			SetLinkerAlign(pPropContainer, varVal.lVal);
			break;
		case IDOPT_SET_CHECKSUM:	// IDOPT_SET_CHECKSUM, "release%T1", OPTARGS(P_SetCheckSum), single,
			SetBoolProperty(pPropContainer, VCLINKID_SetChecksum, varVal.lVal);
			break;
		case IDOPT_MERGE_SECTIONS:	//	IDOPT_MERGE_SECTIONS, "merge:%1", OPTARGS(P_MergeSections), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_MergeSections, varVal.bstrVal);
			}
			break;
		case IDOPT_ORDER_FUNCS:	//	IDOPT_ORDER_FUNCS, "order:%1", OPTARGS(P_OrderFuncs), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_FunctionOrder, varVal.bstrVal);
			}
			break;
		case IDOPT_TRIM_PROC_MEM:	// IDOPT_TRIM_PROC_MEM, "ws:aggressive%T1", OPTARGS(P_TrimProcMem), single,
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal, L"/WS:AGGRESSIVE");
			break;
		case IDOPT_FIXED:	// IDOPT_FIXED,	"fixed%{:no|}1", OPTARGS1(P_Fixed), single,
			SetLinkerFixed(pPropContainer, varVal.lVal);
			break;
		case IDOPT_UNKNOWN_OPTION: //  IDOPT_UNKNOWN_OPTION,	"", NO_OPTARGS, single, PostMiscellaneous
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				AddAdditionalOptions(pPropContainer, VCLINKID_AdditionalOptions, varVal.bstrVal);
			}
			break;
		case IDOPT_EXE_BASE: // IDOPT_EXE_BASE, "base:%1", OPTARGS1(P_BaseAddr), single, BaseAddress
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_BaseAddress, varVal.bstrVal);
			}
			break; 
		case IDOPT_PREVENT_BIND:	// IDOPT_PREVENT_BIND, "allowbind%{|:no}1", OPTARGS1(P_PreventBind), single,
			AddExtraOption(pPropContainer, VCLINKID_AdditionalOptions, varVal.lVal, L"/ALLOWBIND:NO");
			break;
		case IDOPT_VERSION: // IDOPT_VERSION, "version:%1[.%2]", OPTARGS2(P_VersionMaj, P_VersionMin),	single, MajorVersion.MinorVersion
			SetLinkerVersion(pPropContainer, pProjItem, pOptHandler, varVal.lVal);
			break;
		case IDOPT_STACK: // IDOPT_STACK, "st[ack]:%1[,%2]", OPTARGS2(P_StackReserve, P_StackCommit),single, StackReserveSize
			{
				varVal.ChangeType(VT_I4);
				SetIntProperty(pPropContainer, VCLINKID_StackReserveSize, varVal.lVal);
				int i;
				if (pProjItem->GetIntProp(pOptHandler->MapLogical(P_StackCommit), i) == valid)
					SetIntProperty(pPropContainer, VCLINKID_StackCommitSize, i);
			}
			break;
		case IDOPT_HEAP: // IDOPT_HEAP, "st[ack]:%1[,%2]", OPTARGS2(P_HeapReserve, P_HeapCommit),single, HeapReserveSize
			{
				varVal.ChangeType(VT_I4);
				SetIntProperty(pPropContainer, VCLINKID_HeapReserveSize, varVal.lVal);
				int i;
				if (pProjItem->GetIntProp(pOptHandler->MapLogical(P_HeapCommit), i) == valid)
					SetIntProperty(pPropContainer, VCLINKID_HeapCommitSize, i);
			}
			break;
		case IDOPT_ENTRYPOINT: // IDOPT_ENTRYPOINT,	"entry:%1", OPTARGS1(P_EntryName), single, EntryPointSymbol
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLINKID_EntryPointSymbol, varVal.bstrVal);
			}
			break;
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CVCProjConvert::SetLIBToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr* pOptStr,  CProjItem* pProjItem, COptionHandler* pOptHandler)
{
	CComQIPtr<VCLibrarianTool> pLibrarian = pTool;
	if (pLibrarian)
	{
		switch (pOptStr->idOption)
		{
		case IDOPT_UNKNOWN_STRING: // IDOPT_UNKNOWN_STRING,	"", NO_OPTARGS, single,
			AddAdditionalOptions(pPropContainer, VCLIBID_AdditionalOptions, varVal.bstrVal);
			break;
		case IDOPT_LIBNOLOGO: // IDOPT_LIBNOLOGO, "nologo%T1", OPTARGS1(P_NoLogoLib), single,
			SetBoolProperty(pPropContainer, VCLIBID_SuppressStartupBanner, varVal.lVal);
			break;
		case IDOPT_DEFLIB: // IDOPT_DEFLIB, "def:%1", OPTARGS1(P_DefNameLib), single, ModuleDefinitionFile
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLIBID_ModuleDefinitionFile, varVal.bstrVal);
			}
			break;
		case IDOPT_OUTLIB: // IDOPT_OUTLIB, "out:%1", OPTARGS1(P_OutNameLib), single,	
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCLIBID_OutputFile, varVal.bstrVal);
			}
			break;
		case IDOPT_UNKNOWN_OPTION: //  IDOPT_UNKNOWN_OPTION,	"", NO_OPTARGS, single, PostMiscellaneous
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				AddAdditionalOptions(pPropContainer, VCLIBID_AdditionalOptions, varVal.bstrVal);
			}
			break;
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CVCProjConvert::SetMIDLToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr* pOptStr, CProjItem* pProjItem, COptionHandler* pOptHandler, bool bIsBase)
{
	CComQIPtr<VCMidlTool> pMidl = pTool;
	if (pMidl)
	{
		switch (pOptStr->idOption)
		{
		case IDOPT_MTLNOLOGO: // IDOPT_MTLNOLOGO, "nologo%T1", OPTARGS1(P_MTLNologo), single,
			SetBoolProperty(pPropContainer, VCMIDLID_SuppressStartupBanner, varVal.lVal);
			break;
		case IDOPT_MTLINCLUDES: // IDOPT_MTLINCLUDES, "I[ ]%1", OPTARGS1(P_MTLIncludes), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCMIDLID_AdditionalIncludeDirectories, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_MTLDLLDATA: // IDOPT_MTLDLLDATA, "dlldata[ ]%1", OPTARGS1(P_MTLDllData), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCMIDLID_DLLDataFileName, varVal.bstrVal);
			}
			break;
		case IDOPT_MTLMACROS: // IDOPT_MTLMACROS, "D[ ]%1", OPTARGS1(P_MTLMacros), multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCMIDLID_PreprocessorDefinitions, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_MTLOUTPUTTLB: // IDOPT_MTLOUTPUTTLB, "tlb[ ]%1", OPTARGS1(P_MTLOutputTlb), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCMIDLID_TypeLibraryName, varVal.bstrVal, (bIsBase == false));
			}
			break;
		case IDOPT_MTLOUTPUTINC: // IDOPT_MTLOUTPUTINC, "h[ ]%1", OPTARGS1(P_MTLOutputInc), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCMIDLID_HeaderFileName, varVal.bstrVal);
			}
			break;
		case IDOPT_MTLOUTPUTUUID: // IDOPT_MTLOUTPUTUUID,	"iid[ ]%1", OPTARGS1(P_MTLOutputUuid), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCMIDLID_InterfaceIdentifierFileName, varVal.bstrVal);
			}
			break;
		case IDOPT_MTLOUTPUTDIR: // IDOPT_MTLOUTPUTDIR, "out[ ]%1", OPTARGS1(P_MTLOutputDir), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMidlOutput(pPropContainer, VCMIDLID_OutputDirectory, varVal.bstrVal);
			}
			break;
		case IDOPT_MTLMTLCOMPATIBLE: // IDOPT_MTLMTLCOMPATIBLE,	"mktyplib203%T1",	OPTARGS1(P_MTLMtlCompatible), single,
			SetBoolProperty(pPropContainer, VCMIDLID_MkTypLibCompatible, varVal.lVal);
			break;
		case IDOPT_MTL_STUBLESS_PROXY: // IDOPT_MTL_STUBLESS_PROXY,	"Oicf%T1", OPTARGS1(P_MTLStublessProxy),	single,
			SetMidlStublessProxy(pPropContainer, varVal.lVal);
			break;
		case IDOPT_MTLNOCLUTTER: // IDOPT_MTLNOCLUTTER, "o[ ]%1", OPTARGS1(P_MTLNoClutter), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMidlOutput(pPropContainer, VCMIDLID_RedirectOutputAndErrors, varVal.bstrVal);
			}
			break;
		case IDOPT_UNKNOWN_OPTION: //  IDOPT_UNKNOWN_OPTION,	"", NO_OPTARGS, single, PostMiscellaneous
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				AddAdditionalOptions(pPropContainer, VCMIDLID_AdditionalOptions, varVal.bstrVal);
			}
			break;
		case IDOPT_MTL_CHAR: // IDOPT_MTL_CHAR, "char %{signed|ascii7|unsigned}1",	OPTARGS1(P_MTL_Char),	single, DefaultCharType	// see midlCharOption enum
			SetMidlChar(pPropContainer, varVal.lVal);
			break;
		case IDOPT_MTL_CLIENT: // IDOPT_MTL_CLIENT, "client %{stub|none}1",	OPTARGS1(P_MTL_Client), single, Client
			SetMidlClient(pPropContainer, varVal.lVal);
			break;
		case IDOPT_MTL_SERVER: // IDOPT_MTL_SERVER, "server %{stub|none}1",	OPTARGS1(P_MTL_Server), single, Server
			SetMidlServer(pPropContainer, varVal.lVal);
			break;
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CVCProjConvert::SetRCToolSetting(IVCToolImpl *pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr* pOptStr, CProjItem* pProjItem, COptionHandler* pOptHandler, bool bIsBase)
{
	CComQIPtr<VCResourceCompilerTool> pResourceCompiler = pTool;
	if (pResourceCompiler)
	{
		switch (pOptStr->idOption)
		{
		case IDOPT_RESLANGID: // IDOPT_RESLANGID, "l[ ]%1",	OPTARGS1(P_ResLangID), single,
			SetIntProperty(pPropContainer, VCRCID_Culture, varVal.lVal);
			break;
		case IDOPT_RESVERBOSE: // IDOPT_RESVERBOSE, "v%T1", OPTARGS1(P_ResVerbose), single,
			SetBoolProperty(pPropContainer, VCRCID_ShowProgress, varVal.lVal);
			break;
		case IDOPT_RESIGNINC: // IDOPT_RESIGNINC, "x%T1", OPTARGS1(P_ResIgnInCPath), single,
			SetBoolProperty(pPropContainer, VCRCID_IgnoreStandardIncludePath, varVal.lVal);
			break;
		case IDOPT_OUTDIR_RES: // IDOPT_OUTDIR_RES, "fo%1", OPTARGS1(P_OutNameRes), single, ResFileName
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCRCID_ResourceOutputFileName, varVal.bstrVal);
			}
			break;
		case IDOPT_RESINCLUDES: // IDOPT_RESINCLUDES, "i[ ]%1",	OPTARGS1(P_ResIncludes),	multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCRCID_AdditionalIncludeDirectories, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_RESMACROS: // IDOPT_RESMACROS, "d[ ]%1",	OPTARGS1(P_ResMacroNames),	multiple,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetMultiStrProperty(pPropContainer, VCRCID_PreprocessorDefinitions, varVal.bstrVal, bIsBase);
			}
			break;
		case IDOPT_UNKNOWN_OPTION: //  IDOPT_UNKNOWN_OPTION,	"", NO_OPTARGS, single, PostMiscellaneous
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				AddAdditionalOptions(pPropContainer, VCRCID_AdditionalOptions, varVal.bstrVal);
			}
			break;
		case IDOPT_UNKNOWN_STRING: // IDOPT_UNKNOWN_STRING,	"", NO_OPTARGS, single,
			AddAdditionalOptions(pPropContainer, VCRCID_AdditionalOptions, varVal.bstrVal);
			break;
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CVCProjConvert::SetBSCToolSetting(IVCToolImpl* pTool, IVCPropertyContainer* pPropContainer,
	CComVariant& varVal, COptStr* pOptStr,  CProjItem* pProjItem, COptionHandler* pOptHandler)
{
	CComQIPtr<VCBscMakeTool> pBscMake = pTool;
	if (pBscMake && pPropContainer)
	{
		switch (pOptStr->idOption)
		{
		case IDOPT_BSCMAKE_NOLOGO: // IDOPT_BSCMAKE_NOLOGO,	"nologo%T1", OPTARGS1(P_BscMakeNoLogo), single,
			SetBoolProperty(pPropContainer, VCBSCID_SuppressStartupBanner, varVal.lVal);
			break;
		case IDOPT_BSCMAKE_INCUNREF: // IDOPT_BSCMAKE_INCUNREF,	"Iu%T1", OPTARGS1(P_InclUnref), single,
			AddExtraOption(pPropContainer, VCBSCID_AdditionalOptions, varVal.lVal, L"/Iu");
			break;
		case IDOPT_BSCMAKE_OUTNAME: // IDOPT_BSCMAKE_OUTNAME,	"o%1", OPTARGS1(P_BscMakeOutputFilename), single,
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				SetStrProperty(pPropContainer, VCBSCID_OutputFile, varVal.bstrVal);
			}
			break;
		case IDOPT_UNKNOWN_OPTION: //  IDOPT_UNKNOWN_OPTION,	"", NO_OPTARGS, single, PostMiscellaneous
			{
				VSASSERT(varVal.vt == VT_BSTR, "String expected");
				AddAdditionalOptions(pPropContainer, VCBSCID_AdditionalOptions, varVal.bstrVal);
			}
			break;
		}
		return TRUE;
	}
	return FALSE;
}

BOOL CVCProjConvert::AddCustomBuildEventItem(CProjItem *pItem, VCConfiguration *pConfiguration)
{
	if (pConfiguration == NULL)
		return FALSE;

	CProjItem *pProjItem = (CProjItem *)pItem;
	OptBehaviour optbehOld = pProjItem->GetOptBehaviour();
	pProjItem->SetOptBehaviour((OptBehaviour)(optbehOld & ~OBInherit));	// do NOT inherit custom step values from config!

	CString strCommand;
	BOOL bExcludedFromBuild;
	CString strDescription;
	CString strBuildTime;

	pItem->GetConvertedStrProp(P_ItemCustomBuildTime, strBuildTime);
	pItem->GetConvertedStrProp(P_CustomDescription, strDescription);
	pItem->GetConvertedStrProp(P_CustomCommand, strCommand);
	pItem->GetIntProp(P_ItemExcludedFromBuild, bExcludedFromBuild);

	CComPtr<IVCToolImpl> pTool;
	SetToolObject(pConfiguration, strBuildTime, &pTool);
	CComQIPtr<IVCBuildEventToolInternal> pBuildEventTool = pTool;
	VSASSERT(pBuildEventTool, "Failed to set desired build event tool on config!");
	if (pBuildEventTool)
	{
		if (!strCommand.IsEmpty())
			pBuildEventTool->put_CommandLineInternal(CComBSTR(strCommand));
		if (!strDescription.IsEmpty())
			pBuildEventTool->put_DescriptionInternal(CComBSTR(strDescription));
		pBuildEventTool->put_ExcludedFromBuildInternal(bExcludedFromBuild ? VARIANT_TRUE : VARIANT_FALSE);
	}

	pProjItem->SetOptBehaviour(optbehOld);
	return TRUE;
}

BOOL CVCProjConvert::AddCustomBuildItem(CProjItem *pItem, VCCustomBuildTool* pCustomBuildTool, VCFileConfiguration *pFileConfig, VCConfiguration *pConfig)
{// P_CustomDescription P_CustomCommand
	if ((pFileConfig || pConfig) && pItem && pCustomBuildTool)
	{
		CString strDescription;
		CString strCustomCommand;
		CString strOutputs;
		CString strInputs;

		pItem->GetConvertedStrProp(P_CustomDescription, strDescription);
		pItem->GetConvertedStrProp(P_CustomCommand, strCustomCommand);
		CCustomBuildTool::ConvertCustomBuildStrProp(pItem, P_CustomOutputSpec, strOutputs);
		CCustomBuildTool::ConvertCustomBuildStrProp(pItem, P_UserDefinedDeps, strInputs);

		if (!strCustomCommand.IsEmpty())
			pCustomBuildTool->put_CommandLine(CComBSTR(strCustomCommand));
		if (!strDescription.IsEmpty())
			pCustomBuildTool->put_Description(CComBSTR(strDescription));
		if (!strOutputs.IsEmpty())
			pCustomBuildTool->put_Outputs(CComBSTR(strOutputs));
		if (!strInputs.IsEmpty())
			pCustomBuildTool->put_AdditionalDependencies(CComBSTR(strInputs));
	}
	return FALSE;
}


bool CVCProjConvert::GetConfigName(CString& strTargetName, CString& strConfigName, BOOL bFileConfig /* = FALSE */)
{
	CString strPlatformName;
	strConfigName.Empty();
	// strTargetName is in form : "<projectname> - <platform-name> <configuration>"
	int i, j;
	i = strTargetName.Find(_T(" - "));
	if (i > 0)
	{
		j = strTargetName.Find(_T(" "), i+3);
		if (j > 0)
		{
			strPlatformName = strTargetName.Mid(i + 3, j - i - 3);
			strConfigName = strTargetName.Mid(j+1);
			// pull out any (80x86) we may find since this is the default, anyway
			j = strConfigName.Find(_T("(80x86)"));
			if (j >= 0)
			{
				if (j == 0)	// found it on the left
				{
					strConfigName = strConfigName.Right(strConfigName.GetLength()-7);
					strConfigName.TrimLeft();
				}
				else if (j == (strConfigName.GetLength()-7))	// found it on the right
				{
					strConfigName = strConfigName.Left(strConfigName.GetLength()-7);
					strConfigName.TrimRight();
				}
				else	// found it in the middle
				{
					CString strLeft, strRight;
					strLeft = strConfigName.Left(j-1);
					strLeft.TrimRight();
					strRight = strConfigName.Right(strConfigName.GetLength()-j-7);
					strRight.TrimLeft();
					strConfigName = strLeft;
					strConfigName += _T(" ");
					strConfigName += strRight;
				}
			}
			if (bFileConfig)
			{
				CString strT;

				strT = strConfigName;
				strT += _T("|");
				strT += strPlatformName;
				strConfigName = strT;
			}
		}
		return true;
	}
	else	// must be early version of product, say, 2.0, where format is <platform> <config>
	{
		if (!SplitOutV2ConfigName(IDS_V2_WIN32X86_PLATFORM, strTargetName, strConfigName, bFileConfig) ||
			!SplitOutV2ConfigName(IDS_V2_WIN3280X86_PLATFORM, strTargetName, strConfigName, bFileConfig) ||
			!SplitOutV2ConfigName(IDS_V2_WIN32_PLATFORM, strTargetName, strConfigName, bFileConfig))
			return false;
		return true;
	}
}

bool CVCProjConvert::SplitOutV2ConfigName(UINT idPlatform, CString& strTargetName, CString& strConfigName, 
	BOOL bFileConfig /* = FALSE */)
{
	CString strPlatform;
	if (!strPlatform.LoadString(idPlatform))
		return false;

	int nLen = strPlatform.GetLength();
	if (_tcsncmp(strPlatform, strTargetName, nLen))
		return false;	// not for us

	strConfigName = strTargetName.Right(strTargetName.GetLength()-nLen);
	strConfigName.TrimLeft();
	strConfigName.TrimRight();

	if (bFileConfig)
	{
		// pull out any (80x86) we may find since this is the default, anyway
		int j = strPlatform.Find(_T("(80x86)"));
		if (j >= 0)
		{
			CString strLeft, strRight;
			strLeft = strPlatform.Left(j);
			if (j < nLen-7)
				strRight = strPlatform.Right(j+7);
			strLeft.TrimRight();
			strRight.TrimLeft();
			if (!strLeft.IsEmpty() && !strRight.IsEmpty())
				strLeft += _T(" ");
			strPlatform = strLeft + strRight;
		}
		strPlatform.TrimLeft();
		strPlatform.TrimRight();
		strConfigName += _T("|");
		strConfigName += strPlatform;
	}

	return true;
}

BOOL CVCProjConvert::PropertyIsDifferent(CComBSTR& bstrOld, CComBSTR& bstrNew, BOOL bBlankOK /* = FALSE */)
{
	if (bstrNew.Length() == 0)
	{
		if (!bBlankOK || bstrOld.Length() == 0)
			return FALSE;
	}

	if (bstrOld.Length() == 0)
		return TRUE;

	return (_wcsicmp(bstrOld, bstrNew) != 0);
}


BOOL CVCProjConvert::PropertyIsDifferent(CComBSTR& bstrOld, BSTR bstrNew, BOOL bBlankOK /* = FALSE */)
{
	CComBSTR bstrNew2 = bstrNew;
	return PropertyIsDifferent(bstrOld, bstrNew2, bBlankOK);
}

VARIANT_BOOL CVCProjConvert::ConvertToBoolValue(long lVal)
{
	if (lVal)
		return VARIANT_TRUE;

	return VARIANT_FALSE;
}

BOOL CVCProjConvert::EnumIsTrue(long lVal)
{
	return (lVal == 2);
}

void CVCProjConvert::AddExtraOption(IVCPropertyContainer* pPropContainer, long propID, long lVal, BSTR bstrOption)
{
	if (EnumIsTrue(lVal))
		AddAdditionalOptions(pPropContainer, propID, bstrOption);
}

void CVCProjConvert::AddAdditionalOptions(IVCPropertyContainer* pPropContainer, long propID, BSTR bstrOption)
{
	CComBSTR bstrNewValue = bstrOption;
	if (bstrNewValue.Length() == 0)
		return;

	CComBSTR bstrCurrentValue;
	pPropContainer->GetStrProperty(propID, &bstrCurrentValue);
	if (bstrCurrentValue.Length() > 0)
	{
		if (bstrCurrentValue == bstrNewValue)
			return;	// they're the same
		bstrCurrentValue += L" ";
	}
	bstrCurrentValue += bstrNewValue;
	pPropContainer->SetStrProperty(propID, bstrCurrentValue);
}

void CVCProjConvert::SetBoolProperty(IVCPropertyContainer* pPropContainer, long propID, long lVal, 
	BOOL bFlipIt /* = FALSE */)
{
	VARIANT_BOOL bNewValue = ConvertToBoolValue(lVal);
	if (bFlipIt)
		bNewValue = (bNewValue == VARIANT_TRUE) ? VARIANT_FALSE : VARIANT_TRUE;
	VARIANT_BOOL bOldValue;
	pPropContainer->GetBoolProperty(propID, &bOldValue);
	if (bOldValue != bNewValue)
		pPropContainer->SetBoolProperty(propID, bNewValue);
}

void CVCProjConvert::SetStrProperty(IVCPropertyContainer* pPropContainer, long propID, BSTR bstrNewVal, BOOL bBlankOK /* = FALSE */)
{
	CComBSTR bstrOldVal, bstrNewEval;
	// compare _evaluated_ string props
	pPropContainer->GetEvaluatedStrProperty(propID, &bstrOldVal);
	pPropContainer->Evaluate( bstrNewVal, &bstrNewEval );
	if (PropertyIsDifferent(bstrOldVal, bstrNewEval, bBlankOK))
		pPropContainer->SetStrProperty(propID, bstrNewVal);
}

void CVCProjConvert::SetMultiStrProperty(IVCPropertyContainer* pPropContainer, long propID, BSTR bstrNewVal, bool bIsBase)
{
	CComBSTR bstrNewVal2 = bstrNewVal;
	if (bstrNewVal2.Length() > 0)
	{
		CComBSTR bstrCurrentVal;
		pPropContainer->GetStrProperty(propID, &bstrCurrentVal);
		if (bstrCurrentVal.Length() == 0 || wcscmp(bstrCurrentVal, bstrNewVal) != 0)
		{
			if (bstrCurrentVal.Length() == 0)
				bstrCurrentVal.Append(bstrNewVal);
			else
			{
				CStringW strCurrentVal = bstrCurrentVal;
				CStringW strNewVal = bstrNewVal;
				CStringW strSeparatorList = L";,";
				CStringW strItem;
				int nMaxIdx = strNewVal.GetLength();
				int nNextIdx = 0;
				while (nNextIdx >= 0)
				{
					nNextIdx = GetNextItem(strNewVal, nNextIdx, nMaxIdx, strSeparatorList, strItem);
					int nFoundIdx = FindItem(strCurrentVal, strItem, strSeparatorList, 0);
					if (nFoundIdx < 0)		// not there
					{
						bstrCurrentVal.Append(L";");
						CComBSTR bstrItem = strItem;
						bstrCurrentVal.Append(bstrItem);
					}
				}


			}
			if (!bIsBase)
				bstrCurrentVal.Append(L";$(NoInherit)");
			pPropContainer->SetStrProperty(propID, bstrCurrentVal);
		}
	}
}

void CVCProjConvert::SetEnumProperty(IVCPropertyContainer* pPropContainer, long propID, long nNewValue)
{
	VSASSERT(nNewValue > 0, "Old enums are one-based!");

	if (nNewValue <= 0)
		return;

	nNewValue--;	// old stuff is one-based, new stuff is zero-based
	long nOldValue = 0;
	pPropContainer->GetIntProperty(propID, &nOldValue);
	if (nNewValue != nOldValue)
		pPropContainer->SetIntProperty(propID, nNewValue);
}

void CVCProjConvert::SetIntProperty(IVCPropertyContainer* pPropContainer, long propID, long nNewValue,
	BOOL bZeroOK /* = FALSE */)
{
	if (nNewValue == 0 && !bZeroOK)
		return;

	long nOldValue = 0;
	pPropContainer->GetIntProperty(propID, &nOldValue);
	if (nNewValue != nOldValue)
		pPropContainer->SetIntProperty(propID, nNewValue);
}

void CVCProjConvert::SetPtrToMember1(IVCPropertyContainer* pPropContainer, long lVal)
{  // IDOPT_PTRMBR1, "vm%{b|g}1", OPTARGS1(P_PtrMbr1), single,
	CComBSTR bstrSwitch;
	switch (lVal)
	{
	default:
	case 1:	// /vmb
		bstrSwitch = L"/vmb";
		break;
	case 2:	// /vmg
		bstrSwitch = L"/vmg";
		break;
	}

	if (bstrSwitch.Length())
		AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, lVal, bstrSwitch);
}

void CVCProjConvert::SetPtrToMember2(IVCPropertyContainer* pPropContainer, long lVal)
{ // IDOPT_PTRMBR2, "vm%{v|s|m}1", OPTARGS1(P_PtrMbr2), single,
	CComBSTR bstrSwitch;
	switch (lVal)
	{
	default:
	case 1:	// /vmv
		bstrSwitch = L"/vmv";
		break;
	case 2:	// /vms
		bstrSwitch = L"/vms";
		break;
	case 3:	// /vmm
		bstrSwitch = L"/vmm";
		break;
	}

	if (bstrSwitch.Length())
		AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, lVal, bstrSwitch);
}

void CVCProjConvert::SetDebugInfo(VCCLCompilerTool* pCompiler, long lVal)
{ // IDOPT_DEBUGINFO,	"Z%{d|7|i|I}1", OPTARGS1(P_DebugInfo), single, 
	debugOption lNewDebugInformation = debugDisabled;
	switch (lVal)
	{
	case 1:	// /Zd
		lNewDebugInformation = debugLineInfoOnly;
		break;
	case 2:	// /Z7
		lNewDebugInformation = debugOldStyleInfo;
		break;
	case 3:	// /Zi
		lNewDebugInformation = debugEnabled;
		break;
	case 4:	// /ZI
		lNewDebugInformation = debugEditAndContinue;
		break;
	}
	debugOption lOldDebugInformation;
	pCompiler->get_DebugInformationFormat(&lOldDebugInformation);
	if (lOldDebugInformation != lNewDebugInformation)
		pCompiler->put_DebugInformationFormat(lNewDebugInformation); 	// see debugOption enum 
}

void CVCProjConvert::SetOptimization(VCCLCompilerTool* pCompiler, long lVal)
{ // IDOPT_OPTIMIZE, "O%{d|2|1}1", OPTARGS1(P_Optimize), single,
	optimizeOption lOptimization = optimizeCustom, oo = optimizeCustom;
	pCompiler->get_Optimization(&lOptimization);
	switch(lVal)
	{
	case 1: // Od
		oo = optimizeDisabled;
		break;
	case 2: // O2
		oo = optimizeMaxSpeed;
		break;
	case 3: // O1
		oo = optimizeMinSpace;
		break;
	}
	if (lOptimization != oo)
		pCompiler->put_Optimization(oo); 	// see optimizeOption enum 
}

void CVCProjConvert::SetOptimizeX(VCCLCompilerTool* pCompiler, long lVal)
{	// IDOPT_OPT_X, "Ox%T1%<4>2", OPTARGS2(P_Optimize_X, P_Optimize), single,
	optimizeOption lNewOptimization = lVal ? optimizeFull : optimizeDisabled;
	optimizeOption lOldOptimization;
	pCompiler->get_Optimization(&lOldOptimization);
	if (lNewOptimization != lOldOptimization)
		pCompiler->put_Optimization(lNewOptimization);
}

void CVCProjConvert::SetCodeGenFavor(VCCLCompilerTool* pCompiler, UINT idOption, long lVal)
{	// IDOPT_OPT_T, "Ot%T1%<4>2", OPTARGS2(P_Optimize_T, P_Optimize), single,
	// IDOPT_OPT_S, "Os%T1%<4>2", OPTARGS2(P_Optimize_S, P_Optimize), single, FavorSizeOrSpeed // see favorSizeOrSpeedOption enum
	favorSizeOrSpeedOption lFavorSizeOrSpeed, fcgo;
	if (idOption == IDOPT_OPT_T && lVal != 0)
		fcgo = favorSpeed;
	else if (lVal != 0)
		fcgo = favorSize;
	else
		fcgo = favorNone;

	pCompiler->get_FavorSizeOrSpeed(&lFavorSizeOrSpeed);
	if (lFavorSizeOrSpeed != fcgo)
		pCompiler->put_FavorSizeOrSpeed(fcgo); 	// see favorSizeOrSpeedOption enum 
}

void CVCProjConvert::SetStringPooling(VCCLCompilerTool* pCompiler, long lVal)
{	// converting /Gf to /GF on purpose
	VARIANT_BOOL bPoolNew = (lVal != 0) ? VARIANT_TRUE : VARIANT_FALSE;
	VARIANT_BOOL bPoolOld;
	pCompiler->get_StringPooling(&bPoolOld);
	if (bPoolNew != bPoolOld)
		pCompiler->put_StringPooling(bPoolNew);
}

void CVCProjConvert::SetAsmOptions(VCCLCompilerTool* pCompiler, CProjItem* pProjItem, COptionHandler* pOptHandler,
	long lVal)
{	// IDOPT_LISTASM, "FA%{%f1%f2|cs%t1%t2|c%t1%f2|s%f1%t2}3",	OPTARGS3(P_AsmListHasMC, P_AsmListHasSrc, P_ListAsm), single,
	// Looks like it doesn't matter WHAT P_ListAsm refers to as long as it is a non-default property...
	int iAsmListHasMC = 0, iAsmListHasSrc = 0;
	asmListingOption lNewAssemblerOutput = asmListingAssemblyOnly;
	if (pProjItem->GetIntProp(pOptHandler->MapLogical(P_AsmListHasMC), iAsmListHasMC) != valid)
		iAsmListHasMC = 0;
	if (pProjItem->GetIntProp(pOptHandler->MapLogical(P_AsmListHasSrc), iAsmListHasSrc) != valid)
		iAsmListHasSrc = 0;
	if (iAsmListHasMC)
	{
		if (iAsmListHasSrc)
			lNewAssemblerOutput = asmListingAsmMachineSrc;
		else
			lNewAssemblerOutput = asmListingAsmMachine;
	}
	else if (iAsmListHasSrc)
		lNewAssemblerOutput = asmListingAsmSrc;
	asmListingOption lOldAssemblerOutput;
	pCompiler->get_AssemblerOutput(&lOldAssemblerOutput);
	if (lOldAssemblerOutput != lNewAssemblerOutput)
		pCompiler->put_AssemblerOutput(lNewAssemblerOutput); 	// see asmListingOption enum 
}

void CVCProjConvert::SetListBsc(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer, 
	CProjItem* pProjItem, COptionHandler* pOptHandler, 
	UINT idOption, long lVal)
{	// IDOPT_LISTBSCNOLCL,	"Fr%T1%t2[%3]", OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
	// IDOPT_LISTBSC, "FR%T1%f2[%3]", OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
	browseInfoOption newListBsc;
	if (idOption == IDOPT_LISTBSCNOLCL)
		newListBsc = lVal ? brNoLocalSymbols : brInfoNone;
	else
		newListBsc = lVal ? brAllInfo : brInfoNone;
	CString strBscFile;
	if (newListBsc != brInfoNone)
	{
		int iGenInfo = FALSE;
		if (pProjItem->GetIntProp(pOptHandler->MapLogical(P_GenBrowserInfoNoLcl), iGenInfo) == valid
			&& iGenInfo)
			pProjItem->GetConvertedStrProp(pOptHandler->MapLogical(P_OutputDir_Sbr), strBscFile);
	}
	browseInfoOption oldListBsc = brInfoNone;
	pCompiler->get_BrowseInformation(&oldListBsc);
	if (oldListBsc != newListBsc)
		pCompiler->put_BrowseInformation(newListBsc);
	if (newListBsc != brInfoNone && !strBscFile.IsEmpty())
	{
		CComBSTR bstrBscFile = strBscFile;
		SetStrProperty(pPropContainer, VCCLID_BrowseInformationFile, bstrBscFile);
	}
}

void CVCProjConvert::SetAutoPCH(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer,
	COptionHandler* pOptHandler, CProjItem* pProjItem, long lVal)
{	// IDOPT_AUTOPCH, "YX%T1[%2]", OPTARGS2(P_AutoPch, P_AutoPchUpTo), single,
// /nologo /MDd /RTC1 /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_AFXDLL" 
// /D "_MBCS" /Fp"Debug/mfcone.pch" /Yc"stdafx.h" /Fo"Debug/" /Fd"Debug/" /FD /c "x:\tests\mfcone\StdAfx.cpp"

	pchOption pchNewVal = (lVal ? pchGenerateAuto : pchNone);
	pchOption pchOldVal;
	pCompiler->get_UsePrecompiledHeader(&pchOldVal);
	if (pchNewVal != pchOldVal)
		pCompiler->put_UsePrecompiledHeader(pchNewVal);

	CString strHeader;
	if (pchNewVal != pchNone && pProjItem->GetConvertedStrProp(pOptHandler->MapLogical(P_AutoPchUpTo), 
		strHeader) == valid && !strHeader.IsEmpty())
	{
		CComBSTR bstrHeader = strHeader;
		SetStrProperty(pPropContainer, VCCLID_PrecompiledHeaderThrough, bstrHeader);
	}
}

void CVCProjConvert::SetCreatePCH(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer,
	COptionHandler* pOptHandler, CProjItem* pProjItem, long lVal)
{	// IDOPT_PCHCREATE,	"Yc%T1[%2]", OPTARGS2(P_PchCreate, P_PchCreateUptoHeader),	single,
// /nologo /MDd /RTC1 /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_AFXDLL" 
// /D "_MBCS" /Fp"Debug/mfcone.pch" /Yc"stdafx.h" /Fo"Debug/" /Fd"Debug/" /FD /c "x:\tests\mfcone\StdAfx.cpp"

	pchOption pchNewVal = lVal ? pchCreateUsingSpecific : pchNone;
	pchOption pchOldVal;
	pCompiler->get_UsePrecompiledHeader(&pchOldVal);
	if (pchNewVal != pchOldVal)
		pCompiler->put_UsePrecompiledHeader(pchNewVal);

	CString strHeader;
	if (pchNewVal != pchNone)
	{
		GPT gptRet = pProjItem->GetConvertedStrProp(pOptHandler->MapLogical(P_PchCreateUptoHeader), strHeader);
		if (gptRet != valid || strHeader.IsEmpty())
		{
			// HACK: didn't always save the info about what file to use...
			CProject* pProject = pProjItem->GetProject();
			pOptHandler->SetSlob(pProject);
			gptRet = pProject->GetConvertedStrProp(pOptHandler->MapLogical(P_PchUseUptoHeader), strHeader);
			pOptHandler->ResetSlob();
		}
		if (gptRet == valid && !strHeader.IsEmpty())
		{
			CComBSTR bstrHeader = strHeader;
			SetStrProperty(pPropContainer, VCCLID_PrecompiledHeaderThrough, bstrHeader);
		}
	}
}

void CVCProjConvert::SetUsePCH(VCCLCompilerTool* pCompiler, IVCPropertyContainer* pPropContainer, 
	COptionHandler* pOptHandler, CProjItem* pProjItem, long lVal)
{	// IDOPT_PCHUSE, "Yu%T1[%2]", OPTARGS2(P_PchUse, P_PchUseUptoHeader), single,
	SetIntProperty(pPropContainer, VCCLID_UsePrecompiledHeader, lVal ? pchUseUsingSpecific : pchNone, TRUE);
	if (lVal)
	{
		CString strHeader;
		if (pProjItem->GetConvertedStrProp(pOptHandler->MapLogical(P_PchUseUptoHeader), 
			strHeader) == valid)
		{
			CComBSTR bstrHeader = strHeader;
			SetStrProperty(pPropContainer, VCCLID_PrecompiledHeaderThrough, bstrHeader);
		}
	}
}

void CVCProjConvert::SetStackCheck(IVCPropertyContainer* pPropContainer, long lVal)
{	// IDOPT_STACK_PROBE_THOLD,	"Gs%1", OPTARGS1(P_StackProbeTHold), single,
	if (lVal == 0)
		return;

	CStringW strOption;
	strOption.Format(L"/Gs%d", lVal);
	CComBSTR bstrOption = strOption;
	AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, lVal, bstrOption);
}

void CVCProjConvert::SetPreprocess1(VCCLCompilerTool* pCompiler, UINT idOption, long lVal)
{	// IDOPT_PREPROCESS_WO_LINES,	"EP%T1", OPTARGS1(P_PreprocessWOLines), single,
	// IDOPT_PREPROCESS, "E%T1", OPTARGS1(P_Preprocess), single,
	preprocessOption lPreprocess, ppo;
	if (idOption == IDOPT_PREPROCESS_WO_LINES && lVal != 0)
		ppo = preprocessNoLineNumbers;
	else if (lVal != 0)
		return;		// silently don't do this one
	else
		ppo = preprocessNo;

	pCompiler->get_GeneratePreprocessedFile(&lPreprocess);
	if (lPreprocess != ppo)
		pCompiler->put_GeneratePreprocessedFile(ppo); 	// see preprocessOption enum 
}

void CVCProjConvert::SetPreprocess2(VCCLCompilerTool* pCompiler, CProjItem* pProjItem, long lVal)
{	// IDOPT_PREPROCESS_TO_FILE,	"P%T1", OPTARGS1(P_PrepprocessToFile), single,
	preprocessOption oldPreProcessFile = preprocessNo;
	pCompiler->get_GeneratePreprocessedFile(&oldPreProcessFile);

	if (oldPreProcessFile == preprocessNo && !lVal)
		return;	// they're the same

	if (lVal && (oldPreProcessFile == preprocessYes || oldPreProcessFile == preprocessNoLineNumbers))
		return;	// again, they're the same

	if (!lVal)
		pCompiler->put_GeneratePreprocessedFile(preprocessNo);
	else
		pCompiler->put_GeneratePreprocessedFile(preprocessYes);
}

void CVCProjConvert::SetTreatFileAs(VCCLCompilerTool* pCompiler, UINT idOption, long lVal)
{	// IDOPT_TREATFILEAS_CPP1,	"Tp%T1", OPTARGS1(P_TreatFileAsCPP1), single,	
	// IDOPT_TREATFILEAS_CPP2,	"TP%T1", OPTARGS1(P_TreatFileAsCPP2), single,	
	// IDOPT_TREATFILEAS_C1,	"Tc%T1", OPTARGS1(P_TreatFileAsC1), single,
	// IDOPT_TREATFILEAS_C2,	"TC%T1", OPTARGS1(P_TreatFileAsC2), single,
	CompileAsOptions lCompileAs, cao;
	if ((idOption == IDOPT_TREATFILEAS_CPP1 || idOption == IDOPT_TREATFILEAS_CPP2) && lVal != 0)
		cao = compileAsCPlusPlus;
	else if (lVal != 0)
		cao = compileAsC;
	else
		cao = compileAsDefault;

	pCompiler->get_CompileAs(&lCompileAs);
	if (lCompileAs != cao)
		pCompiler->put_CompileAs(cao); 	// see CompileAsOptions enum 
}

void CVCProjConvert::SetProcOptimize(VCCLCompilerTool* pCompiler, long lVal)
{
	ProcessorOptimizeOption OptimizeForProcessor, poo;
	BOOL bIgnoreSwitch = FALSE;
	switch(lVal)
	{
	case 1: // G3
	case 2: // G4
		bIgnoreSwitch = TRUE;
		break;
	case 3: // G5
		poo = procOptimizePentium;
		break;
	case 4: // G6
		poo = procOptimizePentiumProAndAbove;
		break;
	default:
	case 5: // GB
		poo = procOptimizeBlended;
		break;
	}
	if (bIgnoreSwitch)
		return;		// nothing to do

	pCompiler->get_OptimizeForProcessor(&OptimizeForProcessor);
	if (!bIgnoreSwitch && OptimizeForProcessor != poo)
		pCompiler->put_OptimizeForProcessor(poo);
}

void CVCProjConvert::SetCallConvention(VCCLCompilerTool* pCompiler, long lVal)
{	// IDOPT_CALLCONV_ALPHA,	"G%{d}1", OPTARGS1(P_CallConvAlpha), single,
	// IDOPT_CALLCONV_MERCED,	"G%{d}1", OPTARGS1(P_CallConvMerced), single,
	// IDOPT_CALLCONV_MIPS,	"G%{d|r}1", OPTARGS1(P_CallConvMips), single,
	// IDOPT_CALLCONV, "G%{d|r|z}1", OPTARGS1(P_CallConv), single, CallingConvention // see callingConventionOption enum
	callingConventionOption newCallingConvention = callConventionCDecl;
	switch (lVal)
	{
	default:
	case 1:	// /Gd
		newCallingConvention = callConventionCDecl;
		break;
	case 2:	// /Gr
		newCallingConvention = callConventionFastCall;
		break;
	case 3:
		newCallingConvention = callConventionStdCall;
		break;
	}
	callingConventionOption oldCallingConvention;
	pCompiler->get_CallingConvention(&oldCallingConvention);
	if (oldCallingConvention != newCallingConvention)
		pCompiler->put_CallingConvention(newCallingConvention);
}

void CVCProjConvert::SetByteAlign(VCCLCompilerTool* pCompiler, long lVal)
{	// IDOPT_BYTE_MERCED,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignMerced), single,
	// IDOPT_BYTE_MIPS,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignMips), single,
	// IDOPT_BYTE_ALPHA,	"Zp%{2|4|8|16|[1]}1",	OPTARGS1(P_ByteAlignAlpha), single,
	// IDOPT_BYTE, "Zp%{2|4|8|16|[1]}1", OPTARGS1(P_ByteAlign), single, StructMemberAlignment see structMemberAlignOption enum
	structMemberAlignOption StructMemberAlignment, smao;
	pCompiler->get_StructMemberAlignment(&StructMemberAlignment);
	switch(lVal)
	{
	case 1: // Zp2
		smao = alignTwoBytes;
		break;
	case 2: // Zp4
		smao = alignFourBytes;
		break;
	case 3: // Zp8
		smao = alignEightBytes;
		break;
	case 4: // Zp16
		smao = alignSixteenBytes;
		break;
	default:
	case 5: // Zp1
		smao = alignSingleByte;
		break;
	}
	if (StructMemberAlignment != smao)
		pCompiler->put_StructMemberAlignment(smao);
}

void CVCProjConvert::SetRuntimeLib(VCCLCompilerTool* pCompiler, long lVal)
{	// IDOPT_THREAD_MIPS,	"M%{Ld|Td|Dd|L|T|D}1", OPTARGS1(P_ThreadMips), single,
	// IDOPT_THREAD, "M%{Ld|Td|Dd|L|T|D}1",	OPTARGS1(P_Thread), single, RuntimeLibrary runtimeLibraryOption
	// IDOPT_THREAD_MERCED (+3), "M%{L|T|D}1", OPTARGS1(P_ThreadMerced), single,
	// IDOPT_THREAD_ALPHA (+3), "M%{L|T|D}1", OPTARGS1(P_ThreadAlpha), single,
	runtimeLibraryOption RuntimeLibrary, rlo;
	pCompiler->get_RuntimeLibrary(&RuntimeLibrary);

	switch(lVal)
	{
	default:
	case 1: // Ld
		rlo = rtSingleThreadedDebug;
		break;
	case 2: // Td
		rlo = rtMultiThreadedDebug;
		break;
	case 3: // Dd
		rlo = rtMultiThreadedDebugDLL;
		break;
	case 4: // L
		rlo = rtSingleThreaded;
		break;
	case 5: // T
		rlo = rtMultiThreaded;
		break;
	case 6: // D
		rlo = rtMultiThreadedDLL;
		break;
	}

	if (RuntimeLibrary != rlo)
		pCompiler->put_RuntimeLibrary(rlo);
}

void CVCProjConvert::SetOldEH(VCCLCompilerTool* pCompiler, long lVal)
{	// IDOPT_ENABLE_EH,	"GX%{-|}1", OPTARGS1(P_Enable_EH), single,  enables synchronous exception 
	VARIANT_BOOL neho = lVal ? VARIANT_TRUE : VARIANT_FALSE;
	VARIANT_BOOL eho = VARIANT_FALSE;
	pCompiler->get_ExceptionHandling(&eho);
	if (eho != neho)
		pCompiler->put_ExceptionHandling(neho);
}

void CVCProjConvert::SetRuntimeChecks(VCCLCompilerTool* pCompiler, long lVal, basicRuntimeCheckOption newOpt)
{
	basicRuntimeCheckOption oldOpt = runtimeBasicCheckNone;
	HRESULT hr = pCompiler->get_BasicRuntimeChecks(&oldOpt);
	if (FAILED(hr))
		return;
	else if (hr == S_FALSE)		// nothing previously set
		pCompiler->put_BasicRuntimeChecks(lVal ? newOpt : runtimeBasicCheckNone);
	else if (oldOpt == runtimeBasicCheckAll)
	{
		if (newOpt == runtimeBasicCheckAll)	// already included if true, not allowing explicit removal of anything but all if false
			pCompiler->put_BasicRuntimeChecks(lVal ? newOpt : runtimeBasicCheckNone);
	}
	else	// need to check for inclusion
	{
		if (newOpt == oldOpt)
			pCompiler->put_BasicRuntimeChecks(lVal ? newOpt : runtimeBasicCheckNone);
		else if (lVal)
			pCompiler->put_BasicRuntimeChecks(runtimeBasicCheckAll);
	}
}

void CVCProjConvert::SetLinkShowProgress(VCLinkerTool* pLinker, long lVal)
{
	linkProgressOption newShowProgress = lVal ? linkProgressAll : linkProgressNotSet;
	linkProgressOption oldShowProgress;
	pLinker->get_ShowProgress(&oldShowProgress);
	if (oldShowProgress != newShowProgress)
		pLinker->put_ShowProgress(newShowProgress);
}

void CVCProjConvert::SetUsePDB(IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, 
	COptionHandler* pOptHandler, long lVal)
{
	CComBSTR bstrPDBFile;
	if (lVal)
	{
		CString strPDBFile;
		GPT gptRet = pProjItem->GetConvertedStrProp(pOptHandler->MapLogical(P_UsePDBName), strPDBFile);
		if (gptRet == invalid)
		{
			gptRet = pOptHandler->GetDefStrProp(pOptHandler->MapLogical(P_UsePDBName), strPDBFile);
			if (gptRet == valid)
				::ConvertMacros(strPDBFile);
		}
		bstrPDBFile = strPDBFile;
	}
//	else
//		blank PDB file name

	SetStrProperty(pPropContainer, VCLINKID_ProgramDatabaseFile, bstrPDBFile, lVal /* blank OK if not supposed to set... */);
}

void CVCProjConvert::SetMapGen(IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, COptionHandler* pOptHandler, long lVal)
{	//  IDOPT_MAPGEN, "m[ap]%T1[: // %2]", OPTARGS2(P_GenMap, P_MapName), single,
	SetBoolProperty(pPropContainer, VCLINKID_GenerateMapFile, lVal);
	if (lVal)
	{
		CString strMapFile;
		GPT gpt = pProjItem->GetConvertedStrProp(pOptHandler->MapLogical(P_MapName), strMapFile);
		if (gpt != valid)
		{
			gpt = pOptHandler->GetDefStrProp(pOptHandler->MapLogical(P_MapName), strMapFile);
			if (gpt == valid)
				::ConvertMacros(strMapFile);
		}
		if (gpt == valid)
		{
			CComBSTR bstrMapFile = strMapFile;
			SetStrProperty(pPropContainer, VCLINKID_MapFileName, bstrMapFile);
		}
	}
}

void CVCProjConvert::SetLinkerDriver(IVCPropertyContainer* pPropContainer, long lVal)
{	//	IDOPT_DRIVER, "driver%{:junk||:uponly|:wdm}%1", OPTARGS1(P_Driver), single,
	CComBSTR bstrOpt;
	switch (lVal)
	{
	case 2:
		bstrOpt = L"/DRIVER";
		break;
	case 3:
		bstrOpt = L"/DRIVER:UPONLY";
		break;
	case 4:
		bstrOpt = L"/DRIVER:WDM";
		break;
	}

	if (bstrOpt && bstrOpt != L"")
		AddAdditionalOptions(pPropContainer, VCLINKID_AdditionalOptions, bstrOpt);
}

void CVCProjConvert::SetLinkerAlign(IVCPropertyContainer* pPropContainer, long lVal)
{
	if (lVal == 0)
		return;

	CStringW strOpt;
	strOpt.Format(L"/ALIGN:%d", lVal);
	CComBSTR bstrOpt = strOpt;
	AddAdditionalOptions(pPropContainer, VCLINKID_AdditionalOptions, bstrOpt);
}

void CVCProjConvert::SetLinkerFixed(IVCPropertyContainer* pPropContainer, long lVal)
{
	CComBSTR bstrOpt;
	switch (lVal)
	{
	case 1:		// no
		bstrOpt = L"/FIXED:NO";
		break;
	case 2:		// blank
		bstrOpt = L"/FIXED";
		break;
	}

	if (bstrOpt && bstrOpt != L"")
		AddAdditionalOptions(pPropContainer, VCLINKID_AdditionalOptions, bstrOpt);
}

void CVCProjConvert::SetLinkerSubSystem(IVCPropertyContainer* pPropContainer, long lVal)
{
	subSystemOption lSubSystem, sso;
	pPropContainer->GetIntProperty(VCLINKID_SubSystem, (long *)&lSubSystem);
	switch (lVal)
	{
	default:
		sso = subSystemNotSet;
		break;
	case 1:
		sso = subSystemWindows;
		break;
	case 2:
		sso = subSystemConsole;
		break;
	}
	if (lSubSystem != sso)
		pPropContainer->SetIntProperty(VCLINKID_SubSystem, sso); 	// see subSystemOption enum 
}

void CVCProjConvert::SetLinkerLargeAddressAwareness(IVCPropertyContainer* pPropContainer, long lVal)
{	// IDOPT_LARGEADDRESS,	"largeaddressaware%{|:no}1", OPTARGS(P_LargeAddress), single,
	addressAwarenessType lAwareness = addrAwareDefault, mto = addrAwareDefault;
	pPropContainer->GetIntProperty(VCLINKID_LargeAddressAware, (long *)&lAwareness);
	switch (lVal)
	{
	case 1:	// no
		mto = addrAwareNoLarge;
		break;
	case 2:	// blank
		mto = addrAwareLarge;
		break;
	}

	if (lAwareness != mto)
		pPropContainer->SetIntProperty(VCLINKID_LargeAddressAware, mto);
}

void CVCProjConvert::SetLinkerVersion(IVCPropertyContainer* pPropContainer, CProjItem* pProjItem, 
	COptionHandler* pOptHandler, long lVal)
{
	CVCString strVersion;
	int i;
	if (pProjItem->GetIntProp(pOptHandler->MapLogical(P_VersionMin), i) == valid)
		strVersion.Format(_T("%d.%d"), lVal, i);
	else
		strVersion.Format(_T("%d"), lVal);
	CComBSTR bstrVersion = strVersion;
	SetStrProperty(pPropContainer, VCLINKID_Version, bstrVersion);
}

void CVCProjConvert::SetMidlOutput(IVCPropertyContainer* pPropContainer, long lPropID, BSTR bstrVal)
{
	CComBSTR bstrOut = bstrVal;
	if (bstrOut.Length() == 3)
	{
		bstrOut.ToLower();
		if (wcscmp(bstrOut, L"nul") == 0)
			return;	// don't want to set this...
	}
	SetStrProperty(pPropContainer, lPropID, bstrVal);
}

void CVCProjConvert::SetMidlStublessProxy(IVCPropertyContainer* pPropContainer, long lVal)
{  // IDOPT_MTL_STUBLESS_PROXY,	"Oicf%T1", OPTARGS1(P_MTLStublessProxy),	single,
	//GenerateStublessProxies 
	VARIANT_BOOL bGenerateStublessProxies = VARIANT_FALSE;
	pPropContainer->GetBoolProperty(VCMIDLID_GenerateStublessProxies, &bGenerateStublessProxies);
	if (lVal && bGenerateStublessProxies == VARIANT_FALSE)
		pPropContainer->SetBoolProperty(VCMIDLID_GenerateStublessProxies, VARIANT_TRUE);
	else if (!lVal && bGenerateStublessProxies == VARIANT_TRUE)
		pPropContainer->SetBoolProperty(VCMIDLID_GenerateStublessProxies, VARIANT_FALSE);
}

void CVCProjConvert::SetMidlChar(IVCPropertyContainer* pPropContainer, long lVal)
{
	midlCharOption newDefaultCharType;
	switch (lVal)
	{
	default:
	case 1:	// /char signed
		newDefaultCharType = midlCharSigned;
		break;
	case 2:	// /char ascii77
		newDefaultCharType = midlCharAscii7;
		break;
	case 3:	// /char unsigned
		newDefaultCharType = midlCharUnsigned;
		break;
	}
	midlCharOption DefaultCharType;
	pPropContainer->GetIntProperty(VCMIDLID_DefaultCharType, (long *)&DefaultCharType);
	if (DefaultCharType != newDefaultCharType)
		pPropContainer->SetIntProperty(VCMIDLID_DefaultCharType, newDefaultCharType);
}

void CVCProjConvert::SetMidlClient(IVCPropertyContainer* pPropContainer, long lVal)
{	// case IDOPT_MTL_CLIENT: // IDOPT_MTL_CLIENT, "client %{stub|none}1",	OPTARGS1(P_MTL_Client), single, Client
	if (lVal == 0)
		AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, 1, L"/client none");
	else if (lVal == 1)
		AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, lVal, L"/client stub");
}

void CVCProjConvert::SetMidlServer(IVCPropertyContainer* pPropContainer, long lVal)
{	// case IDOPT_MTL_SERVER: // IDOPT_MTL_SERVER, "server %{stub|none}1",	OPTARGS1(P_MTL_Server), single, Server
	if (lVal == 0)
		AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, 1, L"/server none");
	else if (lVal == 1)
		AddExtraOption(pPropContainer, VCCLID_AdditionalOptions, lVal, L"/server stub");
}

//
// primitive custom build 'tool macros'
// Only the ones that are changing their names for VC7 are here as all we're doing is converting those few names
// and not doing a full expansion of any kind on any of them.
//

typedef struct 
{
	UINT idMacro;
	const TCHAR * pchName;
} S_ToolMacroMapEl;

#define IDMACRO_SOLNDIR		100
#define IDMACRO_ENVDIR		101
#define IDMACRO_SOLNBASE	102
#define IDMACRO_PROJDIR		103
#define IDMACRO_CFGNAME		104
#define IDMACRO_TARGDIR		105
#define IDMACRO_REMOTEDIR	106
#define IDMACRO_INPTDIR		107

// yes, the last three in this list don't actually change name.  HOWEVER, having them here
// means that we get the conversion bit about handling the trailing slash correct.
static const S_ToolMacroMapEl mapToolMacros[] =
{
	{IDMACRO_SOLNDIR,	"WkspDir"},			// workspace directory
	{IDMACRO_ENVDIR,	"MSDEVDIR"},		// IDE directory
	{IDMACRO_SOLNBASE,	"WkspName"},		// workspace file basename
	{IDMACRO_CFGNAME,	"ConfigName"},		// configuration name
	{IDMACRO_PROJDIR,	"ProjDir"},			// path to project directory
	{IDMACRO_TARGDIR,	"TargetDir"},		// target directory
	{IDMACRO_REMOTEDIR, "RemoteDir"},		// remote target directory
	{IDMACRO_INPTDIR,	"InputDir"},		// input directory
};

static BOOL rgMacroUsage[sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl)];

// map a macro name to a macro id (IDM_)
BOOL MapMacroNameToId(const TCHAR * pchName, int & cchName, UINT & idMacro)
{
	cchName = 0;

	for (int i = sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl); i > 0; i--)
	{
		int cch = lstrlen(mapToolMacros[i-1].pchName);
		if ((cch > cchName) &&
			(_tcsnicmp(mapToolMacros[i-1].pchName, pchName, cch) == 0))
		{
			idMacro = mapToolMacros[i-1].idMacro;
			cchName = cch;	// found one match, try for bigger match....
		}
	}

	return cchName != 0;	// not mapped
}

BOOL GetMacroConversion(UINT nID, CVCString& rstrNewName)
{
	switch (nID)
	{
	case IDMACRO_SOLNDIR:		// workspace directory
		rstrNewName = _T("$(SolutionDir)");
		break;
	case IDMACRO_ENVDIR:		// IDE directory
		rstrNewName = _T("$(DevEnvDir)");
		break;
	case IDMACRO_SOLNBASE:	// workspace file basename
		rstrNewName = _T("$(SolutionName)");
		break;
	case IDMACRO_PROJDIR:
		rstrNewName = _T("$(ProjectDir)");
		break;
	case IDMACRO_CFGNAME:
		rstrNewName = _T("$(ConfigurationName)");
		break;
	case IDMACRO_TARGDIR:		// target directory
		rstrNewName = _T("$(TargetDir)");
		break;
	case IDMACRO_REMOTEDIR:	// remote target directory
		rstrNewName = _T("$(RemoteDir)");
		break;
	case IDMACRO_INPTDIR:	// input directory
		rstrNewName = _T("$(InputDir)");
		break;
	default:
		return FALSE;
	}

	return TRUE;
}

#define CCH_ALLOC_EXPAND	512

BOOL ConvertMacros(CString& rstrVal)
{
	CVCString strIn = rstrVal;
	if (strIn.IsEmpty())
		return TRUE;
	rstrVal.Empty();

	TCHAR * pchSpec = strIn.GetBuffer(strIn.GetLength());

	int cchOut = 0;
	int cchAlloc = 0;
	TCHAR * pchOut = NULL;

	cchAlloc = cchOut = CCH_ALLOC_EXPAND;
	pchOut = (TCHAR *)malloc(cchAlloc * sizeof(TCHAR));
	*pchOut = _T('\0'); cchOut -= sizeof(TCHAR);

	CVCString strMacroName;

	// copy everything verbatim unless we come across a macro
	while (*pchSpec != _T('\0'))
	{
		// macro?
		TCHAR * pch = pchSpec;
		while (!(*pch == _T('$') && *(pch + sizeof(TCHAR)) == _T('(')) && *pch != _T('\0'))
			pch = _tcsinc(pch);

		int cchReq = 0; 
		const TCHAR * pchBlk = (const TCHAR *)NULL;

		// do block append?
		if (pch != pchSpec)
		{
			// yes
			cchReq = (int)(pch - pchSpec);

			// get block start
			pchBlk = pchSpec;

			// advance
			pchSpec = pch;
		}
		else
		{
			UINT idMacro; int cchMacro;

			// macro-name exact match?
			// skip '$('
			pch += sizeof(TCHAR) * 2;

			if (MapMacroNameToId(pch , cchMacro, idMacro) &&
				*(pch + cchMacro) == _T(')'))
			{
				// advance and skip macro
				pchSpec = pch + cchMacro;

				// skip trailing ')'
				pchSpec++;

				// check to see if this is a *Dir type macro with a trailing slash, if so, we'll want to skip it
				// note that this does NOT apply to $(IntDir) or $(OutDir)
				if (cchMacro > 4 && _tcsnicmp(pch+cchMacro-3, _T("dir)"), 4) == 0 && 
					(cchMacro < 7 || (_tcsnicmp(pch+cchMacro-6, _T("intdir)"), 7) != 0 && 
					_tcsnicmp(pch+cchMacro-6, _T("outdir)"), 7) != 0)) &&
					(*(pch + cchMacro + 1) == _T('/') || *(pch + cchMacro + 1) == _T('\\')))
					pchSpec++;

				// get the macro's new name
				if (GetMacroConversion(idMacro, strMacroName))
				{
					// get the char. block
					cchReq = strMacroName.GetLength();
					pchBlk = (const TCHAR *)strMacroName;
				}
			}
			else	// we're not converting this macro, so bring it on over as is
			{
				// yes
				cchReq = (int)(pch - pchSpec);

				// get block start
				pchBlk = pchSpec;

				// advance
				pchSpec = pch;
			}
		}

		// not just testing usage and chars. req'd and char blk to copy?
		if (cchReq && pchBlk)
		{
			if (cchReq > cchOut)
			{
				int cchIncAlloc = max(CCH_ALLOC_EXPAND, cchReq);

				cchAlloc += cchIncAlloc; cchOut += cchIncAlloc;
				pchOut = (TCHAR *)realloc(pchOut, cchAlloc * sizeof(TCHAR));
			}
						
			// copy block
			_tcsncat(pchOut, pchBlk, cchReq); cchOut -= cchReq;
		}
	}

	rstrVal = pchOut;

	// free up our local buffer
	free(pchOut);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\tool.cpp ===
//
// Intelx86 C/C++ AddOn
//
// Intelx86 Platform C/C++ Tools Component Add-On 'package'
//
// [matthewt]
//

#include "stdafx.h" 

#include "bldpack.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// our components
#include "platx86.h"
#include "platalf.h"
#include "platmrcd.h"
#include "platXbox.h"

#include "x86optn.h"
#include "axpoptn.h"
#include "mcdoptn.h"

class CIntelx86CAddOn : public CPackage
{
public:
	CIntelx86CAddOn();

	// register the build system components for this platform
	BOOL DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD blc_id);

private:
	WORD wpkgid;
};

CIntelx86CAddOn::CIntelx86CAddOn()
	// o instance
	// o handle to window
	// o package id (* do not use *)
	// o command-table
	// o index into cmdtable
{
}


BOOL CIntelx86CAddOn::DoBldSysCompRegister(CProjComponentMgr * pcompmgr, DWORD blc_type, DWORD bsc_id)
{
	wpkgid = pcompmgr->GenerateBldSysCompPackageId((TCHAR *)szAddOnx86);

	DWORD bsc_idx86Platform = GenerateComponentId(wpkgid, BCID_Platform_x86);
	DWORD bsc_idAxpPlatform = GenerateComponentId(wpkgid, BCID_Platform_Alpha);
	DWORD bsc_idMercedPlatform = GenerateComponentId(wpkgid, BCID_Platform_Merced);
	DWORD bsc_idXboxPlatform = GenerateComponentId(wpkgid, BCID_Platform_Xbox);

	// C++ installed?
	static BOOL fGotCPP = TRUE;
	CPlatform *pPlat;
	// what is the hook?
	switch (blc_type)
	{
		case BLC_Platform:
			pPlat = new CPlatform(&g_PlatformInfoWin32x86);
#if !defined (_X86_)
			pPlat->SetBuildable(FALSE);
#endif
			pcompmgr->RegisterBldSysComp(pPlat, bsc_idx86Platform);

			pPlat = new CPlatform(&g_PlatformInfoWin32ALPHA);
#if !defined (_ALPHA_)
			pPlat->SetBuildable(FALSE);
#endif
			pcompmgr->RegisterBldSysComp(pPlat, bsc_idAxpPlatform);

		 	pPlat = new CPlatform(&g_PlatformInfoWin64MERCED);
			pPlat->SetBuildable(FALSE);
			pcompmgr->RegisterBldSysComp(pPlat, bsc_idMercedPlatform);

			pPlat = new CPlatform(&g_PlatformInfoXbox);
			pcompmgr->RegisterBldSysComp(pPlat, bsc_idXboxPlatform);

			break;

		case BLC_TargetType:
			// only for the Intelx86 platform!
			if (bsc_id == bsc_idx86Platform){
				// our Intelx86 project types
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32Exe);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32Dll);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32Con);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32Lib);
				pcompmgr->RegisterBldSysComp(new CProjTypeGeneric);
				pcompmgr->RegisterBldSysComp(new CProjTypeXboxExe);
				pcompmgr->RegisterBldSysComp(new CProjTypeXboxLib);
			}
			else if (bsc_id == bsc_idAxpPlatform){
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32ALPHAExe);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32ALPHADll);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32ALPHACon);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin32ALPHALib);
			}
			else if (bsc_id == bsc_idMercedPlatform){
				pcompmgr->RegisterBldSysComp(new CProjTypeWin64MERCEDExe);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin64MERCEDDll);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin64MERCEDCon);
				pcompmgr->RegisterBldSysComp(new CProjTypeWin64MERCEDLib);
			}
			break;

		case BLC_Tool:
		{
			DWORD type = pcompmgr->BldSysCompType(bsc_id);

			// for the platform?
			if (type == BLC_Platform)
			{
				// yes
				// only for the Intelx86 platform!
				if (bsc_id == bsc_idx86Platform){
					// our Intelx86 tools
					if (fGotCPP)	// install C/C++ compiler only if have language
					{
						pcompmgr->RegisterBldSysComp(new CCCompilerX86Tool,
													 GenerateComponentId(wpkgid, BCID_Tool_Compiler_x86));
					}
					pcompmgr->RegisterBldSysComp(new CLinkerX86Tool,
												 GenerateComponentId(wpkgid, BCID_Tool_Linker_x86));
				}
				else if (bsc_id == bsc_idAxpPlatform){
					pcompmgr->RegisterBldSysComp(new CCCompilerAlphaTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Compiler_Alpha));
					pcompmgr->RegisterBldSysComp(new CLinkerAlphaTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Linker_Alpha));
				}
				else if (bsc_id == bsc_idMercedPlatform){
					pcompmgr->RegisterBldSysComp(new CCCompilerMercedTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Compiler_Merced));
					pcompmgr->RegisterBldSysComp(new CLinkerMercedTool,
												 GenerateComponentId(wpkgid, BCID_Tool_Linker_Merced));
				}
			break;
			}
			// for a target type?
			else if (fGotCPP && type == BLC_TargetType)	// install C/C++ compiler only if have language
			{		   
				// yes
				CBldSysCmp * pcomp = NULL;
				pcompmgr->LookupBldSysComp(bsc_id, pcomp);
				VSASSERT(pcomp != NULL, "Failed to look build system component!");

				if (pcomp->RelatedCompId() == bsc_idx86Platform)
				{
					if (((CProjType *)pcomp)->GetUniqueTypeId() == CProjType::generic)
						break;
					// add our Intelx86 C/C++ compiler tool to these target types
					((CProjType *)pcomp)->AddTool(wpkgid, BCID_Tool_Compiler_x86);
				}
				else if (pcomp->RelatedCompId() == bsc_idMercedPlatform)
				{
					if (((CProjType *)pcomp)->GetUniqueTypeId() == CProjType::generic)
						break;
					// add our Intelx Merced C/C++ compiler tool to these target types
					((CProjType *)pcomp)->AddTool(wpkgid, BCID_Tool_Compiler_Merced);
				}
				else if (pcomp->RelatedCompId() == bsc_idAxpPlatform)
				{
					if (((CProjType *)pcomp)->GetUniqueTypeId() == CProjType::generic)
						break;
					// add our Alpha C/C++ compiler tool to these target types
					((CProjType *)pcomp)->AddTool(wpkgid, BCID_Tool_Compiler_Alpha);
				}
			}
			break;
		}

		case BLC_OptionHdlr:
			if (bsc_id == bsc_idx86Platform){
				// our Intelx86 option handlers
				if (fGotCPP)	// install C/C++ compiler only if have language
				{
					pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(CompilerIntelx86));
				}
	
				pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(LinkerIntelx86));
			}
			else if (bsc_id == bsc_idAxpPlatform){
				pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(CompilerAlpha));
				pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(LinkerAlpha));
			}
			else if (bsc_id == bsc_idMercedPlatform){
				pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(CompilerMerced));
				pcompmgr->RegisterBldSysComp(new OLD_OPTION_HANDLER(LinkerMerced));
			}
			break;

		case BLC_Scanner:
			break;

		default:
			break;
	}

	// nothing left to register
	return FALSE;
}

extern "C" BOOL PASCAL InitPackage(CObList *lstPackages)
{
	// register this package

	// other initialization
    lstPackages->AddTail(new CIntelx86CAddOn);
	return TRUE;	// init'ed ok
}
extern "C" void PASCAL AFX_EXPORT ExitPackage()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\targitem.cpp ===
//
//	CTargetItem
//
//	This is a projitem that represents a target.
//
//	[colint]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop

#include "bldrfile.h"	// our CBuildFile
#include "targitem.h"
#include "project.h"
#include "projdep.h"
#include "VCProjConvert.h"

IMPLEMENT_SERIAL (CTargetItem, CProjContainer, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// A target item has only one property at the moment,
// its name, and this may be deleted in the future as
// its name should really be the name of the target
// file it generates when built.

#define theClass CTargetItem
BEGIN_SLOBPROP_MAP(CTargetItem, CProjContainer)
END_SLOBPROP_MAP()
#undef theClass

CTargetItem::CTargetItem()
{
	// our current target is us!
	m_pOwnerTarget = this;

	m_strTargDir = "";
}

CTargetItem::~CTargetItem()
{
	// delete our contained file-items
	DeleteContents();
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands

BOOL CTargetItem::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	VSASSERT(fPrjChanged == FALSE, "PreMoveItem must let fPrjChanged be TRUE"); // not supported
	if (pContainer)
	{
		VSASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CProject)), "Container must be a project");
	}

	// do the base-class thing
	if (!CProjContainer::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
GPT CTargetItem::GetIntProp(UINT idProp, int& val)
{
	return CProjContainer::GetIntProp(idProp, val);
}

GPT CTargetItem::GetStrProp (UINT idProp, CString &str)
{
	if (idProp == P_ProjConfiguration || idProp == P_ProjItemFullPath || idProp == P_SccStatus)
	{
		// Thunk this property up to the project
		CProject* pProject = GetProject();
		
		return pProject->GetStrProp(idProp, str);
	}
	else
 		return CProjContainer::GetStrProp ((idProp == P_ProjItemName || idProp == P_Title) ? P_TargetName : idProp, str);
}

BOOL CTargetItem::SetStrProp (UINT idProp,  const CString &str)
{
	BOOL bRetval;
	CString strChanged;

	// P_ProjItemName is synonym for P_TargetName
	if (idProp == P_ProjItemName)
		idProp = P_TargetName;

	if (idProp == P_TargetName) 
	{
		// error if this name is blank
		if (str.IsEmpty())
		{
			InformDependants(idProp);
			return FALSE;
		}
	}
 
 	bRetval = CProjContainer::SetStrProp (idProp, str);

	return bRetval;
}

// Target name prefix written to the makefile
const TCHAR *CTargetItem::pcNamePrefix	= _TEXT("Name ");

// Reads target name comments and sets up the config recs accordingly. Also
// registers the target with the target manager.
BOOL CTargetItem::IsNameComment(CObject *&pObject)
{
	// If this is not a makefile comment then give up now!
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
		return FALSE;

	CMakComment *pMc = (CMakComment*) pObject;

	// Skip over any initial white space
	TCHAR *pc, *pcEnd;
	pc = pMc->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// We should have the target name prefix at the front of
	// the comment
	if (_tcsnicmp(pcNamePrefix, pc, 4) != 0)
		return FALSE;

	// Ok, we found the prefix so skip over it.
	pc += 4;
	SkipWhite(pc);

	// Get the quoted target name
	if (!GetQuotedString(pc, pcEnd))
		return FALSE;

	*pcEnd = _T('\0');

	CString strName = pc;
	BOOL bTargetRegistered = FALSE;

	// Now we have the target name get the corresponding config rec
	// and set it to be valid for this target item.
	CProject * pProject = GetProject();
	if (pProject->m_bConvertedDS4x)
	{
		// Register this target with the project target manager.
		CProject * pNewProj = NULL;
		CString strProject;
		CProject::InitProjectEnum();
		while ((pNewProj = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
		{
			if (pNewProj->RegisterTarget(strName, this))  // see if matching config
			{
				if (pNewProj != pProject)
				{
					// fix up proper containment
					CSlob * pContainer = pNewProj;
					(void)PreMoveItem(pContainer, FALSE, TRUE, FALSE);
					(void)MoveItem(pContainer, (CSlob *)NULL, FALSE, TRUE, FALSE);
					pProject = pNewProj;
				}
				g_pActiveProject = pProject; // later code will depend on this
				bTargetRegistered = TRUE;
				break;
			}
		}
		VSASSERT(bTargetRegistered, "Target must be registered");
	}

	// Force the target into it's own config.
 	pProject->SetActiveConfig(strName);
	CConfigurationRecord * pcrTarg = GetActiveConfig();

	if (GetTargetName().IsEmpty())
	{
		int index = strName.Find(" - ");
		VSASSERT(index > 0, "Malformed target name");
		CString strTargetName = strName.Left(index);
		SetTargetName(strTargetName);
		if (GetProject()->GetTargetName().IsEmpty())
			GetProject()->SetTargetName(strTargetName);
		VSASSERT(strTargetName == GetProject()->GetTargetName(), "Malformed target name");
	}

	// ensure that the target has a matching config. and it is valid
	pcrTarg->SetValid(TRUE);

	// Register this target with the project target manager.
	if (!bTargetRegistered)
		pProject->RegisterTarget(strName, this);

	CTargetItem *pTarget = pProject->GetTarget(strName);
	VSASSERT(pTarget == this, "Our project doesn't acknowledge us!");
	CString strDir;
	if (pProject->GetStrProp(P_Proj_TargDir, strDir)==valid)
	{
		CPath path;
		path.CreateFromDirAndFilename(pProject->GetWorkspaceDir(), strDir);
		strDir = path.GetFullPath();
		pTarget->SetTargDir(strDir);
	}

	delete pObject; pObject = NULL;
	return TRUE;
}

BOOL CTargetItem::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
//	Read in this item and any childred from a makfile reader.  The make
//  comment is the first line of our stuff:
//
	CObject *pObject = NULL;
	CString str;

	TRY
    {
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
			AfxThrowFileException (CFileException::generic);

		m_cp = EndOfConfigs;
 		delete pObject; pObject = NULL;

		for (pObject = mr.GetNextElement (); pObject;pObject = mr.GetNextElement ())
	   	{
			if (IsNameComment(pObject))
				continue;
			else if (IsPropComment(pObject))
				continue;
			else if (IsAddSubtractComment(pObject))
				continue;
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				SuckMacro((CMakMacro *)pObject, BaseDir);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				if (!SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException (CFileException::generic);
			}
			// Comment marks start of children:
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment))) 
			{
				VSASSERT(m_cp==EndOfConfigs, "Malformed project file");
				mr.UngetElement ( pObject );
				pObject = NULL;
				break;
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakEndOfFile))) 
			{
				AfxThrowFileException (CFileException::generic);
			}

	   		delete (pObject); pObject = NULL;
		}				 

		CProjContainer * pContainer = this;
		CProject * pProject = GetProject();
		if (pProject->m_bConvertedDS4x || (pProject->m_bProjConverted && (!pProject->m_bConvertedVC20) 
			&& (!pProject->m_bConvertedDS5x && !pProject->m_bConvertedDS6 && !pProject->m_bConvertedDS61)))
		{
 			CString strName, strFilter;
			strName = CVCProjConvert::s_strSourceFilesString;

			CProject *pProj = g_pActiveProject;
			CProjType * pProjType = pProj->GetProjType();

			BOOL bOK = strFilter.LoadString(IDS_SOURCE_FILES_FILTER);
			VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
			pContainer = AddNewGroup(strName, strFilter);
		}
		// Read in children:
		if (!pContainer->ReadInChildren(mr, BaseDir))
 			AfxThrowFileException (CFileException::generic);
	}
	CATCH ( CException, e)
	{
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	// do the rest of the move
	(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

	return TRUE;	// success
}

BOOL CTargetItem::CanContain(CSlob* pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CFileItem)) ||
	    pSlob->IsKindOf(RUNTIME_CLASS(CTimeCustomBuildItem)) ||
	    pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)) ||
		pSlob->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return TRUE;

	return FALSE;
}

void CTargetItem::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	// Exclude targets from the build
	if (fo & flt_RespectTargetExclude)
	{
		CConfigurationRecord * pcr = GetActiveConfig();
		if (pcr && pcr->IsValid())
		{
			fAddItem = FALSE;
			fAddContent = TRUE;
		}
	}
	else if (fo & flt_TargetInclude)
	{
		CConfigurationRecord * pcr = GetActiveConfig();
		if (pcr && pcr->IsValid())
		{
			fAddItem = TRUE;
			fAddContent = TRUE;
		}
	}
	else
	{
		fAddItem = FALSE;
		fAddContent = TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\x86optn.cpp ===
//
// Intelx86 Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "x86optn.h"	// our local header file

IMPLEMENT_DYNAMIC(CCCompilerX86Tool, CCCompilerNTTool)
IMPLEMENT_DYNAMIC(CLinkerX86Tool, CLinkerNTTool)

//----------------------------------------------------------------
// our INTELx86 compiler option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(CompilerIntelx86, (UINT)NULL, (UINT)NULL, P_Cpux86, P_GZ, TRUE)
    IDOPT_CPUX86,       "G%{3|4|5|6|B}1",				OPTARGS1(P_Cpux86),                     single,
	IDOPT_CALLCONV,		"G%{d|r|z}1",				OPTARGS1(P_CallConv),					single,
	IDOPT_GZ,           "GZ%T1",                    OPTARGS1(P_GZ),                 single,
	IDOPT_BYTE,			"Zp%{2|4|8|16|[1]}1",		OPTARGS1(P_ByteAlign),					single,
	IDOPT_THREAD,		"M%{Ld|Td|Dd|L|T|D}1",	OPTARGS1(P_Thread),						single,

// compatibility with VC++ 1.x compiler options, we'll read them
// in then nuke them ;-)
	IDOPT_FLOATPOINT,	"FP%{i87|i|a|c87|c}1",		OPTARGS1(P_FloatPoint),					single,

// run-time checks
	IDOPT_CPP_RTC,		"RTC%{1|2}1",				OPTARGS1(P_RTC),				single,	
	IDOPT_CPP_RTC_StackFrame,	"RTCs%T1%<3>2",		OPTARGS2(P_RTC_StackFrame, P_RTC),	single,		
	IDOPT_CPP_RTC_MemoryAccess,	"RTCm%T1%<3>2",		OPTARGS2(P_RTC_MemoryAccess, P_RTC),	single,
	IDOPT_CPP_RTC_MemoryLeaks,	"RTCl%T1%<3>2",		OPTARGS2(P_RTC_MemoryLeaks, P_RTC),	single,
	IDOPT_CPP_RTC_SmallerType,	"RTCc%T1%<3>2",		OPTARGS2(P_RTC_SmallerType, P_RTC),	single,	
	IDOPT_CPP_RTC_VectorNew,	"RTCv%T1%<3>2",		OPTARGS2(P_RTC_VectorNew, P_RTC),	single,	
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(CompilerIntelx86)
	OPTDEF_INT(Cpux86, 5)
	OPTDEF_INT(CallConv, 1)
	OPTDEF_INT(ByteAlign, 3)
	OPTDEF_INT(Thread, 4)
	OPTDEF_INT(FloatPoint, -1)
	OPTDEF_INT(RTC, 0)
	OPTDEF_BOOL(RTC_StackFrame, FALSE)
	OPTDEF_BOOL(RTC_MemoryAccess, FALSE)
	OPTDEF_BOOL(RTC_MemoryLeaks, FALSE)
	OPTDEF_BOOL(RTC_SmallerType, FALSE)
	OPTDEF_BOOL(RTC_VectorNew, FALSE)
	OPTDEF_BOOL(GZ, FALSE)
END_OPTDEF_MAP()

//----------------------------------------------------------------
// our INTELx86 linker option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(LinkerIntelx86, (UINT)NULL, (UINT)NULL, (UINT)NULL, (UINT)NULL, TRUE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerIntelx86)
END_OPTDEF_MAP()

// compiler tool option default map 'faking'
BOOL OLD_OPTION_HANDLER(CompilerIntelx86)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_Thread);
}


GPT OLD_OPTION_HANDLER(CompilerIntelx86)::GetDefIntProp(UINT idProp, int & nVal)
{
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefIntProp(idProp, nVal);

	FormFakeIntProp(idProp, nVal);
	return valid;
}

void OLD_OPTION_HANDLER(CompilerIntelx86)::OnOptionIntPropChange(UINT idProp, int nVal)
{
	VSASSERT(m_pSlob != (CSlob *)NULL, "No slob set!");

	UINT idPropL = MapActual(idProp);
	int nCurrVal;

	switch (idPropL)
	{
	case P_RTC_StackFrame:
	case P_RTC_MemoryAccess:
	case P_RTC_MemoryLeaks:
	case P_RTC_VectorNew:
	case P_RTC_SmallerType:
		// make sure we should be able to do this
		if (m_pSlob->GetIntProp(MapLogical(P_RTC), nCurrVal) == valid && nCurrVal == 3)
			m_pSlob->SetIntProp(MapLogical(P_RTC), 3);
		break;

	case P_RTC:
		// get rid of GZ if we come through here at all
		if (m_pSlob->GetIntProp(MapLogical(P_GZ), nCurrVal) == valid && nCurrVal)
		{
			m_pSlob->SetIntProp(MapLogical(P_GZ), FALSE);
			m_pSlob->SetIntProp(MapLogical(P_RTC_StackFrame), TRUE);
		}
		break;

	default:
		break;
	}
}

BOOL OLD_OPTION_HANDLER(CompilerIntelx86)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// placeholders for values
	int nVal;	

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Can't have any custom RTC without 'CustomOpt' on
		case P_RTC_StackFrame:
		case P_RTC_MemoryAccess:
		case P_RTC_MemoryLeaks:
		case P_RTC_VectorNew:
		case P_RTC_SmallerType:
			(void)m_pSlob->GetIntProp(MapLogical(P_RTC), nVal);
			fValid = (nVal == 3);
			break;

		default:
			break;
	}

	return fValid;
}

void OLD_OPTION_HANDLER(CompilerIntelx86)::FormFakeIntProp(UINT idProp, int & nVal)
{
	UINT idPropL = MapActual(idProp);

	// should not call this if it is not a fake property
	VSASSERT (IsFakeProp (idProp), "Cannot call FormFakeIntProp with non-fake prop!") ;

	BOOL bUseDebugLibs = FALSE;
	((CProjItem *)m_pSlob)->GetIntProp(P_UseDebugLibs, bUseDebugLibs);

	if (bUseDebugLibs)
		{
		nVal = 1;   //MLd
		}
	else
		{
		nVal = 4;   //ML
		}
	return;
}

///////////////////////////////////////////////////////////////////////////////////////
// CCompilerX86Tool
///////////////////////////////////////////////////////////////////////////////////////
CCCompilerX86Tool::CCCompilerX86Tool() : CCCompilerNTTool()
{
}

//////////////////////////////////////////////////////////////////////////////
// Default tool options for the Intelx86 compiler tool
BOOL CCCompilerX86Tool::GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption)
{
	// are we a mode we can handle?
	VSASSERT(mode == MOB_Debug || mode == MOB_Release, "Unrecognized mode!");
	
	CString strPart; 

	// Our common tool options
	BOOL bOK = strOption.LoadString(IDS_WIN32_CPLR_COMMON);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

	// Our mode tool options
 	bOK = strPart.LoadString(mode == MOB_Debug ? IDS_WIN32_CPLR_DBG : IDS_WIN32_CPLR_REL);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	strOption += _T(' '); strOption += strPart;

	// Return appropriate tool options according to the attributes
	// of the target type
	UINT nIDAttrib = (UINT)-1;

	// console? (takes precedence over executable, executable is implicit...)
	if (attrib & SubsystemConsole)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32CON_CPLR_DBG : IDS_WIN32CON_CPLR_REL;
	}
	// executable
	else if (attrib & ImageExe)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32EXE_CPLR_DBG : IDS_WIN32EXE_CPLR_REL;
	}
	// dynamic link library
	else if (attrib & ImageDLL)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32DLL_CPLR_DBG : IDS_WIN32DLL_CPLR_REL;
	}
	// static library
	else if (attrib & ImageStaticLib)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32LIB_CPLR_DBG : IDS_WIN32LIB_CPLR_REL;
	}	 

	// Our attribute tool options
	if (nIDAttrib != (UINT)-1)
	{
		bOK = strPart.LoadString(nIDAttrib);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
		strOption += _T(' '); strOption += strPart;
	}

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler Intelx86 options are ok to use/not use MFC
BOOL CCCompilerX86Tool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	// Set the thread type usage
	pProjItem->SetIntProp(MapLogical(P_Thread), 1);

	return CCCompilerNTTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}

///////////////////////////////////////////////////////////////////////////////////////
// CLinkerX86Tool
///////////////////////////////////////////////////////////////////////////////////////
CLinkerX86Tool::CLinkerX86Tool() : CLinkerNTTool()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\xbox.h ===
//
// Xbox C/C++ AddOn
//
// Xbox Platform C/C++ Tools Component Add-On 'package'
//

// platforms, tools, option handlers provided by this module

#pragma once

// add-on's name
#define szAddOnXbox "Microsoft Xbox Development Kit C/C++"

// our 'xbox' build system components

#define BCID_Platform_Xbox			10

#define BCID_ProjType_XboxExe		260
#define BCID_ProjType_XboxLib		263
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\x86optn.h ===
//
// Intelx86 Tool Options and Tools
//

#pragma once
#include "optncplr.h"	// our base option handler, the Common Compiler

//----------------------------------------------------------------
// our INTELx86 compiler option data
//----------------------------------------------------------------

// INTELx86 compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	CompilerIntelx86, /* name */
	szAddOnx86, BCID_OptHdlr_Compiler_x86, /* Intelx86 compiler option handler */
	szAddOnx86, BCID_Tool_Compiler_x86, /* Intelx86 compiler tool */
	szAddOnGeneric, BCID_OptHdlr_Compiler /* base generic compiler option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' int prop
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);

	// handle setting of option int props
	virtual void OnOptionIntPropChange(UINT idProp, int nVal);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

private:
	// form a 'fake' string prop
	virtual void FormFakeIntProp(UINT idProp, int & nVal);

END_OPTHDLR()

// INTELx86 compiler tool properties
#define P_Cpux86				 		0x1000
#define P_CallConv						0x1001
#define P_ByteAlign				   		0x1002
#define P_FloatPoint					0x1003
#define P_Thread						0x1004
#define P_RTC							0x1005
#define P_RTC_StackFrame				0x1006
#define P_RTC_MemoryAccess				0x1007
#define P_RTC_MemoryLeaks				0x1008
#define P_RTC_SmallerType               0x1009
#define P_RTC_VectorNew					0x100a
#define P_GZ                            0x100b

// INTELx86 compiler tool options (option ids)
#define IDOPT_CPUX86					2000//072199 IDOPT_BASE + 0
#define IDOPT_CALLCONV					2001//072199 IDOPT_BASE + 1
#define IDOPT_BYTE						2002//072199 IDOPT_BASE + 2
#define IDOPT_FLOATPOINT				2003//072199 IDOPT_BASE + 3
#define IDOPT_THREAD					2004//072199 IDOPT_BASE + 4
#define IDOPT_CPP_RTC					2005//072199 IDOPT_BASE + 5
#define IDOPT_CPP_RTC_StackFrame		2006//072199 IDOPT_BASE + 8
#define IDOPT_CPP_RTC_MemoryAccess		2007//072199 IDOPT_BASE + 9
#define IDOPT_CPP_RTC_MemoryLeaks		2008//072199 IDOPT_BASE + 10
#define IDOPT_CPP_RTC_SmallerType		2009//072199 IDOPT_BASE + 11
#define IDOPT_CPP_RTC_VectorNew			2010//072199 IDOPT_BASE + 12
#define IDOPT_GZ                        2011//072199 IDOPT_BASE + 13

#include "optnlink.h"	// our base option handler, the NT Linker 

//----------------------------------------------------------------
// our INTELx86 linker option data
//----------------------------------------------------------------

// INTELx86 compiler option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerIntelx86, /* name */
	szAddOnx86, BCID_OptHdlr_Linker_x86, /* Intelx86 linker option handler */
	szAddOnx86, BCID_Tool_Linker_x86, /* Intelx86 linker tool */
	szAddOnGeneric, BCID_OptHdlr_LinkerNT /* base generic NT linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

END_OPTHDLR()

#include "optncplr.h"			// the CBuildTool classes
class CCCompilerX86Tool : public CCCompilerNTTool
{
	DECLARE_DYNAMIC (CCCompilerX86Tool)

public:
	CCCompilerX86Tool();

	// Default tool options for the Intelx86 compiler tool
	virtual BOOL GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption);

	//	Ensure that the tool will build an MFC project item.
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	virtual BOOL PerformSettingsWizard(CProjItem *, BOOL fDebug, int iUseMFC);
};

#include "optnlink.h"	// our COMMON compiler tool
class CLinkerX86Tool : public CLinkerNTTool
{
	DECLARE_DYNAMIC (CLinkerX86Tool)

public:
	CLinkerX86Tool();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\resdll\gpcmd.h ===
//----------------------------------------------------------------------------
//
//  Microsoft Visual C++
//
//  Microsoft Confidential
//  Copyright 1997-1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:	vccmd.h
//	Area:	VC Package Commands
//
//  Contents:
//		VC Package Menu, Group, Command IDs
//
//----------------------------------------------------------------------------
#ifndef _VCCMD_H
#define _VCCMD_H

#include "stdidcmd.h"

// Menus
#define IDM_VC_VCPROJ				0x0001
#define IDM_VC_VCSCC				0x0003
#define IDMX_VC_PROJECTNODE			0x0004
#define IDMX_VC_FOLDERNODE			0x0005
#define IDMX_VC_FILENODE			0x0006
#define IDM_VC_CSCD_BLDEVENTS		0x0007
#define IDM_VC_CSCD_USERTOOLS		0x0008
#define IDMX_VC_PROJNODE_DEBUG		0x0009
#define IDMX_VC_EXEPROJECT			0x000A
#define IDMX_VC_MULTINODE			0x000B

#define IDM_VC_ADD 					0x000C
#define IDM_VC_PRJ_DEBUG 			0x000D

// Groups
#define IDG_VC_VCP					0x0010
#define IDG_VC_VCPROJ				0x0011
#define IDG_VC_BUILD				0x0013
#define IDG_VC_EXECUTE				0x0014
#define IDG_VC_VCSCC				0x0015
#define IDG_VC_FOLDER				0x0016
#define IDG_VC_FILE					0x0017
#define IDG_VC_PREVIEW				0x0018
#define IDG_VC_DELETE				0x0019
#define IDG_VC_PROPERTIES			0x001A
#define IDG_VC_PROJSAVE				0x001B
#define IDG_VC_PROJECT				0x001C
#define IDG_VC_VCSCCMENU			0x001D
#define IDG_VC_DELETERENAME			0x001E
#define IDG_VC_ADDPROJ				0x001F
#define IDG_VC_REMOVEFROMPROJ       0x0020
#define	IDG_VC_SETTINGS				0x002F
#define	IDG_VC_SAVE					0x003F
#define IDG_VC_PREVIEWSTART			0x004F
#define IDG_VC_PROJECTBUILD			0x005F
#define IDG_VC_NODEPLOY				0x0060
#define IDG_VC_REMOVEUNLOAD			0x0061
#define IDG_VC_BLDEVENTS			0x0062
#define IDG_VC_VCTOOLS				0x0063
#define IDG_VC_USERTOOLS			0x0064
#define IDG_VC_DEBUG				0x0065
#define IDG_VC_PRJ_BUILD			0x0066
#define IDG_VC_ADD					0x0067
#define IDG_VC_START				0x0068
#define IDG_VC_CTXT_ADD				0x0069
#define IDG_VC_CTXT_DEBUG			0x006A
#define IDG_VC_PRJ_REMOVE  		    0x006B
#define IDG_VC_FLD_REMOVE      		0x006C
#define IDG_VC_FIL_REMOVE      		0x006D


//Command IDs are now in src\common\inc\stdidcmd.h
#define cmdidClassWiz				0xF100
#define cmdidAddNewItemCtx			0xF101
#define cmdidAddExistingItemCtx		0xF102
#define cmdidAddClassCtx			0xF103
#define cmdidAddResource			0xF104
#define cmdidAddResourceCtx			0xF105


#endif //_VCCMD_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\resdll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by prjbldui.rc
//
// WARNING: do NOT place IDs that must remain FIXED (because they are in a .rgs, .vsz, etc. file)
// just anywhere.  There is a special section at the bottom of this file intended for those IDs
// (and ONLY those IDs).  In order to easily identify these numbers, please keep them in the range
// of 10000 to 10999.
//
#define IDI_AboutBox                    1001
#define IDB_SPLASHSCREEN                1002

#define IDC_ARGS                        101
#define IDS_BUILD_TARGETNAME            1001
#define IDS_BUILD_UPTODATE              1002
#define IDS_CUSTOMBUILD_DESC            1003
#define IDS_DESC_BSCMAKING              1005
#define IDS_DESC_CLEANING               1006
#define IDS_DESC_COMPILING              1007
#define IDS_DESC_LIBING                 1008
#define IDS_DESC_LINKING                1009
#define IDS_DESC_MKTYPLIB_COMPILING     1010
#define IDS_DESC_RC_COMPILING           1011
#define IDS_CUSTOMEVENT_DESC            1012
#define IDS_DESC_ALINK_BUILDING         1013
#define IDS_DESC_WEB_COMPILING         	1014
#define IDS_NMAKE_DESC                  1015
#define IDS_ERR_OUT_ARG                 1016
#define IDS_READONLY                    1017
#define IDS_RESOURCEVIEW                1018
#define IDS_TRUE						1022
#define IDS_FALSE						1023
#define IDS_MACROS_EXPANDED				1024
#define IDS_MACROS_CONTRACTED			1025
#define IDC_INSERTMACRO					1026
#define IDC_MACROPICKER_LIST            1027
#define IDS_PROD_NAME                   1028
#define IDS_PROD_DESC                   1029
#define IDS_WEB_DEPLOYING				1030
#define IDS_WEB_DEPLOYING				1030

#define IDS_CREATING_COMMANDLINE        1050
#define IDS_WRN_ENVVAR                  1051
#define IDS_HTML_FOOTER                 1052
#define IDS_COULD_NOT_GET_TEMP_PATH     1053
#define IDS_COULD_NOT_GET_CWD           1054
#define IDS_CREATING_TEMPFILE           1055
#define IDS_COULD_NOT_DELETE_TEMP_FILE  1056
#define IDS_TERMINATE_USER_REQ          1057
#define IDS_CREATING_LINK_MIDL_RSP		1058
#define IDS_USE_LINK_MIDL_RSP			1059
#define IDS_LINK_MIDL_RSP_NAME			1060

#define IDS_PROJECTSAVEFORMATS			1080
#define IDS_SOUND_BUILD_COMPLETE        1081
#define IDS_SOUND_BUILD_ERROR           1082
#define IDS_SOUND_BUILD_UPTODATE        1083
#define IDS_SOUND_BUILD_WARNING         1084
#define IDS_INCLUDE_NOT_FOUND           1085
#define IDS_BUILD_COMPLETE              1086

#define IDS_HTML_COMMANDLINE            1100
#define IDS_HTML_OUTPUTWINDOW           1101
#define IDS_HTML_HEADER                 1102
#define IDS_RESULTS                     1103
#define IDS_USERCANCELED                1104
#define IDS_ERR_CREATE_TEMP_FILE        1105
#define IDS_HTML_PRE_HEADER             1106
#define IDS_HTML_POST_HEADER            1107
#define IDS_HTML_PRE_TOP                1108
#define IDS_HTML_POST_TOP               1109
#define IDS_HTML_PRE_FOOTER             1110
#define IDS_HTML_POST_FOOTER            1111
#define IDS_FILE_EXISTS                 1112
#define IDS_FILE_EXISTS_ERR             1113
#define IDS_FILE_ONDISK_ERR             1114
#define IDS_FILE_CREATION_ERR			1115
#define IDS_HTML_HEADER_MARKER			1116
#define IDS_HTML_ENVIRONMENT			1117

#define IDD_CONVERTDLG                  1146
#define IDC_YESTOALL                    1147
#define IDC_NOTOALL						1148
#define IDC_NOBUTTON                    1149
#define IDC_YESBUTTON                   1150
#define IDC_CONVERTMSG                  1151
#define IDS_CONVERTMSG                  1152

#define IDS_FAIL_VCSPAWN_PRJ0001                1200
#define IDS_FAIL_EXECUTE_PRJ0002                1201
#define IDS_FAIL_SPAWN_PRJ0003                  1202
#define IDS_GET_COMMAND_LINE_FAILED_PRJ0004     1203
#define IDS_COULD_NOT_GET_TEMP_NAME_PRJ0005     1204
#define IDS_COULD_NOT_OPEN_TEMP_FILE_PRJ0006    1205
#define IDS_COULD_NOT_CREATE_DIR_PRJ0007        1206
#define IDS_PROJ_COULD_NOT_DELETE_FILE_PRJ008   1207
#define IDS_WARN_NOBUILDLOG_PRJ0009             1208
#define IDS_CANNOT_BUILD_DEP_PRJ0010            1209
#define IDS_ERR_RESOURCES_EVENT_PRJ0011			1210
#define IDS_ERR_RESOURCES_THREAD_PRJ0012		1211
#define IDS_ERR_RESOURCES_PIPE_PRJ0013			1212
#define IDS_WRN_NOCOMSPEC_PRJ0014				1213
#define IDS_ERR_DEVNULL_PRJ0015					1214
#define IDS_ERR_SECURITY_PRJ0016				1215
#define IDS_ERR_NOCWD_PRJ0017					1216
#define IDS_MISSING_ENV_VAR_PRJ0018             1217
#define IDS_ERR_CUSTOM_PRJ0019             		1218
#define IDS_ERR_BADFILE_PRJ0020					1219
#define IDS_ERR_BADFILE_PRJ0021					1220
#define IDS_ERR_BADFILE_PRJ0022					1221
#define IDS_ERR_BADFILE_PRJ0023					1222
#define IDS_ERR_UNICODE_PATH_PRJ0024            1223
#define IDS_ERR_UNICODE_BAT_PRJ0025             1224
#define IDS_ERR_UNICODE_RSP_PRJ0026             1225
#define IDS_WRN_UNICODE_VAL_PRJ0027             1226
#define IDS_ERR_UNICODE_TEMP_PRJ0028			1227
#define IDS_WARN_NO_CUST_OUTPUT_PRJ0029			1228
#define IDS_ERR_MACRO_EXPANSION_PRJ0030         1229
#define IDS_ERR_CUST_OUTPUT_FILE_INVALID_PRJ0031 1230
#define IDS_ERR_CUST_OUTPUT_PROJ_INVALID_PRJ0032 1231
#define IDS_ERR_CUST_INPUT_FILE_INVALID_PRJ0033	1232
#define IDS_ERR_CUST_INPUT_PROJ_INVALID_PRJ0034	1233
#define IDS_ERR_UNICODE_XML_PRJ0035				1234
#define IDS_ERR_DEPLOY_ADDL_FILE_INVALID_PRJ0036 1235
#define IDS_ERR_NO_IIS_PRJ0038					1237
#define IDS_ERR_NO_CREATE_TEMP_FILE_PRJ0039		1238

#define IDS_SATELLITETEST               1301
#define IDS_FILTER_ALL                  1304
#define IDS_PROJECTS_TITLE              1305
#define IDS_ERROR_OPEN                  1306
#define IDDP_SETTINGSPAGE               1311
#define IDC_GRIDPOS                     1312
#define IDC_TOOLSOPTSGRIDPOS            1319
#define IDR_TOOLDIRMACRO_POPUP          1320
#define IDR_TOOLFILEMACRO_POPUP         1321
#define IDDP_ADDITIONALPAGE             1324
#define IDC_ALLOPTIONS              	1325
#define IDC_ADDOPTIONS              	1326
#define IDS_MULTISELECT	             	1327
#define IDS_PREBUILDEVENT_DESC          1328
#define IDS_PRELINKEVENT_DESC           1329
#define IDS_POSTBUILDEVENT_DESC         1330
#define IDS_FILENAME                    1331
#define IDD_EXE_FOR_DEBUG               1332
#define IDDP_OPTIONS_BUILD              1333
#define IDDP_OPTIONS_DIRECTORIES        1334
#define IDC_DIRS_TOOLSETS               1338
#define IDC_DIRS_TYPE                   1339
#define IDC_DIRLIST                     1340
#define IDS_DIRS_EXECUTABLE             1341
#define IDS_DIRS_INCLUDE                1342
#define IDS_DIRS_REFERENCE              1343
#define IDS_DIRS_LIB                    1344
#define IDS_DIRS_SOURCE                 1345
#define IDS_BUILTGROUP                  1346
#define IDS_DEBUGGROUP                  1347
#define IDS_CONTENTGROUP                1348
#define IDS_DEBUGGERS					1349
#define IDS_REMOTESETTINGS				1350
#define IDS_ACTION						1351
#define IDS_PROJ_UP_VERSION				1352
#define IDS_NO_PROJ_VERSION				1353
#define IDS_E_ADSI_NOTINSTALLED			1354
#define IDS_E_CANTCFG_APPROOT_IIS4_FROM_IIS5 1355
#define IDS_NO_CL_OPTIMIZE				1356
#define IDS_ERR_EMPTY_URL				1357
#define IDS_ERR_UNSUPPORTED_URL			1358
#define IDS_ERR_PROJ_RELOADED			1359

#define IDS_Additional	             	1400
#define IDS_ClOptimization              1401
#define IDS_ClPreprocessor              1402
#define IDS_ClAdvanced                  1403
#define IDS_ClCodeGeneration            1404
#define IDS_ClLanguage                  1405
#define IDS_ClPrecompiledHeaders        1406
#define IDS_ClOutputFiles               1407
#define IDS_ClBrowseInfo                1408
#define IDS_ClGeneral                   1409
#define IDS_Cl                          1410
#define IDS_MidlAdvanced	            1411
#define IDS_MidlOutput		            1412
#define IDS_MidlGeneral                 1413
#define IDS_Midl                        1414
#define IDS_RCGeneral                   1415
#define IDS_RC                          1416
#define IDS_BSCGeneral                  1417
#define IDS_BSC                         1418
#define IDS_LibGeneral                  1419
#define IDS_Lib                         1420
#define IDS_LinkGeneral                 1421
#define IDS_LinkInput                   1422
#define IDS_LinkAdvanced                1423
#define IDS_LinkDebug                   1424
#define IDS_LinkSystem                  1425
#define IDS_LinkOptimization            1426
#define IDS_Link                        1427
#define IDS_BldEvents                   1428
#define IDS_PreBldGeneral               1429
#define IDS_PreBuildEvent               1430
#define IDS_PreLinkGeneral              1431
#define IDS_PreLinkEvent                1432
#define IDS_PostBldGeneral              1433
#define IDS_PostBuildEvent              1434
#define IDS_DebugSettings               1435
#define IDS_GeneralConfigSettings       1436
#define IDS_CustomGeneral               1437
#define IDS_CustomOutputs               1438
#define IDS_CustomBuild                 1439
#define IDS_CustomCommand               1440
#define IDS_NMakeGeneral                1441
#define IDS_NMake                       1442
#define IDS_LinkAlink					1443
#define IDS_Alink						1444
#define IDS_WEBTOOL						1445
#define IDS_WebGeneral					1446
#define IDS_DEPLOYTOOL					1447
#define IDS_DeployGeneral				1448
#define IDS_XBOXDEPLOYTOOL				1449
#define IDS_XboxDeployGeneral			1450
#define IDS_XBOXIMAGETOOL				1451
#define IDS_XboxImageGeneral			1452
#define IDS_XboxImageCertificate		1453
#define IDS_XboxImageTitleInfo			1454

#define IDS_WARN_PRJOPEN_FAILED         1500
#define IDS_VCPROJECT                   1501
#define IDC_CALLING_PROG_TXT2           1502
#define IDC_CALLING_PROG_TXT            1503
#define IDC_CALLING_PROG                1504
#define IDC_DEBUG_BROWSE                1505
#define IDC_HTTP_URL_TXT                1506
#define IDC_HTTP_URL                    1507
#define IDS_LinkMIDL					1508
#define IDS_BUILD_FAILED				1509
#define IDS_BUILD_SUCCEEDED				1510
#define IDS_NOTOOL						1511
#define IDS_REGISTER_OUTPUT				1512
#define IDS_SOURCEGROUP                	1513
#define IDDP_MULTI_LINE					1515
#define IDC_INHERIT						1516
#define IDC_MULTILINELIST				1517
#define IDDP_MULTI_DIRECTORY_PICKER_EDITOR 1518
#define IDS_DebugProgram				1519
#define IDC_DIRCONTROL                  1520
#define IDS_DIRBROWSE					1521
#define IDDP_SINGLE_DIRECTORY_PICKER_EDITOR 1522
#define IDC_EXE_FOR_DEBUG_HELP			1523
#define IDS_DONE						1524
#define IDS_E_READ_ONLY_PROJ_FILE       1525
#define IDS_FILE                        1526
#define IDS_FILTER                      1527
#define IDS_PROJECT                     1528
#define IDS_ITEM                        1529
#define IDS_UNKNOWN_ITEM                1530
#define IDS_BAD_DROP_PARENT             1531
#define IDS_BAD_PASTE_PARENT            1532
#define IDS_BAD_PATH_PARENT             1533
#define IDS_ERR_DROP                    1534
#define IDS_ERR_PASTE                   1535
#define IDS_E_MISSINGSOURCENODE         1536
#define IDS_E_COPY_IN_SAME_PROJ         1537
#define IDS_E_REMOVE_NOT_FOUND          1538
#define IDS_E_NO_REMOVE                 1539
#define IDS_FILTER_EXISTS               1540
#define IDS_E_INVALID_NAME              1541
#define IDS_E_ZOMBIE                    1542
#define IDS_E_FILE_ALREADY_EXISTS       1543
#define IDS_W_DROP_SHELL_FOLDERS        1544
#define IDD_STRING_EDIT					1545
#define IDS_GENERALCAT     				1546
#define IDC_STRING_EDIT					1547
#define IDD_STRING_EDIT_WITH_RETURNS	1548
#define IDS_PROJDEFAULTSCAT				1549
#define IDS_ADDCLASS					1550
#define IDD_COMMANDS_EDIT				1551
#define IDC_COMMANDS_EDIT				1552
#define IDS_NOBUILDCOMMANDLINEMSG		1553
#define IDS_NOCLEANCOMMANDLINEMSG		1554
#define IDS_NOREBUILDCOMMANDLINEMSG		1555
#define IDS_INHERITPRJ					1556
#define IDS_INHERITPRJ2					1557
#define IDS_INHERITPRJDEF				1558
#define IDS_INHERITPRJDEF2				1559
#define IDS_EDIT						1560
#define IDS_E_SYS_STYLE_LOAD_FAILED		1561
#define IDS_E_USER_STYLE_LOAD_FAILED	1562
#define IDS_CONVERSION_ERROR			1563
#define IDS_E_SAME_SOURCE_DEST          1564
#define IDS_E_DBG_BLANK                 1565
#define IDS_E_FILTER_ALREADY_EXISTS     1566
#define IDS_EXE_FOR_DBG_TITLE           1567
#define IDS_MAKCONVERSION_ERROR			1568
#define IDS_CONVERT_SOURCE_FILES        1569
#define IDS_BLDLOG_SAVED				1570
#define IDS_E_URL_INVALID              	1571
#define IDS_BUILD_TIME                  1572
#define IDS_LOG_BUILD_TIME              1573
#define IDS_PROJECT_WORD				1574
#define IDS_NEWFOLDER					1575
#define IDS_CUTLINE						1576
#define IDS_LINEUP						1577
#define IDS_LINEDOWN					1578
#define IDS_BROWSE						1579
#define IDS_PRIMARY_OUTPUT				1580
#define IDS_SECONDARY_OUTPUT			1581
#define IDS_CONTENT_OUTPUT				1582
#define IDS_SOURCE_OUTPUT				1583
#define IDC_SETTINGSEDIT_HELP			1584
#define IDC_CALLING_PROG_BROWSE         1585
#define IDS_UNSUPPORTED_PROJ_FILE		1586
#define IDS_CHECKENTRIES				1587
#define IDC_MACROPICKER					1588
#define IDS_NAME						1589
#define IDS_VALUE						1590
#define IDS_PREBUILDEVENT_TOOLNAME		1591
#define IDS_PRELINKEVENT_TOOLNAME		1592
#define IDS_POSTBUILDEVENT_TOOLNAME		1593
#define IDS_BSCMAKE_TOOLNAME			1594
#define IDS_CL_TOOLNAME					1595
#define IDS_CUSTOM_TOOLNAME				1596
#define IDS_LIB_TOOLNAME				1597
#define IDS_LINK_TOOLNAME				1598
#define IDS_MIDL_TOOLNAME				1599
#define IDS_NMAKE_TOOLNAME				1600
#define IDS_RC_TOOLNAME					1601
#define IDS_WEB_TOOLNAME				1602
#define IDC_INHERITED					1603
#define IDC_STATIC_INHERIT				1604
#define IDC_STATIC_ALLOPTIONS			1605
#define IDC_STATIC_ADDOPTIONS			1606
#define IDS_EXE_PROJ_NAME_LBL			1607
#define IDS_EXE_PROJ_NAME_DESC			1608
#define IDS_EXE_PROJ_PATH_LBL			1609
#define IDS_EXE_PROJ_PATH_DESC			1610
#define IDS_E_DLG_FILENOTFOUND          1612
#define IDS_E_DEBUG_ASPXPERMISSIONDENIED 1613
#define IDS_E_DEBUG_ASPXFORBIDDEN		1614
#define IDS_E_DEBUG_ASPXSENDREQUESTFAILED 1615
#define IDS_E_HTTP_NOT_SUPPORTED		1616
#define IDS_E_DEBUG_ALREADY_ATTACHED	1617
#define IDS_E_NO_MORE_VUP				1618
#define IDS_DEPLOY_TOOLNAME				1619
#define IDS_SERVERSIDECAT				1620
#define IDS_WEBAPPCAT					1621
#define IDS_DESC_DEPLOYING				1622
#define IDDP_MULTI_LINE_NOINHERIT		1623
#define IDS_XBOXDEPLOY_TOOLNAME			1624
#define IDS_DESC_XBOXDEPLOYING			1625
#define IDS_XBOXIMAGE_TOOLNAME			1626
#define IDS_DESC_XBOXIMAGEING			1627

#define IDS_ERR_FILE_EXISTS						1700
#define IDS_ERR_FILTER_EXISTS					1701
#define IDS_ERR_BAD_PROJ_FILE					1702
#define IDS_ERR_BAD_STYLE_FILE					1703
#define IDS_ERR_FILE_AS_URL						1704
#define IDS_ERR_CANNOT_ADD_FILE					1705
#define IDS_ERR_BAD_FILE_NAME					1706
#define IDS_ERR_BAD_FILTER_NAME					1707
#define IDS_ERR_EMPTY_PROJ_NAME					1708
#define IDS_ERR_INVALID_FILE_NAME				1709
#define IDS_ERR_PROJ_READ_ONLY					1710
#define IDS_ERR_PARENT_AS_CHILD					1711
#define IDS_ERR_CANNOT_CREATE_PATH				1712
#define IDS_ERR_CANNOT_CREATE_RELATIVE_PATH		1713
#define IDS_ERR_MOVE_CROSS_PROJ					1714
#define IDS_ERR_BAD_FILE_PARENT					1715
#define IDS_ERR_BAD_FILTER_PARENT				1716
#define IDS_ERR_SET_NULL_PARENT					1717
#define IDS_ERR_PROJ_ZOMBIE						1718
#define IDS_ERR_TOOL_ZOMBIE						1719
#define IDS_ERR_ENUMERATOR_ZOMBIE				1720
#define IDS_ERR_STYLESHEET_ZOMBIE				1721
#define IDS_ERR_FILE_ZOMBIE						1722
#define IDS_ERR_COLLECTION_ZOMBIE				1723
#define IDS_ERR_FILTER_ZOMBIE					1724
#define IDS_ERR_GLOBALS_ZOMBIE					1725
#define IDS_ERR_CFG_ZOMBIE						1726
#define IDS_ERR_OUTPUT_ZOMBIE					1727
#define IDS_ERR_NO_DEF_TOOL						1728
#define IDS_ERR_INVALID_TOOL					1729
#define IDS_ERR_NO_MATCHING_TOOL				1730
#define IDS_ERR_NO_TOOL                         1731
#define IDS_ERR_BUILD_FAILED					1732
#define IDS_ERR_PROJ_NOT_BUILDABLE				1733
#define IDS_ERR_FILE_CFG_NOT_FOUND				1734
#define IDS_ERR_FILE_CFG_NOT_FOUND2				1735
#define IDS_ERR_FILE_NOT_FOUND_FOR_REMOVE		1736
#define IDS_ERR_FILTER_NOT_FOUND_FOR_REMOVE		1737
#define IDS_ERR_PLATFORM_NOT_FOUND				1738
#define IDS_ERR_FILTER_NOT_FOUND				1739
#define IDS_ERR_FILE_NOT_FOUND					1740
#define IDS_ERR_PROJ_NODE_NOT_FOUND				1741
#define IDS_ERR_NO_PLATFORMS					1742
#define IDS_ERR_NO_PROJ_PLATFORMS				1743
#define IDS_ERR_PROJ_NOT_FOUND_FOR_REMOVE		1744
#define IDS_ERR_STYLE_NOT_FOUND_FOR_REMOVE		1745
#define IDS_ERR_INTERNAL_ERROR					1746
#define IDS_ERR_BLD_THREAD_ALREADY_INIT			1747
#define IDS_ERR_NOT_SYS_HEADER					1748
#define IDS_ERR_ENUM_OUT_OF_BOUNDS				1749
#define IDS_ERR_RECURSE_INTDIR					1750
#define IDS_ERR_RECURSE_OUTDIR					1751
#define IDS_ERR_RECURSE_TARG    				1752
#define IDS_ERR_RECURSE_INPUT    				1753
#define IDS_ERR_RECURSE_CFG		  				1754
#define IDS_ERR_RECURSE_PROJ	  				1755
#define IDS_ERR_RECURSE_REMOTE	  				1756
#define IDS_ERR_RECURSE_PLATFORM  				1757
#define IDS_PROJ_PROPERTIES						1758
#define IDS_FILTER_PROPERTIES					1759
#define IDS_FILE_PROPERTIES						1760

// TODO: joshep 7/28/00
// REMOVE THIS ID FOR BETA 2 ///////////////
#define IDS_SOURCE_FILE_BASENAME 		1801
////////////////////////////////////////////

// these property IDs are FIXED as they are in buildpackage.rgs
#define IDS_DEBUGEXE					10000
#define IDS_USEENV						10001
#define IDS_EXEFilter                   10002
#define IDS_VCFilter                    10003
#define IDS_CrashDumpFilter				10004
#define IDS_VCFILES_FILTER				10005
#define IDS_ADDCPPPROJ					10006
#define IDS_ADDCPPITEM					10007
#define IDS_ADDCPPCLASS					10008
#define IDS_BUILDPAGE					10009
#define IDS_DIRECTORIESPAGE				10010
#define IDS_NATIVEWEBFILES_FILTER		10011
#define IDS_RESOURCEFILES_FILTER		10012
#define IDR_VPROJCOMMANDTABLE           10013
#define IDS_BROWSEFILES_FILTER          10014
// these property IDs are FIXED as they are referenced in devenv.rgs
#define IDS_OLEVIEWER_NAME				10050
#define IDS_SPY_NAME					10051
#define IDS_ATLTRACE_NAME				10052


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         5171
#define _APS_NEXT_CONTROL_VALUE         9029
#define _APS_NEXT_SYMED_VALUE           1465
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\resdll\makefile.inc ===
!include $(_NTROOT)\private\vc7addon\vsenv.inc

!include $(VCROOT)\makefile.inc

$(O)\$(RCFILE).res: $(RCFILE).rc $(O)\$(CMDTABLE).cto

$(O)\$(CMDTABLE).cto: $(CMDTABLE).cmd
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\x86tooll.cpp ===
//
// Intelx86 Linker Tool
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "x86tooll.h"	// our local header file

IMPLEMENT_DYNAMIC (CLinkerX86Tool, CLinkerNTTool)

CLinkerX86Tool::CLinkerX86Tool() : CLinkerNTTool()
{
	m_strToolExeName = _T("link.exe");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\stdconversion\x86toolc.cpp ===
//
// Intelx86 Compiler Tool
//
// [v-danwh],[matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "x86toolc.h"	// our local header file

IMPLEMENT_DYNAMIC ( CCCompilerX86Tool, CCCompilerNTTool )

CCCompilerX86Tool::CCCompilerX86Tool() : CCCompilerNTTool()
{
	m_strToolExeName = _TEXT("cl.exe");
}

//////////////////////////////////////////////////////////////////////////////
// Default tool options for the Intelx86 compiler tool
BOOL CCCompilerX86Tool::GetDefaultToolOptions(DWORD bsc_id, DWORD attrib, DWORD mode, CString & strOption)
{
	// are we a mode we can handle?
	VSASSERT(mode == MOB_Debug || mode == MOB_Release, "Unrecognized mode!");
	
	CString strPart; 

	// Our common tool options
	BOOL bOK = strOption.LoadString(IDS_WIN32_CPLR_COMMON);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");

	// Our mode tool options
 	bOK = strPart.LoadString(mode == MOB_Debug ? IDS_WIN32_CPLR_DBG : IDS_WIN32_CPLR_REL);
	VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
	strOption += _T(' '); strOption += strPart;

	// Return appropriate tool options according to the attributes
	// of the target type
	UINT nIDAttrib = (UINT)-1;

	// console? (takes precedence over executable, executable is implicit...)
	if (attrib & SubsystemConsole)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32CON_CPLR_DBG : IDS_WIN32CON_CPLR_REL;
	}
	// executable
	else if (attrib & ImageExe)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32EXE_CPLR_DBG : IDS_WIN32EXE_CPLR_REL;
	}
	// dynamic link library
	else if (attrib & ImageDLL)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32DLL_CPLR_DBG : IDS_WIN32DLL_CPLR_REL;
	}
	// static library
	else if (attrib & ImageStaticLib)
	{
		nIDAttrib = mode == MOB_Debug ? IDS_WIN32LIB_CPLR_DBG : IDS_WIN32LIB_CPLR_REL;
	}	 

	// Our attribute tool options
	if (nIDAttrib != (UINT)-1)
	{
		bOK = strPart.LoadString(nIDAttrib);
		VSASSERT(bOK, "Failed to load a string!  Are the resources initialized properly?");
		strOption += _T(' '); strOption += strPart;
	}

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
// Ensure that this project compiler Intelx86 options are ok to use/not use MFC
BOOL CCCompilerX86Tool::PerformSettingsWizard(CProjItem * pProjItem, BOOL fDebug, int iUseMFC)
{
	// Set the thread type usage
	pProjItem->SetIntProp(MapLogical(P_Thread), 1);

	return CCCompilerNTTool::PerformSettingsWizard(pProjItem, fDebug, iUseMFC);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autobase.h ===
#pragma once

template <class TClass, class PrimaryIface, const LPOLESTR TszGuid> 
class CAutoBase
{
public:
	HRESULT DoGetProperties(TClass* pThis, PrimaryIface* pObject, Properties** ppObject)
	{
		CHECK_POINTER_VALID(ppObject);

		// Obtain the Extensibility Service
		CComPtr<IVsExtensibility> spExtService; 
		HRESULT hr = ExternalQueryService(SID_SVsExtensibility, IID_IVsExtensibility, (void **)&spExtService);
		RETURN_ON_FAIL(hr);
		CComQIPtr<IDispatch> spDispatch = pObject;
		RETURN_INVALID_ON_NULL(spDispatch);
		// get the property object
		return spExtService->get_Properties(pThis, spDispatch, (Properties **)ppObject);
	}
	HRESULT DoGetObject(PrimaryIface* pObject, IDispatch** ppProjectModel, long idErr)
	{
		CHECK_ZOMBIE(pObject, idErr);

		CComQIPtr<IDispatch> spDispObject = pObject;
		return spDispObject.CopyTo(ppProjectModel);
	}
	HRESULT DoGetExtender(TClass* pThis, BSTR bstrExtenderName, IDispatch** ppExtender)
	{
		CHECK_POINTER_VALID(ppExtender);
		*ppExtender = NULL;

		CComBSTR bstrCATID(TszGuid);
		RETURN_ON_NULL2(bstrCATID, S_OK);

		// validate params
		RETURN_ON_NULL2(bstrExtenderName, S_FALSE);

		// get internal ExtensionManager svc
		CComPtr<ObjectExtenders> spExtMgr;
		HRESULT hr = ExternalQueryService(SID_SExtensionManager, IID_ObjectExtenders, (void **)&spExtMgr);
		RETURN_ON_FAIL_OR_NULL(hr, spExtMgr);

		// call GetExtension on svc
		return spExtMgr->GetExtender(bstrCATID, bstrExtenderName, (LPDISPATCH)pThis, ppExtender);
	}
	HRESULT DoGetExtenderNames(TClass* pThis, VARIANT *pvarExtenderNames)
	{
		// validate params
		CHECK_POINTER_VALID(pvarExtenderNames);
		VariantInit(pvarExtenderNames);

		CComBSTR bstrCATID(TszGuid);
		if (!bstrCATID)
			return S_OK;

		// get internal ExtensionManager svc
		CComPtr<ObjectExtenders> spExtMgr;
		HRESULT hr = ExternalQueryService(SID_SExtensionManager, IID_ObjectExtenders, (void **)&spExtMgr);
		RETURN_ON_FAIL_OR_NULL(hr, spExtMgr);

		// call GetExtensionNames on svc
		return spExtMgr->GetExtenderNames(bstrCATID, (LPDISPATCH) pThis, pvarExtenderNames);
	}
	HRESULT DoGetExtenderCATID(BSTR *pbstrRetval)
	{
		// validate params
		CHECK_POINTER_VALID(pbstrRetval);
		*pbstrRetval = NULL;

		// Convert string version of GUID into BSTR string
		*pbstrRetval = ::SysAllocString((OLECHAR *) TszGuid);
		RETURN_ON_NULL2(*pbstrRetval, S_FALSE);
		return S_OK;
	}
};

template <class TAuto>
class CAutoEnumerator :
	public IEnumVARIANT,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CAutoEnumerator)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

	static HRESULT CreateInstance(CAutoEnumerator **ppCollection, TAuto* pOwner, IDispatch* pAutoProject, IDispatch* pAutoParent,
		IDispatch *pDispCollection)
	{
		CHECK_POINTER_NULL(ppCollection);
		CAutoEnumerator *pVar;
		CComObject<CAutoEnumerator> *pObj;
		HRESULT hr = CComObject<CAutoEnumerator>::CreateInstance(&pObj);
		if (SUCCEEDED(hr))
		{
			pVar = pObj;
			pVar->AddRef();
			*ppCollection = pVar;
			hr = pVar->Initialize(pOwner, pAutoProject, pAutoParent, pDispCollection);
		}
		return hr;
	}
	CAutoEnumerator() 
	{
		m_pAuto = NULL;
	}
	~CAutoEnumerator()
	{
	}

protected:
	HRESULT Initialize(TAuto* pOwner, IDispatch* pAutoParent, IDispatch* pAutoProject, IDispatch* pDispCollection)
	{
		CHECK_READ_POINTER_NULL(pOwner);
		CHECK_READ_POINTER_NULL(pDispCollection);

		m_spOwner = pOwner; // want a ref count...
		m_pAuto = pOwner;
		m_spAutoParent = pAutoParent;
		m_spAutoProject = pAutoProject;

		CComQIPtr<IVCCollection> spCollection = pDispCollection;
		VSASSERT(spCollection != NULL, "Bad initialization of CAutoEnumerator");
		RETURN_ON_NULL2(spCollection, E_UNEXPECTED);
		IUnknown* pUnk = NULL;
		HRESULT hr = spCollection->_NewEnum(&pUnk);
		VSASSERT(SUCCEEDED(hr) && pUnk != NULL, "Collection can't be enumerated!");
		RETURN_ON_FAIL(hr);
		if (pUnk == NULL)
			return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
		m_spEnumerator = pUnk;
		pUnk->Release();
		return S_OK;
	}

protected:
	CComQIPtr<IEnumVARIANT> m_spEnumerator;
	CComQIPtr<IDispatch> m_spOwner;		// this is a CAutoItems or CAutoProjects collection
	CComPtr<IDispatch> m_spAutoParent;
	CComPtr<IDispatch> m_spAutoProject;
	TAuto* m_pAuto;

// IEnumVARIANT
public:
	STDMETHOD(Next)(ULONG celt, VARIANT *rgVar, ULONG *pCeltFetched)
	{
		CHECK_ZOMBIE(m_spEnumerator, IDS_ERR_ENUMERATOR_ZOMBIE);

		CHECK_POINTER_VALID(rgVar);
		::VariantClear(rgVar);

		ULONG celtFetchedLocal;
		HRESULT hr = m_spEnumerator->Next(celt, rgVar, &celtFetchedLocal);
		if (pCeltFetched)
			*pCeltFetched = celtFetchedLocal;
		RETURN_ON_FAIL(hr);

		for (ULONG idx = 0; idx < celtFetchedLocal; idx++)
		{
			IDispatch* pDispItem = rgVar[idx].pdispVal;
			if (pDispItem != NULL)
			{
				CComPtr<IDispatch> spDispObject;
				hr = TAuto::GetItem(&spDispObject, m_spOwner, m_spAutoParent, m_spAutoProject, pDispItem);
				rgVar[idx].pdispVal = spDispObject.Detach();
				// have to set vt to dispatch (enumerator->Next() returns us
				// unknowns and automation needs disps)
				rgVar[idx].vt = VT_DISPATCH;
			}
		}
		
		return hr;
	}
	STDMETHOD(Skip)(ULONG celt)
	{
		CHECK_ZOMBIE(m_spEnumerator, IDS_ERR_ENUMERATOR_ZOMBIE);
		return m_spEnumerator->Skip(celt);
	}
	STDMETHOD(Reset)(void)
	{
		CHECK_ZOMBIE(m_spEnumerator, IDS_ERR_ENUMERATOR_ZOMBIE);
		return m_spEnumerator->Reset();
	}
	STDMETHOD(Clone)(IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum)
	{
		CHECK_ZOMBIE(m_pAuto, IDS_ERR_ENUMERATOR_ZOMBIE);
		return m_pAuto->_NewEnum((IUnknown **)ppEnum);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autofilter.cpp ===
// AutoFilter.cpp
// implementation for CAutoFilter

#include "stdafx.h"

#include "AutoFilter.h"
#include "AutoFile.h"
#include "AutoProject.h"    
#include "bldpkg.h"
#include "VCArchy.h"
#include "VCFGrp.h"

CAutoFilter::CAutoFilter()
{
}

CAutoFilter::~CAutoFilter()
{
}

//-----------------------------------------------------------------------------
// create an instance of a Filter node with reference count 1
//-----------------------------------------------------------------------------
HRESULT CAutoFilter::CreateInstance(CAutoFilter** ppAutoFilter, IDispatch* pAutoItems, IDispatch* pAutoProject, 
	IDispatch* pItem)
{
	CComQIPtr<VCFilter> spFilter = pItem;
	RETURN_ON_NULL(spFilter);		// not for us

	CComObject<CAutoFilter> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CAutoFilter>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjObj, E_OUTOFMEMORY);
	pPrjObj->AddRef();
	pPrjObj->Initialize(pAutoItems, pAutoProject, pItem);
	*ppAutoFilter = pPrjObj;
	return hr;
}

void CAutoFilter::Initialize(IDispatch* pAutoItems, IDispatch* pAutoProject, IDispatch* pItem)
{
	m_spAutoItems = pAutoItems;
	VSASSERT(m_spAutoItems != NULL, "CAutoFilter initialized with NULL filter list!");
	m_spAutoProject = pAutoProject;
	VSASSERT(m_spAutoProject != NULL, "CAutoFilter initialized with NULL project!");
	m_spFilter = pItem;
	VSASSERT(m_spFilter != NULL, "CAutoFilter initialized without a Filter!");
}

CVCFileGroup* CAutoFilter::GetFileGroup()
{
	CComQIPtr<IVCExternalCookie> spExtCookie = m_spFilter;
	RETURN_ON_NULL2(spExtCookie, NULL);

	void* pCookie;
	spExtCookie->get_ExternalCookie(&pCookie);
	RETURN_ON_NULL2(pCookie, NULL);
	return (CVCFileGroup*)pCookie;
}

CVCProjectNode* CAutoFilter::GetProjectNode(CVCFileGroup* pFileGroupIn /* = NULL */)
{
	CVCFileGroup* pFileGroup = NULL;
	if (pFileGroupIn)
		pFileGroup = pFileGroupIn;
	else
		pFileGroup = GetFileGroup();
	RETURN_ON_NULL2(pFileGroup, NULL);

	return pFileGroup->GetVCProjectNode();
}

/* _ProjectItem methods */
STDMETHODIMP CAutoFilter::get_IsDirty(VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_POINTER_VALID(lpfReturn);
	*lpfReturn = VARIANT_FALSE;	// folders are never dirty
	return S_OK;
}

STDMETHODIMP CAutoFilter::put_IsDirty(VARIANT_BOOL DirtyFlag)
{
	return E_FAIL;	// CAutoFilter::put_IsDirty, folders are never dirty
}

STDMETHODIMP CAutoFilter::get_FileNames(short Index, BSTR FAR* lpbstrReturn)
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE)
	return m_spFilter->get_Name(lpbstrReturn);
}

STDMETHODIMP CAutoFilter::SaveAs(BSTR NewFilterName, VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE);
	CHECK_POINTER_VALID(lpfReturn);
	return E_FAIL;	// CAutoFilter::SaveAs, folders can never be saved
}

STDMETHODIMP CAutoFilter::get_FileCount(short FAR* lpsReturn)
{
	CHECK_POINTER_VALID(lpsReturn);
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE);

	CComPtr<IDispatch> spDispFiles;
	m_spFilter->get_Files(&spDispFiles);

	CComQIPtr<IVCCollection> spFiles = spDispFiles;
	RETURN_ON_NULL(spFiles);

	long cFiles = 0;
	spFiles->get_Count(&cFiles);

	*lpsReturn = (short)cFiles;
	return S_OK;
}

STDMETHODIMP CAutoFilter::get_Name(BSTR FAR* pbstrReturn)
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE)
	return m_spFilter->get_Name(pbstrReturn);
}

STDMETHODIMP CAutoFilter::put_Name(BSTR bstrName)
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE)
	return m_spFilter->put_Name(bstrName);
}

STDMETHODIMP CAutoFilter::get_Collection(ProjectItems FAR* FAR* lppcReturn)
{
	CHECK_ZOMBIE(m_spAutoItems, IDS_ERR_FILTER_ZOMBIE)
	CHECK_POINTER_VALID(lppcReturn)

	CComQIPtr<ProjectItems> spProjItems = m_spAutoItems;
	*lppcReturn = spProjItems.Detach();
	return S_OK;
}

STDMETHODIMP CAutoFilter::get_Properties(Properties FAR* FAR* ppObject)
{
	return DoGetProperties(this, m_spFilter, ppObject);
}

STDMETHODIMP CAutoFilter::get_DTE(DTE FAR* FAR* lppaReturn)
{
	return GetBuildPkg()->GetDTE(lppaReturn);
}

STDMETHODIMP CAutoFilter::get_Kind(BSTR FAR* lpbstrFilterName)
{
	CHECK_POINTER_VALID(lpbstrFilterName)

	CComBSTR bstrKind = vsProjectItemKindVirtualFolder;
	*lpbstrFilterName = bstrKind.Detach();
	return S_OK;
}

STDMETHODIMP CAutoFilter::get_ProjectItems(ProjectItems FAR* FAR* lppcReturn)
{
	CHECK_POINTER_VALID(lppcReturn);
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE);

	CComPtr<IDispatch> spDispItems;
	HRESULT hr = m_spFilter->get_Items(&spDispItems);
	RETURN_ON_FAIL_OR_NULL2(hr, spDispItems, E_UNEXPECTED);

	CAutoItems *pAutoItems = NULL;
	hr = CAutoItems::CreateInstance(&pAutoItems, this, m_spAutoProject, spDispItems);
	if (SUCCEEDED(hr))
		*lppcReturn = (ProjectItems *)pAutoItems;

	return hr;
}

STDMETHODIMP CAutoFilter::get_IsOpen(BSTR LogView, VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE)
	CHECK_POINTER_VALID(lpfReturn)

	*lpfReturn = VARIANT_FALSE;
	return S_OK;	// filters are never open
}

STDMETHODIMP CAutoFilter::Remove()
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE);
	CVCFileGroup* pFileGroup = GetFileGroup();
	RETURN_ON_NULL2(pFileGroup, E_UNEXPECTED);

	return pFileGroup->OnDelete(NULL, DELITEMOP_RemoveFromProject);
}

STDMETHODIMP CAutoFilter::Delete()
{
	return S_FALSE;	// CAutoFilter::Delete, can't delete from UI, so shouldn't be able to delete from automation, either
}

STDMETHODIMP CAutoFilter::ExpandView()
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE);
	CVCFileGroup* pFileGroup = GetFileGroup();
	RETURN_ON_NULL2(pFileGroup, E_UNEXPECTED);

	CVCProjectNode* pProjectNode = GetProjectNode(pFileGroup);
	RETURN_ON_NULL2(pProjectNode, E_UNEXPECTED);

	CComPtr<IVsUIShell> spUIShell;
	HRESULT hr = GetBuildPkg()->GetVsUIShell(&spUIShell, TRUE /* in main thread */);
	VSASSERT(SUCCEEDED(hr), "Failed to get IVsUIShell interface");
	RETURN_ON_FAIL_OR_NULL(hr, spUIShell);

	CComPtr<IVsWindowFrame> spFrame;
	hr = spUIShell->FindToolWindow(0, GUID_SolutionExplorer, &spFrame);
	RETURN_ON_FAIL_OR_NULL2(hr, spFrame, E_UNEXPECTED);

	CComVariant srpvt;
	hr = spFrame->GetProperty(VSFPROPID_DocView, &srpvt);
	RETURN_ON_FAIL(hr);

	ASSERT(VT_UNKNOWN == V_VT(&srpvt));
	if (VT_UNKNOWN != V_VT(&srpvt))
		return E_FAIL;
	ASSERT(NULL != V_UNKNOWN(&srpvt));

	CComPtr<IVsWindowPane> spPane;
	hr = V_UNKNOWN(&srpvt)->QueryInterface(IID_IVsWindowPane, (void **)&spPane);
	RETURN_ON_FAIL(hr);
	ASSERT(spPane != NULL);

	CComQIPtr<IVsUIHierarchyWindow> spHierarchyWindow = spPane;
	ASSERT(spHierarchyWindow != NULL);
	RETURN_ON_NULL(spHierarchyWindow);

	return spHierarchyWindow->ExpandItem(pProjectNode->GetArchy() ? pProjectNode->GetArchy()->GetIVsUIHierarchy() : NULL, 
		pFileGroup->GetVsItemID(), EXPF_ExpandFolder);
}

STDMETHODIMP CAutoFilter::Open(BSTR LogView, Window FAR* FAR* lppfReturn)
{
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE)
	CHECK_POINTER_VALID(lppfReturn)
	
	*lppfReturn = NULL;
	return S_FALSE;		// filters cannot be opened
}


STDMETHODIMP CAutoFilter::get_Object(IDispatch **ppProjectItemModel)
{
	return DoGetObject(m_spFilter, ppProjectItemModel, IDS_ERR_FILTER_ZOMBIE);
}

STDMETHODIMP CAutoFilter::get_Extender(BSTR bstrExtenderName, IDispatch **ppExtender)
{
	return DoGetExtender(this, bstrExtenderName, ppExtender);
}

STDMETHODIMP CAutoFilter::get_ExtenderNames(VARIANT *pvarExtenderNames)
{
	return DoGetExtenderNames(this, pvarExtenderNames);
}

STDMETHODIMP CAutoFilter::get_ExtenderCATID(BSTR *pbstrRetval)
{
	return DoGetExtenderCATID(pbstrRetval);
}

STDMETHODIMP CAutoFilter::get_Saved(VARIANT_BOOL *lpfReturn)
{
	return get_IsDirty(lpfReturn);
}

STDMETHODIMP CAutoFilter::put_Saved(VARIANT_BOOL Dirty)
{
	return put_IsDirty(Dirty);
}

STDMETHODIMP CAutoFilter::get_SourceControl(SourceControl ** /*ppSourceControl*/)
{
	return E_NOTIMPL;	// CAutoFilter::get_SourceControl
}

STDMETHODIMP CAutoFilter::get_ConfigurationManager(ConfigurationManager ** ppConfigurationManager)
{
	CHECK_POINTER_VALID(ppConfigurationManager);
	*ppConfigurationManager = NULL;
	return S_FALSE;	// filters don't have configurations
}

STDMETHODIMP CAutoFilter::Save(BSTR /*FileName*/)
{
	return E_NOTIMPL;		// CAutoFilter::Save
}

STDMETHODIMP CAutoFilter::get_Document(Document ** ppDocument)
{
	CHECK_POINTER_VALID(ppDocument);
	*ppDocument = NULL;
	return S_FALSE;		// filters don't have documents
}

STDMETHODIMP CAutoFilter::get_SubProject(Project ** ppProject)
{
	CHECK_POINTER_VALID(ppProject);
	*ppProject = NULL;
	return S_OK;
}

STDMETHODIMP CAutoFilter::get_ContainingProject(Project ** ppProject)
{
	CComQIPtr<Project> pProject = m_spAutoProject;
	VSASSERT( pProject != NULL, "QI for Project interface failed" );
	return pProject.CopyTo( ppProject );
}

STDMETHODIMP CAutoFilter::AddFolder(BSTR Name, BSTR Kind, ProjectItem **pProjectItem)
{
	CHECK_POINTER_VALID(pProjectItem);
	CHECK_ZOMBIE(m_spFilter, IDS_ERR_FILTER_ZOMBIE);

	CComPtr<IDispatch> spNewFilter;
	HRESULT hr = m_spFilter->AddFilter(Name, &spNewFilter);
	RETURN_ON_FAIL_OR_NULL(hr, spNewFilter);

	CAutoFilter* pObject = NULL;
	hr = CAutoFilter::CreateInstance(&pObject, m_spFilter, m_spAutoProject, spNewFilter);
	RETURN_ON_FAIL(hr);

	*pProjectItem = (ProjectItem *)pObject;
	return S_OK;
}

STDMETHODIMP CAutoFilter::get_CodeModel(CodeModel ** ppCodeModel)
{
	CHECK_POINTER_VALID(ppCodeModel);
	*ppCodeModel = NULL;
	return S_FALSE;	// no code model for a filter
}

STDMETHODIMP CAutoFilter::get_FileCodeModel(FileCodeModel ** ppFileCodeModel)
{
	CHECK_POINTER_VALID(ppFileCodeModel);
	*ppFileCodeModel = NULL;
	return S_FALSE;	// no code model for a filter
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autofile.h ===
// AutoFile.h
// declares what we implement for the DTE ProjectItem

#include "PrjNode.h"
#include "AutoBase.h"
#include "VCFile.h"

class CAutoProject; // FORWARD...

// classes in this header
class CAutoFile;
class CAutoItems;

// string version of the guid
_declspec(selectany) LPOLESTR szguidCATIDAutoFile = L"{610d461f-d0d5-11d2-8599-006097c68e81}";

class CAutoFile : 
	public CAutoBase<CAutoFile, VCFile, szguidCATIDAutoFile>,
	public CComDualImpl<_ProjectItem, &IID__ProjectItem, &LIBID_DTE, 7, 0>, 
	public ISupportVSProperties,
	public CComObjectRoot
{
public:
	CAutoFile();
	~CAutoFile();
	void Initialize(IDispatch* ppAutoFiles, IDispatch* pAutoProject, IDispatch* pItem);
	static HRESULT CreateInstance(CAutoFile** ppAutoFile, IDispatch* pAutoItems, IDispatch* pAutoProject,
		IDispatch* pItem);
	VCFile *GetFile() { return(m_spFile); }

BEGIN_COM_MAP(CAutoFile)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(_ProjectItem)
	COM_INTERFACE_ENTRY(ISupportVSProperties)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CAutoItems) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

// ProjectItem
public:
    /* _ProjectItem methods */
    STDMETHOD(get_IsDirty)(VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(put_IsDirty)(VARIANT_BOOL DirtyFlag);
    STDMETHOD(get_FileNames)(short Index, BSTR FAR* lpbstrReturn);
    STDMETHOD(SaveAs)(BSTR NewFileName, VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(get_FileCount)(short FAR* lpsReturn);
    STDMETHOD(get_Reserved1)(long FAR* lpulReturn) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved1)(long Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved2)(BSTR FileName) { return E_NOTIMPL; }
    STDMETHOD(Reserved3)() { return E_NOTIMPL; }
    STDMETHOD(get_Name)(BSTR FAR* pbstrReturn);
    STDMETHOD(put_Name)(BSTR bstrName);
    STDMETHOD(get_Reserved14)(IDispatch * FAR* ppDispatch) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved4)(IDispatch * FAR* ppVbaModule) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved5)(long FAR* pkind) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved6)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Collection)(ProjectItems FAR* FAR* lppcReturn);
    STDMETHOD(get_Reserved15)(VARIANT_BOOL FAR* lpfReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Properties)(Properties FAR* FAR* ppObject);
    STDMETHOD(Reserved7)(IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
    STDMETHOD(Reserved8)(BSTR Key, BSTR FAR* lpbstrValue) { return E_NOTIMPL; }
    STDMETHOD(Reserved9)(BSTR Key, BSTR Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved10)() { return E_NOTIMPL; }
    STDMETHOD(get_Reserved11)(long FAR* lpdwContextID) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved11)(long dwContextID) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved12)(BSTR FAR* lpbstrDescription) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved12)(BSTR bstrDescription) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved13)(BSTR FAR* pbstrReturn) { return E_NOTIMPL; }
    STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn);
    STDMETHOD(get_Kind)(BSTR FAR* lpbstrFileName);
    STDMETHOD(get_ProjectItems)(ProjectItems FAR* FAR* lppcReturn);
    STDMETHOD(get_IsOpen)(BSTR LogView, VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(Open)(BSTR LogView, Window FAR* FAR* lppfReturn);
    STDMETHOD(Remove)();
    STDMETHOD(Delete)();
    STDMETHOD(ExpandView)();
    STDMETHOD(get_Object)(IDispatch **ppProjectItemModel);
    STDMETHOD(get_Extender)(BSTR bstrExtenderName, IDispatch **ppExtender);
    STDMETHOD(get_ExtenderNames)(VARIANT *pvarExtenderNames);
    STDMETHOD(get_ExtenderCATID)(BSTR *pbstrRetval);

    STDMETHOD(get_Saved)(VARIANT_BOOL *lpfReturn);
    STDMETHOD(put_Saved)(VARIANT_BOOL Dirty);
    STDMETHOD(get_SourceControl)(SourceControl ** /*ppSourceControl*/);
    STDMETHOD(get_ConfigurationManager)(ConfigurationManager ** /*ppConfigurationManager*/);
    STDMETHOD(get_CodeModel)(CodeModel ** /*ppCodeModel*/);
    STDMETHOD(Save)(BSTR /*FileName*/);
    STDMETHOD(get_Document)(Document ** /*ppDocument*/);
    STDMETHOD(get_SubProject)(Project ** /*ppProject*/);
    STDMETHOD(get_ContainingProject)(Project ** /*ppProject*/);
    STDMETHOD(get_FileCodeModel)(FileCodeModel ** ppFileCodeModel);
    STDMETHOD(AddFolder)(BSTR Name, BSTR Kind, ProjectItem **pProjectItem);

protected:
	CComPtr<IDispatch> m_spAutoItems;
	CComPtr<IDispatch> m_spAutoProject;
	CComQIPtr<VCFile> m_spFile;

	CVCProjectNode* GetProjectNode(CVCFileNode* pFileNode = NULL);
	CVCFileNode* GetFileNode();
	HRESULT IsOpen(BSTR LogView, BOOL bAlwaysProvideLogView, VARIANT_BOOL* lpfReturn, IVsWindowFrame** ppWindowFrame);

// ISupportVSProperties
public:
	STDMETHOD(NotifyPropertiesDelete)()
	{
		return E_NOTIMPL;	// CAutoFile::NotifyPropertiesDelete
	}
};

////////////////////////////////////////////////////////////////////////////////////////////////////
// class CAutoItems

class CAutoItems : 
	public CComDualImpl<_ProjectItems, &IID__ProjectItems, &LIBID_DTE, 7, 0>, 
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CAutoItems();
	~CAutoItems();
	void Initialize(IDispatch* pAutoParent, IDispatch *pAutoProj, IDispatch* pDispItems);
	static HRESULT CreateInstance(CAutoItems **ppEnum, IDispatch* pAutoParent, IDispatch *pAutoProj, 
		IDispatch* pDispItems);

BEGIN_COM_MAP(CAutoItems)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(_ProjectItems)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CAutoItems) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ProjectItems
public:
    /* _ProjectItems methods */
    STDMETHOD(Item)(VARIANT index, ProjectItem FAR* FAR* lppcReturn);
    STDMETHOD(get_Parent)(IDispatch * FAR* lppptReturn);
    STDMETHOD(get_Count)(long FAR* lplReturn);
    STDMETHOD(_NewEnum)(IUnknown * FAR* lppiuReturn);
    STDMETHOD(Reserved1)(IDispatch * VBComponent) { return E_NOTIMPL; }
    STDMETHOD(Reserved2)(long ComponentType, IDispatch * FAR* lppComponent) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved3)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved4)(VARIANT FAR* lpVar) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved4)(VARIANT varInput) { return E_NOTIMPL; }
    STDMETHOD(Reserved5)(BSTR FileName, VARIANT_BOOL RelatedDocuement, IDispatch * FAR* lppComponent) { return E_NOTIMPL; }
    STDMETHOD(Reserved6)(BSTR FileName, IDispatch * FAR* lppComponent) { return E_NOTIMPL; }
    STDMETHOD(Reserved7)(BSTR ProgID, IDispatch * FAR* lppComponent) { return E_NOTIMPL; }
    STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn);
    STDMETHOD(get_Kind)(BSTR FAR* lpbstrFileName);
    STDMETHOD(AddFromFile)(BSTR FileName, ProjectItem FAR* FAR* lppcReturn);
    STDMETHOD(AddFromTemplate)(BSTR FileName, BSTR Name, ProjectItem FAR* FAR* lppcReturn);
    STDMETHOD(AddFromDirectory)(BSTR Directory, ProjectItem FAR* FAR* lppcReturn);
    STDMETHOD(get_ContainingProject)(Project ** /*ppProject*/);
    STDMETHOD(AddFolder)(BSTR Name, BSTR Kind, ProjectItem **pProjectItem);
    STDMETHOD(AddFromFileCopy)(BSTR FilePath, ProjectItem** ppOut);

// helpers
public:
	static HRESULT GetItem(IDispatch** ppProjItem, IDispatch* pOwner, IDispatch* pAutoParent, IDispatch* pAutoProject, IDispatch* pVCItem);

protected:
	HRESULT GetBaseObject(IDispatch** ppObject);
	CVCBaseFolderNode* GetBaseNode();
	HRESULT SetupForAddItemDlg(CVCBaseFolderNode** ppBaseNode, HWND* phwndDlg, ProjectItem** ppOut);
	HRESULT FinishFromAddItemDlg(HRESULT hrReturn, VSADDRESULT addResult, BSTR bstrPath, ProjectItem** ppItem);

protected:
	CComPtr<IDispatch> m_spAutoParent;
	CComPtr<IDispatch> m_spAutoProject;
	CComQIPtr<IVCCollection> m_spItems;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autofile.cpp ===
// AutoFile.cpp
// implementation for CAutoFile

#include "stdafx.h"

#include "AutoFile.h"
#include "AutoFilter.h"
#include "AutoProject.h"    
#include "bldpkg.h"
#include "VCArchy.h"
#include "VCFile.h"
#include "VCCodeModels.h"
#include "VCDesignerObjectInternal.h"
#include "VCCodeModelsInternal.h"

CAutoFile::CAutoFile()
{
}

CAutoFile::~CAutoFile()
{
}

//-----------------------------------------------------------------------------
// create an instance of a file node with reference count 1
//-----------------------------------------------------------------------------
HRESULT CAutoFile::CreateInstance(CAutoFile** ppAutoFile, IDispatch* pAutoItems, IDispatch* pAutoProject, IDispatch* pItem)
{
	CComQIPtr<VCFile> spFile = pItem;
	RETURN_ON_NULL(spFile);		// not for us

	CComObject<CAutoFile> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CAutoFile>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjObj, E_OUTOFMEMORY);
	pPrjObj->AddRef();
	pPrjObj->Initialize(pAutoItems, pAutoProject, pItem);
	*ppAutoFile = pPrjObj;

	return hr;
}

void CAutoFile::Initialize(IDispatch* pAutoItems, IDispatch* pAutoProject, IDispatch* pItem)
{
	m_spAutoItems = pAutoItems;
	VSASSERT(m_spAutoItems != NULL, "CAutoFile initialized with NULL item list!");
	m_spAutoProject = pAutoProject;
	VSASSERT(m_spAutoProject != NULL, "CAutoFile initialized with NULL project!");
	m_spFile = pItem;
	VSASSERT(m_spFile != NULL, "CAutoFile initialized without a file!");
}

CVCFileNode* CAutoFile::GetFileNode()
{
	CComQIPtr<IVCExternalCookie> spExtCookie = m_spFile;
	RETURN_ON_NULL2(spExtCookie, NULL);

	void* pCookie;
	spExtCookie->get_ExternalCookie(&pCookie);
	RETURN_ON_NULL2(pCookie, NULL);

	return (CVCFileNode*)pCookie;
}

CVCProjectNode* CAutoFile::GetProjectNode(CVCFileNode* pFileNodeIn /* = NULL */)
{
	CVCFileNode* pFileNode;
	if (pFileNodeIn)
		pFileNode = pFileNodeIn;
	else
	{
		pFileNode = GetFileNode();
		RETURN_ON_NULL2(pFileNode, NULL);
	}

	return pFileNode->GetVCProjectNode();
}

/* _ProjectItem methods */
STDMETHODIMP CAutoFile::get_IsDirty(VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_POINTER_VALID(lpfReturn);
	*lpfReturn = FALSE;

	VARIANT_BOOL bReturn2 = VARIANT_FALSE;
	CComPtr<IVsWindowFrame> spWindowFrame;
	HRESULT hr = IsOpen(NULL, FALSE, &bReturn2, &spWindowFrame);
	RETURN_ON_FAIL(hr);
	if (bReturn2 == VARIANT_FALSE || spWindowFrame == NULL)	// not open, so obviously not dirty
		return S_OK;

    CComVariant var;
    hr = spWindowFrame->GetProperty(VSFPROPID_DocData, &var);
    if(hr == S_OK)
    {
        ASSERT(V_VT(&var) == VT_UNKNOWN && V_UNKNOWN(&var) != NULL);
        CComPtr<IVsPersistDocData> spDocData;
        (V_UNKNOWN(&var))->QueryInterface(IID_IVsPersistDocData, (void**)&spDocData);
        ASSERT(spDocData);
        BOOL bIsDirty = FALSE;
        hr = spDocData->IsDocDataDirty(&bIsDirty);
        if(hr == S_OK && bIsDirty)
			*lpfReturn = TRUE;
    }

    return hr;
}

STDMETHODIMP CAutoFile::put_IsDirty(VARIANT_BOOL DirtyFlag)
{
	return E_NOTIMPL;	// CAutoFile::put_IsDirty
}

STDMETHODIMP CAutoFile::get_FileNames(short Index, BSTR FAR* lpbstrReturn)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE)
	return m_spFile->get_FullPath(lpbstrReturn);
}

STDMETHODIMP CAutoFile::SaveAs(BSTR NewFileName, VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE)
	CHECK_POINTER_VALID(lpfReturn)
	
	return E_NOTIMPL;	// CAutoFile::SaveAs
}

STDMETHODIMP CAutoFile::Save(BSTR /*FileName*/)
{
	return E_NOTIMPL;		// CAutoFile::Save
}

STDMETHODIMP CAutoFile::get_FileCount(short FAR* lpsReturn)
{
	CHECK_POINTER_VALID(lpsReturn)
	*lpsReturn = 1; // only deal with one file at a time right now.
	return S_OK;
}

STDMETHODIMP CAutoFile::get_Name(BSTR FAR* pbstrReturn)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE)
	return m_spFile->get_Name(pbstrReturn);
}

STDMETHODIMP CAutoFile::put_Name(BSTR bstrName)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE)
	return m_spFile->put_RelativePath(bstrName);
}

STDMETHODIMP CAutoFile::get_Collection(ProjectItems FAR* FAR* lppcReturn)
{
	CHECK_ZOMBIE(m_spAutoItems, IDS_ERR_FILE_ZOMBIE)
	CHECK_POINTER_VALID(lppcReturn)

	CComQIPtr<ProjectItems> spProjItems = m_spAutoItems;
	*lppcReturn = spProjItems.Detach();
	return S_OK;
}

STDMETHODIMP CAutoFile::get_Properties(Properties FAR* FAR* ppObject)
{
	return DoGetProperties(this, m_spFile, ppObject);
}

STDMETHODIMP CAutoFile::get_DTE(DTE FAR* FAR* lppaReturn)
{
	return GetBuildPkg()->GetDTE(lppaReturn);
}

STDMETHODIMP CAutoFile::get_Kind(BSTR FAR* lpbstrFileName)
{
	CHECK_POINTER_VALID(lpbstrFileName)
	CComBSTR bstrKind = vsProjectItemKindPhysicalFile;
	*lpbstrFileName = bstrKind.Detach();
	return S_OK;
}

STDMETHODIMP CAutoFile::get_ProjectItems(ProjectItems FAR* FAR* lppcReturn)
{
	CHECK_POINTER_VALID(lppcReturn);
	*lppcReturn = NULL;
	return S_OK;
}

HRESULT CAutoFile::IsOpen(BSTR LogView, BOOL bAlwaysProvideLogView, VARIANT_BOOL* lpfReturn, IVsWindowFrame** ppWindowFrame)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE)
	CHECK_POINTER_VALID(lpfReturn)
	*ppWindowFrame = NULL;

	*lpfReturn = VARIANT_FALSE;

	CVCProjectNode* pProjectNode = GetProjectNode();
	CHECK_ZOMBIE(pProjectNode, IDS_ERR_PROJ_ZOMBIE);

	CVCArchy *pArchy = pProjectNode->GetArchy();
	VSASSERT(pArchy, "No hierarchy found for project!");
	CHECK_ZOMBIE(pArchy, IDS_ERR_FILE_ZOMBIE);

	CComBSTR bstrName;
	m_spFile->get_Name(&bstrName);

	IID guidLogicalView = GUID_NULL;	
	HRESULT hr = (LogView == NULL && !bAlwaysProvideLogView) ? S_OK : IIDFromString(LogView, &guidLogicalView);
	VSASSERT(SUCCEEDED(hr), "Failed to get logical view GUID!");
	if (FAILED(hr))
		guidLogicalView = GUID_NULL;

	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;  
	hr = ExternalQueryService(SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, 
		(void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Failed to get IVsUIShellOpenDocument from the shell!  (Shell not loaded?  Are we trying to get this service from a secondary thread?)");
	RETURN_ON_FAIL_OR_NULL(hr, pVsUIShellOpenDoc);
  			
	CComPtr<IVsUIHierarchy> pHier;
	BOOL fIsOpen;
	VSITEMID vsid = pArchy->ItemIDFromName(NULL, bstrName);
	VSITEMID  vsidDummy;
	CComPtr<IVsWindowFrame> pFrame;
	hr = pVsUIShellOpenDoc->IsDocumentOpen(pArchy->GetIVsUIHierarchy(), vsid, bstrName, guidLogicalView, IDO_ActivateIfOpen,
		&pHier, &vsidDummy, &pFrame, &fIsOpen);
	VSASSERT(SUCCEEDED(hr), "Failed to determine if a document is open!  (Are we trying to get this info from a secondary thread?  Did the required parameters change on us?");
	if (SUCCEEDED(hr))
		*lpfReturn = fIsOpen ? VARIANT_TRUE : VARIANT_FALSE;
	if (ppWindowFrame && pFrame)
		*ppWindowFrame = pFrame.Detach();

	return hr;
}

STDMETHODIMP CAutoFile::get_IsOpen(BSTR LogView, VARIANT_BOOL FAR* lpfReturn)
{
	return IsOpen(LogView, TRUE, lpfReturn, NULL);
}

STDMETHODIMP CAutoFile::Remove()
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE);
	CVCFileNode* pFileNode = GetFileNode();
	RETURN_ON_NULL2(pFileNode, E_UNEXPECTED);

	return pFileNode->OnDelete(NULL, DELITEMOP_RemoveFromProject);
}

STDMETHODIMP CAutoFile::Delete()
{
	return E_NOTIMPL;	// CAutoFile::Delete, we don't allow Delete from UI, so shouldn't allow it from automation, either
}

STDMETHODIMP CAutoFile::ExpandView()
{
	return E_NOTIMPL;	// CAutoFile::ExpandView, files can't be expanded...
}

STDMETHODIMP CAutoFile::Open(BSTR LogView, Window FAR* FAR* lppfReturn)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE)
	CHECK_POINTER_VALID(lppfReturn)
	*lppfReturn = NULL;

	CVCProjectNode* pProjectNode = GetProjectNode();
	VSASSERT(pProjectNode != NULL, "No project node for the file!  Probably bad initialization");
	CHECK_ZOMBIE(pProjectNode, IDS_ERR_PROJ_ZOMBIE);

	CVCArchy *pArchy = pProjectNode->GetArchy();
	VSASSERT(pArchy, "No hierarchy for project node!");
	CHECK_ZOMBIE(pArchy, IDS_ERR_PROJ_ZOMBIE);

	CComBSTR bstrName;
	m_spFile->get_FullPath(&bstrName);
	
	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;  
	HRESULT hr = ExternalQueryService(SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, 
		(void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Failed to get SID_SVsUIShellOpenDocument service!  (Are we in a secondary thread?)");
	RETURN_ON_FAIL_OR_NULL(hr, pVsUIShellOpenDoc);
  			
	IID guidLogicalView;
	hr = IIDFromString(LogView, &guidLogicalView);
	RETURN_ON_FAIL(hr);

	CComPtr<IVsUIHierarchy> pHier;
	BOOL fIsOpen = FALSE;
	VSITEMID  vsidDummy;
	CComPtr<IVsWindowFrame> pFrame;

	hr = pVsUIShellOpenDoc->IsDocumentOpen(pArchy->GetIVsUIHierarchy(), NULL /*vsid, */, bstrName, guidLogicalView,
		IDO_ActivateIfOpen, &pHier, &vsidDummy, &pFrame, &fIsOpen);
	VSASSERT(SUCCEEDED(hr), "Failed to determine if document is open!  (Are we in a secondary thread?  Did parameters change?)");
	RETURN_ON_FAIL(hr);

	if (!fIsOpen)
	{
		// HACK: If not open with the GUID type passed in, try GUID_NULL first.
		// if it is still isn't opened then open it.
		hr = pVsUIShellOpenDoc->IsDocumentOpen(pArchy->GetIVsUIHierarchy(), NULL /* vsid */, bstrName, GUID_NULL, 
			IDO_ActivateIfOpen, &pHier, &vsidDummy, &pFrame, &fIsOpen);
		VSASSERT(SUCCEEDED(hr), "Failed to determine if document is open!  (Are we in a secondary thread?  Did parameters change?)");
	}

	if (!fIsOpen)
	{
		VSITEMID vsid = pArchy->ItemIDFromName(NULL, bstrName);
		hr = pVsUIShellOpenDoc->OpenStandardEditor(OSE_ChooseBestStdEditor, bstrName, guidLogicalView,
			L"%3"/* base filename */, pArchy->GetIVsUIHierarchy(), vsid, DOCDATAEXISTING_UNKNOWN, NULL, &pFrame);
		VSASSERT(SUCCEEDED(hr), "Failed open standard editor for file!");
	}

	if (SUCCEEDED(hr) && pFrame)
	{
		VARIANT varPunk;
		VariantInit(&varPunk);
		V_VT(&varPunk) = VT_UNKNOWN;
		hr = pFrame->GetProperty(VSFPROPID_ExtWindowObject, &varPunk);
		VSASSERT(SUCCEEDED(hr), "Failed to get window object property!  (Are we in a secondary thread?)");
		if (SUCCEEDED(hr))
		{
			hr = varPunk.punkVal->QueryInterface(IID_Window, (void **)lppfReturn); 
			VSASSERT(SUCCEEDED(hr), "Failed to get Window interface!  (Are we in a secondary thread?)");
			varPunk.punkVal->Release();
		}
	}

    return hr;
}


STDMETHODIMP CAutoFile::get_Object(IDispatch **ppProjectItemModel)
{
	return DoGetObject(m_spFile, ppProjectItemModel, IDS_ERR_FILE_ZOMBIE);
}

STDMETHODIMP CAutoFile::get_Extender(BSTR bstrExtenderName, IDispatch **ppExtender)
{
	return DoGetExtender(this, bstrExtenderName, ppExtender);
}

STDMETHODIMP CAutoFile::get_ExtenderNames(VARIANT *pvarExtenderNames)
{
	return DoGetExtenderNames(this, pvarExtenderNames);
}

STDMETHODIMP CAutoFile::get_ExtenderCATID(BSTR *pbstrRetval)
{
	return DoGetExtenderCATID(pbstrRetval);
}

STDMETHODIMP CAutoFile::get_Saved(VARIANT_BOOL *lpfReturn)
{
	return get_IsDirty(lpfReturn);
}

STDMETHODIMP CAutoFile::put_Saved(VARIANT_BOOL Dirty)
{
	return put_IsDirty(Dirty);
}

STDMETHODIMP CAutoFile::get_SourceControl(SourceControl ** /*ppSourceControl*/)
{
	return E_NOTIMPL;	// CAutoFile::get_SourceControl
}

STDMETHODIMP CAutoFile::get_CodeModel(CodeModel** ppCodeModel)
{
	CHECK_ZOMBIE(m_spAutoProject, IDS_ERR_PROJ_ZOMBIE);
	CComQIPtr<_Project> spProject = m_spAutoProject;
	RETURN_ON_NULL(spProject);

	return spProject->get_CodeModel(ppCodeModel);
}

STDMETHODIMP CAutoFile::get_Document(Document ** ppDocument)
{
	CHECK_ZOMBIE(m_spFile, IDS_ERR_FILE_ZOMBIE);
	CHECK_POINTER_VALID(ppDocument);
	*ppDocument = NULL;

	CVCFileNode* pFileNode = GetFileNode();
	RETURN_ON_NULL2(pFileNode, E_UNEXPECTED);

	VARIANT_BOOL bIsOpen = VARIANT_FALSE;
	CComPtr<IVsWindowFrame> spFrame;
	HRESULT hr = IsOpen(NULL, FALSE, &bIsOpen, &spFrame);
	RETURN_ON_FAIL_OR_NULL2(hr, spFrame, S_FALSE); 	// file not open
	
	CComVariant var;
    hr = spFrame->GetProperty(VSFPROPID_DocCookie, &var);
	RETURN_ON_FAIL(hr);

	CComPtr<IVsExtensibility> pExtService;
	hr = ExternalQueryService(SID_SVsExtensibility, IID_IVsExtensibility, (LPVOID*)&pExtService);
	RETURN_ON_FAIL_OR_NULL2(hr, pExtService, E_UNEXPECTED);

    return pExtService->GetDocumentFromDocCookie(V_INT_PTR(&var), ppDocument);
}

STDMETHODIMP CAutoFile::get_SubProject(Project** ppProject)
{
	CHECK_POINTER_VALID(ppProject);
	*ppProject = NULL;
	return S_OK;
}

STDMETHODIMP CAutoFile::get_ContainingProject(Project ** ppProject)
{
	CHECK_POINTER_VALID(ppProject);
	CComQIPtr<Project> pProject = m_spAutoProject;
	VSASSERT( pProject != NULL, "QI for Project interface failed" );
	return pProject.CopyTo( ppProject );
}

STDMETHODIMP CAutoFile::get_ConfigurationManager(ConfigurationManager** ppConfigurationManager)
{
	CVCFileNode* pFileNode = GetFileNode();
	RETURN_ON_NULL2(pFileNode, E_UNEXPECTED);

	CHECK_POINTER_VALID(ppConfigurationManager);
	CVCProjectNode* pProjectNode = GetProjectNode(pFileNode);
	CVCArchy *pArchy = NULL;
	if (pProjectNode)
		pArchy = pProjectNode->GetArchy();
	CHECK_ZOMBIE(pArchy, IDS_ERR_PROJ_ZOMBIE);

	CComPtr<IVsExtensibility> pExtService;
	HRESULT hr = ExternalQueryService(SID_SVsExtensibility, IID_IVsExtensibility, (LPVOID*)&pExtService);
	RETURN_ON_FAIL_OR_NULL(hr, pExtService);

	CComPtr<IVsHierarchy> spHier = pArchy->GetIVsHierarchy();
	return pExtService->GetConfigMgr(spHier, pFileNode->GetVsItemID(), ppConfigurationManager);
}

STDMETHODIMP CAutoFile::AddFolder(BSTR Name, BSTR Kind, ProjectItem **pProjectItem)
{
	CHECK_POINTER_VALID(pProjectItem);
	*pProjectItem = NULL;
	return E_FAIL;	// CAutoFile::AddFolder, files can't have folders added to them
}

STDMETHODIMP CAutoFile::get_FileCodeModel(FileCodeModel ** ppFileCodeModel)
{
	CHECK_POINTER_VALID(ppFileCodeModel);
	CComBSTR bstrFileName;
	get_Name(&bstrFileName);
	if (bstrFileName.Length() == 0)
		CHECK_ZOMBIE(NULL, IDS_ERR_FILE_ZOMBIE);

	CComPtr<IDispatch> spDispFile;
	HRESULT hr = QueryInterface(__uuidof(IDispatch), reinterpret_cast<void **>(&spDispFile));
	RETURN_ON_FAIL(hr);

	CComPtr<VCCodeModelService> spIVCCodeModelService;
	hr = ExternalQueryService(SID_SVCCodeModelService,
		__uuidof(VCCodeModelService), reinterpret_cast<void **>(&spIVCCodeModelService));
	RETURN_ON_FAIL_OR_NULL(hr, spIVCCodeModelService);

	CComPtr<VCFileCodeModel> spVCFileCodeModel;
	if (FAILED(hr = spIVCCodeModelService->CreateFileCodeModel(bstrFileName, &spVCFileCodeModel)))
	{
		return S_FALSE;
	}

	CComPtr<VCFileCodeModelI> spVCFileCodeModelI;
	hr = spVCFileCodeModel.QueryInterface(&spVCFileCodeModelI);
	RETURN_ON_FAIL_OR_NULL(hr, spVCFileCodeModelI);

	if (FAILED(hr = spVCFileCodeModelI->put_Parent(spDispFile)))
	{
		return S_FALSE;
	}

	return spVCFileCodeModelI.QueryInterface(ppFileCodeModel);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

CAutoItems::CAutoItems()
{
}

CAutoItems::~CAutoItems()
{
}

//-----------------------------------------------------------------------------
// create an instance of a project node with reference count 1
//-----------------------------------------------------------------------------
HRESULT CAutoItems::CreateInstance(CAutoItems **ppAutoItems, IDispatch* pAutoParent, IDispatch* pAutoProject, 
	IDispatch* pDispItems)
{
	CComObject<CAutoItems> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CAutoItems>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjObj, E_OUTOFMEMORY);
	pPrjObj->AddRef();
	pPrjObj->Initialize(pAutoParent, pAutoProject, pDispItems);
	*ppAutoItems = pPrjObj;
	return hr;
}

void CAutoItems::Initialize(IDispatch* pAutoParent, IDispatch *pAutoProject, IDispatch* pDispItems)
{
	m_spAutoParent = pAutoParent;
	VSASSERT(m_spAutoParent != NULL, "Trying to initialize CAutoItems with a NULL parent!");
	m_spAutoProject = pAutoProject;
	VSASSERT(m_spAutoProject != NULL, "Trying to initialize CAutoItems with a NULL project!");
	if (m_spItems != NULL)
		m_spItems.Release();
	VSASSERT(pDispItems != NULL, "Trying to initialize CAutoItems with a NULL item list!");
	m_spItems = pDispItems;
}

//---------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAutoItems::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IVsPackage,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/* _ProjectItems methods */
STDMETHODIMP CAutoItems::Item(VARIANT index, ProjectItem FAR* FAR* lppcReturn)
{
	CHECK_ZOMBIE(m_spItems, IDS_ERR_COLLECTION_ZOMBIE)
	CHECK_POINTER_VALID(lppcReturn)
	
	*lppcReturn = NULL;

	CComPtr<IDispatch> spItem;
	HRESULT hr = m_spItems->Item(index, &spItem);
	RETURN_ON_FAIL_OR_NULL2(hr, spItem, S_FALSE);

	CComPtr<IDispatch> spDispObject;
	hr = GetItem(&spDispObject, this, m_spAutoParent, m_spAutoProject, spItem);
	RETURN_ON_FAIL(hr);
	CComQIPtr<ProjectItem> spProjItem = spDispObject;
	*lppcReturn = spProjItem.Detach();
	return hr;
}

/* static */
HRESULT CAutoItems::GetItem(IDispatch** ppProjItem, IDispatch* pOwner, IDispatch* pAutoParent, IDispatch* pAutoProject, 
	IDispatch* pVCItem)
{
	HRESULT hr = S_OK;
	CComQIPtr<VCFilter> spFilter = pVCItem;
	if (spFilter)
	{
		CAutoFilter* pAutoFilter = NULL;
		hr = CAutoFilter::CreateInstance(&pAutoFilter, pOwner, pAutoProject, pVCItem);
		RETURN_ON_FAIL(hr);
		*ppProjItem = (IDispatch *)pAutoFilter;
		return S_OK;
	}

	// if it wasn't a filter, then it must be a file
	CAutoFile* pAutoFile = NULL;
	if (pAutoParent != pAutoProject)
		hr = CAutoFile::CreateInstance(&pAutoFile, pOwner, pAutoProject, pVCItem);
	else	// need to make sure we get the folder this file really belongs in
	{
		CComQIPtr<VCFile> spFile = pVCItem;
		RETURN_ON_NULL(spFile);
		CComPtr<IDispatch> spParent;
		spFile->get_Parent(&spParent);
		CComQIPtr<VCProject> spProjParent = spParent;
		if (spProjParent)
			hr = CAutoFile::CreateInstance(&pAutoFile, pOwner, pAutoProject, pVCItem);
		else	// parent is a folder
		{
			CComQIPtr<VCFilter> spParentFilter = spParent;
			RETURN_ON_NULL2(spParentFilter, E_UNEXPECTED);

			CComQIPtr<IVCExternalCookie> spCookie = spParentFilter;
			RETURN_ON_NULL(spCookie);
			void* pCookie = NULL;
			spCookie->get_ExternalCookie(&pCookie);
			RETURN_ON_NULL(pCookie);
			CVCFileGroup* pParentGroup = (CVCFileGroup*)pCookie;
			CComVariant var2;
			pParentGroup->GetExtObject(var2);
			if (var2.vt != VT_DISPATCH && var2.vt != VT_UNKNOWN)
				return E_FAIL;
			CComPtr<IDispatch> spRealAutoParent = var2.pdispVal;
			CComPtr<IDispatch> spDispItems;
			HRESULT hr = spParentFilter->get_Items(&spDispItems);
			RETURN_ON_FAIL_OR_NULL(hr, spDispItems);

			CComPtr<CAutoItems> pAutoItems;
			hr = CAutoItems::CreateInstance(&pAutoItems, spRealAutoParent, pAutoProject, spDispItems);
			RETURN_ON_FAIL(hr);

			hr = CAutoFile::CreateInstance(&pAutoFile, pAutoItems, pAutoProject, pVCItem);
		}
	}
	RETURN_ON_FAIL(hr);

	*ppProjItem = (IDispatch *)pAutoFile;
	return S_OK;
}

STDMETHODIMP CAutoItems::get_Parent(IDispatch* FAR* lppptReturn)
{
	return m_spAutoProject.CopyTo(lppptReturn);
}

STDMETHODIMP CAutoItems::get_Count(long FAR* lplReturn)
{
	CHECK_ZOMBIE(m_spItems, IDS_ERR_COLLECTION_ZOMBIE)

	return m_spItems->get_Count(lplReturn);
}

STDMETHODIMP CAutoItems::_NewEnum(IUnknown* FAR* lppiuReturn)
{
	CHECK_ZOMBIE(m_spItems, IDS_ERR_COLLECTION_ZOMBIE)
	CHECK_POINTER_VALID(lppiuReturn)

	*lppiuReturn = NULL;

	CAutoEnumerator<CAutoItems>* pEnumerator = NULL;
	HRESULT hr = CAutoEnumerator<CAutoItems>::CreateInstance(&pEnumerator, this, m_spAutoParent, m_spAutoProject, m_spItems);
	RETURN_ON_FAIL_OR_NULL2(hr, pEnumerator, E_OUTOFMEMORY);

	hr = pEnumerator->QueryInterface(__uuidof(IUnknown), (LPVOID *)lppiuReturn);
	pEnumerator->Release();	// QI above gives us the refcount of 1 we want...
	return hr;
}

STDMETHODIMP CAutoItems::get_DTE(DTE FAR* FAR* lppaReturn)
{
	CHECK_POINTER_VALID(lppaReturn);
	return GetBuildPkg()->GetDTE(lppaReturn);
}

STDMETHODIMP CAutoItems::get_Kind(BSTR FAR* lpbstrFileName)
{
	CHECK_POINTER_VALID(lpbstrFileName)

	CComBSTR bstrKind = L"26FE99B0-8BBA-4436-83FC-B546C6FD3EDC";
	*lpbstrFileName = bstrKind.Detach();
	return S_OK;
}

STDMETHODIMP CAutoItems::AddFromFile(BSTR FileName, ProjectItem FAR* FAR* lppcReturn)
{
	CHECK_POINTER_VALID(lppcReturn)

	*lppcReturn = NULL;

	CComQIPtr<_Project> spRealAutoProject = m_spAutoProject;
	RETURN_ON_NULL2(spRealAutoProject, E_UNEXPECTED);

	CComPtr<IDispatch> spDispProject;
	HRESULT hr = spRealAutoProject->get_Object(&spDispProject);
	VSASSERT(SUCCEEDED(hr) && spDispProject != NULL, "Failed to pick up matching project!");

	CComQIPtr<VCProject> spProject = spDispProject;
	VSASSERT(spProject != NULL, "Failed to get project!");
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(spProject, IDS_ERR_PROJ_ZOMBIE);

	// dunno how to add a filter using this method, so must be a file
	CComPtr<IDispatch> spDispFile;
	hr = spProject->AddFile(FileName, &spDispFile);
	RETURN_ON_FAIL_OR_NULL2(hr, spDispFile, E_UNEXPECTED);

	CAutoFile* pAutoFile = NULL;
	hr = CAutoFile::CreateInstance(&pAutoFile, this, m_spAutoProject, spDispFile);
	*lppcReturn = (ProjectItem *)pAutoFile;
	return hr;
}

HRESULT CAutoItems::GetBaseObject(IDispatch** ppObject)
{
	CHECK_POINTER_NULL(ppObject);

	CComQIPtr<_Project> spAutoProject = m_spAutoParent;
	if (spAutoProject)
		spAutoProject->get_Object(ppObject);
	else
	{
		CComQIPtr<_ProjectItem> spAutoItem = m_spAutoParent;
		RETURN_ON_NULL2(spAutoItem, E_UNEXPECTED);

		spAutoItem->get_Object(ppObject);
	}

	return S_OK;
}

CVCBaseFolderNode* CAutoItems::GetBaseNode()
{
	CComPtr<IDispatch> spDispParent;
	GetBaseObject(&spDispParent);

	CComQIPtr<IVCExternalCookie> spExtCookie = spDispParent;
	RETURN_ON_NULL2(spExtCookie, NULL);

	void* pCookie;
	spExtCookie->get_ExternalCookie(&pCookie);
	RETURN_ON_NULL2(pCookie, NULL);

	return (CVCBaseFolderNode*)pCookie;
}

STDMETHODIMP CAutoItems::AddFromTemplate(BSTR bstrFullSrc, BSTR bstrDest, ProjectItem FAR* FAR* lppcReturn)
{
	CVCBaseFolderNode* pBaseNode;
	HWND hwndDlg;
	HRESULT hr = SetupForAddItemDlg(&pBaseNode, &hwndDlg, lppcReturn);
	RETURN_ON_FAIL(hr);

	CPathW pathFullSrc;
	if (!pathFullSrc.Create(bstrFullSrc))
		RETURN_INVALID();

	CStringW strExt = pathFullSrc.GetExtension();
	strExt.MakeLower();

	VSADDRESULT addResult;
	if (strExt == L".vsz")
		hr = pBaseNode->HandleAddItemDlg(VSADDITEMOP_RUNWIZARD, bstrDest, 1, (LPCOLESTR*)&bstrFullSrc, hwndDlg, &addResult);
	else
		hr = pBaseNode->HandleAddItemDlg(VSADDITEMOP_CLONEFILE, bstrDest, 1, (LPCOLESTR*)&bstrFullSrc, hwndDlg, &addResult);

	return FinishFromAddItemDlg(hr, addResult, bstrDest, lppcReturn);
}

STDMETHODIMP CAutoItems::AddFromDirectory(BSTR Directory, ProjectItem FAR* FAR* lppcReturn)
{
	return E_NOTIMPL;	// CAutoItems::AddFromDirectory -- doesn't really make sense for a reference-based project model
}

STDMETHODIMP CAutoItems::get_ContainingProject(Project **ppProject)
{
	CHECK_POINTER_VALID(ppProject);
	CComQIPtr<Project> pProject = m_spAutoProject;
	VSASSERT( pProject != NULL, "QI for Project interface failed" );
	return pProject.CopyTo( ppProject );
}

STDMETHODIMP CAutoItems::AddFolder(BSTR bstrName, BSTR bstrKind, ProjectItem **pProjectItem)
{
	CHECK_POINTER_VALID(pProjectItem);
	*pProjectItem = NULL;

	OLECHAR *pszVirtualFolder = NULL;
    ::StringFromIID(GUID_ItemType_VirtualFolder, &pszVirtualFolder);
    CComBSTR bstrVirtualFolder = pszVirtualFolder;
    ::CoTaskMemFree(pszVirtualFolder);

	if (bstrKind && bstrVirtualFolder && _wcsicmp(bstrVirtualFolder, bstrKind))
		return E_NOTIMPL;	// CAutoItems::AddFolder, only handle virtual folders

	CComPtr<IDispatch> spDispParent;
	HRESULT hr = GetBaseObject(&spDispParent);
	RETURN_ON_FAIL(hr);

	CComQIPtr<VCFilter> spFilter = spDispParent;
	CComPtr<IDispatch> spNewFilter;
	if (spFilter)
		hr = spFilter->AddFilter(bstrName, &spNewFilter);
	else
	{
		CComQIPtr<VCProject> spProject = spDispParent;
		RETURN_ON_NULL2(spProject, E_UNEXPECTED);
		hr = spProject->AddFilter(bstrName, &spNewFilter);
	}

	RETURN_ON_FAIL(hr);

	return Item(CComVariant(bstrName), pProjectItem);
}

STDMETHODIMP CAutoItems::AddFromFileCopy(BSTR bstrFilePath, ProjectItem** ppOut)
{
	CVCBaseFolderNode* pBaseNode;
	HWND hwndDlg;
	HRESULT hr = SetupForAddItemDlg(&pBaseNode, &hwndDlg, ppOut);
	RETURN_ON_FAIL(hr);

	VSADDRESULT addResult;
	hr = pBaseNode->HandleAddItemDlg(VSADDITEMOP_OPENFILE, L"", 1, (LPCOLESTR*)&bstrFilePath, hwndDlg, &addResult);

	return FinishFromAddItemDlg(hr, addResult, bstrFilePath, ppOut);
}

HRESULT CAutoItems::SetupForAddItemDlg(CVCBaseFolderNode** ppBaseNode, HWND* phwndDlg, ProjectItem** ppOut)
{
	CHECK_POINTER_VALID(ppOut);	// this is a check for outparam of AddFromTemplate and AddFromFileCopy
    *ppOut = NULL;

	*ppBaseNode = GetBaseNode();
	RETURN_ON_NULL2(*ppBaseNode, E_UNEXPECTED);

	CComPtr<IVsUIShell> pUIShell;
	HRESULT hr = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
	RETURN_ON_FAIL_OR_NULL(hr, pUIShell);
	return pUIShell->GetDialogOwnerHwnd(phwndDlg);
}

HRESULT CAutoItems::FinishFromAddItemDlg(HRESULT hrReturn, VSADDRESULT addResult, BSTR bstrPath, ProjectItem** ppItem)
{
	RETURN_ON_FAIL(hrReturn);
	if (ADDRESULT_Failure == addResult)
		return E_FAIL;

	return Item(CComVariant(bstrPath), ppItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autofilter.h ===
// AutoFilter.h
// declares what we implement for the DTE ProjectItem

#include "PrjNode.h"
#include "AutoBase.h"
#include "vcfgrp.h"

// JOSHEP_TODO: you will need to set these classes up so that they know their relationship to:
//	a) the collection they belong to
//	b) any collection they own

// classes in this header
class CAutoFilter;

// string version of the guid
_declspec(selectany) LPOLESTR szguidCATIDAutoFilter = L"{610d461d-d0d5-11d2-8599-006097c68e81}";

class CAutoFilter : 
	public CAutoBase<CAutoFilter, VCFilter, szguidCATIDAutoFilter>,
	public CComDualImpl<_ProjectItem, &IID__ProjectItem, &LIBID_DTE, 7, 0>, 
	public ISupportVSProperties,
	public CComObjectRoot
{
public:
	CAutoFilter();
	~CAutoFilter();
	void Initialize(IDispatch* pAutoItems, IDispatch* pAutoProject, IDispatch* pItem);
	static HRESULT CreateInstance(CAutoFilter** ppAutoFilter, IDispatch* pAutoItems, IDispatch* pAutoProject,
		IDispatch* pItem);
	VCFilter *GetFilter() { return(m_spFilter); }

BEGIN_COM_MAP(CAutoFilter)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(_ProjectItem)
	COM_INTERFACE_ENTRY(ISupportVSProperties)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CAutoFilter) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

// ProjectItem
public:
    /* _ProjectItem methods */
    STDMETHOD(get_IsDirty)(VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(put_IsDirty)(VARIANT_BOOL DirtyFlag);
    STDMETHOD(get_FileNames)(short Index, BSTR FAR* lpbstrReturn);
    STDMETHOD(SaveAs)(BSTR NewFileName, VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(get_FileCount)(short FAR* lpsReturn);
    STDMETHOD(get_Reserved1)(long FAR* lpulReturn) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved1)(long Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved2)(BSTR FileName) { return E_NOTIMPL; }
    STDMETHOD(Reserved3)() { return E_NOTIMPL; }
    STDMETHOD(get_Name)(BSTR FAR* pbstrReturn);
    STDMETHOD(put_Name)(BSTR bstrName);
    STDMETHOD(get_Reserved14)(IDispatch * FAR* ppDispatch) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved4)(IDispatch * FAR* ppVbaModule) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved5)(long FAR* pkind) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved6)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Collection)(ProjectItems FAR* FAR* lppcReturn);
    STDMETHOD(get_Reserved15)(VARIANT_BOOL FAR* lpfReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Properties)(Properties FAR* FAR* ppObject);
    STDMETHOD(Reserved7)(IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
    STDMETHOD(Reserved8)(BSTR Key, BSTR FAR* lpbstrValue) { return E_NOTIMPL; }
    STDMETHOD(Reserved9)(BSTR Key, BSTR Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved10)() { return E_NOTIMPL; }
    STDMETHOD(get_Reserved11)(long FAR* lpdwContextID) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved11)(long dwContextID) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved12)(BSTR FAR* lpbstrDescription) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved12)(BSTR bstrDescription) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved13)(BSTR FAR* pbstrReturn) { return E_NOTIMPL; }
    STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn);
    STDMETHOD(get_Kind)(BSTR FAR* lpbstrFileName);
    STDMETHOD(get_ProjectItems)(ProjectItems FAR* FAR* lppcReturn);
    STDMETHOD(get_IsOpen)(BSTR LogView, VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(Open)(BSTR LogView, Window FAR* FAR* lppfReturn);
    STDMETHOD(Remove)();
    STDMETHOD(Delete)();
    STDMETHOD(ExpandView)();
    STDMETHOD(get_Object)(IDispatch **ppProjectItemModel);
    STDMETHOD(get_Extender)(BSTR bstrExtenderName, IDispatch **ppExtender);
    STDMETHOD(get_ExtenderNames)(VARIANT *pvarExtenderNames);
    STDMETHOD(get_ExtenderCATID)(BSTR *pbstrRetval);

    STDMETHOD(get_Saved)(VARIANT_BOOL *lpfReturn);
    STDMETHOD(put_Saved)(VARIANT_BOOL Dirty);
    STDMETHOD(get_SourceControl)(SourceControl ** /*ppSourceControl*/);
    STDMETHOD(get_ConfigurationManager)(ConfigurationManager ** /*ppConfigurationManager*/);
    STDMETHOD(get_CodeModel)(CodeModel ** /*ppCodeModel*/);
    STDMETHOD(Save)(BSTR /*FileName*/);
    STDMETHOD(get_Document)(Document ** /*ppDocument*/);
    STDMETHOD(get_SubProject)(Project ** /*ppProject*/);
    STDMETHOD(get_ContainingProject)(Project ** /*ppProject*/);
    STDMETHOD(get_FileCodeModel)(FileCodeModel ** ppFileCodeModel);
    STDMETHOD(AddFolder)(BSTR Name, BSTR Kind, ProjectItem **pProjectItem);

protected:
	CComPtr<IDispatch> m_spAutoItems;	// automation collection filter belongs in
	CComPtr<IDispatch> m_spAutoProject;	// project this filter belongs to
	CComQIPtr<VCFilter> m_spFilter;

	CVCFileGroup* GetFileGroup();
	CVCProjectNode* GetProjectNode(CVCFileGroup* pFileGroup = NULL);

// ISupportVSProperties
public:
	STDMETHOD(NotifyPropertiesDelete)()
	{
		return E_NOTIMPL;	// CAutoFilter::NotifyPropertiesDelete
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autoproject.h ===
// AutoProject.h
// declares what we implement for the DTE Project based interface of
// AutoProject

#pragma once

#include "PrjNode.h"
#include "AutoBase.h"

// Constants

// string version of the guid
_declspec(selectany) LPOLESTR szguidCATIDAutoProj = L"{610d461e-d0d5-11d2-8599-006097c68e81}";

class CAutoProject : 
	public CAutoBase<CAutoProject, VCProject, szguidCATIDAutoProj>,
	public IDispatchImpl<_Project, &__uuidof(_Project), &LIBID_DTE, 7, 0>, 
	public ISupportErrorInfo,
	public ISupportVSProperties,
	public CComObjectRoot
{
public:
	CAutoProject();
	~CAutoProject();
	void Initialize(IDispatch* pAutoProjects, IDispatch* pProject);
	static HRESULT CreateInstance(CAutoProject **ppAutoProject, IDispatch* pAutoProjects, IDispatch* pAutoProject, 
		IDispatch* pProject);
	VCProject* GetProject();
	CVCProjectNode* GetProjectNode();

BEGIN_COM_MAP(CAutoProject)
	COM_INTERFACE_ENTRY(ISupportVSProperties)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(_Project)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CAutoProject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// Project
public:
    /* _Project methods */
    STDMETHOD(get_Name)(BSTR FAR* lpbstrName);
    STDMETHOD(put_Name)(BSTR bstrName);
    STDMETHOD(Reserved1)(BSTR ProgID, VARIANT FileName) { return E_NOTIMPL; }
    STDMETHOD(get_FileName)(BSTR FAR* lpbstrReturn);
    STDMETHOD(get_IsDirty)(VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(put_IsDirty)(VARIANT_BOOL Dirty);
    STDMETHOD(Reserved2)(BSTR Section, BSTR Key, BSTR Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved3)(BSTR Section, BSTR Key, BSTR FAR* lpbstrValue) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved4)(BSTR FAR* lpbstrHelpFile) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved4)(BSTR bstrHelpFile) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved5)(long FAR* lpdwContextID) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved5)(long dwContextID) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved6)(BSTR FAR* lpbstrDescription) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved6)(BSTR bstrDescription) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved7)(IDispatch * FAR* lppReferences) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved8)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Collection)(Projects FAR* FAR* lppaReturn);
    STDMETHOD(get_Reserved9)(long FAR* lpStartMode) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved9)(long StartMode) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved10)(BSTR FAR* lpbstrCompatibleOleServer) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved10)(BSTR bstrCompatibleOleServer) { return E_NOTIMPL; }
    STDMETHOD(SaveAs)(BSTR FileName);
    STDMETHOD(Reserved11)() { return E_NOTIMPL; }
    STDMETHOD(get_Reserved12)(long FAR* lpkind) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved12)(long Type) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved13)(long FAR* lpIconState) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved13)(long IconState) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved17)(VARIANT_BOOL FAR* lpfReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved15)(IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved16)(BSTR FAR* lpbstrBldFName) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved16)(BSTR bstrBldFName) { return E_NOTIMPL; }
    STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn);
    STDMETHOD(get_Kind)(BSTR FAR* lpbstrFileName);
    STDMETHOD(get_ProjectItems)(ProjectItems FAR* FAR* lppcReturn);
    STDMETHOD(get_Properties)(Properties FAR* FAR* ppObject);
    STDMETHOD(get_UniqueName)(BSTR FAR* lpbstrFileName);
    STDMETHOD(get_Object)(IDispatch **ppProjectModel);
    STDMETHOD(get_Extender)(BSTR bstrExtenderName, IDispatch **ppExtender);
    STDMETHOD(get_ExtenderNames)(VARIANT *pvarExtenderNames);
    STDMETHOD(get_ExtenderCATID)(BSTR *pbstrRetval);

    STDMETHOD(get_FullName)(BSTR *lpbstrReturn);
    STDMETHOD(get_Saved)(VARIANT_BOOL *lpfReturn);
    STDMETHOD(put_Saved)(VARIANT_BOOL Dirty);
    STDMETHOD(get_SourceControl)(SourceControl ** /*ppSourceControl*/);
    STDMETHOD(get_ConfigurationManager)(ConfigurationManager **ppConfigurationManager);
    STDMETHOD(get_Globals)(Globals ** /*ppGlobals*/);
    STDMETHOD(Save)(BSTR /*FileName*/);
    STDMETHOD(get_ParentProjectItem)(ProjectItem ** ppProjectItem);
    STDMETHOD(get_CodeModel)(CodeModel ** ppCodeModel);
    STDMETHOD(Delete)();

protected:
	CComQIPtr<VCProject> m_spProject;
	CComPtr<IDispatch> m_spAutoProjects;
	CComPtr<Globals> m_spGlobals;

// ISupportVSProperties
public:
	STDMETHOD(NotifyPropertiesDelete)()
	{
		return E_NOTIMPL;	// CAutoProject::NotifyPropertiesDelete
	}
};

class ATL_NO_VTABLE CAutoProjects :
	public CAutoBase<CAutoProjects, IVCCollection, szguidCATIDAutoProj>,
	public CComObjectRoot,
	public ISupportVSProperties,
	public IDispatchImpl<Projects, &IID__Projects, &LIBID_DTE, 7, 0>
{
public:
	CAutoProjects();
	~CAutoProjects();
	static HRESULT CreateInstance(CAutoProjects** ppAutoProjects, IDispatch* pProjects);

BEGIN_COM_MAP(CAutoProjects)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(Projects)
END_COM_MAP()

protected:
	void Initialize(IDispatch* pProjects);

/* _Projects methods */
public:
	STDMETHOD(Item)(VARIANT index, Project FAR* FAR* lppcReturn);
	STDMETHOD(get_Reserved1)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
	STDMETHOD(get_Parent)(DTE FAR* FAR* lppaReturn);
	STDMETHOD(get_Count)(long FAR* lplReturn);
	STDMETHOD(_NewEnum)(IUnknown * FAR* lppiuReturn);
	STDMETHOD(Reserved2)(long Type, VARIANT_BOOL Exclusive, IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
	STDMETHOD(Reserved3)(BSTR PathName, VARIANT_BOOL Exclusive, IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
	STDMETHOD(Reserved4)(BSTR PathName, VARIANT_BOOL Exclusive, IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
	STDMETHOD(Reserved5)(IDispatch * lpc) { return E_NOTIMPL; }
	STDMETHOD(get_Reserved6)(IDispatch * FAR* lppptReturn) { return E_NOTIMPL; }
	STDMETHOD(put_Reserved6)(IDispatch * lpptNewActiveProj) { return E_NOTIMPL; }
	STDMETHOD(Reserved7)(BSTR FAR* lpbstrReturn) { return E_NOTIMPL; }
	STDMETHOD(get_Reserved8)(long FAR* lpIconState) { return E_NOTIMPL; }
	STDMETHOD(put_Reserved8)(long IconState) { return E_NOTIMPL; }
	STDMETHOD(Reserved9)(BSTR PathName) { return E_NOTIMPL; }
	STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn);
	STDMETHOD(get_Properties)(Properties * FAR* lppaReturn);
	STDMETHOD(get_Kind)(BSTR FAR* lpbstrReturn);

protected:
	CComQIPtr<IVCCollection> m_spProjects;

// helpers
public:
	static HRESULT GetItem(IDispatch** ppProjItem, IDispatch* pOwner, IDispatch* pAutoParent, IDispatch* pAutoProject, IDispatch* pVCItem);

// ISupportVSProperties
public:
	STDMETHOD(NotifyPropertiesDelete)()
	{
		return E_NOTIMPL;	// CAutoProject::NotifyPropertiesDelete
	}
};

class ATL_NO_VTABLE CAutoGlobals : 
	public CComObjectRoot,
	public IDispatchImpl<Globals, &IID_Globals, &LIBID_DTE, 7, 0>
{
public:
	CAutoGlobals();
	~CAutoGlobals();
	static HRESULT CreateInstance( CAutoGlobals **ppAutoGlobals, VCProject *pProj );

BEGIN_COM_MAP( CAutoGlobals )
	COM_INTERFACE_ENTRY( IDispatch )
	COM_INTERFACE_ENTRY( Globals )
END_COM_MAP()

protected:
	void Initialize( VCProject *pProj );

// Globals methods
public:
	STDMETHOD(get_DTE)( DTE **ppDTE );
	STDMETHOD(get_Parent)( IDispatch **ppDTE );
	STDMETHOD(get_VariableValue)( BSTR name, VARIANT *pVal );
	STDMETHOD(put_VariableValue)( BSTR name, VARIANT val );
	STDMETHOD(get_VariablePersists)( BSTR name, VARIANT_BOOL *pbVal );
	STDMETHOD(put_VariablePersists)( BSTR name, VARIANT_BOOL bVal );
	STDMETHOD(get_VariableExists)( BSTR name, VARIANT_BOOL *pbVal );
	STDMETHOD(get_VariableNames)( VARIANT *pNames );

private:
	CComPtr<IVCGlobals> m_spGlobals;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\bldpkg.cpp ===
// BldPkg.cpp : Implementation of CBuildPackage
#include "stdafx.h"
#include "path2.h"
#include "projbuildevents.h"
#include "BldPkg.h"
#include "vcfile.h"
#include "vcfgrp.h"
#include "errcontext2.h"

#include "vcarchy.h"
#include "exehierarchy.h"
#include "..\resdll\gpcmd.h"
#include <YVALS.H>
#include "localeinfo.h"
#include "output.h"
#include "bldguid.h"
#include <vcextgd.h>
#include "vcprojcnvt2.h"

#include "OptionsDlg.h"
#include "DirectoriesDlg.h"
#include "ConvertDlg.h"
#include "exefordbg.h"

#include <atlsafe.h>

#include "outgroup.h"
#include "vsappid.h"

#include "utils.h"
#include "profile.h"
#include "AutoProject.h"

#include "bldtst.h"
#include "VsCoCreate.h"

#ifdef AARDVARK
#include "StyleHierarchy.h"


// {A5B688D0-F9AA-4462-94FF-6BD2D72C52BA}
DEFINE_GUID(IID_IStyleSheetHierarchy, 
0xa5b688d0, 0xf9aa, 0x4462, 0x94, 0xff, 0x6b, 0xd2, 0xd7, 0x2c, 0x52, 0xba);
#endif	// AARDVARK

#define USE_GLOBAL_RC_EDITOR	L"UseGlobalRCEditor"

//CWnd g_hMainWnd; // for dialogs' parent
CBuildPackage *g_pBuildPackage = NULL;
BOOL CConvertDlg::s_bCancel = FALSE;
BOOL CConvertDlg::s_bConvertAll = FALSE;
BOOL CConvertDlg::s_bConvertNone = FALSE;
VSOWNEDPROJECTOBJECT CVCProjectFactory::s_EFPolicyCookie;

BOOL CCCallExeForDebug::s_bTestContainerInit = FALSE;
CStringW CCCallExeForDebug::s_strTestContainer = L"";

CLocaleInfo g_LocaleInfo;
HINSTANCE g_hInstLocale; // hinstance of localized resources
CComBSTR CBuildPackage::s_bstrAltKey = L"Software\\Microsoft\\VisualStudio\\7.0";

// global "in project load" flag. DO NOT EDIT DIRECTLY!!!
bool g_bInProjectLoad = false;

// global "root level project" string for VC 4.x conversion ONLY
wchar_t* g_wszRootProjectName = NULL;

CComBSTR bstrExeArguments;

extern "C" void	ENDBOOT_projbld(void){ return; }

// helper class for "in project load" tracking
class CInProjectLoadHelper
{
public:
	CInProjectLoadHelper(){ g_bInProjectLoad = true; }
	~CInProjectLoadHelper(){ g_bInProjectLoad = false; }
};

// Global execution context
CVCExecutionCtx CBuildPackage::s_executionCtx;

CBuildPackage* GetBuildPkg(void)
{
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage != NULL, "Build package not initialized!");
	return /*CBuildPackage::*/g_pBuildPackage;
}

IServiceProvider* GetServiceProvider(void)
{
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage != NULL, "Build package not initialized!");
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage->m_pServiceProvider != NULL, "Shell service provider not initialized!");
	return /*CBuildPackage::*/g_pBuildPackage->m_pServiceProvider;
}

HRESULT ExternalQueryService(REFGUID rsid, REFIID iid, void **ppvObj)
{
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage != NULL, "Build package not initialized!");
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage->m_pServiceProvider != NULL, "Shell service provider not initialized!");
	return /*CBuildPackage::*/g_pBuildPackage->m_pServiceProvider->QueryService(rsid, iid, ppvObj);
}

HRESULT DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bSetErrorInfo /* = TRUE */)
{
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage != NULL, "Build package not initialized!");
	return g_pBuildPackage->DoSetErrorInfo(hrErr, idErr, bSetErrorInfo);
}

HRESULT DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bSetErrorInfo /* = TRUE */)
{
	VSASSERT(/*CBuildPackage::*/g_pBuildPackage != NULL, "Build package not initialized!");
	return g_pBuildPackage->DoSetErrorInfo2(hrErr, idErr, szParam, bSetErrorInfo);
}

void HandleSetErrorInfo(HRESULT hrReport, BSTR bstrMsg)
{
	CComPtr<IVsUIShell> spVsUIShell;
	HRESULT hr = g_pBuildPackage->GetVsUIShell(&spVsUIShell, TRUE /* in main thread */);
	if( hr == S_OK )
	{
		if(spVsUIShell)
			spVsUIShell->SetErrorInfo(hrReport, bstrMsg, 0, NULL, NULL);
	}
}

void ReportError(BSTR bstrMsg, HRESULT hrReport /* = E_FAIL */)
{
	CComPtr<IVsUIShell> spVsUIShell;
	HRESULT hr = g_pBuildPackage->GetVsUIShell(&spVsUIShell, TRUE /* in main thread */);
	if( hr == S_OK )
	{
		if(spVsUIShell)
		{
			spVsUIShell->SetErrorInfo(hrReport, bstrMsg, 0, NULL, NULL);
			spVsUIShell->ReportErrorInfo(hrReport);
		}
	}
}

//t-samhar: use this function to determine whether or not
//to perform any UI-related functions.
BOOL FIsIDEInteractive()
{
	static BOOL fAlreadyQueried = FALSE;
	static BOOL fIsInteractive = TRUE;

	if (fAlreadyQueried==FALSE)
	{
		CComPtr<IVsShell> pVsShell;
		HRESULT hr = GetBuildPkg()->GetVsShell(&pVsShell);
		RETURN_ON_FAIL2(hr, FALSE);

		CComVariant var;
		pVsShell->GetProperty(VSSPROPID_IsInteractive, &var);  
		VSASSERT(SUCCEEDED(hr) && var.vt == VT_BOOL, "Failed to get IsInteractive property");

		fAlreadyQueried = TRUE;
		if (V_BOOL(&var))
			fIsInteractive = TRUE;
		else
			fIsInteractive = FALSE;
	}

	return fIsInteractive;
}

HRESULT CBuildPackage::GetVsShell(IVsShell** ppShell)
{
	CHECK_POINTER_NULL(ppShell);

	HRESULT hr = ExternalQueryService(SID_SVsShell, __uuidof(IVsShell), (void**)ppShell);
	VSASSERT(SUCCEEDED(hr), "Failed to get IVsShell interface");
	RETURN_ON_FAIL_OR_NULL(hr, *ppShell);

	return S_OK;
}

HRESULT CBuildPackage::GetDTE(DTE** lppaReturn)
{
	CHECK_POINTER_VALID(lppaReturn);	// GetDTE is used all over everywhere for automation, so heavy-duty check required
	return ExternalQueryService(SID_SDTE, IID__DTE, (void **)lppaReturn);
}

/////////////////////////////////////////////////////////////////////////////
// CBuildPackage

CBuildPackage::CBuildPackage()
{
   	VSASSERT(g_pBuildPackage == NULL, "Build package previously initialized!");
    g_pBuildPackage = this;

	m_dwBuildProjectEngineCookie = ULONG_MAX;
	m_dwENCBuildSpawnerCookie = ULONG_MAX;
	m_dwBuildErrorContextCookie = ULONG_MAX;
	m_dwTaskCookie = 0;
	m_nSolutionRefCount = 0;
	m_cSolutionBuilds = 0;

	m_pVCNotificationSource = NULL; 
	m_hImageList = NULL;
	m_dwProjectEngineEventsCookie = NULL;
	m_vsSolutionEventsCookie = NULL;

	m_guidPersistenceSlot = GUID_NULL;
	m_fAddNewItem = 0;
	m_pBuildOptions = NULL;
	m_pBuildDirectories = NULL;
	m_bUseGlobalEditorForRC = VARIANT_FALSE;
}

CBuildPackage::~CBuildPackage()
{
	VSASSERT(m_pServiceProvider == NULL, "IBuildPackage::Close() not called");

   	VSASSERT(g_pBuildPackage == this, "Can only have one build package!");

	if (m_spAutoProjects)
		m_spAutoProjects.Release();

    g_pBuildPackage = NULL;

  if (m_pBuildDirectories)
	  delete m_pBuildDirectories;

  if (m_pBuildOptions)
	  delete m_pBuildOptions;
}

HRESULT CBuildPackage::CreateInstance(CBuildPackage **ppBuildPackage)
{
	CComObject<CBuildPackage> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CBuildPackage>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjObj, E_OUTOFMEMORY);
	pPrjObj->AddRef();
	pPrjObj->Initialize();
	*ppBuildPackage = pPrjObj;
	return hr;
}

STDMETHODIMP CBuildPackage::SetSite(IServiceProvider *pSP)
{
/* SetSite:
	Store pSP
*/
	RETURN_ON_NULL2(pSP, S_OK);

	VSASSERT(m_pServiceProvider == NULL, "Cannot call SetSite twice in a row with non-NULL service provider");

	m_pServiceProvider = pSP;

	CComPtr<IVsShell> srpShell;
	HRESULT hr = pSP->QueryService(SID_SVsShell, __uuidof(IVsShell), (void**)&srpShell);
	VSASSERT(SUCCEEDED(hr), "QueryService for IVsShell failed!  (Is this still a valid service?  Are we in a secondary thread?)");
	if(srpShell)
	{
		CComVariant var;
		hr = srpShell->GetProperty(VSSPROPID_VirtualRegistryRoot, &var);
		VSASSERT(SUCCEEDED(hr) && var.vt == VT_BSTR, "Failed to get VirtualRegistryRoot property!");
		if(SUCCEEDED(hr) && var.vt == VT_BSTR)
		{
			CBuildPackage::s_bstrAltKey = var.bstrVal;
			CStringA strAltKey = var.bstrVal;		// YES, ansi
			SetAlternateKey(strAltKey);
			VsLoaderSetRegistryRootW(var.bstrVal);
		}
	}
	
	CStringW strRoot = s_bstrAltKey + "\\VC";
	DWORD dwValue;
	if (FAILED(GetRegIntW(strRoot, USE_GLOBAL_RC_EDITOR, &dwValue)))
		dwValue = VARIANT_FALSE;
	m_bUseGlobalEditorForRC = dwValue ? VARIANT_TRUE : VARIANT_FALSE;
	
	// enable the satellite dll. 
	g_LocaleInfo.SetMainInst(_Module.GetModuleInstance()); 
	g_hInstLocale = g_LocaleInfo.GetUIHostLib();
	{
		// This bails us out of any serious trouble....
		CStringW strTest;

		if (!strTest.LoadString(g_hInstLocale, IDS_SATELLITETEST))
		{
			CComBSTR bstrMessage = L"Can't find localized resources";
			ReportError( bstrMessage );
			return S_FALSE;
		}
	}
	_Module.SetResourceInstance(g_hInstLocale);

	// now create the Engine
	{
		// REVIEW: redo this section of code when the engine becomes a registered package
		hr = Initialize();
		RETURN_ON_FAIL(hr);

		CComPtr<IVCBuildPackageInternal> pPkgInternal;
		QueryInterface(__uuidof(IVCBuildPackageInternal), (void**)&pPkgInternal);

		CComQIPtr<IVCProjectEngineImpl> pPrjUnk;
		pPrjUnk = m_pProjectEngine;
		if(pPrjUnk == NULL)
			return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
		pPrjUnk->Initialize((LONG_PTR)g_hInstLocale, pSP, NULL, pPkgInternal);
	}


	CComPtr<IVsRegisterProjectTypes> srpRegProj;
	hr = ExternalQueryService(SID_SVsRegisterProjectTypes, __uuidof(IVsRegisterProjectTypes), (void **)&srpRegProj);
	if (SUCCEEDED(hr) && srpRegProj)
	{	// register project types

		CComObject<CVCProjectFactory> *pProjectFactory = new CComObject<CVCProjectFactory>;
		RETURN_ON_NULL2(pProjectFactory, E_OUTOFMEMORY);
		pProjectFactory->AddRef();
		hr = srpRegProj->RegisterProjectType(IID_IVCArchy, pProjectFactory, &m_pVCProjectCookie);
		pProjectFactory->Release();
		RETURN_ON_FAIL(hr);

		CComObject<CExeProjectFactory> *pExeProjectFactory = new CComObject<CExeProjectFactory>;
		RETURN_ON_NULL2(pExeProjectFactory, E_OUTOFMEMORY);
		pExeProjectFactory->AddRef();
		hr = srpRegProj->RegisterProjectType(IID_IExeHierarchy, pExeProjectFactory, &m_pExeProjectCookie);
		pExeProjectFactory->Release();
		RETURN_ON_FAIL(hr);

		CComObject<CCrashDumpProjectFactory> *pCrashDumpProjectFactory = new CComObject<CCrashDumpProjectFactory>;
		RETURN_ON_NULL2(pCrashDumpProjectFactory, E_OUTOFMEMORY);
		pCrashDumpProjectFactory->AddRef();
		hr = srpRegProj->RegisterProjectType(IID_ICrashDumpHierarchy, pCrashDumpProjectFactory, &m_pCrashDumpProjectCookie);
		pCrashDumpProjectFactory->Release();
		RETURN_ON_FAIL(hr);

/*
		CComObject<CVUPProjectFactory> *pVUPProjectFactory = new CComObject<CVUPProjectFactory>;
		RETURN_ON_NULL2(pVUPProjectFactory, E_OUTOFMEMORY);
		pVUPProjectFactory->AddRef();
		hr = srpRegProj->RegisterProjectType(IID_IVUPHierarchy, pVUPProjectFactory, &m_pVUPProjectCookie);
		pVUPProjectFactory->Release();
		RETURN_ON_FAIL(hr);
*/

#ifdef AARDVARK
		CComObject<CStyleSheetProjectFactory> *pStyleSheetProjectFactory = new CComObject<CStyleSheetProjectFactory>;
		RETURN_ON_NULL2(pStyleSheetProjectFactory, E_OUTOFMEMORY);
		pStyleSheetProjectFactory->AddRef();
		hr = srpRegProj->RegisterProjectType(IID_IStyleSheetHierarchy, pStyleSheetProjectFactory, &m_pStyleSheetProjectCookie);
		pStyleSheetProjectFactory->Release();
		RETURN_ON_FAIL(hr);
#endif	// AARDVARK
	}

	CComPtr<IProfferService> pProffer;
	if ((SUCCEEDED(ExternalQueryService(SID_SProfferService, __uuidof(IProfferService), (void **)&pProffer))) && (pProffer != NULL))
	{
		CComPtr<IServiceProvider> pBuildServiceProvider;
		QueryInterface(__uuidof(IServiceProvider),(void**)&pBuildServiceProvider);
        pProffer->ProfferService(SID_SProjectEngine, pBuildServiceProvider, &m_dwBuildProjectEngineCookie);
        pProffer->ProfferService(SID_SENCBuildSpawner, pBuildServiceProvider, &m_dwENCBuildSpawnerCookie);
        pProffer->ProfferService(SID_SBuildErrorContext, pBuildServiceProvider, &m_dwBuildErrorContextCookie);
	}

	// Add init code
    if(!GetBuildPkg()->OnInit())
        return S_FALSE;

    // Call GetTaskList here : needed for marshalling the tasklist for builds
    CComPtr<IVsTaskList> spTaskList;
    hr = GetTaskList(&spTaskList, TRUE );

	// Now that we are loaded, check if we were loaded as part of a /debug switch
	CComPtr<IVsAppCommandLine> pCmdLine;
	if ((SUCCEEDED(ExternalQueryService(SID_SVsAppCommandLine, __uuidof(IVsAppCommandLine), (void **)&pCmdLine))) && (pCmdLine != NULL))
	{
		BOOL bDebug = FALSE;

		pCmdLine->GetOption(L"DebugExe",&bDebug,&bstrExeArguments);
		if( bDebug )
		{
			// It was there, so take all remaining switches and make them
			// the switches to the exe to debugs, debug config
			if (bstrExeArguments.Length() > 0)	// need to figure out if there is something here we have to open
			{
				CStringW strExeArguments = bstrExeArguments;
				int nNextIdx = 0;
				strExeArguments.TrimLeft();
				strExeArguments.TrimRight();
				int nMaxIdx = strExeArguments.GetLength();
				CStringW strSeparatorList = L" ";
				CStringW strPossibleExe;
				nNextIdx = GetNextItem(strExeArguments, nNextIdx, nMaxIdx, strSeparatorList, strPossibleExe);
				if (nNextIdx > 0)
				{
					strExeArguments = strExeArguments.Right(nMaxIdx-nNextIdx);
					strExeArguments.TrimLeft();
					strPossibleExe.TrimRight();
				}
				else
					strExeArguments.Empty();
				if (!strPossibleExe.IsEmpty())	// need to strip off any quotes, unfortunately, since SearchPathW doesn't like them
				{
					nMaxIdx = strPossibleExe.GetLength();
					if (nMaxIdx > 0 && strPossibleExe[0] == L'"')
					{
						strPossibleExe = strPossibleExe.Right(nMaxIdx-1);
						nMaxIdx--;
					}
					if (nMaxIdx > 0 && strPossibleExe[nMaxIdx-1] == L'"')
						strPossibleExe = strPossibleExe.Left(nMaxIdx-1);
				}

				bstrExeArguments = strExeArguments;
				CStringW strExtExpected;
				DWORD dwLen = SearchPathW(NULL, strPossibleExe, NULL, 0, NULL, NULL);
				if (!dwLen)
				{
					strExtExpected = L".exe";
					dwLen = SearchPathW(NULL, strPossibleExe, strExtExpected, 0, NULL, NULL);
				}
				if (!dwLen)
				{
					strExtExpected = L".com";
					dwLen = SearchPathW(NULL, strPossibleExe, strExtExpected, 0, NULL, NULL);
				}
				if (dwLen)	// found something
				{
					CStringW strExe;
					LPWSTR szFilePath = strExe.GetBuffer(dwLen+2);
					LPWSTR szFilePart = szFilePath;
					if (strExtExpected.IsEmpty())
						dwLen = SearchPathW(NULL, strPossibleExe, NULL, dwLen+1, szFilePath, &szFilePart);
					else
						dwLen = SearchPathW(NULL, strPossibleExe, strExtExpected, dwLen+1, szFilePath, &szFilePart);
					strExe.ReleaseBuffer();
					strPossibleExe = strExe;
				}

				CComPtr<IVsSolution> pSln;
				hr = GetIVsSolution( &pSln );
				CComPtr<IUnknown> spExeProj;
				if (SUCCEEDED(hr) && pSln)
				{
				    	g_bCommandLineDBG = TRUE;
					hr = pSln->CreateProject( IID_IExeHierarchy, strPossibleExe, NULL, NULL,
						CPF_OPENFILE | CPF_SILENT, IID_IUnknown, (void **)&spExeProj);
				}
			}
		}
	}
	
	// need this so as to initialize the marshalled pointer to the shell
	CComPtr<IVsUIShell> spShell;
	hr = GetVsUIShell(&spShell, TRUE /* in main thread */);

	// Add TSHELL CMDs
	InitTShell();

	UpdateSolutionFile();	// don't care whether we succeed or fail on this...

	CComPtr<IVsSolutionBuildManager> spSolnBldMgr;
	hr = GetSolutionBuildManager(&spSolnBldMgr, TRUE);
	if (SUCCEEDED(hr) && spSolnBldMgr)
		spSolnBldMgr->AdviseUpdateSolutionEvents((IVsUpdateSolutionEvents *)this, &m_vsSolutionEventsCookie);

	CComPtr<IVsSolution> pSln;
	hr = GetIVsSolution( &pSln );
	RETURN_ON_FAIL_OR_NULL2(hr, pSln, E_UNEXPECTED);
	return pSln->AdviseSolutionEvents( (IVsSolutionEvents*)this, &m_dwSlnEventsCookie );
}

int CBuildPackage::FindFirstSeparator(CStringW& strList, CStringW& strSeparatorList, int nStartIdx)
{
	int cSeparators = strSeparatorList.GetLength();
	if (cSeparators == 0)	// no separators means give back first char of list
		return 0;
	else if (cSeparators == 1)
		return strList.Find(strSeparatorList, nStartIdx);

	// got here; means we have the potential for multiple separator possibilities
	int nMinSep = -1, nThisSep = -1;
	for (int idx = 0; idx < cSeparators; idx++)
	{
		nThisSep = strList.Find(strSeparatorList.GetAt(idx), nStartIdx);
		if (nThisSep >= 0 && ((nThisSep < nMinSep) || (nMinSep < 0)))
			nMinSep = nThisSep;
	}

	return nMinSep;
}

int CBuildPackage::GetNextItem(CStringW& strList, int nStartIdx, int nMaxIdx, CStringW& strSeparator, CStringW& strItem)
{
	strItem.Empty();
	if (nStartIdx < 0)
		return nStartIdx;
	else if (nStartIdx >= nMaxIdx)
		return -1;

	int nSep = FindFirstSeparator(strList, strSeparator, nStartIdx);
	if (nSep >= 0)
	{
		int nQuote = strList.Find(L'"', nStartIdx);
		if (nQuote >= nStartIdx && nQuote < nSep)	// need to get outside the quoted string
			return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, TRUE, strSeparator, strItem);
		strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
		nSep++;
		return nSep;
	}

	if (nStartIdx < nMaxIdx)
		strItem = strList.Right(nMaxIdx-nStartIdx);

	return -1;
}

int CBuildPackage::GetNextQuotedItem(CStringW& strList, int nStartIdx, int nMaxIdx, int nSep, int nLastQuote,
	BOOL bOddQuote, CStringW& strSeparator, CStringW& strItem)
{
	if (bOddQuote)
	{
		int nQuote = strList.Find(L'"', nLastQuote+1);
		if (nQuote < nSep)	// doesn't matter that we found a quote
		{
			strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
			nSep++;
			return nSep;
		}
		else
			return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, FALSE, strSeparator, strItem);
	}
	else	// even quote
	{
		nSep = FindFirstSeparator(strList, strSeparator, nLastQuote+1);
		if (nSep >= 0)
		{
			int nQuote = strList.Find(L'"', nLastQuote+1);
			if (nQuote > nLastQuote && nQuote < nSep)	// still need to get outside the quoted string
				return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, TRUE, strSeparator, strItem);
			strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
			nSep++;
			return nSep;
		}

		if (nStartIdx < nMaxIdx)
			strItem = strList.Right(nMaxIdx-nStartIdx);
		
		return -1;
	}
}


STDMETHODIMP CBuildPackage::QueryClose(BOOL *pCanClose)
{
	CHECK_POINTER_NULL(pCanClose);

	*pCanClose = TRUE;
	return S_OK;
}

STDMETHODIMP CBuildPackage::Close()
{
	VSASSERT(m_pServiceProvider != NULL, "Cannot call Close before SetSite!");

	if (m_spAutoProjects)
		m_spAutoProjects.Release();

	// Add exit code
	GetBuildPkg()->OnExit();
	RETURN_ON_NULL2(m_pServiceProvider, E_UNEXPECTED);


	{	// scope spProffer
		CComPtr<IProfferService> spProffer;
		if ((SUCCEEDED(ExternalQueryService(SID_SProfferService, __uuidof(IProfferService), (void **)&spProffer))) && (spProffer != NULL))
		{
			HRESULT hr;
			if (m_dwBuildProjectEngineCookie != ULONG_MAX)
			{
				hr = spProffer->RevokeService(m_dwBuildProjectEngineCookie);
				VSASSERT(SUCCEEDED(hr), "Failed to revoke project engine cookie!");
			}
			m_dwBuildProjectEngineCookie = ULONG_MAX;
			if (m_dwENCBuildSpawnerCookie != ULONG_MAX)
			{
				hr = spProffer->RevokeService(m_dwENCBuildSpawnerCookie);
				VSASSERT(SUCCEEDED(hr), "Failed to revoke ENC build spawner cookie!");
			}
			m_dwENCBuildSpawnerCookie = ULONG_MAX;
			if (m_dwBuildErrorContextCookie != ULONG_MAX)
			{
				hr = spProffer->RevokeService(m_dwBuildErrorContextCookie);
				VSASSERT(SUCCEEDED(hr), "Failed to revoke error context cookie!");
			}
			m_dwBuildErrorContextCookie = ULONG_MAX;
		}
	}

	// unadvise from SolutionEvents before we let the service provider go
	if( m_dwSlnEventsCookie )
	{
		CComPtr<IVsSolution> pSln;
		HRESULT hr = GetIVsSolution( &pSln );
		if( SUCCEEDED( hr ) && pSln )
			pSln->UnadviseSolutionEvents( m_dwSlnEventsCookie );
	}

    m_pServiceProvider.Release();
	m_pVCNotificationSource.Release();

	if (m_pTaskList)
	{
		if (m_dwTaskCookie != 0)
		{
			HRESULT hr = m_pTaskList->UnregisterTaskProvider(m_dwTaskCookie);
			VSASSERT(SUCCEEDED(hr), "Failed to unregister task provider");
		}
		m_marshalTaskList.Clear();
		m_pTaskList.Release();
	}

	// unadvise from UpdateSolutionEvents
	if (m_vsSolutionEventsCookie)
	{
		CComPtr<IVsSolutionBuildManager> spSolnBldMgr;
		HRESULT hr = GetSolutionBuildManager(&spSolnBldMgr, TRUE);
		if (SUCCEEDED(hr) && spSolnBldMgr)
		{
			spSolnBldMgr->UnadviseUpdateSolutionEvents(m_vsSolutionEventsCookie);
			m_vsSolutionEventsCookie = NULL;
		}
	}
	
	if (m_dwProjectEngineEventsCookie && m_pProjectEngine)
	{
		CComQIPtr<IConnectionPointContainer> pCPContainer;
		CComPtr<IConnectionPoint> pCP;
		pCPContainer = m_pProjectEngine;
		VSASSERT(pCPContainer, "Project engine isn't a connection point container!");
		if (pCPContainer)
		{
			HRESULT hr;
			hr = pCPContainer->FindConnectionPoint(__uuidof(IVCProjectEngineEvents), &pCP);
			VSASSERT(SUCCEEDED(hr) && pCP, "Failed to find connection point for IVCProjectEngineEvents!");
			if (pCP)
			{
				pCP->Unadvise(m_dwProjectEngineEventsCookie);
				m_dwProjectEngineEventsCookie = 0;
			}
		}
		CComQIPtr<IVCProjectEngineImpl> pPrjUnk;
		pPrjUnk = m_pProjectEngine;
		pPrjUnk->Close();
		m_pProjectEngine.Release();
	}
	
	m_marshalSolutionBuildManager.Clear();
	m_marshalVsUIShell.Clear();
	m_spVsUIShell.Release();
	m_marshalVsSolution.Clear();
	m_spSolutionBuildManager.Release();
	m_spVsSccManager2.Release();

	return S_OK;
}

//---------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

void CBuildPackage::DoRefreshTaskList()
{
    if (this && m_pTaskList)
        (void)m_pTaskList->RefreshTasks(m_dwTaskCookie);
}


void CBuildPackage::DoUpdateTaskList()
{
    if (this && m_pTaskList)
        (void)m_pTaskList->UpdateProviderInfo(m_dwTaskCookie);
}

//-----------------------------------------------------------------------------
//	Called to update the status for each command
//-----------------------------------------------------------------------------
STDMETHODIMP CBuildPackage::QueryStatus(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);

	// use this as an example. 	The open command will move from here.
	if (*pguidCmdGroup == guidVSStd97)
	{
		for (ULONG i=0; i <cCmds; i++)
		{
			BOOL bEnable = FALSE;
			switch(prgCmds[i].cmdID)
			{
				case cmdidOpen:
					bEnable = TRUE; //GetProjectNode()->IsSourceControlled() && !IsInSourceControl();
					break;
				default:
					bEnable = -2;
					break;
			}

			if(bEnable == -2)
				return OLECMDERR_E_NOTSUPPORTED;
			prgCmds[i].cmdf = OLECMDF_SUPPORTED|OLECMDF_ENABLED;
		}

		return NOERROR;
	}
	else if (*pguidCmdGroup == guidVSStd2K)
	{
		return OLECMDERR_E_NOTSUPPORTED;
	}

	return OLECMDERR_E_UNKNOWNGROUP;
}

//-----------------------------------------------------------------------------
// Called to execute our commands
//-----------------------------------------------------------------------------
STDMETHODIMP CBuildPackage::Exec(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	return OLECMDERR_E_NOTSUPPORTED;
}



//-----------------------------------------------------------------------------
STDMETHODIMP CBuildPackage::GetAutomationObject(
			/* [in] */ LPCOLESTR pszPropName,
            /* [out] */ IDispatch **ppDisp)
{
	CHECK_POINTER_VALID(ppDisp);
	*ppDisp = NULL;

	if (_wcsicmp(pszPropName, L"VCProjects") == 0)
	{
		IDispatch* pAutoProjects = GetAutoProjects();	// not ref-counted
		RETURN_ON_NULL2(pAutoProjects, E_OUTOFMEMORY);
		pAutoProjects->AddRef();
		*ppDisp = pAutoProjects;
		return S_OK;
	}
	else if (_wcsicmp(pszPropName, L"VCBuild") == 0)
	{
		if (m_pProjectEngine)
		{
		    CVCBuildOptionsObject::CreateInstance( ppDisp );
		    return S_OK;
		}
		return E_FAIL;	// something wrong somewhere
	}
	else if (_wcsicmp(pszPropName, L"VCDirectories") == 0)
	{
		if (m_pProjectEngine)
			return m_pProjectEngine->QueryInterface(IID_IDispatch, (void**)ppDisp);
		return E_FAIL;	// something wrong somewhere
	}
	else if (_wcsicmp(pszPropName, L"VCProjectEngineEventsObject") == 0)
	{
		if (m_pProjectEngine)
			return m_pProjectEngine->get_Events(ppDisp);
		return E_FAIL;	// something wrong somewhere
	}

	return E_FAIL;	// unrecognized
}

STDMETHODIMP CBuildPackage::CreateTool(REFGUID rguidPersistenceSlot)
{
	m_guidPersistenceSlot = rguidPersistenceSlot;
	return (S_OK);
}

STDMETHODIMP CBuildPackage::ResetDefaults(PKGRESETFLAGS dwFlags)
{
	return(S_OK);
}

STDMETHODIMP CBuildPackage::GetPropertyPage(REFGUID rguidPage, VSPROPSHEETPAGE * ppage)
{
	CHECK_POINTER_NULL(ppage);

	int i = 0;
	HRESULT hr = E_FAIL;

	// Locate page in our list

	if (IsEqualGUID(GUID_ProjGeneralOptions, rguidPage))
	{
		ZeroMemory(ppage, sizeof(VSPROPSHEETPAGE));
		if (m_pBuildOptions)
			delete m_pBuildOptions;
		m_pBuildOptions = NULL;
		if (m_pProjectEngine)
		{
			CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = m_pProjectEngine;
			if (spProjEngineImpl)
			{
				{
					m_pBuildOptions = new CBuildOptions();
					RETURN_ON_NULL2(m_pBuildOptions, E_OUTOFMEMORY);
					_Module.AddCreateWndData(&(m_pBuildOptions->m_thunk.cd), m_pBuildOptions);

					// Set page specific info
					ppage->wTemplateId = IDDP_OPTIONS_BUILD;
					ppage->pfnDlgProc  = (DLGPROC)&CBuildOptions::StartDialogProc;
				    ppage->dwFlags = PSP_DEFAULT | PSP_USECALLBACK | PSP_HASHELP;
					hr = S_OK;
				}
			}
		}
	}
	else if (IsEqualGUID(GUID_ProjDirectories, rguidPage))
	{
		  ZeroMemory(ppage, sizeof(VSPROPSHEETPAGE));
		  if (m_pBuildDirectories)
			  delete m_pBuildDirectories;
		  m_pBuildDirectories = new CDirectoriesDlg;
		  RETURN_ON_NULL2(m_pBuildDirectories, E_OUTOFMEMORY);
		  _Module.AddCreateWndData(&(m_pBuildDirectories->m_thunk.cd), m_pBuildDirectories);
		  // Set page specific info
		  ppage->wTemplateId = IDDP_OPTIONS_DIRECTORIES;
		  ppage->pfnDlgProc  = (DLGPROC)&CDirectoriesDlg::StartDialogProc;
		  ppage->dwFlags = PSP_DEFAULT | PSP_USECALLBACK | PSP_HASHELP;

		  hr = S_OK;
	}

	if( hr == S_OK )
	{
		  // Set common info in struct
		  ppage->dwSize      = sizeof(VSPROPSHEETPAGE);
		  ppage->hInstance   = g_LocaleInfo.GetUIHostLib();
		  ppage->lParam      = 0;
		  ppage->pfnCallback = NULL;
		  ppage->pcRefParent = NULL;
	}

	// Was page in our list?
	return hr;
}

IVCNotificationSource* CBuildPackage::GetNotificationSource()
{
	if (m_pVCNotificationSource == NULL)
	{
		if (FAILED(ExternalQueryService(SID_SVCService, __uuidof(IVCNotificationSource), (void **)&m_pVCNotificationSource)))
			m_pVCNotificationSource = NULL;
	}
	return m_pVCNotificationSource;
}


STDMETHODIMP CBuildPackage::Initialize()
{
    HRESULT hr = CVCProjBuildEvents::CreateInstance(&m_pProjBuildEvents);
	if (SUCCEEDED(hr) && m_pProjBuildEvents)
	{
		// Do generic initialization here...
		if (m_dwProjectEngineEventsCookie == 0)
		{
			hr = VsLoaderCoCreateInstance<VCProjectEngine>(CLSID_VCProjectEngineObject, &m_pProjectEngine);
			VSASSERT(SUCCEEDED(hr) && m_pProjectEngine, "Failed to create project engine!  Not a whole lot we can do without *that*");
			if (SUCCEEDED(hr) && m_pProjectEngine)
			{
				CComQIPtr<IConnectionPointContainer> pCPContainer;
				CComPtr<IConnectionPoint> pCP;
				pCPContainer = m_pProjectEngine;
				VSASSERT(pCPContainer, "Project engine isn't a connection point container!");
				if (pCPContainer)
				{
					hr = pCPContainer->FindConnectionPoint(__uuidof(IVCProjectEngineEvents), &pCP);
					VSASSERT(SUCCEEDED(hr) && pCP, "Failed to find connection point for IVCProjectEngineEvents!");
					if (pCP)
					{
						hr = pCP->Advise((IVCProjectEngineEvents*)(m_pProjBuildEvents), &m_dwProjectEngineEventsCookie);
					}
				}
			}
		}
	}
	// Create our image list.All the images exist in the same bitmap
	if(m_hImageList == 0)
	{
		m_hImageList = ImageList_LoadBitmap(_Module.GetModuleInstance(), (LPCOLESTR)IDB_IMAGELIST, BITMAPIMAGE_X, 0, IMAGELISTMASKCOLOR);
		if(!m_hImageList)
		{
			ATLTRACE(_T("Image list creation failed!\n"));	
		}
		else
		{	// Set overlay images
			ImageList_SetOverlayImage(m_hImageList, BMP_LINKOVERLAY-1, 1);
			ImageList_SetOverlayImage(m_hImageList, BMP_NOTINSCCOVERLAY-1,2);
			ImageList_SetOverlayImage(m_hImageList, BMP_CHECKEDOUTOVERLAY-1,3);
		}
	}

	// Start our thread. It will do nothing if it is already started.
	//StartThreading();

	return hr;

}

STDMETHODIMP CBuildPackage::QueryService(THIS_ REFGUID rsid, REFIID iid, void ** ppvObj)
{
	CHECK_POINTER_NULL(ppvObj);
		
    HRESULT hr = E_NOINTERFACE;
	if (rsid == SID_SProjectEngine)
	{
		if (m_pProjectEngine)
			hr = m_pProjectEngine->QueryInterface(iid, ppvObj);
	}
	else if (rsid == SID_SENCBuildSpawner)
	{
		CComPtr<IVCBuildEngine> spBuildEngine;
		GetBuildEngine(&spBuildEngine);
		if (spBuildEngine)
			hr = spBuildEngine->QueryInterface(iid, ppvObj);
	}
	else if (rsid == SID_SBuildErrorContext)
	{
		CComPtr<IVCBuildErrorContext> spBuildErrorContext;
		hr = GetBuildErrorContext(&spBuildErrorContext);
		if (SUCCEEDED(hr))
			hr = spBuildErrorContext->QueryInterface(iid, ppvObj);
	}
	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsPersistSolutionOpts
//---------------------------------------------------------------------------

STDMETHODIMP CBuildPackage::SaveUserOptions(IVsSolutionPersistence *pPersistence)
{
	CHECK_READ_POINTER_NULL(pPersistence);

	CComPtr<IVsSolution> pVsSolution;
	HRESULT hr = GetIVsSolution(&pVsSolution);
	VSASSERT(SUCCEEDED(hr), "Failed to obtain service IVsSolution; make sure we're calling from the primary thread");
	RETURN_ON_FAIL_OR_NULL(hr, pVsSolution);

	// VC Projects
	CComPtr<IEnumHierarchies> pEnum;
	hr = pVsSolution->GetProjectEnum( EPF_ALLPROJECTS|EPF_MATCHTYPE, IID_IVCArchy, &pEnum );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	pEnum->Reset();
	while ( true )
	{
		CComQIPtr<IVsHierarchy> pHierarchy;

		hr = pEnum->Next(1, &pHierarchy, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		else if (pHierarchy == NULL)
			continue;

		CComVariant var;
		hr = pHierarchy->GetProperty(VSITEMID_ROOT, VSHPROPID_ProjectName, &var);
		wchar_t strName[32];
		wcsncpy( strName, var.bstrVal, 32 );
		strName[31] = NULL;

		CComQIPtr<IVsPersistSolutionOpts> pOpts = pHierarchy;
		if (pOpts == NULL)
			continue;
		hr = pPersistence->SavePackageUserOpts( pOpts, strName );
	}
	pEnum = NULL;

	// Exe projects
	hr = pVsSolution->GetProjectEnum( EPF_ALLPROJECTS|EPF_MATCHTYPE, IID_IExeHierarchy, &pEnum );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	pEnum->Reset();
	while ( true )
	{
		CComQIPtr<IVsHierarchy> pHierarchy;

		hr = pEnum->Next(1, &pHierarchy, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		else if (pHierarchy == NULL)
			continue;

		CComVariant var;
		hr = pHierarchy->GetProperty(VSITEMID_ROOT, VSHPROPID_ProjectName, &var);
		wchar_t strName[32];
		wcsncpy( strName, var.bstrVal, 32 );
		strName[31] = NULL;

		CComQIPtr<IVsPersistSolutionOpts> pOpts = pHierarchy;
		if (pOpts == NULL)
			continue;

		hr = pPersistence->SavePackageUserOpts( pOpts, strName);
	}
	pEnum = NULL;

	// crash dump projects
	hr = pVsSolution->GetProjectEnum( EPF_ALLPROJECTS|EPF_MATCHTYPE, IID_ICrashDumpHierarchy, &pEnum );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	pEnum->Reset();
	while ( true )
	{
		CComQIPtr<IVsHierarchy> pHierarchy;

		hr = pEnum->Next(1, &pHierarchy, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		else if (pHierarchy == NULL)
			continue;

		CComVariant var;
		hr = pHierarchy->GetProperty(VSITEMID_ROOT, VSHPROPID_ProjectName, &var);
		wchar_t strName[32];
		wcsncpy( strName, var.bstrVal, 32 );
		strName[31] = NULL;

		CComQIPtr<IVsPersistSolutionOpts> pOpts = pHierarchy;
		if (pOpts == NULL)
			continue;
		hr = pPersistence->SavePackageUserOpts( pOpts, strName );
	}

	return S_OK;
}

STDMETHODIMP CBuildPackage::LoadUserOptions(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts)
{
	CHECK_READ_POINTER_NULL(pPersistence);

	CComPtr<IVsSolution> pVsSolution;
	HRESULT hr = GetIVsSolution(&pVsSolution);
	VSASSERT(SUCCEEDED(hr), "Failed to obtain service IVsSolution; make sure we're calling from the primary thread");
	RETURN_ON_FAIL2(hr, S_OK);

	// VC Projects
	CComPtr<IEnumHierarchies> pEnum;
	hr = pVsSolution->GetProjectEnum( EPF_ALLPROJECTS|EPF_MATCHTYPE, IID_IVCArchy, &pEnum );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	pEnum->Reset();
	while ( true )
	{
		CComQIPtr<IVsHierarchy> pHierarchy;

		hr = pEnum->Next(1, &pHierarchy, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		else if (pHierarchy == NULL)
			continue;

		CComVariant var;
		hr = pHierarchy->GetProperty(VSITEMID_ROOT, VSHPROPID_ProjectName, &var);
		wchar_t strName[32];
		wcsncpy( strName, var.bstrVal, 32 );
		strName[31] = NULL;

		CComQIPtr<IVsPersistSolutionOpts> pOpts = pHierarchy;
		if (pOpts == NULL)
			continue;
		hr = pPersistence->LoadPackageUserOpts( pOpts, strName );
	}
	pEnum = NULL;

	// Exe projects
	hr = pVsSolution->GetProjectEnum( EPF_ALLPROJECTS|EPF_MATCHTYPE, IID_IExeHierarchy, &pEnum );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	pEnum->Reset();
	while ( true )
	{
		CComQIPtr<IVsHierarchy> pHierarchy;

		hr = pEnum->Next(1, &pHierarchy, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		else if (pHierarchy == NULL)
			continue;

		CComVariant var;
		hr = pHierarchy->GetProperty(VSITEMID_ROOT, VSHPROPID_ProjectName, &var);

		wchar_t strName[32];
		wcsncpy( strName, var.bstrVal, 32 );
		strName[31] = NULL;

		CComQIPtr<IVsPersistSolutionOpts> pOpts = pHierarchy;
		if (pOpts == NULL)
			continue;
		hr = pPersistence->LoadPackageUserOpts( pOpts, strName );
	}
	pEnum = NULL;

	// crash dump projects
	hr = pVsSolution->GetProjectEnum( EPF_ALLPROJECTS|EPF_MATCHTYPE, IID_ICrashDumpHierarchy, &pEnum );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	pEnum->Reset();
	while ( true )
	{
		CComQIPtr<IVsHierarchy> pHierarchy;

		hr = pEnum->Next(1, &pHierarchy, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		else if (pHierarchy == NULL)
			continue;

		CComVariant var;
		hr = pHierarchy->GetProperty(VSITEMID_ROOT, VSHPROPID_ProjectName, &var);

		wchar_t strName[32];
		wcsncpy( strName, var.bstrVal, 32 );
		strName[31] = NULL;

		CComQIPtr<IVsPersistSolutionOpts> pOpts = pHierarchy;
		if (pOpts == NULL)
			continue;
		hr = pPersistence->LoadPackageUserOpts( pOpts, strName);
	}

	return S_OK;
}

STDMETHODIMP CBuildPackage::WriteUserOptions(IStream *pOptionsStream, LPCOLESTR pszKey)
{
	return E_NOTIMPL;	// CBuildPackage::WriteUserOptions
}

STDMETHODIMP CBuildPackage::ReadUserOptions(IStream *pOptionsStream, LPCOLESTR pszKey)
{
	return E_NOTIMPL;	// CBuildPackage::ReadUserOptions
}


void CBuildPackage::InitializeArchy(BSTR bstrFilename, CVCProjectNode* pProj, CVCArchy* pVCArchy)
{
	CStringW strFilename = bstrFilename;
	WCHAR drive[_MAX_DRIVE];
	WCHAR dir[_MAX_DIR];
	WCHAR fname[_MAX_FNAME];
	WCHAR ext[_MAX_EXT];
	_wsplitpath( (const wchar_t *) strFilename, drive, dir, fname, ext);

	CComBSTR bstrFileName = fname;

	if (pVCArchy)
		pVCArchy->SetImageList(GetBuildPkg()->m_hImageList);
	if (pProj)
		pProj->SetArchy(pVCArchy);		// Archy per project
	if (pVCArchy)
		pVCArchy->SetRootNode(pProj);
	// don't set the caption until the archy is initialized
	if (pProj)
		pProj->SetCaption(bstrFilename);
}

VCProjectEngine* CBuildPackage::GetProjectEngine()	// not ref-counted
{
	VSASSERT(m_pProjectEngine, "Project engine not initialized!");
	return m_pProjectEngine;
}

HRESULT CBuildPackage::GetBuildEngine(IVCBuildEngine** ppBuildEngine)
{
	CHECK_POINTER_NULL(ppBuildEngine);
	*ppBuildEngine = NULL;
	if (m_pProjectEngine == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComPtr<IDispatch> pDispEngine;
	CComQIPtr <IVCProjectEngineImpl> pProjectEngineImpl;
	pProjectEngineImpl = m_pProjectEngine;
	pProjectEngineImpl->get_BuildEngine(&pDispEngine);
	CComQIPtr<IVCBuildEngine> spBuildEngine =  pDispEngine;
	*ppBuildEngine = spBuildEngine.Detach();
	return (*ppBuildEngine == NULL ? S_FALSE : S_OK);
}

IDispatch* CBuildPackage::GetAutoProjects()
{
	if (m_spAutoProjects == NULL && m_pProjectEngine != NULL)
	{
		CComPtr<IDispatch> spProjects;
		m_pProjectEngine->get_Projects(&spProjects);
		VSASSERT(spProjects != NULL, "Failed to get projects collection from the project engine!");
		if (spProjects != NULL)
		{
			CAutoProjects* pAutoProjects = NULL;
			CAutoProjects::CreateInstance(&pAutoProjects, spProjects);
			m_spAutoProjects = pAutoProjects;
			if (pAutoProjects != NULL)
				pAutoProjects->Release();
		}
	}
	return m_spAutoProjects;
}

STDMETHODIMP CBuildPackage::get_OfficialName(BSTR *pbstrName) 
{
	CComBSTR bstrString;
	if (!bstrString.LoadString(IDS_PROD_NAME))
	{
		*pbstrName = NULL;
		return E_OUTOFMEMORY;
	}
	*pbstrName = bstrString.Detach();
	return S_OK;
}

STDMETHODIMP CBuildPackage::get_ProductDetails(BSTR *pbstrProductDetails)
{
	CComBSTR bstrString;
	if (!bstrString.LoadString(IDS_PROD_DESC))
	{
		*pbstrProductDetails = NULL;
		return E_OUTOFMEMORY;
	}

	DWORD nType = REG_SZ;
	DWORD nSize = MAX_PATH;
 	HKEY hSectionKey = NULL;

	// REVIEW: Should use Alternate registry root !
	LONG lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\VisualStudio\\7.0\\Setup\\VC", 0, KEY_READ, &hSectionKey );
	if( hSectionKey )
	{
		wchar_t szVersion[MAX_PATH+1] = {0};
		lRet = RegQueryValueExW( hSectionKey, L"Version", NULL, &nType, (LPBYTE)szVersion, &nSize );
		bstrString.Append( szVersion );
		RegCloseKey( hSectionKey );
	}

	*pbstrProductDetails = bstrString.Detach();
	return S_OK;
} 


/////////////////////////////////////////////////////////////////////////////
// CVCProjectFactory

CVCProjectFactory::CVCProjectFactory(void)
{
}

CVCProjectFactory::~CVCProjectFactory(void)
{
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
STDMETHODIMP CVCProjectFactory::CanCreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ DWORD grfCreateProj,
            /* [out] */ BOOL *pfCanCreate)
{
	CHECK_POINTER_NULL(pfCanCreate);

	*pfCanCreate = TRUE;

	// if we're running a command line build, we cannot convert projects!
	if( !FIsIDEInteractive() )
	{
		CStringW strExt;
		CStringW strFilename = pszFilename;
		int pos = strFilename.ReverseFind( L'.' );
		if( pos != -1 )
			strExt = strFilename.Right( strFilename.GetLength() - pos );
		if( strExt.IsEmpty() || _wcsicmp( strExt, L".vcproj" ) != 0 )
		{
			*pfCanCreate = FALSE;
			
			// REVIEW !!!! This must be localized, and the information should be routed through the output window !
			// FIX ME !!!!
			wprintf( L"\nError: The specified project must be converted before it can be built.\n" );

			// CComQIPtr<IVsOutputWindowPane> pPane;
			// IUnknown* pUnkPane = NULL;
			// pPane->OutputTaskItemStringEx(bstrFullMessage, TP_HIGH, CAT_BUILDCOMPILE, L"", BMP_COMPILE, bstrFile, nLine-1, bstrMessage, bstrHelpKeyword);
		}
	}
	
	return S_OK;
}
        
STDMETHODIMP CVCProjectFactory::CreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled)
{
	// helper object to track "in project load" status
	CInProjectLoadHelper inProjLoad;

	// load the project normally
	HRESULT hr = InitializeForOwner( pszFilename, pszLocation, pszName, grfCreateProj, riid, NULL, ppUnk, pfCanceled );
	if (FAILED(hr))
	{
		if (hr != E_FAIL)
			hr = E_ABORT;
		return hr;
	}

	// look for the VSEF OwnerKey property on the project
	// ppUnk now has the address of a ptr to the hierarchy (which we know to
	// be a VCArchy)
	CComQIPtr<IVsHierarchy> pHier = (IUnknown*)*ppUnk;
	RETURN_ON_NULL2(pHier, E_NOINTERFACE);
	CVCArchy *pArchy = (CVCArchy*)pHier.p;
	CComPtr<VCProject> pProj;
	pArchy->GetVCProject( NULL, &pProj );
	RETURN_ON_NULL(pProj);
	CComBSTR bstrOwnerKey;
	pProj->get_OwnerKey( &bstrOwnerKey );

	// if we have an OwnerKey, we have to dump the project and let it be
	// re-loaded by the owner
	if( bstrOwnerKey.Length() != 0 )
	{
		if (*ppUnk)
		{
			((IUnknown*)(*ppUnk))->Release();
			*ppUnk = NULL;
		}
		// delete & clean up the loaded project
		CComQIPtr<IDispatch> pDisp = pProj;
		VSASSERT( pDisp, "Failed to get IDispatch from VCProject! How did this happen?!" );
		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pBuildPackage->GetProjectEngine();
		if (spProjEngineImpl)
			spProjEngineImpl->RemoveProjectUnderShell( pDisp );
		// get the owner key (guid string)
		CString strKey = bstrOwnerKey;
		CComPtr<IVsProjectFactory> pOwnerPF;

        CLSID guidOwnerProject;
		hr = CLSIDFromString( bstrOwnerKey, &guidOwnerProject );
		RETURN_ON_FAIL(hr);
		CComPtr<IVsSolution> spSolution;
		GetBuildPkg()->GetIVsSolution( &spSolution );
		hr = spSolution->GetProjectFactory( 0, &guidOwnerProject, pszFilename, &pOwnerPF );
		RETURN_ON_FAIL_OR_NULL(hr, pOwnerPF);
		return pOwnerPF->CreateProject( pszFilename, pszLocation, pszName, grfCreateProj, riid, ppUnk, pfCanceled );
	}
	else
		return hr;
}

//---------------------------------------------------------------------------
// interface: IVsOwnedProjectFactory
//---------------------------------------------------------------------------
STDMETHODIMP CVCProjectFactory::PreCreateForOwner( 
            /*[in]*/  IUnknown              *pUnkOwner,
            /*[out]*/ IUnknown              **pppUnkInner,
            /*[out]*/ VSOWNEDPROJECTOBJECT  *pCookie )
{
    //
    // create an Aggregated version of CVsProjHierarchy
    //
    CComPolyObject<CVCArchy> *pAggHier;
    
    HRESULT hr = CComPolyObject<CVCArchy>::CreateInstance( pUnkOwner, &pAggHier);
	RETURN_ON_FAIL_OR_NULL2(hr, pAggHier, E_OUTOFMEMORY);

	CVCArchy *pHier;  // created with Ref count 0

	// assign pWebHier to the inner object
	pHier = &(pAggHier->m_contained);
	RETURN_ON_NULL(pHier);
	pHier->AddRef(); // addref to keep alive - don't forget to release this ref in Initialize for owner

	// get the inner IUnknown
	if( SUCCEEDED( hr = pAggHier->QueryInterface( IID_IUnknown, (void**)pppUnkInner ) ) )
		*pCookie = (VSOWNEDPROJECTOBJECT)(pHier);
	else
		// destroy the pAggHier (balances AddRef above)
		pHier->Release();

    return hr;
}

STDMETHODIMP CVCProjectFactory::InitializeForOwner( 
            /*[in]*/ LPCOLESTR                  pszFilename,
            /*[in]*/ LPCOLESTR                  pszLocation,
            /*[in]*/ LPCOLESTR                  pszName,
            /*[in]*/ VSCREATEPROJFLAGS          grfCreateProj,
            /*[in]*/ REFIID                     riid,
            /*[in]*/ VSOWNEDPROJECTOBJECT       cookie, // additional parameter
            /*[out, iid_is(iidProject)]*/void  **ppUnk,
            /*[out]*/ BOOL                      *pfCanceled)
{
	HRESULT hr = E_FAIL;
	DWORD startTime, endTime;
	VARIANT_BOOL bLog = VARIANT_FALSE;
	CComPtr<IDispatch> pDispProject;
	bool bConverted = false;

	// Enterprise frameworks VCArchy could have been created in PreCreateForOwner.
	s_EFPolicyCookie = cookie;

	CDirW dirTo;
	CDirW dirFrom;

	if (ppUnk != NULL && pfCanceled != NULL)
	{
		*ppUnk = NULL;
		*pfCanceled = FALSE;
		CComBSTR bstrFileName;

		// WARNING ! Although this looks like it is doing nothing, it actually initializes the Wizards package so 
		// that someone SetSite's them.  It also needs to go BEFORE the first project gets loaded or our conversion
		// DLL can't get CoCreate'd.  Go figure.
		// DO NOT REMOVE without asking DaveWa
		if( FIsIDEInteractive() )
		{
			CComPtr<IVsPackage> pUnk;
			hr = ExternalQueryService(SID_SVCService, __uuidof(IVsPackage), (void**)&pUnk);
		}
		// END DO NOT REMOVE

		if(grfCreateProj & CPF_CLONEFILE) // New project
		{
			CPathW pathTo;
			CPathW pathFrom;

			CStringW strTo = pszLocation;
			BOOL bOK = dirTo.CreateFromString(strTo, TRUE);
			VSASSERT(bOK, "Failed create destination directory path!");

			CStringW strName = pszName;
			bOK = pathTo.CreateFromDirAndRelative(dirTo, strName);
			VSASSERT(bOK, "Failed to create destination project file path!");

			// REVIEW: LOGO BUG -- foo.bar should become foo.bar.vcproj instead of foo.vcproj...
			pathTo.ChangeExtension(L".vcproj");
			CComBSTR bstrTo = pathTo;

			CStringW strFrom = pszFilename;
			pathFrom.Create(strFrom);
			dirFrom.CreateFromPath(pathFrom);
			
			if( !dirTo.CreateOnDisk() || !CopyFileW( pathFrom, pathTo, FALSE) || !SetFileAttributesW( pathTo, FILE_ATTRIBUTE_NORMAL) )
				*pfCanceled = TRUE;
			if( *pfCanceled )
			{
				// report error
				LPVOID lpErrMsg;
				FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(), 0, (LPTSTR)&lpErrMsg, 0, NULL );
				ReportError( CComBSTR( (LPTSTR)lpErrMsg ), E_ACCESSDENIED );
				LocalFree( lpErrMsg );
				return E_ACCESSDENIED;
			}
			
			bstrFileName = bstrTo;
		}
		else  // Open existing project
		{
			// see if it is a conversion project...
			CStringW strFile = pszFilename;
			CPathW path;
			path.Create(strFile);
			CComBSTR bstrShortFile = path.GetFileName();
			bstrFileName = pszFilename;

			CStringW strExt = strFile.Right(7);
			strExt.MakeLower();
			if( strExt != L".vcproj" )
			{
				bConverted = true;

				if ( CConvertDlg::s_bConvertNone == TRUE )
				{
					*pfCanceled = TRUE;
					return S_OK;
				}
				else if ( CConvertDlg::s_bConvertAll == FALSE )
				{
					CComPtr<IVsUIShell> pUIShell = NULL;
					HWND hwnd;
					HRESULT hr;
					hr = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
					if (SUCCEEDED(hr) && pUIShell)
					{
						pUIShell->SetForegroundWindow();
						hr = pUIShell->GetDialogOwnerHwnd(&hwnd);
						hr = pUIShell->EnableModeless(FALSE);
						CConvertDlg cvtDlg(bstrShortFile);
						INT_PTR result = cvtDlg.DoModal(hwnd);
						hr = pUIShell->EnableModeless(TRUE);
						if( CConvertDlg::s_bCancel == TRUE )
						{
							*pfCanceled = TRUE;
							return S_OK;
						}
					}
				}
			}

			// if we're doing performance logging
			GetBuildPkg()->GetProjectEngine()->get_PerformanceLogging( &bLog );
			if( bLog == VARIANT_TRUE )
			{
				// start time
				startTime = GetTickCount();
				fprintf( stdout, "Project Load start: %d\n", startTime );
			}

		}

		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = GetBuildPkg()->m_pProjectEngine;
		if (spProjEngineImpl == NULL)
		{
			*pfCanceled = TRUE;
			return E_FAIL;
		}
		hr = spProjEngineImpl->LoadProjectUnderShell(bstrFileName, &pDispProject);
		// if we can't load the project file, bail
		if( FAILED( hr ) )
		{
			CStringW strFileName = bstrFileName;
			CStringW strMessage;
			strMessage.Format(IDS_WARN_PRJOPEN_FAILED, strFileName);
			CComBSTR bstrMessage = strMessage;
			ReportError( bstrMessage, hr );

			*pfCanceled = TRUE;
			if (hr != E_FAIL)
				hr = E_ABORT;
			return hr;
		}
		// if we were given a name, we need to set the correct name of the project
		if( pszName )
		{
			CComQIPtr<VCProject> pProject = pDispProject;
			VSASSERT( pProject, "Failed to get VCProject object back from LoadProject!" );
			RETURN_ON_NULL(pProject);
			// strip the file extension off the name
			CStringW strName = pszName;
			int idx = strName.ReverseFind( L'.' );
			if( idx != -1 )
				strName = strName.Left( idx );
			pProject->put_Name( CComBSTR( strName ) );
		}
	
		if (SUCCEEDED(hr) && pDispProject)
		{
			// if we were converted, and we don't have a "root node" string yet,
			// get the name and set our global "root node" place holder string
			if( bConverted && !g_wszRootProjectName )
			{
				CComBSTR bstrName;
				CComQIPtr<VCProject> pProject = pDispProject;
				if( pProject )
				{
					pProject->get_Name( &bstrName );
					g_wszRootProjectName = new wchar_t[bstrName.Length() + 1];
					memset( g_wszRootProjectName, 0, (bstrName.Length() + 1) * sizeof(wchar_t) );
					wcscpy( g_wszRootProjectName, bstrName );
				}
			}

			// get the IDispatch of the project and add all elements of that project to the UI.
			CComQIPtr<IVCExternalCookie> pExCookie = pDispProject;
			if (pExCookie)
			{
				void* pCookie;
				hr = pExCookie->get_ExternalCookie(&pCookie);
				CVCProjectNode *pProjNode = (CVCProjectNode *)pCookie;
				CComPtr<IVsHierarchy> spHier;
				if (pProjNode != NULL)
					pProjNode->GetVsHierarchy(&spHier, TRUE);
				*ppUnk = NULL;
				RETURN_ON_NULL(spHier);
				hr = spHier->QueryInterface(riid, ppUnk);
				if (FAILED(hr))
				{
					*ppUnk = NULL;
					return hr;
				}
// 				IVsHierarchy* pHier = spHier;
// 				if (pHier && !cookie )
// 					pHier->Release(); // yep, we're now down one ref when we leave here.  that's OK and necessary.
				// if we're a nested hierarchy
				if( cookie ) 					
				{
					IUnknown *pUnk = NULL;
					if( SUCCEEDED( spHier->QueryInterface( IID_IUnknown, (void**)&pUnk ) ) && pUnk )
					{
						pUnk->Release();	// release the AddRef from the QI
						pUnk->Release();	// release the EXACT interface that was addref'd in PreCreateForOwner (the controlling Unknown)
					}
				}
				else
				{
					IVsHierarchy *pHier = spHier;
					if( pHier )
						pHier->Release(); // yep, we're now down one ref when we leave here.  that's OK and necessary.
				}
					
				hr = S_OK;
			}
		}
	}

	if( *ppUnk == NULL )
		hr = E_FAIL;
	if(grfCreateProj & CPF_CLONEFILE)
	{
		// Now do the stupid things of trying to copy template files.

		CComQIPtr<VCProject> pProj = pDispProject;
		CComPtr<IDispatch> pDispFiles;
		pProj->get_Files(&pDispFiles);
		CComQIPtr<IVCCollection> pCollection; 
		pCollection = pDispFiles;
		CComPtr<IEnumVARIANT>		pEnum;
		HRESULT hrT;
		hrT = pCollection->_NewEnum( (IUnknown **)( &pEnum ) );
		if (SUCCEEDED(hrT) && pEnum)
		{
			pEnum->Reset();
			while ( true )
			{
				CComVariant var;
				CComQIPtr<VCFile> pFile;
				
				hrT = pEnum->Next(1, &var, NULL);
				if( FAILED(hrT) ) break;
				else if( hrT == S_FALSE ) break;

				pFile = var.punkVal;
				if (!pFile)
					continue;

				// copy it from where it might have been to where it should be
				CPathW pathFrom;
				CPathW pathTo;

				CComBSTR bstrRelative;
				hrT = pFile->get_RelativePath( &bstrRelative );
				CStringW strRel = bstrRelative;
	
				pathFrom.CreateFromDirAndRelative(dirFrom, strRel);
				pathTo.CreateFromDirAndRelative(dirTo, strRel);
				CDirW dirTo;
				if (dirTo.CreateFromPath(pathTo))
					dirTo.CreateOnDisk();	// don't care about error conditions; CopyFileW will take care of that
	
				if( !CopyFileW( pathFrom, pathTo, FALSE) || !SetFileAttributesW( pathTo, FILE_ATTRIBUTE_NORMAL) )
					*pfCanceled = TRUE;
				if( *pfCanceled )
				{
					// report error
					LPVOID lpErrMsg;
					FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, GetLastError(), 0, (LPTSTR)&lpErrMsg, 0, NULL );
					ReportError( CComBSTR( (LPTSTR)lpErrMsg ), E_ACCESSDENIED );
					LocalFree( lpErrMsg );
					return E_ACCESSDENIED;
				}
			}
		}
	}
	else
	{
		// if we're doing performance logging
		if( bLog == VARIANT_TRUE )
		{
			// start time
			endTime = GetTickCount();
			fprintf( stdout, "Project Load end: %d\n", endTime );
		}
	}

	
	
	if( FAILED(hr) )
	{
		CComBSTR bstrMessage;
		bstrMessage.LoadString(IDS_WARN_PRJOPEN_FAILED);
		ReportError( bstrMessage, hr );

		*pfCanceled = TRUE;
		if (hr != E_FAIL)
			hr = E_ABORT;
		return hr;
	}
	// BBT End
	ENDBOOT_projbld();

	return hr;
}

STDMETHODIMP CVCProjectFactory::SetSite( /* [in] */ IServiceProvider *pSP)
{
	m_srpIServiceProvider.Release();
	if (NULL != pSP)
	{
		pSP->AddRef();
		m_srpIServiceProvider = pSP;
	}
	return S_OK;
}

STDMETHODIMP CVCProjectFactory::Close(void)
{
	VSASSERT(m_srpIServiceProvider != NULL, "Service provider not set on CVCProjectFactory!");
	m_srpIServiceProvider.Release();
	return S_OK;
}

CVCProjectNode* CBuildPackage::GetProjectNode(VCProject* pProject)
{
	RETURN_ON_NULL2(pProject, NULL);
	
	CComQIPtr<IVCExternalCookie> spExtCookie = pProject;
	RETURN_ON_NULL2(spExtCookie, NULL);

	void* pCookie;
	spExtCookie->get_ExternalCookie(&pCookie);
	return (CVCProjectNode*)pCookie;
}

HRESULT CBuildPackage::GetProjectNodeForProjConfig(VCConfiguration* pProjCfg, CVCProjectNode** ppProjNode)
{
	CHECK_POINTER_NULL(ppProjNode);
	CHECK_READ_POINTER_NULL(pProjCfg);

	CComPtr<IDispatch> spDispProject;
	pProjCfg->get_Project(&spDispProject);
	CComQIPtr<VCProject> spProject = spDispProject;
	VSASSERT(spProject != NULL, "Project config doesn't have a project!  Is it zombie?");
	CHECK_ZOMBIE(spProject, IDS_ERR_PROJ_ZOMBIE);

	*ppProjNode = GetProjectNode(spProject);
	CHECK_ZOMBIE(*ppProjNode, IDS_ERR_PROJ_ZOMBIE);
	return S_OK;
}

HRESULT CBuildPackage::GetArchyForProjConfig(VCConfiguration* pProjCfg, CVCArchy** ppArchy)
{
	CHECK_POINTER_NULL(ppArchy);
	CHECK_READ_POINTER_NULL(pProjCfg);
	*ppArchy = NULL;

	CVCProjectNode* pProjNode = NULL;
	HRESULT hr = GetProjectNodeForProjConfig(pProjCfg, &pProjNode);
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(pProjNode, IDS_ERR_PROJ_ZOMBIE);

	*ppArchy = pProjNode->GetArchy();
	CHECK_ZOMBIE(*ppArchy, IDS_ERR_PROJ_ZOMBIE);

	return S_OK;
}

HRESULT CBuildPackage::GetHierarchyForProjConfig(VCConfiguration* pProjCfg, IVsHierarchy** ppHier, BOOL bInMainThread /* = FALSE */)
{
	CHECK_POINTER_NULL(ppHier);
	*ppHier = NULL;

	CVCProjectNode* pProjNode = NULL;
	HRESULT hr = GetProjectNodeForProjConfig(pProjCfg, &pProjNode);
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(pProjNode, IDS_ERR_PROJ_ZOMBIE);

	return pProjNode->GetVsHierarchy(ppHier, bInMainThread);
}

void CBuildPackage::AddSolutionRef()
{
	CComPtr<IVsSolution> spSolution;
	GetIVsSolution(&spSolution);
	m_nSolutionRefCount++;
}

HRESULT CBuildPackage::GetIVsSolution(IVsSolution** ppSolution)	// intended for main thread use only
{
	CHECK_POINTER_NULL(ppSolution);
	if (!m_marshalVsSolution.IsInit())
	{
		CComPtr<IVsSolution> pVsSolution;
		HRESULT hr = ExternalQueryService(__uuidof(IVsSolution), __uuidof(IVsSolution), (void **)&pVsSolution);
		VSASSERT(SUCCEEDED(hr), "Failed to obtain service IVsSolution; make sure we're calling from the primary thread");
		if (SUCCEEDED(hr))
			m_marshalVsSolution.Init((IVsSolution *)pVsSolution);
	}
	return m_marshalVsSolution.GetPtr(ppSolution);
}

void CBuildPackage::ReleaseSolutionRef()
{
	m_nSolutionRefCount--;
	if (m_nSolutionRefCount == 0)
		m_marshalVsSolution.Clear();
	VSASSERT(m_nSolutionRefCount >= 0, "Negative refcount spells trouble...");
}

HRESULT CBuildPackage::GetSolutionBuildManager(IVsSolutionBuildManager** ppSolnBldMgr, BOOL bInMainThread /* = FALSE */)
{
	CHECK_POINTER_NULL(ppSolnBldMgr);
	HRESULT hr = S_OK;
	if (m_spSolutionBuildManager == NULL && bInMainThread)
	{
		hr = ExternalQueryService(SID_SVsSolutionBuildManager, __uuidof(IVsSolutionBuildManager), 
			(void **)&m_spSolutionBuildManager);
		m_marshalSolutionBuildManager.Init(m_spSolutionBuildManager);
	}
	RETURN_ON_FAIL(hr);
	if (bInMainThread)
		return m_spSolutionBuildManager.CopyTo(ppSolnBldMgr);
	RETURN_ON_NULL(m_spSolutionBuildManager);
	
	hr = m_marshalSolutionBuildManager.UnmarshalPtr(ppSolnBldMgr); 
	RETURN_ON_FAIL_OR_NULL(hr, *ppSolnBldMgr);

	return hr;
}

HRESULT CBuildPackage::GetVsUIShell(IVsUIShell** ppShell, BOOL bInMainThread /* = FALSE */)
{
	CHECK_POINTER_NULL(ppShell);
	HRESULT hr = S_OK;
	if (m_spVsUIShell == NULL && bInMainThread)
	{
		hr = ExternalQueryService(SID_SVsUIShell, __uuidof(IVsUIShell), (void **)&m_spVsUIShell);
		m_marshalVsUIShell.Init(m_spVsUIShell);
	}
	RETURN_ON_FAIL(hr);
	if (bInMainThread)
		return m_spVsUIShell.CopyTo(ppShell);
	RETURN_ON_NULL(m_spVsUIShell);

	hr = m_marshalVsUIShell.UnmarshalPtr(ppShell); 
	RETURN_ON_FAIL_OR_NULL(hr, *ppShell);

	return hr;
}

HRESULT CBuildPackage::GetTaskList(IVsTaskList** ppTaskList, BOOL bInMainThread /* = FALSE */)
{
	CHECK_POINTER_NULL(ppTaskList);
	HRESULT hr = S_OK;
	if (m_pTaskList == NULL && bInMainThread)
	{
		hr = ExternalQueryService(SID_SVsTaskList, __uuidof(IVsTaskList), (void **)&m_pTaskList);
		m_marshalTaskList.Init(m_pTaskList);
	}
	RETURN_ON_FAIL(hr);
	if (bInMainThread)
		return m_pTaskList.CopyTo(ppTaskList);
	RETURN_ON_NULL(m_pTaskList);

	hr = m_marshalTaskList.UnmarshalPtr(ppTaskList); 
	RETURN_ON_FAIL_OR_NULL(hr, *ppTaskList);

	return hr;
}

STDMETHODIMP CBuildPackage::HasConfigurationDependencies(VCConfiguration* pProjCfg, VARIANT_BOOL* pbHasDeps)
{
	CHECK_POINTER_NULL(pbHasDeps);
	*pbHasDeps = VARIANT_FALSE;

	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = GetHierarchyForProjConfig(pProjCfg, &spHier);
	RETURN_ON_FAIL_OR_NULL(hr, spHier);

	CComPtr<IVsSolutionBuildManager> spSolnBldMgr;
	hr = GetSolutionBuildManager(&spSolnBldMgr);
	RETURN_ON_FAIL(hr);
	if (spSolnBldMgr == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	ULONG ulActual;
	hr = spSolnBldMgr->GetProjectDependencies(spHier, 0, NULL, &ulActual);
	RETURN_ON_FAIL(hr);

	if (ulActual != 0)
		*pbHasDeps = VARIANT_TRUE;

	return S_OK;
}

STDMETHODIMP CBuildPackage::GetConfigurationDependencies(VCConfiguration* pProjCfg, 
	IVCBuildOutputItems** ppBuildOutputs)
{
	CHECK_POINTER_NULL(ppBuildOutputs);
	*ppBuildOutputs = NULL;
	CHECK_READ_POINTER_NULL(pProjCfg);

	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = GetHierarchyForProjConfig(pProjCfg, &spHier);
	RETURN_ON_FAIL_OR_NULL(hr, spHier);

	CComPtr<IVsSolutionBuildManager> spSolnBldMgr;
	hr = GetSolutionBuildManager(&spSolnBldMgr);
	RETURN_ON_FAIL(hr);
	if (spSolnBldMgr == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	ULONG ulActual;
	hr = spSolnBldMgr->GetProjectDependencies(spHier, 0, NULL, &ulActual);
	RETURN_ON_FAIL(hr);

	if (ulActual == 0)
		return S_OK;

	IVsHierarchy** rgpIVsHierarchy = (IVsHierarchy**) ::CoTaskMemAlloc(ulActual * sizeof(IVsHierarchy *));
	memset(rgpIVsHierarchy, 0, sizeof(IVsHierarchy*)*ulActual);
	RETURN_ON_NULL2(rgpIVsHierarchy, E_OUTOFMEMORY);

	ULONG ulActual2;
	hr = spSolnBldMgr->GetProjectDependencies(spHier, ulActual, rgpIVsHierarchy, &ulActual2);
	VSASSERT(ulActual == ulActual2, "Mismatch in number of dependencies based on whether we're just looking for the number or trying to get them!");
	VSASSERT(SUCCEEDED(hr), "Got the number without getting any?!?");
	if (SUCCEEDED(hr))
	{
		CVCBuildOutputItems* pOutputItemsObj = NULL;
		CVCBuildOutputItems::CreateInstance(&pOutputItemsObj);
		if (pOutputItemsObj != NULL)
		{
			for (ULONG idx = 0; idx < ulActual2; idx++)
			{
				CComPtr<IVsHierarchy> pVsArchy = rgpIVsHierarchy[idx];
				if (pVsArchy == NULL)
					continue;

				CComPtr<IVsProjectCfg> spVsProjCfg;
				HRESULT hr2 = spSolnBldMgr->FindActiveProjectCfg(NULL, NULL, pVsArchy, &spVsProjCfg);
				if (FAILED(hr2) || spVsProjCfg == NULL)
					continue;

				CComPtr<IVsEnumOutputs> spEnumOutputs;
				hr2 = spVsProjCfg->EnumOutputs(&spEnumOutputs);
				if (FAILED(hr2) || spEnumOutputs == NULL)
					continue;
				spEnumOutputs->Reset();

				while (TRUE)
				{
					CComPtr<IVsOutput> spOutput;
					ULONG ulRet = 0;
					hr2 = spEnumOutputs->Next(1, &spOutput, &ulRet);
					if (hr2 != S_OK || spOutput == NULL)
						break;
					pOutputItemsObj->Add(spOutput);
				}
			}
			*ppBuildOutputs = pOutputItemsObj;	// gets the ref from CreateInstance above...
		}
	}
	
	::CoTaskMemFree(rgpIVsHierarchy);
	return S_OK;
}

STDMETHODIMP CBuildPackage::GetUIConfigurationForVCConfiguration(VCConfiguration* pProjCfg, 
	IVCGenericConfiguration** ppGenCfg)
{
	CHECK_POINTER_NULL(ppGenCfg);
	CHECK_READ_POINTER_NULL(pProjCfg);

	CVCArchy* pArchy;
	HRESULT hr = GetArchyForProjConfig(pProjCfg, &pArchy);
	RETURN_ON_FAIL_OR_NULL(hr, pArchy);

	return pArchy->CreateGenCfg(pProjCfg, ppGenCfg);
}

STDMETHODIMP CBuildPackage::get_SolutionFile(BSTR* pbstrSolnFile)
{
	CHECK_POINTER_NULL(pbstrSolnFile);
	return m_bstrSolutionFile.CopyTo(pbstrSolnFile);
}

STDMETHODIMP CBuildPackage::SaveProject(VCProject* pProject, LPCOLESTR szFileName)
{
	// any failure return from here will cause the project engine to go ahead and save its way, anyway
	CVCProjectNode* pProjNode = GetProjectNode(pProject);
	CHECK_ZOMBIE(pProjNode, IDS_ERR_PROJ_ZOMBIE);

	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = pProjNode->GetVsHierarchy(&spHier, TRUE);
	RETURN_ON_FAIL_OR_NULL(hr, spHier);

	CComPtr<IVsRunningDocumentTable> spDocTable;
	hr = ExternalQueryService(SID_SVsRunningDocumentTable, __uuidof(IVsRunningDocumentTable), (void **)&spDocTable);
	RETURN_ON_FAIL_OR_NULL(hr, spDocTable);

	CComPtr<VCProject> spProject;
	hr = pProjNode->GetVCProject(&spProject);
	RETURN_ON_FAIL_OR_NULL(hr, spProject);

	// the whole point of this next section is to determine whether the new and old names are the same...
	CStringW strNewName = szFileName;
	if (!strNewName.IsEmpty())
	{
		CComBSTR bstrNewName = szFileName;
		VARIANT_BOOL bMatches = VARIANT_TRUE;
		hr = spProject->MatchName(bstrNewName, VARIANT_FALSE, &bMatches);
		RETURN_ON_FAIL(hr);

		if (bMatches == VARIANT_FALSE)
		{
			CPathW pathNew;
			if (pathNew.Create(strNewName))
			{
				pathNew.ChangeExtension(L".vcproj");
				strNewName = (const wchar_t*)pathNew;
			}

			CComBSTR bstrOldName;
			hr = spProject->get_ProjectFile(&bstrOldName);
			RETURN_ON_FAIL(hr);

			CStringW strOldName = bstrOldName;
			CPathW pathOld;
			if (pathOld.Create(strOldName))
				strOldName = (const wchar_t*)pathOld;

			if (!strOldName.IsEmpty() && !strNewName.IsEmpty() && _wcsicmp(strOldName, strNewName) != 0)
			{
				hr = spDocTable->RenameDocument(strOldName, strNewName, spHier, VSITEMID_ROOT);
				RETURN_ON_FAIL(hr);
			}
		}
	}

	return spDocTable->SaveDocuments(RDTSAVEOPT_ForceSave, spHier, VSITEMID_ROOT, NULL);
}

HRESULT CBuildPackage::DoFallbackAddConfiguration(VCProject* pProject, BSTR bstrConfigName)
{
	CComQIPtr<IVCProjectImpl> pProjImpl = pProject;
	RETURN_ON_NULL2(pProjImpl, E_UNEXPECTED);
	return pProjImpl->AddConfigurationInternal(bstrConfigName);
}

STDMETHODIMP CBuildPackage::AddConfigurationToProject(VCProject* pProject, BSTR bstrConfigName)
{
	CVCProjectNode* pProjNode = GetProjectNode(pProject);
	if (pProjNode == NULL)
		return DoFallbackAddConfiguration(pProject, bstrConfigName);

	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = pProjNode->GetVsHierarchy(&spHier, TRUE);
	if (FAILED(hr) || spHier == NULL)
		return DoFallbackAddConfiguration(pProject, bstrConfigName);

	CComPtr<IVsExtensibility> pExtService;
	hr = ExternalQueryService(SID_SVsExtensibility, __uuidof(IVsExtensibility), (LPVOID*)&pExtService);
	if(FAILED(hr))
		return DoFallbackAddConfiguration(pProject, bstrConfigName);

	CComPtr<ConfigurationManager> spConfigurationManager;
	hr = pExtService->GetConfigMgr(spHier, VSITEMID_ROOT, &spConfigurationManager);
	if (FAILED(hr) || spConfigurationManager == NULL)
		return DoFallbackAddConfiguration(pProject, bstrConfigName);

	CComPtr<Configurations> spConfigurations;
	return spConfigurationManager->AddConfigurationRow(bstrConfigName, CComBSTR(L""), VARIANT_TRUE, &spConfigurations);
}

STDMETHODIMP CBuildPackage::AddPlatformToProject(VCProject* pProject, LPCOLESTR szPlatformName)
{
	// FUTURE: let the solution in on what we're up to
	CComQIPtr<IVCProjectImpl> spProjImpl = pProject;
	RETURN_ON_NULL2(spProjImpl, E_UNEXPECTED);
	return spProjImpl->AddPlatformInternal(szPlatformName);
}

STDMETHODIMP CBuildPackage::RemovePlatformFromProject(VCProject* pProject, IDispatch* pPlatform)
{
	// FUTURE: let the solution in on what we're up to
	CComQIPtr<IVCProjectImpl> spProjImpl = pProject;
	RETURN_ON_NULL2(spProjImpl, E_UNEXPECTED);
	return spProjImpl->RemovePlatformInternal(pPlatform);
}

STDMETHODIMP CBuildPackage::ErrorCloseOfProject(VCProject* pProject)
{	// call this BEFORE removing a 'dead' project from the project collection; ERROR CLOSE OF PROJECT ONLY
	CVCProjectNode* pProjNode = GetProjectNode(pProject);
	RETURN_ON_NULL2(pProjNode, S_OK);

	CVCArchy* pArchy = pProjNode->GetArchy();
	if (pArchy)
		pArchy->Release();	// this gets rid of the refcount that the solution would have had

	return S_OK;
}

void CBuildPackage::GetVsProject(VCProject* pProject, CComPtr<IVsProject>& rspVsProj)
{
	CVCArchy* pArchy = NULL;
	CVCProjectNode* pProjNode = GetProjectNode(pProject);
	if (pProjNode)
		pArchy = pProjNode->GetHierarchy();
	if (pArchy)
		rspVsProj = VCQI_cast<IVsProject>(pArchy);
	else
		rspVsProj = NULL;
}

BOOL CBuildPackage::GetVsProjectAndTracker(VCProject* pProject, CComPtr<IVsProject>& rspVsProj, 
	CComPtr<IVsTrackProjectDocuments>& rspTrackDocs)
{
	GetVsProject(pProject, rspVsProj);

	if (rspVsProj)	// don't care about this service if no project...
		ExternalQueryService(SID_SVsTrackProjectDocuments, IID_IVsTrackProjectDocuments, (void **)&rspTrackDocs);

	return (rspVsProj != NULL && rspTrackDocs != NULL);
}

BOOL CBuildPackage::GetVsProjectAndTracker(VCProject* pProject, CComPtr<IVsProject>& rspVsProj, 
	CComPtr<IVsTrackProjectDocuments2>& rspTrackDocs)
{
	GetVsProject(pProject, rspVsProj);

	if (rspVsProj)	// don't care about this service if no project...
		ExternalQueryService(SID_SVsTrackProjectDocuments, IID_IVsTrackProjectDocuments2, (void **)&rspTrackDocs);

	return (rspVsProj != NULL && rspTrackDocs != NULL);
}

STDMETHODIMP CBuildPackage::AllowedToAddFile(VCProject* pProject, LPCOLESTR szFile, VARIANT_BOOL bSetErrorInfo)
{
	if ( !FIsIDEInteractive() )
		return S_OK;

	CComPtr<IVsProject> spVsProj;
	CComPtr<IVsTrackProjectDocuments2> spTrackDocs;
	if (!GetVsProjectAndTracker(pProject, spVsProj, spTrackDocs))
		return S_OK;		// don't really care if we could do this or not...

	const int cFiles = 1;
	VSQUERYADDFILEFLAGS rgFlags[cFiles] = {VSQUERYADDFILEFLAGS_NoFlags};
	VSQUERYADDFILERESULTS qafSummary = VSQUERYADDFILERESULTS_AddOK;
	VSQUERYADDFILERESULTS rgQAFResults[cFiles];

	HRESULT hr = spTrackDocs->OnQueryAddFiles(spVsProj, 1, &szFile, rgFlags, &qafSummary, rgQAFResults);
	RETURN_ON_FAIL(hr);

	if (VSQUERYADDFILERESULTS_AddOK == qafSummary)
		return S_OK;
	
	return DoSetErrorInfo2(E_ACCESSDENIED, IDS_ERR_CANNOT_ADD_FILE, szFile, (bSetErrorInfo == VARIANT_TRUE));
}

STDMETHODIMP CBuildPackage::AllowedToRemoveFile(VCProject* pProject, LPCOLESTR szFile)
{
	if ( !FIsIDEInteractive() )
		return S_OK;

	CComPtr<IVsProject> spVsProj;
	CComPtr<IVsTrackProjectDocuments2> spTrackDocs;
	if (!GetVsProjectAndTracker(pProject, spVsProj, spTrackDocs))
		return S_OK;		// don't really care if we could do this or not...

	const int cFiles = 1;
	VSQUERYREMOVEFILEFLAGS rgFlags[cFiles] = {VSQUERYREMOVEFILEFLAGS_NoFlags};
	VSQUERYREMOVEFILERESULTS qrfSummary = VSQUERYREMOVEFILERESULTS_RemoveOK;
	VSQUERYREMOVEFILERESULTS rgQRFResults[cFiles];

	HRESULT hr = spTrackDocs->OnQueryRemoveFiles(spVsProj, cFiles, &szFile, rgFlags, &qrfSummary, rgQRFResults);
	RETURN_ON_FAIL(hr);

	return (VSQUERYREMOVEFILERESULTS_RemoveOK == qrfSummary) ? S_OK : E_ACCESSDENIED;
}

STDMETHODIMP CBuildPackage::InformFileAdded(VCProject* pProject, LPCOLESTR szFile)
{
	if ( !FIsIDEInteractive() )
		return S_OK;

	CComPtr<IVsProject> spVsProj;
	CComPtr<IVsTrackProjectDocuments> spTrackDocs;
	if (!GetVsProjectAndTracker(pProject, spVsProj, spTrackDocs))
		return S_OK;		// don't really care if we could do this or not...

	return spTrackDocs->OnAfterAddFiles(spVsProj, 1, &szFile);
}

STDMETHODIMP CBuildPackage::InformFileRemoved(VCProject* pProject, LPCOLESTR szFile)
{
	if ( !FIsIDEInteractive() )
		return S_OK;

	CComPtr<IVsProject> spVsProj;
	CComPtr<IVsTrackProjectDocuments> spTrackDocs;
	if (!GetVsProjectAndTracker(pProject, spVsProj, spTrackDocs))
		return S_OK;		// don't really care if we could do this or not...

	VSREMOVEFILEFLAGS rgFlags[1] = {VSREMOVEFILEFLAGS_NoFlags};

	return spTrackDocs->OnAfterRemoveFiles(spVsProj, 1, &szFile, rgFlags);
}

HRESULT CBuildPackage::GetDebugCommandLines(VCDebugSettings* pDbgSettings, VCConfiguration* pConfig)
{
	CHECK_READ_POINTER_NULL(pDbgSettings);

	// get the parent for the dlg
	HWND hwndShell;
	CComPtr<IVsUIShell> pUIShell;
	HRESULT hr = ExternalQueryService( SID_SVsUIShell, IID_IVsUIShell, reinterpret_cast<void **>(&pUIShell) );
	RETURN_ON_FAIL_OR_NULL2(hr, pUIShell, E_NOINTERFACE);
	hr = pUIShell->GetDialogOwnerHwnd( &hwndShell );
	RETURN_ON_FAIL(hr);

	CCCallExeForDebug dbgDlg( pConfig, hwndShell );
	CComBSTR bstrUrl, bstrExe;
	pDbgSettings->get_HttpUrl(&bstrUrl);
	pDbgSettings->get_Command(&bstrExe);
	dbgDlg.m_bstrUrl = bstrUrl;
	dbgDlg.m_bstrExe = bstrExe;

	hr = pUIShell->EnableModeless(false);
	RETURN_ON_FAIL(hr);

	if (dbgDlg.DoModalW() == IDOK)
	{
		CComBSTR bstrHttpUrl;
		CComBSTR bstrExeToDebug;
		bstrHttpUrl = dbgDlg.m_bstrUrl;

		bstrExeToDebug = dbgDlg.m_bstrExe;
		if (bstrHttpUrl.Length() > 0)
			pDbgSettings->put_HttpUrl(bstrHttpUrl);
		if (bstrExeToDebug.Length() > 0)
			pDbgSettings->put_Command(bstrExeToDebug);
		hr = S_OK;
	}
	else
	{
		hr = E_ABORT;	// user canceled
	}

	/*hr =*/ pUIShell->EnableModeless(true); //don't want to mask E_ABORT

    return hr;
}

HRESULT CBuildPackage::GetBuildErrorContext(IVCBuildErrorContext** ppIVCBuildErrorContext)
{
	CHECK_POINTER_NULL(ppIVCBuildErrorContext);

	CComPtr<IVsOutputWindowPane> spOutputWindowPane;
	if (SUCCEEDED(CGenCfg::GetOutputWindowPane(&spOutputWindowPane)) && spOutputWindowPane != NULL)
		spOutputWindowPane->Activate();

	CComPtr<IVCBuildOutput> spModelessOutputWindow;
	HRESULT hr = CVCBuildOutput::CreateInstance(&spModelessOutputWindow, spOutputWindowPane);
	RETURN_ON_FAIL_OR_NULL(hr, spModelessOutputWindow);

	CComPtr<IVCBuildEngine> spBldEngine;
	GetBuildEngine(&spBldEngine);
	CComPtr<IVCBuildErrorContext> spErrorContext;

	hr = CBldOutputWinEC::CreateInstance(&spErrorContext, NULL, spBldEngine, NULL, spModelessOutputWindow);
	VSASSERT(SUCCEEDED(hr), "Failed to create error context!");
	*ppIVCBuildErrorContext = spErrorContext.Detach();
	return hr;
}

////////////////////////////////////////////////////////////
// CBldPackage::OnExit

void CBuildPackage::OnExit()
{
}

BOOL CBuildPackage::OnInit()
{

	CComQIPtr<IVCCollection>	spCollection;
	CComQIPtr<VCPlatform>		spPlatform;
	CComPtr<IEnumVARIANT>		spEnum;
	CComPtr<IDispatch>			spDisp;
	HRESULT hr;

	BOOL bUseEnv = FALSE;
	// Now that we are loaded, check if we were loaded as part of a /debug switch
	CComPtr<IVsAppCommandLine> pCmdLine;
	if ((SUCCEEDED(ExternalQueryService(SID_SVsAppCommandLine, __uuidof(IVsAppCommandLine), (void **)&pCmdLine))) && (pCmdLine != NULL))
	{
		pCmdLine->GetOption(L"UseEnv",&bUseEnv,&bstrExeArguments);
	}

	BOOL bWrite = FALSE;

	// For each platform initalize the paths
	hr = GetBuildPkg()->m_pProjectEngine->get_Platforms(&spDisp);
	RETURN_ON_FAIL2(hr, FALSE);
	spCollection = spDisp;
	RETURN_ON_NULL2(spCollection, FALSE);
	hr = spCollection->_NewEnum(reinterpret_cast<IUnknown **>(&spEnum));
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spEnum, FALSE);
	spEnum->Reset();
	while ( TRUE )
	{
		CComVariant var;
		hr = spEnum->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		
		spPlatform = var.punkVal;
		if (!spPlatform)
			return FALSE;

		CStringW strEntry = L"VC\\VC_OBJECTS_PLATFORM_INFO\\";
		CComBSTR bstrName;
		hr = spPlatform->get_Name(&bstrName);
		strEntry += bstrName;
		strEntry += L"\\Directories";
		
		CStringW strPath;

		CComBSTR bstrPath;
		CComBSTR bstrInc;
		CComBSTR bstrAsm;
		CComBSTR bstrLib;
		CComBSTR bstrSrc;

		if( bUseEnv == FALSE )
			GetRegPath(strEntry, L"Path Dirs", strPath, L"");

		if (strPath == L"") 
		{	
			::VCGetEnvironmentVariableW(L"Path", &bstrPath);
			bWrite = TRUE;
		}
		else
		{
			bstrPath = strPath;
		}
		spPlatform->put_ExecutableDirectories(bstrPath);

		strPath = L"";
		if( bUseEnv == FALSE )
			GetRegPath(strEntry, L"Include Dirs", strPath, L"");
		if (strPath == L"") 
		{
			::VCGetEnvironmentVariableW(L"Include", &bstrInc);
			bWrite = TRUE;
		}
		else
		{
			bstrInc = strPath;
		}
		spPlatform->put_IncludeDirectories(bstrInc);
		
		strPath = L"";
		if( bUseEnv == FALSE )
			GetRegPath(strEntry, L"Reference Dirs", strPath, L"");
		if (strPath == "") 
		{
			::VCGetEnvironmentVariableW(L"LIBPATH", &bstrAsm);
			bWrite = TRUE;
		}	
		else
		{
			bstrAsm = strPath;
		}
		spPlatform->put_ReferenceDirectories(bstrAsm);

		strPath = L"";
		if( bUseEnv == FALSE )
			GetRegPath(strEntry, L"Library Dirs", strPath, L"");
		if (strPath == "") 
		{
			::VCGetEnvironmentVariableW(L"Lib", &bstrLib);
			bWrite = TRUE;
		}	
		else
		{
			bstrLib = strPath;
		}
		spPlatform->put_LibraryDirectories(bstrLib);

		strPath = L"";
		if( bUseEnv == FALSE )
			GetRegPath(strEntry, L"Source Dirs", strPath, L"");
		if (strPath == "") 
		{
			::VCGetEnvironmentVariableW(L"Source", &bstrSrc);
			bWrite = TRUE;
		}	
		else
		{
			bstrSrc = strPath;
		}
		spPlatform->put_SourceDirectories(bstrSrc);
	}
	// if bWrite, write the file
	if( bUseEnv == FALSE )
	{
		if( bWrite )
			CDirectoriesDlg::WritePathsToRegistry();
	}
		
	return TRUE;
}

// IVsUpdateSolutionEvents
STDMETHODIMP CBuildPackage::OnActiveProjectCfgChange(IVsHierarchy* pIVsHierarchy)
{
	RETURN_ON_NULL2(m_pProjectEngine, S_FALSE);
	RETURN_ON_NULL2(pIVsHierarchy, S_FALSE);	

	CComQIPtr<IVsUpdateSolutionEvents> spEvents = pIVsHierarchy;
	if( spEvents )
		spEvents->OnActiveProjectCfgChange(NULL);

	return S_OK;
}

// IVsSolutionEvents
STDMETHODIMP CBuildPackage::OnAfterOpenProject( IVsHierarchy *pHierarchy, BOOL fAdded)
{
	// check to see if we need to set project dependencies here...
	// (for VC 4.x projects with sub-projects)
	
	// if the root project name is null
	if( !g_wszRootProjectName )
		return S_OK;

	CHECK_READ_POINTER_NULL(pHierarchy);

	// get the name of the project from the hierarchy
	CComVariant varName;
	pHierarchy->GetProperty( VSITEMID_ROOT, VSHPROPID_Caption, &varName );
	if( varName.vt != VT_BSTR )
	{
		// free the root string and set it back to null
		delete[] g_wszRootProjectName;
		g_wszRootProjectName = NULL;
		return S_OK;
	}
	// is it the same as the root? 
	if( _wcsicmp( g_wszRootProjectName, varName.bstrVal ) == 0 )
	{
		// get the IVCProjConvert pointer
		CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = m_pProjectEngine;
		VSASSERT( pProjEngImpl, "Project Engine is in an invalid state: could not be QI'd for IVCProjectEngineImpl!" );
		CComQIPtr<IVCProjConvert> pProjConvert;
		CComPtr<IUnknown> pUnkProjConvert;
		pProjEngImpl->GetIVCProjConvert( &pUnkProjConvert );
		if( !pUnkProjConvert )
		{
			// free the root string and set it back to null
			delete[] g_wszRootProjectName;
			g_wszRootProjectName = NULL;
			return S_OK;
		}
		pProjConvert = pUnkProjConvert;
		RETURN_ON_NULL(pProjConvert);

		// if there are no dependencies, bail
		VARIANT_BOOL bHasDeps;
		pProjConvert->get_HasProjectDependencies( &bHasDeps );
		if( bHasDeps == VARIANT_FALSE )
		{
			// free the root string and set it back to null
			delete[] g_wszRootProjectName;
			g_wszRootProjectName = NULL;
			return S_OK;
		}

		// get the dte object
		CComQIPtr<_DTE> pDTE;
		HRESULT hr = ExternalQueryService(SID_SDTE, __uuidof(_DTE), (void **)&pDTE);
		VSASSERT( SUCCEEDED( hr ), "Unable to get DTE!" );
		RETURN_ON_FAIL_OR_NULL(hr, pDTE);
		// get the Solution object
		CComPtr<_Solution> pSln;
		hr = pDTE->get_Solution( (Solution**)&pSln );
		VSASSERT( SUCCEEDED( hr ) && pSln, "Unable to get the solution from the DTE!" );
		RETURN_ON_FAIL_OR_NULL(hr, pSln);

		// get the solution service
		CComPtr<IVsSolution> pIVsSln;
		hr = GetIVsSolution( &pIVsSln );
		VSASSERT( SUCCEEDED( hr ) && pIVsSln, "Unable to get the solution service!" );
		RETURN_ON_FAIL_OR_NULL(hr, pIVsSln);

		// set the dependencies:
		
		// iterate through the dependencies
		pProjConvert->ResetProjectDependencyEnum();
		long lNumDeps;
		pProjConvert->get_ProjectDependenciesCount( &lNumDeps );
		for( long i = 0; i < lNumDeps; i++ )
		{
			// get the project and target strings
			CComBSTR bstrProject, bstrTarget;
			pProjConvert->GetNextProjectDependency( &bstrProject, &bstrTarget );

			// find the shell projects that match bstrProject and bstrTarget

			// get the hierarchies enumeration
			CComPtr<IEnumHierarchies> pHierEnum;
			hr = pIVsSln->GetProjectEnum( EPF_ALL, IID_IVCArchy, &pHierEnum );
			if( FAILED( hr ) || !pHierEnum )
				break;
			// for each hierarchy
			CComBSTR bstrProjUniqueName, bstrTargUniqueName;
			pHierEnum->Reset();
			while ( true )
			{
				CComQIPtr<IVsHierarchy> pHierarchy;

				hr = pHierEnum->Next(1, &pHierarchy, NULL);
				if( hr != S_OK )
					break;

				if (pHierarchy == NULL)
					continue;

				// GetProp its VSHPROPID_ExtObject to get the shell project
				CComVariant var;
				CComQIPtr<Project> pProj;
				hr = pHierarchy->GetProperty( VSITEMID_ROOT, VSHPROPID_ExtObject, &var );
				pProj = var.pdispVal;
				if (pProj == NULL)
					continue;

				// get its name
				CComBSTR bstrName;
				hr = pProj->get_Name( &bstrName );
				// compare the name to bstrProject
				if( bstrName && _wcsicmp( bstrName, bstrProject ) == 0 )
				{
					pProj->get_UniqueName( &bstrProjUniqueName );
					continue;
				}
				// compare the name to bstrTarget
				if( bstrName && _wcsicmp( bstrName, bstrTarget ) == 0 )
				{
					pProj->get_UniqueName( &bstrTargUniqueName );
					continue;
				}
			}

			// get the SolutionBuild object
			CComPtr<SolutionBuild> pSlnBld;
			hr = pSln->get_SolutionBuild( &pSlnBld );
			if( FAILED( hr ) || !pSlnBld )
				break;
			// get the BuildDependencies object for strProject
			CComPtr<BuildDependencies> pBldDeps;
			hr = pSlnBld->get_BuildDependencies( &pBldDeps );
			if( FAILED( hr ) || !pBldDeps )
				break;
			// get this particular dependency
			CComPtr<BuildDependency> pBldDep;
			hr = pBldDeps->Item( CComVariant( bstrProjUniqueName ), &pBldDep );
			if( FAILED( hr ) || !pBldDep )
				break;
			// call AddProject on it
			hr = pBldDep->AddProject( bstrTargUniqueName );

		}

		// free the root string and set it back to null
		delete[] g_wszRootProjectName;
		g_wszRootProjectName = NULL;
	}
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnQueryCloseProject( IVsHierarchy *pHierarchy, BOOL fRemoving, BOOL *pfCancel)
{
	*pfCancel = FALSE;
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnBeforeCloseProject( IVsHierarchy *pHierarchy, BOOL fRemoved)
{
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnAfterLoadProject( IVsHierarchy *pStubHierarchy, IVsHierarchy *pRealHierarchy)
{
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnQueryUnloadProject( IVsHierarchy *pRealHierarchy, BOOL *pfCancel)
{
	*pfCancel = FALSE;
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnBeforeUnloadProject( IVsHierarchy *pRealHierarchy, IVsHierarchy *pStubHierarchy)
{
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnAfterOpenSolution( IUnknown *pUnkReserved, BOOL fNewSolution)
{
	UpdateSolutionFile();
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnQueryCloseSolution( IUnknown *pUnkReserved, BOOL *pfCancel)
{
	*pfCancel = FALSE;
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnBeforeCloseSolution( IUnknown *pUnkReserved)
{
	CConvertDlg::s_bConvertAll = CConvertDlg::s_bConvertNone = FALSE;
	return S_OK;
}

STDMETHODIMP CBuildPackage::OnAfterCloseSolution( IUnknown *pUnkReserved)
{
	m_bstrSolutionFile.Empty();
	return S_OK;
}

HRESULT CBuildPackage::DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bSetInfo)
{
	if (bSetInfo)
	{
		CComBSTR bstrErr;
		bstrErr.LoadString(idErr);
		HandleSetErrorInfo(hrErr, bstrErr);
	}
	return hrErr;
}

HRESULT CBuildPackage::DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bSetInfo)
{
	if (bSetInfo)
	{
		CStringW strErr;
		strErr.Format(idErr, szParam);
		CComBSTR bstrErr = strErr;
		HandleSetErrorInfo(hrErr, bstrErr);
	}
	return hrErr;
}

void CBuildPackage::SetUseGlobalEditorForResourceFiles(VARIANT_BOOL bUseGlobal)
{
	CStringW strRoot = s_bstrAltKey + "\\VC";
	m_bUseGlobalEditorForRC = bUseGlobal;
	DWORD dwValue = WriteRegIntW(strRoot, USE_GLOBAL_RC_EDITOR, DWORD(m_bUseGlobalEditorForRC));
}

BOOL CBuildPackage::GetSccManager(IVsSccManager2** ppManager)
{
	CHECK_POINTER_NULL(ppManager);
	*ppManager = NULL;
	if (m_spVsSccManager2 == NULL)
		ExternalQueryService(SID_SVsSccManager, IID_IVsSccManager2, (void **)&m_spVsSccManager2);
	m_spVsSccManager2.CopyTo(ppManager);
	return (m_spVsSccManager2 != NULL);
}

HRESULT CBuildPackage::UpdateSolutionFile()
{
	m_bstrSolutionFile.Empty();
	CComPtr<IVsSolution> spSoln;
	HRESULT hr = GetIVsSolution(&spSoln);
	RETURN_ON_FAIL_OR_NULL(hr, spSoln);
	CComBSTR bstrSolnDir, bstrUserOpts;
	hr = spSoln->GetSolutionInfo(&bstrSolnDir, &m_bstrSolutionFile, &bstrUserOpts);
	VSASSERT(SUCCEEDED(hr), "Failed to get solution info!");
	return hr;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT CExeProjectFactory::CanCreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ DWORD grfCreateProj,
            /* [out] */ BOOL *pfCanCreate)
{
	CHECK_POINTER_NULL(pfCanCreate);

	*pfCanCreate = TRUE;
	return S_OK;
}
        
HRESULT CExeProjectFactory::CreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled)
{
	CHECK_POINTER_NULL(ppUnk);
	CHECK_POINTER_NULL(pfCanceled);

	*ppUnk = NULL;
	*pfCanceled = FALSE;

	if(grfCreateProj & CPF_CLONEFILE) // New project
	{
		// We don't support this.
		return E_FAIL;
	}

	 // Open existing project
	CComObject<CExeHierarchy> *pExeHierarchy;	// created with Ref count 0
	HRESULT hr = CComObject<CExeHierarchy>::CreateInstance(&pExeHierarchy);
	if( pExeHierarchy )
	{
		pExeHierarchy->Initialize(pszFilename, bstrExeArguments);
		pExeHierarchy->QueryInterface(__uuidof(IVsHierarchy), ppUnk);
		if( bstrExeArguments )
		{
			bstrExeArguments = "";
		}
	}

	return hr;
}

STDMETHODIMP CExeProjectFactory::SetSite( /* [in] */ IServiceProvider *pSP)
{
	return S_OK;
}

STDMETHODIMP CExeProjectFactory::Close(void)
{
	return S_OK;
}

HRESULT CCrashDumpProjectFactory::CreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled)
{
	CHECK_POINTER_NULL(ppUnk);
	CHECK_POINTER_NULL(pfCanceled);

	*ppUnk = NULL;
	*pfCanceled = FALSE;

	if(grfCreateProj & CPF_CLONEFILE) // New project
	{
		// We don't support this.
		return E_FAIL;
	}

	 // Open existing project
	CComObject<CCrashDumpHierarchy> *pCrashDumpHierarchy;	// created with Ref count 0
	HRESULT hr = CComObject<CCrashDumpHierarchy>::CreateInstance(&pCrashDumpHierarchy);
	if( pCrashDumpHierarchy )
	{
		pCrashDumpHierarchy->Initialize(pszFilename, bstrExeArguments);
		pCrashDumpHierarchy->QueryInterface(__uuidof(IVsHierarchy), ppUnk);
		if( bstrExeArguments )
		{
			bstrExeArguments = "";
		}
	}

	return hr;
}

#ifdef AARDVARK
//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT CStyleSheetProjectFactory::CanCreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ DWORD grfCreateProj,
            /* [out] */ BOOL *pfCanCreate)
{
	CHECK_POINTER_NULL(pfCanCreate);

	*pfCanCreate = TRUE;
	return S_OK;
}
        
HRESULT CStyleSheetProjectFactory::CreateProject( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled)
{
	// helper object to track "in project load" status
	CInProjectLoadHelper inProjLoad;
	HRESULT hr = E_FAIL;

	CComPtr<IDispatch> pDispStyleSheet;

	CDirW dirTo;
	CDirW dirFrom;

	if (ppUnk != NULL && pfCanceled != NULL)
	{
		*ppUnk = NULL;
		*pfCanceled = FALSE;
		CComBSTR bstrFileName = pszFilename;

		// WARNING ! Although this looks like it is doing nothing, it actually initializes the Wizards package so 
		// that someone SetSite's them.  It also needs to go BEFORE the first project gets loaded or our conversion
		// DLL can't get CoCreate'd.  Go figure.
		// DO NOT REMOVE without asking DaveWa
		if( FIsIDEInteractive() )
		{
			CComPtr<IVsPackage> pUnk;
			hr = ExternalQueryService(SID_SVCService, __uuidof(IVsPackage), (void**)&pUnk);
		}
		// END DO NOT REMOVE

		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = GetBuildPkg()->m_pProjectEngine;
		if (spProjEngineImpl == NULL)
		{
			*pfCanceled = TRUE;
			return E_FAIL;
		}

		hr = spProjEngineImpl->LoadProjectUnderShell(bstrFileName, &pDispStyleSheet);
		// if we can't load the project file, bail
		if( FAILED( hr ) )
		{
			CStringW strFileName = bstrFileName;
			CStringW strMessage;
			strMessage.Format(IDS_WARN_PRJOPEN_FAILED, strFileName);
			CComBSTR bstrMessage = strMessage;
			ReportError( bstrMessage, hr );

			*pfCanceled = TRUE;
			if (hr != E_FAIL)
				hr = E_ABORT;
			return hr;
		}
		// if we were given a name, we need to set the correct name of the project
		if( pszName )
		{
			CComQIPtr<VCStyleSheet> pStyleSheet = pDispStyleSheet;
			VSASSERT( pStyleSheet, "Failed to get VCStyleSheet object back from LoadStyleSheet!" );
			RETURN_ON_NULL(pStyleSheet);
			// strip the file extension off the name
			CStringW strName = pszName;
			int idx = strName.ReverseFind( L'.' );
			if( idx != -1 )
				strName = strName.Left( idx );
			pStyleSheet->put_Name( CComBSTR( strName ) );
		}
	
		if (SUCCEEDED(hr) && pDispStyleSheet)
		{
			// get the IDispatch of the StyleSheet and add all elements of that StyleSheet to the UI.
			CComQIPtr<IVCExternalCookie> pExCookie = pDispStyleSheet;
			if (pExCookie)
			{
				void* pCookie;
				hr = pExCookie->get_ExternalCookie(&pCookie);
				CStyleSheetHierarchy *pStyleHierarchy = (CStyleSheetHierarchy *)pCookie;
				CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(pStyleHierarchy);
				*ppUnk = spHier;	// yep, we're now down one ref when we leave here.  that's OK and necessary.
	
				hr = S_OK;
			}
		}
	}

	if( *ppUnk == NULL )
		hr = E_FAIL;
	
	if( FAILED(hr) )
	{
		CComBSTR bstrMessage;
		bstrMessage.LoadString(IDS_WARN_PRJOPEN_FAILED);
		ReportError( bstrMessage, hr );
		if (hr != E_FAIL)
			hr = E_ABORT;

		*pfCanceled = TRUE;
	}

	return hr;
}

STDMETHODIMP CStyleSheetProjectFactory::SetSite( /* [in] */ IServiceProvider *pSP)
{
	return S_OK;
}

STDMETHODIMP CStyleSheetProjectFactory::Close(void)
{
	return S_OK;
}

#include "stylehierarchy.cpp"
#endif	// AARDVARK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\bldpkg.h ===
// BldPkg.h : Declaration of the CBuildPackage

#ifndef __BUILDPACKAGE_H_
#define __BUILDPACKAGE_H_

#include "rsrc.h"       // main symbols
#include "servprov.h"

#include "vc.h"      // in vc\ide\include
#include <commctrl.h> // for HIMAGELIST
#include "vcguid.h"
#include <objext.h>		// IProfferService
#include <BldMarshal.h>	// for CBldMarshaller
#include "mssplash.h"
#include "utils.h"

#include "prjnode.h"
#include "vssolutn.h"
#include "vstrkdoc.h"
#include <IVsTrackProjectDocuments2.h>
 
typedef CVCPtrList CProjNodeList;

const int MAX_PLATFORMS=16;
#define W_VISUAL_CPP L"VisualC++"

/////////////////////////////////////////////////////////////////////////////
// forward declarations
class CBuildPackage;
class CVCFileNode;	// defined in vcfile.h
class CVCFileGroup;	// defined in vcfgrp.h
class CVCArchy;
class CBuildOptions;
class CDirectoriesDlg;
class CModule;

// Our one and only build Package object
// This is defined in vproj.cpp
extern CBuildPackage * g_pBuildPackage;
CBuildPackage* GetBuildPkg(void);

// global "in project load" flag. DO NOT EDIT DIRECTLY!!!
extern bool g_bInProjectLoad;

// global "root level project" string for VC 4.x conversion ONLY
extern wchar_t* g_wszRootProjectName;

IServiceProvider* GetServiceProvider(void);
HRESULT ExternalQueryService(REFGUID rsid, REFIID iid, void **ppvObj);
void ReportError(BSTR bstrError, HRESULT hrReport = E_FAIL);
void HandleSetErrorInfo(HRESULT hrReport, BSTR bstrError);
// are we under the IDE or not?
BOOL FIsIDEInteractive();

//-----------------------------------------------------------------------------
// provides:
//		interface: IVsProjectFactory
//-----------------------------------------------------------------------------
class CVCProjectFactory :
	public IVsProjectFactory,
	public IVsOwnedProjectFactory,
	public CComObjectRoot
{
public:
			 CVCProjectFactory(void);
	virtual ~CVCProjectFactory(void);

BEGIN_COM_MAP(CVCProjectFactory)
	COM_INTERFACE_ENTRY(IVsProjectFactory)
	COM_INTERFACE_ENTRY(IVsOwnedProjectFactory)
END_COM_MAP()

// IVsProjectFactory
public:
	STDMETHOD(CanCreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ DWORD grfCreateProj,
            /* [out] */ BOOL *pfCanCreate);
        
	STDMETHOD(CreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled);

	STDMETHOD(SetSite)(
			/* [in] */ IServiceProvider *pSP);

	STDMETHOD(Close)(void);

// IVsOwnedProjectFactory
public:
    STDMETHOD(PreCreateForOwner)( 
        /*[in]*/  IUnknown* pOwner,
        /*[out]*/ IUnknown**            ppInner,
        /*[out]*/ VSOWNEDPROJECTOBJECT* pCookie );

    STDMETHOD(InitializeForOwner)( 
        /*[in]*/ LPCOLESTR pszFilename,
        /*[in]*/ LPCOLESTR                 pszLocation,
        /*[in]*/ LPCOLESTR                 pszName,
        /*[in]*/ VSCREATEPROJFLAGS         grfCreateFlags,
        /*[in]*/ REFIID                    iidProject,
        /*[in]*/ VSOWNEDPROJECTOBJECT      cookie, // additional parameter
        /*[out, iid_is(iidProject)]*/void  **ppvProject,
        /*[out]*/ BOOL                     *pfCanceled);

public:
	static VSOWNEDPROJECTOBJECT s_EFPolicyCookie;
protected:
	CComPtr<IServiceProvider> m_srpIServiceProvider;

};

class CExeProjectFactory :
	public IVsProjectFactory,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CExeProjectFactory)
	COM_INTERFACE_ENTRY(IVsProjectFactory)
END_COM_MAP()

// IVsProjectFactory
public:
	STDMETHOD(CanCreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ DWORD grfCreateProj,
            /* [out] */ BOOL *pfCanCreate);
        
	STDMETHOD(CreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled);

	STDMETHOD(SetSite)(
			/* [in] */ IServiceProvider *pSP);

	STDMETHOD(Close)(void);

};

class CCrashDumpProjectFactory : public CExeProjectFactory
{
// IVsProjectFactory
public:
	STDMETHOD(CreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled);
};

#ifdef AARDVARK
class CStyleSheetProjectFactory :
	public IVsProjectFactory,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CStyleSheetProjectFactory)
	COM_INTERFACE_ENTRY(IVsProjectFactory)
END_COM_MAP()

// IVsProjectFactory
public:
	STDMETHOD(CanCreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ DWORD grfCreateProj,
            /* [out] */ BOOL *pfCanCreate);
        
	STDMETHOD(CreateProject)( 
            /* [in] */ LPCOLESTR pszFilename,
            /* [in] */ LPCOLESTR pszLocation,
            /* [in] */ LPCOLESTR pszName,
            /* [in] */ DWORD grfCreateProj,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppUnk,
            /* [out] */ BOOL *pfCanceled);

	STDMETHOD(SetSite)(
			/* [in] */ IServiceProvider *pSP);

	STDMETHOD(Close)(void);

};
#endif	// AARDVARK

class CVUPProjectFactory :
	public IVsProjectFactory,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVUPProjectFactory)
	COM_INTERFACE_ENTRY(IVsProjectFactory)
END_COM_MAP()

// IVsProjectFactory
public:
	STDMETHOD(CanCreateProject)( LPCOLESTR pszFilename, DWORD grfCreateProj, BOOL *pfCanCreate)
	{
		// if extension is .vup pretend that this is going to work.
		if( pfCanCreate )
		{
			*pfCanCreate = TRUE;
		}
		return S_OK;
	}
        
	STDMETHOD(CreateProject)( LPCOLESTR pszFilename, LPCOLESTR pszLocation, LPCOLESTR pszName, DWORD grfCreateProj, REFIID riid, void **ppUnk, BOOL *pfCanceled)
	{
		// Put up an error message that say Sorry Nope !
		CComBSTR bstrErr;
		bstrErr.LoadString(IDS_E_NO_MORE_VUP);
	    	UtilSetErrorInfo( E_FAIL, bstrErr );
		return E_FAIL;
	}

	STDMETHOD(SetSite)(IServiceProvider *pSP)
	{
		m_srpIServiceProvider = pSP;
		return S_OK;
	}

	STDMETHOD(Close)(void)
	{
		m_srpIServiceProvider = NULL;
		return S_OK;
	};

	CComPtr<IServiceProvider> m_srpIServiceProvider;

};

extern _ATL_REGMAP_ENTRY g_rm[];

/////////////////////////////////////////////////////////////////////////////
// CBuildPackage
class CBuildPackage : 
	public IVsPackage,
	public IOleCommandTarget,
	public IVCBuildPackageInternal,
	public IVsPersistSolutionOpts,
	public IServiceProvider,
	public IVsUpdateSolutionEvents,
	public IVsMicrosoftInstalledProduct,
	public IVsSolutionEvents,
	public CComObjectRoot,
	public CComCoClass<CBuildPackage, &CLSID_BuildPackage>
{
public:
	CBuildPackage();
	~CBuildPackage();
	STDMETHOD(Initialize)();

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {
		return _Module.UpdateRegistryFromResource( IDR_BUILDPACKAGE, bRegister, g_rm );
	}

//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBuildPackage)
	COM_INTERFACE_ENTRY(IVsPackage)
	COM_INTERFACE_ENTRY(IServiceProvider)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(IVsPersistSolutionOpts)
	COM_INTERFACE_ENTRY(IVCBuildPackageInternal)
	COM_INTERFACE_ENTRY(IVsUpdateSolutionEvents)
	COM_INTERFACE_ENTRY(IVsSolutionEvents)
	COM_INTERFACE_ENTRY(IVsMicrosoftInstalledProduct)
	COM_INTERFACE_ENTRY(IVsInstalledProduct)
END_COM_MAP()

// IVsPackage
public:
   	STDMETHOD(SetSite)(IServiceProvider *pSP);
	STDMETHOD(QueryClose)(BOOL *pCanClose);
	STDMETHOD(Close)();
	STDMETHOD(GetAutomationObject)(LPCOLESTR pszPropName, IDispatch **ppDisp);
	STDMETHOD(GetPropertyPage)(REFGUID rguidPage, VSPROPSHEETPAGE *ppage);
	STDMETHOD(ResetDefaults)(PKGRESETFLAGS dwFlags);
	STDMETHOD(CreateTool)(REFGUID rguidPersistenceSlot);

// IVsPersistSolutionOpts
public:
    STDMETHOD(SaveUserOptions)(IVsSolutionPersistence *pPersistence);
    STDMETHOD(LoadUserOptions)(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts);
    STDMETHOD(WriteUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    STDMETHOD(ReadUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);

// IOleCommandTarget
public:
	STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);

// IServiceProvider
public:
	STDMETHOD(QueryService)(THIS_ REFGUID rsid, REFIID iid, void ** ppvObj);

//IVsMicrosoftInstalledProduct
    STDMETHOD(get_IdBmpSplash)(UINT *pIdBmp) { *pIdBmp = IDB_SPLASHSCREEN; return NOERROR; }
    STDMETHOD(get_OfficialName)(BSTR *pbstrName);
    STDMETHOD(get_ProductID)(BSTR *pbstrPID) {return E_NOTIMPL;} //pulled from registry
    STDMETHOD(get_ProductDetails)(BSTR *pbstrProductDetails);
    STDMETHOD(get_IdIcoLogoForAboutbox)(UINT *pIdIco) {*pIdIco = IDI_AboutBox; return S_OK;}
    STDMETHOD(get_ProductRegistryName)(BSTR *pbstrRegName){*pbstrRegName = SysAllocString(W_VISUAL_CPP); return S_OK;}
  
// IVsUpdateSolutionEvents
public:
    STDMETHOD(UpdateSolution_Begin)(BOOL* pbCancelUpdate) { return S_OK; }
    STDMETHOD(UpdateSolution_Done)(BOOL bSucceeded, BOOL bModified, BOOL bCancelCommand) { return S_OK; }
    STDMETHOD(UpdateSolution_StartUpdate)(BOOL* pbCancelUpdate) { return S_OK; }
    STDMETHOD(UpdateSolution_Cancel)() { return S_OK; }
    STDMETHOD(OnActiveProjectCfgChange)(IVsHierarchy* pIVsHierarchy);

// IVsSolutionEvents
public:
	STDMETHOD(OnAfterOpenProject)( IVsHierarchy *pHierarchy, BOOL fAdded);
	STDMETHOD(OnQueryCloseProject)( IVsHierarchy *pHierarchy, BOOL fRemoving, BOOL __RPC_FAR *pfCancel);
	STDMETHOD(OnBeforeCloseProject)( IVsHierarchy *pHierarchy, BOOL fRemoved);
	STDMETHOD(OnAfterLoadProject)( IVsHierarchy *pStubHierarchy, IVsHierarchy __RPC_FAR *pRealHierarchy);
	STDMETHOD(OnQueryUnloadProject)( IVsHierarchy *pRealHierarchy, BOOL __RPC_FAR *pfCancel);
	STDMETHOD(OnBeforeUnloadProject)( IVsHierarchy *pRealHierarchy, IVsHierarchy __RPC_FAR *pStubHierarchy);
	STDMETHOD(OnAfterOpenSolution)( IUnknown *pUnkReserved, BOOL fNewSolution);
	STDMETHOD(OnQueryCloseSolution)( IUnknown *pUnkReserved, BOOL __RPC_FAR *pfCancel);
	STDMETHOD(OnBeforeCloseSolution)( IUnknown *pUnkReserved);
	STDMETHOD(OnAfterCloseSolution)( IUnknown *pUnkReserved);

// IVCBuildPackageInternal
public:
	STDMETHOD(GetConfigurationDependencies)(VCConfiguration* pProjConfig, IVCBuildOutputItems** ppBuildOutputs);
	STDMETHOD(HasConfigurationDependencies)(VCConfiguration* pProjConfig, VARIANT_BOOL* pbHasDeps);
	STDMETHOD(GetUIConfigurationForVCConfiguration)(VCConfiguration* pProjCfg, IVCGenericConfiguration** ppGenCfg);
	STDMETHOD(get_SolutionFile)(BSTR* pbstrSolnFile);
	STDMETHOD(SaveProject)(VCProject* pProject, LPCOLESTR szFileName);
	STDMETHOD(AddConfigurationToProject)(VCProject* pProject, BSTR bstrConfigName);
	STDMETHOD(AddPlatformToProject)(VCProject* pProject, LPCOLESTR szPlatformName);
	STDMETHOD(RemovePlatformFromProject)(VCProject* pProject, IDispatch* pDispPlatform);
	STDMETHOD(ErrorCloseOfProject)(VCProject* pProject);	// call this BEFORE removing a 'dead' project from the project collection; ERROR CLOSE OF PROJECT ONLY
	STDMETHOD(AllowedToAddFile)(VCProject* pProject, LPCOLESTR szFile, VARIANT_BOOL bSetErrorInfo);
	STDMETHOD(AllowedToRemoveFile)(VCProject* pProject, LPCOLESTR szFile);
	STDMETHOD(InformFileAdded)(VCProject* pProject, LPCOLESTR szFile);
	STDMETHOD(InformFileRemoved)(VCProject* pProject, LPCOLESTR szFile);

// helper functions
public:
	HRESULT GetBuildErrorContext(IVCBuildErrorContext** ppIVCBuildErrorContext);
	HRESULT GetDebugCommandLines(VCDebugSettings* pDbgSettings, VCConfiguration* pConfig);
	HRESULT GetVsShell(IVsShell** ppShell);
	HRESULT GetDTE(DTE** lppaReturn);
	HRESULT DoFallbackAddConfiguration(VCProject* pProject, BSTR bstrConfigName);
	HRESULT DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bSetInfo = TRUE);
	HRESULT DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bSetInfo = TRUE);

protected:
	BOOL GetVsProjectAndTracker(VCProject* pProject, CComPtr<IVsProject>& rspVsProj, CComPtr<IVsTrackProjectDocuments>& rspTrackDocs);
	BOOL GetVsProjectAndTracker(VCProject* pProject, CComPtr<IVsProject>& rspVsProj, CComPtr<IVsTrackProjectDocuments2>& rspTrackDocs);
	void GetVsProject(VCProject* pProject, CComPtr<IVsProject>& rspVsProj);
	int	 FindFirstSeparator(CStringW& strList, CStringW& strSeparatorList, int nStartIdx);
	int	 GetNextItem(CStringW& strList, int nStartIdx, int nMaxIdx, CStringW& strSeparator, CStringW& strItem);
	int	 GetNextQuotedItem(CStringW& strList, int nStartIdx, int nMaxIdx, int nSep, int nLastQuote,
		BOOL bOddQuote, CStringW& strSeparator, CStringW& strItem);

////////////////////////////////////////////////////////////
// non-COM methods for manipulating build package items
////////////////////////////////////////////////////////////
public:
	static	HRESULT	CreateInstance(CBuildPackage **);

public:
	HRESULT GetBuildEngine(IVCBuildEngine** ppBuildEngine);
	VCProjectEngine* 	GetProjectEngine();			// not ref-counted
	CVCProjectNode* 	GetProjectNode(VCProject* pProject);
	HRESULT GetArchyForProjConfig(VCConfiguration* pProjCfg, CVCArchy** ppArchy);
	HRESULT GetProjectNodeForProjConfig(VCConfiguration* pProjCfg, CVCProjectNode** ppProjNode);
	HRESULT GetHierarchyForProjConfig(VCConfiguration* pProjCfg, IVsHierarchy** ppHier, BOOL bInMainThread = FALSE);
	HRESULT GetSolutionBuildManager(IVsSolutionBuildManager** ppSolnBldMgr, BOOL bInMainThread = FALSE);
	HRESULT GetVsUIShell(IVsUIShell** ppShell, BOOL bInMainThread = FALSE);
	HRESULT GetTaskList(IVsTaskList** ppTaskList, BOOL bInMainThread = FALSE);
	HRESULT GetStatusbar(IVsStatusbar** ppStatusBar, BOOL bInMainThread = FALSE);
	HRESULT UpdateSolutionFile();

	void				AddSolutionRef();
	void				ReleaseSolutionRef();
	HRESULT GetIVsSolution(IVsSolution** ppSolution);	// intended for main thread use only
	void				IncrementSolutionBuildCount() { m_cSolutionBuilds++; }
	void				DecrementSolutionBuildCount() { if (m_cSolutionBuilds) m_cSolutionBuilds--; }
	BOOL				NoBuildsInProgress()			{ return (m_cSolutionBuilds == 0); }

	virtual BOOL OnInit();
	virtual void OnExit();
	// OLE Automation
	IDispatch* GetAutoProjects();
	// UIArchy related functions
	void InitializeArchy(BSTR bstrFilename, CVCProjectNode* pProj, CVCArchy* pArchy);
    void DoRefreshTaskList();
	void DoUpdateTaskList();
	IVCNotificationSource* GetNotificationSource();
	BOOL UseGlobalEditorForResourceFiles() { return m_bUseGlobalEditorForRC; }
	void SetUseGlobalEditorForResourceFiles(VARIANT_BOOL bUseGlobal);

	BOOL GetSccManager(IVsSccManager2** ppManager);

public:
	static CComBSTR s_bstrAltKey;
    static CVCExecutionCtx s_executionCtx;    // Global Execution Context object

public:  // REVIEW: all of these could be private with a little effort
	CComPtr<IServiceProvider>		m_pServiceProvider;
	CComPtr<IVCNotificationSource>	m_pVCNotificationSource;
 	CComPtr<VCProjectEngine> 		m_pProjectEngine;
	CComPtr<IVCProjectEngineEvents> m_pProjBuildEvents;	
	HIMAGELIST						m_hImageList;
	int								m_fAddNewItem;

private:
	CComQIPtr<IDispatch> m_spAutoProjects;

	CBuildOptions 	*m_pBuildOptions;
	CDirectoriesDlg *m_pBuildDirectories;
	CComPtr<IVsSolutionBuildManager> m_spSolutionBuildManager;
	CBldMarshaller<IVsSolutionBuildManager> m_marshalSolutionBuildManager;
	CBldMarshaller<IVsUIShell> m_marshalVsUIShell;
	CBldMarshaller<IVsTaskList> m_marshalTaskList;
	CBldMarshaller<IVsSolution> m_marshalVsSolution;
	CComPtr<IVsSccManager2> m_spVsSccManager2;
	long			m_nSolutionRefCount;
	VARIANT_BOOL	m_bUseGlobalEditorForRC;

	VSCOOKIE		m_pVCProjectCookie;
	VSCOOKIE		m_pExeProjectCookie;
	VSCOOKIE		m_pCrashDumpProjectCookie;
	VSCOOKIE		m_pVUPProjectCookie;
#ifdef AARDVARK
	VSCOOKIE		m_pStyleSheetProjectCookie;
#endif	// AARDVARK
	VSCOOKIE		m_dwTaskCookie;
	VSCOOKIE		m_vsSolutionEventsCookie;	// cookie for UpdateSolutionEvents
	VSCOOKIE		m_dwSlnEventsCookie;		// cookie for SolutionEvents

	DWORD           m_dwProjectEngineEventsCookie;  
	DWORD			m_dwBuildProjectEngineCookie;	// REVIEW: this should be a "VSCOOKIE"
	DWORD			m_dwENCBuildSpawnerCookie;		// REVIEW: this should be a "VSCOOKIE"
	DWORD			m_dwBuildErrorContextCookie;	// REVIEW: this should be a "VSCOOKIE"

    CComPtr<IVsTaskList> m_pTaskList;
	CComPtr<IVsUIShell>	m_spVsUIShell;
	CComPtr<IVCBuildOutput> m_spModelessOutputWindow;

	GUID			m_guidPersistenceSlot;
	CVCPtrList 		m_exePrjList;
	long			m_cSolutionBuilds;

	CComBSTR		m_bstrSolutionFile;
};

// Image offsets for our image list.
// NOTE!!! Do NOT change the order! Always add the "grey" version of an image before the
//		   nongrey version. The code relies on this.
enum
{
// 	BMP_LINKOVERLAY = 1,		// "link" overlay (1 based offset)
// 	BMP_NOTINSCCOVERLAY = 2,			// "not in scc" overlay
// 	BMP_CHECKEDOUTOVERLAY = 3,	// "checked out" overlay
// 	BMP_GREYHTML= 3,
// 	BMP_HTML,
	BMP_LINKOVERLAY,		// "link" overlay (1 based offset)
	BMP_NOTINSCCOVERLAY,			// "not in scc" overlay
	BMP_CHECKEDOUTOVERLAY,	// "checked out" overlay
	BMP_BUILDABLEITEM,
	BMP_NONBUILDABLEITEM,
	BMP_GREYCSS,
	BMP_CSSDEAD,
	BMP_GREYDINALI,
	BMP_DINALI,
	BMP_GREYGLOBAL,
	BMP_GLOBAL,
	BMP_GREYTEXT,
	BMP_TEXT,
	BMP_GREYIMAGEMAP,
	BMP_IMAGEMAP,
	BMP_GREYDOCUMENT,
	BMP_DOCUMENT,
	BMP_GREYAPPLICATION,
	BMP_APPLICATION,
	BMP_GREYACTIVELAYOUT,
	BMP_ACTIVELAYOUT,
	BMP_GREYIMAGE,
	BMP_IMAGE,
	BMP_GREYAUDIO,
	BMP_AUDIO,
	BMP_GREYVIDEO,
	BMP_VIDEO,
	BMP_GREYXWORLD,
	BMP_XWORLD,
	BMP_FOLDER,
	BMP_OPENFOLDER,
	BMP_PROJNODE,
	BMP_DISABLEDPROJNODE,
	BMP_GREYUNKNOWN,
	BMP_UNKNOWN,
	BMP_DBCONNECTION,
	BMP_NODBCONNECTION,
	BMP_COMPILABLEFILE,
    BMP_SOLUTION,
	// AARDVARK bitmaps start here:
	BMP_REFERENCEFOLDER,
	BMP_OPENREFERENCEFOLDER,
	BMP_REFERENCE,
	BMP_WINFORM,
	BMP_CONTROL,
	BMP_CLASS,
	BMP_VBFILE,
	BMP_CSFILE,
	BMP_XSD,
	BMP_XML,
	BMP_WEBFORM,
	BMP_GLOBALASAX,
	BMP_WEBSERVICE,
	BMP_WEBCONTROL,
	BMP_WEBCUSTOMCONTROL,
	BMP_ASPPAGE,
	BMP_WEBCONFIG,
	BMP_HTML,
	BMP_CSS,
	BMP_BMP,
	BMP_BADREFERENCE,
	BMP_ICO,
	BMP_RESX,
	BMP_SCRIPT,
	BMP_CSPROJNODE,
	BMP_VBPROJNODE,
	BMP_OUTPUTS,
	BMP_SATELLITE,
	BMP_OUTPUTSFOLDER,
	BMP_OPENOUTPUTSFOLDER,
	BMP_SATELLITEFOLDER,
	BMP_OPENSATELLITEFOLDER
};
#define BITMAPIMAGE_X	16
#define IMAGELISTMASKCOLOR RGB(255,0,255)


void GetFromRegistry();

#endif //__BUILDPACKAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\autoproject.cpp ===
// dteproj.cpp
// implementation for CAutoProject

#include "stdafx.h"

#include "AutoProject.h"    
#include "AutoFile.h"    
#include "bldpkg.h"
#include "vcarchy.h"
#include "VCCodeModels.h"
#include "VCDesignerObjectInternal.h"
#include "VCCodeModelsInternal.h"
#include "ResPkg.h"
#include "ResGuid.h"

// for CComSafeArray
#include "atlsafe.h"

CAutoProject::CAutoProject()
{
}

CAutoProject::~CAutoProject()
{
}

void CAutoProject::Initialize(IDispatch* pAutoProjects, IDispatch* pProject)
{
	m_spProject = pProject;
	m_spAutoProjects = pAutoProjects;
	VSASSERT(m_spProject != NULL && m_spAutoProjects != NULL, "Unable to initialize CAutoProject!");
	HRESULT hr = CAutoGlobals::CreateInstance( (CAutoGlobals**)(&m_spGlobals), m_spProject );
	VSASSERT( SUCCEEDED( hr ) && m_spGlobals, "Unable to initialize CAutoProject: Can't create Globals object!");
}


//-----------------------------------------------------------------------------
// create an instance of a project node with reference count 1
//-----------------------------------------------------------------------------
HRESULT CAutoProject::CreateInstance(CAutoProject **ppAutoProject, IDispatch* pAutoProjects, 
	IDispatch* /*pAutoProject*/, IDispatch* pProject)
{
	CComObject<CAutoProject> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CAutoProject>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjObj, E_OUTOFMEMORY);
	pPrjObj->AddRef();
	pPrjObj->Initialize(pAutoProjects, pProject);
	*ppAutoProject = pPrjObj;
	return hr;
}

VCProject* CAutoProject::GetProject()
{
	return (m_spProject);
}

CVCProjectNode* CAutoProject::GetProjectNode()
{
	CComQIPtr<IVCExternalCookie> spExtCookie = m_spProject;
	RETURN_ON_NULL2(spExtCookie, NULL);

	void* pCookie;
	spExtCookie->get_ExternalCookie(&pCookie);
	RETURN_ON_NULL2(pCookie, NULL);

	return (CVCProjectNode*)pCookie;
}

//---------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAutoProject::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID__Project,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CAutoProject::get_Name(BSTR FAR* lpbstrName)
{
	CHECK_ZOMBIE(m_spProject, IDS_ERR_PROJ_ZOMBIE);
	return m_spProject->get_Name(lpbstrName);
}

STDMETHODIMP CAutoProject::put_Name(BSTR bstrName)
{
	CHECK_ZOMBIE(m_spProject, IDS_ERR_PROJ_ZOMBIE);
	return m_spProject->put_Name(bstrName);
}


STDMETHODIMP CAutoProject::get_FileName(BSTR FAR* lpbstrReturn)
{
	CHECK_ZOMBIE(m_spProject, IDS_ERR_PROJ_ZOMBIE);
	return m_spProject->get_ProjectFile(lpbstrReturn);
}

STDMETHODIMP CAutoProject::get_IsDirty(VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_ZOMBIE(m_spProject, IDS_ERR_PROJ_ZOMBIE);
	return m_spProject->get_IsDirty(lpfReturn);
}

STDMETHODIMP CAutoProject::put_IsDirty(VARIANT_BOOL Dirty)
{
	CComQIPtr<IVCProjectImpl> spProjImpl = m_spProject;
	CHECK_ZOMBIE(spProjImpl, IDS_ERR_PROJ_ZOMBIE);

	return spProjImpl->put_IsDirty(Dirty);
}

STDMETHODIMP CAutoProject::get_Collection(Projects FAR* FAR* lppaReturn)
{
	CHECK_POINTER_VALID(lppaReturn);

	CComQIPtr<Projects> spProjects = m_spAutoProjects;
	return spProjects.CopyTo(lppaReturn);
}

STDMETHODIMP CAutoProject::SaveAs(BSTR FileName)
{
	return E_NOTIMPL;	// CAutoProject::SaveAs
}

STDMETHODIMP CAutoProject::get_Globals(Globals ** ppGlobals)
{
	CHECK_POINTER_VALID( ppGlobals );

	CComPtr<Globals> spGlobals = m_spGlobals;
	return spGlobals.CopyTo( ppGlobals );
}
STDMETHODIMP CAutoProject::get_ParentProjectItem(ProjectItem ** ppProjectItem)
{
	CHECK_POINTER_VALID( ppProjectItem );

	*ppProjectItem = NULL;

	VSITEMID itemid = VSITEMID_NIL;
	CVCProjectNode* pProjectNode = GetProjectNode();
	CVCArchy *pArchy = NULL;
	RETURN_ON_NULL2(pProjectNode, NOERROR);
	pArchy = pProjectNode->GetArchy();
	RETURN_ON_NULL2(pArchy, NOERROR);
	itemid = pArchy->GetParentHierarchyItemID();
	CComQIPtr<IVsHierarchy> pHier = pArchy->GetParentHierarchy();
	RETURN_ON_NULL2(pHier, NOERROR);
	CComVariant varExtParent;
	pHier->GetProperty( itemid, VSHPROPID_ExtObject, &varExtParent );
	if( varExtParent.vt != VT_UNKNOWN || !varExtParent.punkVal )
		return NOERROR;
 	CComQIPtr<ProjectItem> pProjectItem = varExtParent.punkVal;
	RETURN_ON_NULL2(pProjectItem, NOERROR);
	pProjectItem.CopyTo( ppProjectItem );

	return NOERROR;
}

STDMETHODIMP CAutoProject::get_DTE(DTE FAR* FAR* lppaReturn)
{
	return GetBuildPkg()->GetDTE(lppaReturn);
}

STDMETHODIMP CAutoProject::get_Kind(BSTR FAR* lpbstrFileName)
{
	CHECK_POINTER_VALID(lpbstrFileName);

	CComBSTR bstr = L"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}";
	*lpbstrFileName = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CAutoProject::get_ProjectItems(ProjectItems FAR* FAR* lppcReturn)
{
	CHECK_POINTER_VALID(lppcReturn);
	CHECK_ZOMBIE(m_spProject, IDS_ERR_PROJ_ZOMBIE);

	CComPtr<IDispatch> spDispItems;
	HRESULT hr = m_spProject->get_Items(&spDispItems);
	RETURN_ON_FAIL_OR_NULL2(hr, spDispItems, E_UNEXPECTED);

	CAutoItems *pAutoItems = NULL;
	hr = CAutoItems::CreateInstance(&pAutoItems, this, this, spDispItems);
	RETURN_ON_FAIL_OR_NULL(hr, pAutoItems);
	*lppcReturn = (ProjectItems *)pAutoItems;
	return hr;
}

STDMETHODIMP CAutoProject::get_Properties(Properties FAR* FAR* ppObject)
{
	return DoGetProperties(this, m_spProject, ppObject);
}

STDMETHODIMP CAutoProject::get_UniqueName(BSTR FAR* lpbstrFileName)
{
	CHECK_POINTER_VALID(lpbstrFileName);

	CComPtr<IVsSolution> spVsSolution;

	HRESULT hr = GetBuildPkg()->GetIVsSolution(&spVsSolution);
	VSASSERT(SUCCEEDED(hr), "Unable to QueryService for IVsSolution!  (Are we in a secondary thread?)");
	RETURN_ON_FAIL_OR_NULL(hr, spVsSolution);

	CVCProjectNode* pProjectNode = GetProjectNode();
	CVCArchy *pArchy = NULL;
	if (pProjectNode != NULL)
		pArchy = pProjectNode->GetArchy();
	CHECK_ZOMBIE(pArchy, IDS_ERR_PROJ_ZOMBIE);

	CComPtr<IVsHierarchy> spHier = pArchy->GetIVsHierarchy();
	return spVsSolution->GetUniqueNameOfProject(spHier, lpbstrFileName);
}

STDMETHODIMP CAutoProject::get_Object(IDispatch **ppProjectModel)
{
	return DoGetObject(m_spProject, ppProjectModel, IDS_ERR_PROJ_ZOMBIE);
}

STDMETHODIMP CAutoProject::get_Extender(BSTR bstrExtenderName, IDispatch **ppExtender)
{
	return DoGetExtender(this, bstrExtenderName, ppExtender);
}

STDMETHODIMP CAutoProject::get_ExtenderNames(VARIANT *pvarExtenderNames)
{
	return DoGetExtenderNames(this, pvarExtenderNames);
}

STDMETHODIMP CAutoProject::get_ExtenderCATID(BSTR *pbstrRetval)
{
	return DoGetExtenderCATID(pbstrRetval);
}

STDMETHODIMP CAutoProject::get_FullName(BSTR *lpbstrReturn)
{
	return get_FileName(lpbstrReturn);
}

STDMETHODIMP CAutoProject::get_Saved(VARIANT_BOOL *lpfReturn)
{
	return get_IsDirty(lpfReturn);
}

STDMETHODIMP CAutoProject::put_Saved(VARIANT_BOOL Dirty)
{
	return put_IsDirty(Dirty);
}

STDMETHODIMP CAutoProject::get_SourceControl(SourceControl ** /*ppSourceControl*/)
{
	return E_NOTIMPL;	// CAutoProject::get_SourceControl
}

STDMETHODIMP CAutoProject::Save(BSTR /*FileName*/)
{
	return E_NOTIMPL;		// CAutoProject::Save
}

STDMETHODIMP CAutoProject::get_ConfigurationManager(ConfigurationManager **ppConfigurationManager)
{
	CHECK_POINTER_VALID(ppConfigurationManager);
	CVCProjectNode* pProjectNode = GetProjectNode();
	CVCArchy *pArchy = NULL;
	if (pProjectNode)
		pArchy = pProjectNode->GetArchy();
	CHECK_ZOMBIE(pArchy, IDS_ERR_PROJ_ZOMBIE);

	CComPtr<IVsExtensibility> pExtService;
	HRESULT hr = ExternalQueryService(SID_SVsExtensibility, IID_IVsExtensibility, (LPVOID*)&pExtService);
	RETURN_ON_FAIL_OR_NULL(hr, pExtService);

	CComPtr<IVsHierarchy> spHier = pArchy->GetIVsHierarchy();
	return pExtService->GetConfigMgr(spHier, VSITEMID_ROOT, ppConfigurationManager);
}

STDMETHODIMP CAutoProject::get_CodeModel(CodeModel ** ppCodeModel)
{
	CHECK_POINTER_VALID(ppCodeModel);

	HRESULT hr(S_OK);
	CComBSTR bstrProjName;
	get_Name(&bstrProjName);
	if (bstrProjName.Length() == 0)
		CHECK_ZOMBIE(NULL, IDS_ERR_PROJ_ZOMBIE);
	CComPtr<IDispatch> spDispProject;
	hr = QueryInterface(__uuidof(IDispatch), reinterpret_cast<void **>(&spDispProject));
	RETURN_ON_FAIL(hr);
	CComPtr<VCCodeModelService> spIVCCodeModelService;
	hr = ExternalQueryService(SID_SVCCodeModelService,
		__uuidof(VCCodeModelService), reinterpret_cast<void **>(&spIVCCodeModelService));
	RETURN_ON_FAIL_OR_NULL(hr, spIVCCodeModelService);
	CComPtr<VCCodeModel> spVCCodeModel;
	hr = spIVCCodeModelService->CreateCodeModel(&spVCCodeModel);
	RETURN_ON_FAIL_OR_NULL(hr, spVCCodeModel);
	CComPtr<VCDesignElementI> spCodeModel;
	hr = spVCCodeModel.QueryInterface(&spCodeModel);
	RETURN_ON_FAIL(hr);
	spCodeModel->put_Parent(spDispProject);

	return spVCCodeModel.QueryInterface(ppCodeModel);
}

STDMETHODIMP CAutoProject::Delete()
{
	return E_NOTIMPL;	// CAutoProject::Delete, don't allow this from UI, so no point in allowing from automation, either
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CAutoProjects

CAutoProjects::CAutoProjects()
{
}

CAutoProjects::~CAutoProjects()
{
}

void CAutoProjects::Initialize(IDispatch* pProjects)
{
	VSASSERT(pProjects != NULL, "Cannot initialize CAutoProjects with NULL!");
	m_spProjects = pProjects;
}

//-----------------------------------------------------------------------------
// create an instance of a project node with reference count 1
//-----------------------------------------------------------------------------
HRESULT CAutoProjects::CreateInstance(CAutoProjects **ppAutoProjects, IDispatch* pProjects)
{
	CComObject<CAutoProjects> *pPrjsObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CAutoProjects>::CreateInstance(&pPrjsObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjsObj, E_OUTOFMEMORY);
	pPrjsObj->AddRef();
	pPrjsObj->Initialize(pProjects);
	*ppAutoProjects = pPrjsObj;
	return hr;
}

STDMETHODIMP CAutoProjects::Item(VARIANT index, Project** lppcReturn)
{
	CHECK_POINTER_VALID(lppcReturn);
	*lppcReturn = NULL;

	CHECK_ZOMBIE(m_spProjects, IDS_ERR_COLLECTION_ZOMBIE);

	CComPtr<IDispatch> spItem;
	HRESULT hr = m_spProjects->Item(index, &spItem);
	RETURN_ON_FAIL_OR_NULL2(hr, spItem, S_FALSE);

	CComPtr<IDispatch> spDispAutoProject;
	hr = GetItem(&spDispAutoProject, this, NULL, NULL, spItem);
	RETURN_ON_FAIL(hr);
	CComQIPtr<Project> spAutoProject = spDispAutoProject;
	*lppcReturn = spAutoProject.Detach();
	return hr;
}

/* static */
HRESULT CAutoProjects::GetItem(IDispatch** ppProjItem, IDispatch* pOwner, IDispatch* pAutoProjectParent, 
	IDispatch* pAutoProjectParent2, IDispatch* pVCItem)
{
	CAutoProject* pAutoProject = NULL;
	HRESULT hr = CAutoProject::CreateInstance(&pAutoProject, pOwner, pAutoProjectParent, pVCItem);
	RETURN_ON_FAIL(hr);
	
	*ppProjItem = (IDispatch*)pAutoProject;
	return S_OK;
}

STDMETHODIMP CAutoProjects::get_Parent(DTE** lppaReturn)
{
	CHECK_POINTER_VALID(lppaReturn);
	return ExternalQueryService(SID_SDTE, IID__DTE, (void **)lppaReturn);
}

STDMETHODIMP CAutoProjects::get_Count(long* lplReturn)
{
	CHECK_POINTER_VALID(lplReturn);
	CHECK_ZOMBIE(m_spProjects, IDS_ERR_COLLECTION_ZOMBIE);

	return m_spProjects->get_Count(lplReturn);
}

STDMETHODIMP CAutoProjects::_NewEnum(IUnknown** lppiuReturn)
{
	CHECK_POINTER_VALID(lppiuReturn);
	*lppiuReturn = NULL;
	CHECK_ZOMBIE(m_spProjects, IDS_ERR_COLLECTION_ZOMBIE);

	CAutoEnumerator<CAutoProjects>* pEnumerator = NULL;
	HRESULT hr = CAutoEnumerator<CAutoProjects>::CreateInstance(&pEnumerator, this, NULL, NULL, m_spProjects);
	RETURN_ON_FAIL_OR_NULL2(hr, pEnumerator, E_OUTOFMEMORY);

	hr = pEnumerator->QueryInterface(__uuidof(IUnknown), (LPVOID *)lppiuReturn);
	pEnumerator->Release();	// QI above gives us the refcount of 1 we want...
	return hr;
}

STDMETHODIMP CAutoProjects::get_DTE(DTE** lppaReturn)
{
	return GetBuildPkg()->GetDTE(lppaReturn);
}

STDMETHODIMP CAutoProjects::get_Properties(Properties** ppObject)
{
	return DoGetProperties(this, m_spProjects, ppObject);
}

STDMETHODIMP CAutoProjects::get_Kind(BSTR* lpbstrReturn)
{
	CHECK_POINTER_VALID(lpbstrReturn);

	CComBSTR bstrKind = L"{26FE99B0-8BBA-4436-83FC-B546C6FD3EDC}";
	*lpbstrReturn = bstrKind.Detach();
	return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CAutoGlobals
//////////////////////////////////////////////////////////////////////

CAutoGlobals::CAutoGlobals()
{
}

CAutoGlobals::~CAutoGlobals()
{
}

void CAutoGlobals::Initialize( VCProject *pProj )
{
	// get pointers to the globals data items from the project
	CComQIPtr<IVCProjectImpl> pProjImpl = pProj;
	VSASSERT( pProjImpl, "VCProject object doesn't support IVCProjectImpl! This shouldn't be possible" );
	HRESULT hr = pProjImpl->GetGlobals( &m_spGlobals );
	VSASSERT( SUCCEEDED( hr ) && m_spGlobals, "GetGlobals on project failed" );
}

//-----------------------------------------------------------------------------
// create an instance with reference count 1
//-----------------------------------------------------------------------------
HRESULT CAutoGlobals::CreateInstance( CAutoGlobals **ppAutoGlobals, VCProject *pProj )
{
	CComObject<CAutoGlobals> *pObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CAutoGlobals>::CreateInstance( &pObj );
	RETURN_ON_FAIL_OR_NULL2(hr, pObj, E_OUTOFMEMORY);
	pObj->AddRef();
	pObj->Initialize( pProj );
	*ppAutoGlobals = pObj;
	return hr;
}

STDMETHODIMP CAutoGlobals::get_DTE( DTE **ppDTE )
{
	return GetBuildPkg()->GetDTE(ppDTE);
}

STDMETHODIMP CAutoGlobals::get_Parent( IDispatch **ppDTE )
{
	CHECK_POINTER_VALID( ppDTE );
	return ExternalQueryService( SID_SDTE, IID__DTE, (void **)ppDTE );
}

STDMETHODIMP CAutoGlobals::get_VariableValue( BSTR name, VARIANT *pVal )
{
	CHECK_ZOMBIE(m_spGlobals, IDS_ERR_GLOBALS_ZOMBIE);
	CHECK_POINTER_VALID(pVal);
	CComBSTR bstrValue;
	HRESULT hr = m_spGlobals->GetValue( name, &bstrValue );
	if( SUCCEEDED( hr ) )
	{
		CComVariant varRet( bstrValue );
		varRet.Detach( pVal );
	}
	return hr;
}

STDMETHODIMP CAutoGlobals::put_VariableValue( BSTR name, VARIANT val )
{
	CHECK_ZOMBIE(m_spGlobals, IDS_ERR_GLOBALS_ZOMBIE);
	return m_spGlobals->SetValue( name, val.bstrVal );
}

STDMETHODIMP CAutoGlobals::get_VariablePersists( BSTR name, VARIANT_BOOL *pbVal )
{
	CHECK_ZOMBIE(m_spGlobals, IDS_ERR_GLOBALS_ZOMBIE);
	CHECK_POINTER_VALID(pbVal);
	return m_spGlobals->GetPersistance( name, pbVal );
}

STDMETHODIMP CAutoGlobals::put_VariablePersists( BSTR name, VARIANT_BOOL bVal )
{
	CHECK_ZOMBIE(m_spGlobals, IDS_ERR_GLOBALS_ZOMBIE);
	return m_spGlobals->SetPersistance( name, bVal );
}

STDMETHODIMP CAutoGlobals::get_VariableExists( BSTR name, VARIANT_BOOL *pbVal )
{
	CHECK_ZOMBIE(m_spGlobals, IDS_ERR_GLOBALS_ZOMBIE);
	CHECK_POINTER_VALID(pbVal);
	CComBSTR bstrVal;
	HRESULT hr = m_spGlobals->GetValue( name, &bstrVal );
	if( FAILED( hr ) )
		*pbVal = VARIANT_FALSE;
	else
		*pbVal = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CAutoGlobals::get_VariableNames( VARIANT *pNames )
{
	CHECK_ZOMBIE(m_spGlobals, IDS_ERR_GLOBALS_ZOMBIE);
	CHECK_POINTER_VALID(pNames);

	// get the number of elements (names)
	unsigned long n;
	m_spGlobals->GetCount( &n );
	// create a safe array variant (single dim, of BSTRs)
	CComSafeArray<BSTR> rgNames( n );
	// get all the names
	int i = 0;
	CComBSTR bstrName, bstrValue;
	HRESULT hr = m_spGlobals->GetFirstItem( &bstrName, &bstrValue );
	if( SUCCEEDED( hr ) )
		rgNames.SetAt( i, bstrName );
	else 
	{
		// no items
		return S_OK;
	}
	bstrName.Empty();
	bstrValue.Empty();
	while( SUCCEEDED( m_spGlobals->GetNextItem( &bstrName, &bstrValue ) ) )
	{
		// release our bstrs each time
		rgNames.SetAt( ++i, bstrName );
		bstrName.Empty();
		bstrValue.Empty();
	}
	pNames->vt = VT_ARRAY | VT_BSTR;
	pNames->parray = rgNames.Detach();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\bldtst.cpp ===
// BldPkg.cpp : Implementation of CBuildPackage
#include "stdafx.h"
#include "bldpkg.h"
#include "path2.h"

void TShellPrint( wchar_t *pStr )
{
	CComPtr<IVsTshell> pVsTshell;
	if ((SUCCEEDED(ExternalQueryService(SID_SVsTshell, IID_IVsTshell, (void **)&pVsTshell))) && (pVsTshell != NULL))
	{
		pVsTshell->DebOutputStringW(pStr);
	}
}

STDMETHODIMP PrjBuild(unsigned argc, char **rgsz)
{
    if (argc != 0) 
	{
		RETURN_INVALID();
	}
    else 
	{
		CComPtr<IVsUIShell> pVsUIShell;
		if (SUCCEEDED(GetBuildPkg()->GetVsUIShell(&pVsUIShell, TRUE /* in main thread */)) && pVsUIShell != NULL)
		{
			pVsUIShell->PostExecCommand(&CLSID_StandardCommandSet97, cmdidBuildSln, NULL, NULL);
		}
        return S_OK;
	}
}

STDMETHODIMP PrjClean(unsigned argc, char **rgsz)
{
    if (argc != 0) 
	{
		RETURN_INVALID();
	}
    else 
	{
		CComPtr<IVsUIShell> pVsUIShell;
		if (SUCCEEDED(GetBuildPkg()->GetVsUIShell(&pVsUIShell, TRUE /* in main thread */)) && pVsUIShell != NULL)
		{
			pVsUIShell->PostExecCommand(&CLSID_StandardCommandSet97, cmdidCleanSln, NULL, NULL);
		}
        return S_OK;
	}
}

STDMETHODIMP PrjShowOutput(unsigned argc, char **rgsz)
{
    if (argc != 0) 
	{
		RETURN_INVALID();
	}
    else 
	{
		CComPtr<IVsUIShell> pVsUIShell;
		if (SUCCEEDED(GetBuildPkg()->GetVsUIShell(&pVsUIShell, TRUE /* in main thread */)) && pVsUIShell != NULL)
		{
			pVsUIShell->PostExecCommand(&CLSID_StandardCommandSet97, cmdidOutputWindow, NULL, NULL);
		}
        return S_OK;
	}
}

STDMETHODIMP PrjWaitBuild(unsigned argc, char **rgsz)
{
    if (argc != 0) 
	{
		RETURN_INVALID();
	}
    else 
	{
		CComPtr<_DTE> pDTE;
		if( SUCCEEDED(ExternalQueryService(SID_SDTE, IID__DTE, (void **)&pDTE )) && pDTE != NULL )
		{
			HRESULT hr;
			CComPtr<_Solution> pSln = NULL;
			CComPtr<SolutionBuild> pSlnBld;

			hr = pDTE->get_Solution((Solution**)&pSln);
			hr = pSln->get_SolutionBuild( &pSlnBld );
			vsBuildState enumBldState = vsBuildStateInProgress;
			while( enumBldState == vsBuildStateInProgress )
			{
				// Query the SolutionBuild object every second for the build status
				hr = pSlnBld->get_BuildState( &enumBldState );
				Sleep( 1000 );
			}
		}
        return S_OK;
	}
}

STDMETHODIMP PrjFileExists(unsigned argc, char **rgsz)
{
    if (argc != 1)
	{
		RETURN_INVALID();
	}
    else
	{
		CStringW strFilename = rgsz[0];
		CPathW path;
		path.Create(strFilename);
	
		if(path.ExistsOnDisk())
			TShellPrint( L"YES\n" );
		else
			TShellPrint( L"NO\n" );
        return S_OK;
	}
}

const TSHELL_CMD g_rgcmdsDbg[] =
{
    {"VCPrjBuildSln", (PfnTshell)PrjBuild, "'VCPrjBuildSln' builds the solution"},
    {"VCPrjCleanSln", (PfnTshell)PrjClean, "'VCPrjCleanSln' Cleans the solution"},
    {"VCPrjShowOutput", (PfnTshell)PrjShowOutput, "'VCPrjShowOutput' SHows the Ouput Window"},
    {"VCPrjFileExists", (PfnTshell)PrjFileExists, "'VCPrjFileExists' Tests If file exists on disk"}
};

void InitTShell()
{
	CComPtr<IVsTshell> pVsTshell;
	if ((SUCCEEDED(ExternalQueryService(SID_SVsTshell, IID_IVsTshell, (void **)&pVsTshell))) && (pVsTshell != NULL))
	{
		pVsTshell->AddCmdTable(sizeof(g_rgcmdsDbg) / sizeof(TSHELL_CMD), g_rgcmdsDbg);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\convertdlg.h ===
// ConvertDlg.h : Declaration of the CConvertDlg

#ifndef __CONVERTDLG_H_
#define __CONVERTDLG_H_

#include <atlhost.h>
#include <multimon.h>

void WINAPI ClipOrCenterRectToMonitor(LPRECT prc);

/////////////////////////////////////////////////////////////////////////////
// CConvertDlg
class CConvertDlg : 
	public CAxDialogImpl<CConvertDlg>
{
public:
	CConvertDlg( LPCOLESTR szProject )
	{
		m_strProject = szProject;
	}

	~CConvertDlg()
	{
	}

	enum { IDD = IDD_CONVERTDLG };

BEGIN_MSG_MAP(CConvertDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_CLOSE, OnClose)
	COMMAND_ID_HANDLER(IDC_YESBUTTON, OnYes)
	COMMAND_ID_HANDLER(IDC_NOBUTTON, OnNo)
	COMMAND_ID_HANDLER(IDC_YESTOALL, OnAll)
	COMMAND_ID_HANDLER(IDC_NOTOALL, OnNone)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		s_bCancel = TRUE;
		EndDialog(0);
		return 1;
	}

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		s_bCancel = FALSE;
		CWindow wndText = GetDlgItem(IDC_CONVERTMSG);
		CStringW strTextW;
		strTextW.Format(IDS_CONVERTMSG, m_strProject);
		
		CString strText = strTextW;
		wndText.SetWindowText(strText);

		RECT rc;
	    GetWindowRect(&rc);
   		ClipOrCenterRectToMonitor(&rc);
	    SetWindowPos(NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

		return 1;  // Let the system set the focus
	}

	LRESULT OnYes(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		EndDialog(wID);
		return 0;
	}

	LRESULT OnNo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		s_bCancel = TRUE;
		EndDialog(wID);
		return 0;
	}

	LRESULT OnAll(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		s_bConvertAll = TRUE;
		s_bConvertNone = FALSE;
		EndDialog(wID);
		return 0;
	}

	LRESULT OnNone(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		s_bCancel = TRUE;
		s_bConvertNone = TRUE;
		s_bConvertAll = FALSE;
		EndDialog(wID);
		return 0;
	}

	CStringW m_strProject;
	static BOOL s_bConvertAll;
	static BOOL s_bConvertNone;
	static BOOL s_bCancel;
};

//
//  ClipOrCenterRectToMonitor
//
//  The most common problem apps have when running on a
//  multimonitor system is that they "clip" or "pin" windows
//  based on the SM_CXSCREEN and SM_CYSCREEN system metrics.
//  Because of app compatibility reasons these system metrics
//  return the size of the primary monitor.
//
//  This shows how you use the new Win32 multimonitor APIs
//  to do the same thing.
//
void WINAPI ClipOrCenterRectToMonitor(LPRECT prc)
{

    RECT        rc;

	CComPtr<IVsUIShell> pUIShell;
	HWND hwnd;
	HRESULT hr;
	hr = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
	if (SUCCEEDED(hr) && pUIShell)
	{
		hr = pUIShell->GetDialogOwnerHwnd(&hwnd);
	}
	::GetWindowRect(hwnd, &rc);
	
    int         w = prc->right  - prc->left;
    int         h = prc->bottom - prc->top;

    //
    // center or clip the passed rect to the monitor rect
    //
	prc->left   = rc.left + (rc.right  - rc.left - w) / 2;
	prc->top    = rc.top  + (rc.bottom - rc.top  - h) / 2;
	prc->right  = prc->left + w;
	prc->bottom = prc->top  + h;
}
#endif //__CONVERTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\bldtst.h ===
// BldPkg.cpp : Implementation of CBuildPackage


void InitTShell();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\directoriesdlg.h ===
// BuildOptions.h : Declaration of the CDirectoriesDlg

#ifndef __DIRSDLG_H_
#define __DIRSDLG_H_

#include "rsrc.h"       // main symbols
#undef WM_OCC_LOADFROMSTREAM
#undef WM_OCC_LOADFROMSTORAGE         
#undef WM_OCC_INITNEW                 
#undef WM_OCC_LOADFROMSTREAM_EX       
#undef WM_OCC_LOADFROMSTORAGE_EX      

#include <atlhost.h>

#include "DirControl.h"

enum DIRLIST_TYPE
{
	DIRLIST_PATH = 0,
	DIRLIST_INC = 1,
	DIRLIST_REF = 2,
	DIRLIST_LIB = 3,
	DIRLIST_SRC = 4,
	C_DIRLIST_TYPES = 5
};

struct sPathBlock
{
	CComBSTR m_platformName;
	CComBSTR m_dirLists[C_DIRLIST_TYPES]; 		// path, inc, ref, lib, src
	
};

#define _MAX_PLATFORMS 6

/////////////////////////////////////////////////////////////////////////////
// CDirectoriesDlg
class CDirectoriesDlg : 
	public CAxDialogImpl<CDirectoriesDlg>
{
public:
	CDirectoriesDlg();
	~CDirectoriesDlg();

	enum { IDD = IDDP_OPTIONS_DIRECTORIES };

BEGIN_MSG_MAP(CDirectoriesDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_SETFONT, OnFont)
	MESSAGE_HANDLER( WM_SIZE, OnSize )
  	NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)	
	NOTIFY_CODE_HANDLER(PSN_HELP, OnHelp)
	COMMAND_HANDLER(IDC_DIRS_TYPE, CBN_SELCHANGE, OnSelChangeDirOptions)
	COMMAND_HANDLER(IDC_DIRS_TOOLSETS, CBN_SELCHANGE, OnSelChangeDirToolset)
	CHAIN_MSG_MAP(CAxDialogImpl<CDirectoriesDlg>)
END_MSG_MAP()


//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnFont(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

	LRESULT OnSelChangeDirOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSelChangeDirToolset(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	
	LRESULT OnCheckEntries(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCheckEntriesDblClk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnHelp(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	static HRESULT WritePathsToRegistry( void );

protected:
	static HRESULT GetPlatformsEnumerator(IEnumVARIANT** ppEnum);

	void ResetListbox();
	void FillOptionsList();
	void RetrieveListboxInfo(int nToolset, DIRLIST_TYPE type);
	void CleanUpString(int nToolset, DIRLIST_TYPE type);
	void LoadTitle(UINT idDesc, BSTR *bstrName);
	void LoadDescription(UINT idDesc, BSTR *bstrDesc);
	void DoOnSize();

	int		m_nToolset;		// Current 'toolset' selected.
	int		m_nLastToolset;		// Last 'toolset' selected

	DIRLIST_TYPE m_type;		// Current DIRLIST_TYPE selected.
	DIRLIST_TYPE m_LastType;	// Last DIRLIST_TYPE selected.

	sPathBlock m_pathBlockList[ _MAX_PLATFORMS ];
	CComBSTR m_strDescription[C_DIRLIST_TYPES]; // path, inc, lib, src	- Review FIXME Im ANSI
	CComBSTR m_strName[C_DIRLIST_TYPES];	// friendly name for directory list -- yes, ANSI

	CWindow m_listDirs;
	CAxWindow m_wndDirList;
	CComPtr<IDirList> m_pList;
};

#endif //__DIRSDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\dataobject.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "DataObject.h"
#include "PrjNode.h"
#include "vcarchy.h"
#include "bldpkg.h"

//---------------------------------------------------------------------------
// Clipboard stuff
//---------------------------------------------------------------------------

#define PROJECTCLIPDESCRIPTOR L"VX Clipboard Descriptor Format"
#define HTMLFORMAT            L"HTML Format"

// Register clip formats
CLIPFORMAT CVCProjDataSource::s_cfProjectDescriptor = RegisterClipboardFormatW(PROJECTCLIPDESCRIPTOR);
CLIPFORMAT CVCProjDataSource::s_cfStgProjItems = CF_VSSTGPROJECTITEMS;
CLIPFORMAT CVCProjDataSource::s_cfRefProjItems = CF_VSREFPROJECTITEMS;

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataSource implementation

struct VC_DATACACHE_ENTRY
{
	FORMATETC m_formatEtc;
	STGMEDIUM m_stgMedium;
	DATADIR m_nDataDir;
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
class CVCCopyFormatEtc
{
public:
	static void init(FORMATETC *p)
	{
		p->cfFormat	= 0;
		p->ptd		= NULL;
		p->dwAspect	= 0;
		p->lindex	= 0;
		p->tymed	= 0;
	}
	static HRESULT copy(FORMATETC *pTo, FORMATETC *pFrom)
	{
		pTo->cfFormat	= pFrom->cfFormat;
		pTo->ptd		= _VCOleCopyTargetDevice(pFrom->ptd);
		pTo->dwAspect	= pFrom->dwAspect;
		pTo->lindex		= pFrom->lindex;
		pTo->tymed		= pFrom->tymed;
		return S_OK;
	}
	static void destroy(FORMATETC *p)
	{
		ASSERT(NULL != p);
		CoTaskMemFree(p->ptd);
	}
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
class CVCEnumFormatEtc :
	 public CComEnum<IEnumFORMATETC, &IID_IEnumFORMATETC, FORMATETC, CVCCopyFormatEtc, CComSingleThreadModel>
{
protected:
	virtual ~CVCEnumFormatEtc(void) { };

public:
	CVCEnumFormatEtc(void);

	void AddFormat(const FORMATETC* lpFormatEtc);

protected:
	DWORD m_nSize, m_nMaxSize;
};

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
CVCEnumFormatEtc::CVCEnumFormatEtc(void) : m_nSize(0), m_nMaxSize(0)
{
	m_dwFlags |= BitOwn;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void CVCEnumFormatEtc::AddFormat(const FORMATETC* lpFormatEtc)
{
	ASSERT(m_nSize <= m_nMaxSize);

	if (m_nSize == m_nMaxSize)
	{
		// not enough space for new item -- allocate more
		FORMATETC* pListNew = new FORMATETC[m_nSize+10];
		m_nMaxSize += 10;
		memcpy(pListNew, m_begin, m_nSize*sizeof(FORMATETC));
		m_iter = (m_iter - m_begin) + pListNew;
		delete m_begin;
		m_begin = pListNew;
		m_end = m_begin + m_nSize;
	}

	// add this item to the list
	ASSERT(m_nSize < m_nMaxSize);
	FORMATETC* pFormat = &m_begin[m_nSize];
	pFormat->cfFormat = lpFormatEtc->cfFormat;
	pFormat->ptd = lpFormatEtc->ptd;

	// Note: ownership of lpFormatEtc->ptd is transfered with this call.
	pFormat->dwAspect = lpFormatEtc->dwAspect;
	pFormat->lindex = lpFormatEtc->lindex;
	pFormat->tymed = lpFormatEtc->tymed;
	++m_nSize;
	++m_end;
}

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataObject constructors

CVCOleDataObject::CVCOleDataObject()
{
	m_lpEnumerator = NULL;
	m_lpDataObject = NULL;
	m_bAutoRelease = TRUE;
	m_bClipboard = FALSE;
}

CVCOleDataObject::~CVCOleDataObject()
{
	Release();
}

void CVCOleDataObject::Attach(LPDATAOBJECT lpDataObject, BOOL bAutoRelease)
{
	ASSERT(lpDataObject != NULL);

	Release();  // detach previous
	m_lpDataObject = lpDataObject;
	m_bAutoRelease = bAutoRelease;
}

void CVCOleDataObject::Release()
{
	if (m_lpEnumerator != NULL)
	{
		m_lpEnumerator->Release();
		m_lpEnumerator = NULL;
	}

	if (m_lpDataObject != NULL)
	{
		if (m_bAutoRelease)
			m_lpDataObject->Release();
		m_lpDataObject = NULL;
	}
	m_bClipboard = FALSE;
}

LPDATAOBJECT CVCOleDataObject::Detach()
{
	EnsureClipboardObject();

	LPDATAOBJECT lpDataObject = m_lpDataObject;
	m_lpDataObject = NULL;  // detach without Release
	m_bClipboard = FALSE;

	return lpDataObject;
}

LPDATAOBJECT CVCOleDataObject::GetIDataObject(BOOL bAddRef)
{
	EnsureClipboardObject();

	LPDATAOBJECT lpDataObject = m_lpDataObject;
	if (bAddRef && lpDataObject != NULL)
		lpDataObject->AddRef();

	return lpDataObject;
}

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataObject attributes

void CVCOleDataObject::BeginEnumFormats()
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);

	// release old enumerator
	if (m_lpEnumerator)
	{
		m_lpEnumerator->Release();
		m_lpEnumerator = NULL;
	}

	if (m_lpDataObject == NULL)
		return;

	// get the new enumerator
	SCODE sc = m_lpDataObject->EnumFormatEtc(DATADIR_GET, &m_lpEnumerator);
	ASSERT(sc != S_OK || m_lpEnumerator != NULL);
	sc;
}

BOOL CVCOleDataObject::GetNextFormat(LPFORMATETC lpFormatEtc)
{
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	ASSERT(VCIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// return FALSE if enumerator is already NULL
	RETURN_ON_NULL2(m_lpEnumerator, FALSE);

	// attempt to retrieve the next format with the enumerator
	SCODE sc = m_lpEnumerator->Next(1, lpFormatEtc, NULL);

	// if enumerator fails, stop the enumeration
	if (sc != S_OK)
	{
		if (m_lpEnumerator)
		{
			m_lpEnumerator->Release();
			m_lpEnumerator = NULL;
		}
		return FALSE;   // enumeration has ended
	}
	// otherwise, continue
	return TRUE;
}

CVCFile* CVCOleDataObject::GetFileData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	RETURN_ON_NULL2(m_lpDataObject, NULL);

	ASSERT(lpFormatEtc == NULL ||
		VCIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _VCFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	formatEtc.tymed = TYMED_FILE|TYMED_MFPICT|TYMED_HGLOBAL|TYMED_ISTREAM;

	// attempt to get the data
	STGMEDIUM stgMedium;
	SCODE sc = m_lpDataObject->GetData(lpFormatEtc, &stgMedium);
	if (FAILED(sc))
		return NULL;

	// STGMEDIUMs with pUnkForRelease need to be copied first
	if (stgMedium.pUnkForRelease != NULL)
	{
		STGMEDIUM stgMediumDest;
		stgMediumDest.tymed = TYMED_NULL;
		stgMediumDest.pUnkForRelease = NULL;
		if (!_VCCopyStgMedium(lpFormatEtc->cfFormat, &stgMediumDest, &stgMedium))
		{
			::ReleaseStgMedium(&stgMedium);
			return NULL;
		}
		// release original and replace with new
		::ReleaseStgMedium(&stgMedium);
		stgMedium = stgMediumDest;
	}

	// convert it to a file, depending on data
	CStringA strFileName;
	CVCFile* pFile = NULL;
	{
		switch (stgMedium.tymed)
		{
		case TYMED_FILE:
			strFileName = stgMedium.lpszFileName;
			pFile = new CVCFile;
			if (!pFile->Open(strFileName,
				CVCFile::modeReadWrite|CVCFile::shareExclusive))
			{
				delete pFile;
				pFile = NULL;
				break;
			}
			// caller is responsible for deleting the actual file,
			//  but we free the file name.
			CoTaskMemFree(stgMedium.lpszFileName);
			break;

		case TYMED_MFPICT:
		case TYMED_HGLOBAL:
			ASSERT(!_T("port CSharedFile"));
			pFile = new CVCSharedFile;
			((CVCSharedFile*)pFile)->SetHandle(stgMedium.hGlobal);
			break;

		case TYMED_ISTREAM:
			ASSERT(!_T("port COleStreamFile"));
#if 0
			pFile = new COleStreamFile(stgMedium.pstm);
#endif
			break;

		default:
			// type not supported, so return error
			::ReleaseStgMedium(&stgMedium);
			break;
		}
	}
	// store newly created CVCFile* and return
	return pFile;
}

HGLOBAL CVCOleDataObject::GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	RETURN_ON_NULL2(m_lpDataObject, NULL);

	ASSERT(lpFormatEtc == NULL || VCIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	BOOL bFillFormatEtc = (lpFormatEtc == NULL);
	lpFormatEtc = _VCFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	if (bFillFormatEtc)
		lpFormatEtc->tymed = TYMED_HGLOBAL|TYMED_MFPICT;
	ASSERT((lpFormatEtc->tymed & (TYMED_HGLOBAL|TYMED_MFPICT)) != 0);

	// attempt to get the data
	STGMEDIUM stgMedium;
	SCODE sc = m_lpDataObject->GetData(lpFormatEtc, &stgMedium);
	if (FAILED(sc))
		return FALSE;

	// handle just hGlobal types
	switch (stgMedium.tymed)
	{
	case TYMED_MFPICT:
	case TYMED_HGLOBAL:
		RETURN_ON_NULL2(stgMedium.pUnkForRelease, stgMedium.hGlobal);
		STGMEDIUM stgMediumDest;
		stgMediumDest.tymed = TYMED_NULL;
		stgMediumDest.pUnkForRelease = NULL;
		if (!_VCCopyStgMedium(lpFormatEtc->cfFormat, &stgMediumDest, &stgMedium))
		{
			::ReleaseStgMedium(&stgMedium);
			return NULL;
		}
		::ReleaseStgMedium(&stgMedium);
		return stgMediumDest.hGlobal;

	// default -- falls through to error condition...
	}

	::ReleaseStgMedium(&stgMedium);
	return NULL;
}

BOOL CVCOleDataObject::GetData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
	LPFORMATETC lpFormatEtc)
{
	EnsureClipboardObject();
	ASSERT(m_bClipboard || m_lpDataObject != NULL);
	RETURN_ON_NULL2(m_lpDataObject, FALSE);
	ASSERT(VCIsValidAddress(lpStgMedium, sizeof(STGMEDIUM), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _VCFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

	// attempt to get the data
	SCODE sc = m_lpDataObject->GetData(lpFormatEtc, lpStgMedium);
	if (FAILED(sc))
		return FALSE;

	return TRUE;
}

BOOL CVCOleDataObject::IsDataAvailable(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	if (m_bClipboard)
	{
		// it is faster and more reliable to ask the real Win32 clipboard
		//  instead of the OLE clipboard.
		return ::IsClipboardFormatAvailable(cfFormat);
	}
	else
	{
		ASSERT(m_lpDataObject != NULL);
		ASSERT(lpFormatEtc == NULL || VCIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

		// fill in FORMATETC struct
		FORMATETC formatEtc;
		lpFormatEtc = _VCFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);

		// attempt to get the data
		return m_lpDataObject->QueryGetData(lpFormatEtc) == S_OK;
	}
}

/////////////////////////////////////////////////////////////////////////////
// clipboard API wrappers

BOOL CVCOleDataObject::AttachClipboard()
{
	ASSERT(VCIsValidAddress(this, sizeof(CVCOleDataObject)));
	ASSERT(m_lpDataObject == NULL); // need to call release?
	ASSERT(!m_bClipboard); // already attached to clipboard?

	// set special "clipboard" flag for optimizations
	m_bClipboard = TRUE;
	return TRUE;
}

void CVCOleDataObject::EnsureClipboardObject()
{
	ASSERT(VCIsValidAddress(this, sizeof(CVCOleDataObject)));

	if (m_bClipboard && m_lpDataObject == NULL)
	{
		// get clipboard using OLE API
		LPDATAOBJECT lpDataObject;
		SCODE sc = ::OleGetClipboard(&lpDataObject);

		// attach CVCOleDataObject wrapper to IDataObject from clipboard
		if (sc == S_OK)
			Attach(lpDataObject, TRUE);
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
	// attempt to find match in the cache
	VC_DATACACHE_ENTRY* pCache = this->Lookup(pformatetcIn, DATADIR_GET);
	RETURN_ON_NULL2(pCache, DATA_E_FORMATETC);

	// use cache if entry is not delay render
	memset(pmedium, 0, sizeof(STGMEDIUM));
	if (pCache->m_stgMedium.tymed != TYMED_NULL)
	{
		// Copy the cached medium into the lpStgMedium provided by caller.
		if (!_VCCopyStgMedium(pformatetcIn->cfFormat, pmedium, &pCache->m_stgMedium))
			return DATA_E_FORMATETC;

		// format was supported for copying
		return S_OK;
	}

	SCODE sc = DATA_E_FORMATETC;

	// attempt LPSTGMEDIUM based delay render
	if (OnRenderData(pformatetcIn, pmedium))
		sc = S_OK;
	return sc;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
	// these two must be the same
	ASSERT(pformatetc->tymed == pmedium->tymed);
	pformatetc->tymed = pmedium->tymed;    // but just in case...

	// attempt to find match in the cache
	VC_DATACACHE_ENTRY* pCache = this->Lookup(pformatetc, DATADIR_GET);
	RETURN_ON_NULL2(pCache, DATA_E_FORMATETC);

	// handle cached medium and copy
	if (pCache->m_stgMedium.tymed != TYMED_NULL)
	{
		// found a cached format -- copy it to dest medium
		ASSERT(pCache->m_stgMedium.tymed == pmedium->tymed);
		if (!_VCCopyStgMedium(pformatetc->cfFormat, pmedium, &pCache->m_stgMedium))
			return DATA_E_FORMATETC;

		// format was supported for copying
		return S_OK;
	}

	SCODE sc = DATA_E_FORMATETC;
	// attempt pmedium based delay render
	if (OnRenderData(pformatetc, pmedium))
		sc = S_OK;
	return sc;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppenumFormatEtc)
{
	*ppenumFormatEtc = NULL;

	// generate a format list from the cache
	CComObject<CVCEnumFormatEtc> *pFormatList = NULL;
	HRESULT hr = CComObject<CVCEnumFormatEtc>::CreateInstance(&pFormatList);
	if (SUCCEEDED(hr))
	{
		for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
		{
			VC_DATACACHE_ENTRY* pCache = &m_pDataCache[nIndex];
			if ((DWORD)pCache->m_nDataDir & dwDirection)
			{
				// entry should be enumerated -- add it to the list
				FORMATETC formatEtc;
				_VCOleCopyFormatEtc(&formatEtc, &pCache->m_formatEtc);
				pFormatList->AddFormat(&formatEtc);
			}
		}
	}
	(*ppenumFormatEtc) = pFormatList;
	(*ppenumFormatEtc)->AddRef();
	return hr;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::EnumDAdvise(IEnumSTATDATA **ppenumAdvise)
{
	ATLTRACE(_T("IDataObjectImpl::EnumDAdvise\n"));
	HRESULT hr = E_FAIL;
	if (m_spDataAdviseHolder != NULL)
		hr = m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
	return hr;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::DUnadvise(DWORD dwConnection)
{
	ATLTRACE(_T("IDataObjectImpl::DUnadvise\n"));
	RETURN_ON_NULL2(m_spDataAdviseHolder, OLE_E_NOCONNECTION);
	return m_spDataAdviseHolder->Unadvise(dwConnection);
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::DAdvise(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
	ATLTRACE(_T("IDataObjectImpl::DAdvise\n"));
	HRESULT hr = S_OK;
	if (this->m_spDataAdviseHolder == NULL)
		hr = CreateDataAdviseHolder(&m_spDataAdviseHolder);

	if (hr == S_OK)
		hr = m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

	return hr;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
{
	ASSERT(pformatetc->tymed == pmedium->tymed);

	// attempt to find match in the cache
	VC_DATACACHE_ENTRY* pCache = Lookup(pformatetc, DATADIR_SET);
	RETURN_ON_NULL2(pCache, DATA_E_FORMATETC);
	ASSERT(pCache->m_stgMedium.tymed == TYMED_NULL);

	SCODE sc = E_UNEXPECTED;

	// attempt pmedium based SetData
	if (OnSetData(pformatetc, pmedium, fRelease))
		sc = S_OK;
	return sc;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
STDMETHODIMP CVCOleDataSource::QueryGetData(FORMATETC *pformatetc)
{
	// attempt to find match in the cache
	VC_DATACACHE_ENTRY* pCache = Lookup(pformatetc, DATADIR_GET);
	RETURN_ON_NULL2(pCache, DATA_E_FORMATETC);

	// it was found in the cache or can be rendered -- success
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataSource cache implementation

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
VC_DATACACHE_ENTRY* CVCOleDataSource::Lookup(LPFORMATETC lpFormatEtc, DATADIR nDataDir) const
{
	VC_DATACACHE_ENTRY* pLast = NULL;
	// look for suitable match to lpFormatEtc in cache
	for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
	{
		// get entry from cache at nIndex
		VC_DATACACHE_ENTRY* pCache = &m_pDataCache[nIndex];
		FORMATETC *pCacheFormat = &pCache->m_formatEtc;

		// check for match
		if (pCacheFormat->cfFormat == lpFormatEtc->cfFormat && (pCacheFormat->tymed & lpFormatEtc->tymed) != 0 &&
			pCacheFormat->lindex == lpFormatEtc->lindex && pCacheFormat->dwAspect == lpFormatEtc->dwAspect &&
			pCache->m_nDataDir == nDataDir)
		{
			// for backward compatibility we match even if we never
			// find an exact match for the DVTARGETDEVICE
			DVTARGETDEVICE* ptd1 = pCacheFormat->ptd;
			DVTARGETDEVICE* ptd2 = lpFormatEtc->ptd;
			pLast = pCache;
			if ( ((ptd1 == NULL) && (ptd2 == NULL)) || ((ptd1 != NULL) && (ptd2 != NULL) && (ptd1->tdSize == ptd2->tdSize) &&
				(memcmp(ptd1, ptd2, ptd1->tdSize)==0)))
			{
				// exact match, so break now and return it
				break;
			}
			// continue looking for better match
		}
	}

	return pLast;    // not found
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
BOOL CVCOleDataSource::OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
	// attempt TYMED_HGLOBAL as prefered format
	if (lpFormatEtc->tymed & TYMED_HGLOBAL)
	{
		// attempt HGLOBAL delay render hook
		HGLOBAL hGlobal = lpStgMedium->hGlobal;
		if (OnRenderGlobalData(lpFormatEtc, &hGlobal))
		{
			ASSERT(lpStgMedium->tymed != TYMED_HGLOBAL || (lpStgMedium->hGlobal == hGlobal));
			ASSERT(hGlobal != NULL);
			lpStgMedium->tymed = TYMED_HGLOBAL;
			lpStgMedium->hGlobal = hGlobal;
			return TRUE;
		}

		// attempt CVsFile* based delay render hook
		CVCSharedFile file;
		if (lpStgMedium->tymed == TYMED_HGLOBAL)
		{
			ASSERT(lpStgMedium->hGlobal != NULL);
			file.SetHandle(lpStgMedium->hGlobal, FALSE);
		}
		if (OnRenderFileData(lpFormatEtc, &file))
		{
			lpStgMedium->tymed = TYMED_HGLOBAL;
			lpStgMedium->hGlobal = file.Detach();
			ASSERT(lpStgMedium->hGlobal != NULL);
			return TRUE;
		}
		if (lpStgMedium->tymed == TYMED_HGLOBAL)
			file.Detach();
	}

	// attempt TYMED_ISTREAM format
	if (lpFormatEtc->tymed & TYMED_ISTREAM)
	{
		ASSERT(!_T("port COleStreamFile"));
#if 0
		COleStreamFile file;
		if (lpStgMedium->tymed == TYMED_ISTREAM)
		{
			ASSERT(lpStgMedium->pstm != NULL);
			file.Attach(lpStgMedium->pstm);
		}
		else
		{
			if (!file.CreateMemoryStream())
				return FALSE;
		}

		// get data into the stream
		if (OnRenderFileData(lpFormatEtc, &file))
		{
			lpStgMedium->tymed = TYMED_ISTREAM;
			lpStgMedium->pstm = file.Detach();
			return TRUE;
		}
		if (lpStgMedium->tymed == TYMED_ISTREAM)
			file.Detach();
#endif //0
	}

	return FALSE;   // default does nothing
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
CVCOleDataSource::CVCOleDataSource(void)
{
	m_pDataCache = NULL;
	m_nMaxSize = 0;
	m_nSize = 0;
	m_nGrowBy = 10;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
CVCOleDataSource::~CVCOleDataSource(void)
{
	// clear clipboard source if this object was on the clipboard
#if 0
	_AFX_OLE_STATE* pOleState = _afxOleState;
	if (this == pOleState->m_pClipboardSource)
		pOleState->m_pClipboardSource = NULL;
#endif
	// free the clipboard data cache
	Empty();
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void CVCOleDataSource::Empty()
{
	if (m_pDataCache != NULL)
	{
		ASSERT(m_nMaxSize != 0);
		ASSERT(m_nSize != 0);

		// release all of the STGMEDIUMs and FORMATETCs
		for (UINT nIndex = 0; nIndex < m_nSize; nIndex++)
		{
			::CoTaskMemFree(m_pDataCache[nIndex].m_formatEtc.ptd);
			::ReleaseStgMedium(&m_pDataCache[nIndex].m_stgMedium);
		}

		// delete the cache
		delete[] m_pDataCache;
		m_pDataCache = NULL;
		m_nMaxSize = 0;
		m_nSize = 0;
	}
	ASSERT(m_pDataCache == NULL);
	ASSERT(m_nMaxSize == 0);
	ASSERT(m_nSize == 0);
}

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataSource clipboard API wrappers

void CVCOleDataSource::SetClipboard(void)
{
	// attempt OLE set clipboard operation
	SCODE sc = ::OleSetClipboard(this);
	ASSERT(S_OK == sc);

	// success - set as current clipboard source
	ASSERT(::OleIsCurrentClipboard(this) == S_OK);
}

// for LPSTGMEDIUM or HGLOBAL based delayed render
void CVCOleDataSource::DelayRenderData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc)
{
	ASSERT(lpFormatEtc == NULL || VCIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	if (lpFormatEtc == NULL)
	{
		lpFormatEtc = _VCFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
		lpFormatEtc->tymed = TYMED_HGLOBAL;
	}
	// ensure that cfFormat member is set
	if (cfFormat != 0)
		lpFormatEtc->cfFormat = cfFormat;

	// add it to the cache
	VC_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_GET);
	memset(&pEntry->m_stgMedium, 0, sizeof pEntry->m_stgMedium);
}

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataSource cache allocation

VC_DATACACHE_ENTRY* CVCOleDataSource::GetCacheEntry(LPFORMATETC lpFormatEtc, DATADIR nDataDir)
{
	VC_DATACACHE_ENTRY* pEntry = Lookup(lpFormatEtc, nDataDir);
	if (pEntry != NULL)
	{
		// cleanup current entry and return it
		::CoTaskMemFree(pEntry->m_formatEtc.ptd);
		::ReleaseStgMedium(&pEntry->m_stgMedium);
	}
	else
	{
		// allocate space for item at m_nSize (at least room for 1 item)
		if (m_pDataCache == NULL || m_nSize == m_nMaxSize)
		{
			ASSERT(m_nGrowBy != 0);
			VC_DATACACHE_ENTRY* pCache = new VC_DATACACHE_ENTRY[m_nMaxSize+m_nGrowBy];
			m_nMaxSize += m_nGrowBy;
			if (m_pDataCache != NULL)
			{
				memcpy(pCache, m_pDataCache, m_nSize * sizeof(VC_DATACACHE_ENTRY));
				delete[] m_pDataCache;
			}
			m_pDataCache = pCache;
		}
		ASSERT(m_pDataCache != NULL);
		ASSERT(m_nMaxSize != 0);

		pEntry = &m_pDataCache[m_nSize++];
	}

	// fill the cache entry with the format and data direction and return it
	pEntry->m_nDataDir = nDataDir;
	pEntry->m_formatEtc = *lpFormatEtc;
	return pEntry;
}

// for HGLOBAL based cached render
void CVCOleDataSource::CacheGlobalData(CLIPFORMAT cfFormat, HGLOBAL hGlobal, LPFORMATETC lpFormatEtc)
{
	ASSERT(hGlobal != NULL);
	ASSERT(lpFormatEtc == NULL || VCIsValidAddress(lpFormatEtc, sizeof(FORMATETC), FALSE));

	// fill in FORMATETC struct
	FORMATETC formatEtc;
	lpFormatEtc = _VCFillFormatEtc(lpFormatEtc, cfFormat, &formatEtc);
	lpFormatEtc->tymed = TYMED_HGLOBAL;

	// add it to the cache
	VC_DATACACHE_ENTRY* pEntry = GetCacheEntry(lpFormatEtc, DATADIR_GET);
	pEntry->m_stgMedium.tymed = TYMED_HGLOBAL;
	pEntry->m_stgMedium.hGlobal = hGlobal;
	pEntry->m_stgMedium.pUnkForRelease = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CVCOleDataSource diagnostics

#ifdef _DEBUG
void CVCOleDataSource::AssertValid() const
{
//	CCmdTarget::AssertValid();
	ASSERT(m_nSize <= m_nMaxSize);
	ASSERT(m_nMaxSize != 0 || m_pDataCache == NULL);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
// Free our hold on the nodes
//---------------------------------------------------------------------------
CVCProjDataSource::~CVCProjDataSource() 
{ 
    CleanupNodes();
}

//---------------------------------------------------------------------------
// We copy the nodes in rgNodeList to our list and addref them so they don't go
// away.
//---------------------------------------------------------------------------
void CVCProjDataSource::SetNodeList(CVCArchy* pHier, CVCNodeArray& rgNodeList)
{   // Addref all the nodes
	ASSERT(m_pVCProjHier == NULL);
	m_pVCProjHier = pHier;
	CleanupNodes();
	m_rgNodeList.SetSize(rgNodeList.GetSize());
	for (int i = 0; i < rgNodeList.GetSize(); i++)
	{
		m_rgNodeList[i] = rgNodeList[i];
		m_rgNodeList[i]->AddRef();
	}
}

//---------------------------------------------------------------------------
// Free our hold on the nodes
//---------------------------------------------------------------------------
void CVCProjDataSource::CleanupNodes()
{
    for (int i = 0; i < m_rgNodeList.GetSize(); i++)
        m_rgNodeList[i]->Release();

    m_rgNodeList.RemoveAll();
}

//---------------------------------------------------------------------------
// Called to render our dragdrop format. By delaying the rendering it allows
// us to get the files local for VC projects other than the one that sourced it.
//---------------------------------------------------------------------------
BOOL CVCProjDataSource::OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal)
{
    BOOL bRet = FALSE;
    ASSERT(lpFormatEtc && phGlobal);
    if(lpFormatEtc && phGlobal && lpFormatEtc->cfFormat == s_cfRefProjItems && (lpFormatEtc->tymed & TYMED_HGLOBAL))
    {   // All right, it's our format. Walk the node list building up the projref 
        // format for each item.
        CComPtr<IVsSolution> spSolution;
		GetBuildPkg()->GetIVsSolution(&spSolution);
        ASSERT(spSolution);
        CVCSharedFile dataFile2(GMEM_DDESHARE|GMEM_MOVEABLE, 512);
        DROPFILES dropFiles = {sizeof(DROPFILES), {0, 0}, FALSE, TRUE};
        BOOL bSuccess = dataFile2.Write(&dropFiles, sizeof(DROPFILES));
        ASSERT(bSuccess);
        for (int i = 0; i < m_rgNodeList.GetSize(); i++)
        {   
            BOOL bAddedItem = FALSE;
            CVCNode* pNode = m_rgNodeList[i];
            // Make sure node hasn't been zombied in the mean time.
            if(!pNode->IsZombie())
            {
                CComBSTR bstrProjref;
                spSolution->GetProjrefOfItem(m_pVCProjHier->GetIVsHierarchy(), pNode->GetVsItemID(), &bstrProjref);
                if(bstrProjref)
                {   // This is a good one
                    bSuccess = dataFile2.Write(bstrProjref, sizeof(WCHAR) * (lstrlenW(bstrProjref)+1));
                    ASSERT(bSuccess);
                    bAddedItem = TRUE;
                }
            }
            if (!bAddedItem)
            {   // Remove this node from our list of dragged items
                m_rgNodeList.RemoveAt(i);
                --i;
            }
        }
        // Only cache the format if we actually added at least one file (otherwise we simply let
        // the sharedFile release the HGlobal.
        if(m_rgNodeList.GetSize())
        {   // Write trailer
            WCHAR szTerm[2] = {0,0};
            dataFile2.Write(szTerm, 2*sizeof(WCHAR));

            // Return the hGlobal. 
            *phGlobal = dataFile2.Detach();
            bRet = TRUE;
        }
    }
    return bRet;
}

//---------------------------------------------------------------------------
// Helper for creating default FORMATETC from cfFormat
//---------------------------------------------------------------------------
LPFORMATETC _VCFillFormatEtc(LPFORMATETC lpFormatEtc, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtcFill)
{
	ASSERT(lpFormatEtcFill != NULL);
	if (lpFormatEtc == NULL && cfFormat != 0)
	{
		lpFormatEtc = lpFormatEtcFill;
		lpFormatEtc->cfFormat = cfFormat;
		lpFormatEtc->ptd = NULL;
		lpFormatEtc->dwAspect = DVASPECT_CONTENT;
		lpFormatEtc->lindex = -1;
		lpFormatEtc->tymed = (DWORD) -1;
	}
	return lpFormatEtc;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static HGLOBAL CopyGlobalMemory(HGLOBAL hDest, HGLOBAL hSource)
{
	ASSERT(hSource != NULL);

	// make sure we have suitable hDest
	ASSERT(::GlobalSize(hSource) < INT_MAX);
	DWORD nSize = (LONG32) (::GlobalSize(hSource));
	if (hDest == NULL)
	{
		hDest = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, nSize);
		RETURN_ON_NULL2(hDest, NULL);
	}
	else if (nSize > ::GlobalSize(hDest))
	{
		// hDest is not large enough
		return NULL;
	}

	// copy the bits
	LPVOID lpSource = ::GlobalLock(hSource);
	LPVOID lpDest = ::GlobalLock(hDest);
	ASSERT(lpDest != NULL);
	ASSERT(lpSource != NULL);
	memcpy(lpDest, lpSource, nSize);
	::GlobalUnlock(hDest);
	::GlobalUnlock(hSource);

	// success -- return hDest
	return hDest;
}

//---------------------------------------------------------------------------
BOOL _VCCopyStgMedium(CLIPFORMAT cfFormat, LPSTGMEDIUM lpDest, LPSTGMEDIUM lpSource)
{
	if (lpDest->tymed == TYMED_NULL)
	{
		ASSERT(lpSource->tymed != TYMED_NULL);
		switch (lpSource->tymed)
		{
		case TYMED_ENHMF:
		case TYMED_HGLOBAL:
			ASSERT(sizeof(HGLOBAL) == sizeof(HENHMETAFILE));
			lpDest->tymed = lpSource->tymed;
			lpDest->hGlobal = NULL;
			break;  // fall through to CopyGlobalMemory case

		case TYMED_ISTREAM:
			lpDest->pstm = lpSource->pstm;
			lpDest->pstm->AddRef();
			lpDest->tymed = TYMED_ISTREAM;
			return TRUE;

		case TYMED_ISTORAGE:
			lpDest->pstg = lpSource->pstg;
			lpDest->pstg->AddRef();
			lpDest->tymed = TYMED_ISTORAGE;
			return TRUE;

		case TYMED_MFPICT:
			{
				// copy LPMETAFILEPICT struct + embedded HMETAFILE
				HGLOBAL hDest = ::CopyGlobalMemory(NULL, lpSource->hGlobal);
				RETURN_ON_NULL2(hDest, FALSE);
				LPMETAFILEPICT lpPict = (LPMETAFILEPICT)::GlobalLock(hDest);
				ASSERT(lpPict != NULL);
				lpPict->hMF = ::CopyMetaFile(lpPict->hMF, NULL);
				if (lpPict->hMF == NULL)
				{
					::GlobalUnlock(hDest);
					::GlobalFree(hDest);
					return FALSE;
				}
				::GlobalUnlock(hDest);

				// fill STGMEDIUM struct
				lpDest->hGlobal = hDest;
				lpDest->tymed = TYMED_MFPICT;
			}
			return TRUE;

		case TYMED_GDI:
			lpDest->tymed = TYMED_GDI;
			lpDest->hGlobal = NULL;
			break;

		case TYMED_FILE:
			{
				USES_CONVERSION;
				lpDest->tymed = TYMED_FILE;
				ASSERT(lpSource->lpszFileName != NULL);
				UINT cbSrc = (int)ocslen(lpSource->lpszFileName);
				LPOLESTR szFileName = (LPOLESTR)CoTaskMemAlloc(cbSrc*sizeof(OLECHAR));
				lpDest->lpszFileName = szFileName;
				RETURN_ON_NULL2(szFileName, FALSE);
				memcpy(szFileName, lpSource->lpszFileName,  (cbSrc+1)*sizeof(OLECHAR));
				return TRUE;
			}

		// unable to create + copy other TYMEDs
		default:
			return FALSE;
		}
	}
	ASSERT(lpDest->tymed == lpSource->tymed);

	switch (lpSource->tymed)
	{
	case TYMED_HGLOBAL:
		{
			HGLOBAL hDest = ::CopyGlobalMemory(lpDest->hGlobal,
			lpSource->hGlobal);
			RETURN_ON_NULL2(hDest, FALSE);
			lpDest->hGlobal = hDest;
		}
		return TRUE;

	case TYMED_ISTREAM:
		{
			ASSERT(lpDest->pstm != NULL);
			ASSERT(lpSource->pstm != NULL);

			// get the size of the source stream
			STATSTG stat;
			if (lpSource->pstm->Stat(&stat, STATFLAG_NONAME) != S_OK)
			{
				// unable to get size of source stream
				return FALSE;
			}
			ASSERT(stat.pwcsName == NULL);

			// always seek to zero before copy
			LARGE_INTEGER zero = { 0, 0 };
			lpDest->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
			lpSource->pstm->Seek(zero, STREAM_SEEK_SET, NULL);

			// copy source to destination
			if ( lpSource->pstm->CopyTo(lpDest->pstm, stat.cbSize, NULL, NULL) != S_OK )
			{
				// copy from source to dest failed
				return FALSE;
			}

			// always seek to zero after copy
			lpDest->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
			lpSource->pstm->Seek(zero, STREAM_SEEK_SET, NULL);
		}
		return TRUE;

	case TYMED_ISTORAGE:
		{
			ASSERT(lpDest->pstg != NULL);
			ASSERT(lpSource->pstg != NULL);

			// just copy source to destination
			if (lpSource->pstg->CopyTo(0, NULL, NULL, lpDest->pstg) != S_OK)
				return FALSE;
		}
	return TRUE;

	case TYMED_FILE:
		{
			USES_CONVERSION;
			ASSERT(lpSource->lpszFileName != NULL);
			ASSERT(lpDest->lpszFileName != NULL);
			return CopyFile(OLE2T(lpSource->lpszFileName), OLE2T(lpDest->lpszFileName), FALSE);
		}


	case TYMED_ENHMF:
	case TYMED_GDI:
		{
			ASSERT(sizeof(HGLOBAL) == sizeof(HENHMETAFILE));

			// with TYMED_GDI cannot copy into existing HANDLE
			if (lpDest->hGlobal != NULL)
				return FALSE;

			// otherwise, use OleDuplicateData for the copy
			lpDest->hGlobal = OleDuplicateData(lpSource->hGlobal, cfFormat, 0);
			RETURN_ON_NULL2(lpDest->hGlobal, FALSE);
		}
		return TRUE;

	// other TYMEDs cannot be copied
	default:
		return FALSE;
	}
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
DVTARGETDEVICE* _VCOleCopyTargetDevice(DVTARGETDEVICE* ptdSrc)
{
	RETURN_ON_NULL2(ptdSrc, NULL);

	DVTARGETDEVICE* ptdDest = (DVTARGETDEVICE*)CoTaskMemAlloc(ptdSrc->tdSize);
	RETURN_ON_NULL2(ptdDest, NULL);

	memcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
	return ptdDest;
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void _VCOleCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
	ASSERT(petcDest != NULL);
	ASSERT(petcSrc != NULL);

	petcDest->cfFormat = petcSrc->cfFormat;
	petcDest->ptd = _VCOleCopyTargetDevice(petcSrc->ptd);
	petcDest->dwAspect = petcSrc->dwAspect;
	petcDest->lindex = petcSrc->lindex;
	petcDest->tymed = petcSrc->tymed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\dlink.h ===
/*** 
*dlink.h
*
*  Copyright (C) 1995, Microsoft Corporation.  All Rights Reserved.
*  Information Contained Herein Is Proprietary and Confidential.
*
*Purpose:
*
*  Contains template implementations of linked lists. Also contains 
*  definition of a simple byte buffer.
*
*****************************************************************************/

// UNDONE: Are all the members of the various lists used or can we get rid of
// some for space savings

#ifndef _DLINK_H_
#define _DLINK_H_


// @@ Linked lists
// Simple parameterized singly and doubly link lists and iterators. 
// Templates are used for safe type checking.
//
// Usage:
//
//  For singly linked lists, your data structure must inherit from CSingleLink:
//
//  struct CFoo : CSingleLink<CFoo>
//  {
//    ...
//  }
//
//  Then you can create singly lists of CFoo and its iterators as follows:
//
//  CFoo * pfoo;
//
//  CSingleList<CFoo>      foolist; 
//  foolist.InsertFirst(pfoo);
//  foolist.InsertLast(pfoo);
//  ....
//
//  CSingleListIter<CFoo>  iter(&foolist); 
//  while (pfoo = iter.Next())
//  {
//    ...
//  }
//
//
//  For doubly linked lists, your data structure must inherit from CDoubleLink:
//
//  struct CFoo : CDoubleLink<CFoo>
//  {
//    ...
//  }
//
//  Then you can create doubly lists of CFoo and its iterators as follows:
//
//  CFoo * pfoo;
//
//  CDoubleList<CFoo>      foolist; 
//  foolist.InsertFirst(pfoo);
//  foolist.InsertLast(pfoo);
//  ....
//
//  CDoubleListFowardIter<CFoo>  f_iter(&foolist); 
//  while (pfoo = f_iter.Next())
//  {
//    ...
//  }
//
//  CDoubleListBackIter<CFoo>  b_iter(&foolist); 
//  while (pfoo = f_iter.Prev())
//  {
//    ...
//  }
//
//

//---------------------------------------------------------------------------
// CSingleLink class template
//---------------------------------------------------------------------------

template<class T> class CSingleList;
template<class T> class CSingleListIter;

template<class T>
class CSingleLink
{
public:
    CSingleLink()
	: m_next(NULL)
    {
    }

    virtual ~CSingleLink()
    {
	VSASSERT(NULL == m_next, "This CSingleLink is still linked to something!");
    }

    T * Next()
    {
	return m_next;
    }

    T ** NextPointer()
    {
        return &m_next;
    }

    void Insert(T * InsertNode)
    {
        // Make sure the next node isn't already set
        VSASSERT(InsertNode.m_next == NULL, "Already have a next");
        InsertNode.m_next = m_next;
        m_next = InsertNode;
    }

private:
    T * m_next;

    friend class CSingleList<T>;
    friend class CSingleListIter<T>;
};

//---------------------------------------------------------------------------
// CSingleList class template
//---------------------------------------------------------------------------

template<class T>
class CSingleList
{    
public:
    CSingleList()
	: m_first(NULL)
	, m_last(NULL)
	, m_ulCount(0)
	, m_fOwner(false)
    {
    }

    CSingleList(bool isOwner)
	: m_first(NULL)
	, m_last(NULL)
	, m_ulCount(0)
	, m_fOwner(isOwner)
    {
    }

    virtual ~CSingleList()
    {
	Reset();
    }

    // Ownership determines whether the destructor of CSingleList deletes
    // every link in the list.
    void SetOwnership(bool fOwner)
    {
	m_fOwner = fOwner;
    }

    T * GetFirst()
    {
	return m_first;
    }

    T * GetLast()
    {
	return m_last;	
    }

    T ** GetFirstPointer()
    {
        return &m_first;
    }

    unsigned long NumberOfEntries() const
    {
	return m_ulCount;
    }

    // Prepend a new element pointed to by 'pLink'. pLink must not be NULL
    // and must not be linked to something else already.
    // If CSingleList has ownership, pLink is assumed to be freed only by
    // CSingleList.
    void InsertFirst(T * pLink)
    {
	VSASSERT(pLink != NULL, "Invalid parameter");
	VSASSERT(pLink->m_next == NULL,
		  "The link to be inserted is already linked to something else");

	pLink->m_next = m_first;
	m_first = pLink;
	if (m_ulCount == 0)
	{
	    m_last = pLink;
	}
	m_ulCount += 1;
    }

    // Append a new element pointed to by 'pLink'. pLink must not be NULL
    // and must not be linked to something else already.
    // If CSingleList has ownership, pLink is assumed to be freed only by
    // CSingleList.
    void InsertLast(T * pLink)
    {
	VSASSERT(pLink != NULL, "Invalid parameter");
	VSASSERT(pLink->m_next == NULL,
		  "The link to be inserted is already linked to something else");

	if (m_ulCount == 0)
	{
	    m_first = pLink;
	}
	else
	{
	    m_last->m_next = pLink;
	}
	m_last = pLink;
	m_ulCount += 1;
    }

    // Unlink the element pointed to by 'pLink' from the list. pLink must 
    // not be NULL. pLink will NOT be freed by CSingleList regardless of
    // whether CSingleList has ownership or not.
    void Remove(T * pLink)
    {
	VSASSERT(pLink != NULL, "Invalid parameter");
	VSASSERT(m_ulCount > 0, "There is no element in the list to unlink!");

	if (pLink == m_first) {
	    m_first = pLink->m_next;
	    pLink->m_next = NULL;
	    m_ulCount -= 1;
	    if (m_last == pLink)
	    {
		m_last = NULL;
	    }
	    return;
	} else {
	    for (T * pPrevious = m_first; pPrevious->m_next != NULL; pPrevious = pPrevious->m_next)
	    {
		if (pPrevious->m_next == pLink)
		{
		    pPrevious->m_next = pLink->m_next;
		    pLink->m_next = NULL;

		    m_ulCount -= 1;
		    if (m_last == pLink)
		    {
			m_last = pPrevious;
		    }
		    return;
		}
	    }
	}
	VSASSERT(false, "No such element found in the list to unlink!");
    }

    // Throw away everything. If CSingleList has ownership, it will delete all
    // elements. Otherwise, it will unlink all elements from each other so
    // that each of them can be used again as new.
    void Reset()
    {
	if (m_fOwner)
	{
	    DeleteAll();
	}
	else
	{
	    T * pCurrent;

	    while (m_first != NULL)
	    {
		pCurrent = m_first;
		m_first = m_first->m_next;

		pCurrent->m_next = NULL;
	    }
	    m_ulCount = 0;
	    m_first   = NULL;
	    m_last    = NULL;
	}
    }

    // Delete all elements in the list regardless of whether the list has
    // ownership or not.
    void DeleteAll()
    {
	T * pCurrent;

	while (m_first != NULL)
	{
	    pCurrent = m_first;
	    m_first = m_first->m_next;

	    pCurrent->m_next = NULL;
	    delete pCurrent;
	}
	m_last = NULL;
	m_ulCount = 0;
    }

    // Splice the passed-in list into the current list.
    void Splice(CSingleList<T> *psl)
    {
        DebAssert(m_fOwner == psl->m_fOwner, "Different ownership");

        if (psl->m_first)
        {
            if (!m_last)
            {
                *this = *psl;
            }
            else
            {
                m_last->m_next = psl->m_first;
                m_last = psl->m_last;
                m_ulCount += psl->m_ulCount;
            }

            psl->m_first = psl->m_last = NULL;
            psl->m_ulCount = 0;
        }
    }

private:
    T *		    m_first;
    T *		    m_last;
    unsigned long   m_ulCount;
    bool	    m_fOwner;

    friend class CSingleListIter<T>;
};

//---------------------------------------------------------------------------
// CSingleListIter class template
//---------------------------------------------------------------------------

template<class T>
class CSingleListIter
{
public:
    CSingleListIter(CSingleList<T> * pList)
	: m_pList(pList)
    {
	Reset();
    }

    T * Next()
    {
	T * pLink = m_pCurLink;

	// We could put VSASSERT(m_pCurLink != NULL, "No more element in list!");
	// here, but many clients who use the old version probably wants to see
	// a null pointer returned in this case.
	if (m_pCurLink != NULL)
	{
	    m_pCurLink = m_pCurLink->m_next;
	}
	return pLink;
    }

    bool IsDone() const
    {
	return (m_pCurLink == NULL);
    }

    void Reset()
    {
	m_pCurLink = m_pList->m_first;
    }

private:
    T		    * m_pCurLink;
    CSingleList<T>  * m_pList;
};


//---------------------------------------------------------------------------
// CDoubleLink class template
//---------------------------------------------------------------------------

template<class T> class CDoubleLink;
template<class T> class CDoubleList;
template<class T> class CComDoubleList;
template<class T> class CDoubleListForwardIter;
template<class T> class CDoubleListBackIter;

template<class T>
class CDoubleLink
{
public:
    CDoubleLink() 
	: m_next(NULL)
	, m_prev(NULL)
    { 
    }

    virtual ~CDoubleLink() 
    {
	VSASSERT(m_next == NULL && m_prev == NULL, "This element is still linked to something!");
	ATLTRACE(_T("This element is still linked to something!"));
    }

    T * Next()
    {
	return m_next;
    }

    T * Prev()
    {
	return m_prev;
    }

private:
    T * m_prev;
    T * m_next;

    friend class CDoubleList<T>;
    friend class CComDoubleList<T>;
    friend class CDoubleListForwardIter<T>;
    friend class CDoubleListBackIter<T>;
};

//---------------------------------------------------------------------------
// CDoubleList class template
//---------------------------------------------------------------------------

template<class T>
class CDoubleList
{      
public:
    CDoubleList()
	: m_first(NULL)
	, m_last(NULL)
	, m_ulCount(0)
	, m_fOwner(false)
    {
    }

    CDoubleList(bool isOwner)
	: m_first(NULL)
	, m_last(NULL)
	, m_ulCount(0)
	, m_fOwner(isOwner)
    {
    }

    virtual ~CDoubleList()
    {
	Reset();
    }

    void SetOwnership(bool fOwner)
    {
	m_fOwner = fOwner;
    }

    T * GetFirst() 
    {
        return m_first;
    }

    T * GetLast() 
    { 
        return m_last;
    }

    unsigned long NumberOfEntries() const
    { 
        return m_ulCount;
    }
    
    // Prepend a new element pointed to by 'pLink'. pLink must not be NULL
    // and must not be linked to something else already.
    // If CDoubleList has ownership, pLink is assumed to be freed only by
    // CDoubleList.
    virtual void InsertFirst(T * pLink)
    {
	VSASSERT(pLink != NULL, "Invalid parameter");
	ATLTRACE(_T("Invalid parameter"));
	VSASSERT(pLink->m_next == NULL && pLink->m_prev == NULL, "The link to be inserted is already linked to something else");
    ATLTRACE(_T("The link to be inserted is already linked to something else"));

	pLink->m_next = m_first;
	pLink->m_prev = NULL;
	if (m_ulCount == 0)
	{
	    m_last = pLink;
	}
	else
	{
	    m_first->m_prev = pLink;
	}
	m_first = pLink;
	m_ulCount += 1;
    }

    // Append a new element pointed to by 'pLink'. pLink must not be NULL
    // and must not be linked to something else already.
    // If CDoubleList has ownership, pLink is assumed to be freed only by
    // CDoubleList.
    virtual void InsertLast(T * pLink)
    {
	VSASSERT(pLink != NULL, "Invalid parameter");
	ATLTRACE(_T("Invalid parameter"));
	VSASSERT(pLink->m_next == NULL && pLink->m_prev == NULL, "The link to be inserted is already linked to something else");
	ATLTRACE(_T("The link to be inserted is already linked to something else"));

	pLink->m_prev = m_last;
	pLink->m_next = NULL;
	if (m_ulCount == 0)
	{
	    m_first = pLink;
	}
	else
	{
	    m_last->m_next = pLink;
	}
	m_last = pLink;
	m_ulCount += 1;
    }

    // Insert a new element pointed to by 'pLinkInsert' after the element
    // pointed to by 'pLinkAfter'. Both pointers must not be NULL.
    // pLinkAfter is assumed to be in the list, and pLinkInsert must not be
    // linked to anything else already.
    // If CDoubleList has ownership, pLinkInsert is assumed to be freed only
    // by CDoubleList.
    virtual void InsertAfter(T * pLinkInsert, T * pLinkAfter)
    {
	VSASSERT(pLinkInsert != NULL, "Invalid parameter");
	ATLTRACE(_T("Invalid parameter"));
	VSASSERT(pLinkAfter != NULL, "Invalid parameter");
	ATLTRACE(_T("Invalid parameter"));
	VSASSERT(pLinkInsert->m_next == NULL && pLinkInsert->m_prev == NULL, "The link to be inserted is already linked to something else");
	ATLTRACE(_T("The link to be inserted is already linked to something else"));

#if ID_DEBUG
	// Check whether pLinkAfter is in this list
	T * pTemp = m_first;
	while (pTemp != NULL && pTemp != pLinkAfter)
	{
	    pTemp = pTemp->m_next;
	}
	VSASSERT(pTemp == pLinkAfter, "pLinkAfter is not found in this list!");
	ATLTRACE(_T("pLinkAfter is not found in this list!"));
#endif  // ID_DEBUG

	if (pLinkAfter->m_next != NULL)
	{
	    pLinkAfter->m_next->m_prev = pLinkInsert;
	}
	pLinkInsert->m_next = pLinkAfter->m_next;
	pLinkInsert->m_prev = pLinkAfter;
	pLinkAfter->m_next = pLinkInsert;
	m_ulCount += 1;

	if (pLinkAfter == m_last)
	{
	    m_last = pLinkInsert;
	}
    }

    // Unlink the element pointed by pLink from the list. pLink must not
    // be NULL. pLink will not be deleted by CDoubleList regardless of
    // whether CDoubleList has ownership or not.
    virtual void Remove(T * pLink)
    {
	VSASSERT(pLink != NULL, "Invalid parameter");
	ATLTRACE(_T("Invalid parameter"));

	if (pLink->m_next != NULL)
	{
	    pLink->m_next->m_prev = pLink->m_prev;
	}
	if (pLink->m_prev != NULL)
	{
	    pLink->m_prev->m_next = pLink->m_next;
	}
	if (pLink == m_first)
	{
	    m_first = pLink->m_next;
	}
	if (pLink == m_last)
	{
	    m_last = pLink->m_prev;
	}
	pLink->m_next = NULL;
	pLink->m_prev = NULL;

	m_ulCount -= 1;
    }

    // Throw away everything. If CDoubleList has ownership, it will delete all
    // elements. Otherwise, it will unlink all elements from each other so
    // that each of them can be used again as new.
    virtual void Reset()
    {
	if (m_fOwner)
	{
	    DeleteAll();
	}
	else
	{
	    T * pTemp;
	    while (m_first != NULL)
	    {
		pTemp = m_first;
		m_first = m_first->m_next;

		pTemp->m_next = NULL;
		pTemp->m_prev = NULL;
	    }
	    m_first = NULL;
	    m_last = NULL;
	    m_ulCount = 0;
	}
    }

    // Delete all elements in the list regardless of whether the list has
    // ownership or not.
    virtual void DeleteAll()
    {
	T * pTemp;

	while (m_first != NULL)
	{
	    pTemp = m_first;
	    m_first = m_first->m_next;

	    pTemp->m_next = NULL;
	    pTemp->m_prev = NULL;
	    delete pTemp;
	}
	m_first = NULL;
	m_last = NULL;
	m_ulCount = 0;
    }

protected:
    T *		     m_first;
    T *		     m_last;
    bool	     m_fOwner;
    unsigned long    m_ulCount;

    friend class CDoubleListForwardIter<T>;
    friend class CDoubleListBackIter<T>;
};

//---------------------------------------------------------------------------
// CComDoubleList class template
//---------------------------------------------------------------------------

template<class T>
class CComDoubleList : public CDoubleList<T>
{
public:
    virtual ~CComDoubleList()
    {
        Reset();
    }

    virtual void InsertFirst(T * pLink)
    {
        CDoubleList<T>::InsertFirst(pLink);
        pLink->AddRef();
    }

    virtual void InsertLast(T * pLink)
    {
        CDoubleList<T>::InsertLast(pLink);
        pLink->AddRef();
    }

    virtual void InsertAfter(T * pLinkInsert, T * pLinkAfter)
    {
        CDoubleList<T>::InsertAfter(pLinkInsert, pLinkAfter);
        pLinkInsert->AddRef();
    }

    virtual void Remove(T * pLink)
    {
        CDoubleList<T>::Remove(pLink);
        pLink->Release();
    }

    virtual void Reset()
    {
        if (m_fOwner)
        {
            DeleteAll();
        }
        else
        {
	    T * pTemp;

	    while (m_first != NULL)
	    {
	        pTemp = m_first;
	        m_first = m_first->m_next;

	        pTemp->m_next = NULL;
	        pTemp->m_prev = NULL;
	        pTemp->Release();
	    }
	    m_first = NULL;
	    m_last = NULL;
	    m_ulCount = 0;        
        }
    }

    virtual void DeleteAll()
    {
	T *   pTemp;
        ULONG ulRef;

	while (m_first != NULL)
	{
	    pTemp = m_first;
	    m_first = m_first->m_next;

	    pTemp->m_next = NULL;
	    pTemp->m_prev = NULL;
	    ulRef = pTemp->Release();

            VSASSERT(ulRef == 0, "Someone still holds a pointer to this object");
			ATLTRACE(_T("Someone still holds a pointer to this object"));

            // If it's still alive, kill it!
            if (ulRef != 0)
            {
                delete pTemp;
            }
	}
	m_first = NULL;
	m_last = NULL;
	m_ulCount = 0;
    }
};

//---------------------------------------------------------------------------
// CDoubleListForwardIter class template
//---------------------------------------------------------------------------

template<class T>
class CDoubleListForwardIter
{
public:
    CDoubleListForwardIter(CDoubleList<T> * pList)
	: m_pList(pList)
    {
        Reset(); 
    }

    T * Next()
    {
	T * pTemp = m_pCurLink;

	if (m_pCurLink != NULL)
	{
	    m_pCurLink = m_pCurLink->m_next;
	}
	return pTemp;
    }

    void Reset()
    {
        m_pCurLink = m_pList->m_first;
    }

    bool IsDone() const
    {
	return (m_pCurLink == NULL);
    }

private:
    T		    * m_pCurLink;            // current element
    CDoubleList<T>  * m_pList;
};

//---------------------------------------------------------------------------
// CDoubleListBackIter class template
//---------------------------------------------------------------------------

template<class T>
class CDoubleListBackIter
{
public:
    CDoubleListBackIter(CDoubleList<T> * pList)
	: m_pList(pList)
    {
	VSASSERT(m_pList != NULL, "CDoubleList<T> pointer is NULL!");
	ATLTRACE(_T("CDoubleList<T> pointer is NULL!"));
        Reset(); 
    }

    T * Prev()
    {
	T * pTemp = m_pCurLink;

	if (m_pCurLink != NULL)
	{
	    m_pCurLink = m_pCurLink->m_prev;
	}
	return pTemp;
    }

    void Reset()
    {
        m_pCurLink = m_pList->m_last;
    }

    bool IsDone() const
    {
	return (m_pCurLink == NULL);
    }

private:
    T		    * m_pCurLink;            // current element
    CDoubleList<T>  * m_pList;
};

#endif  // _DLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\dataobject.h ===
//---------------------------------------------------------------------------
// This was taken from the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1998 Microsoft Corporation
// All rights reserved.
//
//---------------------------------------------------------------------------
#pragma once

#include <vcfileclasses.h>
#include "vcnode.h"

struct VC_DATACACHE_ENTRY;

extern LPFORMATETC _VCFillFormatEtc(
	LPFORMATETC lpFormatEtc, CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtcFill);

extern DVTARGETDEVICE* _VCOleCopyTargetDevice(DVTARGETDEVICE* ptdSrc);

extern void _VCOleCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc);

extern BOOL _VCCopyStgMedium(
	CLIPFORMAT cfFormat, LPSTGMEDIUM lpDest, LPSTGMEDIUM lpSource);

//---------------------------------------------------------------------------
// CVCOleDataObject -- simple wrapper for IDataObject
//---------------------------------------------------------------------------
class CVCOleDataObject
{
// Constructors
public:
			 CVCOleDataObject();
	virtual	 ~CVCOleDataObject();

// Operations
	void Attach(LPDATAOBJECT lpDataObject, BOOL bAutoRelease = TRUE);
	LPDATAOBJECT Detach();  // detach and get ownership of m_lpDataObject
	void Release(); // detach and Release ownership of m_lpDataObject
	BOOL AttachClipboard(); // attach to current clipboard object

// Attributes
	void BeginEnumFormats();
	BOOL GetNextFormat(LPFORMATETC lpFormatEtc);
	CVCFile* GetFileData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	HGLOBAL GetGlobalData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);
	BOOL GetData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);
	BOOL IsDataAvailable(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Implementation
public:
	LPDATAOBJECT m_lpDataObject;
	LPENUMFORMATETC m_lpEnumerator;

	// advanced use and implementation
	LPDATAOBJECT GetIDataObject(BOOL bAddRef);
	void EnsureClipboardObject();
	BOOL m_bClipboard;      // TRUE if represents the Win32 clipboard

protected:
	BOOL m_bAutoRelease;    // TRUE if destructor should call Release

private:
	// Disable the copy constructor and assignment by default so you will get
	//   compiler errors instead of unexpected behaviour if you pass objects
	//   by value or assign objects.
	CVCOleDataObject(const CVCOleDataObject&);  // no implementation
	void operator=(const CVCOleDataObject&);  // no implementation
};

//---------------------------------------------------------------------------
// CVCOleDataSource -- wrapper for implementing IDataObject
//  (works similar to how data is provided on the clipboard)
//---------------------------------------------------------------------------
class CVCOleDataSource :
 	 public CComObjectRoot
	,public IDataObject
{
protected:	// Destructors (protected to prevent accidental deletion
	virtual ~CVCOleDataSource();

public:	// Constructors
	CVCOleDataSource();

BEGIN_COM_MAP(CVCOleDataSource)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCOleDataSource)

// IDataObject
public:
	STDMETHOD(GetData)( 
            /* [unique][in] */ FORMATETC *pformatetcIn,
            /* [out] */ STGMEDIUM *pmedium);
        
	STDMETHOD(GetDataHere)( 
            /* [unique][in] */ FORMATETC *pformatetc,
            /* [out][in] */ STGMEDIUM *pmedium);
        
	STDMETHOD(QueryGetData)( 
            /* [unique][in] */ FORMATETC *pformatetc);
        
	STDMETHOD(GetCanonicalFormatEtc)( 
            /* [unique][in] */ FORMATETC *pformatectIn,
            /* [out] */ FORMATETC *pformatetcOut) { return DATA_S_SAMEFORMATETC; }
        
	STDMETHOD(SetData)( 
            /* [unique][in] */ FORMATETC *pformatetc,
            /* [unique][in] */ STGMEDIUM *pmedium,
            /* [in] */ BOOL fRelease);
        
	STDMETHOD(EnumFormatEtc)( 
            /* [in] */ DWORD dwDirection,
            /* [out] */ IEnumFORMATETC **ppenumFormatEtc);
        
	STDMETHOD(DAdvise)( 
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ DWORD advf,
            /* [unique][in] */ IAdviseSink *pAdvSink,
            /* [out] */ DWORD *pdwConnection);
        
	STDMETHOD(DUnadvise)( 
            /* [in] */ DWORD dwConnection);
        
	STDMETHOD(EnumDAdvise)( 
            /* [out] */ IEnumSTATDATA **ppenumAdvise);

public:	// IDataObjectImpl support
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;

public:
// Operations
	void Empty();   // empty cache (similar to ::EmptyClipboard)

	// CacheData & DelayRenderData operations similar to ::SetClipboardData
	void CacheGlobalData(CLIPFORMAT cfFormat, HGLOBAL hGlobal,
		LPFORMATETC lpFormatEtc = NULL);    // for HGLOBAL based data
	void DelayRenderFileData(CLIPFORMAT cfFormat,
		LPFORMATETC lpFormatEtc = NULL);    // for CVsFile* based delayed render

	// Clipboard and Drag/Drop access
#if 0
	DROPEFFECT DoDragDrop(
		DWORD dwEffects = DROPEFFECT_COPY|DROPEFFECT_MOVE|DROPEFFECT_LINK,
		LPCRECT lpRectStartDrag = NULL,
		COleDropSource* pDropSource = NULL);
#endif
	void SetClipboard();
	static void PASCAL FlushClipboard();
//	static CVCOleDataSource* PASCAL GetClipboardOwner();

	// Advanced: STGMEDIUM based cached data
	void CacheData(CLIPFORMAT cfFormat, LPSTGMEDIUM lpStgMedium,
		LPFORMATETC lpFormatEtc = NULL);    // for LPSTGMEDIUM based data
	// Advanced: STGMEDIUM or HGLOBAL based delayed render
	void DelayRenderData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

	// Advanced: support for SetData in COleServerItem
	//  (not generally useful for clipboard or drag/drop operations)
	void DelaySetData(CLIPFORMAT cfFormat, LPFORMATETC lpFormatEtc = NULL);

// Overidables
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal) { return FALSE; }
	virtual BOOL OnRenderFileData(LPFORMATETC lpFormatEtc, CVCFile* pFile) { return FALSE; }
	virtual BOOL OnRenderData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium);
		// OnRenderFileData and OnRenderGlobalData are called by
		//  the default implementation of OnRenderData.
	virtual BOOL OnSetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium, BOOL bRelease) { return FALSE; }
		// used only in COleServerItem implementation

// Implementation
public:

#ifdef _DEBUG
	virtual void AssertValid() const;
//	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	VC_DATACACHE_ENTRY* m_pDataCache;  // data cache itself
	UINT m_nMaxSize;    // current allocated size
	UINT m_nSize;       // current size of the cache
	UINT m_nGrowBy;     // number of cache elements to grow by for new allocs

	VC_DATACACHE_ENTRY* Lookup(
		LPFORMATETC lpFormatEtc, DATADIR nDataDir) const;
	VC_DATACACHE_ENTRY* GetCacheEntry(
		LPFORMATETC lpFormatEtc, DATADIR nDataDir);

};

typedef CVCTypedPtrArray<CVCPtrArray, CVCNode*> CVCNodeArray;

//---------------------------------------------------------------------------
// Our DataSource wrapper
//---------------------------------------------------------------------------
class CVCProjDataSource : public CVCOleDataSource
{
public:
                        CVCProjDataSource() : m_pVCProjHier(NULL) {}

    void                SetNodeList(CVCArchy* pHier, CVCNodeArray& rgNodeList);
    const CVCNodeArray& GetNodeList() {return m_rgNodeList;}

    // Called to render our global data
	virtual BOOL OnRenderGlobalData(LPFORMATETC lpFormatEtc, HGLOBAL* phGlobal);

    // Registered clip formats
    static CLIPFORMAT   s_cfProjectDescriptor;  // Identifies the project which put the data on the clipboard.
    static CLIPFORMAT   s_cfStgProjItems;       // vsshell storage project items 
	static CLIPFORMAT	s_cfRefProjItems;		// vsshell reference items (like all VC items...)

protected:
    virtual ~CVCProjDataSource();
    void    CleanupNodes();
    
    CVCNodeArray	m_rgNodeList;
    CVCArchy*		m_pVCProjHier;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\errcontext2.h ===
#pragma once

// classes in this header
class CBldOutputWinEC;

#include <path2.h>
#include "bldpkg.h"

///////////////////////////////////////////////////////////////////////////////
//	Error context that writes to the output window in the IDE.  Note the 
//	the IDE must be in output window "mode" so that the output window is
//	visible, etc:
class CBldOutputWinEC :
	public IDispatchImpl<IVCBuildErrorContext, &IID_IVCBuildErrorContext, &LIBID_VCProjectEnginePrivateLibrary, 1,0, CVsTypeInfoHolder>, 
	public CComObjectRoot
{
public:
	CBldOutputWinEC();
	~CBldOutputWinEC();
	static HRESULT CreateInstance(IVCBuildErrorContext** ppContext, CBldOutputWinEC** ppContextObj, IVCBuildEngine* pBldEngine, 
		BSTR dir, IVCBuildOutput* pModelessOutputWindow);

BEGIN_COM_MAP(CBldOutputWinEC)
	COM_INTERFACE_ENTRY(IVCBuildErrorContext)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CBldOutputWinEC) 

// IVCBuildErrorContext
public:

	STDMETHOD(AddError)		(BSTR bstrMessage, BSTR bstrHelp, BSTR bstrFile, long nLine, BSTR bstrFull );
	STDMETHOD(AddWarning) 	(BSTR bstrMessage, BSTR bstrHelp, BSTR bstrFile, long nLine, BSTR bstrFull );
	STDMETHOD(AddInfo) 		(BSTR bstrMessage);
	STDMETHOD(AddLine)		(BSTR bstrMessage);

	STDMETHOD(WriteLog)		(BSTR bstrString);

	STDMETHOD(ActivateWindow)(VARIANT_BOOL bForce);
	STDMETHOD(ActivateTaskList)(VARIANT_BOOL bForce);
	STDMETHOD(ClearWindow)();
	STDMETHOD(Close)();

	STDMETHOD(get_Warnings)( long *pnErr );
	STDMETHOD(get_Errors)( long *pnWrn );
	STDMETHOD(get_BaseDirectory)(BSTR* pbstrBaseDir);
	STDMETHOD(put_BaseDirectory)(BSTR bstrBaseDir);
	STDMETHOD(get_ProjectName)(BSTR* pbstrBaseDir);
	STDMETHOD(put_ProjectName)(BSTR bstrBaseDir);

	STDMETHOD(get_AssociatedBuildEngine)(IDispatch** ppBldEngine);
	STDMETHOD(put_AssociatedBuildEngine)(IDispatch* pBldEngine);
	STDMETHOD(get_ShowOutput)(VARIANT_BOOL* pbShow);
	STDMETHOD(put_ShowOutput)(VARIANT_BOOL bShow);

	HRESULT DetermineWindowActivation(VARIANT_BOOL bForce, VSHPROPID propid, BOOL& bActivate);

	CDirW m_dir;
	CComBSTR m_bstrName;
	int m_nErrors;
	int m_nWarnings;
	VARIANT_BOOL m_bShowOutput;
	CComQIPtr<IVCBuildEngine> m_spBuildEngine;
	CComQIPtr<IVCBuildOutput> m_spModelessOutputWindow;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\directoriesdlg.cpp ===
// DirectoriesDlg.cpp : Implementation of CDirsDlg
#include "stdafx.h"
#include "DirectoriesDlg.h"
#include "bldpkg.h"
#include "vcarchy.h"
#include "profile.h"

/////////////////////////////////////////////////////////////////////////////
// CDirsDlg
    
CDirectoriesDlg::CDirectoriesDlg()
{
	m_nLastToolset = -1;
	m_nToolset = 0;
}

CDirectoriesDlg::~CDirectoriesDlg()
{
}

HRESULT CDirectoriesDlg::GetPlatformsEnumerator(IEnumVARIANT** ppEnum)
{
	CHECK_POINTER_NULL(ppEnum);

	VCProjectEngine* pProjEngine = g_pBuildPackage->GetProjectEngine();

    CComPtr<IDispatch> spDisp;
	HRESULT hr = pProjEngine->get_Platforms(&spDisp);
   	CComQIPtr<IVCCollection> spCollection = spDisp;

	VSASSERT(spCollection, "Could not get platforms collection.");
	RETURN_ON_FAIL_OR_NULL(hr, spCollection);
	
	hr = spCollection->_NewEnum(reinterpret_cast<IUnknown **>( ppEnum ) );
	VSASSERT(SUCCEEDED(hr) && *ppEnum, "Failed to get an enumerator on the platforms collection");
	RETURN_ON_FAIL_OR_NULL(hr, *ppEnum);

	(*ppEnum)->Reset();
	return hr;
}
LRESULT CDirectoriesDlg::OnFont(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled = TRUE;
	return 0;  // Let the system set the focus
}

LRESULT CDirectoriesDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	CStringW strDirsOpt, strToolsetName;	// yes, ANSI
	CWindow pathCombo(GetDlgItem(IDC_DIRS_TYPE));
	CWindow platformCombo(GetDlgItem(IDC_DIRS_TOOLSETS));

	USES_CONVERSION;

	CComPtr<IEnumVARIANT>		spEnum;
	HRESULT hr = GetPlatformsEnumerator(&spEnum);
	RETURN_ON_FAIL_OR_NULL(hr, spEnum);

	int currIndex = 0;
	while ( true )
	{
		CComVariant var;
		CComQIPtr<VCPlatform> spPlatform;
		CComBSTR bstrName;
		
		hr = spEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) break;

		spPlatform = var.punkVal;
		if (spPlatform == NULL)
			continue;

		hr = spPlatform->get_Name(&m_pathBlockList[currIndex].m_platformName);
		
		::SendDlgItemMessage(m_hWnd,IDC_DIRS_TOOLSETS, CB_ADDSTRING, currIndex,
			(LPARAM)W2T(m_pathBlockList[currIndex].m_platformName) );

		spPlatform->get_ExecutableDirectories(&m_pathBlockList[currIndex].m_dirLists[DIRLIST_PATH]);
		spPlatform->get_IncludeDirectories(&m_pathBlockList[currIndex].m_dirLists[DIRLIST_INC]);
		spPlatform->get_ReferenceDirectories(&m_pathBlockList[currIndex].m_dirLists[DIRLIST_REF]);
		spPlatform->get_LibraryDirectories(&m_pathBlockList[currIndex].m_dirLists[DIRLIST_LIB]);
		spPlatform->get_SourceDirectories(&m_pathBlockList[currIndex].m_dirLists[DIRLIST_SRC]);
		currIndex++;
	}
    
	LoadDescription(VCPLATID_ExecutableDirectories, & m_strDescription[DIRLIST_PATH] );
	LoadTitle(VCPLATID_ExecutableDirectories, & m_strName[DIRLIST_PATH] );
	LoadDescription(VCPLATID_IncludeDirectories, & m_strDescription[DIRLIST_INC] );
	LoadTitle(VCPLATID_IncludeDirectories, & m_strName[DIRLIST_INC] );
	LoadDescription(VCPLATID_ReferenceDirectories, & m_strDescription[DIRLIST_REF] );
	LoadTitle(VCPLATID_ReferenceDirectories, & m_strName[DIRLIST_REF] );
	LoadDescription(VCPLATID_LibraryDirectories, & m_strDescription[DIRLIST_LIB] );
	LoadTitle(VCPLATID_LibraryDirectories, & m_strName[DIRLIST_LIB] );
	LoadDescription(VCPLATID_SourceDirectories, & m_strDescription[DIRLIST_SRC] );
	LoadTitle(VCPLATID_SourceDirectories, & m_strName[DIRLIST_SRC] );

	platformCombo.SendMessage(CB_SETCURSEL, 0);
	m_nToolset = 0;

	
	// Set the directory list type combo.
	FillOptionsList();
	pathCombo.SendMessage(CB_SETCURSEL, (const int)DIRLIST_PATH);

	CComPtr<IUnknown> pUnk;
	hr = ExternalQueryService(SID_SDirList, IID_IUnknown, (void **)&pUnk);
 
	RECT rectChild = { 0, 26, 263, 151 };
	m_wndDirList.Create(m_hWnd, rectChild, L"{AFD20A96-EED8-4D8C-A4EA-18AB96F6C432}",
		WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, IDC_DIRLIST);
	m_wndDirList.QueryControl(&m_pList);
	DoOnSize();

	// Establish the listbox contents.  This will also disable
	// any buttons which depend on a selection in the listbox.
	m_type = DIRLIST_PATH;	// make sure we're actually set to what we want to be!!!
	ResetListbox();

	return 1;  // Let the system set the focus
}

LRESULT CDirectoriesDlg::OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	bHandled = TRUE;

	DoOnSize();
	return 0;
}

void CDirectoriesDlg::DoOnSize()
{
	if (!m_wndDirList)
		return;

	// What we're doing here is filling the bulk of the dialog with the directory picker.
	// We're picking up the tool set combo box location merely to act as an anchor for the
	// upper left corner of the directory picker
	RECT rectParent, rectToolSetCombo, rectDirList;
	GetWindowRect(&rectParent);
	::GetWindowRect(GetDlgItem(IDC_DIRS_TOOLSETS), &rectToolSetCombo);

	rectDirList.left = 0;
	rectDirList.right = rectParent.right - rectParent.left;
	rectDirList.top = rectToolSetCombo.bottom - rectParent.top + ((rectToolSetCombo.bottom - rectToolSetCombo.top)/2);
	rectDirList.bottom = rectParent.bottom - rectParent.top;
	m_wndDirList.MoveWindow(&rectDirList);
}

void CDirectoriesDlg::FillOptionsList()
{
	CWindow pathCombo(GetDlgItem(IDC_DIRS_TYPE));

	CStringW strDirsOpt;

	if (!strDirsOpt.LoadString(IDS_DIRS_EXECUTABLE))
		strDirsOpt = "Executable files";
	::SendDlgItemMessage(m_hWnd,IDC_DIRS_TYPE,CB_ADDSTRING, DIRLIST_PATH, (LPARAM)(const wchar_t*)strDirsOpt);

	if (!strDirsOpt.LoadString(IDS_DIRS_INCLUDE))
		strDirsOpt = "Include files";
	::SendDlgItemMessage(m_hWnd,IDC_DIRS_TYPE,CB_ADDSTRING, DIRLIST_INC, (LPARAM)(const wchar_t*)strDirsOpt);

	if (!strDirsOpt.LoadString(IDS_DIRS_REFERENCE))
		strDirsOpt = "Reference files";
	::SendDlgItemMessage(m_hWnd,IDC_DIRS_TYPE,CB_ADDSTRING, DIRLIST_REF, (LPARAM)(const wchar_t*)strDirsOpt);

	if (!strDirsOpt.LoadString(IDS_DIRS_LIB))
		strDirsOpt = "Library files";
	::SendDlgItemMessage(m_hWnd,IDC_DIRS_TYPE,CB_ADDSTRING, DIRLIST_LIB, (LPARAM)(const wchar_t*)strDirsOpt);

	if (!strDirsOpt.LoadString(IDS_DIRS_SOURCE))
		strDirsOpt = "Source files";
	::SendDlgItemMessage(m_hWnd,IDC_DIRS_TYPE,CB_ADDSTRING, DIRLIST_SRC, (LPARAM)(const wchar_t*)strDirsOpt);

	BOOL bHandled = TRUE;
	OnSelChangeDirOptions(0, 0, 0, bHandled);
}

void CDirectoriesDlg::LoadDescription(UINT idDesc, BSTR * bstrDesc )
{
	if (idDesc <= 0)
		return;

	CStringW strFullDesc;
	CStringW strDesc;

	strFullDesc.LoadString(idDesc);

	int nColon = strFullDesc.Find(L": ");
	if (nColon < 0)
	{
		strDesc = strFullDesc;
	}
	else
	{
		int nLen = strFullDesc.GetLength();
		strDesc = strFullDesc.Right(strFullDesc.GetLength()-nColon-2);
	}
	strDesc.TrimLeft();
	strDesc.TrimRight();

	*bstrDesc = strDesc.AllocSysString();
}

void CDirectoriesDlg::LoadTitle(UINT idDesc, BSTR * bstrName)
{
	if (idDesc <= 0)
		return;

	CStringW strFullDesc;
	CStringW strName;
	strFullDesc.LoadString(idDesc);

	int nColon = strFullDesc.Find(L": ");
	if (nColon < 0)
	{
		strName = strFullDesc;
	}
	else
	{
		int nLen = strFullDesc.GetLength();
		strName = strFullDesc.Left(nColon);
	}
	strName.TrimLeft();
	strName.TrimRight();
	*bstrName = strName.AllocSysString();
}


void CDirectoriesDlg::ResetListbox()
{
	if( m_type < DIRLIST_PATH || m_type >= C_DIRLIST_TYPES || m_nToolset< 0 || m_nToolset >= _MAX_PLATFORMS)
		return;		// nothing to do

	RetrieveListboxInfo(m_nLastToolset, m_LastType);
	
	if( m_pList )
	{
		m_pList->put_Title( m_strName[m_type] );
		m_pList->put_Description( m_strDescription[m_type] );

		m_pList->Reset();
		CStringW temp = m_pathBlockList[m_nToolset].m_dirLists[m_type];
		int loc = temp.Find(L';');
		while( -1 != loc )
		{
			CComBSTR bstr = temp.Left( loc );
			temp = temp.Right( temp.GetLength() - loc -1);
			m_pList->Add(bstr);
			loc = temp.Find(';');
		}
		if (!temp.IsEmpty())	// pick up if there is one more on the end...
		{
			CComBSTR bstr = temp;
			m_pList->Add(bstr);
		}
	}
}

void CDirectoriesDlg::CleanUpString(int nToolset, DIRLIST_TYPE type)
{
	CComBSTR bstrDirList = m_pathBlockList[nToolset].m_dirLists[type];

	CStringW csDirList = bstrDirList;

	// first replace "\r\n"
	int loc = csDirList.Find(L"\r\n");
	while( -1 != loc )
	{
		csDirList.Delete( loc, 2 );
		csDirList.Insert( loc, L";");
		loc = csDirList.Find(L" ; ");
	}
	
	// now replace " ; "
	loc = csDirList.Find(L" ; ");
	while( -1 != loc )
	{
		csDirList.Delete( loc, 3 );
		csDirList.Insert( loc, L";");
		loc = csDirList.Find(L" ; ");
	}

	// now replace " ;"
	loc = csDirList.Find(L" ;");
	while( -1 != loc )
	{
		csDirList.Delete( loc, 2 );
		csDirList.Insert( loc, L";");

		loc = csDirList.Find(L" ;");
	}

	// now replace "; "
	loc = csDirList.Find(L"; ");
	while( -1 != loc )
	{
		csDirList.Delete( loc, 2 );
		csDirList.Insert( loc, L";");

		loc = csDirList.Find(L"; ");
	}

	// save it away.
	m_pathBlockList[nToolset].m_dirLists[type] = csDirList;
}

void CDirectoriesDlg::RetrieveListboxInfo(int nToolset, DIRLIST_TYPE type)
{
	if (nToolset < 0 || (int)type < 0)
	{
		m_nLastToolset = m_nToolset;
		m_LastType = m_type;

		return;
	}

	if( m_pList )
	{
		CComBSTR listData;
		//
		long i;
		long j;
		m_pList->get_Count( &j );
		for( i=0; i< j; i++)
		{
			CComBSTR bstrItem;
			m_pList->Index(i, &bstrItem);
			if (bstrItem.Length() > 0)
			{
				listData += bstrItem;
				listData += L";";
			}
		}

		m_pathBlockList[nToolset].m_dirLists[type] = listData;
		CleanUpString( nToolset, type );
	}

	m_nLastToolset = m_nToolset;
	m_LastType = m_type;
}

LRESULT CDirectoriesDlg::OnSelChangeDirOptions(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	CWindow pathCombo(GetDlgItem(IDC_DIRS_TYPE));

	INT nSel = (INT) pathCombo.SendMessage(CB_GETCURSEL, 0L, 0L);

	if (m_type == (DIRLIST_TYPE)nSel)
		return TRUE;	// nothing changed = nothing to do

	m_LastType = m_type;
	m_type = (DIRLIST_TYPE)nSel;

	ResetListbox();
	return TRUE;
}

LRESULT CDirectoriesDlg::OnSelChangeDirToolset(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	CWindow platformCombo(GetDlgItem(IDC_DIRS_TOOLSETS));

	INT		nSel = (INT) platformCombo.SendMessage(CB_GETCURSEL, 0L, 0L);
	if (m_nToolset == nSel)
		return TRUE;	// nothing changed, so nothing to do

	m_nLastToolset = m_nToolset;
	m_nToolset = nSel;

	ResetListbox();	
	return TRUE;
}


LRESULT CDirectoriesDlg::OnHelp(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	CComPtr<Help> pHlp;
	CComBSTR bstrTopic;
	bstrTopic = L"vc.proj.properties";

	HRESULT hr = E_FAIL;
	hr = ExternalQueryService(SID_SVsHelp, __uuidof(Help), (void **)&pHlp);
	if( pHlp )
		hr = pHlp->DisplayTopicFromF1Keyword(bstrTopic);
	return hr;
}


LRESULT CDirectoriesDlg::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	RetrieveListboxInfo(m_nToolset, m_type);

	CComPtr<IEnumVARIANT>		spEnum;
	HRESULT hr = GetPlatformsEnumerator(&spEnum);
	RETURN_ON_FAIL_OR_NULL(hr, spEnum);
	
	int currIndex = 0;
    while ( true )
    {
		CComVariant var;
		CComQIPtr<VCPlatform> spPlatform;
		CComBSTR bstrName;
		
		hr = spEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) 
			break;

		spPlatform = var.punkVal;
		if (spPlatform == NULL)
			continue;

		spPlatform->put_ExecutableDirectories(m_pathBlockList[currIndex].m_dirLists[DIRLIST_PATH]);
		spPlatform->put_IncludeDirectories(m_pathBlockList[currIndex].m_dirLists[DIRLIST_INC]);
		spPlatform->put_ReferenceDirectories(m_pathBlockList[currIndex].m_dirLists[DIRLIST_REF]);
		spPlatform->put_LibraryDirectories(m_pathBlockList[currIndex].m_dirLists[DIRLIST_LIB]);
		spPlatform->put_SourceDirectories(m_pathBlockList[currIndex].m_dirLists[DIRLIST_SRC]);
		currIndex++;
    }

	WritePathsToRegistry();
	return 0;
}


HRESULT CDirectoriesDlg::WritePathsToRegistry( void )
{
	CComPtr<IEnumVARIANT> spEnum;
	HRESULT	hr = GetPlatformsEnumerator(&spEnum);
	RETURN_ON_FAIL_OR_NULL(hr, spEnum);

	int currIndex = 0;
    while ( true )
    {
		CComVariant var;
		CComQIPtr<VCPlatform> spPlatform;
		CComBSTR bstrName;
		
		hr = spEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) break;

		spPlatform = var.punkVal;
		if (spPlatform == NULL)
			continue;

		CStringW strEntry = L"VC\\VC_OBJECTS_PLATFORM_INFO\\";
		hr = spPlatform->get_Name(&bstrName);
		strEntry += bstrName;
		strEntry += L"\\Directories";

		CComBSTR bstrPath;
		spPlatform->get_ExecutableDirectories(&bstrPath);
		WriteRegPath(strEntry, L"Path Dirs", bstrPath, TRUE );
		bstrPath.Empty();
		spPlatform->get_IncludeDirectories(&bstrPath);
		WriteRegPath(strEntry, L"Include Dirs", bstrPath, TRUE );
		bstrPath.Empty();
		spPlatform->get_ReferenceDirectories(&bstrPath);
		WriteRegPath(strEntry, L"Reference Dirs", bstrPath, TRUE );
		bstrPath.Empty();
		spPlatform->get_LibraryDirectories(&bstrPath);
		WriteRegPath(strEntry, L"Library Dirs", bstrPath, TRUE );
		spPlatform->get_SourceDirectories(&bstrPath);
		WriteRegPath(strEntry, L"Source Dirs", bstrPath, TRUE );
		currIndex++;
    }

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\errcontext.cpp ===
#include "stdafx.h"
#include "errcontext2.h"
#include "bldpkg.h"
#include "output.h"
#include "path2.h"

HRESULT ShowToolWindow(REFGUID guidWindow)
{
	CComPtr<IVsUIShell> spUIShell;
	HRESULT hr = GetBuildPkg()->GetVsUIShell(&spUIShell);
	VSASSERT(SUCCEEDED(hr), "Failed to get IVsUIShell interface");
	RETURN_ON_FAIL_OR_NULL(hr, spUIShell);

	CComPtr<IVsWindowFrame> spFrame;
	hr = spUIShell->FindToolWindow(0, guidWindow, &spFrame);
	RETURN_ON_FAIL_OR_NULL2(hr, spFrame, S_FALSE);

	//...and if we find it, show it.
	return spFrame->Show();
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CBldOutputWinEC --------------------------------
//
///////////////////////////////////////////////////////////////////////////////

// An error context for writing to the output window through the CVPROJIdeInterface:
#define MAX_OUTPUT  2047	// Max chars debugger can show in output window

CBldOutputWinEC::CBldOutputWinEC()
{
	m_nWarnings = 0;
	m_nErrors = 0;
	m_bShowOutput = VARIANT_TRUE;
}

CBldOutputWinEC::~CBldOutputWinEC()
{
	if (m_spModelessOutputWindow)
		m_spModelessOutputWindow->CloseAll();
}

STDMETHODIMP CBldOutputWinEC::get_Errors( long *pnErr )
{
	CHECK_POINTER_NULL(pnErr);

	*pnErr = m_nErrors;
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::get_Warnings( long *pnWrn )
{
	CHECK_POINTER_NULL(pnWrn);

	*pnWrn = m_nWarnings;
	return S_OK;
}

HRESULT CBldOutputWinEC::CreateInstance(IVCBuildErrorContext** ppContext, CBldOutputWinEC** ppContextObj, 
	IVCBuildEngine* pBldEngine, BSTR dir, IVCBuildOutput* pModelessOutputWindow)
{
	if (ppContext)
		*ppContext = NULL;
	if (ppContextObj)
		*ppContextObj = NULL;

	IVCBuildErrorContext *pVar;
	CComObject<CBldOutputWinEC> *pObj;
	HRESULT hr = CComObject<CBldOutputWinEC>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = (IVCBuildErrorContext*)pObj;
		pVar->AddRef();
		if (ppContext)
			*ppContext = pVar;
		if (ppContextObj)
			*ppContextObj = pObj;
			
		CStringW strDir = dir;
		if (!strDir.IsEmpty())
			pObj->m_dir.CreateFromString(strDir);
		pObj->m_spBuildEngine = pBldEngine;
		pObj->m_spModelessOutputWindow = pModelessOutputWindow;
	}
	return(hr);
}

STDMETHODIMP CBldOutputWinEC::get_BaseDirectory(BSTR* pbstrBaseDir)
{
	CHECK_POINTER_NULL(pbstrBaseDir);

	if (m_dir.IsInit())
	{
		CStringW strDir = m_dir;
		*pbstrBaseDir = strDir.AllocSysString();
	}
	else
		*pbstrBaseDir = NULL;

	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::put_BaseDirectory(BSTR bstrBaseDir)
{
	CStringW strDir = bstrBaseDir;
	if (m_dir.CreateFromString(strDir))
		return S_OK;

	return E_FAIL;
}

STDMETHODIMP CBldOutputWinEC::get_ProjectName(BSTR* pbstrBaseDir)
{
	return m_bstrName.CopyTo(pbstrBaseDir);
}

STDMETHODIMP CBldOutputWinEC::put_ProjectName(BSTR bstrName)
{
	m_bstrName = bstrName;
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::get_AssociatedBuildEngine(IDispatch** ppBldEngine)
{
	CHECK_POINTER_NULL(ppBldEngine);
	CComQIPtr<IDispatch> spDispBldEngine = m_spBuildEngine;
	*ppBldEngine = spDispBldEngine.Detach();
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::put_AssociatedBuildEngine(IDispatch* pBldEngine)
{
	m_spBuildEngine = pBldEngine;
	return S_OK;
}
STDMETHODIMP CBldOutputWinEC::get_ShowOutput(VARIANT_BOOL* pbShow)
{
	CHECK_POINTER_NULL(pbShow);
	*pbShow = m_bShowOutput;
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::put_ShowOutput(VARIANT_BOOL bShow)
{
	m_bShowOutput = bShow;
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::Close()
{
	int iCnt; // when this is zero, we close out too...
	if (m_spModelessOutputWindow)
		m_spModelessOutputWindow->CloseWithCount(&iCnt);
	return S_OK;
}

HRESULT CBldOutputWinEC::DetermineWindowActivation(VARIANT_BOOL bForce, VSHPROPID propid, BOOL& bActivate)
{
	if (bForce == VARIANT_TRUE)
	{
		bActivate = TRUE;
		return S_OK;
	}

	bActivate = FALSE;
	CComPtr<IVsShell> spVsShell;
	HRESULT hr = GetBuildPkg()->GetVsShell(&spVsShell);
	RETURN_ON_FAIL2(hr, S_FALSE);

	CComVariant var;
	spVsShell->GetProperty(propid, &var);
	VSASSERT(SUCCEEDED(hr) && var.vt == VT_BOOL, "Failed to get ShowOutputPaneOnBuildBegin/ShowTasklistOnBuildEnd property");
	if (V_BOOL(&var))
		bActivate = TRUE;

	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::ActivateWindow(VARIANT_BOOL bForce)
{
	if (m_spModelessOutputWindow == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	m_spModelessOutputWindow->Activate();

	BOOL bActivate = FALSE;
	HRESULT hr = DetermineWindowActivation(bForce, VSSPROPID_ShowOutputPaneOnBuildBegin, bActivate);
	if (hr != S_OK || !bActivate)
		return hr;

	return ShowToolWindow(GUID_OutputWindow);
}

STDMETHODIMP CBldOutputWinEC::ActivateTaskList(VARIANT_BOOL bForce)
{	// ONLY activates task list if task list is supposed to be activated at the end of a build
	if (bForce == VARIANT_FALSE && m_nErrors == 0)
		return S_OK;

	BOOL bActivate = FALSE;
	HRESULT hr = DetermineWindowActivation(bForce, VSSPROPID_ShowTasklistOnBuildEnd, bActivate);
	if (hr != S_OK || !bActivate)
		return hr;

	CComPtr<IVsTaskList> spTaskList;
	hr = GetBuildPkg()->GetTaskList(&spTaskList);
	RETURN_ON_FAIL_OR_NULL(hr, spTaskList);

	spTaskList->AutoFilter2(GUID_VsTaskListViewCompilerTasks);
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::ClearWindow()
{
	if (m_spModelessOutputWindow)
		m_spModelessOutputWindow->Clear();
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::AddError( BSTR bstrMessage , BSTR bstrHelpKeyword, BSTR bstrFile, long nLine, BSTR bstrFullMsg)
{
	m_nErrors++;
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	// Format the Message
	CComBSTR bstrFullMessage(bstrFullMsg);
	if( bstrFullMessage.Length() == 0 )
	{
		if( nLine )
		{
			CStringW strFullMsg;
			strFullMsg.Format(L"%s(%d) : error %s : %s\n",bstrFile, nLine, bstrHelpKeyword, bstrMessage);
			bstrFullMessage = strFullMsg;
		}
		else
		{
			CStringW strFullMsg;
			strFullMsg.Format(L"%s : error %s : %s\n",bstrFile, bstrHelpKeyword, bstrMessage);
			bstrFullMessage = strFullMsg;
		}
	}
	else
	{
		bstrFullMessage.Append("\n");
	}
	
	// First Write to the log
	if(m_spBuildEngine)
	{
		VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
		HRESULT hr = m_spBuildEngine->get_HaveLogging(&bHaveLogging);
		if( hr == S_OK && bHaveLogging == VARIANT_TRUE)
			m_spBuildEngine->LogTrace(eLogOutput, bstrFullMessage);
	}

	// Then write to the output window and task list
	if (m_spModelessOutputWindow != NULL) 
	{
		CComQIPtr<IVsOutputWindowPane> pPane;
		IUnknown* pUnkPane = NULL;
		m_spModelessOutputWindow->get_OutputWindowPane(&pUnkPane);
		pPane = pUnkPane;
		if( pPane )
		{
			if( nLine > 0 )
			{
				pPane->OutputTaskItemStringEx(bstrFullMessage, TP_HIGH, CAT_BUILDCOMPILE, L"", BMP_COMPILE, bstrFile, nLine-1, bstrMessage, bstrHelpKeyword);
			}
			else
			{
				pPane->OutputTaskItemStringEx(bstrFullMessage, TP_HIGH, CAT_BUILDCOMPILE, L"", BMP_COMPILE, bstrFile, nLine, bstrMessage, bstrHelpKeyword);
			}
			pPane->FlushToTaskList();
		}
		if( pUnkPane )
		{
			pUnkPane->Release();
		}
	}
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::AddWarning( BSTR bstrMessage, BSTR bstrHelpKeyword, BSTR bstrFile, long nLine, BSTR bstrFullMsg )
{
	m_nWarnings++;
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	// Format the Message
	CComBSTR bstrFullMessage(bstrFullMsg);
	if( bstrFullMessage.Length() == 0 )
	{
		if( nLine )
		{
			CStringW strFullMsg;
			strFullMsg.Format(L"%s(%d) : warning %s : %s\n",bstrFile, nLine, bstrHelpKeyword, bstrMessage);
			bstrFullMessage = strFullMsg;
		}
		else
		{
			CStringW strFullMsg;
			strFullMsg.Format(L"%s : warning %s : %s\n",bstrFile, bstrHelpKeyword, bstrMessage);
			bstrFullMessage = strFullMsg;
		}
	}
	else
	{
		bstrFullMessage.Append(L"\n");
	}
	
	// First Write to the log
	if(m_spBuildEngine)
	{
		VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
		HRESULT hr = m_spBuildEngine->get_HaveLogging(&bHaveLogging);
		if( hr == S_OK && bHaveLogging == VARIANT_TRUE)
			m_spBuildEngine->LogTrace(eLogOutput, bstrFullMessage);
	}

	// Then write to the output window and task list
	if (m_spModelessOutputWindow != NULL) 
	{
		CComQIPtr<IVsOutputWindowPane> pPane;
		IUnknown* pUnkPane = NULL;
		m_spModelessOutputWindow->get_OutputWindowPane(&pUnkPane);
		pPane = pUnkPane;
		if( pPane )
		{
			if( nLine > 0 )
			{
				pPane->OutputTaskItemStringEx(bstrFullMessage, TP_NORMAL, CAT_BUILDCOMPILE, L"", BMP_COMPILE, bstrFile, nLine-1, bstrMessage, bstrHelpKeyword );
			}
			else
			{
				pPane->OutputTaskItemStringEx(bstrFullMessage, TP_NORMAL, CAT_BUILDCOMPILE, L"", BMP_COMPILE, bstrFile, nLine, bstrMessage, bstrHelpKeyword );
			}
			pPane->FlushToTaskList();
		}
		if( pUnkPane )
		{
			pUnkPane->Release();
		}
	}
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::AddInfo( BSTR bstrMessage )
{
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	// First Write to the log
	if(m_spBuildEngine)
	{
		VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
		HRESULT hr = m_spBuildEngine->get_HaveLogging(&bHaveLogging);
		if( hr == S_OK && bHaveLogging == VARIANT_TRUE)
			m_spBuildEngine->LogTrace(eLogOutput, bstrMessage);
	}

	// Then write to the output window and task list
	if (m_spModelessOutputWindow != NULL) 
	{
		IUnknown* pUnkPane = NULL;
		m_spModelessOutputWindow->get_OutputWindowPane(&pUnkPane);
		CComQIPtr<IVsOutputWindowPane> pPane = pUnkPane;
		if( pPane )
		{
			HRESULT hr = pPane->OutputString(bstrMessage);
		}
		if( pUnkPane )
			pUnkPane->Release();
	}
	return S_OK;
}

STDMETHODIMP CBldOutputWinEC::AddLine(BSTR bstrMessage )
{
	return AddInfo(bstrMessage);
}


STDMETHODIMP CBldOutputWinEC::WriteLog(BSTR bstrString)
{
	if(m_spBuildEngine)
	{
		VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
		HRESULT hr = m_spBuildEngine->get_HaveLogging(&bHaveLogging);
		if( hr == S_OK && bHaveLogging == VARIANT_TRUE)
			m_spBuildEngine->LogTrace(eLogOutput, bstrString);
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\exefordbg.h ===
// CCallExeForDebug.h : Declaration of the CCCallExeForDebug

#ifndef __CCALLEXEFORDEBUG_H_
#define __CCALLEXEFORDEBUG_H_

#include <atlhost.h>

#include <stdafx.h>

#include "utils.h"
#include <vcdlg.h>
#include <register.h>

const WORD rgDebugCommands[] = {
	VCDSID_Command_IExplore,
	VCDSID_Command_ATLTest,
	VCDSID_Command_RegSvr,
	VCDSID_Command_Browse,
};	

#define ELEM_COUNT(x) (sizeof((x))/sizeof((*x)))

/////////////////////////////////////////////////////////////////////////////
// CCCallExeForDebug
class CCCallExeForDebug : 
	public CVCAxDialogImpl<CCCallExeForDebug>
{
public:
	CCCallExeForDebug(VCConfiguration* pConfig, HWND hwndParent) : 
		m_hwndParent( hwndParent ),
		m_exeForDbg(L"ComboBox", this, 1)
	{
		m_spConfig = pConfig;
	}

	~CCCallExeForDebug()
	{
	}

	enum { IDD = IDD_EXE_FOR_DEBUG };

BEGIN_MSG_MAP(CCCallExeForDebug)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_ID_HANDLER(IDC_EXE_FOR_DEBUG_HELP, OnHelp)
	MESSAGE_HANDLER(WM_HELP, OnHelp)
	COMMAND_HANDLER(IDC_CALLING_PROG, CBN_SELCHANGE, OnSelectExeForDbg)
	COMMAND_HANDLER(IDC_CALLING_PROG, CBN_DROPDOWN, OnSelectExeForDbgDropdown)
ALT_MSG_MAP(1)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{

		// set the appropriate font and size for the dlg and controls
		// get the font to use
		UIDLGLOGFONT logFont;
		CComPtr<IUIHostLocale> pLocale;
		HRESULT hr = ExternalQueryService( SID_SUIHostLocale, IID_IUIHostLocale, (void**)&pLocale );
		RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pLocale, 1);
		pLocale->GetDialogFont( &logFont );
		m_hFont = CreateFontIndirectW( (LOGFONTW*)&logFont );
	
		SetFont( m_hFont );
		HDC dc = GetDC();
		SelectObject( dc, m_hFont );

		// set the appropriate size for the dlg and controls
		// get a base "unit" for sizing the dlg
		SIZE unit;
		GetTextExtentPoint32W( dc, L"X", 1, &unit );
		ReleaseDC( dc );
		
		int xBorder, yBorder;
		xBorder = GetSystemMetrics( SM_CXDLGFRAME );
		yBorder = GetSystemMetrics( SM_CYDLGFRAME ) + GetSystemMetrics( SM_CYCAPTION );

		// set the dlg size
		RECT r;
		r.left = 0;
		r.top = 0;
		r.right = (long)(67.5*unit.cx) + xBorder;
		r.bottom = (long)(10.5*unit.cy) + yBorder;
		SetWindowPos( HWND_TOP, &r, 0 );
		CenterWindow( m_hwndParent );

		// set the control sizes
		// static description
		CWindow staticDesc( GetDlgItem( IDC_CALLING_PROG_TXT2 ) );
		staticDesc.SetFont( m_hFont );
		r.left = (long)(0.5*unit.cx);
		r.top = (long)(0.5*unit.cy);
		r.right = (long)(r.left + (long)(55*unit.cx));
		r.bottom = (long)(r.top + (2.5*unit.cy));
		staticDesc.SetWindowPos( HWND_TOP, &r, 0 );
		// static exe name
		CWindow staticExeName( GetDlgItem( IDC_CALLING_PROG_TXT ) );
		staticExeName.SetFont( m_hFont );
		r.left = (long)(0.5*unit.cx);
		r.top = (long)(3*unit.cy);
		r.right = (long)(r.left + (55*unit.cx));
		r.bottom = (long)(r.top + (unit.cy));
		staticExeName.SetWindowPos( HWND_TOP, &r, 0 );
		// combo box
		CWindow combo( GetDlgItem( IDC_CALLING_PROG ) );
		combo.SetFont( m_hFont );
		r.left = (long)(0.5*unit.cx);
		r.top = (long)(4.5*unit.cy);
		r.right = (long)(r.left + (50*unit.cx));
		r.bottom = (long)(r.top + (1.5*unit.cy));
		combo.SetWindowPos( HWND_TOP, &r, 0 );
		// static URL
		CWindow staticURL( GetDlgItem( IDC_HTTP_URL_TXT ) );
		staticURL.SetFont( m_hFont );
		r.left = (long)(0.5*unit.cx);
		r.top = (long)(6.5*unit.cy);
		r.right = (long)(r.left + (55*unit.cx));
		r.bottom = (long)(r.top + (1*unit.cy));
		staticURL.SetWindowPos( HWND_TOP, &r, 0 );
		// edit field
		CWindow editURL( GetDlgItem( IDC_HTTP_URL ) );
		editURL.SetFont( m_hFont );
		r.left = (long)(0.5*unit.cx);
		r.top = (long)(8*unit.cy);
		r.right = (long)(r.left + (50*unit.cx));
		r.bottom = (long)(r.top + (1.5*unit.cy));
		editURL.SetWindowPos( HWND_TOP, &r, 0 );
		// ok button
		CWindow ok( GetDlgItem( IDOK ) );
		ok.SetFont( m_hFont );
		r.left = (long)(56.5*unit.cx);
		r.top = (long)(0.5*unit.cy);
		r.right = (long)(r.left + (10*unit.cx));
		r.bottom = (long)(r.top + (2*unit.cy));
		ok.SetWindowPos( HWND_TOP, &r, 0 );
		// cancel button
		CWindow cancel( GetDlgItem( IDCANCEL ) );
		cancel.SetFont( m_hFont );
		r.left = (long)(56.5*unit.cx);
		r.top = (long)(3*unit.cy);
		r.right = (long)(r.left + (10*unit.cx));
		r.bottom = (long)(r.top + (2*unit.cy));
		cancel.SetWindowPos( HWND_TOP, &r, 0 );
		// help button
		CWindow help( GetDlgItem( IDC_EXE_FOR_DEBUG_HELP ) );
		help.SetFont( m_hFont );
		r.left = (long)(56.5*unit.cx);
		r.top = (long)(5.5*unit.cy);
		r.right = (long)(r.left + (10*unit.cx));
		r.bottom = (long)(r.top + (2*unit.cy));
		help.SetWindowPos( HWND_TOP, &r, 0 );

		if( m_bstrExe.Length() != 0 )
			::SetDlgItemTextW( m_hWnd, IDC_CALLING_PROG, m_bstrExe );
		if( m_bstrUrl.Length() != 0 )
			::SetDlgItemTextW( m_hWnd, IDC_HTTP_URL, m_bstrUrl );

		CComBSTR bstrProjName;
        if (m_spConfig)
        {
            CComPtr<IDispatch> spDispProj;
            m_spConfig->get_Project(&spDispProj);
            CComQIPtr<VCProject> spProject = spDispProj;
            if (spProject)
            {
                spProject->get_Name(&bstrProjName);
            }

            CStringW strTitle;
            strTitle.Format(IDS_EXE_FOR_DBG_TITLE, bstrProjName);
            ::SetWindowTextW( m_hWnd, strTitle );
        }

		// turn autocompletion on
		HWND hwndEdit;
		hwndEdit = GetDlgItem( IDC_CALLING_PROG );
		SHAutoComplete( hwndEdit, 0 );
		m_exeForDbg.SubclassWindow(hwndEdit);
		hwndEdit = GetDlgItem( IDC_HTTP_URL );
		SHAutoComplete( hwndEdit, 0 );

		const int cItems = ELEM_COUNT(rgDebugCommands);
		for (int iItem = 0; iItem < cItems; iItem++)
		{
			CStringW str;
			if (str.LoadString(rgDebugCommands[iItem]))
			{
				m_listExeForDbgChoices.Add(rgDebugCommands[iItem]);
				m_listExeForDbgStrings.Add(str);
			}
		}

		return 1;  // Let the system set the focus
	}

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CStringW strText;
		::GetDlgItemTextW( m_hWnd, IDC_CALLING_PROG, strText.GetBuffer(500), 500 );
		m_bstrExe = strText;
		strText.ReleaseBuffer();
		::GetDlgItemTextW( m_hWnd, IDC_HTTP_URL, strText.GetBuffer(500), 500 );
		m_bstrUrl = strText;
		strText.ReleaseBuffer();
		
		CComBSTR bstrProjName;
		if (m_spConfig)
		{
			CComPtr<IDispatch> spDispProj;
			m_spConfig->get_Project(&spDispProj);
			CComQIPtr<VCProject> spProject = spDispProj;
			if (spProject)
			{
				spProject->get_Name(&bstrProjName);
			}
		}

		if (m_bstrExe.Length() == 0 && m_bstrUrl.Length() == 0)
		{
			//the user didn't fill in either field
			strText.LoadString(IDS_E_DBG_BLANK);
			::MessageBoxW(m_hWnd, strText, bstrProjName, MB_OK|MB_ICONERROR);
			return wID;
		}
		else if (m_bstrExe.Length())
		{
			//the user typed in a file name, make sure that it exists on disk...
			WIN32_FIND_DATA FindFileData;
			HANDLE hFind = ::FindFirstFile(m_bstrExe, &FindFileData);

			if (INVALID_HANDLE_VALUE == hFind)
			{
				strText.Format(IDS_E_DLG_FILENOTFOUND, m_bstrExe);
				if (IDYES == ::MessageBoxW(m_hWnd, strText, bstrProjName, MB_YESNO | MB_ICONERROR))
					return wID;
			}
		}

		DeleteObject( m_hFont );

		EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		DeleteObject( m_hFont );
		EndDialog(wID);
		return 0;
	}
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		HRESULT hr = S_OK;
		CComPtr<IVsHelp> pIHelp;
		if (SUCCEEDED(hr = ExternalQueryService(SID_SVsHelp, IID_IVsHelp, reinterpret_cast<void**>(&pIHelp))) && pIHelp)
		{
			hr = pIHelp->DisplayTopicFromF1Keyword(L"vs.debug.exefordebug");
		}
		
		return 0;
	}
	
	LRESULT OnHelp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		return OnHelp(WM_HELP, (WPARAM)0, (LPARAM)0, bHandled);
	}
	LRESULT OnSelectExeForDbgDropdown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{	// about to drop the list box down, so save off anything the user had typed in here...
		::GetDlgItemTextW( m_hWnd, IDC_CALLING_PROG, m_strSavedText.GetBuffer(500), 500 );

		// we reset the content every time we drop the list down because we had to add a fake entry
		// at the end if the user actually selected something
		m_exeForDbg.SendMessage(CB_RESETCONTENT, 0L, 0L);
		INT_PTR cItems = m_listExeForDbgStrings.GetSize();
		for (INT_PTR iItem = 0; iItem < cItems; iItem++)
			UtilSendMessageWString( m_exeForDbg, CB_ADDSTRING, NULL, (LPARAM)(const wchar_t*)m_listExeForDbgStrings[iItem]);
		return 0;
	}

	LRESULT OnSelectExeForDbg(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		INT nSel = (INT)m_exeForDbg.SendMessage(CB_GETCURSEL, 0L, 0L);
		if (nSel < 0 || nSel >= ELEM_COUNT(rgDebugCommands))
			return 0;

		UINT id = m_listExeForDbgChoices[nSel];

		HRESULT hr = S_OK;
		CStringW strCommand;
		switch (id)
		{
		case VCDSID_Command_IExplore:
			//
			// User selected default browser, go find it
			//
			if (FAILED(hr = GetBrowserCommand(strCommand)))
			{
				VSFAIL ("Couldn't find a browser!");
			}
			break;

		case VCDSID_Command_ATLTest:
			hr = GetTestContainerCommand(strCommand);
			break;
			
		case VCDSID_Command_RegSvr:
			hr = GetRegSvrCommand(strCommand);
			break;
			
		case VCDSID_Command_Browse:
			hr = BrowseForCommand(strCommand);
			break;
			
		default:
			//
			// User must have typed something in - use it as-is.
			//
			return 0;
		}

		if (SUCCEEDED(hr))
			m_strSavedText = strCommand;

		UtilSendMessageWString( m_exeForDbg, CB_ADDSTRING, NULL, (LPARAM)(const wchar_t*)m_strSavedText );
		m_exeForDbg.SendMessage(CB_SETCURSEL, (WPARAM)m_listExeForDbgChoices.GetSize(), 0L);
		
		bHandled = TRUE;
		return 1;
	}

	//
	// Return a browser command w/ %s for the URL to open.  For example:
	//
	//  c:\W3C\Arena.exe -startpage "%s"
	//
	HRESULT GetBrowserCommand( CStringW& strCommand )
	{
		CRegKey regKey;
		CStringW strBrowser;
		ULONG result;
		DWORD dwSize = _MAX_PATH;
		CStringW strCommandLine;

		if (regKey.Open (HKEY_CLASSES_ROOT, L"http\\shell\\open\\command") != ERROR_SUCCESS)
		{
	        return E_FAIL;
		}

		{
			CString strA;
			result = regKey.QueryStringValue (NULL, strA.GetBuffer (dwSize), &dwSize);
			strA.ReleaseBuffer ();
			strBrowser = strA;
		}
		if (result != ERROR_SUCCESS)
		{
			return E_FAIL;
		}

		if (strBrowser.IsEmpty())
		{
			return E_FAIL;
		}

		{
			// From here there are two possible formats for the registry entry:
			// Netscape uses c:\progra~1\...\Netscape.exe -h "%1"
			// while IE uses "C:\Program Files\...\IEXPLORE.EXE" -nohome
			// The bstrExe that we return must be the executable alone without quotes, 
			// and we cannot pass args except through the bstrArg parameter.
			int iMarker = strBrowser.Find (L"%1");
			if (iMarker != -1)
			{
				// Netscape-style entry -- make a %s
				strCommandLine = strBrowser;
				((LPWSTR)(LPCWSTR)strCommandLine)[ iMarker + 1 ] = L's';
			}
			else
			{
				// IE-style entry
				strCommandLine = strBrowser + L" %s";
			}
		}

		//
		// Spit into EXE paths and args
		//

		int iSplit;
		if (strCommandLine[0] == L'\"')
		{
			// Quoted exe
			iSplit = strCommandLine.Find (L'\"', 1);
			VSASSERT (iSplit != -1, "Quote not found");
			VSASSERT (iSplit > 0, "Empty EXE Path");

			strCommand = strCommandLine.Mid (1, iSplit - 1);
		}

		else
		{
			iSplit = strCommandLine.Find (L' ');
			VSASSERT (iSplit != -1, "Space not found");
			VSASSERT (iSplit > 0, "Empty EXE Path");

			strCommand = strCommandLine.Left (iSplit);
		}

		return S_OK;
	}

	HRESULT GetTestContainerCommand( CStringW& strCommand )
	{
		GetTestContainerName(strCommand);
		return S_OK;
	}	

	HRESULT GetRegSvrCommand( CStringW& strCommand )
	{
		LPTSTR pszFile;

		CStringW str;
		str.ReleaseBuffer(SearchPathW(
			NULL,
			L"regsvr32.exe",
			NULL,
			_MAX_PATH + 1,
			str.GetBuffer( _MAX_PATH + 1 ),
			&pszFile
			));

		strCommand = str;

		return strCommand.IsEmpty() ? E_FAIL : S_OK;
	}

	HRESULT BrowseForCommand(CStringW& strCommand)
	{
		VSOPENFILENAMEW openFileName = {0};
		CStringW strFilter( MAKEINTRESOURCE( IDS_EXEFilter ));
		CStringW strTitle( MAKEINTRESOURCE( IDS_DebugProgram ));

		strFilter.Replace( L';', 0 );
		strFilter += L'\0';

		openFileName.lStructSize = sizeof (VSOPENFILENAMEW);
		openFileName.hwndOwner = m_hWnd;
		openFileName.pwzDlgTitle = strTitle;
		openFileName.pwzFileName = strCommand.GetBuffer( _MAX_PATH );
		openFileName.nMaxFileName = _MAX_PATH;
		openFileName.pwzInitialDir = NULL;
		openFileName.pwzFilter = strFilter;  
		openFileName.nFilterIndex = 0;
		openFileName.nFileOffset = 0;
		openFileName.nFileExtension = 0;
		openFileName.dwHelpTopic = 0;
		openFileName.dwFlags = 0;

		CComPtr<IVsUIShell> pShell;
		ExternalQueryService( SID_SVsUIShell, IID_IVsUIShell, (void**)&pShell );
		VSASSERT( pShell, "Can't get the VsUIShell service! How can there not be a shell?!" );
		if( pShell )
			pShell->GetOpenFileNameViaDlg( &openFileName );

		strCommand = openFileName.pwzFileName;
		
		return strCommand.IsEmpty() ? E_FAIL : S_OK;
	}

	BOOL GetTestContainerName(CStringW& strTestContainer)
	{
		InitializeTestContainer();
		strTestContainer = s_strTestContainer;
		return !strTestContainer.IsEmpty();
	}

	void InitializeTestContainer()
	{
		if (s_bTestContainerInit)
			return;

		s_bTestContainerInit = TRUE;

		//
		// Search order:
		//  1) Common7\Tools
		//	2) vc7 directory
		//	3) devenv.exe directory
		//	4) Use SearchPath()


		// Try Common7\Tools
		///////////////////////////////////
		UtilGetCommon7Folder(s_strTestContainer);
		s_strTestContainer += L"Tools\\tstcon32.exe";
		CPathW pathExe1;
		if (pathExe1.Create(s_strTestContainer) && pathExe1.ExistsOnDisk())
			return;

		// Try vc7\bin
		///////////////////////////////////

		UtilGetVCInstallFolder(s_strTestContainer);
		s_strTestContainer += L"bin\\tstcon32.exe";
		CPathW pathExe2;
		if (pathExe2.Create(s_strTestContainer) && pathExe2.ExistsOnDisk())
			return;

		//
		// Try devenv.exe directory
		//
		UtilGetDevenvFolder(s_strTestContainer);
		s_strTestContainer += L"tstcon32.exe";

		CPathW pathExe3;
		if (pathExe3.Create(s_strTestContainer) && pathExe3.ExistsOnDisk())
			return;


		//
		// Try the path
		//
		wchar_t * psz, szPath[_MAX_PATH + 1];
		DWORD dw = SearchPathW(NULL, L"tstcon32.exe", NULL, _MAX_PATH, szPath, &psz);
		if ( 0 < dw && _MAX_PATH > dw )
			s_strTestContainer = szPath;
		else
			s_strTestContainer.Empty();
	}

public:
	CComBSTR m_bstrExe;
	CComBSTR m_bstrUrl;
	CComPtr<VCConfiguration> m_spConfig;

protected:
	CContainedWindow m_exeForDbg;
	CVCUIntArray m_listExeForDbgChoices;
	CVCStringWArray m_listExeForDbgStrings;
	CStringW m_strSavedText;
	HFONT m_hFont;
	HWND m_hwndParent;

	static BOOL s_bTestContainerInit;
	static CStringW s_strTestContainer;
};

#endif //__CCALLEXEFORDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\filegencfg.cpp ===
// filegencfg.cpp
// implementation of CFileGenCfg

#include "stdafx.h"
#include "vssolutn.h"
#include "filegencfg.h"

//////////////////////////////////////////////////////////////////////////////
// CFileGenCfg
// 

CFileGenCfg::CFileGenCfg( void ) : m_pFileConfig( NULL )
{
}

CFileGenCfg::~CFileGenCfg( void )
{
}

void CFileGenCfg::Initialize( VCFileConfiguration *pCfg )
{
	m_pFileConfig = pCfg;
}

HRESULT CFileGenCfg::CreateInstance( IVsCfg **ppCfg, VCFileConfiguration* pFileCfg )
{
	CComObject<CFileGenCfg> *pFileGenCfgObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CFileGenCfg>::CreateInstance( &pFileGenCfgObj );
	if( SUCCEEDED( hr ) )
	{
		pFileGenCfgObj->Initialize( pFileCfg );
		hr = pFileGenCfgObj->QueryInterface( _uuidof( IVsCfg ), (void**)ppCfg );
	}
	return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IVCCfg methods

STDMETHODIMP CFileGenCfg::get_Tool( VARIANT toolIndex, IUnknown **ppTool )
{
	CHECK_POINTER_NULL(ppTool)
	
	HRESULT hr;
	CComPtr<IDispatch> spTool;

	hr = m_pFileConfig->get_Tool(&spTool);		//Get the tool
	if (SUCCEEDED(hr)) 
	{
		//Return the unk interface of the tool
		hr = spTool->QueryInterface(IID_IUnknown, (void **) ppTool);
	}
	return hr;	
}

STDMETHODIMP CFileGenCfg::get_Object( IDispatch **ppConfig)
{
	CHECK_POINTER_NULL(ppConfig)
	
	HRESULT hr;
	hr = m_pFileConfig->QueryInterface(IID_IDispatch, (void **) ppConfig);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
// IVsCfg
STDMETHODIMP CFileGenCfg::get_DisplayName( BSTR *pVal )
{
	return m_pFileConfig->get_Name( pVal );
}

STDMETHODIMP CFileGenCfg::get_IsDebugOnly( BOOL *pVal )
{
	CHECK_POINTER_NULL(pVal)
	
    CComBSTR bstrName;
	m_pFileConfig->get_Name( &bstrName );
	if( !wcsstr( bstrName, L"Debug" ) )
		*pVal = TRUE;
	else
		*pVal = FALSE;
	return S_OK;
}

STDMETHODIMP CFileGenCfg::get_IsReleaseOnly( BOOL *pVal )
{
	CHECK_POINTER_NULL(pVal)

    CComBSTR bstrName;
	m_pFileConfig->get_Name( &bstrName );
	if( !wcsstr( bstrName, L"Release" ) )
		*pVal = TRUE;
	else
		*pVal = FALSE;
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPages methods
STDMETHODIMP CFileGenCfg::GetPages( CAUUID *pPages )
{
	CHECK_POINTER_NULL(pPages)
	
	// QI for ISpecifyPropertyPages from the config
	CComQIPtr<ISpecifyPropertyPages> pSPP = GetVCFileConfiguration();
	if( !pSPP )
		return E_NOINTERFACE;
	return pSPP->GetPages( pPages );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\exehierarchy.h ===
//---------------------------------------------------------------------------
// Microsoft VC++
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// CExeHierarchy.h: Definition of the CExeHierarchy class
//
// A separate interface object to CVC
//---------------------------------------------------------------------------

#if !defined(AFX_CExeHierarchy_H__BDD4A1A3_7A1F_11D0_AC13_00A0C91E29D5__INCLUDED_)
#define AFX_CExeHierarchy_H__BDD4A1A3_7A1F_11D0_AC13_00A0C91E29D5__INCLUDED_

#include "vssolutn.h"
#include "bldpkg.h"
#include "fpstfmt.h"

//
// When retrieving a shell interface from CExeHierarchy, perform a QI to get the desired interface.
// We can't perform a simple cast from CExeHierarchy to any shell interface because that prevents 
// CExeHierarchy from being aggregated correctly.
//
// Usage:	IVsHierarchy* pHier = VCQI_cast<IVsHierarchy>(this);
//			IVsProject*   pProj = VCQI_cast<IVsProject>(this);
//			etc.
//
// forward declaration
extern BOOL g_bCommandLineDBG;
class CExeHierarchy;

template <typename T> CComPtr<T> VCQI_cast( const CExeHierarchy* pCExeHierarchy) 
{ 
	CComPtr<T>	pT;
	((CExeHierarchy*)pCExeHierarchy)->QueryInterface( __uuidof(T), (void**)&pT );
	ASSERT( pT );
	return pT;
}

class CExeConfig :
	public IVCCfg,
	public ISpecifyPropertyPages,
	public IVsDebuggableProjectCfg,	// derives from IVsProjectCfg -> IVsCfg
	public IVsPersistSolutionOpts,
	public CComObjectRoot
{
public:
	CExeConfig(void) : m_pArchy(NULL) {}
	~CExeConfig(void){}
	static HRESULT CreateInstance(IVsDebuggableProjectCfg **ppGenCfg, LPCOLESTR pszFileName, LPCOLESTR pszArgs, 
		CExeHierarchy* pHierarchy);
	HRESULT Initialize(LPCOLESTR pszFileName, LPCOLESTR pszArgs, CExeHierarchy* pHierarchy);
	
BEGIN_COM_MAP(CExeConfig)
	COM_INTERFACE_ENTRY(IVsCfg)						// Config interfaces
	COM_INTERFACE_ENTRY(IVsProjectCfg)	
	COM_INTERFACE_ENTRY(IVsDebuggableProjectCfg)	
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)		
	COM_INTERFACE_ENTRY(IVsPersistSolutionOpts)
	COM_INTERFACE_ENTRY(IVCCfg)
END_COM_MAP()

private:
	CComQIPtr<IVCDebugSettingsImpl> m_pDbgSettings;
	CExeHierarchy* m_pArchy;

// IVsCfg
public:
	STDMETHOD(get_DisplayName)( /* [out] */ BSTR *pbstrDisplayName);
	STDMETHOD(get_IsDebugOnly)( /* [out] */ BOOL *pfIsDebugOnly);
	STDMETHOD(get_IsReleaseOnly)( /* [out] */ BOOL *pfIsRetailOnly);

// IVsProjectCfg
public:
	STDMETHOD(get_ProjectCfgProvider)( /* [out] */ IVsProjectCfgProvider **ppIVsProjectCfgProvider);
	STDMETHOD(get_CanonicalName)( /* [out] */ BSTR *pbstrCanonicalName);
	STDMETHOD(get_IsRetailOnly)( /* [out] */ BOOL *pfIsRetailOnly);
	STDMETHOD(get_Platform)( /* [out] */ GUID *pguidPlatform)
		{return E_NOTIMPL;	/* CExeConfig::get_Platform */ }
	STDMETHOD(EnumOutputs)( /* [out] */ IVsEnumOutputs **ppIVsEnumOutputs)
		{return E_NOTIMPL; /* CExeConfig::EnumOutputs */ }
	STDMETHOD(OpenOutput)( /* [in] */ LPCOLESTR szOutputCanonicalName, /* [out] */ IVsOutput **ppIVsOutput)
		{return E_NOTIMPL; /* CExeConfig::OpenOutput */ }
	STDMETHOD(get_BuildableProjectCfg)( /* [out] */ IVsBuildableProjectCfg **ppIVsBuildableProjectCfg)
		{return E_NOTIMPL; /* CExeConfig::get_BuildableProjectCfg */ }
	STDMETHOD(get_IsPackaged)( /* [out] */ BOOL *pfIsPackaged);
	STDMETHOD(get_IsSpecifyingOutputSupported)( /* [out] */ BOOL *pfIsSpecifyingOutputSupported);
	STDMETHOD(get_TargetCodePage)( /* [out] */ UINT *puiTargetCodePage);
	STDMETHOD(get_UpdateSequenceNumber)(/* [out] */ ULARGE_INTEGER *puliUSN)
		{return E_NOTIMPL; /* CExeConfig::get_UpdateSequenceNumber */ }
	STDMETHOD(get_RootURL)(/* [out] */ BSTR *pbstrRootURL)
		{return E_NOTIMPL; /* CExeConfig::get_RootURL */ }

// IVsDebuggableProjectCfg
public:
    STDMETHOD(DebugLaunch)(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch);
    STDMETHOD(QueryDebugLaunch)(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch, /* [out] */ BOOL *pfCanLaunch);

// ISpecifyPropertyPages
public:
    STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );

// IVCCfg
public:
	STDMETHOD(get_Tool)(/* [in] */ VARIANT toolIndex, /* [out] */ IUnknown **ppConfig)
		{return E_NOTIMPL; /* CExeConfig::get_Tool */ }
	STDMETHOD(get_Object)(/* [out] */ IDispatch **ppDebugSettings);
	
// IVsPersistSolutionOpts
public:
    STDMETHOD(SaveUserOptions)(IVsSolutionPersistence *pPersistence)
		{return E_NOTIMPL; /* CExeConfig::SaveUserOptions */ }
    STDMETHOD(LoadUserOptions)(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts)
		{return E_NOTIMPL; /* CExeConfig::LoadUserOptions */ }

    STDMETHOD(WriteUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    STDMETHOD(ReadUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
};

class CExeHierarchy : 
	public IVsUIHierarchy,			// derives from IVsHierarchy
	public IVsHierarchyDeleteHandler,
	public IVsProject,				
	public IVsProjectCfgProvider,	// derives drom IVsCfgProvider
	public IOleCommandTarget,	
	public IVsPersistHierarchyItem,
	public IPersistFileFormat,		// derives from IPersist
	public IVsPersistSolutionOpts,
	public IVsPerPropertyBrowsing,
	public IDispatchImpl<_Project, &IID__Project, &LIBID_DTE, 7, 0>,
	public CComObjectRoot
{
private:
	CComPtr<IServiceProvider> m_pServiceProvider;
	CComPtr<IVsDebuggableProjectCfg> m_pConfig;
	CComBSTR m_bstrName;
	CComBSTR m_bstrFullPath;
	// un-ref-counted ptr to parent hierarchy
	IUnknown *m_pParentHierarchy;
	VSITEMID m_dwParentHierarchyItemID;
	
public:
	CExeHierarchy(void){}
	~CExeHierarchy(void){}
	HRESULT Initialize(LPCOLESTR pszFileName, LPCOLESTR pszArgs );
	
DECLARE_NOT_AGGREGATABLE(CExeHierarchy)

BEGIN_COM_MAP(CExeHierarchy)
	COM_INTERFACE_ENTRY(IVsProject)					// Project interfaces
	COM_INTERFACE_ENTRY(IVsHierarchy)			
	COM_INTERFACE_ENTRY(IVsUIHierarchy)			
	COM_INTERFACE_ENTRY(IVsHierarchyDeleteHandler)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(_Project)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)

	COM_INTERFACE_ENTRY(IVsProjectCfgProvider)		// Config provider interfaces
	COM_INTERFACE_ENTRY(IVsCfgProvider)				

	COM_INTERFACE_ENTRY(IPersistFileFormat)			// Persistance interfaces
	COM_INTERFACE_ENTRY(IVsPersistHierarchyItem)			
	COM_INTERFACE_ENTRY(IVsPersistSolutionOpts)
END_COM_MAP()


//  IVsProject
public:
	STDMETHOD (IsDocumentInProject) ( LPCOLESTR pszMkDocument, BOOL *pfFound, VSDOCUMENTPRIORITY *pdwPriority, VSITEMID *pvsid)
		{return E_NOTIMPL; /* CExeHierarchy::IsDocumentInProject */ }
	STDMETHOD (GetMkDocument) (VSITEMID vsid, BSTR *pbstrMkDocument) {return E_NOTIMPL; /* CExeHierarchy::GetMkDocument */ }
	STDMETHOD (OpenItem) (VSITEMID vsid, REFGUID guidDocViewType, IUnknown *punkDocDataExisting, IVsWindowFrame **ppWindowFrame)
		{return E_NOTIMPL; /* CExeHierarchy::OpenItem */ }
	STDMETHOD (GetItemContext) (VSITEMID vsid, IServiceProvider **ppSP) {return E_NOTIMPL; /* CExeHierarchy::GetItemContext */ }
	STDMETHOD (GenerateUniqueItemName) ( VSITEMID itemidLoc, LPCOLESTR pszExt, LPCOLESTR pszSuggestedRoot, BSTR * pbstrItemName)
		{return E_NOTIMPL; /* CExeHierarchy::GenerateUniqueItemName */ }
	STDMETHOD (AddItem)( /* [in] */ VSITEMID itemidLoc, /* [in] */ VSADDITEMOPERATION dwAddItemOperation, /* [in] */ LPCOLESTR pszItemName, /* [in] */ DWORD cFilesToOpen, /* [in, size_is(cFilesToOpen)] */ LPCOLESTR rgpszFilesToOpen[], /* [in] */ HWND hwndDlg, /* [out, retval] */ VSADDRESULT * pResult)
		{return E_NOTIMPL; /* CExeHierarchy::AddItem */ }
	STDMETHOD (Close)(void) {return S_OK;}

// Project
public:
    /* _Project methods */
    STDMETHOD(get_Name)(BSTR FAR* pbstrName);
    STDMETHOD(put_Name)(BSTR bstrName) { return E_NOTIMPL; }
    STDMETHOD(get_FileName)(BSTR FAR* pbstrName);
    STDMETHOD(get_IsDirty)(VARIANT_BOOL FAR* lpfReturn);
    STDMETHOD(put_IsDirty)(VARIANT_BOOL Dirty){ return E_NOTIMPL; }
    STDMETHOD(get_Collection)(Projects FAR* FAR* lppaReturn){ return E_NOTIMPL; }
    STDMETHOD(SaveAs)(BSTR FileName){ return E_NOTIMPL; }
    STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn);
    STDMETHOD(get_Kind)(BSTR FAR* lpbstrFileName);
    STDMETHOD(get_ProjectItems)(ProjectItems FAR* FAR* lppcReturn){ return E_NOTIMPL; }
    STDMETHOD(get_Properties)(Properties FAR* FAR* ppObject){ return E_NOTIMPL; }
    STDMETHOD(get_UniqueName)(BSTR FAR* pbstrName){ return get_FileName(pbstrName); }
    STDMETHOD(get_Object)(IDispatch **ppProjectModel){ return E_NOTIMPL; }
    STDMETHOD(get_Extender)(BSTR bstrExtenderName, IDispatch **ppExtender){ return E_NOTIMPL; }
    STDMETHOD(get_ExtenderNames)(VARIANT *pvarExtenderNames){ return E_NOTIMPL; }
    STDMETHOD(get_ExtenderCATID)(BSTR *pbstrRetval){ return E_NOTIMPL; }
    STDMETHOD(get_FullName)(BSTR *lpbstrReturn);
    STDMETHOD(get_Saved)(VARIANT_BOOL *lpfReturn);
    STDMETHOD(put_Saved)(VARIANT_BOOL Dirty) { return S_OK; }
    STDMETHOD(get_SourceControl)(SourceControl **) { return E_NOTIMPL; /* CExeHierarchy::get_SourceControl */ }
    STDMETHOD(get_ConfigurationManager)(ConfigurationManager **ppConfigurationManager);
    STDMETHOD(get_Globals)(Globals ** /*ppGlobals*/) { return E_NOTIMPL;	/* CExeHierarchy::get_Globals*/ }
    STDMETHOD(Save)(BSTR /*FileName*/) { return E_NOTIMPL; /* CExeHierarchy::Save */ }
    STDMETHOD(get_ParentProjectItem)(ProjectItem ** ppProjectItem);
    STDMETHOD(get_CodeModel)(CodeModel ** ppCodeModel) { return E_NOTIMPL; }
    STDMETHOD(Delete)(void) { return E_NOTIMPL; }

    STDMETHOD(Reserved1)(BSTR ProgID, VARIANT FileName) { return E_NOTIMPL; }
    STDMETHOD(Reserved2)(BSTR Section, BSTR Key, BSTR Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved3)(BSTR Section, BSTR Key, BSTR FAR* lpbstrValue) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved4)(BSTR FAR* lpbstrHelpFile) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved4)(BSTR bstrHelpFile) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved5)(long FAR* lpdwContextID) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved5)(long dwContextID) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved6)(BSTR FAR* lpbstrDescription) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved6)(BSTR bstrDescription) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved7)(IDispatch * FAR* lppReferences) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved8)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved9)(long FAR* lpStartMode) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved9)(long StartMode) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved10)(BSTR FAR* lpbstrCompatibleOleServer) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved10)(BSTR bstrCompatibleOleServer) { return E_NOTIMPL; }
    STDMETHOD(Reserved11)() { return E_NOTIMPL; }
    STDMETHOD(get_Reserved12)(long FAR* lpkind) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved12)(long Type) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved13)(long FAR* lpIconState) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved13)(long IconState) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved17)(VARIANT_BOOL FAR* lpfReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved15)(IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved16)(BSTR FAR* lpbstrBldFName) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved16)(BSTR bstrBldFName) { return E_NOTIMPL; }

// IVsHierarchy
public:
	STDMETHOD(SetSite)( /* [in] */ IServiceProvider *pSP);
	STDMETHOD(GetSite)( /* [out] */ IServiceProvider **ppSP); 	
	STDMETHOD(QueryClose)( /* [out] */ BOOL *pfCanClose);
	STDMETHOD(GetGuidProperty)( /* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [out] */ GUID *pguid);
	STDMETHOD(SetGuidProperty)( /* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ REFGUID guid);
	STDMETHOD(GetProperty)( VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [out] */ VARIANT *pvar);
	STDMETHOD(SetProperty)( VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ VARIANT var);
	STDMETHOD(GetNestedHierarchy)( /* [in] */ VSITEMID itemid, /* [in] */ REFIID riid, /* [out] */ void **ppHierarchyNested, /* [out] */ VSITEMID *pitemidNested)
		{return E_NOTIMPL; /* CExeHierarchy::GetNestedHierarchy */ }
	STDMETHOD(GetCanonicalName)( /* [in] */ VSITEMID itemid, /* [out] */ BSTR *ppszName);
	STDMETHOD(ParseCanonicalName)( /* [in] */ LPCOLESTR pszName, /* [out] */ VSITEMID *pitemid);
	STDMETHOD(AdviseHierarchyEvents)( /* [in] */ IVsHierarchyEvents *pEventSink, /* [out] */ VSCOOKIE *pdwCookie);
	STDMETHOD(UnadviseHierarchyEvents)( /* [in] */ VSCOOKIE dwCookie) {return S_OK;}
	STDMETHOD(Unused0)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused1)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused2)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused3)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused4)( void ){return E_NOTIMPL;}

// IVsHierarchyDeleteHandler
public:
	STDMETHOD(QueryDeleteItem)(	/* [in] */ VSDELETEITEMOPERATION dwDelItemOp, /* [in] */ VSITEMID itemid, /* [retval][out] */ BOOL __RPC_FAR *pfCanDelete);
	STDMETHOD(DeleteItem)( /* [in] */ VSDELETEITEMOPERATION dwDelItemOp, /* [in] */ VSITEMID itemid);

// IVsUIHierarchy
public:
    STDMETHOD (QueryStatusCommand)(VSITEMID itemid, const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[],
		OLECMDTEXT *pCmdText);
	STDMETHOD(ExecCommand)(VSITEMID itemid, const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn,
		VARIANT* pvaOut);

// IOleCommandTarget
public:
	STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);
		   
// IVsCfgProvider
public:
	STDMETHOD(GetCfgs)(ULONG celt, IVsCfg *rgpcfg[], ULONG *pcActual, VSCFGFLAGS *prgfFlags); 

// IVsProjectCfgProvider
public:
	STDMETHOD(OpenProjectCfg)(/*[in]*/ LPCOLESTR szProjectCfgCanonicalName, IVsProjectCfg **ppIVsProjectCfg)
		{return E_NOTIMPL; /* CExeHierarchy::OpenProjectCfg */ }
	STDMETHOD(get_UsesIndependentConfigurations)(/*[out]*/ BOOL *pfUsesIndependentConfigurations);

// IPersist
public:
	STDMETHOD(GetClassID)( /* [out] */ CLSID *pClassID);

// IPersistFileFormat
public:
	STDMETHOD(IsDirty)(BOOL __RPC_FAR *pfIsDirty);
	STDMETHOD(InitNew)( DWORD nFormatIndex) { return E_NOTIMPL; }	// CExeHierarchy::InitNew
	STDMETHOD(Load)( LPCOLESTR pszFilename, DWORD grfMode, BOOL fReadOnly) { return S_OK; }
	STDMETHOD(Save)( LPCOLESTR pszFilename, BOOL fRemember, DWORD nFormatIndex) { return S_OK; }
	STDMETHOD(SaveCompleted)( LPCOLESTR pszFileName) {return S_OK; }
	STDMETHOD(GetCurFile)( LPOLESTR __RPC_FAR *ppszFilename, DWORD __RPC_FAR *pnFormatIndex);
	STDMETHOD(GetFormatList)( LPOLESTR __RPC_FAR *ppszFormatList ) {return E_NOTIMPL; }	// CExeHierarchy::GetFormatList

// IVsPersistHierarchyItem
public:
    STDMETHOD(IsItemDirty)( VSITEMID vsid, IUnknown __RPC_FAR *punkDocData, BOOL __RPC_FAR *pfDirty)
		{return E_NOTIMPL; /* CExeHierarchy::IsItemDirty */ }
    STDMETHOD(SaveItem)( VSSAVEFLAGS dwSave, LPCOLESTR lpstrMkDocument, VSITEMID vsid, IUnknown __RPC_FAR *punkDocData, BOOL __RPC_FAR *pfCanceled)
		{return E_NOTIMPL; /* CExeHierarchy::SaveItem */ }

// IVsPersistSolutionOpts
public:
    STDMETHOD(SaveUserOptions)(IVsSolutionPersistence *pPersistence) {return E_NOTIMPL; /* CExeHierarchy::SaveUserOptions */ }
    STDMETHOD(LoadUserOptions)(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts) {return E_NOTIMPL; /* CExeHierarchy::LoadUserOptions */ }
    STDMETHOD(WriteUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    STDMETHOD(ReadUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    
// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide);
	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay) { return E_NOTIMPL; /* CExeHierarchy::DisplayChildProperties */ }
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault) { return E_NOTIMPL; /* CExeHierarchy::HasDefaultValue */ }
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly);
	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc);
	STDMETHOD(GetClassName)(BSTR* pbstrClassName);
    STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
    STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}
};

class CCrashDumpHierarchy : public CExeHierarchy
{
// IPersist
public:
	STDMETHOD(GetClassID)( /* [out] */ CLSID *pClassID);
};

#endif // !defined(AFX_CExeHierarchy_H__BDD4A1A3_7A1F_11D0_AC13_00A0C91E29D5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\gencfg.cpp ===
// GenCfg.cpp : Implementation of CDevbldApp and DLL registration.

#include "stdafx.h"
#include "vssln.h"
#include "bldpkg.h"
#include "GenCfg.h"
#include "vcarchy.h"
#include "path2.h"
#include "msdbg.h"
#include "projouts.h"
#include "output.h"
#include "outsenum.h"
#include "outgroup.h"
#include "ErrContext2.h"
#include "utils.h"
#include "vsappid.h"
#include <dpkg.h>

/////////////////////////////////////////////////////////////////////////////
//
CGenCfg::CGenCfg()
{
	m_pBuildHelper = NULL;
}

CGenCfgBuildHelper::CGenCfgBuildHelper()
{
	m_ppFiles = NULL;
	m_celtFiles = 0;
}

CGenCfg::~CGenCfg()
{
	ClearOutputs();
	if (m_pBuildHelper)
		delete m_pBuildHelper;
}

CGenCfgBuildHelper::~CGenCfgBuildHelper() 
{
	for (int i = 0; i < NUMBER_OF(m_rgsrpIVsBuildStatusCallback); i++)
	{
		if (m_rgsrpIVsBuildStatusStreamCallback[i])
		{
			HRESULT hr = AtlFreeMarshalStream(m_rgsrpIVsBuildStatusStreamCallback[i]);
			VSASSERT(SUCCEEDED(hr), "Failed to free marshal a build status callback");
		}
	}
	FreeFiles(FALSE);
}

void CGenCfg::ClearOutputs()
{
	VCPOSITION pos = m_ListOutputs.GetHeadPosition();
	while (pos)
	{
		IVsOutput *pOut = (IVsOutput *)m_ListOutputs.GetNext(pos);
		if (pOut != NULL)
			pOut->Release();
	}
	m_ListOutputs.RemoveAll();
}

HRESULT CGenCfg::CreateInstance(IVsCfg * * ppGenCfg,CVCArchy *pArchy, VCConfiguration *pCfg)
{
	CComObject<CGenCfg> *pGenCfgObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CGenCfg>::CreateInstance(&pGenCfgObj);
	if (SUCCEEDED(hr))
	{
		pGenCfgObj->Initialize(pArchy, pCfg);
		hr = pGenCfgObj->QueryInterface(__uuidof(IVsCfg), (void**)ppGenCfg );
	}
	return hr;

}

void CGenCfg::Initialize(CVCArchy *pArchy, VCConfiguration *pCfg)
{
	m_pConfig = pCfg;
	if (pArchy)
		m_marshalVsProjectCfgProvider.Init((IVsProjectCfgProvider *)pArchy);
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg2
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_CfgType( /* [in] */ REFIID iidCfg, /* [out] */ void **ppCfg )
{
    return QueryInterface(iidCfg, ppCfg); 
}
	
STDMETHODIMP CGenCfg::get_OutputGroups( /* [in] */ ULONG celt, /* [in, out] */ IVsOutputGroup *rgpcfg[],
			/* [out] */ ULONG *pcActual)
{
	if( celt == 0 )
	{
		CHECK_POINTER_NULL(pcActual);
		*pcActual = 4;
		return S_OK;
	}

	if (celt != 1)
		CHECK_POINTER_NULL(pcActual);

	// return as many as they want.
	CComQIPtr<IVsProjectCfg2> pCfg = this;
	HRESULT hr = COutputGroup::CreateInstance(&rgpcfg[PRIMARY_OUTPUT], pCfg, PRIMARY_OUTPUT );
	RETURN_ON_FAIL(hr);
	if (pcActual)
		*pcActual = 1;

	if( celt > 1 )
	{
		hr = COutputGroup::CreateInstance(&rgpcfg[SECONDARY_OUTPUT], pCfg, SECONDARY_OUTPUT );
		RETURN_ON_FAIL(hr);
		*pcActual = 2;
	}
	
	if( celt > 2 )
	{
		COutputGroup::CreateInstance(&rgpcfg[CONTENT_OUTPUT], pCfg, CONTENT_OUTPUT );
		RETURN_ON_FAIL(hr);
		*pcActual = 3;
	}

	if( celt > 3 )
	{
		COutputGroup::CreateInstance(&rgpcfg[SOURCE_OUTPUT], pCfg, SOURCE_OUTPUT );
		RETURN_ON_FAIL(hr);
		*pcActual = 4;
	}

	return S_OK;
}

STDMETHODIMP CGenCfg::OpenOutputGroup(
		/* [in] */ LPCOLESTR szCanonicalName,
		/* [out] */ IVsOutputGroup **ppIVsOutputGroup)
{
	CHECK_POINTER_NULL(ppIVsOutputGroup);

	HRESULT hr = E_NOTIMPL;	// CGenCfg::OpenOutputGroup, anything other than what's specifically supported
	CStringW strCanonicalName = szCanonicalName;
	if (strCanonicalName == L"Built")
	{
		hr = COutputGroup::CreateInstance(ppIVsOutputGroup, this, PRIMARY_OUTPUT);
	}
	else if (strCanonicalName == L"ContentFiles")
	{
		hr = COutputGroup::CreateInstance(ppIVsOutputGroup, this, CONTENT_OUTPUT);
	}
	else if (strCanonicalName == L"Symbols")
	{
		hr = COutputGroup::CreateInstance(ppIVsOutputGroup, this, SECONDARY_OUTPUT);
	}
	else if (strCanonicalName == L"SourceFiles")
	{
		hr = COutputGroup::CreateInstance(ppIVsOutputGroup, this, SOURCE_OUTPUT);
	}

	return hr;
}

STDMETHODIMP CGenCfg::OutputsRequireAppRoot( /* [out] */ BOOL *pfRequiresAppRoot )
{
	CHECK_POINTER_NULL(pfRequiresAppRoot);
	*pfRequiresAppRoot = FALSE;
	return S_OK;
}
		
STDMETHODIMP CGenCfg::get_VirtualRoot( /* [out] */ BSTR *pbstrVRoot )
{
	CHECK_POINTER_NULL(pbstrVRoot);
	return E_NOTIMPL;	// CGenCfg::get_VirtualRoot
}

STDMETHODIMP CGenCfg::get_IsPrivate( /* [out] */ BOOL *pfPrivate )
{
	if( pfPrivate )
		*pfPrivate = FALSE;
	return S_FALSE;
}


//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_ProjectCfgProvider(/* [out] */ IVsProjectCfgProvider **ppIVsProjectCfgProvider)
{
	CHECK_POINTER_NULL(ppIVsProjectCfgProvider);
	return m_marshalVsProjectCfgProvider.UnmarshalPtr(ppIVsProjectCfgProvider);
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_CanonicalName(/* [out] */ BSTR *pbstrCanonicalName)
{
	CHECK_POINTER_NULL(pbstrCanonicalName);
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);
	return m_pConfig->get_Name(pbstrCanonicalName);
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_DisplayName(/* [out] */ BSTR *pbstrDisplayName)
{
	CHECK_POINTER_NULL(pbstrDisplayName);
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);
	return m_pConfig->get_Name(pbstrDisplayName);
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_IsDebugOnly(/* [out] */ BOOL *pfIsDebugOnly)
{
	CHECK_POINTER_NULL(pfIsDebugOnly)
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

    CComBSTR bstrName;
	HRESULT hr = m_pConfig->get_Name(&bstrName);
	RETURN_ON_FAIL(hr);
	if ( !wcsstr(bstrName,L"Debug") )
		*pfIsDebugOnly = TRUE;
	else
		*pfIsDebugOnly = FALSE;
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_IsReleaseOnly(/* [out] */ BOOL *pfIsRetailOnly)
{
	CHECK_POINTER_NULL(pfIsRetailOnly)
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

    CComBSTR bstrName;
	HRESULT hr = m_pConfig->get_Name(&bstrName);
	RETURN_ON_FAIL(hr);

	if ( !wcsstr(bstrName,L"Release") )
		*pfIsRetailOnly = TRUE;
	else
		*pfIsRetailOnly = FALSE;
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_IsRetailOnly(/* [out] */ BOOL *pfIsRetailOnly)
{
	return get_IsReleaseOnly(pfIsRetailOnly);
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_Platform(/* [out] */ GUID *pguidPlatform)
{
	CHECK_POINTER_NULL(pguidPlatform)

	*pguidPlatform = GUID_VS_PLATFORM_WIN32_X86;   // TODO: DRA Could be others too...
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::EnumOutputs(/* [out] */ IVsEnumOutputs **ppIVsEnumOutputs)
{
	CHECK_POINTER_NULL(ppIVsEnumOutputs);
	*ppIVsEnumOutputs = NULL;

	HRESULT hr = InitEnumOuts();
	if (SUCCEEDED(hr))
		hr = COutsEnum::CreateInstance(ppIVsEnumOutputs, m_pConfig, &m_ListOutputs);

	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::OpenOutput(
            /* [in] */ LPCOLESTR szOutputCanonicalName,
            /* [out] */ IVsOutput **ppIVsOutput)
{
	CHECK_POINTER_NULL(ppIVsOutput);
	ATLTRACENOTIMPL(L"CGenCfg::OpenOutput");
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_BuildableProjectCfg(/* [out] */ IVsBuildableProjectCfg **ppIVsBuildableProjectCfg)
{
	CHECK_POINTER_NULL(ppIVsBuildableProjectCfg);

	*ppIVsBuildableProjectCfg = this;
	((IVsBuildableProjectCfg *)this)->AddRef();

	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_IsPackaged(/* [out] */ BOOL *pfIsPackaged)
{
	CHECK_POINTER_NULL(pfIsPackaged);

	*pfIsPackaged = FALSE;
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_IsSpecifyingOutputSupported(/* [out] */ BOOL *pfIsSpecifyingOutputSupported)
{
	CHECK_POINTER_NULL(pfIsSpecifyingOutputSupported);

	*pfIsSpecifyingOutputSupported = FALSE;
	return S_OK;
}

//---------------------------------------------------------------------------
// Unicode is officially code page 1200.  For strict unicode vs. mbcs matching of
// project configurations, you can use TargetCodePage == 1200 as equivalent to
// the project configuration being for Unicode.  Project configurations which
// are generically not Unicode should use CP_ACP.
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_TargetCodePage(/* [out] */ UINT *puiTargetCodePage)
{
	CHECK_POINTER_NULL(puiTargetCodePage);

	*puiTargetCodePage = CP_ACP;
	return S_OK;
}

//---------------------------------------------------------------------------
// The UpdateSequenceNumber property is used to determine how often to reprompt
// the user about whether they would like to rebuild the solution.  The primary
// scenario for this property is stepping in the debugger.  On each step operation
// in the debugger, the solution build manager will check the active project
// configurations, to see if any have updated their USNs.
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_UpdateSequenceNumber(/* [out] */ ULARGE_INTEGER *puliUSN)
{
	CHECK_POINTER_NULL(puliUSN);

	puliUSN->LowPart = 0;
	puliUSN->HighPart = 0;
	return S_OK;
}


//---------------------------------------------------------------------------
// The RootURL property is the root URL for the project outputs.  Essentially,
// if an output's project-relative path is required, it's computed by removing
// the RootURL from its DeploySourceURL.  As is the case for DeploySourceURL
// values, the convention is that paths that are in the local filesystem
// begin with the eight characters: "file:///".
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_RootURL(/* [out] */ BSTR *pbstrRootURL)
{
	CHECK_POINTER_NULL(pbstrRootURL);
	*pbstrRootURL = NULL;

	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	CComPtr<IDispatch> spDispProject;
	m_pConfig->get_Project(&spDispProject);
	CComQIPtr<VCProject> spProject = spDispProject;
	CHECK_ZOMBIE(spProject, IDS_ERR_PROJ_ZOMBIE);

	return spProject->get_ProjectDirectory(pbstrRootURL);
}

//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_ProjectCfg(/* [out] */ IVsProjectCfg __RPC_FAR *__RPC_FAR *ppIVsProjectCfg)
{
	CHECK_POINTER_NULL(ppIVsProjectCfg);

	*ppIVsProjectCfg = static_cast<IVsProjectCfg2*>(this);
	(*ppIVsProjectCfg)->AddRef();
	return S_OK;

}

STDMETHODIMP CGenCfg::AdviseBuildStatusCallback( 
            /* [in] */ IVsBuildStatusCallback __RPC_FAR *pIVsBuildStatusCallback,
            /* [out] */ VSCOOKIE __RPC_FAR *pdwCookie)
{ // stolen from solution\sprojbld.cpp (CVsSimpleProjectBuilder)
	CHECK_POINTER_NULL(pdwCookie);
	RETURN_INVALID_ON_NULL(pIVsBuildStatusCallback);

	if (m_pBuildHelper == NULL)
		m_pBuildHelper = new CGenCfgBuildHelper;
	RETURN_ON_NULL2(m_pBuildHelper, E_OUTOFMEMORY);

	return m_pBuildHelper->AdviseBuildStatusCallback(pIVsBuildStatusCallback, pdwCookie);
}

HRESULT CGenCfgBuildHelper::AdviseBuildStatusCallback( 
            /* [in] */ IVsBuildStatusCallback __RPC_FAR *pIVsBuildStatusCallback,
            /* [out] */ VSCOOKIE __RPC_FAR *pdwCookie)
{ // stolen from solution\sprojbld.cpp (CVsSimpleProjectBuilder)
	ULONG i;

	for (i=0; i<NUMBER_OF(m_rgsrpIVsBuildStatusCallback); i++)
	{
		if (m_rgsrpIVsBuildStatusCallback[i] == NULL)
			break;
	}

	if (i < NUMBER_OF(m_rgsrpIVsBuildStatusCallback))
	{
		HRESULT hr;
		CComPtr<IStream> pIStream;

		*pdwCookie = (i + 1);
		//m_rgsrpIVsBuildStatusCallback[i].p = pIVsBuildStatusCallback; // just set the pointer. Don't addref
		m_rgsrpIVsBuildStatusCallback[i] = pIVsBuildStatusCallback; 
		hr = AtlMarshalPtrInProc((IUnknown *)pIVsBuildStatusCallback, __uuidof (IVsBuildStatusCallback),
			&pIStream);
		VSASSERT(SUCCEEDED(hr), "Failed to marshal IVsBuildStatusCallback pointer!");
		if (SUCCEEDED(hr))
		{
			m_rgsrpIVsBuildStatusStreamCallback[i] = pIStream;

			// We'll tick right now so we can just keep track of whether we want
			// to issue further ticks.
			hr = pIVsBuildStatusCallback->Tick(NULL);
			VSASSERT(SUCCEEDED(hr), "Tick failed!");

			m_rgfTicking[i] = (hr != S_FALSE);
		}

		return NOERROR;
	}

	// We're out of room.
	return CONNECT_E_ADVISELIMIT;
}
        
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::UnadviseBuildStatusCallback(/* [in] */ VSCOOKIE dwCookie)
{
	RETURN_ON_NULL2(m_pBuildHelper, S_OK);
	return m_pBuildHelper->UnadviseBuildStatusCallback(dwCookie);
}

HRESULT CGenCfgBuildHelper::UnadviseBuildStatusCallback(/* [in] */ VSCOOKIE dwCookie)
{
	HRESULT hr;

	VSASSERT((dwCookie > 0) && (dwCookie <= NUMBER_OF(m_rgsrpIVsBuildStatusCallback)), "Callback cookie out of range");

	if ((dwCookie <= 0) || (dwCookie > NUMBER_OF(m_rgsrpIVsBuildStatusCallback)))
		RETURN_INVALID();

	dwCookie--;

	VSASSERT(m_rgsrpIVsBuildStatusCallback[dwCookie] != NULL, "Bad callback pointer at cookie!");

	if (m_rgsrpIVsBuildStatusStreamCallback[dwCookie])
	{
		IStream* pStream = m_rgsrpIVsBuildStatusStreamCallback[dwCookie];
		pStream->AddRef();	// this lets us release via AtlFreeMarshalStream AND by setting the pointer to NULL later...
		hr = AtlFreeMarshalStream(m_rgsrpIVsBuildStatusStreamCallback[dwCookie]);
		VSASSERT(SUCCEEDED(hr), "Failed to free marshal a callback pointer");
		if (SUCCEEDED(hr))
		{
			m_rgsrpIVsBuildStatusStreamCallback[dwCookie] = NULL;
		}
	}
	if (m_rgsrpIVsBuildStatusCallback[dwCookie])
		m_rgsrpIVsBuildStatusCallback[dwCookie] = NULL;

	return NOERROR;
}
   
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::StartBuild(IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, DWORD dwOptions)
{
	bldActionTypes bldType = TOB_Build;
	BOOL bLocalStorage = FALSE;
	if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_LOCAL)
		bLocalStorage = TRUE;
	if (dwOptions & VS_BUILDABLEPROJECTCFGOPTS_REBUILD)
		bldType = TOB_ReBuild;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_COMPILE)
		bldType = TOB_Compile;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_LINK)
		bldType = TOB_Link;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_PREBLD)
		bldType = TOB_PreBuildEvent;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_PRELINK)
		bldType = TOB_PreLinkEvent;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_POSTBLD)
		bldType = TOB_PostBuildEvent;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_DEPLOY)
		bldType = TOB_Deploy;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_XBOXIMAGE)
		bldType = TOB_XboxImage;
	else if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_XBOXDEPLOY)
		bldType = TOB_XboxDeploy;

	return DoStartBuild(pIVsOutputWindowPane, bldType, bLocalStorage);
}
        
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::StartClean( 
				/* [in] */ IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane,
				/* [in] */ DWORD dwOptions)
{
	BOOL bLocalStorage = FALSE;
	if (dwOptions & VC_BUILDABLEPROJECTCFGOPTS_LOCAL)
		bLocalStorage = TRUE;

	return DoStartBuild(pIVsOutputWindowPane, TOB_Clean, bLocalStorage);
}
        
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::StartUpToDateCheck( 
				/* [in] */ IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane,
				/* [in] */ DWORD dwOptions)
{
	RETURN_ON_NULL2(m_pConfig, S_FALSE);	// nothing we can do in this case...

	VARIANT_BOOL bUpToDate = VARIANT_FALSE;
	m_pConfig->get_UpToDate(&bUpToDate);
	return (bUpToDate == VARIANT_TRUE) ? S_OK : E_FAIL;
}
        
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::QueryStatus(/* [out] */ BOOL __RPC_FAR *pfBuildDone)
{
	BOOL bDone = !SpawnerActive();
	if (pfBuildDone)
		*pfBuildDone = bDone;

	return (bDone ? S_OK : E_FAIL);
}
        
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::Stop(/* [in] */ BOOL fSync)
{
	RETURN_ON_NULL2(m_pBuildHelper, S_OK);
	return m_pBuildHelper->Stop(fSync);
}

HRESULT CGenCfgBuildHelper::Stop(BOOL fSync)
{
	CComPtr<IVCBuildEngine> spBldEngine = m_spBuildEngine;	// QI just to make sure it doesn't go away on us in another thread...
	if (spBldEngine != NULL)
		spBldEngine->StopBuild();
	FreeFiles(FALSE);

	return S_OK;
}
        
//---------------------------------------------------------------------------
// interface: IVsBuildableProjectCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::Wait( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ BOOL fTickWhenMessageQNotEmpty)
{
	VSASSERT(dwMilliseconds == INFINITE, "Don't know how to do non-infinite wait");
	RETURN_ON_NULL2(m_pBuildHelper, S_OK);	// not doing a build

	return m_pBuildHelper->Wait(dwMilliseconds, fTickWhenMessageQNotEmpty);
}

HRESULT CGenCfgBuildHelper::Wait( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ BOOL fTickWhenMessageQNotEmpty)
{
	CComPtr<IVCBuildEngine> spBldEngine = m_spBuildEngine;	// QI just to make sure it doesn't go away on us in another thread...

	RETURN_ON_NULL2(spBldEngine, S_OK);	// not doing a build if this is NULL

	MSG msg;
	VARIANT_BOOL bSpawnerActive = VARIANT_FALSE;
	spBldEngine->get_SpawnerActive(&bSpawnerActive);
	while((bSpawnerActive == VARIANT_TRUE) && ::GetMessage(&msg, NULL, 0, 0))
    {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
		spBldEngine->get_SpawnerActive(&bSpawnerActive);
    }
	return S_OK;
}

STDMETHODIMP CGenCfg::QueryStartBuild( 
    /* [in] */ DWORD dwOptions,
    /* [optional][out] */ BOOL __RPC_FAR *pfSupported,
    /* [optional][out] */ BOOL __RPC_FAR *pfReady)
{
	return QueryCanBuild(pfSupported, pfReady);
}

HRESULT CGenCfg::QueryCanBuild(BOOL __RPC_FAR *pfSupported, BOOL __RPC_FAR *pfReady)
{
	HRESULT hr = SpawnerActive() ? E_FAIL : S_OK;

	if (pfSupported != NULL && !IsBadWritePtr(pfSupported, sizeof(*pfSupported)))
		*pfSupported = TRUE;

	if (pfReady != NULL && !IsBadWritePtr(pfReady, sizeof(*pfReady)))
		*pfReady = SUCCEEDED(hr);

	return hr;
}

BOOL CGenCfg::SpawnerActive()
{
	RETURN_ON_NULL2(m_pBuildHelper, FALSE);
	return m_pBuildHelper->SpawnerActive();
}

BOOL CGenCfgBuildHelper::SpawnerActive()
{
	return (m_spBuildEngine != NULL);
}

STDMETHODIMP CGenCfg::QueryStartClean( 
    /* [in] */ DWORD dwOptions,
    /* [optional][out] */ BOOL __RPC_FAR *pfSupported,
    /* [optional][out] */ BOOL __RPC_FAR *pfReady)
{
	return QueryCanBuild(pfSupported, pfReady);
}



STDMETHODIMP CGenCfg::QueryStartUpToDateCheck( 
    /* [in] */ DWORD dwOptions,
    /* [optional][out] */ BOOL __RPC_FAR *pfSupported,
    /* [optional][out] */ BOOL __RPC_FAR *pfReady)
{
	if (pfSupported && !IsBadWritePtr(pfSupported, sizeof(*pfSupported)))
		*pfSupported = (m_pConfig != NULL); 
	if (pfReady && !IsBadWritePtr(pfReady, sizeof(*pfReady)))
		*pfReady = (m_pConfig != NULL);

	return (m_pConfig != NULL) ? S_OK : E_FAIL;
}



// protected
HRESULT CGenCfg::InitEnumOuts()
{
	VSASSERT(m_pConfig != NULL, "Config is NULL!  Is this GenCfg badly initialized or is it zombie?");
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	ClearOutputs();	// a little inefficient in some ways...

	CComBSTR bstrPrimaryOutput;
	HRESULT hr = m_pConfig->get_PrimaryOutput(&bstrPrimaryOutput);
	RETURN_ON_FAIL(hr);
	if (bstrPrimaryOutput.Length() == 0)
		CHECK_ZOMBIE(NULL, IDS_ERR_CFG_ZOMBIE);
	
	CStringW strPrimaryOutput = bstrPrimaryOutput;
	CPathW path;
	if (!path.CreateFromKnown(strPrimaryOutput))
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComPtr<IVsOutput> spOut;
	hr = CProjectOutput::CreateInstance(&spOut, m_pConfig, path);
	VSASSERT(SUCCEEDED(hr) && spOut != NULL, "Out of memory");
	if (spOut)
	{
		IVsOutput* pProjOut = spOut.Detach();
		m_ListOutputs.AddTail((LPVOID)pProjOut);
	}

	CComBSTR bstrImportLib;
	HRESULT hr2 = m_pConfig->get_ImportLibrary(&bstrImportLib);
	if (hr2 == S_OK)
	{
		CStringW strImportLib = bstrImportLib;
		CPathW pathLib;
		if (!pathLib.Create(strImportLib))
			return VCPROJ_E_BAD_PATH;

		CComPtr<IVsOutput> spOut2;
		hr = CProjectOutput::CreateInstance(&spOut2, m_pConfig, pathLib);
		VSASSERT(SUCCEEDED(hr) && spOut2 != NULL, "Out of memory");
		if (spOut2)
		{
			IVsOutput* pProjOut = spOut2.Detach();
			m_ListOutputs.AddTail((LPVOID)pProjOut);
		}
	}
	return hr;
}

void CGenCfg::SetOutputPath(BSTR bstrOut, CPathW& rpathPrimary, CPathW& rpathPdb)
{
	CStringW strOut = bstrOut;
	CPathW pathOut;
	BOOL bOK = pathOut.Create(strOut);
	VSASSERT(bOK, "Failed to create output path!");
	CStringW strExt = pathOut.GetExtension();
	strExt.MakeLower();
	if (strExt == L".pdb")
		rpathPdb = pathOut;
	else
		rpathPrimary = pathOut;
}

STDMETHODIMP CGenCfg::InformBuildEnd(BOOL fOK)
{
	if (m_pBuildHelper)
		m_pBuildHelper->InformBuildEnd(fOK);

	return S_OK;	// return code not checked
}

void CGenCfgBuildHelper::InformBuildEnd(BOOL fOK)
{
	// handle EVERYTHING we can before we tell the solution we're done
	m_spBuildEngine.Release();
	if (m_spBuildThread)
	{
		m_spBuildThread->ExitThread();
		m_spBuildThread.Release();
	}

	GetBuildPkg()->DecrementSolutionBuildCount();

	// Inform the solution builder that the build is done
	// we're in the main thread now, so no need to marshal anything
	for (int i = 0; m_rgsrpIVsBuildStatusCallback[i]; i++)
	{
		m_rgsrpIVsBuildStatusCallback[i]->BuildEnd(fOK);
	}

	FreeFiles(FALSE);
}

STDMETHODIMP CGenCfg::InformBuildBegin()
{
	if (m_pBuildHelper)
		return m_pBuildHelper->InformBuildBegin();

	return S_OK;
}

HRESULT CGenCfgBuildHelper::InformBuildBegin()
{
	BOOL fContinue = TRUE;
	HRESULT hr;

	// Inform the solution builder that the build is starting
	for (int i = 0; m_rgsrpIVsBuildStatusCallback[i]; i++)
	{
		//m_rgsrpIVsBuildStatusCallback[i]->BuildBegin(&fContinue);
		if (m_rgsrpIVsBuildStatusStreamCallback[i])
		{
			IVsBuildStatusCallback *pIVsBuildStatusCallback;
			hr = AtlUnmarshalPtr(m_rgsrpIVsBuildStatusStreamCallback[i],
				__uuidof (IVsBuildStatusCallback), (IUnknown **)&pIVsBuildStatusCallback);
			VSASSERT(SUCCEEDED(hr), "Failed to unmarshal build status callback pointer");
			if (SUCCEEDED(hr) && pIVsBuildStatusCallback)
			{
				pIVsBuildStatusCallback->BuildBegin(&fContinue);
			}
		}
	}

	if (fContinue)
		GetBuildPkg()->IncrementSolutionBuildCount();
	return (fContinue ? S_OK : E_FAIL);
}

HRESULT CGenCfg::GetOutputWindowPane(IVsOutputWindowPane** ppOutputWindowPane)
{
	CHECK_POINTER_NULL(ppOutputWindowPane);

	CComPtr<IVsOutputWindow> spOutputWindow;
	HRESULT hr = ExternalQueryService(SID_SVsOutputWindow, __uuidof(IVsOutputWindow), (void **)&spOutputWindow);
	RETURN_ON_FAIL_OR_NULL(hr, spOutputWindow);

	hr = spOutputWindow->GetPane(GUID_BuildOutputWindowPane, ppOutputWindowPane);
	RETURN_ON_FAIL_OR_NULL(hr, *ppOutputWindowPane);

	return S_OK;
}

STDMETHODIMP CGenCfg::StartAutomationBuild(bldActionTypes bldType)
{
	HRESULT hr = QueryCanBuild(NULL, NULL);	// returns S_OK if no build currently in progress
	RETURN_ON_FAIL(hr);

	DWORD dwFlags = VC_BUILDABLEPROJECTCFGOPTS_LOCAL;
	VSSOLNBUILDUPDATEFLAGS solnFlags = SBF_OPERATION_BUILD;

	switch (bldType)
	{
	case TOB_Build:
		break;	// everything set up correctly already
	case TOB_ReBuild:
		dwFlags |= VS_BUILDABLEPROJECTCFGOPTS_REBUILD;
		break;
	case TOB_Clean:
		solnFlags = SBF_OPERATION_CLEAN;
		break;
	case TOB_Link:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_LINK;
		break;
	case TOB_PreBuildEvent:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_PREBLD;
		break;
	case TOB_PreLinkEvent:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_PRELINK;
		break;
	case TOB_PostBuildEvent:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_POSTBLD;
		break;
	case TOB_Deploy:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_DEPLOY;
		break;
	case TOB_XboxImage:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_XBOXIMAGE;
		break;
	case TOB_XboxDeploy:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_XBOXDEPLOY;
		break;
	case TOB_Compile:
		dwFlags |= VC_BUILDABLEPROJECTCFGOPTS_COMPILE;
		break;
	default:
		RETURN_INVALID();
	}

	return StartSolutionBuild(dwFlags, solnFlags);
}

STDMETHODIMP CGenCfg::StartFileBuild(ULONG celtFiles, VCFile* pFiles[])
{
	HRESULT hr = QueryCanBuild(NULL, NULL);	// returns S_OK if no build currently in progress
	RETURN_ON_FAIL(hr);

	if (m_pBuildHelper == NULL)
		m_pBuildHelper = new CGenCfgBuildHelper;
	RETURN_ON_NULL2(m_pBuildHelper, E_OUTOFMEMORY);

	hr = m_pBuildHelper->SetLocalStorage(celtFiles, pFiles);
	RETURN_ON_FAIL(hr);

	hr = StartSolutionBuild(VC_BUILDABLEPROJECTCFGOPTS_LOCAL | VC_BUILDABLEPROJECTCFGOPTS_COMPILE, SBF_OPERATION_BUILD);
	if (FAILED(hr) && m_pBuildHelper)
		m_pBuildHelper->FreeFiles(FALSE);
	return hr;
}

HRESULT CGenCfgBuildHelper::SetLocalStorage(ULONG celtFiles, VCFile* pFiles[])
{
	FreeFiles(TRUE);
	if (celtFiles == 0)
		return S_FALSE;

	m_ppFiles = (VCFile**) ::CoTaskMemAlloc(celtFiles * sizeof(VCFile *));
	memset(m_ppFiles, 0, sizeof(VCFile*)*celtFiles);
	RETURN_ON_NULL2(m_ppFiles, E_OUTOFMEMORY);

	m_celtFiles = celtFiles;
	for (ULONG idx = 0; idx < m_celtFiles; idx++)
	{
		VCFile* pFile = pFiles[idx];
		if (pFile)
			pFile->AddRef();
		m_ppFiles[idx] = pFile;
	}
	return S_OK;
}

void CGenCfgBuildHelper::FreeFiles(BOOL bExpectFresh)
{
	if (bExpectFresh)
		VSASSERT(m_ppFiles == NULL, "Hey, trying to reuse the files list before it's ready!");

	if (m_ppFiles == NULL && m_celtFiles == 0)
		return;

	for (ULONG idx = 0; idx < m_celtFiles; idx++)
	{
		VCFile* pFile = m_ppFiles[idx];
		if (pFile)
			pFile->Release();
	}
	::CoTaskMemFree(m_ppFiles);
	m_ppFiles = NULL;
	m_celtFiles = 0;
}
 
HRESULT CGenCfg::StartSolutionBuild(DWORD dwFlags, VSSOLNBUILDUPDATEFLAGS solnFlags)
{
	CComPtr<IVsProjectCfgProvider> spCfgProvider;
	HRESULT hr = m_marshalVsProjectCfgProvider.GetPtr(&spCfgProvider);
	CComQIPtr<IVsHierarchy> spHier = spCfgProvider;
	RETURN_ON_FAIL_OR_NULL2(hr, spHier, E_UNEXPECTED);

	CComPtr<IVsSolutionBuildManager> spBldMgr;
	hr = GetBuildPkg()->GetSolutionBuildManager(&spBldMgr, TRUE);
	CComQIPtr<IVsSolutionBuildManager2> spBldMgr2 = spBldMgr;
	VSASSERT(spBldMgr2, "Hey, why no IVsSolutionBuildManager2 for IVsSolutionBuildManager?!?");
	RETURN_ON_FAIL_OR_NULL2(hr, spBldMgr2, E_UNEXPECTED);

	IVsHierarchy* pHierTmp = spHier;	// yes, no refcount
	IVsCfg* pVsCfg = (IVsCfg*)(IVsProjectCfg2*)this;		// yes, no refcount
	return spBldMgr2->StartUpdateSpecificProjectConfigurations(1, &pHierTmp, &pVsCfg, 
		solnFlags & SBF_OPERATION_CLEAN ? &dwFlags : NULL, solnFlags & SBF_OPERATION_CLEAN ? NULL : &dwFlags,
		NULL /* deploy flags */, solnFlags, !(FIsIDEInteractive()));
}

STDMETHODIMP CGenCfg::SupportsBuildType(bldActionTypes buildType, VARIANT_BOOL* pbSupports, VARIANT_BOOL* pbAvailable)
{
	CHECK_POINTER_NULL(pbSupports);
	CHECK_POINTER_NULL(pbAvailable);
	*pbSupports = VARIANT_FALSE;
	*pbAvailable = VARIANT_FALSE;

	CComQIPtr<IVCConfigurationImpl> spCfgImpl = m_pConfig;
	CHECK_ZOMBIE(spCfgImpl, IDS_ERR_CFG_ZOMBIE);

	return spCfgImpl->SupportsBuildType(buildType, pbSupports, pbAvailable);
}

STDMETHODIMP CGenCfg::get_NoBuildIsInProgress(BOOL* pbNoneInProgress)
{
	return QueryCanBuild(NULL, pbNoneInProgress);
}

// IVsDebuggableProjectCfg
STDMETHODIMP CGenCfg::DebugLaunch(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch)
{
	CComPtr<IVsDebugger> pVsDebugger;
	HRESULT hr = ExternalQueryService(IID_IVsDebugger, IID_IVsDebugger, (void **)&pVsDebugger);
	RETURN_ON_FAIL2(hr, S_OK);
	RETURN_ON_NULL2(pVsDebugger, S_OK);

	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);
	CComPtr<IDispatch> pDispDbgSettings;
	m_pConfig->get_DebugSettings(&pDispDbgSettings);

	CComQIPtr<IVCDebugSettingsImpl> pDbgSettings = pDispDbgSettings;
	VSASSERT(pDbgSettings, "Failed to get debug settings object");
	RETURN_ON_NULL(pDbgSettings);

	VsDebugTargetInfo  dbgi[2];
	DWORD dwNumTargets = 2;
	ZeroMemory( dbgi, 2 * sizeof(VsDebugTargetInfo) );
	hr = pDbgSettings->CanGetDebugTargetInfo(NULL);
	if (hr != S_OK)
	{
		CComQIPtr<VCDebugSettings> pDbgSettingsPublic = pDbgSettings;
		hr = GetBuildPkg()->GetDebugCommandLines(pDbgSettingsPublic, m_pConfig);
	}
	if (hr == S_OK)
		hr = pDbgSettings->GetDebugTargetInfo( grfLaunch, dbgi, &dwNumTargets );
	if (hr == S_OK)
	{
		UpdateDebuggingInfoForDeployment(dbgi);
		
		hr = pVsDebugger->LaunchDebugTargets(dwNumTargets, dbgi);

		// free up the structures
		for (DWORD i = 0; i < dwNumTargets; i++)
		{
			SysFreeString(dbgi[i].bstrRemoteMachine);
			SysFreeString(dbgi[i].bstrMdmRegisteredName);
			SysFreeString(dbgi[i].bstrExe);
			SysFreeString(dbgi[i].bstrArg);
			SysFreeString(dbgi[i].bstrCurDir);
			SysFreeString(dbgi[i].bstrEnv);
			SysFreeString(dbgi[i].bstrOptions);
			CoTaskMemFree(dbgi[i].pClsidList);
		}
		if( FAILED(hr) )
		{
			CComBSTR bstrError;
			switch( hr )
			{
				case E_HTTP_PERMISSION_DENIED :
					bstrError.LoadString(IDS_E_DEBUG_ASPXPERMISSIONDENIED);
					UtilSetErrorInfo(E_FAIL, bstrError);
					break;
				case E_HTTP_FORBIDDEN :
					bstrError.LoadString(IDS_E_DEBUG_ASPXFORBIDDEN);
					UtilSetErrorInfo(E_FAIL, bstrError);
					break;
				case E_HTTP_SENDREQUEST_FAILED :
					bstrError.LoadString(IDS_E_DEBUG_ASPXSENDREQUESTFAILED);
					UtilSetErrorInfo(E_FAIL, bstrError);
					break;
				case E_HTTP_NOT_SUPPORTED :
					bstrError.LoadString(IDS_E_HTTP_NOT_SUPPORTED);
					UtilSetErrorInfo(E_FAIL, bstrError);
					break;
				case E_ATTACH_DEBUGGER_ALREADY_ATTACHED:
					bstrError.LoadString(IDS_E_DEBUG_ALREADY_ATTACHED);
					UtilSetErrorInfo(E_FAIL, bstrError);
					break;
				default :
					break;
			}
		}
	}

	return hr;
}

HRESULT CGenCfg::UpdateDebuggingInfoForDeployment(VsDebugTargetInfo* dbgi)
{
	CComPtr<IVsShell> spShell;
	HRESULT hr = ExternalQueryService(SID_SVsShell, IID_IVsShell, (void **)&spShell);
	if (hr != S_OK || spShell == NULL)
		return S_OK;

	// figure out if we've even got deployment involved
	CLSID clsidDeploy;
	hr = CLSIDFromString(VS_GUID_DEPLOYMENT_PACKAGE, &clsidDeploy);
	CComPtr<IVsPackage> spPackage;
	hr = spShell->IsPackageLoaded(clsidDeploy, &spPackage);
	if (hr != S_OK || spPackage == NULL)
		return S_OK;

	// check with deployment to see if this target has been deployed
	CComPtr<IVsSolutionDebuggingAssistant2> pDebugAss;
	hr = ExternalQueryService( SID_SVsSolutionDebuggingAssistant2, IID_IVsSolutionDebuggingAssistant2, (void**)&pDebugAss );
	if ( FAILED( hr ) || pDebugAss == NULL)
		return S_OK;

	CComQIPtr<IVsProjectCfg> pProjectCfg = (IVCGenericConfiguration*)this;
	CComBSTR bstrMachine, bstrURL;
	unsigned long ulNumTargets = 0;
	hr = pDebugAss->MapOutputToDeployedURLs( 0, pProjectCfg, dbgi[0].bstrExe, 1, &bstrMachine, &bstrURL, &ulNumTargets );
	if( FAILED( hr ) || ulNumTargets <= 0 )
		return S_OK;

	// reset the exe and remote machine
	SysFreeString(dbgi[0].bstrExe);
	SysFreeString(dbgi[0].bstrRemoteMachine);

	// Change the file URL to be a "Path"
	CStringW strExePath;
	if( bstrURL && _wcsnicmp(bstrURL,L"file:///", 8) == 0 )
	{
		CComBSTR bstrPath = bstrURL + 8;
		strExePath = bstrPath;
		dbgi[0].bstrExe = bstrPath.Detach();
	} 
	else 
	{
		strExePath = bstrURL;
		dbgi[0].bstrExe = bstrURL.Detach();
	}

	bstrMachine.CopyTo(&(dbgi[0].bstrRemoteMachine));

	if (m_pConfig == NULL || !(dbgi[0].bstrCurDir) || *(dbgi[0].bstrCurDir) == L'\0' || bstrMachine.Length() <= 0)
		return S_OK;

	CComBSTR bstrComputerName;
	if (::IsUnicodeSystem())
	{
		wchar_t wszComputerName[MAX_COMPUTERNAME_LENGTH+1];
		DWORD dwLen = MAX_COMPUTERNAME_LENGTH;
		if (::GetComputerNameW(wszComputerName, &dwLen))
			bstrComputerName = wszComputerName;
	}
	else	// must be Win9X
	{
		char szComputerName[MAX_COMPUTERNAME_LENGTH+1];
		DWORD dwLen = MAX_COMPUTERNAME_LENGTH;
		if (::GetComputerNameA(szComputerName, &dwLen))
			bstrComputerName = szComputerName;
	}
	if (bstrComputerName.Length() == 0)
		return S_OK;

	CStringW strDeployMachine = bstrMachine;
	CStringW strLocalMachine = bstrComputerName;
	strDeployMachine.MakeLower();
	strLocalMachine.MakeLower();
	if (strDeployMachine == strLocalMachine)
		return S_OK;

	CComBSTR bstrWorkingDir = dbgi[0].bstrCurDir;
	::SysFreeString(dbgi[0].bstrCurDir);
	dbgi[0].bstrCurDir = NULL;

	CDirW dirExe;
	if (!dirExe.CreateFromPath(strExePath))
		return S_OK;

	CComPtr<IDispatch> spDispProj;
	m_pConfig->get_Project(&spDispProj);
	CComQIPtr<VCProject> spProject = spDispProj;
	if (spProject == NULL)
		return S_OK;

	CComBSTR bstrProjDir;
	spProject->get_ProjectDirectory(&bstrProjDir);
	if (bstrProjDir.Length() == 0)
		return S_OK;

	CDirW dirProj;
	dirProj.CreateFromKnown(bstrProjDir);
	CStringW strWorkingDir = bstrWorkingDir;
	CPathW pathDir;
	if (!pathDir.Create(strWorkingDir))
		return S_OK;

	CStringW strRelativeName;
	if (!pathDir.GetRelativeName(dirProj, strRelativeName))
		strRelativeName = pathDir.GetFileName();

	CPathW pathNewDir;
	if (pathNewDir.CreateFromDirAndFilename(dirExe, strRelativeName))
	{
		CComBSTR bstrNewName = pathNewDir.GetFullPath();
		dbgi[0].bstrCurDir = bstrNewName.Detach();
	}

	return S_OK;
}

// IVsDebuggableProjectCfg
STDMETHODIMP CGenCfg::QueryDebugLaunch(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch, /* [out] */ BOOL *pfCanLaunch)
{
	CHECK_POINTER_NULL(pfCanLaunch);

	HRESULT hr = S_OK;
	if (m_pConfig == NULL)
		*pfCanLaunch = FALSE;
	else
	{
		CComPtr<IDispatch> pDispDbgSettings;
		hr = m_pConfig->get_DebugSettings(&pDispDbgSettings);
		CComQIPtr<VCDebugSettings> pDbgSettings = pDispDbgSettings;
		if( pDbgSettings )
			*pfCanLaunch = TRUE;
		else
			*pfCanLaunch = FALSE;
	}
	return hr;
}

//---------------------------------------------------------------------------
// interface: ISpecifyPropertyPages
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::GetPages(/* [out] */ CAUUID *pPages)
{
	CHECK_POINTER_NULL(pPages)
	
	CComQIPtr<ISpecifyPropertyPages> pSPP = GetVCConfiguration();
	RETURN_ON_NULL2(pSPP, E_NOINTERFACE);
	return pSPP->GetPages( pPages );
}

HRESULT CGenCfg::DoStartBuild(IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, bldActionTypes bldType, BOOL bLocalStorage)
{
	if (m_pBuildHelper == NULL)
		m_pBuildHelper = new CGenCfgBuildHelper;
	RETURN_ON_NULL2(m_pBuildHelper, E_OUTOFMEMORY);

	return m_pBuildHelper->DoStartBuild(this, m_pConfig, pIVsOutputWindowPane, bldType, bLocalStorage);
}

HRESULT CGenCfgBuildHelper::DoStartBuild(IVCGenericConfiguration* pGenCfg, VCConfiguration* pConfig, 
	IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, bldActionTypes bldType, BOOL bLocalStorage)
{
	VSASSERT(g_pBuildPackage->m_pProjectEngine != NULL, "No project engine!  How'd we get this far?");
	if (g_pBuildPackage->m_pProjectEngine == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	GetBuildPkg()->GetBuildEngine(&m_spBuildEngine);

	if (m_spBuildEngine == NULL)
	{
		VSASSERT(FALSE, "No build engine!  How'd we get this far?");
		return E_OUTOFMEMORY;
	}

	CHECK_ZOMBIE(pConfig, IDS_ERR_CFG_ZOMBIE);

	VARIANT_BOOL bBuildable = VARIANT_FALSE;
	VARIANT_BOOL bValid = VARIANT_FALSE;
	CComQIPtr <IVCConfigurationImpl> pConfigImpl = pConfig;
	HRESULT hr = pConfigImpl->get_IsBuildable(&bBuildable);
	RETURN_ON_FAIL(hr);
	 if (bBuildable == VARIANT_FALSE)
		 return DoSetErrorInfo(VCPROJ_E_NOT_BUILDABLE, IDS_ERR_PROJ_NOT_BUILDABLE);
	hr = pConfigImpl->get_IsValidConfiguration(&bValid);
	RETURN_ON_FAIL(hr);
	if (bValid == VARIANT_FALSE)
		 return DoSetErrorInfo(VCPROJ_E_NOT_BUILDABLE, IDS_ERR_PROJ_NOT_BUILDABLE);

	// doing this get of the solution build manager just to initialize it in the main thread
	CComPtr<IVsSolutionBuildManager> spSolnBldMgr;
	hr = GetBuildPkg()->GetSolutionBuildManager(&spSolnBldMgr, TRUE);
	RETURN_ON_FAIL_OR_NULL(hr, spSolnBldMgr);

	if (m_spBuildThread == NULL)
	{
		CComQIPtr <IVCBuildEngineImpl> spBuildEngineImpl = m_spBuildEngine;
		if (spBuildEngineImpl == NULL)
			return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
		else
			hr = spBuildEngineImpl->get_BuildThread(&m_spBuildThread);
		RETURN_ON_FAIL(hr);
		if (m_spBuildThread == NULL)
			return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}

	CComPtr<IVCBuildOutput> spModelessOutputWindow;
	hr = CVCBuildOutput::CreateInstance(&spModelessOutputWindow, pIVsOutputWindowPane);
	RETURN_ON_FAIL_OR_NULL(hr, spModelessOutputWindow);

	CComPtr<IVCBuildErrorContext> spErrorContext;

	CComPtr<IDispatch> spDispProject;
	pConfig->get_Project(&spDispProject);
	CComQIPtr<VCProject> spProject = spDispProject;
	RETURN_ON_NULL2(spProject, E_UNEXPECTED);
	CComBSTR bstrDir;
	spProject->get_ProjectDirectory(&bstrDir);
	CComBSTR bstrName;
	spProject->get_Name(&bstrName);

	CBldOutputWinEC::CreateInstance(&spErrorContext, NULL, m_spBuildEngine, bstrDir, spModelessOutputWindow);
	RETURN_ON_NULL2(spErrorContext, E_OUTOFMEMORY);
	spErrorContext->put_ProjectName(bstrName);

	hr = m_spBuildThread->InitializeForBuild(pGenCfg, pConfig, m_celtFiles, m_ppFiles, bldType, (m_ppFiles == NULL), 
		FALSE, m_spBuildEngine, spErrorContext);

	if (SUCCEEDED(hr))
		hr = m_spBuildThread->StartThread();
	
	return hr;
}
        
//---------------------------------------------------------------------------
// interface: IVCCfg
//---------------------------------------------------------------------------
STDMETHODIMP CGenCfg::get_Tool(/* [in] */ VARIANT toolIndex, /* [out] */ IUnknown **ppConfig)
{
	CHECK_POINTER_NULL(ppConfig);
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);
	
	HRESULT hr;

	CComQIPtr<IVCCollection> spCollection;	//Collection SP
	CComPtr<IDispatch> pDisp;

	hr = m_pConfig->get_Tools(&pDisp);	//Get the tools collection
	spCollection = pDisp;
	
	if (SUCCEEDED(hr) && spCollection)
	{
		CComPtr<IDispatch> spDisp;
		hr = spCollection->Item(toolIndex, &spDisp);	//Get the tool item
		RETURN_ON_FAIL_OR_NULL(hr, spDisp);
		hr = spDisp->QueryInterface(IID_IUnknown, (void **) ppConfig);	//Get the tool unk
	}
	
	return hr;
}

STDMETHODIMP CGenCfg::get_Object( IDispatch **ppConfig)
{
	CHECK_POINTER_NULL(ppConfig);
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);
	return m_pConfig->QueryInterface(IID_IDispatch, (void **) ppConfig);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\guids.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "rsrc.h"

#pragma warning(default:4103)
#include <initguid.h>

#include <resguid.h>
#include "bldguid.h"
#include <dbgpguid.h>
#include <objext.h>
#include <vcextgd.h>
#include <vcguid.h> 
#include "vc.h"

#ifdef AARDVARK
// {A5B688D0-F9AA-4462-94FF-6BD2D72C52BA}
DEFINE_GUID(IID_IStyleSheetHierarchy, 
0xa5b688d0, 0xf9aa, 0x4462, 0x94, 0xff, 0x6b, 0xd2, 0xd7, 0x2c, 0x52, 0xba);
#endif	// AARDVARK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\exehierarchy.cpp ===
//---------------------------------------------------------------------------
// Microsoft Visual InterDev
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// WebArchy.cpp : Implementation of CIswsApp and DLL registration.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "ExeHierarchy.h"
#include "..\resdll\gpcmd.h"
#include "VsCoCreate.h"
#include "context.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BOOL g_bCommandLineDBG = FALSE;

HRESULT CExeHierarchy::Initialize( LPCOLESTR pszFilename, LPCOLESTR pszArgs )
{
	wchar_t drive[_MAX_PATH];  // Should these be _MAX_DRIVE, _MAX_DIR and _MAX_FNAME?
	wchar_t path[_MAX_PATH];
	wchar_t name[_MAX_PATH];
	wchar_t ext[_MAX_EXT];

	_wsplitpath( pszFilename, drive, path, name, ext );

	m_bstrFullPath = pszFilename;
	m_bstrName = name;
	m_bstrName.Append(ext);

	m_pParentHierarchy = NULL;
	m_dwParentHierarchyItemID = VSITEMID_NIL;

    // To emulate VC6 behavior, we want to see if this .EXE has an BSC file associated with it.  If it does we want it loaded.
    wchar_t bscpath[_MAX_PATH];
    _wmakepath(bscpath, drive, path, name, L"bsc");

    if (GetFileAttributesW(bscpath) != -1)
    {
        //Try to open the .bsc
        CComPtr<IVsUIShellOpenDocument> spOpenDoc;
        BOOL bIsOpen = FALSE;
        if (SUCCEEDED(ExternalQueryService(SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument,reinterpret_cast<void **>(&spOpenDoc))) &&
            SUCCEEDED(spOpenDoc->IsDocumentOpen(NULL, NULL, bscpath, GUID_NULL, 0, NULL, NULL, NULL, &bIsOpen)))
        {
            // We are not checking the return value because we are not going to do anything with it anyways.
            if (!bIsOpen)
                spOpenDoc->OpenDocumentViaProject(bscpath, LOGVIEWID_Primary, NULL, NULL, NULL, NULL);
        }
    }
	
	return CExeConfig::CreateInstance(&m_pConfig, pszFilename, pszArgs, this);
}

// _Project
STDMETHODIMP CExeHierarchy::get_Name(BSTR FAR* pbstrName)
{
	wchar_t drive[_MAX_PATH];
	wchar_t path[_MAX_PATH];
	wchar_t name[_MAX_PATH];
	wchar_t ext[_MAX_EXT];

	_wsplitpath( m_bstrFullPath, drive, path, name, ext );

	CComBSTR bstrName = name;
	*pbstrName = bstrName.Detach();
	return S_OK;
}

STDMETHODIMP CExeHierarchy::get_FileName( BSTR *pbstrPath )
{
	return get_FullName(pbstrPath);
}

STDMETHODIMP CExeHierarchy::get_IsDirty(VARIANT_BOOL FAR* lpfReturn)
{
	CHECK_POINTER_VALID(lpfReturn)
	*lpfReturn = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CExeHierarchy::get_DTE(DTE FAR* FAR* lppaReturn)
{
	CHECK_POINTER_VALID(lppaReturn)
	return ExternalQueryService(SID_SDTE, IID__DTE, (void **)lppaReturn);
}

STDMETHODIMP CExeHierarchy::get_Kind(BSTR FAR* lpbstrFileName)
{
	CHECK_POINTER_VALID(lpbstrFileName);

	CComBSTR bstr = L"{F1C25864-3097-11D2-A5C5-00C04F7968B4}"; // should be guid ?
	*lpbstrFileName = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CExeHierarchy::get_FullName(BSTR *pbstrPath)
{
	CHECK_POINTER_VALID(pbstrPath);
	return m_bstrFullPath.CopyTo( pbstrPath );
}

STDMETHODIMP CExeHierarchy::get_Saved(VARIANT_BOOL *lpfReturn)
{
	CHECK_POINTER_VALID(lpfReturn)
	*lpfReturn = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CExeHierarchy::get_ConfigurationManager(ConfigurationManager **ppConfigurationManager)
{
	CHECK_POINTER_VALID(ppConfigurationManager);
	HRESULT hr = S_OK;
	CComPtr<IVsExtensibility> pExtService;
	CComPtr<IVsCfgProvider> pCfgProvider;

	hr = ExternalQueryService(SID_SVsExtensibility, IID_IVsExtensibility, (LPVOID*)&pExtService);
	RETURN_ON_FAIL_OR_NULL(hr, pExtService);

	CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(this);
	return pExtService->GetConfigMgr(spHier, VSITEMID_ROOT, ppConfigurationManager);
}

STDMETHODIMP CExeHierarchy::get_ParentProjectItem(ProjectItem ** ppProjectItem)
{
	CHECK_POINTER_VALID(ppProjectItem);
	*ppProjectItem = NULL;
	return NOERROR;
}

//  IVsHierarchy
STDMETHODIMP CExeHierarchy::SetSite(IServiceProvider *pSP)
{
	m_pServiceProvider = pSP;
	return S_OK;
}

STDMETHODIMP CExeHierarchy::GetSite(IServiceProvider **ppSP)
{
	CHECK_POINTER_NULL(ppSP);
	return m_pServiceProvider.CopyTo(ppSP);
}

STDMETHODIMP CExeHierarchy::QueryClose(BOOL *pfCanClose)
{
	CHECK_POINTER_NULL(pfCanClose);
	*pfCanClose = TRUE;
	return S_OK;
}

STDMETHODIMP CExeHierarchy::GetGuidProperty(VSITEMID itemid, VSHPROPID propid, GUID *pguid)
{
	CHECK_POINTER_NULL(pguid);
	return E_FAIL;
}

STDMETHODIMP CExeHierarchy::SetGuidProperty( /* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ REFGUID guid)
{
	return E_FAIL;
}

STDMETHODIMP CExeHierarchy::ParseCanonicalName( /* [in] */ LPCOLESTR pszName, /* [out] */ VSITEMID *pitemid)
{
	CHECK_POINTER_NULL(pitemid);
	return E_NOTIMPL;	// CExeHierarchy::ParseCanonicalName
}

STDMETHODIMP CExeHierarchy::GetCanonicalName( /* [in] */ VSITEMID itemid, /* [out] */ BSTR *ppszName)
{
	CHECK_POINTER_NULL(ppszName);
	if(itemid != VSITEMID_ROOT)
		return E_FAIL;

	return m_bstrFullPath.CopyTo( ppszName );
};

STDMETHODIMP CExeHierarchy::GetProperty(  VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [out] */ VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);
	switch(propid)
	{
		case VSHPROPID_Caption:
		case VSHPROPID_Name:
		{	
			V_VT(pvar) = VT_BSTR;
			return m_bstrName.CopyTo( &V_BSTR(pvar) );
		}
		case VSHPROPID_Expandable:		
		case VSHPROPID_ExpandByDefault:
		{
			V_VT(pvar) = VT_BOOL;
			V_BOOL(pvar) = VARIANT_FALSE;
			return S_OK;
		}
		case VSHPROPID_AltHierarchy:
		{
			V_VT(pvar) = VT_I4;
			V_UI4(pvar) = NULL;
			return E_FAIL;
		}
		case VSHPROPID_SortPriority:
		{
			V_VT(pvar) = VT_BOOL;
			V_UI4(pvar) = VARIANT_FALSE;
			return E_FAIL;
		}
		case VSHPROPID_ParentHierarchy:
		{
			pvar->vt = VT_UNKNOWN;
			if( !m_pParentHierarchy )
				return E_FAIL;
			pvar->punkVal = m_pParentHierarchy;
			if (pvar->punkVal)
				pvar->punkVal->AddRef();
			return S_OK;
		}
		case VSHPROPID_ParentHierarchyItemid:
		{
			pvar->vt = VT_INT_PTR;
			if( m_dwParentHierarchyItemID == VSITEMID_NIL )
			{
				V_INT_PTR(pvar) = VSITEMID_ROOT;
				return S_OK;
			}
			V_INT_PTR(pvar) = m_dwParentHierarchyItemID;
			return S_OK;
		}
		case VSHPROPID_Parent:			
		{
			V_VT(pvar) = VT_INT_PTR;
			V_INT_PTR(pvar) = VSITEMID_NIL;
			return S_OK;
		}
		case VSHPROPID_Root:			
		{
			V_VT(pvar) = VT_INT_PTR;			
			V_INT_PTR(pvar) = VSITEMID_ROOT;
			return S_OK;
		}

		case VSHPROPID_BrowseObject:
		case VSHPROPID_ExtObject:
		{
			VariantInit(pvar);
			if(SUCCEEDED(QueryInterface(IID_IDispatch, (void **)&V_DISPATCH(pvar))))
			{
				V_VT(pvar) = VT_DISPATCH;
				return S_OK;
			}
			return E_FAIL;
		}
		case VSHPROPID_ItemDocCookie:
		case VSHPROPID_ImplantHierarchy:
		case VSHPROPID_FirstVisibleChild:
		case VSHPROPID_NextVisibleSibling:
		case VSHPROPID_IsHiddenItem:
		case VSHPROPID_IsNonMemberItem:
		case VSHPROPID_OpenFolderIconIndex:
		case VSHPROPID_SelContainer:
		case VSHPROPID_EditLabel:
			return E_NOTIMPL;	// CExeHierarchy::GetProperty, several properties that don't need to be impl

		case VSHPROPID_UserContext:
			{
				V_VT(pvar) = VT_UNKNOWN;
				IVsUserContext *pUserCtx = NULL;
				CComPtr<IVsMonitorUserContext> pmuc;
				if (SUCCEEDED(ExternalQueryService(SID_SVsMonitorUserContext,
					IID_IVsMonitorUserContext, (void **)&pmuc)))
				{
					pmuc->CreateEmptyContext(&pUserCtx);
					if(pUserCtx)
					{
						pUserCtx->AddAttribute(VSUC_Usage_Filter, L"PRODUCT", L"VC");
						pUserCtx->AddAttribute(VSUC_Usage_Filter, L"ITEM", L"EXE");
						V_UNKNOWN(pvar) = pUserCtx;
						return S_OK;
					}
				}
				return E_FAIL;
			}
		case VSHPROPID_IconImgList:		
			V_VT(pvar) = VT_INT_PTR;
			V_INT_PTR(pvar) = reinterpret_cast<INT_PTR>(GetBuildPkg()->m_hImageList);
			return S_OK;
		
		case VSHPROPID_IconIndex:		
			V_VT(pvar) = VT_I4;
			V_I4(pvar) = BMP_PROJNODE;
			return S_OK;
		
		case VSHPROPID_StateIconIndex:
			V_VT(pvar) = VT_I4;
			V_I4(pvar) = STATEICON_NONE;
			return S_OK;
		
		case VSHPROPID_HandlesOwnReload:
		{
			V_VT(pvar) = VT_BOOL;
			V_BOOL(pvar) = VARIANT_TRUE;
			return S_OK;
		}
			
		default:
			break;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CExeHierarchy::SetProperty(VSITEMID itemid, VSHPROPID propid, /* [in] */ VARIANT var)
{
	switch( propid )
	{
	case VSHPROPID_ParentHierarchy:
		if( var.vt != VT_UNKNOWN )
			RETURN_INVALID();
		m_pParentHierarchy = var.punkVal;
		return S_OK;

	case VSHPROPID_ParentHierarchyItemid:
		if( var.vt != VT_I4 )
			RETURN_INVALID();
		m_dwParentHierarchyItemID = var.lVal;
		return S_OK;

	default:
		return S_OK;
	}
}


// IVsUIHierarchy
STDMETHODIMP CExeHierarchy::QueryStatusCommand( VSITEMID itemid, const GUID * pguidCmdGroup,
						ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
	return S_OK;
}

HRESULT CExeHierarchy::ExecCommand(
			VSITEMID itemid, const GUID * pguidCmdGroup, DWORD nCmdID,
			DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut)
{
	if(*pguidCmdGroup == GUID_VsUIHierarchyWindowCmds)
	{
		HRESULT hr;
		switch(nCmdID)
		{
			case UIHWCMDID_RightClick:
			{
				CComPtr<IOleComponentUIManager> pOleComponentUImanager;
				hr = ExternalQueryService(SID_OleComponentUIManager, __uuidof(IOleComponentUIManager), (void**)&pOleComponentUImanager);
				if (SUCCEEDED(hr) && pOleComponentUImanager)
				{
					CComQIPtr<IOleInPlaceComponentUIManager> pComponentUImanager = pOleComponentUImanager;
					if (pComponentUImanager)
						pComponentUImanager->UpdateUI(0, FALSE, 0);

					POINTS pnts;
					ULONG ulPts = V_UI4(pvaIn);
					memcpy((void*)&pnts, &ulPts, sizeof(POINTS));
					CComPtr<IOleCommandTarget> spTarget = VCQI_cast<IOleCommandTarget>(this);
					hr = pOleComponentUImanager->ShowContextMenu(
						0, 
						guidVCGrpId, 
						IDMX_VC_EXEPROJECT,
						pnts,
						spTarget);
				}

				break;
			}
//			case UIHWCMDID_DoubleClick:
//			case UIHWCMDID_EnterKey:
			default:
				hr = OLECMDERR_E_NOTSUPPORTED;
				break;
		}
		return hr;
	}

	return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CExeHierarchy::AdviseHierarchyEvents( /* [in] */ IVsHierarchyEvents *pEventSink, /* [out] */ VSCOOKIE *pdwCookie)
{
	CHECK_POINTER_NULL(pdwCookie);
	*pdwCookie = 1;
	return S_OK;
};

// IVsHierarchyDeleteHandler
STDMETHODIMP CExeHierarchy::QueryDeleteItem( /* [in] */ VSDELETEITEMOPERATION dwDelItemOp, /* [in] */ VSITEMID itemid, /* [retval][out] */ BOOL __RPC_FAR *pfCanDelete)
{
	CHECK_POINTER_NULL(pfCanDelete);

	if (dwDelItemOp != DELITEMOP_RemoveFromProject)	// support remove only, not delete
	{
		*pfCanDelete = FALSE;
		return S_OK;
	}

	// yes, we can be deleted
	*pfCanDelete = TRUE;
	return S_OK;
}
	
STDMETHODIMP CExeHierarchy::DeleteItem( /* [in] */ VSDELETEITEMOPERATION dwDelItemOp, /* [in] */ VSITEMID itemid)
{
	if (dwDelItemOp != DELITEMOP_RemoveFromProject)	// support remove only, not delete
		return E_UNEXPECTED;

	// cause the solution to shut down the project
	CComPtr<IVsSolution> pSolution;

	HRESULT hr = GetBuildPkg()->GetIVsSolution( &pSolution );
	VSASSERT( SUCCEEDED( hr ), "QueryService for solution failed!  Note that you can't do a QueryService for that in a secondary thread..." );
	RETURN_ON_FAIL(hr);
	
	// remove project from solution
	CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(this);
	return pSolution->CloseSolutionElement( SLNSAVEOPT_PromptSave, spHier, 0 );
}

// IOleCommandTarget
STDMETHODIMP CExeHierarchy::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
	return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CExeHierarchy::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
            VARIANT *pvaIn, VARIANT *pvaOut)
{
	return OLECMDERR_E_UNKNOWNGROUP;
}
			

		   
// IVsCfgProvider
STDMETHODIMP CExeHierarchy::GetCfgs(ULONG celt, IVsCfg *rgpcfg[], ULONG *pcActual, VSCFGFLAGS *prgfFlags)
{
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	if (celt == 0)
	{
		CHECK_POINTER_NULL(pcActual);
		*pcActual = 1;
		return S_OK;
	}

	CHECK_POINTER_NULL(rgpcfg);

	if (pcActual)
		*pcActual = 1;

	return m_pConfig->QueryInterface(IID_IVsCfg, (void**)rgpcfg);
}

// IVsProjectCfgProvider
STDMETHODIMP CExeHierarchy::get_UsesIndependentConfigurations(BOOL *pfUsesIndependentConfigurations )
{
	CHECK_POINTER_NULL(pfUsesIndependentConfigurations);
	*pfUsesIndependentConfigurations = FALSE;
	return S_FALSE;
};



HRESULT CExeConfig::CreateInstance(IVsDebuggableProjectCfg ** ppCfg, LPCOLESTR pszFilename, LPCOLESTR pszArgs, 
	CExeHierarchy* pArchy)
{
	CComObject<CExeConfig> *pCfg = NULL;  
	HRESULT hr = CComObject<CExeConfig>::CreateInstance(&pCfg);
	if (SUCCEEDED(hr))
	{
		pCfg->Initialize( pszFilename, pszArgs, pArchy );
		hr = pCfg->QueryInterface(__uuidof(IVsDebuggableProjectCfg), (void**)ppCfg );
	}
	return hr;
}

HRESULT CExeConfig::Initialize( LPCOLESTR pszFilename, LPCOLESTR pszArgs, CExeHierarchy* pArchy )
{
	CComPtr<VCDebugSettings> pDebug;
	HRESULT hr = VsLoaderCoCreateInstance<VCDebugSettings>(CLSID__VCDebugSettings, &pDebug);
//	HRESULT hr = pDebug.CoCreateInstance(CLSID_VCDebugSettings);
	if(SUCCEEDED(hr) && pDebug)
	{
		m_pDbgSettings = pDebug;

		wchar_t drive[_MAX_PATH];
		wchar_t path[_MAX_PATH];
		wchar_t name[_MAX_PATH];
		wchar_t ext[_MAX_EXT];

		_wsplitpath( pszFilename, drive, path, name, ext );

		CComBSTR bstrFullPath = pszFilename;
		CComBSTR bstrName = name;
		bstrName.Append(ext);
		
		CStringW strDir;
		if( g_bCommandLineDBG == TRUE )
		{
			GetCurrentDirectoryW(MAX_PATH, strDir.GetBuffer(MAX_PATH));
			strDir.ReleaseBuffer();
			g_bCommandLineDBG = FALSE;
		}
		else
		{
			strDir = drive;
			strDir += path;
		}

		CComBSTR bstrDir = strDir;
		CComBSTR bstrArgs = pszArgs;
		pDebug->put_Command(bstrFullPath);
		pDebug->put_WorkingDirectory(bstrDir);
		pDebug->put_CommandArguments(bstrArgs);

		m_pArchy = pArchy;
	}
	return hr;
}

	
// IVsCfg
STDMETHODIMP CExeConfig::get_DisplayName(BSTR *pbstrDisplayName)
{
	CHECK_POINTER_NULL(pbstrDisplayName);

	CComBSTR bstrCfg = L"Debug";
	return bstrCfg.CopyTo(pbstrDisplayName);
}
	
STDMETHODIMP CExeConfig::get_IsDebugOnly(BOOL *pfIsDebugOnly )
{
	CHECK_POINTER_NULL(pfIsDebugOnly);

	*pfIsDebugOnly = TRUE;
	return S_OK;
};

STDMETHODIMP CExeConfig::get_IsReleaseOnly(BOOL *pfIsRetailOnly)
{
	CHECK_POINTER_NULL(pfIsRetailOnly);

	*pfIsRetailOnly = FALSE;
	return S_FALSE;
};

// IVsProjectCfg
STDMETHODIMP CExeConfig::get_ProjectCfgProvider(/* [out] */ IVsProjectCfgProvider **ppIVsProjectCfgProvider)
{
	CHECK_POINTER_NULL(ppIVsProjectCfgProvider);
	*ppIVsProjectCfgProvider = NULL;

	CHECK_POINTER_NULL(m_pArchy);

	return m_pArchy->QueryInterface(IID_IVsProjectCfgProvider, (void**)ppIVsProjectCfgProvider );
}

STDMETHODIMP CExeConfig::get_CanonicalName(/* [out] */ BSTR *pbstrCanonicalName)
{
	CHECK_POINTER_NULL(pbstrCanonicalName);

	CComBSTR bstrCfg = L"Debug";
	return bstrCfg.CopyTo(pbstrCanonicalName);
}
	
STDMETHODIMP CExeConfig::get_IsRetailOnly(BOOL *pfIsRetailOnly)
{
	CHECK_POINTER_NULL(pfIsRetailOnly);

	*pfIsRetailOnly = FALSE;
	return S_FALSE;
};

STDMETHODIMP CExeConfig::get_IsPackaged(BOOL *pfIsPackaged)
{
	CHECK_POINTER_NULL(pfIsPackaged);

	*pfIsPackaged = FALSE;
	return S_FALSE;
};

STDMETHODIMP CExeConfig::get_IsSpecifyingOutputSupported(BOOL *pfIsSpecifyingOutputSupported)
{
	CHECK_POINTER_NULL(pfIsSpecifyingOutputSupported);

	*pfIsSpecifyingOutputSupported = FALSE;
	return S_FALSE;
};

STDMETHODIMP CExeConfig::get_TargetCodePage( /* [out] */ UINT *puiTargetCodePage)
{
	CHECK_POINTER_NULL(puiTargetCodePage);

	*puiTargetCodePage = 1200;
	return S_OK;
}

// IVsDebuggableProjectCfg
STDMETHODIMP CExeConfig::DebugLaunch(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch)
{
	CComPtr<IVsDebugger> pVsDebugger;
	HRESULT hr = ExternalQueryService(IID_IVsDebugger, IID_IVsDebugger, (void **)&pVsDebugger);
	if (SUCCEEDED(hr) && pVsDebugger)
	{
		VSASSERT(hr==S_OK, "Must have gotten some form of warning/success!");

		VsDebugTargetInfo  dbgi[2];
		ZeroMemory( dbgi, 2 * sizeof(VsDebugTargetInfo) );
		DWORD dwNumTargets = 2;

		CHECK_ZOMBIE(m_pDbgSettings, IDS_ERR_CFG_ZOMBIE);
		hr = m_pDbgSettings->CanGetDebugTargetInfo(NULL);
		if (hr != S_OK)
		{
			CComQIPtr<VCDebugSettings> pDbgSettingsPublic = m_pDbgSettings;
			hr = GetBuildPkg()->GetDebugCommandLines(pDbgSettingsPublic, NULL);
		}
		if (hr == S_OK)
			hr = m_pDbgSettings->GetDebugTargetInfo( grfLaunch, dbgi, &dwNumTargets );
		if (hr==S_OK)
		{
			hr = pVsDebugger->LaunchDebugTargets(dwNumTargets, dbgi);

			// free up the structures
			for (DWORD i = 0; i < dwNumTargets; i++)
			{
				SysFreeString(dbgi[i].bstrRemoteMachine);
				SysFreeString(dbgi[i].bstrMdmRegisteredName);
				SysFreeString(dbgi[i].bstrExe);
				SysFreeString(dbgi[i].bstrArg);
				SysFreeString(dbgi[i].bstrCurDir);
				SysFreeString(dbgi[i].bstrEnv);
				CoTaskMemFree(dbgi[i].pClsidList);
			}
		}

		if (FAILED(hr))
		{
			// do something reasonable here.
		}
	}

	return hr;
}

STDMETHODIMP CExeConfig::QueryDebugLaunch(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch, /* [out] */ BOOL *pfCanLaunch)
{
	CHECK_POINTER_NULL(pfCanLaunch);

	*pfCanLaunch = TRUE;
	return S_OK;
}

// ISpecifyPropertyPages
STDMETHODIMP CExeConfig::GetPages(/* [out] */ CAUUID *pPages)
{
	CHECK_POINTER_NULL(pPages);

	// number of tool pages plus number of 'extra' pages
	pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID));
	RETURN_ON_NULL2(pPages->pElems, E_OUTOFMEMORY);

	pPages->pElems[0] = __uuidof(DebugSettingsPage);
	pPages->cElems = 1;
	return S_OK;
}

// IVcCfg

STDMETHODIMP CExeConfig::get_Object( IDispatch **ppConfig)
{
	CHECK_POINTER_NULL(ppConfig);
	return m_pDbgSettings->QueryInterface(IID_IDispatch, (void **) ppConfig);
}

//

STDMETHODIMP CExeConfig::ReadUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	CHECK_READ_POINTER_NULL(pStream);

	CComBSTR	bstrName;
	HRESULT 	hr;
	
	//Read in the settings header
	hr = bstrName.ReadFromStream(pStream);
	RETURN_ON_FAIL(hr);

	//Check to see if this is the debug settings
	if (bstrName == L"DebugSettings")
	{
		//Load settings
		CHECK_ZOMBIE(m_pDbgSettings, IDS_ERR_CFG_ZOMBIE);
		hr = m_pDbgSettings->ReadFromStream(pStream);
		RETURN_ON_FAIL(hr);
	}

	return hr;
}

STDMETHODIMP CExeConfig::WriteUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	CHECK_READ_POINTER_NULL(pStream);
	CHECK_ZOMBIE(m_pDbgSettings, IDS_ERR_CFG_ZOMBIE);

	//Write out the debug settings header
	CComBSTR 	bstrName = L"DebugSettings";
	HRESULT 	hr;

	hr = bstrName.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	//Save to stream
	hr = m_pDbgSettings->WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	return hr;
}


// IPersist
STDMETHODIMP CExeHierarchy::GetClassID( CLSID *pClassID)
{
	CHECK_POINTER_NULL(pClassID);
	*pClassID = IID_IExeHierarchy;
	return S_OK;
}

// IPersistFileFormat
STDMETHODIMP CExeHierarchy::IsDirty(BOOL *pfIsDirty)
{
	CHECK_POINTER_NULL(pfIsDirty);

	*pfIsDirty = FALSE;
	return S_FALSE;
};


STDMETHODIMP CExeHierarchy::ReadUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	CHECK_READ_POINTER_NULL(pStream);
	CComQIPtr<IVsPersistSolutionOpts> pOpts = m_pConfig;
	CHECK_ZOMBIE(pOpts, IDS_ERR_CFG_ZOMBIE);
	return pOpts->ReadUserOptions(pStream, pszKey);
}

STDMETHODIMP CExeHierarchy::WriteUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	CHECK_READ_POINTER_NULL(pStream);
	CComQIPtr<IVsPersistSolutionOpts> pOpts = m_pConfig;
	CHECK_ZOMBIE(pOpts, IDS_ERR_CFG_ZOMBIE);
	return pOpts->WriteUserOptions(pStream, pszKey);
}

STDMETHODIMP CExeHierarchy::GetCurFile( /* [out] */ LPOLESTR __RPC_FAR *ppszFilename, /* [out] */ DWORD __RPC_FAR *pnFormatIndex)
{
	CHECK_POINTER_NULL(ppszFilename);

	DWORD dwLen = (DWORD)(ocslen(m_bstrFullPath) + sizeof(OLECHAR));

	*ppszFilename = (LPOLESTR)::CoTaskMemAlloc(dwLen * sizeof(OLECHAR));
	if (NULL == *ppszFilename)
		return E_OUTOFMEMORY;

	ocscpy(*ppszFilename, m_bstrFullPath);
	return S_OK;
};

// IVsPerPropertyBrowsing
STDMETHODIMP CExeHierarchy::HideProperty(DISPID dispid, BOOL *pfHide)
{
	*pfHide = FALSE;
	switch( dispid )
	{
	case DISPID_VALUE:
	case 209:
		*pfHide = FALSE;
		break;
	default:
		*pfHide = TRUE;
		break;
	}
	return S_OK;
}

// IVsPerPropertyBrowsing
STDMETHODIMP CExeHierarchy::IsPropertyReadOnly( DISPID dispid, BOOL *fReadOnly)
{ 
	*fReadOnly = TRUE;
	return S_OK; 
}

STDMETHODIMP CExeHierarchy::GetLocalizedPropertyInfo(DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
{
	CHECK_POINTER_NULL(pbstrName);
	*pbstrName = NULL;
	CHECK_POINTER_NULL(pbstrDesc);
	*pbstrDesc = NULL;

	CComBSTR bstrName;
	CComBSTR bstrDesc;

	switch( dispid )
	{
	case DISPID_VALUE:
	{
		if (!bstrName.LoadString(IDS_EXE_PROJ_NAME_LBL))
			bstrName = ( L"Name" );
		*pbstrName = bstrName.Detach();

		if (!bstrDesc.LoadString(IDS_EXE_PROJ_NAME_DESC))
			bstrDesc = ( L"The Name of the exe to debug" );

		break;
	}
	case 209:
	{
		if (!bstrName.LoadString(IDS_EXE_PROJ_PATH_LBL))
			bstrName = ( L"Full Path" );

		if (!bstrDesc.LoadString(IDS_EXE_PROJ_PATH_DESC))
			bstrDesc = ( L"The Full Path to the exe to debug" );

		break;
	}
	default:
		break;
	}

	if (bstrName)
		*pbstrName = bstrName.Detach();
	if (bstrDesc)
		*pbstrDesc = bstrDesc.Detach();
	
	return S_OK;
}

STDMETHODIMP CExeHierarchy::GetClassName(BSTR* pbstrClassName)
{
	CHECK_POINTER_NULL(pbstrClassName);
	CComBSTR bstrClassName;
	bstrClassName.LoadString(IDS_PROJ_PROPERTIES);
	*pbstrClassName = bstrClassName.Detach();
	if (*pbstrClassName)
		return S_OK;
	else
		return E_OUTOFMEMORY;
}

// IPersist
STDMETHODIMP CCrashDumpHierarchy::GetClassID( CLSID *pClassID)
{
	CHECK_POINTER_NULL(pClassID);
	*pClassID = IID_ICrashDumpHierarchy;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\global.inl ===
// requires inclusion of bldpkg.h

CBuildPackage* GetBuildPkg(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\filegencfg.h ===
// filegencfg.h
// declaration of the CFileGenCfg object

#ifndef __FILEGENCFG_H_
#define __FILEGENCFG_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rsrc.h"       // main symbols
// CFileGenCfg
// 

class CFileGenCfg : 
	public CComObjectRoot,
	public IVCCfg,
	public IVsCfg,
	public ISpecifyPropertyPages
{
public:
	CFileGenCfg( void );
	~CFileGenCfg( void );
	
	void Initialize( VCFileConfiguration *pCfg );
	static HRESULT CreateInstance( IVsCfg **ppGenCfg, VCFileConfiguration* pFileCfg );

BEGIN_COM_MAP(CFileGenCfg)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IVsCfg)
	COM_INTERFACE_ENTRY(IVCCfg)
END_COM_MAP()

	// IVCCfg methods
	STDMETHOD(get_Tool)( VARIANT toolIndex, IUnknown **ppTool );
	STDMETHOD(get_Object)( IDispatch **ppTool );
	
	// IVsCfg
	STDMETHOD(get_DisplayName)( BSTR *pVal );
	STDMETHOD(get_IsDebugOnly)( BOOL *pVal );
	STDMETHOD(get_IsReleaseOnly)( BOOL *pVal );

	// ISpecifyPropertyPages methods
    STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );

	VCFileConfiguration* GetVCFileConfiguration(){ return (VCFileConfiguration*)m_pFileConfig; }
private:
	CComPtr<VCFileConfiguration> m_pFileConfig;
	
};

#endif // end include fence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\gencfg.h ===
// GenCfg.h: Definition of the CGenCfg class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_GENCFG_H__9A9BFE7A_0D1A_11D1_B59E_00A0C91BC942__INCLUDED_)
#define AFX_GENCFG_H__9A9BFE7A_0D1A_11D1_B59E_00A0C91BC942__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "rsrc.h"       // main symbols
#include <path2.h>
#include "bldpkg.h"

#if !defined(NUMBER_OF)
#define NUMBER_OF(x) (sizeof(x) / sizeof((x)[0]))
#endif // !defined(NUMBER_OF)

const int MAX_ADVISES = 5;

#define PRIMARY_OUTPUT		0
#define SECONDARY_OUTPUT	1
#define CONTENT_OUTPUT		2
#define SOURCE_OUTPUT		3

/////////////////////////////////////////////////////////////////////////////
// CGenCfg

class CGenCfg;
class CVCArchy;
class COutputGroup;
class CGenCfgBuildHelper;

/////////////////////////////////////////////////////////////////////////////
// CGenCfg

class CGenCfg : 
	public IVsBuildableProjectCfg,
 	public ISpecifyPropertyPages,
	public IVsDebuggableProjectCfg,
	public IVsProjectCfg2,
	public CComObjectRoot,
	public IVCGenericConfiguration,
	public IVCCfg
{
public:
	CGenCfg();
	~CGenCfg();
	void Initialize(CVCArchy *pArchy, VCConfiguration *pCfg);
	static HRESULT CreateInstance(IVsCfg **ppGenCfg, CVCArchy *pArchy, VCConfiguration*);

BEGIN_COM_MAP(CGenCfg)
	COM_INTERFACE_ENTRY(IVCCfg)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IVsBuildableProjectCfg)
	COM_INTERFACE_ENTRY(IVsProjectCfg2)
	COM_INTERFACE_ENTRY(IVsDebuggableProjectCfg)
	COM_INTERFACE_ENTRY2(IVsProjectCfg, IVsDebuggableProjectCfg)
	COM_INTERFACE_ENTRY2(IVsCfg, IVsProjectCfg2)	// parent to IVsProjectCfg
	// IVsCfg
	COM_INTERFACE_ENTRY(IVCGenericConfiguration)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CGenCfg) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()


// IVsProjectCfg
public:
	STDMETHOD(get_ProjectCfgProvider)( IVsProjectCfgProvider **ppIVsProjectCfgProvider);
	STDMETHOD(get_CanonicalName)( BSTR *pbstrCanonicalName);
	STDMETHOD(get_DisplayName)( BSTR *pbstrDisplayName);
	STDMETHOD(get_IsDebugOnly)( BOOL *pfIsDebugOnly);
	STDMETHOD(get_IsReleaseOnly)( BOOL *pfIsRetailOnly);
	STDMETHOD(get_IsRetailOnly)( BOOL *pfIsRetailOnly);
	STDMETHOD(get_Platform)( GUID *pguidPlatform);
	STDMETHOD(EnumOutputs)( IVsEnumOutputs **ppIVsEnumOutputs);
	STDMETHOD(OpenOutput)(LPCOLESTR szOutputCanonicalName, IVsOutput **ppIVsOutput);
	STDMETHOD(get_BuildableProjectCfg)(IVsBuildableProjectCfg **ppIVsBuildableProjectCfg);
	STDMETHOD(get_IsPackaged)( BOOL *pfIsPackaged);
	STDMETHOD(get_IsSpecifyingOutputSupported)( BOOL *pfIsSpecifyingOutputSupported);

	// Unicode is officially code page 1200.  For strict unicode vs. mbcs matching of
	// project configurations, you can use TargetCodePage == 1200 as equivalent to
	// the project configuration being for Unicode.  Project configurations which
	// are generically not Unicode should use CP_ACP.
	STDMETHOD(get_TargetCodePage)( /* [out] */ UINT *puiTargetCodePage);

	// The UpdateSequenceNumber property is used to determine how often to reprompt
	// the user about whether they would like to rebuild the solution.  The primary
	// scenario for this property is stepping in the debugger.  On each step operation
	// in the debugger, the solution build manager will check the active project
	// configurations, to see if any have updated their USNs.
	STDMETHOD (get_UpdateSequenceNumber)(/* [out] */ ULARGE_INTEGER *puliUSN);

	// The RootURL property is the root URL for the project outputs.  Essentially,
	// if an output's project-relative path is required, it's computed by removing
	// the RootURL from its DeploySourceURL.  As is the case for DeploySourceURL
	// values, the convention is that paths that are in the local filesystem
	// begin with the eight characters: "file:///".
	STDMETHOD (get_RootURL)(/* [out] */ BSTR *pbstrRootURL);

// IVsProjectCfg2
public:
    STDMETHOD(get_CfgType)(REFIID iidCfg, void **ppCfg);
    STDMETHOD(get_OutputGroups)(ULONG celt, IVsOutputGroup *rgpcfg[], ULONG *pcActual);
    STDMETHOD(OpenOutputGroup)(LPCOLESTR szCanonicalName, IVsOutputGroup **ppIVsOutputGroup);
	STDMETHOD(OutputsRequireAppRoot)(BOOL *pfRequiresAppRoot);	// MattGe 8/12/99:  New method.
    STDMETHOD(get_VirtualRoot)(BSTR *pbstrVRoot);
    STDMETHOD(get_IsPrivate)(BOOL *pfPrivate);

// IVsBuildableProjectCfg        
public:
    STDMETHOD(get_ProjectCfg)(IVsProjectCfg __RPC_FAR *__RPC_FAR *ppIVsProjectCfg);
    STDMETHOD(AdviseBuildStatusCallback)(IVsBuildStatusCallback __RPC_FAR *pIVsBuildStatusCallback, VSCOOKIE __RPC_FAR *pdwCookie);
    STDMETHOD(UnadviseBuildStatusCallback)(VSCOOKIE dwCookie);
    STDMETHOD(StartBuild)(IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, DWORD dwOptions);
    STDMETHOD(StartClean)(IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, DWORD dwOptions);
    STDMETHOD(StartUpToDateCheck)(IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, DWORD dwOptions);
    STDMETHOD(QueryStatus)(BOOL __RPC_FAR *pfBuildDone);
    STDMETHOD(Stop)(BOOL fSync);
    STDMETHOD(Wait)(DWORD dwMilliseconds, BOOL fTickWhenMessageQNotEmpty);
    STDMETHOD(QueryStartBuild)(DWORD dwOptions, BOOL __RPC_FAR *pfSupported, BOOL __RPC_FAR *pfReady);
    STDMETHOD(QueryStartClean)(DWORD dwOptions, BOOL __RPC_FAR *pfSupported, BOOL __RPC_FAR *pfReady);
    STDMETHOD(QueryStartUpToDateCheck)(DWORD dwOptions, BOOL __RPC_FAR *pfSupported, BOOL __RPC_FAR *pfReady);
			
// IVsDebuggableProjectCfg
public:
    STDMETHOD(DebugLaunch)(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch);
    STDMETHOD(QueryDebugLaunch)(/* [in] */ VSDBGLAUNCHFLAGS grfLaunch, /* [out] */ BOOL *pfCanLaunch);

// ISpecifyPropertyPages
public:
    STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );
       
// IVCGenericConfiguration
public:
	STDMETHOD(InformBuildBegin)();
	STDMETHOD(InformBuildEnd)(BOOL fOK);
	STDMETHOD(StartAutomationBuild)(bldActionTypes bldType);
	STDMETHOD(StartFileBuild)(ULONG celt, VCFile* pFile[]);
	STDMETHOD(SupportsBuildType)(bldActionTypes buildType, VARIANT_BOOL* pbSupports, VARIANT_BOOL* pbAvailable);
	STDMETHOD(get_NoBuildIsInProgress)(BOOL* pbNoneInProgress);	// no build currently in progress

// IVCCfg
public:
	STDMETHOD(get_Tool)(/* [in] */ VARIANT toolIndex, /* [out] */ IUnknown **ppConfig);
	STDMETHOD(get_Object)(/* [out] */ IDispatch **ppConfig);

// CGenCfg
public:
	VCConfiguration* GetVCConfiguration()	{ return m_pConfig; }	// not ref-counted
	HRESULT StartSolutionBuild(DWORD dwFlags, VSSOLNBUILDUPDATEFLAGS solnFlags);

protected:
	HRESULT InitEnumOuts();
	void ClearOutputs();
	void SetOutputPath(BSTR bstrOut, CPathW& rpathPrimary, CPathW& rpathPdb);
	HRESULT DoStartBuild(IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, bldActionTypes bldType, BOOL bLocalStorage);
	HRESULT QueryCanBuild(BOOL __RPC_FAR *pfSupported, BOOL __RPC_FAR *pfReady);
	BOOL SpawnerActive();

// variables
protected:
	CComPtr<VCConfiguration> m_pConfig;
	CVCPtrList 	m_ListOutputs;	// list of CProjectOutput for IVsOutput enumeration. See COutsEnum
	CBldMarshaller<IVsProjectCfgProvider> m_marshalVsProjectCfgProvider;
	CGenCfgBuildHelper* m_pBuildHelper;

// some nice helper functions
public:
	static HRESULT GetOutputWindowPane(IVsOutputWindowPane** ppOutputWindowPane);

protected:
	HRESULT UpdateDebuggingInfoForDeployment(VsDebugTargetInfo* dbgi);
};

class CGenCfgBuildHelper
{
public:
	CGenCfgBuildHelper();
	~CGenCfgBuildHelper();
	HRESULT InformBuildBegin();
	void InformBuildEnd(BOOL fOK);
	HRESULT DoStartBuild(IVCGenericConfiguration* pGenCfg, VCConfiguration* pConfig, 
		IVsOutputWindowPane __RPC_FAR *pIVsOutputWindowPane, bldActionTypes bldType, BOOL bLocalStorage);
	HRESULT AdviseBuildStatusCallback(/* [in] */ IVsBuildStatusCallback __RPC_FAR *pIVsBuildStatusCallback,
		/* [out] */ VSCOOKIE __RPC_FAR *pdwCookie);
	HRESULT UnadviseBuildStatusCallback(/* [in] */ VSCOOKIE dwCookie);
	HRESULT Stop(BOOL fSync);
	HRESULT Wait(/* [in] */ DWORD dwMilliseconds, /* [in] */ BOOL fTickWhenMessageQNotEmpty);
	BOOL SpawnerActive();
	HRESULT SetLocalStorage(ULONG celtFiles, VCFile* pFiles[]);
	void FreeFiles(BOOL bExpectFresh);

public:
	// thread for building
	CComPtr<IVCBuildThread> m_spBuildThread;
	CComPtr<IVCBuildEngine> m_spBuildEngine;

	// for AdviseBuildStatusCallBack, etc.	
	CComPtr<IVsBuildStatusCallback> m_rgsrpIVsBuildStatusCallback[MAX_ADVISES];
	CComPtr<IStream> m_rgsrpIVsBuildStatusStreamCallback[MAX_ADVISES]; 
	bool m_rgfTicking[MAX_ADVISES];
	bool m_rgfStarted[MAX_ADVISES];
	VCFile** m_ppFiles;
	ULONG m_celtFiles;
};

#endif // !defined(AFX_GENCFG_H__9A9BFE7A_0D1A_11D1_B59E_00A0C91BC942__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\localeinfo.cpp ===
// localeinfo.cpp : Implementation of CLocaleInfo
#include "stdafx.h"

#include "localeinfo.h"
#include "path2.h"
#include "locale.h"
#include "register.h" // for CreateBaseKey
#include "profile.h"	// for GetRegString
#include "bldpkg.h"	// for ExternalQueryService

CLocaleInfo::CLocaleInfo()
{
	m_hInst = NULL;
	m_hInstMain = NULL;
}

CLocaleInfo::CLocaleInfo(HINSTANCE hInst, IServiceProvider *pServiceProvider)
{
	m_hInst = NULL;
	m_hInstMain = hInst;
}


CLocaleInfo::~CLocaleInfo() 
{
}


// returns NULL if can't find.
HINSTANCE CLocaleInfo::GetUIHostLib()
{
	if (m_hInst == NULL)
	{
		HRESULT hr = E_FAIL;
		HINSTANCE hInstUIDll = NULL;
		CComPtr<IUIHostLocale> pUIHostLocale;
		if (SUCCEEDED(ExternalQueryService(SID_SUIHostLocale, __uuidof(IUIHostLocale) /*IID_IUIHostLocale*/, (LPVOID *)&pUIHostLocale)))
		{
			CComQIPtr<IUIHostLocale2> pUIHostLocale2 = pUIHostLocale;
			if (pUIHostLocale2)
			{
				if (m_hInstMain)
				{
					CStringW strRoot = CBuildPackage::s_bstrAltKey;

					CComBSTR bstrPath;
					CComBSTR bstrDllName;
					LPOLESTR lpszBuf = NULL;
					StringFromCLSID(__uuidof(BuildPackage), &lpszBuf);
					CStringW strRegKey = strRoot + L"\\Packages\\";
					strRegKey += lpszBuf;
					strRegKey += L"\\SatelliteDLL";
					::CoTaskMemFree(lpszBuf);
					
					hr = GetRegStringW(strRegKey, L"Path", &bstrPath );
					hr = GetRegStringW(strRegKey, L"DllName", &bstrDllName );

					if( bstrPath.Length() == 0 || bstrDllName.Length() == 0 )
					{
						// Couldn't get the info from the registry. Fallback to 1033 directory
                        CStringW strModuleFileName;
						if (UtilGetModuleFileNameW(_Module.GetModuleInstance(), strModuleFileName))
						{
							wchar_t drive[_MAX_DRIVE];
							wchar_t dir[_MAX_DIR];
							wchar_t fname[_MAX_FNAME];
							wchar_t ext[_MAX_EXT];

							_wsplitpath( strModuleFileName, drive, dir, fname, ext );
							CStringW strDllName = drive;	
							strDllName += dir;	
							strDllName += L"1033\\";	
							strDllName += fname;
							strDllName += L"UI";
							strDllName += ext;
							hInstUIDll = LoadLibraryW( strDllName );
						}
					}
					else
					{
						hr = pUIHostLocale2->LoadUILibrary(bstrPath, bstrDllName, /*LOAD_LIBRARY_AS_DATAFILE |*/ DONT_RESOLVE_DLL_REFERENCES, (DWORD_PTR *)&hInstUIDll);
						VSASSERT(SUCCEEDED(hr) && hInstUIDll, "Failed to load the UI library");
					}
				}
			}
		}
		if(SUCCEEDED(hr))
		{
			m_hInst = hInstUIDll;
		}
	}
	return(m_hInst);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\optionsdlg.cpp ===
// BuildOptions.cpp : Implementation of CBuildOptions
#include "stdafx.h"
#include "OptionsDlg.h"
#include "bldpkg.h"
#include "profile.h"

/////////////////////////////////////////////////////////////////////////////
// CBuildOptions

LRESULT CBuildOptions::OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if( m_pGrid )
	{
	    m_pGrid->SetSelectedObjects( 0, NULL );
	    m_pGrid = NULL;
	}
	return 1;  // Let the system set the focus
}

LRESULT CBuildOptions::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

	CComPtr<IVSMDPropertyBrowser> pBrowser;
	HRESULT hr = ::ExternalQueryService(SID_SVSMDPropertyBrowser, __uuidof(IVSMDPropertyBrowser), (LPVOID *)&pBrowser);
	RETURN_ON_FAIL2(hr, 1);

	pBrowser->CreatePropertyGrid( &m_pGrid );

	if( hr == S_OK && m_pGrid )
	{

		HWND hwndGrid;
		HWND hwndGridPos;
		RECT rectGridPos;
		RECT rectGrid;
		hwndGridPos = ::GetDlgItem(m_hWnd, IDC_TOOLSOPTSGRIDPOS );
		::GetWindowRect(hwndGridPos, &rectGridPos);

		LONG res = ::GetWindowLong( hwndGridPos, GWL_STYLE );
		::SetWindowLong( hwndGridPos, GWL_STYLE, res ^ WS_VISIBLE );
		
		rectGrid.top = 0;
		rectGrid.left = 0;
		rectGrid.bottom = rectGridPos.bottom - rectGridPos.top;
		rectGrid.right = rectGridPos.right - rectGridPos.left;
		
		m_pGrid->get_Handle(&hwndGrid);
		CWindow wndGrid;
		wndGrid.Attach(hwndGrid);
		wndGrid.SetParent(m_hWnd);
        
	        VARIANT vt;
        	VariantInit(&vt);
	        V_VT(&vt) = VT_BOOL;
        	V_BOOL(&vt) = VARIANT_FALSE;

	        m_pGrid->SetOption(PGOPT_TOOLBAR, vt);
        	m_pGrid->put_GridSort(PGSORT_ALPHABETICAL);
		wndGrid.SetWindowPos( HWND_TOP, &rectGrid, SWP_FRAMECHANGED );
		
		IUnknown* pTemp = m_spOptions;
		m_pGrid->SetSelectedObjects( 1, &pTemp );
	}
	
	return 1;  // Let the system set the focus
}

LRESULT CBuildOptions::OnHelp(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	CComPtr<Help> pHlp;
	CComBSTR bstrTopic;
	bstrTopic = L"vc.proj.properties";

	HRESULT hr = ExternalQueryService(SID_SVsHelp, __uuidof(Help), (void **)&pHlp);
	if( pHlp )
		hr = pHlp->DisplayTopicFromF1Keyword(bstrTopic);
	return hr;
}

LRESULT CBuildOptions::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
	// let the project engine know about the changes
	VSASSERT(m_spOptions, "Don't have a property container to feed build option data back to!");

	CStringW strRoot  = CBuildPackage::s_bstrAltKey + "\\VC";
	VCProjectEngine *pProjEng = GetBuildPkg()->GetProjectEngine();

	VARIANT_BOOL buildLogging;
	m_spOptions->get_BuildLogging(&buildLogging);
	pProjEng->put_BuildLogging(buildLogging);
	WriteRegBoolW( strRoot, L"Build Logging", buildLogging );

	VARIANT_BOOL buildTiming;
	m_spOptions->get_BuildTiming(&buildTiming);
	pProjEng->put_BuildTiming(buildTiming);
	WriteRegBoolW( strRoot, L"Build Timing", buildTiming );

	// performance logging
	VARIANT_BOOL performanceLogging;
 	pProjEng->get_PerformanceLogging( &performanceLogging );	
	WriteRegBoolW( strRoot, L"Performance Logging", performanceLogging );

	CComBSTR bstrExt;
	m_spOptions->get_CPPExtensions(&bstrExt);
	// REVIEW: Multi platform broken !
	strRoot += L"\\VC_OBJECTS_PLATFORM_INFO\\Win32\\ToolDefaultExtensionLists\\";
	WriteRegStringW( strRoot, L"VCCLCompilerTool", bstrExt );
	return 0;
}

STDMETHODIMP CVCBuildOptionsPage::get_BuildLogging(VARIANT_BOOL *pbLog)
{
	CHECK_POINTER_NULL(pbLog);
	*pbLog = m_buildLogging;
	return S_OK;
}

STDMETHODIMP CVCBuildOptionsPage::put_BuildLogging(VARIANT_BOOL bLog)
{
	m_buildLogging = bLog;
	return S_OK;
}

STDMETHODIMP CVCBuildOptionsPage::get_BuildTiming(VARIANT_BOOL *pbTime)
{
	CHECK_POINTER_NULL(pbTime);
	*pbTime = m_buildTiming;
	return S_OK;
}

STDMETHODIMP CVCBuildOptionsPage::put_BuildTiming(VARIANT_BOOL bTime)
{
	m_buildTiming = bTime;
	return S_OK;
}

STDMETHODIMP CVCBuildOptionsPage::get_CPPExtensions(BSTR *pbstrExt)
{
	CHECK_POINTER_NULL(pbstrExt);
	return m_bstrExt.CopyTo(pbstrExt);
}

STDMETHODIMP CVCBuildOptionsPage::put_CPPExtensions(BSTR bstrExt)
{
    m_bstrExt = bstrExt;
	return S_OK;
}


STDMETHODIMP CVCBuildOptionsObject::get_BuildLogging(VARIANT_BOOL *pbLog)
{
	return g_pBuildPackage->m_pProjectEngine->get_BuildLogging(pbLog);
}

STDMETHODIMP CVCBuildOptionsObject::put_BuildLogging(VARIANT_BOOL bLog)
{
	return g_pBuildPackage->m_pProjectEngine->put_BuildLogging(bLog);
}

STDMETHODIMP CVCBuildOptionsObject::get_BuildTiming(VARIANT_BOOL *pbTime)
{
	return g_pBuildPackage->m_pProjectEngine->get_BuildTiming(pbTime);
}

STDMETHODIMP CVCBuildOptionsObject::put_BuildTiming(VARIANT_BOOL bTime)
{
	return g_pBuildPackage->m_pProjectEngine->put_BuildTiming(bTime);
}

STDMETHODIMP CVCBuildOptionsObject::get_CPPExtensions(BSTR *pbstrExt)
{
	CHECK_POINTER_VALID(pbstrExt);
	// REVIEW (CVCBuildOptionsObject::get_CPPExtensions): Multi platform broken!
	CStringW strRoot = CBuildPackage::s_bstrAltKey;
	strRoot += L"\\VC\\VC_OBJECTS_PLATFORM_INFO\\Win32\\ToolDefaultExtensionLists";
	return GetRegStringW(strRoot, L"VCCLCompilerTool", pbstrExt);
}

STDMETHODIMP CVCBuildOptionsObject::put_CPPExtensions(BSTR bstrExt)
{
	// REVIEW (CVCBuildOptionsObject::put_CPPExtensions): Multi platform broken!
	CStringW strRoot = CBuildPackage::s_bstrAltKey;
	strRoot += L"\\VC_OBJECTS_PLATFORM_INFO\\Win32\\ToolDefaultExtensionLists\\";
	WriteRegStringW( strRoot, L"VCCLCompilerTool", bstrExt );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\makefile.inc ===
!include $(VSROOT)\Src\VC\IDE\makefile.inc

$(URTTARGET)\Microsoft.VisualStudio.VCProject.dll: $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\ProjBld2.tlb
    echo Building and signing Microsoft.VisualStudio.VCProject.dll (com+ Metadata) from ProjBld2.tlb > con
    SET OLDPATHBACK=%%PATH%%
    set PATH=%%PATH%%;$(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY);$(URTTARGET)
    $(TLBIMP_CMD)  /nologo /strictref /PublicKey:$(COMMON_ROOT)\security\FinalPublicKey.snk  /Primary $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\projbld2.tlb /Out:$(URTTARGET)\Microsoft.VisualStudio.VCProject.dll
    $(REGASM_CMD) /regfile:$(O)\Microsoft.VisualStudio.VCProject.reg $(URTTARGET)\Microsoft.VisualStudio.VCProject.dll
    $(DEVTOOLS)\$(PROCESSOR_ARCHITECTURE)\radtools\perl.exe $(VSROOT)\public\tools\reg2vrg.pl < $(O)\Microsoft.VisualStudio.VCProject.reg > $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\Microsoft.VisualStudio.VCProject.vrg
    $(VSPUBLIC)\tools\vsrebase.bat $(URTTARGET)\Microsoft.VisualStudio.VCProject.dll
    SET PATH=%%OLDPATHBACK%%
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\localeinfo.h ===
#ifndef __LOCALE_INFO__
#define __LOCALE_INFO__
/*
*/
#include "uilocale.h"

class CLocaleInfo
{
public:
	CLocaleInfo();
	CLocaleInfo(HINSTANCE hInst, IServiceProvider *pServiceProvider);
	~CLocaleInfo();

	void SetMainInst(HINSTANCE hInst) {m_hInstMain = hInst;};

	HINSTANCE GetUIHostLib(); // returns NULL if can't find.

protected:

	HINSTANCE m_hInstMain;
	HINSTANCE m_hInst;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\outgroup.cpp ===
// OutGroup.cpp: implementation of the COutputGroup class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "vssolutn.h"
#include "OutGroup.h"
#include "gencfg.h"

#ifdef UNICODE
#undef _TCHAR
#define  _TCHAR char
#endif
#include <mrengine.h>
#include <utf.h>

LPCOLESTR s_SystemFiles[] =
{
	L"KERNEL32.DLL",
	L"GDI32.DLL",
	L"SHELL32.DLL",
	L"OLE32.DLL",
	L"USER32.DLL",
	L"ADVAPI32.DLL",
	L"WINMM.DLL",
	L"WINSPOOL.DRV",
	L"MSCOREE.DLL",
	L"IMAGEHLP.DLL",
	L"SHLWAPI.DLL",
	L"WS2_32.DLL",
	L"DBGHELP.DLL",
	L"USERENV.DLL",
	L"OLEAUT32.DLL",
	L"COMCTL32.DLL",
	NULL
};

HRESULT InitMRE();
HRESULT GetImportDependencies(BSTR bstrIdbFile, CVCStringWList *pList);
HRESULT GetLibDependencies( VCConfiguration *pConfig, BSTR bstrPrimaryOutput, CVCStringWList *pList );
BOOL MRECALL FEnumDepFileForDeployment(PMREUtil pmre, EnumFile& ef, EnumType et);
BOOL MRECALL FEnumSrcFileForDeployment(PMREUtil pMre, EnumFile& ef, EnumType et);

HRESULT COutputGroup::CreateInstance(IVsOutputGroup **ppOutGroup, IVsProjectCfg2* pParent, int groupType)
{
	CComObject<COutputGroup> *pOutGroup = NULL;
	HRESULT hr = CComObject<COutputGroup>::CreateInstance(&pOutGroup);
	if( SUCCEEDED(hr) )
	{
		hr = pOutGroup->QueryInterface(__uuidof(IVsOutputGroup),(void**)ppOutGroup);
		pOutGroup->Initialize(pParent, groupType);
	}
	return hr;
}


void COutputGroup::Initialize(IVsProjectCfg2* pParent, int groupType)
{
	m_pCfg = pParent;
	m_groupType = groupType;
}

STDMETHODIMP COutputGroup::get_CanonicalName(BSTR *pbstrCanonicalName)
{
	CHECK_POINTER_NULL(pbstrCanonicalName)

	CComBSTR bstrGroupName;
	switch( m_groupType )
	{
		case PRIMARY_OUTPUT:
			bstrGroupName = L"Built";
			break;
		case SECONDARY_OUTPUT:
			bstrGroupName = L"Symbols";
			break;
		case CONTENT_OUTPUT:
			bstrGroupName = L"ContentFiles";
			break;
		case SOURCE_OUTPUT:
			bstrGroupName = L"SourceFiles";
			break;
		default:
			return E_FAIL;
	}
	*pbstrCanonicalName = bstrGroupName.Detach();
	return S_OK;
}

STDMETHODIMP COutputGroup::get_DisplayName(BSTR *pbstrDisplayName)
{
	CHECK_POINTER_NULL(pbstrDisplayName)
	
	CComBSTR bstrGroupName;
	switch( m_groupType )
	{
		case PRIMARY_OUTPUT:
			bstrGroupName.LoadString(IDS_BUILTGROUP);
			break;
		case SECONDARY_OUTPUT:
			bstrGroupName.LoadString(IDS_DEBUGGROUP);
			break;
		case CONTENT_OUTPUT:
			bstrGroupName.LoadString(IDS_CONTENTGROUP);
			break;
		case SOURCE_OUTPUT:
			bstrGroupName.LoadString(IDS_SOURCEGROUP);
			break;
		default:
			return E_FAIL;
	}
	*pbstrDisplayName = bstrGroupName.Detach();
	return S_OK;
}

// MattGe 8/12/99:  New method
STDMETHODIMP COutputGroup::get_KeyOutput(BSTR *pbstrKeyOutput)
{
	CHECK_POINTER_NULL(pbstrKeyOutput);
	*pbstrKeyOutput = NULL;

	CComPtr<VCConfiguration> pConfig;
	HRESULT hr = GetVCConfiguration(&pConfig);
	RETURN_ON_FAIL_OR_NULL(hr, pConfig);

	CComBSTR bstrName;
	switch( m_groupType )
	{
		case PRIMARY_OUTPUT:
			hr = pConfig->get_PrimaryOutput(&bstrName);
			break;
		case SECONDARY_OUTPUT:
			break;
		case CONTENT_OUTPUT:
			break;
		case SOURCE_OUTPUT:
			break;
	}
	*pbstrKeyOutput = bstrName.Detach();
	return hr;
}


STDMETHODIMP COutputGroup::get_ProjectCfg(IVsProjectCfg2 **ppIVsProjectCfg2)
{
	CHECK_POINTER_NULL(ppIVsProjectCfg2);
	return m_pCfg.CopyTo(ppIVsProjectCfg2);
}

STDMETHODIMP COutputGroup::get_Outputs(ULONG celt,IVsOutput2* rgpcfg[], ULONG *pcActual)
{
	HRESULT hr = S_OK;
	CComPtr<VCConfiguration> pConfig;
	GetVCConfiguration(&pConfig);

	if( celt == 0 )
	{
		CHECK_POINTER_NULL(pcActual);
		switch( m_groupType )
		{
			case PRIMARY_OUTPUT:
			{
				CComQIPtr<IVCConfigurationImpl> spConfigImpl = pConfig;
				long cOutputs = 0;
				if (spConfigImpl)
					spConfigImpl->get_DeployableOutputsCount(&cOutputs);
				else
				{
					CComBSTR bstrPrimaryOutput;
					if (SUCCEEDED(pConfig->get_PrimaryOutput(&bstrPrimaryOutput)) && bstrPrimaryOutput && 
						bstrPrimaryOutput[0] != L'\0')
						cOutputs = 1;
				}
				*pcActual = cOutputs;
				break;
			}
			case SECONDARY_OUTPUT:
				*pcActual = 1;
				break;
			case CONTENT_OUTPUT:
			{
				CComPtr<IEnumVARIANT> pEnum;
				hr = GetVCFileEnumerator(&pEnum);
				RETURN_ON_FAIL_OR_NULL(hr, pEnum);

				unsigned long i = 0;
				while( true )
				{
					CComVariant var;
					hr = pEnum->Next( 1, &var, NULL );
					if( hr != S_OK )
						break;
					CComQIPtr<VCFile> pFile = var.punkVal;
					if (pFile == NULL)
						continue;

					VARIANT_BOOL bContent = VARIANT_FALSE;
					hr = pFile->get_DeploymentContent( &bContent );
					if( bContent == VARIANT_TRUE )
						i++;
				}
				*pcActual = i;
				break;
			}
			case SOURCE_OUTPUT:
			{
				CComPtr<IEnumVARIANT> pEnum;
				hr = GetVCFileEnumerator(&pEnum);
				RETURN_ON_FAIL_OR_NULL(hr, pEnum);

				// REVIEW(kperry) get_Count would be more efficient.
				unsigned long i = 1; // start at 1 to account for the project file.
				while( true )
				{
					CComVariant var;
					hr = pEnum->Next( 1, &var, NULL );
					if( hr != S_OK )
						break;
					i++;
				}
				*pcActual = i;
				break;
			}
		}
		return S_OK;
	}

	CHECK_POINTER_NULL(rgpcfg);

	// calculate the outputs here
	CComBSTR bstrName;
	CComBSTR bstrPrimaryOutput;
	switch( m_groupType )
	{
		case PRIMARY_OUTPUT:
		{
			RETURN_ON_NULL(pConfig);
			long idxActual = 0;
			CComQIPtr<IVCConfigurationImpl> spConfigImpl = pConfig;
			if (spConfigImpl)
			{
				CComPtr<IVCBuildStringCollection> spDeployableOutputs;
				spConfigImpl->get_DeployableOutputs(&spDeployableOutputs);
				if (spDeployableOutputs)
				{
					spDeployableOutputs->Reset();
					while (TRUE)
					{
						CComBSTR bstrOutput;
						HRESULT hrT = spDeployableOutputs->Next(&bstrOutput);
						if (hrT != S_OK)
							break;
						else if (bstrOutput == NULL)
							continue;

						CPathW path;
						path.Create(bstrOutput);
						CComBSTR bstrRelativePath = path.GetFileName();
						COutput2::CreateInstance(&rgpcfg[idxActual], m_pCfg, bstrOutput, bstrRelativePath);
						idxActual++;
					}
				}
			}
			if (idxActual == 0)
			{
				hr = pConfig->get_PrimaryOutput(&bstrPrimaryOutput);
				if (SUCCEEDED(hr) && bstrPrimaryOutput && bstrPrimaryOutput[0] != L'\0')
				{
					CPathW path;
					path.Create(bstrPrimaryOutput);
					CComBSTR bstrRelativePath = path.GetFileName();
					COutput2::CreateInstance(&rgpcfg[0], m_pCfg, bstrPrimaryOutput, bstrRelativePath);
					idxActual = 1;
				}
			}
			if( pcActual )
				*pcActual = idxActual;
			break;
		}
		case SECONDARY_OUTPUT:
		{
			CComBSTR bstrPDB;
			hr = pConfig->get_ProgramDatabase(&bstrPDB);
			if (hr == S_OK && bstrPDB && bstrPDB[0] != L'\0')
			{
				CPathW path;
				path.Create(bstrPDB);
				CComBSTR bstrRelativePath = path.GetFileName();

				COutput2::CreateInstance(&rgpcfg[0], m_pCfg, bstrPDB, bstrRelativePath);
				if( pcActual )
					*pcActual = 1;
			}
			else
			{
				if (pcActual)
					*pcActual = 0;
			}
			break;
		}
		case CONTENT_OUTPUT:
		case SOURCE_OUTPUT:
		{
			CComPtr<IEnumVARIANT> pEnum;
			hr = GetVCFileEnumerator(&pEnum);
			RETURN_ON_FAIL_OR_NULL(hr, pEnum);

			CComBSTR bstrDir;
			CComPtr<IDispatch> pDispProject;
			pConfig->get_Project( &pDispProject );
			CComQIPtr<VCProject> pProject = pDispProject;
			pProject->get_ProjectDirectory(&bstrDir);

			unsigned long i = 0;
			while( true )
			{
				CComVariant var;
				hr = pEnum->Next( 1, &var, NULL );
				if( hr != S_OK )
					break;
				CComQIPtr<VCFile> pFile = var.punkVal;
				if (pFile == NULL)
					continue;

				if( m_groupType  == CONTENT_OUTPUT )
				{
				    VARIANT_BOOL bContent = VARIANT_FALSE;
				    hr = pFile->get_DeploymentContent( &bContent );
				    if( bContent == VARIANT_FALSE )
					continue;
				}

				// create an output instance for this file
				CComBSTR bstrFilename;
				hr = pFile->get_FullPath( &bstrFilename );
				if (FAILED(hr) || bstrFilename == NULL)
					continue;

				CComBSTR bstrRelativePath;
				int rDirLen = bstrDir.Length();
				if (!_wcsnicmp(bstrDir, bstrFilename, rDirLen))
				{
					bstrRelativePath = &bstrFilename[rDirLen];
				}
				else
				{
					CPathW path;
					path.Create(bstrFilename);
					bstrRelativePath = path.GetFileName();
				}

				COutput2::CreateInstance(&rgpcfg[i], m_pCfg, bstrFilename, bstrRelativePath );
				i++;
			}

			if( m_groupType  == SOURCE_OUTPUT )
			{
				CComBSTR bstrFilename;
				pProject->get_ProjectFile( &bstrFilename );
				CPathW path;
				path.Create(bstrFilename);
				CComBSTR bstrRelativePath;
				bstrRelativePath = path.GetFileName();
				COutput2::CreateInstance(&rgpcfg[i], m_pCfg, bstrFilename, bstrRelativePath );
				i++;
			}
			
			if( pcActual )
				*pcActual = i;
			break;

		}
		default:
			return E_FAIL;
	}
	return S_OK;
}

BOOL COutputGroup::IsManaged(VCConfiguration* pConfig)
{
	ConfigurationTypes configType = typeUnknown;
	if (FAILED(pConfig->get_ConfigurationType(&configType)))
		return FALSE;
	else if (configType != typeApplication && configType != typeDynamicLibrary)
		return FALSE;

	CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
	RETURN_ON_NULL2(spPropContainer, FALSE);

	compileAsManagedOptions managedExt = managedNotSet;
	if (spPropContainer->GetIntProperty(VCCLID_CompileAsManaged, (long *)&managedExt) != S_OK)
		return FALSE;

	return (managedExt != managedNotSet);
}

HRESULT COutputGroup::GetVCProject(VCProject** ppProject)
{
	*ppProject = NULL;

	CComPtr<VCConfiguration> pConfig;
	HRESULT hr = GetVCConfiguration(&pConfig);
	RETURN_ON_NULL(pConfig);

	CComPtr<IDispatch> pDispProject;
	pConfig->get_Project( &pDispProject );
	CComQIPtr<VCProject> pProject = pDispProject;
	RETURN_ON_NULL(pProject);

	*ppProject = pProject.Detach();
	return S_OK;
}

HRESULT COutputGroup::GetVCFileEnumerator(IEnumVARIANT** ppEnum, VCProject* pProj /* = NULL */)
{
	*ppEnum = NULL;

	// Get a VCProject from an IVsCfg project
	CComPtr<VCProject> pProject;
	HRESULT hr = S_OK;
	
	if (pProj)
		pProject = pProj;
	else
	{
		GetVCProject(&pProject);
		RETURN_ON_FAIL_OR_NULL(hr, pProject);
	}

	// Get the file collection
	CComPtr<IDispatch> pDispColl;
	hr = pProject->get_Files( &pDispColl );
	CComQIPtr<IVCCollection> spColl = pDispColl;
	RETURN_ON_FAIL_OR_NULL(hr, spColl);

	CComPtr<IEnumVARIANT> pEnum;
	hr = spColl->_NewEnum(reinterpret_cast<IUnknown **>(&pEnum));
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);

	pEnum->Reset();
	*ppEnum = pEnum.Detach();
	return S_OK;
}

STDMETHODIMP COutputGroup::get_DeployDependencies(ULONG celt, IVsDeployDependency* rgpdpd[], ULONG *pcActual)
{
	if( pcActual )
		*pcActual = 0;

	if( celt > 0 )
	{
		CHECK_POINTER_NULL(rgpdpd);
		rgpdpd[0] = NULL;
	}

	if( m_groupType != PRIMARY_OUTPUT)
		return S_OK;


	CComBSTR bstrPrimaryOutput;
	CComPtr<VCConfiguration> pConfig;
	GetVCConfiguration(&pConfig);
	RETURN_ON_NULL(pConfig);
	HRESULT hr = pConfig->get_PrimaryOutput(&bstrPrimaryOutput);
	RETURN_ON_FAIL(hr);
	if (bstrPrimaryOutput == NULL || bstrPrimaryOutput[0] == L'\0')	// empty, so no deployment dependencies here...
		return S_OK;

	FILETIME newTime;
	WIN32_FIND_DATAW fd;
	HANDLE hFind = FindFirstFileW(bstrPrimaryOutput, &fd);
	::FindClose(hFind);
	newTime = fd.ftLastWriteTime;
   	if( (m_oldTime.dwHighDateTime != newTime.dwHighDateTime) || (m_oldTime.dwLowDateTime != newTime.dwLowDateTime) )
	{
		m_oldTime = newTime;

		// new to recalculate everything
	    m_strList.RemoveAll();
	    CComQIPtr<IVCConfigurationImpl> spConfigImpl = pConfig;
	    if (spConfigImpl)
	    {
			CComBSTR bstrIdbFile;
			spConfigImpl->get_MrePath(&bstrIdbFile);
			hr = m_IDB.GetImportDependencies( bstrIdbFile, &m_strList);
	    }
	    hr = m_IDB.GetLibDependencies(pConfig, bstrPrimaryOutput, &m_strList);
	}

	ULONG nCount = 0;
	if (celt > 0)
	{
	    // For each file in
		VCPOSITION pos = m_strList.GetHeadPosition();
		while( pos && ((ULONG)nCount < celt) )
		{
			CComBSTR bstrDep = m_strList.GetNext(pos);
			CDeployDependency::CreateInstance(&(rgpdpd[nCount]), bstrDep);
		    nCount++;
		}
	}
	else
	{
		nCount = (ULONG)m_strList.GetCount();
	}

	if( pcActual )
		*pcActual = nCount;

	return S_OK;
}

STDMETHODIMP COutputGroup::get_Description(BSTR *pbstrDescription)
{
	CComBSTR bstrDesc;

	switch( m_groupType )
	{
	case PRIMARY_OUTPUT:
		bstrDesc.LoadString( IDS_PRIMARY_OUTPUT );
		break;
	case SECONDARY_OUTPUT:
		bstrDesc.LoadString( IDS_SECONDARY_OUTPUT );
		break;
	case CONTENT_OUTPUT:
		bstrDesc.LoadString( IDS_CONTENT_OUTPUT );
		break;
	case SOURCE_OUTPUT:
		bstrDesc.LoadString( IDS_SOURCE_OUTPUT );
		break;
	default:
		RETURN_INVALID();
	}
	*pbstrDescription = bstrDesc.Detach();
	return S_OK;
}


HRESULT CDeployDependency::CreateInstance(IVsDeployDependency** ppDep, BSTR bstrURL)
{
	CComObject<CDeployDependency> *pDep = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CDeployDependency>::CreateInstance(&pDep);
	if (SUCCEEDED(hr))
	{
		pDep->QueryInterface(__uuidof(IVsDeployDependency), (void**)ppDep);
		pDep->Initialize(bstrURL);
	}

	return hr;
}


void CDeployDependency::Initialize(BSTR bstrURL)
{
	// this is a URL, so add the file:// to the front of it.
	m_depName += bstrURL;
}

STDMETHODIMP CDeployDependency::get_DeployDependencyURL(BSTR *pbstrURL)
{
	CHECK_POINTER_NULL(pbstrURL);
	return m_depName.CopyTo(pbstrURL);
}


// IVsOutput2 implementation

void COutput2::Initialize(IVsProjectCfg2* pCfg, BSTR bstrPath, BSTR bstrRelativePath )
{
	m_pCfg = pCfg;
	m_bstrFullPath = bstrPath;
	m_bstrRelativePath = bstrRelativePath;
}

HRESULT COutput2::CreateInstance(IVsOutput2 **ppOutput, IVsProjectCfg2* pCfg, BSTR bstrPath, BSTR bstrRelativePath)
{
	CComObject<COutput2> *pOutput = NULL;
	HRESULT hr = CComObject<COutput2>::CreateInstance(&pOutput);
	if (SUCCEEDED(hr))
	{
		pOutput->Initialize(pCfg, bstrPath, bstrRelativePath);
		hr = pOutput->QueryInterface( __uuidof(IVsOutput2), (void**)ppOutput );
	}
	return hr;
}

HRESULT COutput2::get_DisplayName(BSTR *pbstrDisplayName)
{
	CHECK_POINTER_NULL(pbstrDisplayName)

	// well, here we just send the file name
	return m_bstrRelativePath.CopyTo(pbstrDisplayName);
}

HRESULT COutput2::get_CanonicalName(BSTR *pbstrCanonicalName)
{
	CHECK_POINTER_NULL(pbstrCanonicalName)
	return m_bstrFullPath.CopyTo(pbstrCanonicalName);
}

// The DeploySourceURL is the web location of the item.  For items in the
// local filesystem, the URL should begin with the eight characters:
// "file:///".  Consumers of outputs may not be able to process URLs of
// other forms, so it's very important for projects that are generating URLs
// for local items to try to use this form of URL as much as possible.
HRESULT COutput2::get_DeploySourceURL(BSTR *pbstrDeploySourceURL)
{
	CHECK_POINTER_NULL(pbstrDeploySourceURL)

	CStringW out = L"file:///";
	out += m_bstrFullPath;
	*pbstrDeploySourceURL = SysAllocString((LPCOLESTR)out);
	return S_OK;
}

HRESULT COutput2::get_Type(GUID *pguidType)
{
	CHECK_POINTER_NULL(pguidType);
	return E_NOTIMPL;	// COutput2::get_Type
}

STDMETHODIMP COutput2::get_RootRelativeURL(BSTR *pbstrRelativePath)
{
	CHECK_POINTER_NULL(pbstrRelativePath)
	
	return m_bstrRelativePath.CopyTo(pbstrRelativePath);
}

HRESULT COutput2::GetVCConfiguration(VCConfiguration** ppConfig)
{
	CComQIPtr<IVCCfg> pCfg = m_pCfg;
	CHECK_ZOMBIE(pCfg, IDS_ERR_OUTPUT_ZOMBIE);
	CComPtr<IDispatch> spDispCfg;
	pCfg->get_Object(&spDispCfg);
	CComQIPtr<VCConfiguration> spConfig = spDispCfg;
	CHECK_ZOMBIE(spConfig, IDS_ERR_OUTPUT_ZOMBIE);

	*ppConfig = spConfig.Detach();
	return S_OK;
}

HRESULT COutputGroup::GetVCConfiguration(VCConfiguration** ppConfig)
{
	CComQIPtr<IVCCfg> pCfg = m_pCfg;
	CHECK_ZOMBIE(pCfg, IDS_ERR_OUTPUT_ZOMBIE);
	CComPtr<IDispatch> spDispCfg;
	pCfg->get_Object(&spDispCfg);
	CComQIPtr<VCConfiguration> spConfig = spDispCfg;
	CHECK_ZOMBIE(spConfig, IDS_ERR_OUTPUT_ZOMBIE);

	*ppConfig = spConfig.Detach();
	return S_OK;
}

STDMETHODIMP COutput2::get_Property(LPCOLESTR szProperty, VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);

	HRESULT hr = S_FALSE;
	CStringW strProp = szProperty;
	if (strProp == L"PrimaryOutput")
	{
		CComPtr<VCConfiguration> spConfig;
		hr = GetVCConfiguration(&spConfig);
		RETURN_ON_FAIL_OR_NULL(hr, spConfig);

		CComBSTR bstrName;
		hr = spConfig->get_PrimaryOutput(&bstrName);
		CComVariant var = bstrName;
		var.Detach(pvar);
		return hr;
	}
	else if (strProp == L"COM2REG")
	{

		CComPtr<VCConfiguration> spConfig;
		hr = GetVCConfiguration(&spConfig);
		RETURN_ON_FAIL_OR_NULL(hr, spConfig);

		VARIANT_BOOL bRegister = VARIANT_FALSE;
		hr = spConfig->get_RegisterOutput(&bRegister);
		if( hr == S_FALSE )
			hr = S_OK;
		CComVariant var = bRegister;
		var.Detach(pvar);
		return hr;
	}

	RETURN_INVALID();
}


CVCBuildOutputItems::~CVCBuildOutputItems()
{
	while (!m_outputs.IsEmpty())
	{
		IVsOutput* pOutput = (IVsOutput *)m_outputs.RemoveHead();
		if (pOutput)
			pOutput->Release();
	}
}

HRESULT CVCBuildOutputItems::CreateInstance(CVCBuildOutputItems** ppOutputs)
{
	CComObject<CVCBuildOutputItems> *pOutputsObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CVCBuildOutputItems>::CreateInstance(&pOutputsObj);
	if (SUCCEEDED(hr))
		((IVCBuildOutputItems *)pOutputsObj)->AddRef();
	*ppOutputs = pOutputsObj;
	return hr;
}

STDMETHODIMP CVCBuildOutputItems::get_Count(long* pcOutputs)
{
	CHECK_POINTER_NULL(pcOutputs)

	*pcOutputs = (long) m_outputs.GetCount();
	return S_OK;
}

STDMETHODIMP CVCBuildOutputItems::Next(IVCBuildOutputItem** ppItem)
{
	CHECK_POINTER_NULL(ppItem)
	*ppItem = NULL;
	
	RETURN_ON_NULL2(m_pos, S_FALSE);

	IVsOutput* pOutput = (IVsOutput* )m_outputs.GetNext(m_pos);
	CComQIPtr<IVCBuildOutputItem> spBldOutput = pOutput;
	*ppItem = spBldOutput.Detach();
	return S_OK;
}

void CVCBuildOutputItems::Add(IVsOutput* pOutput)
{
	if (pOutput == NULL)
		return;	// not adding NULL elements to the list...

	CComQIPtr<IVCBuildOutputItem> spBldOutput = pOutput;
	if (spBldOutput == NULL)	// dependency is not one of ours
	{
		CComPtr<IVsOutput> spItem;
		if (FAILED(COutputWrapper::CreateInstance(&spItem, pOutput)) || spItem == NULL)
		{
			VSASSERT(FALSE, "Out of memory");
			return;
		}
		m_outputs.AddTail(spItem.Detach());
	}
	else
	{
		pOutput->AddRef();
		m_outputs.AddTail(pOutput);
	}
}


static LPCOLESTR s_szMspdbDll = L"mspdb70.dll";;

typedef BOOL (MRECALL *FOpen_fnptr)(OUT PMREngine *ppmre, SZC szPdb, EC& ec, char szErr[], BOOL fReproSig, BOOL fWrite);
static FOpen_fnptr s_FOpen = NULL;

HINSTANCE	CIDBDeps::s_hInstPdbDll = NULL;
wchar_t		CIDBDeps::s_szComplusDir[MAX_PATH+1] = {0};
int			CIDBDeps::s_nComPlusLen = 0;

BOOL MRECALL FEnumSrcFileForDeployment(PMREUtil pMre, EnumFile& ef, EnumType et)
{
	pMre->EnumDepFiles(ef, FEnumDepFileForDeployment);
	return TRUE;
}

BOOL MRECALL FEnumDepFileForDeployment(PMREUtil pmre, EnumFile& ef, EnumType et)
{
	CVCStringWList *pList = (CVCStringWList *)ef.pvContext;
	if ((IncludeType)(ef.fiSrc.ftInclude) == itText)
		return TRUE;

	// Check for the slight possibility that ef.szFileSrc was not updated.
	if (NULL != ef.szFileSrc && ef.szFileSrc[0] != 0)
	{
		// Filter out system-provided stuff and write into list.
		CStringW str;
		PWSTR pStr = str.GetBuffer(_MAX_PATH);
		UTF8ToUnicode(ef.szFileSrc, NULL_TERMINATED_MODE, pStr, _MAX_PATH);
		str.ReleaseBuffer();
		if (str.IsEmpty())
			return TRUE;
//		if( !CIDBDeps::IsComPlus(str) )
		pList->AddTail(str);
	}
	return TRUE;
}


BOOL CIDBDeps::IsComPlus(LPCOLESTR strFile)
{
	if( strFile == NULL )
		return FALSE;

	if( CIDBDeps::s_nComPlusLen == 0 )
	{
		LONG lRet;
		DWORD nType = REG_SZ;
		DWORD nSize = MAX_PATH;
		HKEY hSectionKey = NULL;
		lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\.NETFramework", 0, KEY_READ, &hSectionKey );
		if( hSectionKey )
		{
			lRet = RegQueryValueExW( hSectionKey, L"InstallRoot", NULL, &nType, (LPBYTE)CIDBDeps::s_szComplusDir, &nSize );
			RegCloseKey( hSectionKey );
		}
		CIDBDeps::s_nComPlusLen = (int)wcslen(CIDBDeps::s_szComplusDir);
		if( CIDBDeps::s_nComPlusLen == 0 )
			CIDBDeps::s_nComPlusLen = -1;	// failed, don't bother again.
	}
	if( CIDBDeps::s_nComPlusLen > 0 )
	{
		if( !_wcsnicmp(strFile,CIDBDeps::s_szComplusDir, CIDBDeps::s_nComPlusLen) )
			return TRUE;
	}
	return FALSE;
}

HRESULT CIDBDeps::InitMRE()
{
	if (s_hInstPdbDll == NULL)
	{
		s_hInstPdbDll = LoadLibraryW(s_szMspdbDll);
		if (NULL == s_hInstPdbDll)
			return E_FAIL;
	}
#ifdef _WIN64
	s_FOpen = (FOpen_fnptr)GetProcAddress(s_hInstPdbDll,"?FOpen@MREngine@@SAHPEAPEAU1@PEBDAEAJQEADHH@Z");  // NOTE: There is no GetProcAddressW in Win32
#else
	s_FOpen = (FOpen_fnptr)GetProcAddress(s_hInstPdbDll,"?FOpen@MREngine@@SGHPAPAU1@PBDAAJQADHH@Z");  // NOTE: There is no GetProcAddressW in Win32
#endif
	if (NULL == s_FOpen)
	{
		BOOL bOK = FreeLibrary(s_hInstPdbDll);
		s_hInstPdbDll = NULL;
		return E_FAIL;
	}
	return S_OK;
}

HRESULT CIDBDeps::GetImportDependencies(BSTR bstrIdbFile, CVCStringWList *pList)
{
	HRESULT hr = S_OK;
	if( pList == NULL )
			return E_FAIL;

	if( !s_FOpen )
	{
		hr = InitMRE();
		if( !SUCCEEDED(hr) )
			return hr;
	}

	PMREngine pMre;
	EC ec;
	CStringA strIdbFileA = bstrIdbFile;	// yes, ANSI -- 'cause CBldMreDependencies needs it this way

	if( _access(strIdbFileA, 0) == -1 )
		return E_FAIL;
	if( !(*s_FOpen)(&pMre, strIdbFileA, ec, NULL, FALSE, FALSE) ) 
		return E_FAIL;
	if( pMre == NULL )
		return E_FAIL;

	PMREUtil pMreUtil;
	pMre->QueryMreUtil(pMreUtil);
	if( pMreUtil )
	{
		pMreUtil->EnumSrcFiles(FEnumSrcFileForDeployment, NULL, (void*)pList);
		pMreUtil->FRelease();
	}
	pMre->FClose(FALSE);

	return S_OK;
}


HRESULT CIDBDeps::GetLibDependencies( VCConfiguration *pConfig, BSTR bstrPrimaryOutput, CVCStringWList *pList )
{
	LPVOID					lpvFile;
	PIMAGE_FILE_HEADER		pIFH;
	PIMAGE_OPTIONAL_HEADER	pIOH;
	PIMAGE_SECTION_HEADER	pISH;
	CString					strPath;

	{
	    CHandle hMap;
	    {
			// Open the file for read.
			CHandle hFile;
			hFile.Attach( CreateFileW(bstrPrimaryOutput, GENERIC_READ, FILE_SHARE_READ, 
								NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) );
						
			// Exit now if the file failed to open.
			if (hFile == INVALID_HANDLE_VALUE) 
				return S_OK;
			  
			// Create a file mapping object for the open module.
			hMap.Attach( CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL) );
	    }
	    
	    // Exit now if the file failed to map.
		RETURN_ON_NULL2(hMap, S_OK);
	    
	    // Create a file mapping view for the open module.
	    lpvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
	}

	PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER)lpvFile;

	// Check for the DOS signature ("MZ").
	if (pIDH->e_magic != IMAGE_DOS_SIGNATURE) {
		UnmapViewOfFile(lpvFile);
		return S_OK;
	}

	// Map an IMAGE_NT_HEADERS structure onto our module file mapping.
	PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((DWORD_PTR)lpvFile + pIDH->e_lfanew);

	// Check for NT/PE signature ("PE\0\0").
	if (pINTH->Signature != IMAGE_NT_SIGNATURE) {
		UnmapViewOfFile(lpvFile);
		return S_OK;
	}

	// Map our IMAGE_FILE_HEADER structure onto our module file mapping.
	pIFH = &pINTH->FileHeader;

	// Map our IMAGE_OPTIONAL_HEADER structure onto our module file mapping.
	pIOH = &pINTH->OptionalHeader;
	// If this module has no imports (like NTDLL.DLL), then just return success.
	if (pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size == 0) {
		UnmapViewOfFile(lpvFile);
		return S_OK;
	}

	// Map our IMAGE_SECTION_HEADER structure array onto our module file mapping
	pISH = IMAGE_FIRST_SECTION(pINTH);

	// Locate our Import Image Directory's relative virtual address
	DWORD VAImageDir = pIOH->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

	// Locate the section that contains this Image Directory. We do this by
	// walking through all of our sections until we find the one that specifies
	// an address range that our Image Directory fits in.
	PIMAGE_SECTION_HEADER pISHFound = NULL;
	int i;
	for (i = 0; i < pIFH->NumberOfSections; i++) {
		if ((VAImageDir >= pISH[i].VirtualAddress) &&
			 (VAImageDir < (pISH[i].VirtualAddress + pISH[i].SizeOfRawData)))
		{
			pISHFound = &pISH[i];
			break;
		}
	}

	// Bail out if we could not find a section that owns our Image Directory.
	if (pISHFound == NULL) {
		UnmapViewOfFile(lpvFile);
		return S_OK;
	}

	// Now lets setup the search path for DLLs
	// According to spec this is ...
	
	// Exe dir,
	// WorkingDir
	// Window\\system32
	// Windows
	// Rest of Path

	CStringW strFullPath;
	// The directory that the output file itself is in
	CDirW dirOutput;
	if (dirOutput.CreateFromPath(bstrPrimaryOutput))
	{
		strFullPath = (const wchar_t *)dirOutput;
		strFullPath += L";";
	}

	// now append the working directory for the debugger, if any
	CComPtr<IDispatch> spDispDebugSettings;
	if (SUCCEEDED(pConfig->get_DebugSettings(&spDispDebugSettings)))
	{
		CComQIPtr<VCDebugSettings> spDebugSettings = spDispDebugSettings;
		if (spDebugSettings)
		{
			CComBSTR bstrPath2;
			if (SUCCEEDED(spDebugSettings->get_WorkingDirectory(&bstrPath2)))
			{
				if (bstrPath2.Length() )
				{
					strFullPath += bstrPath2;
					strFullPath += L";";
				}
			}
		}
	}

	// now append the Windows System Directory
	CStringW strSys;
	::GetSystemDirectoryW(strSys.GetBuffer(MAX_PATH+1),MAX_PATH);
	strSys.ReleaseBuffer();
	strFullPath += strSys;
	strFullPath += L";";

	// now append the Windows Directory
	CStringA strWin;
	// Review - Note this funtion is not wrapped in Win9x Lib.
	::GetWindowsDirectoryA(strWin.GetBuffer(MAX_PATH+1),MAX_PATH);
	strWin.ReleaseBuffer();
	strFullPath += strWin;
	strFullPath += L";";

	// calculate path using this configs path variable
	CComPtr< IDispatch > spDispPlatform;
	if ( pConfig->get_Platform(&spDispPlatform)==S_OK)
	{
		CComQIPtr<VCPlatform> spPlatform = spDispPlatform;
		if (spPlatform)
		{
			CComBSTR bstrExePath1, bstrExePath2;
			spPlatform->get_ExecutableDirectories(&bstrExePath1);
			spPlatform->Evaluate(bstrExePath1, &bstrExePath2);
			strFullPath += bstrExePath2;
			strFullPath += L";";
		}
	}

	// Compute our base that everything else is an offset from. We do this by
	// taking our base file pointer and adding our section's PointerToRawData,
	// which is an absolute offset value into our file.  We then subtract off our
	// Virtual Address since the offsets we are going to be adding later will be
	// relative to the this Virtual Address
	DWORD_PTR dwBase = (DWORD_PTR)lpvFile + pISHFound->PointerToRawData - pISHFound->VirtualAddress;

	// To locate the beginning of our Image Import Descriptor array, we add our
	// Image Directory offset to our base.
	PIMAGE_IMPORT_DESCRIPTOR pIID = (PIMAGE_IMPORT_DESCRIPTOR)(dwBase + VAImageDir);

	// Loop through all the Image Import Descriptors in the array.
	while (pIID->OriginalFirstThunk || pIID->FirstThunk)
	{
		CComBSTR bstrName =(LPCSTR)(dwBase + pIID->Name);
		int j = 0;
		while( s_SystemFiles[j] && _wcsicmp( bstrName, s_SystemFiles[j] ) )
		{
			j++;
		}
		if( s_SystemFiles[j] == NULL )
		{ 
			wchar_t *szEnd = NULL;
			CStringW strBuf;
			DWORD dwOK = SearchPathW(strFullPath, bstrName, NULL, 4095, strBuf.GetBuffer(4096), &szEnd);
			strBuf.ReleaseBuffer();
			if( dwOK )
				pList->AddTail(strBuf);
		}
		pIID++;
	}
	UnmapViewOfFile(lpvFile);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\optionsdlg.h ===
// BuildOptions.h : Declaration of the CBuildOptions

#ifndef __BUILDOPTIONS_H_
#define __BUILDOPTIONS_H_

#include "rsrc.h"       // main symbols
#undef WM_OCC_LOADFROMSTREAM
#undef WM_OCC_LOADFROMSTORAGE         
#undef WM_OCC_INITNEW                 
#undef WM_OCC_LOADFROMSTREAM_EX       
#undef WM_OCC_LOADFROMSTORAGE_EX      

#include <atlhost.h>
#include "bldpkg.h"
#include "profile.h"

/////////////////////////////////////////////////////////////////////////////
// CVCBuildOptionsPage
class ATL_NO_VTABLE CVCBuildOptionsPage :
	public IDispatchImpl<IVCBuildOptionsPage, &IID_IVCBuildOptionsPage, &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public IVsPerPropertyBrowsing,
	public IPerPropertyBrowsing,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCBuildOptionsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildOptionsPage)
END_COM_MAP()

	static HRESULT CreateInstance( IVCBuildOptionsPage **ppI )
	{
		HRESULT hr;
		CComObject<CVCBuildOptionsPage> *pObj;
		hr = CComObject<CVCBuildOptionsPage>::CreateInstance(&pObj);
		if (SUCCEEDED(hr))
		{
			pObj->QueryInterface(__uuidof(IVCBuildOptionsPage), (void**)ppI);
		}

		VARIANT_BOOL buildLogging;
		VARIANT_BOOL buildTiming;
		CComBSTR bstrExt;

		g_pBuildPackage->m_pProjectEngine->get_BuildLogging(&buildLogging);
		g_pBuildPackage->m_pProjectEngine->get_BuildTiming(&buildTiming);
		
		CStringW strRoot = CBuildPackage::s_bstrAltKey;
		strRoot += L"\\VC\\VC_OBJECTS_PLATFORM_INFO\\Win32\\ToolDefaultExtensionLists";
		hr = GetRegStringW(strRoot, L"VCCLCompilerTool", &bstrExt);

		(*ppI)->put_BuildTiming(buildTiming);
		(*ppI)->put_BuildLogging(buildLogging);
		(*ppI)->put_CPPExtensions(bstrExt);

		return hr;
	}
	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCBuildOptionsPage, &IID_IVCBuildOptionsPage, &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCBuildOptionsPage
public:
	STDMETHOD(get_BuildLogging)(VARIANT_BOOL *pbLog);
	STDMETHOD(put_BuildLogging)(VARIANT_BOOL bLog);
	STDMETHOD(get_BuildTiming)(VARIANT_BOOL *pbTime);
	STDMETHOD(put_BuildTiming)(VARIANT_BOOL bTime);
	STDMETHOD(get_CPPExtensions)(BSTR *pbstrExt);
	STDMETHOD(put_CPPExtensions)(BSTR bstrExt);

// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide)
	{
		CHECK_POINTER_NULL(pfHide);
		*pfHide = FALSE;
		return E_NOTIMPL;
	};

	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay)
	{
		CHECK_POINTER_NULL(pfDisplay);
		*pfDisplay = FALSE;
		return S_OK;
	}

	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
	{

		CComQIPtr<IDispatch> pdisp = static_cast<IDispatch*>(this);
		RETURN_ON_NULL(pdisp);

		CComPtr<ITypeInfo> pTypeInfo;
		HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
		CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
		RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);

		CComBSTR bstrDoc;
		hr = pTypeInfo2->GetDocumentation2(dispid, localeID, &bstrDoc, NULL, NULL);
		RETURN_ON_FAIL_OR_NULL(hr, bstrDoc.m_str);
		
		LPOLESTR pDesc = wcsstr( bstrDoc, L": " );
		RETURN_ON_NULL(pDesc);

		int nSize = (int)(pDesc - bstrDoc);
		pDesc+=2;

		CComBSTR bstrName( nSize-1, bstrDoc );
		if (pbstrName != NULL)
			*pbstrName = bstrName.Detach();

		CComBSTR bstrDesc( pDesc );
		if (pbstrDesc != NULL)
			*pbstrDesc = bstrDesc.Detach();
		
		return S_OK;
	}

	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault)
	{
		*pfDefault = TRUE;
		return S_OK;
	}
	
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly)
	{
		CHECK_POINTER_NULL(fReadOnly);
		*fReadOnly = FALSE;
		return S_OK;
	}

	STDMETHOD(GetClassName)(BSTR* ) {return E_NOTIMPL;}	
    STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
    STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}


public:
	// IPerPropertyBrowsing methods
	STDMETHOD(MapPropertyToPage)( DISPID dispID, CLSID *pClsid )
		{ return E_NOTIMPL; }
	
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr )
	{
		CHECK_POINTER_NULL(pBstr)
		*pBstr = NULL;
				
		HRESULT hr;

		CComQIPtr<IDispatch> pdisp = static_cast<IDispatch*>(this);
		
		// what type is this?
		CComVariant var;
		hr = CComDispatchDriver::GetProperty( pdisp, dispID, &var );
		RETURN_ON_FAIL2(hr, S_FALSE);

		switch( var.vt )
		{
			case VT_BSTR:
			{
				// if it was a bstr, return it and let the default behavior happen
				CComBSTR bstrTemp = var.bstrVal;
				*pBstr = bstrTemp.Detach();
 				return S_FALSE;
			}
			case VT_BOOL:
			{
				if( var.boolVal == VARIANT_TRUE )
				{
					CComBSTR bstrTrue;
					bstrTrue.LoadString(VCTDENUM_Yes);
					*pBstr = bstrTrue.Detach();
				}
				else 
				{
					CComBSTR bstrFalse;
					bstrFalse.LoadString(VCTDENUM_No);
					*pBstr = bstrFalse.Detach();
				}
				return S_OK;
			}
			default:
			{
				// unhandled type, do default
				return S_FALSE;
			}
		}
	}
	
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut )
	{
		CHECK_POINTER_NULL(pCaStringsOut)
		CHECK_POINTER_NULL(pCaCookiesOut)
		
		HRESULT hr;

		CComQIPtr<IDispatch> pdisp = static_cast<IDispatch*>(this);
		
		// what type is this?
		CComVariant var;
		hr = CComDispatchDriver::GetProperty( pdisp, dispID, &var );
		RETURN_ON_FAIL2(hr, S_FALSE);

		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;

		switch( var.vt )
		{
			case VT_BOOL:
			{
				CComBSTR bstrTrue;
				bstrTrue.LoadString(VCTDENUM_Yes);
				CComBSTR bstrFalse;
				bstrFalse.LoadString(VCTDENUM_No);
				int nElems = 2;

				pCaCookiesOut->cElems = nElems;
				pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc( nElems * sizeof(DWORD) );
				pCaCookiesOut->pElems[0] = 0;
				pCaCookiesOut->pElems[1] = 1;
				
				pCaStringsOut->cElems = nElems;
				pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( nElems * sizeof(LPOLESTR) );
				pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrFalse ) + 1) * sizeof(OLECHAR) );
				wcscpy( pCaStringsOut->pElems[0], bstrFalse );
				pCaStringsOut->pElems[1] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrTrue ) + 1) * sizeof(OLECHAR) );
				wcscpy( pCaStringsOut->pElems[1], bstrTrue );

				return S_OK;
			}
			default:
			{
				// unhandled type, do default
				return S_FALSE;
			}
		}
		return E_FAIL;
	}

	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut )
	{
		CHECK_POINTER_NULL(pVarOut)
		
		HRESULT hr;
		CComQIPtr<IDispatch> pdisp = static_cast<IDispatch*>(this);
		
		// what type is this?
		CComVariant var;
		hr = CComDispatchDriver::GetProperty( pdisp, dispID, &var );
		RETURN_ON_FAIL2(hr, S_FALSE);
		
		CComVariant varOut;
		
		switch( var.vt )
		{
		// boolean
		case VT_BOOL:
		{
			if( dwCookie == 0 )
			{
				// varOut.boolVal = VARIANT_FALSE;
				CComBSTR bstrFalse(L"False");
				varOut = bstrFalse;
			}
			else if( dwCookie == 1 )
			{
				CComBSTR bstrTrue(L"True");
				varOut = bstrTrue;
				// varOut.boolVal = VARIANT_TRUE;
				// varOut = L"True";
			}
			break;
		}
		default:
			// unhandled type, do default
			return S_FALSE;
		}
		varOut.Detach(pVarOut);
		return S_OK;
	}

	VARIANT_BOOL m_buildLogging;
	VARIANT_BOOL m_buildTiming;
	CComBSTR m_bstrExt;
};

/////////////////////////////////////////////////////////////////////////////
// CBuildOptions
class CBuildOptions : 
	public CAxDialogImpl<CBuildOptions>
{
public:
	CBuildOptions()
	{
		CVCBuildOptionsPage::CreateInstance( &m_spOptions );
	}

	~CBuildOptions()
	{
	}

	enum { IDD = IDDP_OPTIONS_BUILD };

BEGIN_MSG_MAP(CBuildOptions)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroyDialog)
  	NOTIFY_CODE_HANDLER(PSN_APPLY,OnApply)	
  	NOTIFY_CODE_HANDLER(PSN_HELP,OnHelp)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
	LRESULT OnHelp(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

protected:
	CComPtr<IVSMDPropertyGrid> m_pGrid;
	CComQIPtr<IVCBuildOptionsPage> m_spOptions;
};


/////////////////////////////////////////////////////////////////////////////
// CVCBuildOptionsObject - use this for automation, but otherwise matches CVCBuildOptionsPage class above
class ATL_NO_VTABLE CVCBuildOptionsObject :
	public IDispatchImpl<IVCBuildOptionsPage, &IID_IVCBuildOptionsPage, &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCBuildOptionsObject)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildOptionsPage)
END_COM_MAP()
        static HRESULT CreateInstance( IDispatch **ppDisp )
        {
                HRESULT hr;
                CComObject<CVCBuildOptionsObject> *pObj;
                hr = CComObject<CVCBuildOptionsObject>::CreateInstance(&pObj);
                if (SUCCEEDED(hr))
                {
                        pObj->QueryInterface(__uuidof(IDispatch), (void**)ppDisp);
                }
                return hr;
        }

// IVCBuildOptionsPage
public:
	STDMETHOD(get_BuildLogging)(VARIANT_BOOL *pbLog);
	STDMETHOD(put_BuildLogging)(VARIANT_BOOL bLog);
	STDMETHOD(get_BuildTiming)(VARIANT_BOOL *pbTime);
	STDMETHOD(put_BuildTiming)(VARIANT_BOOL bTime);
	STDMETHOD(get_CPPExtensions)(BSTR *pbstrExt);
	STDMETHOD(put_CPPExtensions)(BSTR bstrExt);
};

#endif //__BUILDOPTIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\outgroup.h ===
// OutGroup.h: interface for the COutputGroup class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <path2.h>
class CGenCfg;
class COutput2 : 
	public IVsOutput2,
	public IVCBuildOutputItem,
	public CComObjectRoot
{
public:
	COutput2(){}
	~COutput2(){}

	void Initialize(IVsProjectCfg2* pCfg, BSTR bstrPath, BSTR bstrRelativePath);
	static HRESULT CreateInstance(IVsOutput2 **ppOutput, IVsProjectCfg2* pCfg, BSTR bstrPath, BSTR bstrRelativePath);

BEGIN_COM_MAP(COutput2)
	COM_INTERFACE_ENTRY(IVsOutput)
	COM_INTERFACE_ENTRY(IVsOutput2)
	COM_INTERFACE_ENTRY(IVCBuildOutputItem)
END_COM_MAP()

public:
	// IVsOutput
    STDMETHOD(get_DisplayName)( /* [out] */ BSTR *pbstrDisplayName);
    STDMETHOD(get_CanonicalName)( /* [out] */ BSTR *pbstrCanonicalName);
    STDMETHOD(get_DeploySourceURL)( /* [out] */ BSTR *pbstrDeploySourceURL);
    STDMETHOD(get_Type)( /* [out] */ GUID *pguidType);
	// IVSOutput2
    STDMETHOD(get_RootRelativeURL)( /* [out] */ BSTR *pbstrRelativePath); 
    STDMETHOD(get_Property)( /* [in] */ LPCOLESTR szProperty, VARIANT *pvar);

public:
	// IVCBuildOutputItem
	STDMETHOD(get_FullPathName)(BSTR* pbstrFullPathName) 
		{ return get_CanonicalName(pbstrFullPathName); }

protected:	// helpers
	HRESULT GetVCConfiguration(VCConfiguration** ppConfig);

// Member variables
protected:
	CComBSTR	m_bstrFullPath;
	CComBSTR	m_bstrRelativePath;
	CComPtr<IVsCfg> m_pCfg;
};


class CIDBDeps
{
public:
	static BOOL IsComPlus(LPCOLESTR strFile);
	HRESULT InitMRE();
	HRESULT GetImportDependencies(BSTR bstrIdbFile, CVCStringWList *pList);
	HRESULT GetLibDependencies( VCConfiguration *pConfig, BSTR bstrPrimaryOutput, CVCStringWList *pList );

private:
	static HINSTANCE s_hInstPdbDll;
	static wchar_t s_szComplusDir[MAX_PATH+1];
	static int s_nComPlusLen;
};

class COutputGroup : 
	public IVsOutputGroup,
	public CComObjectRoot
{
public:
	COutputGroup() {m_oldTime.dwLowDateTime = 0;m_oldTime.dwHighDateTime = 0;}
	~COutputGroup() {}
	static HRESULT CreateInstance(IVsOutputGroup **ppOutGroup, IVsProjectCfg2* pParent, int groupType);
	void Initialize(IVsProjectCfg2* pParent, int groupType);

BEGIN_COM_MAP(COutputGroup)
	COM_INTERFACE_ENTRY(IVsOutputGroup)
END_COM_MAP()

public:
	// IVsOutputGroup
//    STDMETHOD(get_CfgType)( REFIID iidCfg, void **ppCfg)
//		{ return E_NOTIMPL; /* COutputGroup::get_CfgType */ }
	STDMETHOD(get_CanonicalName)( BSTR *pbstrCanonicalName);
	STDMETHOD(get_DisplayName)( BSTR *pbstrDisplayName);
	STDMETHOD(get_KeyOutput)( BSTR *pbstrKeyOutput);
    STDMETHOD(get_ProjectCfg)( IVsProjectCfg2 **ppIVsProjectCfg2);
    STDMETHOD(get_Outputs)( ULONG celt, IVsOutput2 * rgpcfg[], ULONG *pcActual);
    STDMETHOD(get_DeployDependencies)( ULONG celt,IVsDeployDependency * rgpdpd[], ULONG *pcActual);
	STDMETHOD(get_Description)(BSTR *pbstrDescription);

// helper functions
	HRESULT GetVCConfiguration(VCConfiguration** ppConfig);
	HRESULT GetVCFileEnumerator(IEnumVARIANT** ppEnum, VCProject* pProj = NULL);
	HRESULT GetVCProject(VCProject** ppProject);
	BOOL IsManaged(VCConfiguration* pConfig);

// member variables
protected:
	int 					m_groupType;
	CComPtr<IVsProjectCfg2> m_pCfg;
	CVCStringWList 			m_strList;
	FILETIME			m_oldTime;
	CIDBDeps			m_IDB;
};

class CDeployDependency : 
	public IVsDeployDependency,
	public CComObjectRoot
{
public:
	CDeployDependency() : m_depName("") { }
	void Initialize(BSTR bstrURL);
	static HRESULT CreateInstance( IVsDeployDependency **ppDep, BSTR bstrURL);

BEGIN_COM_MAP(CDeployDependency)
	COM_INTERFACE_ENTRY(IVsDeployDependency)
END_COM_MAP()


// IVsDeployDependency
public:
    STDMETHOD(get_DeployDependencyURL)( BSTR *pbstrURL );

// Member variables
protected:
	CComBSTR m_depName;

};

class CVCBuildOutputItems :
	public IVCBuildOutputItems, 
	public CComObjectRoot
{
public:
	static HRESULT CreateInstance(CVCBuildOutputItems** ppItems);
	CVCBuildOutputItems() : m_pos(NULL) {}
	~CVCBuildOutputItems();

BEGIN_COM_MAP(CVCBuildOutputItems)
	COM_INTERFACE_ENTRY(IVCBuildOutputItems)
END_COM_MAP()

// IVCBuildOutputItems
public:
	STDMETHOD(get_Count)(long* pcOutputs);
	STDMETHOD(Reset)() 
	{ 
		m_pos = m_outputs.GetHeadPosition();
		return S_OK;
	}
	STDMETHOD(Next)(IVCBuildOutputItem** ppOutput);

public:
	void Add(IVsOutput* pItem);

protected:
	CVCPtrList m_outputs;
	VCPOSITION m_pos;
};

class COutputWrapper : 
	public IVsOutput,
	public IVCBuildOutputItem, 
	public CComObjectRoot
{
public:
	COutputWrapper() {}
	~COutputWrapper() {}
	static HRESULT CreateInstance(IVsOutput **ppOutputWrapper, IVsOutput* pOutput)
	{
		CHECK_POINTER_NULL(ppOutputWrapper);
		*ppOutputWrapper = NULL;
		CComObject<COutputWrapper> *pOutputWrapperObj = NULL;  // created with 0 ref count
		HRESULT hr = CComObject<COutputWrapper>::CreateInstance(&pOutputWrapperObj);
		RETURN_ON_FAIL_OR_NULL(hr, pOutputWrapperObj);
		IVsOutput* pOutputVar = pOutputWrapperObj;
		pOutputVar->AddRef();
		pOutputWrapperObj->Initialize(pOutput);
		*ppOutputWrapper = pOutputVar;
		return hr;
	}

BEGIN_COM_MAP(COutputWrapper)
	COM_INTERFACE_ENTRY(IVsOutput)
	COM_INTERFACE_ENTRY(IVCBuildOutputItem)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CDeployDependency) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

protected:
	void Initialize(IVsOutput* pOutput) { m_spOutput = pOutput; }

public:
	// IVsOutput
    STDMETHOD(get_DisplayName)(BSTR *pbstrDisplayName) 
	{
		CHECK_ZOMBIE(m_spOutput, IDS_ERR_OUTPUT_ZOMBIE);
		return m_spOutput->get_DisplayName(pbstrDisplayName);
	}
    STDMETHOD(get_CanonicalName)(BSTR *pbstrCanonicalName)
	{
		CHECK_ZOMBIE(m_spOutput, IDS_ERR_OUTPUT_ZOMBIE);
		return m_spOutput->get_CanonicalName(pbstrCanonicalName);
	}
    STDMETHOD(get_DeploySourceURL)(BSTR *pbstrDeploySourceURL)
	{
		CHECK_ZOMBIE(m_spOutput, IDS_ERR_OUTPUT_ZOMBIE);
		return m_spOutput->get_DeploySourceURL(pbstrDeploySourceURL);
	}
    STDMETHOD(get_Type)(GUID *pguidType)
	{
		CHECK_ZOMBIE(m_spOutput, IDS_ERR_OUTPUT_ZOMBIE);
		return m_spOutput->get_Type(pguidType);
	}

// IVCBuildOutputItem
public:
	STDMETHOD(get_FullPathName)(BSTR* pbstrFullPathName) 
		{ return get_CanonicalName(pbstrFullPathName); }

// Member variables
protected:
	CComPtr<IVsOutput> m_spOutput;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\outsenum.h ===
// OutsEnum.h: Definition of the COutsEnum class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "rsrc.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COutsEnum
class CVCArchy;
class CGenCfg;

class COutsEnum : 
	public IVsEnumOutputs, 
	public ISupportErrorInfo,
	public CComObjectRoot
	//,public CComCoClass<COutsEnum,&CLSID_OutsEnum>
{
public:
	COutsEnum() { m_pConfig = NULL; m_iOut = 0; }
	~COutsEnum() {}
	void Initialize(VCConfiguration* pConfig, CVCPtrList *pList);
	static HRESULT CreateInstance(IVsEnumOutputs **ppOutsEnum, VCConfiguration* pConfig, CVCPtrList *pList);

BEGIN_COM_MAP(COutsEnum)
	COM_INTERFACE_ENTRY(IVsEnumOutputs)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(COutsEnum) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IVsEnumOutputs
public:
	STDMETHOD(Reset)();
	STDMETHOD(Next)(/*[in]*/ ULONG cElements, /*[in, out, size_is(cElements)]*/ IVsOutput *rgpIVsOutput[], /*[out]*/ ULONG *pcElementsFetched);
	STDMETHOD(Skip)(/*[in]*/ ULONG cElements);
	STDMETHOD(Clone)(/*[out]*/ IVsEnumOutputs **ppIVsEnumOutputs);

protected:
	CVCPtrList m_ListOuts;
	VCConfiguration* m_pConfig;
	UINT m_iOut;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\output.h ===
#pragma once

#include "filechng.h"	// for CTestableSection

/////////////////////////////////////////////////////////////////////////////
// CVCBuildOutput 
const int MAXTHREADS = 3;

class CVCBuildOutput : 
	public IVCBuildOutput,
	public CComObjectRoot
{
// Construction
public:
	CVCBuildOutput();   // standard constructor
	~CVCBuildOutput();
	static HRESULT CreateInstance(IVCBuildOutput** ppOutput, IUnknown* pUnkWindowPane);
BEGIN_COM_MAP(CVCBuildOutput)
	COM_INTERFACE_ENTRY(IVCBuildOutput)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCBuildOutput) 

protected:
	HRESULT InitInstance(IUnknown* pUnkWindowPane);

// IVCBuildOutput
public:
	STDMETHOD(FlushToTaskList)(); // TODO: DRA add thread id to all other calls if we need to use these again
	STDMETHOD(AddString)(BSTR str, BOOL bAddCRLF);
	STDMETHOD(EnsureVisible)();
	STDMETHOD(Clear)();
	STDMETHOD(Activate)();
	STDMETHOD(Create)();
	STDMETHOD(Close)();
	STDMETHOD(CloseWithCount)(int *pCount);
	STDMETHOD(CloseAll)();
	STDMETHOD(get_OutputWindowPane)(IUnknown** pOutWindowPane);
	STDMETHOD(OutputTaskItemString)(LPCOLESTR pszOutputString, LONG /*VSTASKPRIORITY*/ nPriority, 
		LONG /*VSTASKCATEGORY*/ nCategory, LPCOLESTR pszSubcategory, LONG /*VSTASKBITMAP*/ nBitmap, 
		LPCOLESTR pszFilename, ULONG nLineNum, LPCOLESTR pszTaskItemText);
	STDMETHOD(SameWindowPane)(IUnknown* pUnkPane);

	static CTestableSection s_sectionOutWindowPane;

// Implementation
protected:
	IVsOutputWindowPane* GetOutWindowPane();
	IStream *m_pStreamOutPane;
	CComPtr<IUnknown> m_spUnkWindowPane;
	CVCMap< int, int, IVsOutputWindowPane *, IVsOutputWindowPane *> m_rgpVsOutputWindowPane;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\outsenum.cpp ===
// OutsEnum.cpp : Implementation of CDevbldApp and DLL registration.

#include "stdafx.h"
#include <vssolutn.h>
#include <BldMarshal.h>
#include "OutsEnum.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP COutsEnum::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IVsEnumOutputs,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT COutsEnum::CreateInstance(IVsEnumOutputs** ppOutsEnum, VCConfiguration* pConfig, CVCPtrList *pList)
{
	CComObject<COutsEnum> *pOutsEnumObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<COutsEnum>::CreateInstance(&pOutsEnumObj);
	if (SUCCEEDED(hr))
	{
		((IVsEnumOutputs *)pOutsEnumObj)->AddRef();
		pOutsEnumObj->Initialize(pConfig, pList);
	}
	*ppOutsEnum = (IVsEnumOutputs *)pOutsEnumObj;
	return hr;

}


void COutsEnum::Initialize(VCConfiguration* pConfig, CVCPtrList *pList)
{
	m_pConfig = pConfig;
	VCPOSITION pos = pList->GetHeadPosition();
	while (pos)
		m_ListOuts.AddTail(pList->GetNext(pos));
}


STDMETHODIMP COutsEnum::Reset()
{
	HRESULT hr = S_OK;
	m_iOut = 0;
	return(hr);
}

STDMETHODIMP COutsEnum::Next(/*[in]*/ ULONG cElements, /*[in, out, size_is(cElements)]*/ IVsOutput *rgpIVsOutput[], /*[out]*/ ULONG *pcElementsFetched)
{
	HRESULT hr = S_FALSE;
	UINT i = 0;
	UINT iMax;
	VCPOSITION pos;

	iMax = (UINT) m_ListOuts.GetCount();
	rgpIVsOutput[i] = (IVsOutput *)NULL;
	if (m_iOut < iMax)
	{
		pos = m_ListOuts.FindIndex(m_iOut);
		while (pos && cElements > 0)
		{
			CBldMarshaller<IVsOutput> marshalVsOutput;
			marshalVsOutput.Init((IVsOutput *)m_ListOuts.GetNext(pos));
			CComPtr<IVsOutput> spOutput;
			marshalVsOutput.UnmarshalPtr(&spOutput);
			rgpIVsOutput[i] = spOutput.Detach();
			i++;
			cElements--;
		}
		m_iOut += i;
		hr = i > 0 ? S_OK : S_FALSE;
	}
	if (pcElementsFetched)
	{
		*pcElementsFetched = i;
	}
	return(hr);
}

STDMETHODIMP COutsEnum::Skip(/*[in]*/ ULONG cElements)
{
	HRESULT hr = S_OK;
	UINT iMax;

	iMax = (UINT) m_ListOuts.GetCount();
	if (iMax > m_iOut + cElements)
		m_iOut += cElements;
	else
		m_iOut = iMax - 1;
	return(hr);
}

STDMETHODIMP COutsEnum::Clone(/*[out]*/ IVsEnumOutputs **ppIVsEnumOutputs)
{
	RETURN_INVALID_ON_NULL(ppIVsEnumOutputs);
	*ppIVsEnumOutputs = NULL;

	CComPtr<IVsEnumOutputs> spCfgEnum;
	HRESULT hr = COutsEnum::CreateInstance(&spCfgEnum, m_pConfig, &m_ListOuts);
	if (SUCCEEDED(hr))
	{
		CBldMarshaller<IVsEnumOutputs> marshalEnumOutputs;
		hr = marshalEnumOutputs.Init(spCfgEnum);
		if (SUCCEEDED(hr))
			hr = marshalEnumOutputs.UnmarshalPtr(ppIVsEnumOutputs);
	}

	return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\output.cpp ===
#include "stdafx.h"
#include "output.h"

CTestableSection CVCBuildOutput::s_sectionOutWindowPane;

/////////////////////////////////////////////////////////////////////////////
// CVCBuildOutput

CVCBuildOutput::CVCBuildOutput()
{
	m_pStreamOutPane = NULL;
}

HRESULT CVCBuildOutput::CreateInstance(IVCBuildOutput** ppOutput, IUnknown* pUnkWindowPane)
{
	HRESULT hr;
	CVCBuildOutput *pVar;
	CComObject<CVCBuildOutput> *pObj;
	hr = CComObject<CVCBuildOutput>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		hr = pVar->InitInstance(pUnkWindowPane);
		pVar->Create();
		*ppOutput = reinterpret_cast<IVCBuildOutput *>(pVar);
	}
	return(hr);
}

HRESULT CVCBuildOutput::InitInstance(IUnknown* pUnkWindowPane)
{
	m_pStreamOutPane = NULL;
	HRESULT hr = AtlMarshalPtrInProc(pUnkWindowPane, IID_IVsOutputWindowPane, &m_pStreamOutPane);
	VSASSERT(SUCCEEDED(hr), "Failed to marshal output window pane; was our stream created in the primary thread (required)?");
	m_spUnkWindowPane = pUnkWindowPane;

	return S_OK;
}

CVCBuildOutput::~CVCBuildOutput()
{
	VSASSERT(m_rgpVsOutputWindowPane.GetCount() == 0, "Still have an output window pane at destruction time!");
	if (m_rgpVsOutputWindowPane.GetCount() != 0)
		CloseAll();

	HRESULT hr = AtlFreeMarshalStream(m_pStreamOutPane);
	VSASSERT(SUCCEEDED(hr), "Failed to free marshal an output window pane");
	m_pStreamOutPane = NULL; // get rid of this... we don't want to re-use this accidently
	m_spUnkWindowPane.Release();
}

STDMETHODIMP CVCBuildOutput::SameWindowPane(IUnknown* pUnkPane)
{
	return (pUnkPane == m_spUnkWindowPane) ? S_OK : S_FALSE;
}

STDMETHODIMP CVCBuildOutput::Close()
{
	return CloseWithCount(NULL);
}

STDMETHODIMP CVCBuildOutput::CloseWithCount(int *pCount)
{
	CritSectionT cs(s_sectionOutWindowPane);

	int idThread = GetCurrentThreadId();
	IVsOutputWindowPane *pPane;
	if (m_rgpVsOutputWindowPane.Lookup(idThread, pPane) != 0)
	{
		pPane->Release();
		m_rgpVsOutputWindowPane.RemoveKey(idThread);
	}
	if (pCount != NULL)
		*pCount = m_rgpVsOutputWindowPane.GetCount();

	return S_OK;
}

STDMETHODIMP CVCBuildOutput::CloseAll()
{
	CritSectionT cs(s_sectionOutWindowPane);

	VCPOSITION pos = m_rgpVsOutputWindowPane.GetStartPosition();
	while (pos)
	{
		IVsOutputWindowPane *pPane;
		int idThread;
		m_rgpVsOutputWindowPane.GetNextAssoc(pos, idThread, pPane);
		if (pPane)
			pPane->Release();
	}
	m_rgpVsOutputWindowPane.RemoveAll();

	return S_OK;
}

IVsOutputWindowPane *CVCBuildOutput::GetOutWindowPane()
{
	HRESULT hr;
	IVsOutputWindowPane *pPane = NULL;

	int id;
	id = GetCurrentThreadId();
	CritSectionT cs(s_sectionOutWindowPane);
	if (m_rgpVsOutputWindowPane.Lookup(id, pPane) == 0 && m_pStreamOutPane != NULL)
	{
		hr = AtlUnmarshalPtr(m_pStreamOutPane, IID_IVsOutputWindowPane, (IUnknown **)&pPane);
		VSASSERT(SUCCEEDED(hr), "Failed to unmarshal output window pane stream!");
		if (pPane)
			m_rgpVsOutputWindowPane[id] = pPane;
	}

	return(pPane);
}

STDMETHODIMP CVCBuildOutput::get_OutputWindowPane(IUnknown** ppOutWindowPane)
{
	CHECK_POINTER_NULL(ppOutWindowPane);

	IVsOutputWindowPane* pPane = GetOutWindowPane();
	RETURN_ON_NULL(pPane);

	pPane->AddRef();
	*ppOutWindowPane = pPane;
	return S_OK;
}

STDMETHODIMP CVCBuildOutput::Create()
{
	return(S_OK);
}

STDMETHODIMP CVCBuildOutput::AddString(BSTR bstr, BOOL bAddCRLF)
{
	IVsOutputWindowPane *pPane = GetOutWindowPane();
	RETURN_ON_NULL(pPane);

	CComBSTR bstrOut;
	if (bAddCRLF)
	{
		CStringW strCRLF = bstr;
		strCRLF += L"\n";
		bstrOut = strCRLF;
	}
	else
		bstrOut = bstr;
	HRESULT hr = pPane->OutputString(bstrOut);
	VSASSERT(SUCCEEDED(hr), "Failed to write a string to the output window pane!");
	return hr;
}

STDMETHODIMP CVCBuildOutput::Clear()
{
	IVsOutputWindowPane *pPane = GetOutWindowPane();
	if (pPane)
		pPane->Clear();

	EnsureVisible();
	return S_OK;
}

STDMETHODIMP CVCBuildOutput::Activate()
{
	IVsOutputWindowPane *pPane = GetOutWindowPane();
	if (pPane)
		pPane->Activate();

	return S_OK;
}

HRESULT CVCBuildOutput::EnsureVisible()
{
/*
	find the containing window for our output window. This assumes that
	we are always contained by this. We also assume that our pane is inside
	this frame.
*/
	return E_FAIL;
}


STDMETHODIMP CVCBuildOutput::FlushToTaskList()
{
	IVsOutputWindowPane *pPane = GetOutWindowPane();
	if (pPane)
		pPane->FlushToTaskList();

	return S_OK;
}


STDMETHODIMP CVCBuildOutput::OutputTaskItemString(LPCOLESTR pszOutputString, LONG /*VSTASKPRIORITY*/ nPriority, 
	LONG /*VSTASKCATEGORY*/ nCategory, LPCOLESTR pszSubcategory, LONG /*VSTASKBITMAP*/ nBitmap, LPCOLESTR pszFilename, 
	ULONG nLineNum, LPCOLESTR pszTaskItemText)

{
	IVsOutputWindowPane *pPane = GetOutWindowPane();
	RETURN_ON_NULL(pPane);

	HRESULT hr = pPane->OutputTaskItemString(pszOutputString, (VSTASKPRIORITY)nPriority, 
		(VSTASKCATEGORY)nCategory, pszSubcategory, (VSTASKBITMAP)nBitmap, pszFilename, nLineNum, pszTaskItemText);
	VSASSERT(SUCCEEDED(hr), "Failed to write a string to the task list; did we get a parameter wrong?");
	if (pPane)
		pPane->FlushToTaskList();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\prjnode.h ===
// VCPrjNode.h: interface for the CVCProjectNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VCPRJNODE_H__1FAE18F5_9021_11D0_8D12_00A0C91BC942__INCLUDED_)
#define AFX_VCPRJNODE_H__1FAE18F5_9021_11D0_8D12_00A0C91BC942__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "vc.h"
#include "VCBsNode.h"
// for IVsGetCfgProvider
#include "vssolutn.h"
#include <prjids.h>
#include <BldMarshal.h>
#include "DataObject.h"
#include "ocdesign.h"

#include <atlctl.h>

enum  ICON_TYPE;
class CVCArchy;
class COnDropHelper;

class CVCProjectNode;

template <typename T> CComPtr<T> VCQI_cast( const CVCProjectNode* pCVCProjectNode) 
{ 
	CComPtr<T>	pT;
	((CVCProjectNode*)pCVCProjectNode)->QueryInterface( __uuidof(T), (void**)&pT );
	ASSERT( pT );
	return pT;
}

class CVCProjectNode :	public CVCBaseFolderNode,
						public IVsGetCfgProvider,
						public IDispatchImpl<_VCProject, &IID__VCProject, &LIBID_VCPrivateProjectLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
						public IVsPerPropertyBrowsing,
						public IOleCommandTarget,
						public IProvidePropertyBuilder,				
						public IPerPropertyBrowsing,
						public IPropertyNotifySinkCP<CVCProjectNode>,
						public IConnectionPointContainerImpl<CVCProjectNode>
{
public:
	CVCProjectNode(void);
	virtual ~CVCProjectNode();

	BOOL Open();
	virtual VSITEMID GetVsItemID(void) const;
	static HRESULT CreateInstance(CVCProjectNode **);
	virtual HRESULT DoDefaultAction(BOOL fNewFile);
	virtual HRESULT GetCanonicalName(BSTR* pbstrCanonicalName);
	virtual HRESULT GetName(BSTR* pbstrName);
	virtual HRESULT DisplayContextMenu(VARIANT *pvaIn);
	virtual CVCArchy* GetHierarchy(void) const;

	virtual	HRESULT CleanUpBeforeDelete();
	virtual HRESULT OnDelete(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE);
	virtual HRESULT CleanUpUI(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE);

	HRESULT CleanUpObjectModel(IDispatch* pParentDisp, IDispatch* pProjectDisp);
	HRESULT GetObjectsForDelete(IDispatch** ppParentDisp, IDispatch** ppProjectDisp);
	STDMETHOD(OnSaveProject)(LPCOLESTR pszNewName);
	BOOL IsProjectFileDirty();
	BOOL MatchesHierarchy(IVsHierarchy* pIVsHierarchy);
	void OnActiveProjectCfgChange();

public:
	virtual HRESULT GetExtObject(CComVariant& varRes);
	HRESULT GetActiveConfig(IVCGenericConfiguration** ppGenCfg);
	HRESULT CompileFileItems(CVCPtrList& rlistFiles);
	HRESULT OnDropMove(CVCOleDataObject& rDataObject, CVCNode* pDropNode, CVCProjDataSource* pOurDataSource, BOOL bCrossVC,
		BOOL bDrag, BOOL& bReported);
	HRESULT OnDropCopy(CVCOleDataObject& rDataObject, CVCNode* pDropNode, CVCProjDataSource* pOurDataSource, BOOL bCrossVC,
		BOOL bDrag, BOOL& bReported);
	virtual CVCProjectNode* GetVCProjectNode() { return this; }
	HRESULT GetBscFileName(BSTR* pbstrBSCName);

BEGIN_COM_MAP(CVCProjectNode)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
	COM_INTERFACE_ENTRY(_VCProject)
	COM_INTERFACE_ENTRY(IVsGetCfgProvider)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCProjectNode)

BEGIN_PROP_MAP(CVCProjectNode)
	PROP_ENTRY( "Name", VCPRJNODID_Name, CLSID_NULL )
END_PROP_MAP()

BEGIN_CONNECTION_POINT_MAP(CVCProjectNode)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP() 

public:
// _VCProject
	STDMETHOD(get_ProjectFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ProjectDependencies)( BSTR *pVal );

	// automation extender methods
	STDMETHOD(get_Extender)(BSTR bstrName, IDispatch **ppDisp);
	STDMETHOD(get_ExtenderNames)(VARIANT *pvarNames);
	STDMETHOD(get_ExtenderCATID)(BSTR *pbstrGuid);

// IPerPropertyBrowsing
// Everything that should not be viewable by the user should be E_NOTIMPL!!
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr )
		{ return E_NOTIMPL; /* CVCProjectNode::GetDisplayString */ }
	STDMETHOD(MapPropertyToPage)( DISPID dispID, CLSID *pClsid )
		{ return E_NOTIMPL; /* CVCProjectNode::MapPropertyToPage */ }
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut )
		{ return E_NOTIMPL; /* CVCProjectNode::GetPredefinedStrings */ }
	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut )
		{ return E_NOTIMPL; /* CVCProjectNode::GetPredefinedValue */ }

// IProvidepropertyBuilder
	STDMETHOD(MapPropertyToBuilder)( LONG dispid, LONG *pdwCtlBldType, BSTR *pbstrGuidBldr, VARIANT_BOOL *pfRetVal );
	STDMETHOD(ExecuteBuilder)( LONG dispid, BSTR bstrGuidBldr, IDispatch *pdispApp, LONG_PTR hwndBldrOwner, VARIANT *pvarValue, VARIANT_BOOL *pfRetVal );

// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)(DISPID dispid, BOOL *pfHide)
		{ return E_NOTIMPL; /* CVCProjectNode::HideProperty */ }
	STDMETHOD(DisplayChildProperties)(DISPID dispid, BOOL *pfDisplay)
		{ return E_NOTIMPL; /* CVCProjectNode::DisplayChildProperties */ }
	STDMETHOD(HasDefaultValue)(DISPID dispid, BOOL *pfDefault)
		{ return E_NOTIMPL; /* CVCProjectNode::HasDefaultValue */ }
	STDMETHOD(IsPropertyReadOnly)(DISPID dispid, BOOL *fReadOnly);
	STDMETHOD(GetLocalizedPropertyInfo)(DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc);
	STDMETHOD(GetClassName)(BSTR* pbstrClassName);
    STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
    STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}


public:
	UINT GetIconIndex(ICON_TYPE);
	HRESULT GetGuidProperty( VSHPROPID propid, GUID *pguid);
	HRESULT SetGuidProperty( VSHPROPID propid, GUID guid );
	HRESULT SetProperty(VSHPROPID propid, const VARIANT& var);
	HRESULT GetProperty(VSHPROPID propid, VARIANT *pvar);

	// IOleCommandTarget
	STDMETHOD(QueryStatus)(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut);
	
// IVsGetCfgProvider
public:
	STDMETHOD(GetCfgProvider)(IVsCfgProvider** ppCfgProvider);

public:
	virtual UINT GetKindOf( void )
	{
		return Type_CVCProjectNode;
	}

protected:
	CVCArchy *m_pArchy;
	CBldMarshaller<IVsHierarchy> m_marshalVsHierarchy;

public:
	virtual HRESULT GetVCProject(VCProject** ppProject)
	{ 
		CHECK_POINTER_NULL(ppProject);
		CComQIPtr<VCProject> spProject = m_dispkeyItem;
		*ppProject = spProject.Detach();
		return S_OK;
	}
	virtual HRESULT GetDispVCProject(IDispatch** ppProject)
	{ 
		CHECK_POINTER_NULL(ppProject);
		*ppProject = m_dispkeyItem;
		if (*ppProject)
			(*ppProject)->AddRef();
		return S_OK;
	}
	CVCArchy* GetArchy();
	void SetArchy(CVCArchy* pArchy);
	HRESULT GetVsHierarchy(IVsHierarchy** ppHier, BOOL bInMainThread = FALSE);

protected:
	HRESULT DoInternalMove(CVCNode* pTgtNode, DWORD cItems, CVCNode* rgMovedNodes[], BOOL bDrag, BOOL& bReported);
	HRESULT DoCrossVCMoveOrCopy(CVCOleDataObject& rDataObject, CVCNode* pTgtNode, bool bIsMove, BOOL bDrag, BOOL& bReported);
	HRESULT DoNonVCCopy(CVCOleDataObject& rDataObject, CVCNode* pTgtNode, BOOL bDrag, BOOL& bReported);
	HRESULT CanMoveOrCopyElement(VCProject* pProjectParent, VCFilter* pFilterParent, IDispatch* pItem, bool bTopLevel, 
		bool bIsMove, BOOL bDrag, BOOL& bReported);
	HRESULT CanAddElementCollection(VCProject* pProject, VCFilter* pFilter, IDispatch* pItemCollection, BOOL bDrag, BOOL& bReported);
	HRESULT AddElement(VCProject* pProjectParent, VCFilter* pFilterParent, IDispatch* pItem, bool bIsMove, BOOL bDrag,
		BOOL& bReported);
	HRESULT AddElementCollection(VCProject* pProject, VCFilter* pFilter, IDispatch* pItemCollection, BOOL bDrag,
		BOOL& bReported);
	HRESULT BuildProjItemList(COnDropHelper& dropHelper, CVCOleDataObject& rDataObject, BOOL bCrossVC);
	void GetVCItemFromVsItem(IVsHierarchy* pHier, VSITEMID itemID, IDispatch** ppVCItem);
	void GetVsItemNameAndType(IVsHierarchy* pHier, VSITEMID itemID, BSTR* pbstrName, BOOL& bIsFile, BOOL& bIsFilter);
	HRESULT CanCopyVsElement(VCProject* pProjectParent, VCFilter* pFilterParent, IVsHierarchy* pHier, VSITEMID itemID, 
		bool bIsTopLevel, BOOL bDrag, BOOL& bReported);
	HRESULT AddVsElement(VCProject* pProjectParent, VCFilter* pFilterParent, IVsHierarchy* pHier, VSITEMID itemID, BOOL bDrag,
		BOOL& bReported);

	HRESULT ReportMoveError(HRESULT hrReport, IDispatch* pItem, IDispatch* pParent, BOOL bDrag, BOOL& bReported);
	HRESULT ReportVCCopyError(HRESULT hrReport, VCProject* pProjectParent, VCFilter* pFilterParent, IDispatch* pItem, 
		bool bIsMove, BOOL bDrag, BOOL& bReported);
	HRESULT ReportVsCopyError(HRESULT hrReport, VCProject* pProjectParent, VCFilter* pFilterParent, IVsHierarchy* pHier, 
		VSITEMID itemID, BOOL bDrag, BOOL& bReported);
	HRESULT ReportRemoveError(HRESULT hrReport, IDispatch* pItem, BOOL& bReported);

	static HRESULT ReportCopyError(HRESULT hrReport, IDispatch* pParent, CStringW& strItemName, CStringW& strParentName, 
		BOOL bDrag, BOOL& bReported);
	static void GetIdentifierString(IDispatch* pItem, CStringW& strIdentifier);

	enumEnableStates SupportsBuildType(bldActionTypes buildType);
	HRESULT DoBuildType(bldActionTypes buildType);

public:
	BOOL InBuild();

	static HRESULT ReportShellCopyError(HRESULT hrReport, VCProject* pProject, VCFilter* pFilter, LPWSTR wstrFile, 
		BOOL& bReported);
	static BOOL VsHandlesError(HRESULT hrReport);
	static void GetProjectNameString(IDispatch* pItem, CStringW& strProj);

private:
	// flag to prevent recursive closing 
	// (ugly hack, but necessary because we're called back from the shell)
	bool m_bStartedClose;
	CComBSTR m_bstrProjectType;
private:
	// automation extender CATID
	static const LPOLESTR s_wszCATID;
};

//-----------------------------------------------------------------------------
// Execution context class. Allows program to set state about an execution through
// the use of key/value pairs. For example: the delete commaand could set the ctx
// IDYES for it's delete confirmation dialog. So when user checks "apply to all items"
// it won't prompt. The code can get back the ctx (in this case IDYES) and use
// that. The Start/EndSingleOp() method should be used at the start and end of an operation to
// flush out the context. MultiSelect handlers should use the start/end MultiOp 
// funcitons.
// The class provides a generic CANCELLED state since this applies across all items.
//-----------------------------------------------------------------------------
#define CTX_MULTISELECT  0xffffffff
class CVCExecutionCtx
{
public:
				CVCExecutionCtx();
				~CVCExecutionCtx();
		void	SetCancelled(){m_bCancelled = TRUE;}
		void	ClearCancelled(){m_bCancelled = FALSE;}
		void	SetMultiSelect(DWORD dwCount){SetValue(CTX_MULTISELECT, dwCount);}
		DWORD	GetMultiSelect(){return GetValue(CTX_MULTISELECT);}
		void	StartOp();
		void	EndOp();
		BOOL	IsCancelled(){return m_bCancelled;}
		DWORD	GetValue(DWORD key);
		void	SetValue(DWORD key, DWORD value);
		// Use nesting level to determine multiop func
		BOOL	IsMultiOp() {return m_dwRef > 1;}
		DWORD	GetRefCount() {return m_dwRef;}
		void	ClearData();
protected:
		void	Clear();

	struct CExCtx
		{
			DWORD key;
			DWORD value;
		};
		BOOL	m_bCancelled;
		DWORD	m_dwRef;	// Nesting control
		CVCTypedPtrArray<CVCPtrArray, CExCtx*> m_exCtxArray;

		CExCtx* GetExCtx(DWORD key);
};

// Useful helper to automatically do the start/end operations for you
class CVCExecution
{
public:
				CVCExecution(CVCExecutionCtx* pCtx) : m_pCtx(pCtx){pCtx->StartOp();};
				~CVCExecution() {m_pCtx->EndOp();};
protected:
	CVCExecutionCtx*	m_pCtx;
};

class COnDropHelper
{
public:
	COnDropHelper();
	~COnDropHelper();

	HDROP m_hItemDropInfo;
	int m_numFiles;
	int m_numActualFiles;
	VSITEMID* m_rgSrcItemIDs;
	IVsHierarchy** m_rgSrcHierarchies;
};

#endif // !defined(AFX_VCPRJNODE_H__1FAE18F5_9021_11D0_8D12_00A0C91BC942__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\prjnode.cpp ===
// VCPrjNode.cpp: implementation of the CVCProjectNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BldPkg.h"
#include "PrjNode.h"
#include "..\resdll\gpcmd.h"
#include "vcfgrp.h"
#include "vcfile.h"
#include "vcarchy.h"
#include "vssccmgr.h"
#include "stdidcmd.h"
#include "vsshlids.h"
#include <docobj.h>
#include <vcguid.h>
#include "AutoProject.h"
#include <vsqryed.h>
#include "context.h"

#ifndef ECMD_WEBDEPLOY
#define ECMD_WEBDEPLOY 5000
#endif	// ECMD_WEBDEPLOY

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// static member initialization

const LPOLESTR CVCProjectNode::s_wszCATID = L"{EE8299CB-19B6-4f20-ABEA-E1FD9A33B683}";

//-----------------------------------------------------------------------------
// create an instance of a project node with refrence count 1
//-----------------------------------------------------------------------------
HRESULT CVCProjectNode::CreateInstance(CVCProjectNode **ppProjectNode)
{
	CComObject<CVCProjectNode> *pPrjObj = NULL;	 // created with 0 ref count
	HRESULT hr = CComObject<CVCProjectNode>::CreateInstance(&pPrjObj);

	if (SUCCEEDED(hr))
		pPrjObj->AddRef();
	*ppProjectNode = pPrjObj;

	return hr;
}

CVCProjectNode::CVCProjectNode(void)
{
	m_pArchy = NULL;
	m_bStartedClose = false;
}

CVCProjectNode::~CVCProjectNode()
{
}

CVCArchy* CVCProjectNode::GetArchy()
{ 
	return m_pArchy;
}

void CVCProjectNode::SetArchy(CVCArchy* pArchy)
{
	m_pArchy = pArchy;
	if (m_pArchy != NULL)
		m_marshalVsHierarchy.Init(static_cast<IVsHierarchy*>(pArchy));	// yes, I WANT the static cast here!
	else
		m_marshalVsHierarchy.Clear();
}

HRESULT CVCProjectNode::GetVsHierarchy(IVsHierarchy** ppHier, BOOL bInMainThread /* = FALSE */)
{
	CHECK_POINTER_NULL(ppHier);

	if (bInMainThread)
	{
		CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(m_pArchy);
		*ppHier = spHier.Detach();
		return S_OK;
	}

	VSASSERT(m_marshalVsHierarchy.IsInit(), "GetVsHierarchy being called from secondary thread before initialization in primary thread");

	// yes, I know, we're not dealing with the aggregated version of the pointer here, but that isn't 
	// really necessary since we'll only be here in secondary threads, like in a build
	return m_marshalVsHierarchy.UnmarshalPtr(ppHier);
}

//---------------------------------------------------------------------------
// Returns our Hierarchy object
//---------------------------------------------------------------------------
CVCArchy* CVCProjectNode::GetHierarchy(void) const
{
	VSASSERT(NULL != m_pArchy, "Our hierarchy isn't initialized!");
	return m_pArchy;
}

//-----------------------------------------------------------------------------
// Reads the project file (if we havent' already done so), and loads the project 
// into memory.
//-----------------------------------------------------------------------------
BOOL CVCProjectNode::Open()
{
	BOOL bRetVal = TRUE;
// open the project file. For now, we pretend we have one.
	return bRetVal;
}

//---------------------------------------------------------------------------
// return the VSITEMID value for this node
// a cast of the this pointer to the VSITEMID (dword) type
// exception will be for root nodes which should return VSITEMID_ROOT
//---------------------------------------------------------------------------
VSITEMID CVCProjectNode::GetVsItemID(void) const
{
	VSASSERT(GetParent() == NULL, "Shouldn't have parent for a project!");
	return VSITEMID_ROOT;
}

UINT CVCProjectNode::GetIconIndex(ICON_TYPE iconType)
{
#ifdef AARDVARK
	if(iconType == ICON_StateImage)
		return STATEICON_NOSTATEICON;

	CComBSTR bstrName;
	GetName( &bstrName );
	if( wcsncmp( bstrName, L"CSharp", wcslen( L"CSharp" ) ) == 0 )
		return BMP_CSPROJNODE;
	else if( wcsncmp( bstrName, L"VB", wcslen( L"VB" ) ) == 0 )
		return BMP_VBPROJNODE;
	else
		return BMP_PROJNODE;
#endif // AARDVARK

	UINT index = BMP_SOLUTION;
	if(iconType == ICON_StateImage)
	{
		CVCArchy *pArchy;

		pArchy = (CVCArchy *)GetHierarchy();
		if (pArchy)
		{
			CComBSTR bstrPath;
			LPOLESTR pszFullPaths;
			VSSCCSTATUS dwSccStatus;
			index = STATEICON_NOSTATEICON;
			
			CComPtr<VCProject> pProject;
			GetVCProject(&pProject);
			RETURN_ON_NULL2(pProject, index);

			pProject->get_ProjectFile( &bstrPath );
			pszFullPaths = bstrPath;


			CComPtr<IVsSccManager2> srpIVsSccManager2;
			if (GetBuildPkg() && GetBuildPkg()->GetSccManager(&srpIVsSccManager2))
			{
				VsStateIcon siGlyph = STATEICON_NOSTATEICON;
				srpIVsSccManager2->GetSccGlyph(1, &pszFullPaths, &siGlyph, &dwSccStatus);
				index = siGlyph;
			}
		}
	}
	else
	{
		index = BMP_PROJNODE;
	}
	return index;
}

HRESULT CVCProjectNode::DoDefaultAction(BOOL fNewFile)
{
	return S_OK;
}

HRESULT CVCProjectNode::GetCanonicalName(BSTR* pbstrName)
{
	CComPtr<VCProject> pProject;
	GetVCProject(&pProject);
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	return pProject->get_ProjectFile(pbstrName);
}

HRESULT CVCProjectNode::GetName(BSTR* pbstrName)
{
	CComPtr<VCProject> pProject;
	GetVCProject(&pProject);
	if (pProject)
		return pProject->get_Name(pbstrName);

	CHECK_ZOMBIE(NULL, IDS_ERR_PROJ_ZOMBIE);
	return S_OK;
}

void CVCProjectNode::OnActiveProjectCfgChange()
{
	if (m_pArchy == NULL)
		return;		// nothing we can do

	// the shell isn't paying attention to the fact that we really want to have the
	// OnPropertyChanged call passed down to all members of the hierarchy, so we
	// have to walk through the list and do it ourselves.  Sigh.  This code assumes
	// that only files can have per config changes in the icon.

	// walk through the file list and tell all of them that their icon may have changed
	CComQIPtr<VCProject> spProject = m_dispkeyItem;
	if (spProject == NULL)
		return;		// nothing more we can do

	CComPtr<IDispatch> spDispFiles;
	spProject->get_Files(&spDispFiles);
	CComQIPtr<IVCCollection> spFiles = spDispFiles;
	if (spFiles == NULL)
		return;		// nothing more we can do

	CComPtr<IEnumVARIANT> spEnum;
	spFiles->_NewEnum(reinterpret_cast<IUnknown **>(&spEnum));
	if (spEnum == NULL)
		return;		// nothing more we can do

	spEnum->Reset();
	while (TRUE)
	{
		CComVariant var;
		HRESULT hr = spEnum->Next(1, &var, NULL);
		if (hr != S_OK)
			break;

		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;

		CComQIPtr<IVCExternalCookie> spCookie = var.pdispVal;
		if (spCookie == NULL)
			continue;

		void* pNode = NULL;
		spCookie->get_ExternalCookie(&pNode);
		if (pNode == NULL)
			continue;

		CVCFileNode* pFileNode = (CVCFileNode*)pNode;
		m_pArchy->OnPropertyChanged(pFileNode, VSHPROPID_IconIndex, 0x0);
	}
}

//---------------------------------------------------------------------------
//	REVIEW: This is for debugging only
//---------------------------------------------------------------------------
HRESULT CVCProjectNode::DisplayContextMenu(VARIANT *pvaIn)
{
	CComPtr<IOleCommandTarget> spTarget = VCQI_cast<IOleCommandTarget>(this);
	return ShowContextMenu(IDM_VS_CTXT_PROJNODE, pvaIn, guidSHLMainMenu, spTarget);
}

//-----------------------------------------------------------------------------
// Called to update the status of our commands
//-----------------------------------------------------------------------------
STDMETHODIMP CVCProjectNode::QueryStatus(
	const GUID *pguidCmdGroup,
	ULONG cCmds,
	OLECMD prgCmds[],
	OLECMDTEXT *pCmdText)
{
	if(!pguidCmdGroup)
		return OLECMDERR_E_UNKNOWNGROUP;

	if(*pguidCmdGroup == guidVSStd2K)
	{
		for (ULONG i=0; i<cCmds; i++)
		{
			enumEnableStates fEnable = eEnableSupported;
#ifdef _DEBUG_MENU
			ATLTRACE(_T("ProjectNode guidVSStd2K: cmdid=%ld (%lx)\n"), prgCmds[i].cmdID, prgCmds[i].cmdID);
#endif
			switch(prgCmds[i].cmdID)
			{
				case ECMD_PROJSETTINGS:
				case ECMD_ADDRESOURCE:
					fEnable = eEnableSupportedAndEnabled;
					break;
				case ECMD_ADDWEBREFERENCE:
				case ECMD_ADDWEBREFERENCECTX:
					fEnable = CanAddWebRef() ? eEnableSupportedAndEnabled : eEnableSupported;
					break;
				case ECMD_LINKONLY:
					fEnable = SupportsBuildType(TOB_Link);
					break;
				case ECMD_WEBDEPLOY:
					fEnable = SupportsBuildType(TOB_Deploy);
					break;
				case ECMD_XBOXIMAGE:
					fEnable = SupportsBuildType(TOB_XboxImage);
					break;
				case ECMD_XBOXDEPLOY:
					fEnable = SupportsBuildType(TOB_XboxDeploy);
					break;
				default:
					return CVCBaseFolderNode::QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
			}
			prgCmds[i].cmdf = TranslateEnableState(fEnable);
		}

		return NOERROR;
	}
	else if(*pguidCmdGroup == guidVSStd97)
	{
		for (ULONG i=0; i<cCmds; i++)
		{
			enumEnableStates fEnable = eEnableSupported;
#ifdef _DEBUG_MENU
			ATLTRACE(_T("ProjectNode guidVSStd97: cmdid=%ld (%lx)\n"), prgCmds[i].cmdID, prgCmds[i].cmdID);
#endif
			switch(prgCmds[i].cmdID)
			{
				case cmdidAddClass:
				case cmdidSetStartupProject:
					fEnable = eEnableSupportedAndEnabled;
					break;
				case cmdidPaste:
					fEnable = CanPaste() ? eEnableSupportedAndEnabled : eEnableSupported;
					break;
				default:
				{	// REVIEW: This won't work if cCmds > 1)
					VSASSERT(cCmds == 1, "REVIEW: our QueryStatus doesn't work if cCmds > 1");
					return CVCBaseFolderNode::QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);	 // OLECMDERR_E_NOTSUPPORTED;
				}
			}
			prgCmds[i].cmdf = TranslateEnableState(fEnable);
		}
		return NOERROR;
	}
	// Let base class deal with the rest
	return CVCBaseFolderNode::QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
}

HRESULT CVCProjectNode::GetGuidProperty( VSHPROPID propid, GUID *pguid)
{
	CHECK_POINTER_NULL(pguid)

	switch(propid)
	{
		case VSHPROPID_TypeGuid:
		{
			*pguid = IID_IVCArchy;
			return S_OK;
		}
		case VSHPROPID_CmdUIGuid:
		{
			*pguid = IID_IVCArchy;
			return S_OK;
		}
		case VSHPROPID_ProjectIDGuid:
		{
			HRESULT hr;
			CComBSTR bstrGuid;
			CComQIPtr<VCProject> pProj = m_dispkeyItem;
			hr = pProj->get_ProjectGUID( &bstrGuid );
			hr = CLSIDFromString( bstrGuid, pguid );
			return S_OK;
		}
	}
	return E_FAIL;
}

HRESULT CVCProjectNode::SetGuidProperty( VSHPROPID propid, GUID guid)
{
	switch(propid)
	{
		case VSHPROPID_ProjectIDGuid:
		{
			HRESULT hr;
			CComQIPtr<VCProject> pProj = m_dispkeyItem;

		    	CComBSTR bstrOldGuid;
			hr = pProj->get_ProjectGUID( &bstrOldGuid );
			
			LPOLESTR lpszBuf = NULL;
			hr = StringFromCLSID(guid, &lpszBuf);
			CComBSTR bstrGuid;
			bstrGuid = lpszBuf;
			::CoTaskMemFree(lpszBuf);

			if( bstrGuid == bstrOldGuid )  
			    return S_OK;		// Shell doing something really stupid here ! Don't write if they match.

			hr = pProj->put_ProjectGUID( bstrGuid );
			return S_OK;
		}
	}
	return E_FAIL;
}

HRESULT CVCProjectNode::SetProperty(VSHPROPID propid, const VARIANT& var)
{
	if( propid == VSHPROPID_EditLabel )
	{
		// don't try to set if it hasn't actually changed
		CComBSTR bstrOldName;
		get_Name( &bstrOldName );
		if( wcscmp( bstrOldName, var.bstrVal ) != 0 )
			put_Name( var.bstrVal );
		return S_OK;
	}
	else if( propid == VSHPROPID_OwnerKey )
	{
		CComPtr<VCProject> pProj;
		HRESULT hr = GetVCProject( &pProj );
		RETURN_ON_FAIL_OR_NULL(hr, pProj);
		return pProj->put_OwnerKey( var.bstrVal );
	}

	// handle project node properties here...
	else 
		return CVCBaseFolderNode::SetProperty(propid, var);
}

//---------------------------------------------------------------------------
//	Returns the requested property in the given variant.
//---------------------------------------------------------------------------
HRESULT CVCProjectNode::GetProperty(VSHPROPID propid, VARIANT *pvar)
{
	// handle project node properties here...
	HRESULT hr = E_FAIL;
	CComVariant varRes;
	switch( propid )
	{
	case VSHPROPID_Name:
	case VSHPROPID_SaveName:
	case VSHPROPID_Caption:
	case VSHPROPID_EditLabel:
	{	// return this node's displayed caption
		pvar->vt = VT_BSTR;
		CComBSTR bstrName;
		hr = GetName(&bstrName);
		if (SUCCEEDED(hr))
			pvar->bstrVal = bstrName.Detach();
		return hr;
	}
	case VSHPROPID_UserContext:
	{
		varRes.ChangeType(VT_UNKNOWN);
		varRes.punkVal = NULL;

		CComPtr<IVsUserContext> pUserCtx;
		CComPtr<IVsMonitorUserContext> pmuc;
		if (SUCCEEDED(ExternalQueryService(SID_SVsMonitorUserContext, IID_IVsMonitorUserContext, (void **)&pmuc)))
		{

			CComQIPtr<VCProject> pProj = m_dispkeyItem;
			
			CComBSTR bstrKeyword;
			pProj->get_Keyword( &bstrKeyword );
			
			if( m_bstrProjectType.Length() == 0 )
			{
				CComPtr<IVCGenericConfiguration> spGenCfg;
				hr = GetActiveConfig(&spGenCfg);
				CComQIPtr<IVCCfg> spCfg = spGenCfg;
				if( FAILED(hr) || spCfg == NULL )
				{
					hr = S_OK;
					break;
				}

				CComPtr<IDispatch> pDisp;
				hr = spCfg->get_Object(&pDisp);
				CComQIPtr<VCConfiguration> pConfig = pDisp;
				if( FAILED(hr) || pConfig == NULL )
				{
					hr = S_OK;
					break;
				}

				ConfigurationTypes cfgType;
				pConfig->get_ConfigurationType( &cfgType );
				switch( cfgType )
				{
					case typeApplication:
						m_bstrProjectType = L"exe";
						break;
					case typeDynamicLibrary:
						m_bstrProjectType = L"dll";
						break;
					case typeStaticLibrary:
						m_bstrProjectType = L"lib";
						break;
					case typeGeneric:
						m_bstrProjectType = L"util";
						break;
					case typeUnknown:
						m_bstrProjectType = L"mak";
						break;
					default:
						m_bstrProjectType = L"exe";
						break;
				}
			}
				
			CComBSTR bstrSccProjectName;
			pProj->get_SccProjectName( &bstrSccProjectName );
			LPOLESTR szSCC;
			if( bstrSccProjectName.Length() > 0 )
				 szSCC = L"true";
			else
				 szSCC = L"false";
				
			pmuc->CreateEmptyContext(&pUserCtx);
			pUserCtx->AddAttribute(VSUC_Usage_Filter, L"product",	L"vc");
			pUserCtx->AddAttribute(VSUC_Usage_Filter, L"item",		L"project");
			pUserCtx->AddAttribute(VSUC_Usage_Filter, L"target",	L"win32");
			pUserCtx->AddAttribute(VSUC_Usage_Filter, L"project",	m_bstrProjectType );
			pUserCtx->AddAttribute(VSUC_Usage_Filter, L"projtype", bstrKeyword );
			pUserCtx->AddAttribute(VSUC_Usage_Filter, L"sourcecontrol", szSCC);
			
			varRes = pUserCtx;
			hr = S_OK;
		}
		break;
	}
	case VSHPROPID_OwnerKey:
	{
		CComPtr<VCProject> pProj;
		hr = GetVCProject( &pProj );
		RETURN_ON_FAIL_OR_NULL(hr, pProj);
		CComBSTR bstrTemp;
		pProj->get_OwnerKey( &bstrTemp );
		pvar->vt = VT_BSTR;
		pvar->bstrVal = bstrTemp.Detach();
		return S_OK;
	}
	case VCPROPID_ProjBldBscFile:
	{
		CComBSTR bstrTemp;
		hr = GetBscFileName(&bstrTemp);
		pvar->vt = VT_BSTR;
		pvar->bstrVal = bstrTemp.Detach();
		return hr;
	}
	default:
		hr = CVCBaseFolderNode::GetProperty(propid, &varRes);
		break;
	}
	varRes.Detach(pvar);
	return hr;
}


HRESULT CVCProjectNode::GetBscFileName(BSTR* pbstrBSCName)
{
	*pbstrBSCName = NULL;

	CComPtr<IDispatch> spDispProjCfg;
	HRESULT hr = GetActiveVCProjectConfig(&spDispProjCfg);
	CComQIPtr<VCConfiguration> pVcCfg = spDispProjCfg;
	RETURN_ON_FAIL_OR_NULL(hr, pVcCfg);

	// now, let's try to pick up the per-tool stuff
	VARIANT_BOOL b;
	pVcCfg->get_BuildBrowserInformation( &b );

	if( b == VARIANT_TRUE )
	{
		CComPtr<IDispatch> pDispColl;
		pVcCfg->get_Tools(&pDispColl);
		CComQIPtr<IVCCollection> pToolsColl = pDispColl;
		CComBSTR bstrName( L"VCBscMakeTool");
		CComPtr<IDispatch> pDispTool;
		hr = pToolsColl->Item( CComVariant( bstrName ), &pDispTool );

		CComQIPtr<IVCToolImpl> spToolImpl = pDispTool;
		long nPathID = 0;
		if ( spToolImpl != NULL )
		{
			CComQIPtr<IVCPropertyContainer> spPropContainer = pVcCfg;
			RETURN_ON_NULL2(spPropContainer, E_UNEXPECTED);
			
			CComBSTR bstrOutName;
			hr = spPropContainer->GetEvaluatedStrProperty(VCBSCID_OutputFile, &bstrOutName);
			if (hr != S_OK)
				return hr;
			
			CStringW strName = bstrOutName;
			if (strName.IsEmpty())
				return E_FAIL;
			
			CComBSTR bstrProjName;
			hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjName); 
			if (FAILED(hr))
				return hr;
	
			CStringW strDirName = bstrProjName;
			CDirW dirProj;
			if (!dirProj.CreateFromKnown(strDirName))
				return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
			
			CPathW path;
			if( !path.CreateFromDirAndFilename(dirProj, strName))
				return E_FAIL;
			path.GetActualCase(TRUE);
			*pbstrBSCName = SysAllocString((LPCOLESTR)path);
		
			return S_OK;
		}
	}
	return S_FALSE;
}


//-----------------------------------------------------------------------------
// IProvidePropertyBuilder methods
//-----------------------------------------------------------------------------
STDMETHODIMP CVCProjectNode::MapPropertyToBuilder( LONG dispid, LONG *pdwCtlBldType, BSTR *pbstrGuidBldr, VARIANT_BOOL *pfRetVal )
{
	CHECK_POINTER_NULL( pfRetVal );
	CHECK_POINTER_NULL( pbstrGuidBldr );
	if( dispid == VCPRJNODID_ProjectDependencies )
	{
		*pfRetVal = VARIANT_TRUE;
		*pdwCtlBldType = CTLBLDTYPE_FINTERNALBUILDER;
	}
	else
		*pfRetVal = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CVCProjectNode::ExecuteBuilder( LONG dispid, BSTR bstrGuidBldr, IDispatch *pdispApp, LONG_PTR hwndBldrOwner, VARIANT *pvarValue, VARIANT_BOOL *pfRetVal )
{
	CComPtr<IOleCommandTarget> pCmdTgt;
	HRESULT hr = ExternalQueryService( SID_SUIHostCommandDispatcher, IID_IOleCommandTarget, (void**)&pCmdTgt );
	RETURN_ON_FAIL_OR_NULL(hr, pCmdTgt);
	return pCmdTgt->Exec( &CLSID_StandardCommandSet97, cmdidProjectDependencies, OLECMDEXECOPT_DODEFAULT, NULL, NULL );
}

STDMETHODIMP CVCProjectNode::IsPropertyReadOnly(DISPID dispid, BOOL *fReadOnly)
{ 
	CHECK_POINTER_NULL(fReadOnly);
	if( dispid == VCPRJNODID_Name )
		*fReadOnly = FALSE;
	else
		*fReadOnly = TRUE;
	return S_OK; 
}

STDMETHODIMP CVCProjectNode::GetLocalizedPropertyInfo(DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
{
	CComQIPtr<IDispatch> pdisp;
	QueryInterface(__uuidof(IDispatch), (void**)&pdisp);
	RETURN_ON_NULL(pdisp);

	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
	CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
	RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);

	CComBSTR bstrDoc;
	hr = pTypeInfo2->GetDocumentation2(dispid, localeID, &bstrDoc, NULL, NULL);
	RETURN_ON_FAIL_OR_NULL(hr, bstrDoc.m_str);
	
	LPOLESTR pDesc = wcsstr( bstrDoc, L": " );
	RETURN_ON_NULL(pDesc);

	int nSize = (int)(pDesc - bstrDoc);
	pDesc+=2;

	CComBSTR bstrName( nSize-1, bstrDoc );
	if (pbstrName != NULL)
		*pbstrName = bstrName.Detach();

	CComBSTR bstrDesc( pDesc );
	if (pbstrDesc != NULL)
		*pbstrDesc = bstrDesc.Detach();
	
	return S_OK;
}

STDMETHODIMP CVCProjectNode::GetClassName(BSTR* pbstrClassName)
{
	CHECK_POINTER_NULL(pbstrClassName);
	CComBSTR bstrClassName;
	bstrClassName.LoadString(IDS_PROJ_PROPERTIES);
	*pbstrClassName = bstrClassName.Detach();
	if (*pbstrClassName)
		return S_OK;
	else
		return E_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------
// IVsGetCfgProvider method
//-----------------------------------------------------------------------------
STDMETHODIMP CVCProjectNode::GetCfgProvider(IVsCfgProvider** ppCfgProvider)
{
	VSASSERT(m_pArchy != NULL, "Hey, somebody calling GetCfgProvider after the project has been closed!");
	CHECK_ZOMBIE(m_pArchy, IDS_ERR_PROJ_ZOMBIE);
	CHECK_POINTER_NULL(ppCfgProvider);
	return m_pArchy->QueryInterface(IID_IVsCfgProvider, (void**)ppCfgProvider);
}

//-----------------------------------------------------------------------------
// Called to execute our commands
//-----------------------------------------------------------------------------
STDMETHODIMP CVCProjectNode::Exec(
	const GUID *pguidCmdGroup,
	DWORD nCmdID,
	DWORD nCmdexecopt,
	VARIANT *pvaIn,
	VARIANT *pvaOut)
{
	if (!pguidCmdGroup)
		  return OLECMDERR_E_UNKNOWNGROUP;
	
	if(*pguidCmdGroup == guidVSStd2K)
	{
		switch(nCmdID)
		{
			case ECMD_PROJSETTINGS:
				return ShowSettings(CLSID_VCProject);
			case ECMD_LINKONLY:
				return DoBuildType(TOB_Link);
			case ECMD_WEBDEPLOY:
				return DoBuildType(TOB_Deploy);
			case ECMD_XBOXIMAGE:
				return DoBuildType(TOB_XboxImage);
			case ECMD_XBOXDEPLOY:
				return DoBuildType(TOB_XboxDeploy);
			default:
				return CVCBaseFolderNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
		}
	}
	else if(*pguidCmdGroup == guidVSStd97)
		return CVCBaseFolderNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); // OLECMDERR_E_NOTSUPPORTED;

	return OLECMDERR_E_NOTSUPPORTED;
}

HRESULT CVCProjectNode::CleanUpUI( CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen /*= TRUE*/ )
{
	if (!m_bStartedClose)
		return OnDelete( pRoot, dwDelItemOp, bCloseIfOpen );
	return S_OK;
}

HRESULT CVCProjectNode::OnDelete( CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen /*= TRUE*/ )
{
	// cause the solution to shut down the project
	CComPtr<IVsSolution> pSolution;

	HRESULT hr = GetBuildPkg()->GetIVsSolution( &pSolution );
	VSASSERT( SUCCEEDED( hr ), "QueryService for solution failed!  Please note that the shell is not thread-safe..." );
	RETURN_ON_FAIL_OR_NULL(hr, pSolution);

	// remove project from solution
	if(dwDelItemOp == DELITEMOP_RemoveFromProject)
	{
		CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(GetHierarchy());
		hr = pSolution->CloseSolutionElement( SLNSAVEOPT_NoSave, spHier, 0 );
		// if closing the solution element failed, it's probably because the
		// project failed to load and hasn't actually been added to their list
		// yet, so try to close our hierarchy explicitly...
		// UNLESS (!!!) it's E_ABORT, in which case SCC may have sent that
		// back from QueryEditQuerySave(), indicating that we cannot dirty the
		// sln file!
		if( FAILED( hr ) && hr != E_ABORT )
			if( spHier )
				hr = spHier->Close();
		return hr;
	}
	// delete from disk
	else
	{
		CComPtr<VCProject> pProject;
		GetArchy()->GetVCProject( static_cast<CVCNode*>(this), &pProject );
		VSASSERT(pProject != NULL, "Hey, we have a NULL project!");
		RETURN_ON_NULL2(pProject, E_NOINTERFACE);
		CComPtr<IDispatch> pDisp;
		pProject->get_Files( &pDisp );
		CComQIPtr<IVCCollection> pColl = pDisp;
		RETURN_ON_NULL2(pColl, E_NOINTERFACE);
		long num_elems; 
		pColl->get_Count( &num_elems );
		// for each file in the project
		for( int i = 1; i <= num_elems; i++ )
		{
			// get the filename
			CComPtr<IDispatch> pDispFile;
			pColl->Item( CComVariant( i ), &pDispFile );
			CComQIPtr<VCFile> pFile = pDispFile;
			VSASSERT( pFile, "Non-file in file collection!" );
			CComBSTR bstrFullPath;
			pFile->get_FullPath( &bstrFullPath );

			// close the file window if it's open
			BOOL fIsOpen;
			CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;	
			hr = ExternalQueryService( SID_SVsUIShellOpenDocument, 
									  IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc );
			VSASSERT( SUCCEEDED( hr ), "Failed to obtain VsUIShellOpenDoc service; either service ID has changed or you're in the wrong thread" );
					
			CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(GetHierarchy());
			CComPtr<IVsWindowFrame> pFrame;
			hr = pVsUIShellOpenDoc->IsDocumentOpen(
					spHier, 
					GetArchy()->ItemIDFromName( static_cast<CVCNode*>(this), bstrFullPath ),
					bstrFullPath,
					GUID_NULL,
					IDO_ActivateIfOpen,
					NULL,
					NULL,
					&pFrame,
					&fIsOpen );
			VSASSERT( SUCCEEDED( hr ), "Failed to determine if the file is open!  Are you in the right thread?" );

			if( fIsOpen )
			{
				// close the file
				hr = pFrame->CloseFrame( FRAMECLOSE_NoSave );
				RETURN_ON_FAIL(hr);
			}

			// do the actual delete
			CString strName;
			strName = bstrFullPath;

			SHFILEOPSTRUCT fop;
			fop.hwnd = NULL;
			fop.wFunc = FO_DELETE;
			fop.pFrom = strName;
			fop.fFlags = FOF_ALLOWUNDO | FOF_NOERRORUI | FOF_NOCONFIRMATION;
			fop.fAnyOperationsAborted = NULL;
			fop.hNameMappings = NULL;;
			fop.lpszProgressTitle = NULL;
			fop.pTo = NULL;

			SHFileOperation( &fop );
		}
		// delete the project file
		CComBSTR bstrProjFile;
		pProject->get_ProjectFile( &bstrProjFile );

		CString strName;
		strName = bstrProjFile;

		SHFILEOPSTRUCT fop;
		fop.hwnd = NULL;
		fop.wFunc = FO_DELETE;
		fop.pFrom = strName;
		fop.fFlags = FOF_ALLOWUNDO | FOF_NOERRORUI | FOF_NOCONFIRMATION;
		fop.fAnyOperationsAborted = FALSE;
		fop.hNameMappings = NULL;
		fop.lpszProgressTitle = NULL;
		fop.pTo = NULL;

		SHFileOperation( &fop );

		// remove project from solution
		CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(GetHierarchy());
		return pSolution->CloseSolutionElement( SLNSAVEOPT_NoSave, spHier, 0 );
	}
}

HRESULT CVCProjectNode::CleanUpBeforeDelete()
{
	// if we've already started closing, then we've already deleted the
	// objects and don't want to do it again
	if( !m_bStartedClose )
	{
		// we're deleting via the engine object model, not UI, so we set this flag
		// to keep us from trying to delete things twice
		m_bStartedClose = true;

		CComPtr<IDispatch> pProjectDisp;
		GetObjectsForDelete(NULL, &pProjectDisp);
		return CleanUpObjectModel(NULL, pProjectDisp);
	}
	else 
		m_bStartedClose = false;

	return S_OK;
}

HRESULT CVCProjectNode::GetObjectsForDelete(IDispatch** ppParent, IDispatch** ppItem)
{
	CHECK_POINTER_NULL(ppItem);

	if (ppParent != NULL)	// for project, don't need to worry about parent...
		*ppParent = NULL;

	if( m_dispkeyItem )
	{
		*ppItem = m_dispkeyItem;
		if (*ppItem)
			(*ppItem)->AddRef();
	}
	return S_OK;
}

HRESULT CVCProjectNode::CleanUpObjectModel(IDispatch* pParent, IDispatch* pProjectDisp)
{
	CHECK_READ_POINTER_NULL(pProjectDisp);

	CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = GetBuildPkg()->GetProjectEngine();
	RETURN_ON_NULL2(spProjEngineImpl, E_UNEXPECTED);
	return spProjEngineImpl->RemoveProjectUnderShell(pProjectDisp);
}

STDMETHODIMP CVCProjectNode::OnSaveProject(LPCOLESTR pszNewName)
{ 
	HRESULT hr;
	CComPtr<VCProject> pProject;
	GetVCProject(&pProject);
	CComQIPtr<IVCProjectImpl> pProjectImpl = pProject;
	RETURN_ON_NULL(pProjectImpl);

	// if we're under SCC
	CComBSTR bstrSccProjectName;
	CComQIPtr<VCProject> pProjectItem = m_dispkeyItem;
	RETURN_ON_NULL(pProjectItem);
	pProjectItem->get_SccProjectName( &bstrSccProjectName );
	if( bstrSccProjectName && bstrSccProjectName.Length() > 0 )
	{
		// ask SCC if we can save the file
		CComPtr<IVsQueryEditQuerySave> pQuerySave;
		hr = ExternalQueryService( SID_SVsQueryEditQuerySave, IID_IVsQueryEditQuerySave, (void**)&pQuerySave );
		if( SUCCEEDED( hr ) && pQuerySave )
		{
			VSQuerySaveResult fSaveResult;
			CComBSTR bstrFullPath;
			pProjectItem->get_ProjectFile( &bstrFullPath );
			hr = pQuerySave->QuerySaveFile( bstrFullPath, VSQEQS_AllowCheckout, NULL, &fSaveResult );
			if( fSaveResult != QSR_SaveOK )
				return E_FAIL;
		}
	}

	// check for NULL - cannot assign NULL to a CComBSTR (it will assert)
	if( !pszNewName )
		hr = pProjectImpl->DoSave( NULL );
	else
		hr = pProjectImpl->DoSave( pszNewName );
	return hr;
}

HRESULT CVCProjectNode::GetActiveConfig(IVCGenericConfiguration** ppGenCfg)
{
	CHECK_POINTER_NULL(ppGenCfg);

	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = GetVsHierarchy(&spHier, TRUE /* main thread */);
	RETURN_ON_FAIL_OR_NULL(hr, spHier);

	CComPtr<IVsSolutionBuildManager> spSolnBldMgr;
	if( GetBuildPkg() == NULL )
		return E_FAIL;
	hr = GetBuildPkg()->GetSolutionBuildManager(&spSolnBldMgr, TRUE);
	RETURN_ON_FAIL_OR_NULL(hr, spSolnBldMgr);

	CComPtr<IVsProjectCfg> spVsProjCfg;
	hr = spSolnBldMgr->FindActiveProjectCfg(NULL, NULL, spHier, &spVsProjCfg);
	CComQIPtr<IVCGenericConfiguration> spGenCfg = spVsProjCfg;
	RETURN_ON_FAIL_OR_NULL(hr, spGenCfg);

	*ppGenCfg = spGenCfg.Detach();
	return S_OK;
}

HRESULT CVCProjectNode::CompileFileItems(CVCPtrList& rlistFiles)
{
	if (rlistFiles.IsEmpty())
		return S_OK;	// nothing to do

	HRESULT hr = S_OK;
	CComPtr<IVCGenericConfiguration> spGenCfg;
	hr = GetActiveConfig(&spGenCfg);
	RETURN_ON_FAIL_OR_NULL(hr, spGenCfg);

	ULONG celt = (ULONG) rlistFiles.GetCount();
	VCFile** rgpVCFile = (VCFile**) ::CoTaskMemAlloc(celt * sizeof(VCFile *));
	memset(rgpVCFile, 0, sizeof(VCFile*)*celt);
	RETURN_ON_NULL2(rgpVCFile, E_OUTOFMEMORY);

	int idx = 0;
	VCPOSITION pos = rlistFiles.GetHeadPosition();
	while (pos != NULL)
	{
		CVCFileNode* pFileNode = (CVCFileNode *)rlistFiles.GetNext(pos);
		CComPtr<VCFile> spFile;
		pFileNode->GetVCFile(&spFile);
		rgpVCFile[idx] = spFile;
		idx++;
	}

	hr = spGenCfg->StartFileBuild(celt, rgpVCFile);
	::CoTaskMemFree(rgpVCFile);

	return hr;
}

BOOL CVCProjectNode::IsProjectFileDirty()
{
	CComPtr<VCProject> pProject;
	GetVCProject(&pProject);
	RETURN_ON_NULL2(pProject, FALSE);

	HRESULT hr;
	VARIANT_BOOL bDirty;
	hr = pProject->get_IsDirty(&bDirty);

	return (bDirty == VARIANT_TRUE);
}

enumEnableStates CVCProjectNode::SupportsBuildType(bldActionTypes buildType)
{
	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = GetActiveConfig(&spGenCfg);
	if (FAILED(hr))
		return eEnableInvisible;

	VARIANT_BOOL bSupported = VARIANT_FALSE;
	VARIANT_BOOL bAvailable = VARIANT_FALSE;

	hr = spGenCfg->SupportsBuildType(buildType, &bSupported, &bAvailable);
	if (FAILED(hr))
		return eEnableInvisible;

	if (bSupported == VARIANT_FALSE)
		return eEnableInvisible;
	else if (bAvailable == VARIANT_FALSE)	// supported, but not available
		return eEnableSupported;

	// now we need to figure out whether we've got a build in progress to determine whether it should be grayed out or active
	hr = spGenCfg->get_NoBuildIsInProgress(NULL);
	if (SUCCEEDED(hr))
		return eEnableSupportedAndEnabled;
	else	// build going, so gray this out
		return eEnableSupported;
}


BOOL CVCProjectNode::InBuild()
{
	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = GetActiveConfig(&spGenCfg);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spGenCfg, TRUE);

	hr = spGenCfg->get_NoBuildIsInProgress(NULL);
	return (FAILED(hr));	// previous call succeeds if no build in progress
}

HRESULT CVCProjectNode::DoBuildType(bldActionTypes buildType)
{
	CComPtr<IVsOutputWindowPane> spOutputWindowPane;
	if (SUCCEEDED(CGenCfg::GetOutputWindowPane(&spOutputWindowPane)) && spOutputWindowPane != NULL)
	{
		if (GetBuildPkg()->NoBuildsInProgress())
			spOutputWindowPane->Clear();
		spOutputWindowPane->Activate();
	}

	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = GetActiveConfig(&spGenCfg);
	RETURN_ON_FAIL_OR_NULL(hr, spGenCfg);

	return spGenCfg->StartAutomationBuild(buildType);
}

HRESULT CVCProjectNode::GetExtObject(CComVariant& varRes)
{
	varRes.vt = VT_EMPTY;
	IDispatch* pAutoProjects = g_pBuildPackage->GetAutoProjects();
	VSASSERT(pAutoProjects != NULL, "No auto projects list!");
	RETURN_ON_NULL(pAutoProjects);

	CComPtr<IDispatch> spDispProject;
	GetDispVCProject(&spDispProject);
	RETURN_ON_NULL(spDispProject);

	CComPtr<CAutoProject> pAutoProject;
	HRESULT hr = CAutoProject::CreateInstance(&pAutoProject, pAutoProjects, NULL, spDispProject);
	RETURN_ON_FAIL(hr);

	varRes.vt = VT_DISPATCH;
	varRes.pdispVal = (IDispatch *)pAutoProject.Detach();

	return S_OK;
}

STDMETHODIMP CVCProjectNode::get_ProjectFile( BSTR *pVal )
{
	CHECK_POINTER_NULL(pVal);
	CComQIPtr<VCProject> pProject = m_dispkeyItem;
	CHECK_ZOMBIE(pProject, IDS_ERR_PROJ_ZOMBIE);
	return pProject->get_ProjectFile( pVal );
}

STDMETHODIMP CVCProjectNode::get_Name( BSTR *pVal )
{
	CHECK_POINTER_NULL(pVal);
	CComQIPtr<VCProject> pProject = m_dispkeyItem;
	CHECK_ZOMBIE(pProject, IDS_ERR_PROJ_ZOMBIE);
	return pProject->get_Name( pVal );
}

STDMETHODIMP CVCProjectNode::put_Name( BSTR Val )
{
	CComQIPtr<VCProject> pProject = m_dispkeyItem;
	CHECK_ZOMBIE(pProject, IDS_ERR_PROJ_ZOMBIE);

	HRESULT hr = pProject->put_Name( Val );
	CFirePropNotifyEvent::FireOnChanged( GetUnknown(), VCPRJNODID_Name );
	return hr;
}

STDMETHODIMP CVCProjectNode::get_ProjectDependencies( BSTR *pVal )
{
	CHECK_POINTER_NULL( pVal );
	CComBSTR bstrDeps( L"" );
	*pVal = bstrDeps.Detach();
	return S_OK;
}

// automation extender methods
STDMETHODIMP CVCProjectNode::get_Extender(BSTR bstrName, IDispatch **ppDisp)
{
	return GetExtender( s_wszCATID, bstrName, ppDisp );
}

STDMETHODIMP CVCProjectNode::get_ExtenderNames(VARIANT *pvarNames)
{
	return GetExtenderNames( s_wszCATID, pvarNames );
}

STDMETHODIMP CVCProjectNode::get_ExtenderCATID(BSTR *pbstrGuid)
{
	CHECK_POINTER_NULL( pbstrGuid );
	CComBSTR bstrRetVal = s_wszCATID;
	*pbstrGuid = bstrRetVal.Detach();
	return S_OK;
}

//-----------------------------------------------------------------------------
// Called on a drop operation. rDataObject contains the dragdrop format from 
// the source. Also passed in is pOurDataSource. This is our datasource if we 
// sourced the drag or clipboard operation. If it is non-null, we can assume that
// the source is us and we can use the information in pOurDataSource to complete
// the move. This is important for web scenarios where we delay render the GetData() so
// that we can ensure local copies of files exist. We don't want to call GetData() in 
// that scenario, since there is no need to get local copies (dirprj handles 
// internal moves and copies).
//-----------------------------------------------------------------------------
class CDropMoveHelper
{
public:
	CDropMoveHelper() : m_rgMovedNodes(NULL) {}
	~CDropMoveHelper() { delete [] m_rgMovedNodes; }

	CVCNode** m_rgMovedNodes;
};

HRESULT CVCProjectNode::OnDropMove(CVCOleDataObject& rDataObject, CVCNode* pDropNode, CVCProjDataSource* pOurDataSource,
	BOOL bCrossVC, BOOL bDrag, BOOL& bReported)
{
	RETURN_ON_NULL2(pDropNode, S_FALSE);

	// check out the project file before adding/removing anything to the project
	if ((bCrossVC || pOurDataSource == NULL) && CanDirtyProject() != S_OK)
		return OLE_E_PROMPTSAVECANCELLED;

	HRESULT hr = S_OK;

	if (bCrossVC)
		return DoCrossVCMoveOrCopy(rDataObject, pDropNode, true /* move */, bDrag, bReported);
	else if (pOurDataSource == NULL)	// We didn't source this thing, do a copy instead
		return OnDropCopy(rDataObject, pDropNode, pOurDataSource, bCrossVC, bDrag, bReported); 

	const CVCNodeArray& rgNodes = pOurDataSource->GetNodeList();
	int numFiles = (int) rgNodes.GetSize();
	if (numFiles == 0)
		return S_OK;

	// first, let's make sure we don't have a single file/folder we're trying to drop back on the same spot
	if (numFiles == 1)
	{
		CVCNode* pNode = rgNodes[0];
		if (pNode->GetParent() == pDropNode)	// this is almost certainly a no-op, treat it like one
			return S_OK;
	}

	// check out the project file before adding/removing anything to the project
	if (CanDirtyProject() != S_OK)
		return OLE_E_PROMPTSAVECANCELLED;

	CDropMoveHelper moveHelper;
	moveHelper.m_rgMovedNodes = new CVCNode*[numFiles];
	RETURN_ON_NULL2(moveHelper.m_rgMovedNodes, E_OUTOFMEMORY);

	int numActualFiles = 0;
	for (int i = 0; i < numFiles; i++)
	{
		CVCNode* pNode = rgNodes[i];

		if(pNode == NULL || pNode->IsZombie())
		{	// Can't find source node.
			CStringW strErr;
			CComBSTR bstrName;
			if (pNode)
				pNode->GetName(&bstrName);
			else
				bstrName = L"";
			CString strTmp = bstrName;
			strErr.Format(IDS_E_MISSINGSOURCENODE, strTmp);
			CComBSTR bstrErr = strErr;
			ReportError(bstrErr, E_FAIL);
			bReported = TRUE;
			return E_FAIL;	// caller must honor bReported and return a success code to VS since VS report error requires 
							// that we not return an error code in this case...
		}

		// This one's OK
		VSASSERT(pNode->GetKindOf() == Type_CVCFile || pNode->GetKindOf() == Type_CVCFileGroup, "Wrong node type in CVCProjectNode::OnDropMove" );
		moveHelper.m_rgMovedNodes[numActualFiles]= pNode;
		// Adjust count of files
		numActualFiles++;
		hr = S_OK;
	}

	if (numActualFiles)
		hr = DoInternalMove(pDropNode, numActualFiles, moveHelper.m_rgMovedNodes, bDrag, bReported);

	return hr;
}

//-----------------------------------------------------------------------------
// Called on a drop operation. rDataObject contains the dragdrop format from 
// the source. Also passed in is pOurDataSource. This is our datasource if we 
// sourced the drag or clipboard operation. If it is non-null, we can assume that
// the source is us and we can use the information in pOurDataSource to complete
// the move. 
//-----------------------------------------------------------------------------
HRESULT CVCProjectNode::OnDropCopy(CVCOleDataObject& rDataObject, CVCNode* pDropNode, CVCProjDataSource* pOurDataSource,
	BOOL bCrossVC, BOOL bDrag, BOOL& bReported)
{
	// Is this internal? ie is pOurDataSource != NULL?
	if (pOurDataSource)
	{
		CComBSTR bstrErr;
		bstrErr.LoadString(IDS_E_COPY_IN_SAME_PROJ);		// don't allow for copy within the same project
		ReportError(bstrErr);
		bReported = TRUE;
		return E_FAIL;	// caller needs to honor bReported and return a success code since VS requires we return a 
						// non-error code if we handled the error
	}

	RETURN_ON_NULL2(pDropNode, S_FALSE);

	// check out the project file before adding/removing anything to the project
	if (CanDirtyProject() != S_OK)
		return OLE_E_PROMPTSAVECANCELLED;

	if (bCrossVC)
		return DoCrossVCMoveOrCopy(rDataObject, pDropNode, false /* not move */, bDrag, bReported);

	return DoNonVCCopy(rDataObject, pDropNode, bDrag, bReported);
}

//-----------------------------------------------------------------------------
// Returns a CString array populated with the files from a PROJREF drop. Note that 
// we can't use the system's DragQueryFile() functions because they will NOT work 
// on win9x with unicode strings. Returns the count of files. The format looks like 
// the following: DROPFILES structure with pFiles member containing the offset to 
// the list of files:
//	 ----------------------------------------------------------------------------
//	|{DROPFILES structure}|ProjRefItem1|0|ProjRefItem2|0|.......|ProjRefItemN|0|0|
//	 ----------------------------------------------------------------------------
//
// If index == -1 it returns everything otherwise it just returns the one file at index (0 based) and
// returns a count of 1. Count of 0 means it couldn't find the one at the index requested.
//-----------------------------------------------------------------------------
int UtilGetFilesFromPROJITEMDrop(HGLOBAL h, CVCStringWArray& rgFiles, int index)
{
	int numFiles = 0;
	DROPFILES* pszDropFiles = reinterpret_cast<DROPFILES*>(::GlobalLock(h));
	ASSERT(pszDropFiles);
	if(pszDropFiles)
	{	// It better be marked unicode
		ASSERT(pszDropFiles->fWide);
		// The first member of the structure contains the offset to the files
		WCHAR* wzBuffer = reinterpret_cast<WCHAR*>(((BYTE*)pszDropFiles) + pszDropFiles->pFiles);
		// We go until *wzBuffer is null since we don't allow empty strings.
		while(*wzBuffer)
		{
			if(index == -1)
			{
				rgFiles.Add(wzBuffer);
				ASSERT(!rgFiles[numFiles].IsEmpty());
				wzBuffer += rgFiles[numFiles].GetLength()+1;
				numFiles++;
			}
			else
			{
				if(index == numFiles)
				{	// Just return the one asked for and return a count of 1.
					rgFiles.Add(wzBuffer);
					return 1;
				}
				numFiles++;

				// Skip to the next one.
				while(*wzBuffer++);
			}
		}
		::GlobalUnlock(h);
	}
	// if we didn't find the one requested 
	if(index != -1)
		numFiles = 0;
	return numFiles;
}

HRESULT CVCProjectNode::BuildProjItemList(COnDropHelper& dropHelper, CVCOleDataObject& rDataObject, BOOL bCrossVC)
{
	CComPtr<IVsSolution> spSolution;
	GetBuildPkg()->GetIVsSolution( &spSolution );
	VSASSERT(spSolution, "Unable to get IVsSolution!" );

	dropHelper.m_hItemDropInfo = (HDROP)rDataObject.GetGlobalData(CVCProjDataSource::s_cfRefProjItems);
	if (dropHelper.m_hItemDropInfo == NULL)
		dropHelper.m_hItemDropInfo = (HDROP)rDataObject.GetGlobalData(CVCProjDataSource::s_cfStgProjItems);
	RETURN_ON_NULL2(dropHelper.m_hItemDropInfo, S_OK);

	// Walk the list of files/folders
	dropHelper.m_numActualFiles = 0;
	CVCStringWArray rgFiles;
	dropHelper.m_numFiles = UtilGetFilesFromPROJITEMDrop(dropHelper.m_hItemDropInfo, rgFiles, -1);
	if (dropHelper.m_numFiles == 0)
		return S_OK;

	// Get the first item to get the source hierarchy.
	CComPtr<IVsHierarchy> spSrcHierarchy;
	VSITEMID itemidLoc;
	CStringW strMoniker;
	strMoniker = rgFiles.GetAt(0);
	HRESULT hrT = spSolution->GetItemOfProjref(strMoniker, &spSrcHierarchy, &itemidLoc, NULL, NULL);
	RETURN_ON_FAIL(hrT);

	// It better NOT have come from us!!
	// and, yes, that GetIVsHierarchy() handles the VCQI_cast
	VSASSERT(spSrcHierarchy && spSrcHierarchy != GetHierarchy()->GetIVsHierarchy(), "Bad hierarchy in CVCProjectNode::BuildProjItemList" );

	dropHelper.m_rgSrcHierarchies = new IVsHierarchy*[dropHelper.m_numFiles];
	RETURN_ON_NULL2(dropHelper.m_rgSrcHierarchies, E_OUTOFMEMORY);
	memset(dropHelper.m_rgSrcHierarchies, 0, dropHelper.m_numFiles*sizeof(IVsHierarchy*));
	dropHelper.m_rgSrcItemIDs = new VSITEMID[dropHelper.m_numFiles];
	RETURN_ON_NULL2(dropHelper.m_rgSrcItemIDs, E_OUTOFMEMORY);
	memset(dropHelper.m_rgSrcItemIDs, 0, dropHelper.m_numFiles*sizeof(VSITEMID));

	for (int i = 0; i < dropHelper.m_numFiles; i++)
	{	// Add each item (file or folder)
		CComPtr<IVsHierarchy> spHier;
		strMoniker = rgFiles.GetAt(i);
		if (FAILED(spSolution->GetItemOfProjref(strMoniker, &spHier, &itemidLoc, NULL, NULL)))
			break;

		if ((spHier == NULL) || (itemidLoc == VSITEMID_NIL))
			continue;

		dropHelper.m_rgSrcItemIDs[dropHelper.m_numActualFiles] = itemidLoc;
		dropHelper.m_rgSrcHierarchies[dropHelper.m_numActualFiles] = spHier.Detach();
		dropHelper.m_numActualFiles++;
	}

	return S_OK;
}

HRESULT CVCProjectNode::DoInternalMove(CVCNode* pTgtNode, DWORD cItems, CVCNode* rgMovedNodes[], BOOL bDrag, BOOL& bReported)
{
	// already checked for ability to dirty project file and that pTgtNode is non-NULL
	CVCWaitCursor waitCur;
	CComQIPtr<IDispatch> spParent = pTgtNode->m_dispkeyItem;

	HRESULT hr = S_FALSE;
	VARIANT_BOOL bOK = VARIANT_TRUE;
	DWORD idx = 0;
	BOOL bAnyMove = FALSE;
	for (idx = 0; idx < cItems && SUCCEEDED(hr) && bOK; idx++)
	{
		CVCNode* pNode = rgMovedNodes[idx];
		CComQIPtr<IDispatch> spItem = pNode->m_dispkeyItem;
		if (spItem == NULL)
			continue;

		CComQIPtr<VCFile> spThisFile = spItem;
		CComQIPtr<VCFilter> spThisFilter = spItem;
		if (spThisFile != NULL)
			hr = spThisFile->CanMove(spParent, &bOK);
		else if (spThisFilter != NULL)
			hr = spThisFilter->CanMove(spParent, &bOK);

		if (hr == S_OK)
			bAnyMove = TRUE;
		else if (FAILED(hr))
			return ReportMoveError(hr, spItem, spParent, bDrag, bReported); // not allowed to move at least one
		else if (!bOK)
			return ReportMoveError(E_FAIL, spItem, spParent, bDrag, bReported); // not allowed to move at least one
	}

	if (!bAnyMove)	// all potential moves are no-ops
	{
		bReported = false;
		for (idx = 0; idx < cItems && !bReported; idx++)
		{
			CVCNode* pNode = rgMovedNodes[idx];
			CComQIPtr<IDispatch> spItem = pNode->m_dispkeyItem;
			if (spItem == NULL)
				continue;

			CComBSTR bstrName;
			CComQIPtr<VCFile> spFile = spItem;
			if (spFile != NULL)
				hr = spFile->get_Name(&bstrName);
			else
			{
				CComQIPtr<VCFilter> spFilter = spItem;
				if (spFilter != NULL)
					spFilter->get_Name(&bstrName);
				else
					continue;
			}

			bReported = true;
			CStringW strErr;
			strErr.Format(IDS_E_SAME_SOURCE_DEST, bstrName);
			CComBSTR bstrErr = strErr;
			ReportError(bstrErr);
		}
		if (bReported)
			return E_FAIL;	// caller needs to know we reported it, but failed
		return S_FALSE;
	}

	bAnyMove = FALSE;
	hr = S_FALSE;
	for (idx = 0; idx < cItems && SUCCEEDED(hr); idx++)
	{
		CVCNode* pNode = rgMovedNodes[idx];
		CComQIPtr<IDispatch> spItem = pNode->m_dispkeyItem;
		if (spItem == NULL)
			continue;

		CComQIPtr<VCFile> spThisFile = spItem;
		CComQIPtr<VCFilter> spThisFilter = spItem;
		if (spThisFile)
			hr = spThisFile->Move(spParent);
		else if (spThisFilter)
			hr = spThisFilter->Move(spParent);
		if (hr == S_OK)
			bAnyMove = TRUE;
		else if (FAILED(hr))
			return ReportMoveError(hr, spItem, spParent, bDrag, bReported);
	}

	if (bAnyMove)
		return S_OK;
	else
		return S_FALSE;
}

/* static */
BOOL CVCProjectNode::VsHandlesError(HRESULT hrReport)
{
	return (hrReport == E_OUTOFMEMORY);
}

HRESULT CVCProjectNode::ReportMoveError(HRESULT hrReport, IDispatch* pItem, IDispatch* pParent, BOOL bDrag, BOOL& bReported)
{
	if (VsHandlesError(hrReport))
		return hrReport;	// let VS handle the error message

	bReported = TRUE;		// anything left, we're reporting here

	long errID;
	int cParams = 1;
	CStringW strParam1;
	CStringW strParam2;
	CStringW strItemName;
	GetIdentifierString(pItem, strItemName);
	switch(hrReport)
	{
	case E_ACCESSDENIED:
		errID = IDS_E_READ_ONLY_PROJ_FILE;
		GetProjectNameString(pParent, strParam1);
		break;

	case VCPROJ_E_BAD_PATH:
		errID = IDS_BAD_PATH_PARENT;
		strParam1 = strItemName;
		break;

	case VCPROJ_E_BAD_PARENT:
		errID = bDrag ? IDS_BAD_DROP_PARENT : IDS_BAD_PASTE_PARENT;
		strParam1 = strItemName;
		GetIdentifierString(pParent, strParam2);
		cParams = 2;
		break;

	case VCPROJ_E_FILTER_EXISTS:
		errID = IDS_FILTER_EXISTS;
		strParam1 = strItemName;
		GetIdentifierString(pParent, strParam2);
		cParams = 2;
		break;

	// case VCPROJ_E_NULL_PATH:		// not likely case since we'd better not have a NULL ID parent in the hierarchy!
	// case E_UNEXPECTED:
	// case VCPROJ_E_DIFF_PROJ:		// not likely as we've already ascertained that we're dropping on the same project!
	default:
		errID = bDrag ? IDS_ERR_DROP : IDS_ERR_PASTE;
		strParam1 = strItemName;
		GetIdentifierString(pParent, strParam2);
		cParams = 2;
		break;
	}

	CStringW strErr;
	if (cParams == 1)
		strErr.Format(errID, strParam1);
	else
	{
		VSASSERT(cParams == 2, "Hey, wrong number of params to format!");
		strErr.Format(errID, strParam1, strParam2);
	}

	CComBSTR bstrErr = strErr;
	ReportError(bstrErr, hrReport);
	return hrReport;	// caller must honor bReported later and return a success code; VS requires that we return a 
						// non-error code if we handled the error
}

HRESULT CVCProjectNode::ReportVCCopyError(HRESULT hrReport, VCProject* pProjectParent, VCFilter* pFilterParent, 
	IDispatch* pItem, bool bIsMove, BOOL bDrag, BOOL& bReported)
{
	if (VsHandlesError(hrReport))
		return hrReport;	// let VS handle the error message

	CComPtr<IDispatch> spParent = pProjectParent;
	if (spParent == NULL)
		spParent = pFilterParent;
	if (bIsMove)
		return ReportMoveError(hrReport, pItem, spParent, bDrag, bReported);
	
	CStringW strItemName;
	GetIdentifierString(pItem, strItemName);
	CStringW strParentName;
	GetIdentifierString(spParent, strParentName);
	return ReportCopyError(hrReport, spParent, strItemName, strParentName, bDrag, bReported);
}

/* static */
HRESULT CVCProjectNode::ReportCopyError(HRESULT hrReport, IDispatch* pParent, CStringW& strItemName, CStringW& strParentName, 
	BOOL bDrag, BOOL& bReported)
{
	if (VsHandlesError(hrReport))
		return hrReport;	// let VS handle the error message

	bReported = TRUE;	// let caller know we handled the error reporting

	long nErrID;
	CStringW strParam1, strParam2;
	int cParams = 1;
	switch (hrReport)
	{
	case E_INVALIDARG:
		nErrID = IDS_E_INVALID_NAME;
		strParam1 = strItemName;
		break;

	case VCPROJ_E_ZOMBIE:
		nErrID = IDS_E_ZOMBIE;
		strParam1 = strParentName;
		break;

	case E_ACCESSDENIED:
		nErrID = IDS_E_READ_ONLY_PROJ_FILE;
		GetProjectNameString(pParent, strParam1);
		break;

	case VCPROJ_E_FILE_EXISTS:
		nErrID = IDS_E_FILE_ALREADY_EXISTS;
		strParam1 = strItemName;
		GetProjectNameString(pParent, strParam2);
		cParams = 2;
		break;

	case VCPROJ_E_FILTER_EXISTS:
		nErrID = IDS_FILTER_EXISTS;
		strParam1 = strItemName;
		strParam2 = strParentName;
		cParams = 2;
		break;

	default:
//	case E_UNEXPECTED:
//	case E_OUTOFMEMORY:
		nErrID = bDrag ? IDS_ERR_DROP : IDS_ERR_PASTE;
		strParam1 = strItemName;
		strParam2 = strParentName;
		cParams = 2;
		break;
	}

	CStringW strErr;
	if (cParams == 1)
		strErr.Format(nErrID, strParam1);
	else
	{
		VSASSERT(cParams == 2, "Hey, wrong number of params to format!");
		strErr.Format(nErrID, strParam1, strParam2);
	}

	CComBSTR bstrErr = strErr;
	ReportError(bstrErr, hrReport);
	return hrReport;	// caller must honor bReported later and return a success code; VS requires that we return a 
						// non-error code if we handled the error
}

HRESULT CVCProjectNode::ReportRemoveError(HRESULT hrReport, IDispatch* pItem, BOOL& bReported)
{
	if (VsHandlesError(hrReport))
		return hrReport;	// let VS handle the error message

	bReported = TRUE;	// we're handling the error message

	CComQIPtr<VCFile> spFile = pItem;
	CComQIPtr<VCFilter> spFilter = pItem;
	CComPtr<IDispatch> spParent;
	if (spFile)
		spFile->get_Parent(&spParent);
	else if (spFilter)
		spFilter->get_Parent(&spParent);

	CStringW strItemName, strParentName;
	GetIdentifierString(pItem, strItemName);
	GetIdentifierString(spParent, strParentName);

	long errID;
	int cParams = 2;
	CStringW strParam1, strParam2;

	switch (hrReport)
	{
	case VCPROJ_E_NOT_FOUND:
		errID = IDS_E_REMOVE_NOT_FOUND;
		strParam1 = strItemName;
		strParam2 = strParentName;
		break;

	case E_ACCESSDENIED:
		errID = IDS_E_READ_ONLY_PROJ_FILE;
		GetProjectNameString(spParent, strParam1);
		cParams = 1;
		break;

	default:
	//case E_UNEXPECTED:
	//case E_NOINTERFACE:
		errID = IDS_E_NO_REMOVE;
		strParam1 = strItemName;
		strParam2 = strParentName;
	}

	CStringW strErr;
	if (cParams == 1)
		strErr.Format(errID, strParam1);
	else
	{
		VSASSERT(cParams == 2, "Hey, wrong number of params to format!");
		strErr.Format(errID, strParam1, strParam2);
	}

	CComBSTR bstrErr = strErr;
	ReportError(bstrErr, hrReport);
	return hrReport;	// caller must honor bReported and return a success code later; VS requires that we return a 
						// non-error code if we handled the error
}

HRESULT CVCProjectNode::ReportVsCopyError(HRESULT hrReport, VCProject* pProjectParent, VCFilter* pFilterParent, 
	IVsHierarchy* pHier, VSITEMID itemID, BOOL bDrag, BOOL& bReported)
{
	if (VsHandlesError(hrReport))
		return hrReport;	// let VS handle the error message

	CComQIPtr<IDispatch> spParent = pProjectParent;
	if (spParent == NULL)
		spParent = pFilterParent;
	CStringW strParentName;
	GetIdentifierString(spParent, strParentName);

	CStringW strItemName;
	if (itemID != VSITEMID_NIL && pHier)
	{
		CComBSTR bstrItemName;
		pHier->GetCanonicalName(itemID, &bstrItemName);
		CStringW str1 = bstrItemName;
		strItemName.Format(IDS_ITEM, str1);
	}
	else
		strItemName.LoadString(IDS_UNKNOWN_ITEM);

	return ReportCopyError(hrReport, spParent, strItemName, strParentName, bDrag, bReported);
}

/* static */ 
HRESULT CVCProjectNode::ReportShellCopyError(HRESULT hrReport, VCProject* pProject, VCFilter* pFilter, LPWSTR wstrFile,
	BOOL& bReported)
{
	if (VsHandlesError(hrReport))
		return hrReport;	// let VS handle the error message

	CComQIPtr<IDispatch> spParent = pProject;
	if (spParent == NULL)
		spParent = pFilter;

	CStringW strParentName;
	GetIdentifierString(spParent, strParentName);

	CStringW strTmp = wstrFile;
	CStringW strItemName;
	strItemName.Format(IDS_FILE, strTmp);

	return ReportCopyError(hrReport, spParent, strItemName, strParentName, TRUE, bReported);
}

/* static */
void CVCProjectNode::GetIdentifierString(IDispatch* pItem, CStringW& strItemString)
{
	CStringW str;
	CComBSTR bstr;

	CComQIPtr<VCFile> spFile = pItem;
	if (spFile)
	{
		spFile->get_FullPath(&bstr);
		str = bstr;
		strItemString.Format(IDS_FILE, str);
		return;
	}

	CComQIPtr<VCFilter> spFilter = pItem;
	if (spFilter)
	{
		spFilter->get_Name(&bstr);
		str = bstr;
		strItemString.Format(IDS_FILTER, str);
		return;
	}

	CComQIPtr<VCProject> spProject = pItem;
	if (spProject)
	{
		spProject->get_Name(&bstr);
		str = bstr;
		strItemString.Format(IDS_PROJECT, str);
		return;
	}

	strItemString.LoadString(IDS_UNKNOWN_ITEM);
}

/* static */
void CVCProjectNode::GetProjectNameString(IDispatch* pItem, CStringW& strProj)
{
	CComQIPtr<VCProject> spProject = pItem;
	CComBSTR bstr;
	if (spProject)
	{
		spProject->get_Name(&bstr);
		strProj = bstr;
		return;
	}

	CComPtr<IDispatch> spDispProject;
	CComQIPtr<VCProjectItem> spProjItem = pItem;
	if (spProjItem)
		spProjItem->get_Project(&spDispProject);
	spProject = spDispProject;
	if (spProject)
		spProject->get_Name(&bstr);
	strProj = bstr;
}

BOOL CVCProjectNode::MatchesHierarchy(IVsHierarchy* pIVsHierarchy)
{
	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = GetVsHierarchy(&spHier, TRUE);
	RETURN_ON_FAIL2(hr, FALSE);

	return (pIVsHierarchy == spHier);
}

void CVCProjectNode::GetVsItemNameAndType(IVsHierarchy* pHier, VSITEMID itemID, BSTR* pbstrName, BOOL& bIsFile, BOOL& bIsFilter)
{
	*pbstrName = NULL;	// BETTER be valid pointer since this is internal...
	bIsFile = FALSE;
	bIsFilter = FALSE;
	if (pHier == NULL || itemID == VSITEMID_NIL)
		return;

	if (FAILED(pHier->GetCanonicalName(itemID, pbstrName)))
		return;

	GUID guid;
	if (FAILED(pHier->GetGuidProperty(itemID, VSHPROPID_TypeGuid, &guid)))	// if this fails, probably Misc Files project
	{
		bIsFile = TRUE;
		bIsFilter = FALSE;
		return;
	}

	bIsFile = IsEqualGUID(guid, GUID_ItemType_PhysicalFile);
	bIsFilter = (IsEqualGUID(guid, GUID_ItemType_PhysicalFolder) || IsEqualGUID(guid, GUID_ItemType_VirtualFolder));
}

HRESULT CVCProjectNode::CanCopyVsElement(VCProject* pProjectParent, VCFilter* pFilterParent, IVsHierarchy* pHier, VSITEMID itemID, 
	bool bIsTopLevel, BOOL bDrag, BOOL& bReported)
{
	CComBSTR bstrName;
	BOOL bIsFile = FALSE;
	BOOL bIsFilter = FALSE;
	GetVsItemNameAndType(pHier, itemID, &bstrName, bIsFile, bIsFilter);
	if (!bIsFile && !bIsFilter)
		return S_FALSE; // neither filter nor file, so ignore it

	HRESULT hr = S_FALSE;

	CComQIPtr<IVCProjectImpl> spProjectParentImpl = pProjectParent;
	CComQIPtr<IVCFilterImpl> spFilterParentImpl = pFilterParent;
	if (bIsFile)
	{
		if (spProjectParentImpl)
			hr = spProjectParentImpl->CanAddFile2(bstrName);
		else if (spFilterParentImpl)
			hr = spFilterParentImpl->CanAddFile2(bstrName);
		else
			hr = E_FAIL;
		if (FAILED(hr))
			return ReportVsCopyError(hr, pProjectParent, pFilterParent, pHier, itemID, bDrag, bReported);
	}

	if (bIsTopLevel)	// only doing this for top level filter being copied
	{
		if (spProjectParentImpl)
			hr = spProjectParentImpl->CanAddFilter2(bstrName, VARIANT_FALSE /* no errorinfo */);
		else if (spFilterParentImpl)
			hr = spFilterParentImpl->CanAddFilter2(bstrName, VARIANT_FALSE /* no errorinfo */);
		else
			hr = E_FAIL;

		if (FAILED(hr))
			return ReportVsCopyError(hr, pProjectParent, pFilterParent, pHier, itemID, bDrag, bReported);
	}
	else
		hr = S_OK;

	// may have contents
	CComVariant varFirstChild;
	hr = pHier->GetProperty(itemID, VSHPROPID_FirstChild, &varFirstChild);
	VSASSERT(varFirstChild.vt == VT_I4 || varFirstChild.vt == VT_UI4, "Unexpected variant type");
	VSITEMID itemidChild = varFirstChild.lVal;
	while (itemidChild != 0 && itemidChild != VSITEMID_NIL && SUCCEEDED(hr))
	{
		hr = CanCopyVsElement(pProjectParent, pFilterParent, pHier, itemidChild, false, bDrag, bReported);
		if (SUCCEEDED(hr))
		{
			CComVariant varChild;
			hr = pHier->GetProperty(itemidChild, VSHPROPID_NextSibling, &varChild);
			VSASSERT(varChild.vt == VT_I4 || varChild.vt == VT_UI4, "Unexpected variant type");
			itemidChild = varChild.lVal;
		}
	}

	return hr;
}

HRESULT CVCProjectNode::AddVsElement(VCProject* pProjectParent, VCFilter* pFilterParent, IVsHierarchy* pHier, VSITEMID itemID,
	BOOL bDrag, BOOL& bReported)
{
	CComBSTR bstrName;
	BOOL bIsFile = FALSE;
	BOOL bIsFilter = FALSE;
	GetVsItemNameAndType(pHier, itemID, &bstrName, bIsFile, bIsFilter);
	if (!bIsFile && !bIsFilter)
		return S_FALSE; // neither filter nor file, so ignore it

	HRESULT hr = S_FALSE;

	CComPtr<IDispatch> spOut;

	if (bIsFile)
	{
		if (pProjectParent)
			hr = pProjectParent->AddFile(bstrName, &spOut);
		else
			hr = pFilterParent->AddFile(bstrName, &spOut);
		if (FAILED(hr))
			return ReportVsCopyError(hr, pProjectParent, pFilterParent, pHier, itemID, bDrag, bReported);
		return hr;
	}

	// pick off the last directory name if what we have is a full path
	CPathW pathFilter;
	CStringW strName = bstrName;
	int nLastFwdSlash = strName.ReverseFind(L'/');
	int nLastBackSlash = strName.ReverseFind(L'\\');
	int nLen = strName.GetLength();
	if (nLastFwdSlash == nLen-1 || nLastBackSlash == nLen-1)
	{
		strName = strName.Left(nLen-1);		// kill any trailing slash
		nLen--;
	}
	if (pathFilter.Create(strName))
	{
		pathFilter.GetActualCase(TRUE);	// need to make it proper case per file system
		strName = pathFilter;
		nLen = strName.GetLength(); // length can change due to beautification
	}
	nLastFwdSlash = strName.ReverseFind(L'/');
	nLastBackSlash = strName.ReverseFind(L'\\');
	int nLastSlash = -1;
	if (nLastFwdSlash > nLastBackSlash)
		nLastSlash = nLastFwdSlash;
	else if (nLastBackSlash > nLastFwdSlash)
		nLastSlash = nLastBackSlash;
	if (nLastSlash >= 0)
		strName = strName.Right(nLen-nLastSlash-1);
	bstrName = strName;

	if (pProjectParent)
		hr = pProjectParent->AddFilter(bstrName, &spOut);
	else
		hr = pFilterParent->AddFilter(bstrName, &spOut);
	if (FAILED(hr))
		return ReportVsCopyError(hr, pProjectParent, pFilterParent, pHier, itemID, bDrag, bReported);

	CComQIPtr<VCFilter> spNewFilterParent = spOut;
	RETURN_ON_NULL2(spNewFilterParent, E_UNEXPECTED);

		// may have contents
	CComVariant varFirstChild;
	hr = pHier->GetProperty(itemID, VSHPROPID_FirstChild, &varFirstChild);
	VSASSERT(varFirstChild.vt == VT_I4 || varFirstChild.vt == VT_UI4, "Unexpected variant type");
	VSITEMID itemidChild = varFirstChild.lVal;
	while (itemidChild != 0 && itemidChild != VSITEMID_NIL && SUCCEEDED(hr))
	{
		hr = AddVsElement(NULL, spNewFilterParent, pHier, itemidChild, bDrag, bReported);
		if (SUCCEEDED(hr))
		{
			CComVariant varChild;
			hr = pHier->GetProperty(itemidChild, VSHPROPID_NextSibling, &varChild);
			VSASSERT(varChild.vt == VT_I4 || varChild.vt == VT_UI4, "Unexpected variant type");
			itemidChild = varChild.lVal;
		}
	}

	return hr;
}

HRESULT CVCProjectNode::DoNonVCCopy(CVCOleDataObject& rDataObject, CVCNode* pTgtNode, BOOL bDrag, BOOL& bReported)
{
	// already checked for ability to dirty project file and that pTgtNode is non-NULL
	COnDropHelper dropHelper;
	HRESULT hr = BuildProjItemList(dropHelper, rDataObject, FALSE);
	RETURN_ON_FAIL_OR_NULL2(hr, dropHelper.m_numActualFiles, S_FALSE);

	CComQIPtr<IDispatch> spParent = pTgtNode->m_dispkeyItem;
	CComQIPtr<VCProject> spProjectParent = spParent;
	CComQIPtr<VCFilter> spFilterParent = spParent;
	if (spProjectParent == NULL && spFilterParent == NULL)
		return E_UNEXPECTED;

	int idx = 0;
	bool bAnyMove = false;
	for (idx = 0; idx < dropHelper.m_numActualFiles && SUCCEEDED(hr); idx++)
	{
		IVsHierarchy* pHier = dropHelper.m_rgSrcHierarchies[idx];
		VSITEMID itemID = dropHelper.m_rgSrcItemIDs[idx];
		hr = CanCopyVsElement(spProjectParent, spFilterParent, pHier, itemID, true, bDrag, bReported);
		if (hr == S_OK)
			bAnyMove = true;
	}

	RETURN_ON_FAIL(hr);	// error reported in CanCopyVsElement
	if (!bAnyMove)
		return S_OK;	// nothing to do

	bAnyMove = false;
	for (idx = 0; idx < dropHelper.m_numActualFiles && SUCCEEDED(hr); idx++)
	{
		IVsHierarchy* pHier = dropHelper.m_rgSrcHierarchies[idx];
		VSITEMID itemID = dropHelper.m_rgSrcItemIDs[idx];
		hr = AddVsElement(spProjectParent, spFilterParent, pHier, itemID, bDrag, bReported);
		if (hr == S_OK)
			bAnyMove = true;
	}

	RETURN_ON_FAIL(hr);	// error reported in AddVsElement

	return S_OK;	// override any S_FALSE we might otherwise have seen
}

void CVCProjectNode::GetVCItemFromVsItem(IVsHierarchy* pHier, VSITEMID itemID, IDispatch** ppVCItem)
{
	*ppVCItem = NULL;	// BETTER be valid pointer since this is internal...

	if (pHier == NULL || itemID == VSITEMID_NIL)
		return;

	CComVariant var;
	pHier->GetProperty(itemID, VSHPROPID_ExtObject, &var);
	if (var.vt == VT_EMPTY)
		return;

	CComQIPtr<_ProjectItem> spVsItem = var.pdispVal;
	if (spVsItem == NULL)
		return;

	spVsItem->get_Object(ppVCItem);
}

HRESULT CVCProjectNode::DoCrossVCMoveOrCopy(CVCOleDataObject& rDataObject, CVCNode* pTgtNode, bool bIsMove, BOOL bDrag, 
	BOOL& bReported)
{
	// already checked for ability to dirty project file and that pTgtNode is non-NULL
	CVCWaitCursor waitCur;

	COnDropHelper dropHelper;
	HRESULT hr = BuildProjItemList(dropHelper, rDataObject, TRUE);
	RETURN_ON_FAIL_OR_NULL2(hr, dropHelper.m_numActualFiles, S_FALSE);

	CComQIPtr<IDispatch> spParent = pTgtNode->m_dispkeyItem;
	CComQIPtr<VCProject> spProjectParent = spParent;
	CComQIPtr<VCFilter> spFilterParent = spParent;
	if (spProjectParent == NULL && spFilterParent == NULL)
		return E_UNEXPECTED;

	int idx = 0;
	// don't check to see if we are allowed to move/copy here, the AddElement will
	// do the check itself
	for (idx = 0; idx < dropHelper.m_numActualFiles && SUCCEEDED(hr); idx++)
	{
		IVsHierarchy* pHier = dropHelper.m_rgSrcHierarchies[idx];
		VSITEMID itemID = dropHelper.m_rgSrcItemIDs[idx];
		CComPtr<IDispatch> spItem;
		GetVCItemFromVsItem(pHier, itemID, &spItem);
		if (spItem == NULL) // ignore any empty elements
			continue;

		hr = AddElement(spProjectParent, spFilterParent, spItem, bIsMove, bDrag, bReported);
	}

	// any errors reported in AddElement and/or RemoveElement
	return hr;
}

HRESULT CVCProjectNode::CanMoveOrCopyElement(VCProject* pProjectParent, VCFilter* pFilterParent, IDispatch* pItem, bool bTopLevel, 
	bool bIsMove, BOOL bDrag, BOOL& bReported)
{
	HRESULT hr = E_UNEXPECTED;	// assume neither file or filter

	CComBSTR bstrName;
	CComQIPtr<VCFile> spFile = pItem;
	CComQIPtr<IVCProjectImpl> spProjectParentImpl = pProjectParent;
	CComQIPtr<IVCFilterImpl> spFilterParentImpl = pFilterParent;
	if (spFile)
	{
		spFile->get_FullPath(&bstrName);
		if (spProjectParentImpl)
			hr = spProjectParentImpl->CanAddFile2(bstrName);
		else if (spFilterParentImpl)
			hr = spFilterParentImpl->CanAddFile2(bstrName);
		else
			hr = E_FAIL;

		if (FAILED(hr))
			return ReportVCCopyError(hr, pProjectParent, pFilterParent, pItem, bIsMove, bDrag, bReported);
	}

	CComQIPtr<VCFilter> spFilter = pItem;
	if (spFilter)
	{
		if (bTopLevel)	// only doing this for top level filter being moved
		{
			spFilter->get_Name(&bstrName);
			if (spProjectParentImpl)
				hr = spProjectParentImpl->CanAddFilter2(bstrName, VARIANT_FALSE /* no errorinfo */);
			else if (spFilterParentImpl)
				hr = spFilterParentImpl->CanAddFilter2(bstrName, VARIANT_FALSE /* no errorinfo */);
			else
				hr = E_FAIL;
			if (FAILED(hr))
				return ReportVCCopyError(hr, pProjectParent, pFilterParent, pItem, bIsMove, bDrag, bReported);
		}
		else
			hr = S_OK;

		// may have contents
		CComPtr<IDispatch> spDispFiles;
		spFilter->get_Files(&spDispFiles);
		hr = CanAddElementCollection(pProjectParent, pFilterParent, spDispFiles, bDrag, bReported);
		RETURN_ON_FAIL_OR_NULL(hr, spFilter);
		CComPtr<IDispatch> spDispFilters;
		spFilter->get_Filters(&spDispFilters);
		hr = CanAddElementCollection(pProjectParent, pFilterParent, spDispFilters, bDrag, bReported);
		RETURN_ON_FAIL(hr);
	}

	if (spFilter == NULL && spFile == NULL)
		return ReportVCCopyError(E_UNEXPECTED, pProjectParent, pFilterParent, NULL, bIsMove, bDrag, bReported);

	if (bTopLevel && bIsMove)
	{
		// verify we can do a cut
		CComPtr<IDispatch> spDispProject;
		if (spFile)
			spFile->get_Project(&spDispProject);
		else	// spFilter
			spFilter->get_Project(&spDispProject);
		CComQIPtr<IVCProjectImpl> spOldProjectImpl = spDispProject;
		if (spOldProjectImpl == NULL)
			hr = E_UNEXPECTED;
		else
			hr = spOldProjectImpl->get_CanDirty(NULL);
		if (FAILED(hr))
			return ReportRemoveError(hr, pItem, bReported);
	}

	return hr;
}

HRESULT CVCProjectNode::CanAddElementCollection(VCProject* pProject, VCFilter* pFilter, IDispatch* pItemCollection, BOOL bDrag, 
	BOOL& bReported)
{
	HRESULT hr = S_OK;
	CComQIPtr<IVCCollection> spItems = pItemCollection;
	if (spItems)
	{
		CComPtr<IEnumVARIANT> spEnum;
		spItems->_NewEnum((IUnknown**)&spEnum);
		if (spEnum)
		{
			spEnum->Reset();
			while (SUCCEEDED(hr))
			{
				CComVariant var;
				hr = spEnum->Next(1, &var, NULL);
				if (hr != S_OK)
					break;
				if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
					continue;
				CComQIPtr<IDispatch> spDispItem = var.pdispVal;
				hr = CanMoveOrCopyElement(pProject, pFilter, spDispItem, false, false, bDrag, bReported);
			}
		}
	}

	if (hr == S_FALSE)
		hr = S_OK;
	return hr;
}

HRESULT CVCProjectNode::AddElement(VCProject* pProjectParent, VCFilter* pFilterParent, IDispatch* pItem, bool bIsMove, 
	BOOL bDrag, BOOL& bReported)
{
	HRESULT hr = S_OK;
	CComPtr<IDispatch> spOut;
	CComBSTR bstrName;
	CComQIPtr<VCFile> spFile = pItem;
	if (spFile)
	{
		spFile->get_FullPath(&bstrName);
		if (pProjectParent)
			hr = pProjectParent->AddFile(bstrName, &spOut);
		else
			hr = pFilterParent->AddFile(bstrName, &spOut);
		if (FAILED(hr))
			return ReportVCCopyError(hr, pProjectParent, pFilterParent, pItem, bIsMove, bDrag, bReported);
		return hr;
	}

	CComQIPtr<VCFilter> spFilter = pItem;
	if (spFilter)
	{
		spFilter->get_Name(&bstrName);
		if (pProjectParent)
			hr = pProjectParent->AddFilter(bstrName, &spOut);
		else
			hr = pFilterParent->AddFilter(bstrName, &spOut);
		if (FAILED(hr))
			return ReportVCCopyError(hr, pProjectParent, pFilterParent, pItem, bIsMove, bDrag, bReported);
		CComQIPtr<VCFilter> spNewFilterParent = spOut;
		RETURN_ON_NULL2(spNewFilterParent, E_UNEXPECTED);
		CComPtr<IDispatch> spFiles;
		spFilter->get_Files(&spFiles);
		hr = AddElementCollection(NULL, spNewFilterParent, spFiles, bDrag, bReported);
		RETURN_ON_FAIL(hr);
		CComPtr<IDispatch> spFilters;
		spFilter->get_Filters(&spFilters);
		return AddElementCollection(NULL, spNewFilterParent, spFilters, bDrag, bReported);
	}

	return ReportVCCopyError(E_UNEXPECTED, pProjectParent, pFilterParent, pItem, bIsMove, bDrag, bReported);	// neither file nor filter
}

HRESULT CVCProjectNode::AddElementCollection(VCProject* pProject, VCFilter* pFilter, IDispatch* pItemCollection, BOOL bDrag,
	BOOL& bReported)
{
	HRESULT hr = S_OK;
	CComQIPtr<IVCCollection> spItems = pItemCollection;
	if (spItems)
	{
		CComPtr<IEnumVARIANT> spEnum;
		spItems->_NewEnum((IUnknown**)&spEnum);
		if (spEnum)
		{
			spEnum->Reset();
			while (SUCCEEDED(hr))
			{
				CComVariant var;
				hr = spEnum->Next(1, &var, NULL);
				if (hr != S_OK)
					break;
				CComQIPtr<IDispatch> spDispItem = var.pdispVal;
				if (spDispItem == NULL)		// ignore any empty elements
					continue;
				hr = AddElement(pProject, pFilter, spDispItem, false, bDrag, bReported);
			}
		}
	}

	if (hr == S_FALSE)
		hr = S_OK;
	return hr;
}

//-----------------------------------------------------------------------------
// Execution context class. Allows program to set state about an execution through
// the use of key/value pairs. For example: the delete commaand could set the ctx
// IDYES for it's delete confirmation dialog. So when user checks "apply to all items"
// it won't prompt. The code can get back the ctx (in this case IDYES) and use
// that. The Start/EndSingleOp() method should be used at the start and end of an operation to
// flush out the context. MultiSelect handlers should use the start/end MultiOp 
// funcitons.
// The class provides a generic CANCELLED state since this applies across all items.
//-----------------------------------------------------------------------------
CVCExecutionCtx::CVCExecutionCtx()
  :
	m_bCancelled(FALSE),
	m_dwRef(0)
{
	m_exCtxArray.SetSize(0,5);
}

//----------------------------------------------------------------------------
// Cleans up object
//----------------------------------------------------------------------------
CVCExecutionCtx::~CVCExecutionCtx()
{
	Clear();
}

//----------------------------------------------------------------------------
// Clears all values from the ctx, including the cancelled status. 
//
//----------------------------------------------------------------------------
void CVCExecutionCtx::Clear()
{
	ClearData();
	m_dwRef = 0;
}

//----------------------------------------------------------------------------
// Clears all values from the ctx, including the cancelled status, but not ref count
//
//----------------------------------------------------------------------------
void CVCExecutionCtx::ClearData()
{
	for(int i=0; i< m_exCtxArray.GetSize(); i++)
	{
		CExCtx* pExCtx = m_exCtxArray[i];
		delete pExCtx;
	}
	m_exCtxArray.RemoveAll();
	m_bCancelled = FALSE;
}

//----------------------------------------------------------------------------
// Called to start an operation
//----------------------------------------------------------------------------
void CVCExecutionCtx::StartOp()
{
	if(m_dwRef == 0)
		Clear();
	++m_dwRef;
}
//----------------------------------------------------------------------------
// Called at end operation
//----------------------------------------------------------------------------
void CVCExecutionCtx::EndOp()
{
	--m_dwRef;
	VSASSERT(((int)m_dwRef) >= 0, "Bad refcount in CVCExecutionCtx::EndOp" );
	if(((int)m_dwRef) < 0)
		m_dwRef = 0;
	if(m_dwRef == 0)
		Clear();
}

//----------------------------------------------------------------------------
// Returns the value at key, or 0 if not found.
//----------------------------------------------------------------------------
DWORD CVCExecutionCtx::GetValue(DWORD key)
{
	CExCtx* pExCtx = GetExCtx(key);
	if(!pExCtx)
		return 0;
	return pExCtx->value;

}

//----------------------------------------------------------------------------
// Sets the value at key. If a value already exists, it is replaced.
//----------------------------------------------------------------------------
void CVCExecutionCtx::SetValue(DWORD key, DWORD value)
{
	CExCtx* pExCtx = GetExCtx(key);
	if(!pExCtx)
	{
		if(value)
		{
			pExCtx = new CExCtx;
			if( pExCtx )
			{
				pExCtx->key = key;
				m_exCtxArray.Add(pExCtx);
			}
		}
	}
	else
	{	// Setting a value to 0 effectively clears it.
		pExCtx->value = value;
	}

}

//----------------------------------------------------------------------------
// Searchs and returns the CExCtx structure for key.
//----------------------------------------------------------------------------
CVCExecutionCtx::CExCtx* CVCExecutionCtx::GetExCtx(DWORD key)
{
	for(int i=0; i< m_exCtxArray.GetSize(); i++)
	{
		CExCtx* pExCtx = m_exCtxArray[i];
		if(pExCtx->key == key)
			return pExCtx;
	}
	// Not found
	return NULL;
}

COnDropHelper::COnDropHelper() : m_hItemDropInfo(NULL), m_numFiles(0), m_rgSrcItemIDs(NULL), m_rgSrcHierarchies(NULL),
	m_numActualFiles(0) 
{}

COnDropHelper::~COnDropHelper()
{	// Free everything
	if (m_hItemDropInfo)
		::GlobalFree(m_hItemDropInfo);
	if (m_rgSrcHierarchies)
	{
		for (int idx = 0; idx < m_numFiles; idx++)
		{
			IVsHierarchy* pHier = m_rgSrcHierarchies[idx];
			if (pHier)
				pHier->Release();
		}
		delete [] m_rgSrcHierarchies;
	}
	if (m_rgSrcItemIDs)
		delete [] m_rgSrcItemIDs;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\projbuildevents.cpp ===
#include "stdafx.h"
#include "bldpkg.h"
#include "projbuildevents.h"
#include "vcarchy.h"
#include "vcfile.h"
#include "vcfgrp.h"
#include "vsqryed.h"

#include "prjids.h"

#ifdef AARDVARK
#include "StyleHierarchy.h"
#endif	// AARDVARK

//t-samhar: declared in gencfg.cpp, use this
//to determine if its safe to do UI work
extern BOOL FIsIDEInteractive();

CVCProjBuildEvents::CVCProjBuildEvents()
{

}

CVCProjBuildEvents::~CVCProjBuildEvents()
{

}


HRESULT CVCProjBuildEvents::CreateInstance(IVCProjectEngineEvents** ppOutput)
{
	HRESULT hr;
	CVCProjBuildEvents *pVar;
	CComObject<CVCProjBuildEvents> *pObj;
	hr = CComObject<CVCProjBuildEvents>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppOutput = reinterpret_cast<IVCProjectEngineEvents *>(pVar);
	}
	return(hr);
}

// recursive helper function to find a particular folder, returns NULL if it can't find
CVCFileGroup* FindFolderInHierarchy( IDispatch* pItem, CVCNode *pNode, CVCNode *pTailNode )
{
	while( pNode )
	{
		// check for folder
		if( pNode->GetKindOf() == Type_CVCFileGroup )
		{
			// if this was the node,
			if( static_cast<CVCFileGroup*>(pNode)->m_dispkeyItem == pItem )
			{
				return static_cast<CVCFileGroup*>(pNode);
			}
			// otherwise check the nodes inside of it
			// TODO: need recursion here
			else
			{
				// next
				CVCNode *pNewNode = reinterpret_cast<CVCNode*>(static_cast<CVCBaseFolderNode*>(pNode)->GetFirstChild());
				if( pNewNode && pNewNode != (CVCNode*)VSITEMID_NIL )
				{
					// new tail 
					CVCNode *pNewTailNode = static_cast<CVCFileGroup*>(pNewNode)->GetTail();
					CVCFileGroup* pFolder = FindFolderInHierarchy( pItem, pNewNode, pNewTailNode );
					if( pFolder )
						return pFolder;
				}
			}
		}
		// was that the last node?
		if( pNode == pTailNode )
			pNode = NULL;

		// otherwise go on
		else
			pNode = pNode->GetNext();
	}
	return NULL;
}

// find the file for a given file config
IDispatch* FindFileForFileConfig( IDispatch *pItem, IDispatch *pDispFiles )
{
	CComPtr<IDispatch> pDisp;
	CComQIPtr<IVCCollection> pFileColl = pDispFiles;
	if( !pFileColl )
		return NULL;
	long lNumFiles;
	pFileColl->get_Count( &lNumFiles );
	for( long i = 1; i <= lNumFiles; i++ )
	{
		CComPtr<IDispatch> pDispFile;
		pFileColl->Item( CComVariant( i ), &pDispFile );
		CComQIPtr<VCFile> pFile = pDispFile;
		if( pFile )
		{
			// get each file config for this file
			pDisp = NULL;
			pFile->get_FileConfigurations( &pDisp );
			CComQIPtr<IVCCollection> pCfgColl = pDisp;
			if( !pCfgColl )
				return NULL;
			long lNumCfgs;
			pCfgColl->get_Count( &lNumCfgs );
			for( long j = 1; j <= lNumCfgs; j++ )
			{
				pDisp = NULL;
				pCfgColl->Item( CComVariant( j ), &pDisp );
				CComQIPtr<VCFileConfiguration> pFileCfg = pDisp;
				// compare it to ours
				if( pFileCfg == pItem )
					return pDispFile;
			}
		}
	}
	return NULL;
}

// recursive helper function to find a particular file, returns NULL if it can't find
CVCFileNode* FindFileInHierarchy( IDispatch* pItem, CVCNode *pNode, CVCNode *pTailNode )
{
	while( pNode )
	{
		// check for file node
		if( pNode->GetKindOf() == Type_CVCFile )
		{
			// if this was the node,
			if( static_cast<CVCFileNode*>(pNode)->m_dispkeyItem == pItem )
			{
				return static_cast<CVCFileNode*>(pNode);
			}
		}
		// otherwise, if it's a folder, check the nodes inside of it
		else if( pNode->GetKindOf() == Type_CVCFileGroup )
		{
			// next
			CVCNode *pNewNode = reinterpret_cast<CVCNode*>(static_cast<CVCBaseFolderNode*>(pNode)->GetFirstChild());
			if( pNewNode && pNewNode != (CVCNode*)VSITEMID_NIL )
			{
				// new tail 
				CVCNode *pNewTailNode = static_cast<CVCFileGroup*>(pNewNode)->GetTail();
				CVCFileNode* pFile = FindFileInHierarchy( pItem, pNewNode, pNewTailNode );
				if( pFile )
					return pFile;
			}
		}
		// was that the last node?
		if( pNode == pTailNode )
			pNode = NULL;

		// otherwise go on
		else
			pNode = pNode->GetNext();
	}
	return NULL;
}

// find where to insert a filter or file
void CVCProjBuildEvents::FindNodeForItem(IDispatch* pItem, CVCNode** ppNode)
{
	*ppNode = NULL;
	CComQIPtr<IVCExternalCookie> pExCookie = pItem;
	if (pExCookie == NULL)	// not a whole lot we can do here...
		return;

	void* pCookie;
	pExCookie->get_ExternalCookie(&pCookie);
	*ppNode = (CVCNode*)pCookie;
}

STDMETHODIMP CVCProjBuildEvents::ItemAdded(IDispatch *pItem, IDispatch *pItemParent)
{
	HRESULT hr = S_OK;

	CComQIPtr<IVCExternalCookie> pExCookie = pItem;
 	if (pExCookie)
	{
		// Project
		CComQIPtr<VCProject> pProject = pItem;
		if( pProject )
		{
			CComBSTR bszFilename;
			CComObject<CVCArchy> *pVCArchy;	// created with Ref count 0
			hr = pProject->get_ProjectFile(&bszFilename);
			// if we haven't done so in the "PreCreate", create the archy now.
			if(CVCProjectFactory::s_EFPolicyCookie == NULL)
			{
				hr = CComObject<CVCArchy>::CreateInstance(&pVCArchy);
				if (SUCCEEDED(hr))
				{
					pVCArchy->AddRef();
				}
				else
				{
					VSASSERT(SUCCEEDED(hr), "Failed to create a hierarchy for a new project!");
					return E_FAIL; 
				}
			}
			else
			{
				// TODO: ASSERT g_EFPolicyCookieStr == bszFilename
				pVCArchy = (CComObject<CVCArchy> *)CVCProjectFactory::s_EFPolicyCookie;
				CVCProjectFactory::s_EFPolicyCookie= NULL;
			}

			pVCArchy->SetSite(GetServiceProvider());
			CVCProjectNode *pProj;
			hr = CVCProjectNode::CreateInstance(&pProj);
			VSASSERT(SUCCEEDED(hr), "Failed to create a project node for a new project");
			hr = pExCookie->put_ExternalCookie((void *)pProj);
			VSASSERT(SUCCEEDED(hr), "Failed in giving the project engine a hint about our hierarchy address");
			pProj->m_dispkeyItem = pItem;
			GetBuildPkg()->InitializeArchy(bszFilename, pProj, pVCArchy);
			
			return S_OK;
		}

#ifdef AARDVARK
		// Style Sheet
		CComQIPtr<VCStyleSheet> pStyleSheet = pItem;
		if (pStyleSheet)
		{
			CComBSTR bstrFilename;
			CStyleSheetHierarchy* pStyleSheetHierarchy;
			hr = pStyleSheet->get_StyleSheetFile(&bstrFilename);
			RETURN_ON_FAIL(hr);
			hr = CStyleSheetHierarchy::CreateInstance(&pStyleSheetHierarchy, bstrFilename);
			RETURN_ON_FAIL_OR_NULL(hr, pStyleSheetHierarchy);

			pStyleSheetHierarchy->SetSite(GetServiceProvider());
			hr = pExCookie->put_ExternalCookie((void *)pStyleSheetHierarchy);
			VSASSERT(SUCCEEDED(hr), "Failed in giving the style sheet engine a hint about our hierarchy address");
			pStyleSheetHierarchy->m_dispkeyItem = pItem;
			return S_OK;
		}
#endif	// AARDVARK

		// File
		CComQIPtr<VCFile> pFile = pItem;
		if( pFile )
		{
			CVCNode* pParentNode = NULL;
			FindNodeForItem(pItemParent, &pParentNode);
			RETURN_ON_NULL(pParentNode);

			CVCFileNode *pVCFile;
			hr = CVCFileNode::CreateInstance(&pVCFile, pItem);
 			hr = pExCookie->put_ExternalCookie((void *)pVCFile);
			RETURN_ON_FAIL2(hr, S_FALSE);
			CComQIPtr<VCProject> pProjParent = pItemParent;
			if( pProjParent )
			{
				CVCProjectNode* pProjNode = (CVCProjectNode*) pParentNode;
		   		pProjNode->AddTail(pVCFile);
			}
			else
			{
				CComQIPtr<VCFilter> pFiltParent = pItemParent;
				if( pFiltParent )
				{
					CVCFileGroup *pVCFileGroup = (CVCFileGroup*) pParentNode;
					pVCFileGroup->AddTail(pVCFile);
					// if this file shouldn't be under SCC, then we need to exclude it
					VARIANT_BOOL bScc;
					pFiltParent->get_SourceControlFiles( &bScc );
					if( !bScc )
					{
						CComQIPtr<VCProjectItem> pProjItem = pParentNode;
						if( !pProjItem )
							return E_FAIL;
						CComPtr<IDispatch> pDisp;
						hr = pProjItem->get_Project( &pDisp );
						if( FAILED( hr ) )
							return hr;
						CComQIPtr<VCProject> pProj = pDisp;
						if( !pProj )
							return E_FAIL;
						CComBSTR bstrProjFile;
						pProj->get_ProjectFile( &bstrProjFile );
						CComPtr<_DTE> pDTE;
						hr = ExternalQueryService( SID_SDTE, __uuidof(_DTE), (void **)&pDTE );
						if( FAILED( hr ) )
							return hr;
						if( !pDTE )
							return E_FAIL;
						CComPtr<SourceControl> pScc;
						hr = pDTE->get_SourceControl( &pScc );
						if( FAILED( hr ) )
							return hr;
						if( !pScc )
							return E_FAIL;
						CComBSTR bstrFilename;
						pVCFile->get_FullPath( &bstrFilename );
						pScc->ExcludeItem( bstrProjFile, bstrFilename );
					}
				}
			}
			
			// update SCC etc				
			// do NOT TrackProjectDocuments during project load or from
			// command line builds!!
			if( !g_bInProjectLoad )
			{
				CComBSTR bstrFilePath;
				hr = pFile->get_FullPath( &bstrFilePath );

				// Fix up Deployment content ...
				CPathW path;
				path.Create( bstrFilePath );
				CStringW strExt = path.GetExtension();
				if( _wcsicmp( strExt, L".srf" ) == 0 || _wcsicmp( strExt, L".htm" ) == 0 )
				{
					pFile->put_DeploymentContent( VARIANT_TRUE );
				}

				// change the output file if needed to make it unique
				MakeOutputFileUnique(pFile);
			}
			return S_OK;
		}
		// Filter
		CComQIPtr<VCFilter> pFilter = pItem;
		if( pFilter )
		{
			CVCNode* pParentNode = NULL;
			FindNodeForItem(pItemParent, &pParentNode);
			RETURN_ON_NULL(pParentNode);
	
			CVCFileGroup *pVCGroup;
			hr = CVCFileGroup::CreateInstance(&pVCGroup, pItem);
			hr = pExCookie->put_ExternalCookie((void *)pVCGroup);
			if (SUCCEEDED(hr))
			{
				// project
				CComQIPtr<VCProject> pProjParent = pItemParent;
				if( pProjParent )
				{
 					CVCProjectNode* pProjNode = (CVCProjectNode*) pParentNode;
		   		    pProjNode->AddTail(pVCGroup);
					pVCGroup->GetHeadEx();	// don't really care about return since it is known NULL, but need side effects of this call
					return S_OK;
				}
				// filter
				CComQIPtr<VCFilter> pFiltParent = pItemParent;
				if( pFiltParent )
				{
					CVCFileGroup *pVCFileGroup = (CVCFileGroup*) pParentNode;
		   		    pVCFileGroup->AddTail(pVCGroup);
					pVCGroup->GetHeadEx();	// don't really care about return since it is known NULL, but need side effects of this call
					return S_OK;
				}
			}
		}
	}
	// configs don't support externalcookie
	else
	{
		// Config
		CComQIPtr<VCConfiguration> pConfig = pItem;
		if( pConfig )
		{
			CComQIPtr<VCProject> spProject = pItemParent;
			CVCArchy* pArchy = NULL;
			CVCProjectNode* pNode = GetBuildPkg()->GetProjectNode(spProject);
			if (pNode)
				pArchy = pNode->GetArchy();
			if (pArchy == NULL)
			{
				VSASSERT(false, "Failed to find the correct archy to inform!");
				return E_FAIL;
			}

			// get the cfg name
			CComBSTR bstrCfgName;
			hr = pConfig->get_Name( &bstrCfgName );
			RETURN_ON_FAIL(hr);
			// inform about the new cfg
			pArchy->InformConfigurationAdded( bstrCfgName );
			return S_OK;
		}
	}
 	return E_FAIL;
}

void CVCProjBuildEvents::MakeOutputFileUnique(VCFile* pFile)
{
	if (!(GetBuildPkg()->m_fAddNewItem))
		return;		// only do this during Add Item

	CComQIPtr<IVCFileImpl> spFileImpl = pFile;
	if (spFileImpl == NULL)
		return;

	CComPtr<IDispatch> spDispProject;
	pFile->get_Project(&spDispProject);
	CComQIPtr<IVCProjectImpl> spProjectImpl = spDispProject;
	if (spProjectImpl == NULL)
		return;

	spProjectImpl->MakeOutputFileUnique(pFile);
}

HRESULT CVCProjBuildEvents::FindProjectParent(IDispatch* pItem, IDispatch* pItemParent, VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;

	CComQIPtr<VCProject> spProject = pItemParent;
	if (spProject)
	{
		*ppProject = spProject.Detach();
		return S_OK;
	}

	CComPtr<IDispatch> spDispProject;
	CComQIPtr<VCFile> spFile = pItem;
	if (spFile)
	{
		spFile->get_Project(&spDispProject);
		spProject = spDispProject;
		*ppProject = spProject.Detach();
		return S_OK;
	}

	CComQIPtr<VCFilter> spFilter = pItem;
	if (spFilter)
	{
		spFilter->get_Project(&spDispProject);
		spProject = spDispProject;
		*ppProject = spProject.Detach();
		return S_OK;
	}

	CComQIPtr<VCFileConfiguration> pFileCfg = pItem;
	if( pFileCfg )
	{
		CComPtr<IDispatch> pFileDisp;
		pFileCfg->get_File( &pFileDisp );
		CComQIPtr<VCFile> pFile = pFileDisp;
		pFile->get_Project( &spDispProject );
		spProject = spDispProject;
		*ppProject = spProject.Detach();
		return S_OK;
	}

	// OK, no luck with either of those, so try to get the project of the parent
	spFilter = pItemParent;
	if (spFilter)
	{
		spFilter->get_Project(&spDispProject);
		spProject = spDispProject;
		*ppProject = spProject.Detach();
		return S_OK;
	}

	return E_FAIL;
}

HRESULT CVCProjBuildEvents::FindItemInHierarchy(IDispatch* pItem, IDispatch* pItemParent, CVCProjectNode** ppProjNode,
	CVCFileNode** ppFileNode, CVCFileGroup** ppFileGroup)
{
	if (ppProjNode == NULL && ppFileNode == NULL && ppFileGroup == NULL)
		return E_UNEXPECTED;
	if (ppProjNode)
		*ppProjNode = NULL;
	if (ppFileNode)
		*ppFileNode = NULL;
	if (ppFileGroup)
		*ppFileGroup = NULL;

	CComQIPtr<VCFile> spFile = pItem;
	CComQIPtr<VCFilter> spFilter = pItem;
	CComQIPtr<VCProject> spProject = pItem;
	if (spFile == NULL && spFilter == NULL && spProject == NULL)
		return S_FALSE;		// not a whole lot we can do...

	if (spProject)
	{
		CHECK_POINTER_NULL(ppProjNode);	// this had better be available in this case...
		*ppProjNode = GetBuildPkg()->GetProjectNode(spProject);
		return ((*ppProjNode != NULL) ? S_OK : S_FALSE);
	}

	CVCNode *pTailNode, *pHeadNode;
	FindProjectParent(pItem, pItemParent, &spProject);
	CVCProjectNode* pNode = GetBuildPkg()->GetProjectNode(spProject);
	if (pNode)
	{
		pHeadNode = pNode->GetHead();
		pTailNode = pNode->GetTail();
	}
	else
	{
		pHeadNode = pTailNode = NULL;
	}

	if (spFile)
	{
		CHECK_POINTER_NULL(ppFileNode);	// this had better be available in this case...
		*ppFileNode = FindFileInHierarchy(pItem, pHeadNode, pTailNode);
	}
	else
	{
		CHECK_POINTER_NULL(ppFileGroup);
		*ppFileGroup = FindFolderInHierarchy(pItem, pHeadNode, pTailNode);
	}

	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ItemRemoved(IDispatch *pItem, IDispatch *pItemParent)
{
	CComQIPtr<IVCExternalCookie> pExCookie;
	HRESULT hr;

 	pExCookie = pItem;
 	if (pExCookie)
	{
		CVCProjectNode* pProjNode = NULL;
		CVCFileNode* pFileNode = NULL;
		CVCFileGroup* pFileGroup = NULL;
		FindItemInHierarchy(pItem, pItemParent, &pProjNode, &pFileNode, &pFileGroup);
		// file
		if( pFileNode )
		{
			// call CleanUpUI() on the ui file object
			// The second arg is the delete op, and we NEVER delete from disk via the engine
			return pFileNode->CleanUpUI( pFileNode, DELITEMOP_RemoveFromProject );
		}
		// filter
		else if( pFileGroup )
		{
			// call CleanUpUI() on the ui filter object
			// The second arg is the delete op, and we NEVER delete from disk via the engine
 			return pFileGroup->CleanUpUI( pFileGroup, DELITEMOP_RemoveFromProject );
		}
		// project
		if( pProjNode )
		{
			// call CleanUpUI() on the ui project object
			// The second arg is the delete op, and we NEVER delete from disk via the engine
			return pProjNode->CleanUpUI( pProjNode, DELITEMOP_RemoveFromProject );
		}
	}
	// configs don't support externalcookie
	else
	{
		// Config
		CComQIPtr<VCConfiguration> pConfig = pItem;
		if( pConfig )
		{
			// get the cfg name
			CComBSTR bstrCfgName;
			hr = pConfig->get_Name( &bstrCfgName );
			RETURN_ON_FAIL(hr);
			CComQIPtr<VCProject> spProject = pItemParent;
			CVCProjectNode *pProjNode = GetBuildPkg()->GetProjectNode(spProject);
			if( pProjNode && pProjNode->GetArchy())	// inform about the new cfg
				pProjNode->GetArchy()->InformConfigurationRemoved( bstrCfgName );
			return S_OK;
		}
	}
	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ItemRenamed(IDispatch *pItem, IDispatch *pItemParent, BSTR bstrOldName)
{
	// only configs come through this path currently
	// (folders go through PropertyChange, below)
	HRESULT hr;
	CComQIPtr<VCConfiguration> pConfig = pItem;
	if( pConfig )
	{
		// get the cfg name
		CComBSTR bstrCfgName;
		hr = pConfig->get_Name( &bstrCfgName );
		RETURN_ON_FAIL(hr);
		// inform about the new cfg
		CComQIPtr<VCProject> spProject = pItemParent;
		CVCProjectNode* pProjNode = GetBuildPkg()->GetProjectNode(spProject);
		if (pProjNode && pProjNode->GetArchy())
			pProjNode->GetArchy()->InformConfigurationRenamed( bstrCfgName, bstrOldName );
	}
	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ItemMoved(IDispatch *pItem, IDispatch *pNewParent, IDispatch* pOldParent)
{
	CVCProjectNode* pProjNode = NULL;
	CVCFileNode* pFileNode = NULL;
	CVCFileGroup* pFileGroup = NULL;
	CVCNode* pNode = NULL;
	FindItemInHierarchy(pItem, pOldParent, &pProjNode, &pFileNode, &pFileGroup);
	if (pFileNode == NULL && pFileGroup == NULL)	// we're not moving a project, so don't care about pProjNode above
	{
		VSASSERT(FALSE, "Hey, trying to do a move across projects here?!?");
		return ItemAdded(pItem, pNewParent);	// couldn't find spot to remove from...
	}

	pNode = ((pFileNode == NULL) ? static_cast<CVCNode*>(pFileGroup) : static_cast<CVCNode*>(pFileNode));

	CVCNode* pNewParentNode = NULL;
	FindNodeForItem(pNewParent, &pNewParentNode);

	CComQIPtr<VCProject> pProjParent = pNewParent;
	CComQIPtr<VCFilter> pFiltParent = pNewParent;
	if (pProjParent == NULL && pFiltParent == NULL)
		return E_UNEXPECTED;

	pNode->GetHierarchy()->OnItemDeleted(pNode);	// just tell the hierarchy about the remove AND NOBODY ELSE (NOT an interface call)
	static_cast<CVCBaseFolderNode*>(pNode->GetParent())->Remove(pNode);		// pull it out of old location

	if( pProjParent )
	{
		CVCProjectNode* pVCProjNode = (CVCProjectNode*) pNewParentNode;
		pVCProjNode->AddTail(pNode);
	}
	else	// pFiltParent
	{
		CVCFileGroup *pVCFileGroup = (CVCFileGroup*) pNewParentNode;
		pVCFileGroup->AddTail(pNode);
	}
			
	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ItemPropertyChange(IDispatch *pItem, long dispid)
{
	// TODO: handle the properties we care about here
	// which are:
	switch( dispid )
	{
	// project Name
	case VCPROJID_Name:
	{
		// make sure we got a project
		CComQIPtr<VCProject> pProject = pItem;
		RETURN_ON_NULL2(pProject, E_NOINTERFACE);

		// get the project node
		CVCProjectNode* pNode = GetBuildPkg()->GetProjectNode(pProject);
		CHECK_ZOMBIE(pNode, IDS_ERR_PROJ_ZOMBIE);

		// set the caption
		CComBSTR bstrName;
		pProject->get_Name( &bstrName );
		pNode->SetCaption( bstrName );
		return S_OK;
	}
	break;
	// filter Name
	case VCFLTID_Name:
	{
		// make sure we got a filter
		CComQIPtr<VCFilter> pFilter = pItem;
		if( !pFilter )
			return E_NOINTERFACE;

		// find the folder associated with it
		CVCFileGroup* pFolder = NULL;
		FindItemInHierarchy(pItem, NULL, NULL, NULL, &pFolder);
		if( pFolder )
		{
			// set the caption
			CComBSTR bstrName;
			pFilter->get_Name( &bstrName );
			pFolder->SetCaption( bstrName );
			return S_OK;
		}
	}
	break;
	// file RelativePath
	case VCFILEID_RelativePath:
	{
		// make sure we got a file
		CComQIPtr<VCFile> pFile = pItem;
		if( !pFile )
			return E_NOINTERFACE;

		// find the file node associated with it
		CVCFileNode* pFileNode = NULL;
		FindItemInHierarchy(pItem, NULL, NULL, &pFileNode, NULL);
		if( pFileNode )
		{
			// set the caption
			CComBSTR bstrName;
			pFile->get_Name( &bstrName );
			pFileNode->SetCaption( bstrName );
			return S_OK;
		}
	}
	break;
	// file level custom build stuff
	case VCFCSTID_CommandLine:
	case VCFCSTID_Outputs:
	// file fileconfig Tool
	case VCFCFGID_Tool:
	// file ExcludeFromBuild
	case VCFCFGID_ExcludedFromBuild:
	{
		// find the file that has this fileconfig
		CComQIPtr<VCProject> spProject;
		FindProjectParent(pItem, NULL, &spProject);
		RETURN_ON_NULL2(spProject, E_NOINTERFACE);

		CComPtr<IDispatch> pDispFiles;
		spProject->get_Files( &pDispFiles );
		IDispatch *pDispFile = FindFileForFileConfig( pItem, pDispFiles );
		// Find this file in the hierarchy
		CVCNode *pTailNode, *pHeadNode;
		CVCProjectNode* pNode = GetBuildPkg()->GetProjectNode(spProject);
		if (pNode)
		{
			pHeadNode = pNode->GetHead();
			pTailNode = pNode->GetTail();
		}
		else
		{
			pHeadNode = pTailNode = NULL;
		}
		CVCFileNode *pFileNode = FindFileInHierarchy( pDispFile, pHeadNode, pTailNode );
		if( pFileNode && pFileNode->GetHierarchy())
		{
			// update the glyph
			pFileNode->GetHierarchy()->OnPropertyChanged( pFileNode, VSHPROPID_IconIndex, 0 );	// not an interface call...
		}
	}
	break;

	default:
		break;
	}

	return S_OK ;
}

STDMETHODIMP CVCProjBuildEvents::SccEvent( IDispatch* pItem, enumSccEvent event, VARIANT_BOOL *pRet )
{
	CHECK_POINTER_NULL(pRet);
	*pRet = VARIANT_TRUE;	// whatever it is, assume it will be OK to do unless told otherwise...

	// we can bail right off the bat if we're doing a command line build...
	if( !FIsIDEInteractive() )
		return S_OK;

	HRESULT hr;
	CComQIPtr<VCProject> pProject;
	CComPtr<IVsQueryEditQuerySave> pQueryEdit;
	CVCProjectNode* pProjNode;

	switch( event )
	{
	case eProjectInScc:
		pProject = pItem;
		RETURN_INVALID_ON_NULL(pProject);
		pProjNode = GetBuildPkg()->GetProjectNode(pProject);
		if (pProjNode && pProjNode->GetArchy())
			pProjNode->GetArchy()->RegisterSccProject();
		return S_OK;

	case ePreDirtyNotification:
		hr = ExternalQueryService(SID_SVsQueryEditQuerySave, IID_IVsQueryEditQuerySave,(void**)&pQueryEdit);
		if( SUCCEEDED(hr) && pQueryEdit )
		{
			VSQueryEditResult fEditResult;
			pProject = pItem;
			RETURN_INVALID_ON_NULL(pProject);
			CComBSTR bstrFullPath;
			pProject->get_ProjectFile( &bstrFullPath );
			hr = pQueryEdit->QueryEditFiles(QEF_AllowInMemoryEdits, 1,
						&bstrFullPath, NULL, NULL, &fEditResult, NULL);
			if( fEditResult != QER_EditOK )
				*pRet = VARIANT_FALSE;
			else 
				*pRet = VARIANT_TRUE;
		}
		return hr;

	default:
		RETURN_INVALID();
	}

	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ReportError( BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword )
{
	CComPtr<IVsUIShell> pUIShell;
	HRESULT hr = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
	if( SUCCEEDED( hr ) && pUIShell )
		pUIShell->SetErrorInfo( hrReport, bstrErrMsg, 0, bstrHelpKeyword, NULL );
		pUIShell->ReportErrorInfo(hrReport);
	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ProjectBuildStarted( IDispatch *pCfg )
{
	return S_OK;
}

STDMETHODIMP CVCProjBuildEvents::ProjectBuildFinished( IDispatch *pCfg, long warnings, long errors, VARIANT_BOOL bCancelled )
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\projbld.cpp ===
// projbld.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f projbldps.mk in the project directory.

#include "stdafx.h"
#include "utils.h"
#include "localeinfo.h"
#include "bldguid.h"
#include "..\resdll\resource.h"
#include "bldpkg.h"
#include "register.h"
#include <path2.h>

//#include "projbld_i.c"
#ifdef _DEBUG
	#define PBDLLNAME "projbldd.dll"
#else
	#define PBDLLNAME "projbld.dll"
#endif

static LPOLESTR g_wszAlternateRegistryRoot = NULL;
static char g_szAlternateRegistryRoot[_MAX_PATH];
static char *g_pszAlternateRegistryRoot = NULL;

#define COMMANDTABLE_VERSION 1
#define PACKAGE_ID	4

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_BuildPackage, CBuildPackage)
//	OBJECT_ENTRY(CLSID_DebugProjectOpen, CDebugProjectOpen) // TODO: Put this back in
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    return _Module.DllMain(hInstance, dwReason, lpReserved, ObjectMap, &LIBID_VCProjectLibrary); 
} 

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return _Module.DllCanUnloadNow();
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.DllGetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

_ATL_REGMAP_ENTRY g_rm[] = {
	{L"VCDIR", NULL },
	{L"COMMONIDE", NULL },
	{L"REGROOTBEGIN",NULL },
	{L"REGROOTEND", NULL },
	{0,0}
};

wchar_t szProductDir[MAX_PATH+1] = {0};
wchar_t szVsProductDir[MAX_PATH+1] = {0};
CComBSTR bstrRootBegin;
CComBSTR bstrRootEnd;

void SetupMap(void)
{
	if( g_wszAlternateRegistryRoot == NULL )	// Dovii NoProvii
		g_wszAlternateRegistryRoot = L"Software\\Microsoft\\VisualStudio\\7.0";

	WideCharToMultiByte(CP_ACP, 0, g_wszAlternateRegistryRoot, -1, g_szAlternateRegistryRoot, sizeof(g_szAlternateRegistryRoot), NULL, NULL);
	g_pszAlternateRegistryRoot = g_szAlternateRegistryRoot;

	// setup paths in registry
	LONG lRet;
	DWORD nType = REG_SZ;
	DWORD nSize = MAX_PATH;
 	HKEY hSectionKey = NULL;

	// get the VC product directory
	CStringW strKey = g_wszAlternateRegistryRoot;
	strKey += L"\\Setup\\VC";
	lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hSectionKey );
	if( hSectionKey )
		lRet = RegQueryValueExW( hSectionKey, L"ProductDir", NULL, &nType, (LPBYTE)szProductDir, &nSize );
	int len = lstrlenW(szProductDir);
	if( len && szProductDir[len-1] != '\\' )
	{
		szProductDir[len] = '\\';
		szProductDir[len+1] = NULL;
	}
	if( hSectionKey )
    	RegCloseKey( hSectionKey );
	g_rm[0].szData = szProductDir;

	// Get The Vs product Dir
	strKey = g_wszAlternateRegistryRoot;
	strKey += L"\\Setup\\VS";
	lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hSectionKey );
	if( hSectionKey )
		lRet = RegQueryValueExW( hSectionKey, L"ProductDir", NULL, &nType, (LPBYTE)szVsProductDir, &nSize );
	len = lstrlenW(szVsProductDir);
	if( len && szVsProductDir[len-1] != '\\' )
	{
		szVsProductDir[len] = '\\';
		szVsProductDir[len+1] = NULL;
	}
	if( hSectionKey )
    	RegCloseKey( hSectionKey );
	g_rm[1].szData = szVsProductDir;
	
	HRESULT hr = GetRegRootStrings( g_wszAlternateRegistryRoot, &bstrRootBegin, &bstrRootEnd );
	if( SUCCEEDED(hr) )
	{
		g_rm[2].szData = bstrRootBegin.m_str;
		g_rm[3].szData = bstrRootEnd.m_str;
	} else {
		g_rm[2].szKey = NULL;
	}
}

STDAPI DllRegisterServer(void)
{
	SetupMap();
	HRESULT hr = _Module.DllRegisterServer();
	_Module.RegisterTypeLib(_T("\\2"));
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	SetupMap();
	return _Module.UnregisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// VSDllRegisterServer - Adds entries to the system registry

STDAPI VSDllRegisterServer(LPOLESTR wszAlternateRegistryRoot)
{
	g_wszAlternateRegistryRoot = wszAlternateRegistryRoot;
	HRESULT hr= DllRegisterServer();
	g_wszAlternateRegistryRoot = NULL;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// VSDllUnregisterServer - Removes entries from the system registry

STDAPI VSDllUnregisterServer(LPOLESTR wszAlternateRegistryRoot)
{
	g_wszAlternateRegistryRoot = wszAlternateRegistryRoot;
	HRESULT hr= DllUnregisterServer();
	g_wszAlternateRegistryRoot = NULL;
	return hr;
}

extern "C" HRESULT __declspec(dllexport) DLLGetDocumentation( ITypeLib *ptlib, ITypeInfo *ptinfo, LCID lcid, DWORD dwHelpStringContext, BSTR *pbstrHelpString)
{
	CComBSTR bstrHelp;
	bstrHelp.LoadString(dwHelpStringContext);
	*pbstrHelpString = bstrHelp.Detach();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by projbld.rc
//

// TODO: anything with the IDI_TEXT icon should be just as suspect as anything with the IDI_VAGUE icon as a candidate
// for its own icon in V.Next (post V7).  Current major suspects for this include: codfile, ifile, incfile, lstfile, 
// and mapfile.  (4/4/2001)
#define IDI_PROJICON                      1
#define IDR_ASLM                          2
#define IDI_CPP                           3
#define IDI_C                             4
#define IDI_H                             5
#define IDI_VAGUE                         6
#define IDI_BSC                           7
#define IDI_TEXT						  8
#define IDI_SOLUTION					  9		// This is the pre-7.0 .dsw icon!   We register it.  LEAVE IT ALONE.
#define IDI_MAKEFILE                     10
#define IDI_RGSFILE                      11
#define IDI_SRFFILE                      12
#define IDI_CRASHDUMP                    13
#define IDI_EXPFILE						 14
#define IDI_IDBFILE						 15
#define IDI_LIBFILE						 16
#define IDI_ILKFILE						 17
#define IDI_NCBFILE						 18
#define IDI_OBJFILE						 19
#define IDI_PCHFILE						 20
#define IDI_PDBFILE						 21
#define IDI_SBRFILE						 22
#define IDR_BUILDPACKAGE                203
#define IDB_IMAGELIST                   204


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        226
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\projouts.h ===
// ProjOuts.h: Definition of the CProjectOutput class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "rsrc.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CProjectOutput
class CVCArchy;

class CProjectOutput : 
	public IVsOutput,
	public CComObjectRoot
{
public:
	CProjectOutput() : m_pConfig(NULL) {}
	~CProjectOutput();
	void Initialize(VCConfiguration* pConfig, CPathW& path);
	static HRESULT CreateInstance(IVsOutput** ppProjOut, VCConfiguration* pConfig, CPathW& path);

BEGIN_COM_MAP(CProjectOutput)
	COM_INTERFACE_ENTRY(IVsOutput)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CProjectOutput) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

// IVsOutput
public:
	STDMETHOD(get_DisplayName)(/*[out]*/ BSTR *pbstrDisplayName);
	STDMETHOD(get_CanonicalName)(/*[out]*/ BSTR *pbstrCanonicalName);
	STDMETHOD(get_DeploySourceURL)(/*[out]*/ BSTR *pbstrDeploySourceURL);
	STDMETHOD(get_Type)(/*[out]*/ GUID *pguidType);

protected:
	CPathW m_path;
	VCConfiguration* m_pConfig;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\rsrc.h ===
// include both resource files
#include "resource.h"
#include "..\resdll\resource.h"

// the following defines don't have resources attached but are needed for compilation...
#define IDDP_TOOL_INPUTS                16220
#define IDDP_TOOL_OUTPUTS               16221
#define IDDP_TOOL_DEPENDENCIES          16409
#define IDC_OPTN_TREECTL                16410
#define IDS_PROF_BROWSETITLE            16634
#define IDC_DLLS_LIST                   16127
#define IDC_CUSTOM_CMDS                 16217
#define IDC_DIRS_LIST                   16037
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\projouts.cpp ===
// ProjOuts.cpp : Implementation of CProjectOutput

#include "stdafx.h"
#include <vssolutn.h>
#include <path2.h>
#include "ProjOuts.h"

/////////////////////////////////////////////////////////////////////////////
//
CProjectOutput::~CProjectOutput()
{
}

HRESULT CProjectOutput::CreateInstance(IVsOutput** ppProjOut, VCConfiguration* pConfig, CPathW& path)
{
	CComObject<CProjectOutput> *pProjOutObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CProjectOutput>::CreateInstance(&pProjOutObj);
	if (SUCCEEDED(hr))
	{
		((IVsOutput *)pProjOutObj)->AddRef();
		pProjOutObj->Initialize(pConfig, path);
	}
	*ppProjOut = (IVsOutput *)pProjOutObj;
	return hr;

}

void CProjectOutput::Initialize(VCConfiguration* pConfig, CPathW& path)
{
	m_pConfig = pConfig;
	m_path = path;
}

STDMETHODIMP CProjectOutput::get_DisplayName(/*[out]*/ BSTR *pbstrDisplayName)
{
	CHECK_POINTER_NULL(pbstrDisplayName)

	CStringW strName = m_path.GetFileName();
	*pbstrDisplayName = strName.AllocSysString();
	return S_OK;
}

STDMETHODIMP CProjectOutput::get_CanonicalName(/*[out]*/ BSTR *pbstrCanonicalName)
{
	CHECK_POINTER_NULL(pbstrCanonicalName)

	CStringW strName = m_path.GetFullPath();
	*pbstrCanonicalName = strName.AllocSysString();
	return S_OK;
}


// The DeploySourceURL is the web location of the item.  For items in the
// local filesystem, the URL should begin with the eight characters:
// "file:///".  Consumers of outputs may not be able to process URLs of
// other forms, so it's very important for projects that are generating URLs
// for local items to try to use this form of URL as much as possible.
STDMETHODIMP CProjectOutput::get_DeploySourceURL(/*[out]*/ BSTR *pbstrDeploySourceURL)
{
	CHECK_POINTER_NULL(pbstrDeploySourceURL)

	CStringW strUrl = L"file:///";
	strUrl += m_path.GetFullPath();
	*pbstrDeploySourceURL = strUrl.AllocSysString();
	return S_OK;
}


STDMETHODIMP CProjectOutput::get_Type(/*[out]*/ GUID *pguidType)
{
	CHECK_POINTER_NULL(pguidType)

	*pguidType = GUID_NULL;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\projbuildevents.h ===
#pragma once
#include "vcnode.h"
#include "prjnode.h"
#include "vcfile.h"
#include "vcfgrp.h"

/////////////////////////////////////////////////////////////////////////////
// CVCProjBuildEvents
 
class CVCProjBuildEvents : 
	public IDispatchImpl<IVCProjectEngineEvents, &__uuidof(IVCProjectEngineEvents), &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CComObjectRoot
{
// Construction
public:
	CVCProjBuildEvents();   // standard constructor
	~CVCProjBuildEvents();
	static HRESULT CreateInstance(IVCProjectEngineEvents** ppOutput);
BEGIN_COM_MAP(CVCProjBuildEvents)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCProjectEngineEvents)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCProjBuildEvents) 

// IVCProjectEngineEvents
public:
	STDMETHOD(ItemAdded)(IDispatch *pItem, IDispatch *pItemParent);
    STDMETHOD(ItemRemoved)(IDispatch *pItem, IDispatch *pItemParent);
    STDMETHOD(ItemRenamed)(IDispatch *pItem, IDispatch *pItemParent, BSTR bstrOldName);
	STDMETHOD(ItemMoved)(IDispatch* pItem, IDispatch* pNewParent, IDispatch* pOldParent);
    STDMETHOD(ItemPropertyChange)(IDispatch *pItem, long dispid);
	STDMETHOD(SccEvent)(IDispatch *pItem, enumSccEvent event, VARIANT_BOOL *pRet );
	STDMETHOD(ReportError)( BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword );
	STDMETHOD(ProjectBuildStarted)( IDispatch *pCfg );
	STDMETHOD(ProjectBuildFinished)( IDispatch *pCfg, long warnings, long errors, VARIANT_BOOL bCancelled );

// helpers
protected:
	HRESULT FindProjectParent(IDispatch* pItem, IDispatch* pItemParent, VCProject** ppProject);
	void FindNodeForItem(IDispatch* pItem, CVCNode** ppNode);
	HRESULT FindItemInHierarchy(IDispatch* pItem, IDispatch* pItemParent, CVCProjectNode** ppProjNode,
		CVCFileNode** ppFileNode, CVCFileGroup** ppFileGroup);
	void MakeOutputFileUnique(VCFile* pFile);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\StyleHierarchy.cpp ===
//---------------------------------------------------------------------------
// Microsoft Visual C++
//
// Microsoft Confidential
// Copyright 1994 - 2001 Microsoft Corporation. All Rights Reserved.
//
// StyleHierarchy.cpp : Implementation of CIswsApp and DLL registration.
//---------------------------------------------------------------------------

//#include "stdafx.h"
#include "StyleHierarchy.h"
//#include "..\resdll\gpcmd.h"
//#include "VsCoCreate.h"
//#include "context.h"

//#ifdef _DEBUG
//#undef THIS_FILE
//static char THIS_FILE[] = __FILE__;
//#endif

// static
HRESULT CStyleSheetHierarchy::CreateInstance(CStyleSheetHierarchy** ppStyle, LPCOLESTR szFileName)
{
	CHECK_POINTER_NULL(ppStyle);
	*ppStyle = NULL;

	CComObject<CStyleSheetHierarchy> *pStyleObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CStyleSheetHierarchy>::CreateInstance(&pStyleObj);
	RETURN_ON_FAIL_OR_NULL(hr, pStyleObj);
	hr = pStyleObj->Initialize();
	RETURN_ON_FAIL(hr);
	((IVsHierarchy *)pStyleObj)->AddRef();
	
	*ppStyle = pStyleObj;
	return hr;
}

HRESULT CStyleSheetHierarchy::Initialize()
{
	return CStyleSheetConfig::CreateInstance(&m_pConfig, this);
}

//  IVsHierarchy
STDMETHODIMP CStyleSheetHierarchy::SetSite(IServiceProvider *pSP)
{
	m_pServiceProvider = pSP;
	return S_OK;
}

STDMETHODIMP CStyleSheetHierarchy::GetSite(IServiceProvider **ppSP)
{
	CHECK_POINTER_NULL(ppSP);
	return m_pServiceProvider.CopyTo(ppSP);
}

STDMETHODIMP CStyleSheetHierarchy::QueryClose(BOOL *pfCanClose)
{
	CHECK_POINTER_NULL(pfCanClose);
	*pfCanClose = TRUE;
	return S_OK;
}

STDMETHODIMP CStyleSheetHierarchy::GetGuidProperty(VSITEMID itemid, VSHPROPID propid, GUID *pguid)
{
	CHECK_POINTER_NULL(pguid);
	return E_FAIL;
}

STDMETHODIMP CStyleSheetHierarchy::SetGuidProperty( /* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ REFGUID guid)
{
	return E_FAIL;
}

STDMETHODIMP CStyleSheetHierarchy::ParseCanonicalName( /* [in] */ LPCOLESTR pszName, /* [out] */ VSITEMID *pitemid)
{
	CHECK_POINTER_NULL(pitemid);
	return E_NOTIMPL;	// CStyleSheetHierarchy::ParseCanonicalName
}

STDMETHODIMP CStyleSheetHierarchy::GetCanonicalName( /* [in] */ VSITEMID itemid, /* [out] */ BSTR *ppszName)
{
	CHECK_POINTER_NULL(ppszName);
	if(itemid != VSITEMID_ROOT)
		return E_FAIL;

	CComPtr<VCStyleSheet> spStyleSheet;
	GetVCStyleSheet(&spStyleSheet);
	CHECK_ZOMBIE(spStyleSheet, IDS_ERR_STYLESHEET_ZOMBIE);

	return spStyleSheet->get_StyleSheetFile(ppszName);
};

STDMETHODIMP CStyleSheetHierarchy::GetProperty(  VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [out] */ VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);
	switch(propid)
	{
		case VSHPROPID_Caption:
		case VSHPROPID_Name:
		{	
			V_VT(pvar) = VT_BSTR;
			CComBSTR bstrName;
			HRESULT hr = get_Name(&bstrName);
			RETURN_ON_FAIL(hr);
			return bstrName.CopyTo( &V_BSTR(pvar) );
		}
		case VSHPROPID_Expandable:		
		case VSHPROPID_ExpandByDefault:
		{
			V_VT(pvar) = VT_BOOL;
			V_BOOL(pvar) = VARIANT_FALSE;
			return S_OK;
		}
		case VSHPROPID_AltHierarchy:
		{
			V_VT(pvar) = VT_I4;
			V_UI4(pvar) = NULL;
			return E_FAIL;
		}
		case VSHPROPID_SortPriority:
		{
			V_VT(pvar) = VT_BOOL;
			V_UI4(pvar) = VARIANT_FALSE;
			return E_FAIL;
		}
		case VSHPROPID_ShowProjInSolutionPage:
		{
			V_VT(pvar) = VT_BOOL;
			V_BOOL(pvar) = VARIANT_TRUE;
			return S_OK;
		}
		case VSHPROPID_ParentHierarchy:
		{
			pvar->vt = VT_UNKNOWN;
			if( !m_pParentHierarchy )
				return E_FAIL;
			pvar->punkVal = m_pParentHierarchy;
			if (pvar->punkVal)
				pvar->punkVal->AddRef();
			return S_OK;
		}
		case VSHPROPID_ParentHierarchyItemid:
		{
			pvar->vt = VT_INT_PTR;
			if( m_dwParentHierarchyItemID == VSITEMID_NIL )
			{
				V_INT_PTR(pvar) = VSITEMID_ROOT;
				return S_OK;
			}
			V_INT_PTR(pvar) = m_dwParentHierarchyItemID;
			return S_OK;
		}
		case VSHPROPID_Parent:			
		{
			V_VT(pvar) = VT_INT_PTR;
			V_INT_PTR(pvar) = VSITEMID_NIL;
			return S_OK;
		}
		case VSHPROPID_Root:			
		{
			V_VT(pvar) = VT_INT_PTR;			
			V_INT_PTR(pvar) = VSITEMID_ROOT;
			return S_OK;
		}

		case VSHPROPID_BrowseObject:
		case VSHPROPID_ExtObject:
		{
			VariantInit(pvar);
			if(SUCCEEDED(QueryInterface(IID_IDispatch, (void **)&V_DISPATCH(pvar))))
			{
				V_VT(pvar) = VT_DISPATCH;
				return S_OK;
			}
			return E_FAIL;
		}
		case VSHPROPID_ItemDocCookie:
		case VSHPROPID_ImplantHierarchy:
		case VSHPROPID_FirstVisibleChild:
		case VSHPROPID_NextVisibleSibling:
		case VSHPROPID_IsHiddenItem:
		case VSHPROPID_IsNonMemberItem:
		case VSHPROPID_OpenFolderIconIndex:
		case VSHPROPID_SelContainer:
		case VSHPROPID_EditLabel:
			return E_NOTIMPL;	// CStyleSheetHierarchy::GetProperty, several properties that don't need to be impl

		case VSHPROPID_UserContext:
			{
				V_VT(pvar) = VT_UNKNOWN;
				IVsUserContext *pUserCtx = NULL;
				CComPtr<IVsMonitorUserContext> pmuc;
				if (SUCCEEDED(ExternalQueryService(SID_SVsMonitorUserContext,
					IID_IVsMonitorUserContext, (void **)&pmuc)))
				{
					pmuc->CreateEmptyContext(&pUserCtx);
					if(pUserCtx)
					{
						pUserCtx->AddAttribute(VSUC_Usage_Filter, L"PRODUCT", L"VC");
						pUserCtx->AddAttribute(VSUC_Usage_Filter, L"ITEM", L"STYLESHEET");
						V_UNKNOWN(pvar) = pUserCtx;
						return S_OK;
					}
				}
				return E_FAIL;
			}
		case VSHPROPID_IconImgList:		
			V_VT(pvar) = VT_INT_PTR;
			V_INT_PTR(pvar) = reinterpret_cast<INT_PTR>(GetBuildPkg()->m_hImageList);
			return S_OK;
		
		case VSHPROPID_IconIndex:		
			V_VT(pvar) = VT_I4;
			V_I4(pvar) = BMP_PROJNODE;
			return S_OK;
		
		case VSHPROPID_StateIconIndex:
			V_VT(pvar) = VT_I4;
			V_I4(pvar) = STATEICON_NONE;
			return S_OK;
		
		case VSHPROPID_HandlesOwnReload:
		{
			V_VT(pvar) = VT_BOOL;
			V_BOOL(pvar) = VARIANT_TRUE;
			return S_OK;
		}
			
		default:
			break;
	}
	return E_UNEXPECTED;
}

STDMETHODIMP CStyleSheetHierarchy::SetProperty(VSITEMID itemid, VSHPROPID propid, /* [in] */ VARIANT var)
{
	switch( propid )
	{
	case VSHPROPID_ParentHierarchy:
		if( var.vt != VT_UNKNOWN )
			RETURN_INVALID();
		m_pParentHierarchy = var.punkVal;
		return S_OK;

	case VSHPROPID_ParentHierarchyItemid:
		if( var.vt != VT_I4 )
			RETURN_INVALID();
		m_dwParentHierarchyItemID = var.lVal;
		return S_OK;

	default:
		return S_OK;
	}
}


// IVsUIHierarchy
STDMETHODIMP CStyleSheetHierarchy::QueryStatusCommand( VSITEMID itemid, const GUID * pguidCmdGroup,
						ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
	return S_OK;
}

HRESULT CStyleSheetHierarchy::ExecCommand(
			VSITEMID itemid, const GUID * pguidCmdGroup, DWORD nCmdID,
			DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut)
{
	if(*pguidCmdGroup == GUID_VsUIHierarchyWindowCmds)
	{
		HRESULT hr;
		switch(nCmdID)
		{
			case UIHWCMDID_RightClick:
			{
				CComPtr<IOleComponentUIManager> pOleComponentUImanager;
				hr = ExternalQueryService(SID_OleComponentUIManager, __uuidof(IOleComponentUIManager), (void**)&pOleComponentUImanager);
				if (SUCCEEDED(hr) && pOleComponentUImanager)
				{
					CComQIPtr<IOleInPlaceComponentUIManager> pComponentUImanager = pOleComponentUImanager;
					if (pComponentUImanager)
						pComponentUImanager->UpdateUI(0, FALSE, 0);

					POINTS pnts;
					ULONG ulPts = V_UI4(pvaIn);
					memcpy((void*)&pnts, &ulPts, sizeof(POINTS));
					CComPtr<IOleCommandTarget> spTarget = VCQI_cast<IOleCommandTarget>(this);
					hr = pOleComponentUImanager->ShowContextMenu(
						0, 
						guidVCGrpId, 
						IDMX_VC_EXEPROJECT,
						pnts,
						spTarget);
				}

				break;
			}
			case UIHWCMDID_DoubleClick:
				return ShowSettings();

//			case UIHWCMDID_EnterKey:
			default:
				hr = OLECMDERR_E_NOTSUPPORTED;
				break;
		}
		return hr;
	}

	return OLECMDERR_E_UNKNOWNGROUP;
}


HRESULT CStyleSheetHierarchy::ShowSettings()
{
	// for this one command, set the focus to Project Explorer before letting shell actually do what
	// it wants to do
	CComPtr<IOleCommandTarget> srpCmdTgt;
	if (SUCCEEDED(ExternalQueryService( SID_SUIHostCommandDispatcher, IID_IOleCommandTarget, 
		(void**)&srpCmdTgt)) && srpCmdTgt != NULL)
	{
		srpCmdTgt->Exec(&CLSID_StandardCommandSet97, cmdidProjectExplorer, OLECMDEXECOPT_DODEFAULT, 
			NULL, NULL);
	}

	CComPtr<IVsPropertyPageFrame> pPPFrame;
	HRESULT hr = ExternalQueryService(SID_SVsPropertyPageFrame, IID_IVsPropertyPageFrame, (void**)&pPPFrame);
	RETURN_ON_FAIL_OR_NULL(hr, pPPFrame);

	hr = pPPFrame->ShowFrame(CLSID_VCProject);
	if (FAILED(hr))
	{
		pPPFrame->ReportError(hr);
		pPPFrame->HideFrame();
	}

	return hr;
}


STDMETHODIMP CStyleSheetHierarchy::AdviseHierarchyEvents( /* [in] */ IVsHierarchyEvents *pEventSink, /* [out] */ VSCOOKIE *pdwCookie)
{
	CHECK_POINTER_NULL(pdwCookie);
	*pdwCookie = 1;
	return S_OK;
};

// IOleCommandTarget
STDMETHODIMP CStyleSheetHierarchy::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
	return OLECMDERR_E_UNKNOWNGROUP;
}

STDMETHODIMP CStyleSheetHierarchy::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
            VARIANT *pvaIn, VARIANT *pvaOut)
{
	return OLECMDERR_E_UNKNOWNGROUP;
}
			
// IPersist
STDMETHODIMP CStyleSheetHierarchy::GetClassID( CLSID *pClassID)
{
	CHECK_POINTER_NULL(pClassID);
	*pClassID = IID_IStyleSheetHierarchy;
	return S_OK;
}

// IPersistFileFormat
STDMETHODIMP CStyleSheetHierarchy::IsDirty(BOOL *pfIsDirty)
{
	CHECK_POINTER_NULL(pfIsDirty);

	*pfIsDirty = FALSE;
	return S_FALSE;
};


STDMETHODIMP CStyleSheetHierarchy::ReadUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	return S_OK;
}

STDMETHODIMP CStyleSheetHierarchy::WriteUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	return S_OK;
}

STDMETHODIMP CStyleSheetHierarchy::GetCurFile( /* [out] */ LPOLESTR __RPC_FAR *ppszFilename, /* [out] */ DWORD __RPC_FAR *pnFormatIndex)
{
	CHECK_POINTER_NULL(ppszFilename);

	CComBSTR bstrName;
	HRESULT hr = GetCanonicalName(VSITEMID_ROOT, &bstrName);
	RETURN_ON_FAIL_OR_NULL(hr, bstrName);
	DWORD dwLen = (DWORD)(ocslen(bstrName) + sizeof(OLECHAR));

	*ppszFilename = (LPOLESTR)::CoTaskMemAlloc(dwLen * sizeof(OLECHAR));
	if (NULL == *ppszFilename)
		return E_OUTOFMEMORY;

	ocscpy(*ppszFilename, bstrName);
	return S_OK;
};

STDMETHODIMP CStyleSheetHierarchy::get_Name(BSTR FAR* pbstrName)
{
	CComPtr<VCStyleSheet> spStyleSheet;
	GetVCStyleSheet(&spStyleSheet);
	CHECK_ZOMBIE(spStyleSheet, IDS_ERR_STYLESHEET_ZOMBIE);

	return spStyleSheet->get_Name(pbstrName);
}

STDMETHODIMP CStyleSheetHierarchy::put_Name(BSTR bstrName)
{
	CComPtr<VCStyleSheet> spStyleSheet;
	GetVCStyleSheet(&spStyleSheet);
	CHECK_ZOMBIE(spStyleSheet, IDS_ERR_STYLESHEET_ZOMBIE);

	return spStyleSheet->put_Name(bstrName);
}

STDMETHODIMP CStyleSheetHierarchy::Close()
{
	m_pServiceProvider.Release();
	if (m_dispkeyItem)
		m_dispkeyItem.Release();

	return S_OK;
}

// IVsCfgProvider
STDMETHODIMP CStyleSheetHierarchy::GetCfgs(ULONG celt, IVsCfg *rgpcfg[], ULONG *pcActual, VSCFGFLAGS *prgfFlags)
{
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_STYLESHEET_ZOMBIE);

	if (celt == 0)
	{
		CHECK_POINTER_NULL(pcActual);
		*pcActual = 1;
		return S_OK;
	}

	CHECK_POINTER_NULL(rgpcfg);

	if (pcActual)
		*pcActual = 1;

	return m_pConfig->QueryInterface(IID_IVsCfg, (void**)rgpcfg);
}

// IVsProjectCfgProvider
STDMETHODIMP CStyleSheetHierarchy::get_UsesIndependentConfigurations(BOOL *pfUsesIndependentConfigurations )
{
	CHECK_POINTER_NULL(pfUsesIndependentConfigurations);
	*pfUsesIndependentConfigurations = FALSE;
	return S_FALSE;
};

HRESULT CStyleSheetHierarchy::GetVCStyleSheet(VCStyleSheet** ppStyle)
{
	CHECK_POINTER_NULL(ppStyle);
	CComQIPtr<VCStyleSheet> spStyleSheet = m_dispkeyItem;
	*ppStyle = spStyleSheet.Detach();
	CHECK_ZOMBIE(*ppStyle, IDS_ERR_STYLESHEET_ZOMBIE);
	return S_OK;
}

HRESULT CStyleSheetHierarchy::GetVCDispStyleSheet(IDispatch** ppStyle)
{
	RETURN_ON_NULL(ppStyle);
	CComQIPtr<IDispatch> spDispStyleSheet = m_dispkeyItem;
	*ppStyle = spDispStyleSheet.Detach();
	CHECK_ZOMBIE(*ppStyle, IDS_ERR_STYLESHEET_ZOMBIE);
	return S_OK;
}

HRESULT CStyleSheetConfig::CreateInstance(IVsProjectCfg ** ppCfg, CStyleSheetHierarchy* pArchy)
{
	CComObject<CStyleSheetConfig> *pCfg = NULL;  
	HRESULT hr = CComObject<CStyleSheetConfig>::CreateInstance(&pCfg);
	if (SUCCEEDED(hr))
	{
		pCfg->Initialize( pArchy );
		hr = pCfg->QueryInterface(__uuidof(IVsProjectCfg), (void**)ppCfg );
	}
	return hr;
}

HRESULT CStyleSheetConfig::Initialize( CStyleSheetHierarchy* pArchy )
{
	m_pArchy = pArchy;
	return S_OK;
}

	
// IVsCfg
STDMETHODIMP CStyleSheetConfig::get_DisplayName(BSTR *pbstrDisplayName)
{
	CHECK_ZOMBIE(m_pArchy, IDS_ERR_STYLESHEET_ZOMBIE);
	return m_pArchy->get_Name(pbstrDisplayName);
}
	
STDMETHODIMP CStyleSheetConfig::get_IsDebugOnly(BOOL *pfIsDebugOnly )
{
	CHECK_POINTER_NULL(pfIsDebugOnly);

	*pfIsDebugOnly = FALSE;
	return S_OK;
};

STDMETHODIMP CStyleSheetConfig::get_IsReleaseOnly(BOOL *pfIsRetailOnly)
{
	CHECK_POINTER_NULL(pfIsRetailOnly);

	*pfIsRetailOnly = FALSE;
	return S_FALSE;
};

// IVsProjectCfg
STDMETHODIMP CStyleSheetConfig::get_ProjectCfgProvider(/* [out] */ IVsProjectCfgProvider **ppIVsProjectCfgProvider)
{
	CHECK_POINTER_NULL(ppIVsProjectCfgProvider);
	*ppIVsProjectCfgProvider = NULL;

	RETURN_ON_NULL(m_pArchy);

	return m_pArchy->QueryInterface(IID_IVsProjectCfgProvider, (void**)ppIVsProjectCfgProvider );
}

STDMETHODIMP CStyleSheetConfig::get_CanonicalName(/* [out] */ BSTR *pbstrCanonicalName)
{
	CHECK_ZOMBIE(m_pArchy, IDS_ERR_STYLESHEET_ZOMBIE);
	return m_pArchy->GetCanonicalName(VSITEMID_ROOT, pbstrCanonicalName);
}
	
STDMETHODIMP CStyleSheetConfig::get_IsRetailOnly(BOOL *pfIsRetailOnly)
{
	CHECK_POINTER_NULL(pfIsRetailOnly);

	*pfIsRetailOnly = FALSE;
	return S_FALSE;
};

STDMETHODIMP CStyleSheetConfig::get_IsPackaged(BOOL *pfIsPackaged)
{
	CHECK_POINTER_NULL(pfIsPackaged);

	*pfIsPackaged = FALSE;
	return S_FALSE;
};

STDMETHODIMP CStyleSheetConfig::get_IsSpecifyingOutputSupported(BOOL *pfIsSpecifyingOutputSupported)
{
	CHECK_POINTER_NULL(pfIsSpecifyingOutputSupported);

	*pfIsSpecifyingOutputSupported = FALSE;
	return S_FALSE;
};

STDMETHODIMP CStyleSheetConfig::get_TargetCodePage( /* [out] */ UINT *puiTargetCodePage)
{
	CHECK_POINTER_NULL(puiTargetCodePage);

	*puiTargetCodePage = 1200;
	return S_OK;
}

// ISpecifyPropertyPages
STDMETHODIMP CStyleSheetConfig::GetPages(/* [out] */ CAUUID *pPages)
{
	CHECK_POINTER_NULL(pPages);
	CHECK_ZOMBIE(m_pArchy, IDS_ERR_STYLESHEET_ZOMBIE);

	CComPtr<IDispatch> spDispStyleSheet;
	m_pArchy->GetVCDispStyleSheet(&spDispStyleSheet);
	CComQIPtr<ISpecifyPropertyPages> pSPP = spDispStyleSheet;
	CHECK_ZOMBIE(pSPP, IDS_ERR_STYLESHEET_ZOMBIE);
	return pSPP->GetPages( pPages );
}

//---------------------------------------------------------------------------
// interface: IVCCfg
//---------------------------------------------------------------------------
STDMETHODIMP CStyleSheetConfig::get_Tool(/* [in] */ VARIANT toolIndex, /* [out] */ IUnknown **ppTool)
{
	CHECK_POINTER_NULL(ppTool);
	CHECK_ZOMBIE(m_pArchy, IDS_ERR_STYLESHEET_ZOMBIE);

	CComPtr<VCStyleSheet> spStyleSheet;
	m_pArchy->GetVCStyleSheet(&spStyleSheet);
	CHECK_ZOMBIE(spStyleSheet, IDS_ERR_STYLESHEET_ZOMBIE);
	
	CComQIPtr<IVCCollection> spCollection;	//Collection SP
	CComPtr<IDispatch> pDisp;

	HRESULT hr = spStyleSheet->get_Tools(&pDisp);	//Get the tools collection
	spCollection = pDisp;
	
	if (SUCCEEDED(hr) && spCollection)
	{
		CComPtr<IDispatch> spDisp;
		hr = spCollection->Item(toolIndex, &spDisp);	//Get the tool item
		RETURN_ON_FAIL_OR_NULL(hr, spDisp);
		hr = spDisp->QueryInterface(IID_IUnknown, (void **) ppTool);	//Get the tool unk
	}
	
	return hr;
}

STDMETHODIMP CStyleSheetConfig::get_Object( IDispatch **ppStyle)
{
	CHECK_POINTER_NULL(ppStyle);
	CHECK_ZOMBIE(m_pArchy, IDS_ERR_STYLESHEET_ZOMBIE);

	CComPtr<IDispatch> spDispStyle;
	m_pArchy->GetVCDispStyleSheet(&spDispStyle);
	CHECK_ZOMBIE(spDispStyle, IDS_ERR_STYLESHEET_ZOMBIE);
	*ppStyle = spDispStyle.Detach();
	return S_OK;
}

//

STDMETHODIMP CStyleSheetConfig::ReadUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	return S_OK;
}

STDMETHODIMP CStyleSheetConfig::WriteUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__93607FA2_EEBE_11D2_8D27_00C04F8EEA30__INCLUDED_)
#define AFX_STDAFX_H__93607FA2_EEBE_11D2_8D27_00C04F8EEA30__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include "resource.h"
#include "../resdll/resource.h"
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "vsassert.h"
#undef ASSERT
#define ASSERT(x) VSASSERT (x, "vc proj bld")

extern HRESULT DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bSetErrorInfo = TRUE);
extern HRESULT DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bSetErrorInfo = TRUE);
extern HRESULT HandleSetErrorInfo(HRESULT hrErr, LPCOLESTR szErr);

#define CHECK_ZOMBIE(x, err) \
	if( (x) == NULL )\
		return DoSetErrorInfo(VCPROJ_E_ZOMBIE, err);

#define CHECK_POINTER_VALID(x) \
	if( (x) == NULL ){\
		return E_POINTER;} \
	else if (IsBadWritePtr((x), sizeof(*(x)))) {\
		return E_POINTER; }

#define CHECK_POINTER_NULL(pObj) \
	if ((pObj) == NULL) \
		return E_POINTER;

#define CHECK_READ_POINTER_VALID(x) \
	if ( (x) == NULL ){\
		return E_INVALIDARG; } \
	else if (IsBadReadPtr((x), sizeof (*(x)))) {\
		return E_INVALIDARG; }

#define CHECK_READ_POINTER_NULL(x) \
	if ( (x) == NULL ){\
		return E_INVALIDARG; } 

#define RETURN_ON_FAIL_OR_NULL(hr, pObj) \
	if (FAILED(hr)) \
		return hr; \
	else if ((pObj) == NULL) \
		return E_FAIL;

#define RETURN_ON_FAIL_OR_NULL2(hr1, pObj, hr2) \
	if (FAILED(hr1)) \
		return hr1; \
	else if ((pObj) == NULL) \
		return hr2;

#define RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr1, pObj, hr2) \
	if (FAILED(hr1) || (pObj) == NULL) \
		return hr2;

#define RETURN_ON_FAIL(hr) \
	if (FAILED(hr)) \
		return hr;

#define RETURN_ON_FAIL2(hr1, hr2) \
	if (FAILED(hr1)) \
		return hr2;

#define RETURN_ON_NULL(pObj) \
	if ((pObj) == NULL) \
		return E_FAIL;

#define RETURN_ON_NULL2(pObj, hr) \
	if ((pObj) == NULL) \
		return hr;

#define RETURN_INVALID_ON_NULL(pObj) \
	if ((pObj) == NULL) \
	{ \
		/* VSASSERT(FALSE, "Returning E_INVALIDARG!"); */\
		return E_INVALIDARG; \
	}

#define RETURN_INVALID() \
	{ \
		/* VSASSERT(FALSE, "Hey, returning E_INVALIDARG"); */\
		return E_INVALIDARG; \
	}

#define CONTINUE_ON_FAIL_OR_NULL(hr, pObj) \
	if (FAILED(hr)) \
		continue; \
	else if ((pObj) == NULL) \
		continue;

#define CONTINUE_ON_FAIL(hr) \
	if (FAILED(hr)) \
		continue;

#ifndef DROPEFFECT
typedef  DWORD DROPEFFECT;
#endif	// DROPEFFECT

#include <atlstr.h>
#include "vcstring.h"

#include <oleauto.h>

//#undef CVCString
//#define CVCString CStringW

#include "vccolls.h"
#include "vcmap.h"
#include <vcpb2.h>
#include <VCProjectPrivateTypeLib.h>
#include <ProjBld2.h>
#include <ProjBldPrivate.h>

#include <SHLOBJ.H>
// #include "vcpbeng.h"

#include "vsshell.h"
#include "dte.h"

#define NO_MFC	// don't allow certain files to include too much (eg., utilbld.h)

#include "vstypeinfo.h"

#define PublicProjBuildTypeLibNumber 1
#define PrivateProjBuildTypeLibNumber 2

extern HINSTANCE g_hInstLocale; // hinstance of localized resources

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__93607FA2_EEBE_11D2_8D27_00C04F8EEA30__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\StyleHierarchy.h ===
//---------------------------------------------------------------------------
// Microsoft VC++
//
// Microsoft Confidential
// Copyright 1994 - 2001 Microsoft Corporation. All Rights Reserved.
//
// CStyleSheetHierarchy.h: Definition of the CStyleSheetHierarchy class
//
// A separate interface object to CVC
//---------------------------------------------------------------------------

#pragma once

#include "vssolutn.h"
#include "bldpkg.h"
#include "fpstfmt.h"

// {A5B688D0-F9AA-4462-94FF-6BD2D72C52BA}
DEFINE_GUID(IID_IStyleSheetHierarchy, 
0xa5b688d0, 0xf9aa, 0x4462, 0x94, 0xff, 0x6b, 0xd2, 0xd7, 0x2c, 0x52, 0xba);

//
// When retrieving a shell interface from CStyleSheetHierarchy, perform a QI to get the desired interface.
// We can't perform a simple cast from CStyleSheetHierarchy to any shell interface because that prevents 
// CStyleSheetHierarchy from being aggregated correctly.
//
// Usage:	IVsHierarchy* pHier = VCQI_cast<IVsHierarchy>(this);
//			IVsProject*   pProj = VCQI_cast<IVsProject>(this);
//			etc.
//
// forward declaration
class CStyleSheetHierarchy;

template <typename T> CComPtr<T> VCQI_cast( const CStyleSheetHierarchy* pCStyleSheetHierarchy) 
{ 
	CComPtr<T>	pT;
	((CStyleSheetHierarchy*)pCStyleSheetHierarchy)->QueryInterface( __uuidof(T), (void**)&pT );
	ASSERT( pT );
	return pT;
}

class CStyleSheetConfig :
	public IVCCfg,
	public ISpecifyPropertyPages,
	public IVsProjectCfg,
	public IVsPersistSolutionOpts,
	public CComObjectRoot
{
public:
	CStyleSheetConfig(void) : m_pArchy(NULL) {}
	~CStyleSheetConfig(void){}
	static HRESULT CreateInstance(IVsProjectCfg **ppGenCfg, CStyleSheetHierarchy* pHierarchy);
	HRESULT Initialize(CStyleSheetHierarchy* pHierarchy);
	
BEGIN_COM_MAP(CStyleSheetConfig)
	COM_INTERFACE_ENTRY(IVsCfg)						// Config interfaces
	COM_INTERFACE_ENTRY(IVsProjectCfg)	
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)		
	COM_INTERFACE_ENTRY(IVsPersistSolutionOpts)
	COM_INTERFACE_ENTRY(IVCCfg)
END_COM_MAP()

private:
	CStyleSheetHierarchy* m_pArchy;

// IVsCfg
public:
	STDMETHOD(get_DisplayName)( /* [out] */ BSTR *pbstrDisplayName);
	STDMETHOD(get_IsDebugOnly)( /* [out] */ BOOL *pfIsDebugOnly);
	STDMETHOD(get_IsReleaseOnly)( /* [out] */ BOOL *pfIsRetailOnly);

// IVsProjectCfg
public:
	STDMETHOD(get_ProjectCfgProvider)( /* [out] */ IVsProjectCfgProvider **ppIVsProjectCfgProvider);
	STDMETHOD(get_CanonicalName)( /* [out] */ BSTR *pbstrCanonicalName);
	STDMETHOD(get_IsRetailOnly)( /* [out] */ BOOL *pfIsRetailOnly);
	STDMETHOD(get_Platform)( /* [out] */ GUID *pguidPlatform)
		{return E_NOTIMPL;	/* CStyleSheetConfig::get_Platform */ }
	STDMETHOD(EnumOutputs)( /* [out] */ IVsEnumOutputs **ppIVsEnumOutputs)
		{return E_NOTIMPL; /* CStyleSheetConfig::EnumOutputs */ }
	STDMETHOD(OpenOutput)( /* [in] */ LPCOLESTR szOutputCanonicalName, /* [out] */ IVsOutput **ppIVsOutput)
		{return E_NOTIMPL; /* CStyleSheetConfig::OpenOutput */ }
	STDMETHOD(get_BuildableProjectCfg)( /* [out] */ IVsBuildableProjectCfg **ppIVsBuildableProjectCfg)
		{return E_NOTIMPL; /* CStyleSheetConfig::get_BuildableProjectCfg */ }
	STDMETHOD(get_IsPackaged)( /* [out] */ BOOL *pfIsPackaged);
	STDMETHOD(get_IsSpecifyingOutputSupported)( /* [out] */ BOOL *pfIsSpecifyingOutputSupported);
	STDMETHOD(get_TargetCodePage)( /* [out] */ UINT *puiTargetCodePage);
	STDMETHOD(get_UpdateSequenceNumber)(/* [out] */ ULARGE_INTEGER *puliUSN)
		{return E_NOTIMPL; /* CStyleSheetConfig::get_UpdateSequenceNumber */ }
	STDMETHOD(get_RootURL)(/* [out] */ BSTR *pbstrRootURL)
		{return E_NOTIMPL; /* CStyleSheetConfig::get_RootURL */ }

// ISpecifyPropertyPages
public:
    STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );

// IVCCfg
public:
	STDMETHOD(get_Tool)(/* [in] */ VARIANT toolIndex, /* [out] */ IUnknown **ppConfig);
	STDMETHOD(get_Object)(/* [out] */ IDispatch **ppDebugSettings);
	
// IVsPersistSolutionOpts
public:
    STDMETHOD(SaveUserOptions)(IVsSolutionPersistence *pPersistence)
		{return E_NOTIMPL; /* CStyleSheetConfig::SaveUserOptions */ }
    STDMETHOD(LoadUserOptions)(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts)
		{return E_NOTIMPL; /* CStyleSheetConfig::LoadUserOptions */ }

    STDMETHOD(WriteUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    STDMETHOD(ReadUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
};

class CStyleSheetHierarchy : 
	public IVsUIHierarchy,			// derives from IVsHierarchy
	public IVsProject,				
	public IVsProjectCfgProvider,	// derives drom IVsCfgProvider
	public IOleCommandTarget,	
	public IPersistFileFormat,		// derives from IPersist
	public IVsPersistSolutionOpts,
	public IVsPerPropertyBrowsing,
//	public IDispatchImpl<IStyleSheet, &IID_IStyleSheet, &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public IDispatchImpl<_Project, &IID__Project, &LIBID_DTE, 7, 0>,
	public CComObjectRoot
{
public:
	CComPtr<IServiceProvider> m_pServiceProvider;
	CComQIPtr<IDispatch> m_dispkeyItem;
	CComPtr<IVsProjectCfg> m_pConfig;
	CComBSTR m_bstrName;
	CComBSTR m_bstrFullPath;
	// un-ref-counted ptr to parent hierarchy
	IUnknown *m_pParentHierarchy;
	VSITEMID m_dwParentHierarchyItemID;
	
public:
	CStyleSheetHierarchy(void){}
	~CStyleSheetHierarchy(void){}
	static HRESULT CreateInstance(CStyleSheetHierarchy** ppHierarchy, LPCOLESTR szFoo);
	HRESULT Initialize();
	
DECLARE_NOT_AGGREGATABLE(CStyleSheetHierarchy)

BEGIN_COM_MAP(CStyleSheetHierarchy)
	COM_INTERFACE_ENTRY(IVsProject)					// Project interfaces
	COM_INTERFACE_ENTRY(IVsHierarchy)			
	COM_INTERFACE_ENTRY(IVsUIHierarchy)			
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(IDispatch)
//	COM_INTERFACE_ENTRY(IStyleSheet)
	COM_INTERFACE_ENTRY(_Project)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)

	COM_INTERFACE_ENTRY(IVsProjectCfgProvider)		// Config provider interfaces
	COM_INTERFACE_ENTRY(IVsCfgProvider)				

	COM_INTERFACE_ENTRY(IPersistFileFormat)			// Persistance interfaces
	COM_INTERFACE_ENTRY(IVsPersistSolutionOpts)
END_COM_MAP()


//  IVsProject
public:
	STDMETHOD (IsDocumentInProject) ( LPCOLESTR pszMkDocument, BOOL *pfFound, VSDOCUMENTPRIORITY *pdwPriority, VSITEMID *pvsid)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::IsDocumentInProject */ }
	STDMETHOD (GetMkDocument) (VSITEMID vsid, BSTR *pbstrMkDocument) 
		{return E_NOTIMPL; /* CStyleSheetHierarchy::GetMkDocument */ }
	STDMETHOD (OpenItem) (VSITEMID vsid, REFGUID guidDocViewType, IUnknown *punkDocDataExisting, IVsWindowFrame **ppWindowFrame)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::OpenItem */ }
	STDMETHOD (GetItemContext) (VSITEMID vsid, IServiceProvider **ppSP)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::GetItemContext */ }
	STDMETHOD (GenerateUniqueItemName) ( VSITEMID itemidLoc, LPCOLESTR pszExt, LPCOLESTR pszSuggestedRoot, BSTR * pbstrItemName)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::GenerateUniqueItemName */ }
	STDMETHOD (AddItem)( /* [in] */ VSITEMID itemidLoc, /* [in] */ VSADDITEMOPERATION dwAddItemOperation, /* [in] */ LPCOLESTR pszItemName, /* [in] */ DWORD cFilesToOpen, /* [in, size_is(cFilesToOpen)] */ LPCOLESTR rgpszFilesToOpen[], /* [in] */ HWND hwndDlg, /* [out, retval] */ VSADDRESULT * pResult)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::AddItem */ }
	STDMETHOD (Close)(void);

// Project
public:
    /* _Project methods */
    STDMETHOD(get_Name)(BSTR FAR* pbstrName);
    STDMETHOD(put_Name)(BSTR bstrName);
    STDMETHOD(get_FileName)(BSTR FAR* pbstrName) { return GetCanonicalName(VSITEMID_ROOT, pbstrName); }
    STDMETHOD(get_IsDirty)(VARIANT_BOOL FAR* lpfReturn)
	{
		CHECK_POINTER_VALID(lpfReturn)
		*lpfReturn = VARIANT_FALSE;
		return S_OK;
	}
    STDMETHOD(put_IsDirty)(VARIANT_BOOL Dirty){ return E_NOTIMPL; }
    STDMETHOD(get_Collection)(Projects FAR* FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(SaveAs)(BSTR FileName){ return E_NOTIMPL; }
    STDMETHOD(get_DTE)(DTE FAR* FAR* lppaReturn)
	{
		CHECK_POINTER_VALID(lppaReturn)
		return ExternalQueryService(SID_SDTE, IID__DTE, (void **)lppaReturn);
	}
    STDMETHOD(get_Kind)(BSTR FAR* lpbstrFileName)
	{
		CHECK_POINTER_VALID(lpbstrFileName);
	
		CComBSTR bstr = L"{A5F5D510-5301-487e-9647-FCBDC4624B8E}"; // should be guid ?
		*lpbstrFileName = bstr.Detach();
		return S_OK;
	}
    STDMETHOD(get_ProjectItems)(ProjectItems FAR* FAR* lppcReturn){ return E_NOTIMPL; }
    STDMETHOD(get_Properties)(Properties FAR* FAR* ppObject){ return E_NOTIMPL; }
    STDMETHOD(get_UniqueName)(BSTR FAR* pbstrName) { return GetCanonicalName(VSITEMID_ROOT, pbstrName); }
	STDMETHOD(get_Object)(IDispatch **ppProjectModel){ return E_NOTIMPL; }
    STDMETHOD(get_Extender)(BSTR bstrExtenderName, IDispatch **ppExtender){ return E_NOTIMPL; }
    STDMETHOD(get_ExtenderNames)(VARIANT *pvarExtenderNames){ return E_NOTIMPL; }
    STDMETHOD(get_ExtenderCATID)(BSTR *pbstrRetval){ return E_NOTIMPL; }

    STDMETHOD(get_FullName)(BSTR *lpbstrReturn) { return GetCanonicalName(VSITEMID_ROOT, lpbstrReturn); }
    STDMETHOD(get_Saved)(VARIANT_BOOL *lpfReturn)
	{
		CHECK_POINTER_VALID(lpfReturn)
		*lpfReturn = VARIANT_TRUE;
		return S_OK;
	}
    STDMETHOD(put_Saved)(VARIANT_BOOL Dirty)
		{ return S_OK; }
    STDMETHOD(get_SourceControl)(SourceControl ** /*ppSourceControl*/)
		{ return E_NOTIMPL; /* CStyleSheetHierarchy::get_SourceControl */ }
    STDMETHOD(get_ConfigurationManager)(ConfigurationManager **ppConfigurationManager)
	{	return E_FAIL;	/* doesn't have configurations */ }
    STDMETHOD(get_Globals)(Globals ** /*ppGlobals*/)
		{ return E_NOTIMPL;	/* CStyleSheetHierarchy::get_Globals*/ }
    STDMETHOD(Save)(BSTR /*FileName*/)
		{ return E_NOTIMPL; /* CStyleSheetHierarchy::Save */ }
    STDMETHOD(get_ParentProjectItem)(ProjectItem ** ppProjectItem)
    {
		*ppProjectItem = NULL;
		return NOERROR;
    }
    STDMETHOD(get_CodeModel)(CodeModel ** ppCodeModel) { return E_NOTIMPL; }
    STDMETHOD(Delete)(void) { return E_NOTIMPL; }

    STDMETHOD(Reserved1)(BSTR ProgID, VARIANT FileName) { return E_NOTIMPL; }
    STDMETHOD(Reserved2)(BSTR Section, BSTR Key, BSTR Value) { return E_NOTIMPL; }
    STDMETHOD(Reserved3)(BSTR Section, BSTR Key, BSTR FAR* lpbstrValue) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved4)(BSTR FAR* lpbstrHelpFile) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved4)(BSTR bstrHelpFile) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved5)(long FAR* lpdwContextID) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved5)(long dwContextID) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved6)(BSTR FAR* lpbstrDescription) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved6)(BSTR bstrDescription) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved7)(IDispatch * FAR* lppReferences) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved8)(IDispatch * FAR* lppaReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved9)(long FAR* lpStartMode) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved9)(long StartMode) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved10)(BSTR FAR* lpbstrCompatibleOleServer) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved10)(BSTR bstrCompatibleOleServer) { return E_NOTIMPL; }
    STDMETHOD(Reserved11)() { return E_NOTIMPL; }
    STDMETHOD(get_Reserved12)(long FAR* lpkind) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved12)(long Type) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved13)(long FAR* lpIconState) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved13)(long IconState) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved17)(VARIANT_BOOL FAR* lpfReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved15)(IDispatch * FAR* lppcReturn) { return E_NOTIMPL; }
    STDMETHOD(get_Reserved16)(BSTR FAR* lpbstrBldFName) { return E_NOTIMPL; }
    STDMETHOD(put_Reserved16)(BSTR bstrBldFName) { return E_NOTIMPL; }
	

// IVsHierarchy
public:
	STDMETHOD(SetSite)( /* [in] */ IServiceProvider *pSP);
	STDMETHOD(GetSite)( /* [out] */ IServiceProvider **ppSP); 	
	STDMETHOD(QueryClose)( /* [out] */ BOOL *pfCanClose);
	STDMETHOD(GetGuidProperty)( /* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [out] */ GUID *pguid);
	STDMETHOD(SetGuidProperty)( /* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ REFGUID guid);
	STDMETHOD(GetProperty)( VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [out] */ VARIANT *pvar);
	STDMETHOD(SetProperty)( VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ VARIANT var);
	STDMETHOD(GetNestedHierarchy)( /* [in] */ VSITEMID itemid, /* [in] */ REFIID riid, /* [out] */ void **ppHierarchyNested, /* [out] */ VSITEMID *pitemidNested)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::GetNestedHierarchy */ }
	STDMETHOD(GetCanonicalName)( /* [in] */ VSITEMID itemid, /* [out] */ BSTR *ppszName);
	STDMETHOD(ParseCanonicalName)( /* [in] */ LPCOLESTR pszName, /* [out] */ VSITEMID *pitemid);
	STDMETHOD(AdviseHierarchyEvents)( /* [in] */ IVsHierarchyEvents *pEventSink, /* [out] */ VSCOOKIE *pdwCookie);
	STDMETHOD(UnadviseHierarchyEvents)( /* [in] */ VSCOOKIE dwCookie) {return S_OK;}
	STDMETHOD(Unused0)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused1)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused2)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused3)( void ){return E_NOTIMPL;}
	STDMETHOD(Unused4)( void ){return E_NOTIMPL;}

// IVsUIHierarchy
public:
    STDMETHOD (QueryStatusCommand)(VSITEMID itemid, const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
	STDMETHOD(ExecCommand)(VSITEMID itemid, const GUID * pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, 
		VARIANT* pvaOut);

// IOleCommandTarget
public:
	STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);
			
// IVsCfgProvider
public:
	STDMETHOD(GetCfgs)(ULONG celt, IVsCfg *rgpcfg[], ULONG *pcActual, VSCFGFLAGS *prgfFlags); 

// IVsProjectCfgProvider
public:
	STDMETHOD(OpenProjectCfg)(/*[in]*/ LPCOLESTR szProjectCfgCanonicalName, IVsProjectCfg **ppIVsProjectCfg)
		{return E_NOTIMPL; /* CExeHierarchy::OpenProjectCfg */ }
	STDMETHOD(get_UsesIndependentConfigurations)(/*[out]*/ BOOL *pfUsesIndependentConfigurations);

// IPersist
public:
	STDMETHOD(GetClassID)( /* [out] */ CLSID *pClassID);

// IPersistFileFormat
public:
	STDMETHOD(IsDirty)(BOOL __RPC_FAR *pfIsDirty);
	STDMETHOD(InitNew)( DWORD nFormatIndex)
		{ return E_NOTIMPL; }
	STDMETHOD(Load)( LPCOLESTR pszFilename, DWORD grfMode, BOOL fReadOnly)
		{ return S_OK; }
	STDMETHOD(Save)( LPCOLESTR pszFilename, BOOL fRemember, DWORD nFormatIndex)
		{ return S_OK; }
	STDMETHOD(SaveCompleted)( LPCOLESTR pszFileName)
		{return S_OK; }
	STDMETHOD(GetCurFile)( LPOLESTR __RPC_FAR *ppszFilename, DWORD __RPC_FAR *pnFormatIndex);
	STDMETHOD(GetFormatList)( LPOLESTR __RPC_FAR *ppszFormatList )
		{return E_NOTIMPL; }


// IVsPersistSolutionOpts
public:
    STDMETHOD(SaveUserOptions)(IVsSolutionPersistence *pPersistence)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::SaveUserOptions */ }
    STDMETHOD(LoadUserOptions)(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts)
		{return E_NOTIMPL; /* CStyleSheetHierarchy::LoadUserOptions */ }

    STDMETHOD(WriteUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    STDMETHOD(ReadUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    
// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide)
	{
	    *pfHide = FALSE;
	    return S_OK;
	}
	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay)
		{ return E_NOTIMPL; /* CStyleSheetHierarchy::DisplayChildProperties */ }
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault)
		{ return E_NOTIMPL; /* CStyleSheetHierarchy::HasDefaultValue */ }
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly)
	{ 
	    *fReadOnly = TRUE;
	    return S_OK; 
	}
	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
	{
	    switch( dispid )
	    {
		case DISPID_VALUE:
		{
		    CComBSTR bstrName( L"Name" );
		    if (pbstrName != NULL)
			*pbstrName = bstrName.Detach();
    
		    CComBSTR bstrDesc( L"The Name of the exe to debug" );
		    if (pbstrDesc != NULL)
			*pbstrDesc = bstrDesc.Detach();

		    break;
		}
		case 209:
		{
		    CComBSTR bstrName( L"Full Path" );
		    if (pbstrName != NULL)
			*pbstrName = bstrName.Detach();
    
		    CComBSTR bstrDesc( L"The Full Path to the exe to debug" );
		    if (pbstrDesc != NULL)
			*pbstrDesc = bstrDesc.Detach();

		    break;
		}
		default:
		    break;
	    }
	    return S_OK;
	}

	STDMETHOD(GetClassName)(BSTR* ) {return E_NOTIMPL;}	
    STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
    STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}

public:
	HRESULT GetVCStyleSheet(VCStyleSheet** ppStyle);
	HRESULT GetVCDispStyleSheet(IDispatch** ppStyle);
	HRESULT ShowSettings();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\utils.cpp ===
//-----------------------------------------------------------------------------
// Microsoft Visual C++
//
// Microsoft Confidential
// Copyright 1994 - 2000 Microsoft Corporation. All Rights Reserved.
//
// Utils.cpp : Implementation of useful functions
//-----------------------------------------------------------------------------
#include "stdafx.h"
#include "rsrc.h"
#include "utils.h"
#include "path2.h"
#include "locale.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static bool bPlatformInited = false;
static DWORD dwPlatform;

//-----------------------------------------------------------------------------
// Useful directory separator check
//-----------------------------------------------------------------------------
static inline BOOL IsDirSep(wchar_t ch)
{
	return (ch == L'\\' || ch == L'/');
}

static inline BOOL IsDirSep(char ch)
{
	return (ch == '\\' || ch == '/');
}

//-----------------------------------------------------------------------------
// Returns the registered folder holding our new Ui dlls
//-----------------------------------------------------------------------------
void UtilGetProjUIFolder(CString& strProjItemDir)
{
	strProjItemDir.Empty();
	if (!UtilGetModuleFileName(_Module.GetModuleInstance( ), strProjItemDir))
		return;

	int nLoc = strProjItemDir.ReverseFind(_T('\\'));
	VSASSERT(nLoc >= 0, "At least one slash required in devenv.exe's location!");
	strProjItemDir = strProjItemDir.Left(nLoc);
}

//-----------------------------------------------------------------------------
//	Creates the directory strDirName. Unlike CreateDirectory() this function will
//	create all the intermediate directories along the way. Note you MUST provide 
//	the full path!
//-----------------------------------------------------------------------------
BOOL UtilCreateDirectory(LPCTSTR strDirName)
{
	// Extract the root name of the volume
	TCHAR szRoot[_MAX_PATH+1];
	memset(szRoot, 0, _MAX_PATH+1);
	_tcsncpy(szRoot, strDirName, _MAX_PATH);

	for (LPTSTR lpsz = szRoot; *lpsz != _T('\0'); lpsz++)
	{	// Find first double slash and stop
		if (IsDirSep(lpsz[0]) && IsDirSep(lpsz[1]))
			break;
	}
	if (*lpsz != _T('\0'))
	{	// It is a UNC name, find second slash past '\\'
		lpsz += 2;
		while (*lpsz != _T('\0') && (!IsDirSep(*lpsz)))
			lpsz = _tcsinc(lpsz);
		if (*lpsz != _T('\0'))
			lpsz = _tcsinc(lpsz);
		while (*lpsz != _T('\0') && (!IsDirSep(*lpsz)))
			lpsz = _tcsinc(lpsz);
		// Terminate after the UNC root (ie. '\\server\share\')
		if (*lpsz != _T('\0'))
			lpsz[1] = _T('\0');
	}
	else
	{
		// Not a UNC, look for just the first slash
		lpsz = szRoot;
		while (*lpsz != _T('\0') && (!IsDirSep(*lpsz)))
			lpsz = _tcsinc(lpsz);
		// Terminate it just after root (ie. 'x:\')
		if (*lpsz != _T('\0'))
			lpsz[1] = _T('\0');
	}

	// Figure out offset past the volume info and set buffer ptr there.
	TCHAR buffer[_MAX_PATH];
	_tcsncpy(buffer, strDirName, _MAX_PATH);
	buffer[_MAX_PATH-1] = _T('0');
	TCHAR* pPath = &buffer[_tcsclen(szRoot)];

	SECURITY_ATTRIBUTES sa; 
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa. bInheritHandle = TRUE;

	TCHAR* pNextToken = _tcstok( pPath, _T("\\/"));
	while(pNextToken)
	{
		// Append token to path so far
		_tcscat(szRoot, pNextToken);
		
		// If this subdir hasn't been created, do so.
		if(::GetFileAttributes(szRoot) == -1)
		{
				if(!::CreateDirectory(szRoot, &sa))
				{	// Failed create of subdir
					return FALSE;
				}
		}

		// Add in separator and get next part of path
		_tcscat(szRoot, _T("\\"));
		pNextToken = _tcstok( NULL, _T("\\/"));
	}
	
	// Made it all the way through.
	return TRUE;
}

//-----------------------------------------------------------------------------
//	Creates the directory strDirName. Unlike CreateDirectory() this function will
//	create all the intermediate directories along the way. Note you MUST provide 
//	the full path!
//-----------------------------------------------------------------------------
BOOL UtilCreateDirectoryW(const wchar_t* strDirName)
{
	// Extract the root name of the volume
	wchar_t szRoot[_MAX_PATH+1];
	memset(szRoot, 0, sizeof(wchar_t)*(_MAX_PATH+1) );
	wcsncpy(szRoot, strDirName, _MAX_PATH);
	szRoot[_MAX_PATH] = 0; // wcsncpy does not terminate for you.

	for (wchar_t* lpsz = szRoot; *lpsz != L'\0'; lpsz++)
	{	// Find first double slash and stop
		if (IsDirSep(lpsz[0]) && IsDirSep(lpsz[1]))
			break;
	}
	if (*lpsz != L'\0')
	{	// It is a UNC name, find second slash past '\\'
		lpsz += 2;
		while (*lpsz != L'\0' && (!IsDirSep(*lpsz)))
			lpsz++;
		if (*lpsz != L'\0')
			lpsz++;
		while (*lpsz != L'\0' && (!IsDirSep(*lpsz)))
			lpsz++;
		// Terminate after the UNC root (ie. '\\server\share\')
		if (*lpsz != L'\0')
			lpsz[1] = L'\0';
	}
	else
	{
		// Not a UNC, look for just the first slash
		lpsz = szRoot;
		while (*lpsz != L'\0' && (!IsDirSep(*lpsz)))
			lpsz++;
		// Terminate it just after root (ie. 'x:\')
		if (*lpsz != L'\0')
			lpsz[1] = L'\0';
	}

	// Figure out offset past the volume info and set buffer ptr there.
	wchar_t buffer[_MAX_PATH];
	wcsncpy(buffer, strDirName, _MAX_PATH);
	buffer[_MAX_PATH-1] = 0;
	wchar_t* pPath = &buffer[wcslen(szRoot)];

	SECURITY_ATTRIBUTES sa; 
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;

	wchar_t* pNextToken = wcstok( pPath, L"\\/");
	while(pNextToken)
	{
		// Append token to path so far
		wcscat(szRoot, pNextToken);
		
		// If this subdir hasn't been created, do so.
		if(::GetFileAttributesW(szRoot) == -1)
		{
				if(!::CreateDirectoryW(szRoot, &sa))
				{	// Failed create of subdir
					return FALSE;
				}
		}

		// Add in separator and get next part of path
		wcscat(szRoot, L"\\");
		pNextToken = wcstok( NULL, L"\\/");
	}
	
	// Made it all the way through.
	return TRUE;
}


//-----------------------------------------------------------------------------
// Handle SendMessage as SendMessageW on NT/Win2k
//-----------------------------------------------------------------------------
LRESULT UtilSendMessageW( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{
	if( !bPlatformInited )
	{
		bPlatformInited = true;
		// what OS are we running on?
		OSVERSIONINFO osver;
		memset( &osver, 0, sizeof(osver) );
		osver.dwOSVersionInfoSize = sizeof(osver);
		GetVersionEx( &osver );
		dwPlatform = osver.dwPlatformId;
	}
	// if we're running on NT, use Unicode 
	if( dwPlatform == VER_PLATFORM_WIN32_NT )
		return SendMessageW( hWnd, Msg, wParam, lParam );
	// otherwise, Win9x, we can't use Unicode
	else
		return SendMessage( hWnd, Msg, wParam, lParam );
}

//-----------------------------------------------------------------------------
// Handle SendMessage as SendMessageW on NT/Win2k where the LPARAM is a string
// (hence ANSI on Win9x and Unicode on NT/Win2k...)
//-----------------------------------------------------------------------------
LRESULT UtilSendMessageWString( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{
	if( !bPlatformInited )
	{
		bPlatformInited = true;
		// what OS are we running on?
		OSVERSIONINFO osver;
		memset( &osver, 0, sizeof(osver) );
		osver.dwOSVersionInfoSize = sizeof(osver);
		GetVersionEx( &osver );
		dwPlatform = osver.dwPlatformId;
	}
	// if we're running on NT, use Unicode 
	if( dwPlatform == VER_PLATFORM_WIN32_NT )
	{
		return SendMessageW( hWnd, Msg, wParam, lParam );
	}
	// otherwise, Win9x, we can't use Unicode
	else
	{
		// convert the string to ANSI
		USES_CONVERSION;
		char* szString = W2A( (wchar_t*)lParam );
		return SendMessageA( hWnd, Msg, wParam, (LPARAM)szString );
	}
}


//-----------------------------------------------------------------------------
// Sets the error information in the shell. 
//-----------------------------------------------------------------------------
HRESULT UtilSetErrorInfo(HRESULT hrError, LPCOLESTR pszDescription)
{
    HRESULT     hr = S_OK;

    if (hrError == S_OK)
    {
        hr = ::SetErrorInfo(0, NULL);
        return hr;
    }

    CComPtr<ICreateErrorInfo>   srpCreateErrInfo;
    CComQIPtr<IErrorInfo>       srpErrInfo;

    hr = ::CreateErrorInfo(&srpCreateErrInfo);
    hr = srpCreateErrInfo->SetDescription((LPOLESTR)pszDescription);
    hr = srpCreateErrInfo->SetGUID(GUID_NULL);
    hr = srpCreateErrInfo->SetHelpContext(0);
    hr = srpCreateErrInfo->SetHelpFile(NULL);
    hr = srpCreateErrInfo->SetSource(L"");
	srpErrInfo = srpCreateErrInfo;
    hr = ::SetErrorInfo(0, srpErrInfo);

	return hr;
}

// End of utils.cpp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcarchy.cpp ===
//---------------------------------------------------------------------------
// Microsoft Visual C++
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// VCArchy.cpp : Implementation of CVCArchy
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "rsrc.h"
#include "bldpkg.h"
#include "VCArchy.h"
#include "vcfile.h"
#include <vcguid.h>
#include "vcnode.h"
#include "path2.h"
#include "gencfg.h"
#include "vcfgrp.h"
#include "vstrkdoc.h"
#include "..\resdll\gpcmd.h"
#include "vssolutn.h"
#include "VsCoCreate.h"
#include "DataObject.h"
#include "VCPropObject.h"
#include "..\..\vcpb\comlist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// using this variable to generate unique cookies (via incrementing)
VSCOOKIE CVCArchy::g_dwCookie = 0;

// did we start this drag or not
BOOL CVCArchy::s_bStartedDrag = FALSE;

CVCArchy::CVCArchy(void) :
	m_hImageList(NULL),
	m_pRootNode(NULL),
	m_pParentHierarchy(NULL),
	m_dwParentHierarchyItemid(VSITEMID_NIL),
	m_fRegisteredWithScc( false ),
	m_dropType(DT_NONE),
	m_bInternalDrop(FALSE),
	m_dwClipEvtCookie(0),
	m_pDragDropDataObject(NULL),
	m_pClipboardDataObject(NULL),
	m_bWasCut(FALSE),
	m_pCachedNode(NULL),
	m_nCachedIconType(0)
{
	if (GetBuildPkg())
		GetBuildPkg()->AddSolutionRef();	// want the solution around while any project is around

	// get a VsCfgProviderEventsHelper to send cfg events to the shell with
	CComPtr<ILocalRegistry> pLocalReg;
	HRESULT hr = ExternalQueryService( SID_SLocalRegistry, IID_ILocalRegistry, (void**)&pLocalReg );
	VSASSERT( SUCCEEDED( hr ) && pLocalReg, "Failed to QueryService for SLocalRegistry!  Could this be a threading issue or is it just a registry issue?" );
	if (pLocalReg)
	{
		hr = pLocalReg->CreateInstance( CLSID_VsCfgProviderEventsHelper, NULL, IID_IVsCfgProviderEventsHelper, CLSCTX_SERVER, (void**)&m_pCfgProviderEventsHelper );
		VSASSERT( SUCCEEDED( hr ) && m_pCfgProviderEventsHelper, "Failed to CreateInstance IVsCfgProviderEventsHelper!  Could this be a threading issue or is it just a registry issue?" );
	}
}

CVCArchy::~CVCArchy(void)
{
}

HRESULT CVCArchy::CanDirtyProject( void )
{
	// see if we are allowed to touch the project
	CComPtr<IDispatch> pProject;
	GetDispVCProject( NULL, &pProject );
	CComQIPtr<IVCProjectImpl> pProjImpl = pProject;
	RETURN_ON_NULL2(pProjImpl, E_NOINTERFACE);
	VARIANT_BOOL bCanDirty;
	if( pProjImpl->get_CanDirty( &bCanDirty ) != S_OK || bCanDirty == VARIANT_FALSE )
		return E_ACCESSDENIED;
	return S_OK;
}

UINT CVCArchy::GetIconIndex(CVCNode* pNode, ICON_TYPE iconType) 
{
	if (pNode == m_pCachedNode)	// caching node info just to make SCC perform faster
		return m_nCachedIconType;
	else
		return pNode->GetIconIndex( iconType ); // TODO: Make sure all pNodes have one of these.
}

//---------------------------------------------------------------------------
// interface: IVsProject
//---------------------------------------------------------------------------

STDMETHODIMP CVCArchy::IsDocumentInProject (
						LPCOLESTR pszMkDocument,
						BOOL *pfFound,
						VSDOCUMENTPRIORITY *pdwPriority,
						VSITEMID *pvsid)
{
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	CHECK_ZOMBIE(pProj, IDS_ERR_PROJ_ZOMBIE);
	CHECK_READ_POINTER_NULL(pszMkDocument);

	CComBSTR bstrProjectFile;
	pProj->get_ProjectFile( &bstrProjectFile );
	CPathW path;
	{
		CCurDirW dir(bstrProjectFile, TRUE);
		if( _wcsnicmp(pszMkDocument,L"file:///", 8) == 0 )
		{
			pszMkDocument = pszMkDocument + 8; // skip past the "file:///" prepend
		}

		BOOL b = path.Create(pszMkDocument);
		if( b == FALSE )
		{
			return E_FAIL;  // not a valid path
		}
	}

	path.GetActualCase(TRUE);

	CComQIPtr<IVCProjectImpl> pProjImp = pProj;
	RETURN_ON_NULL(pProjImp);

	if(pfFound)
		*pfFound = FALSE;

	VSITEMID vsid = VSITEMID_NIL;
	VARIANT_BOOL bIn = VARIANT_FALSE;
	pProjImp->IsFileProbablyInProject( (LPCOLESTR)path, &bIn );
	if( bIn == VARIANT_TRUE )
	{
    
	    // is it the project file??
	    CComBSTR bstrCannon;
	    bstrCannon = path;
	    VARIANT_BOOL bMatch;
	    if (SUCCEEDED(pProj->MatchName(bstrCannon, VARIANT_TRUE, &bMatch)) && bMatch == VARIANT_TRUE)
		    vsid = VSITEMID_ROOT;
	    else
		    vsid = DoItemIDFromName(NULL, VARIANT_TRUE, bstrCannon);
    
	    if (vsid != VSITEMID_NIL)
	    {
		    if(pfFound)
			    *pfFound = TRUE;
		    if(pdwPriority)
			    *pdwPriority = DP_Standard;
	    }
    
	}

	if(pvsid)
		*pvsid = vsid;

	return S_OK;
}

STDMETHODIMP CVCArchy::GetMkDocument (VSITEMID vsid, BSTR *pbstrMkDocument)
{
	CHECK_POINTER_NULL(pbstrMkDocument);

	CVCNode*	pNode = NULL;
	HRESULT hr = VSITEMID2Node(vsid, &pNode);
	CVCNode *pVcNode = static_cast<CVCNode*>(pNode);
	RETURN_ON_NULL(pVcNode);

	CComQIPtr<VCFile> pFile = pVcNode->m_dispkeyItem;
	if (pFile)
		return pFile->get_FullPath(pbstrMkDocument);

	CComQIPtr<VCProject> pProj = pVcNode->m_dispkeyItem;
	if (pProj)
		return pProj->get_ProjectFile(pbstrMkDocument);

	return E_FAIL;
}

STDMETHODIMP CVCArchy::OpenItem (VSITEMID vsid,
				   REFGUID guidDocViewType,
				   IUnknown *punkDocDataExisting,
				   IVsWindowFrame **ppWindowFrame)
{
	CVCNode		   *pNode = NULL;
	HRESULT			hr = VSITEMID2Node(vsid, &pNode);
	BOOL			fIsOpen = FALSE;
	CVCFileNode	   *pFile;
	VSITEMID		vsidDummy;

	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;	
	hr = ExternalQueryService(SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Failed to obtain VSUIShellOpenDocument service.  Did the service ID change?  Are you in the wrong thread?");

	pFile = static_cast<CVCFileNode*>(pNode);
	RETURN_ON_NULL(pFile);

	CComBSTR bstrFile = pFile->GetFullPath();
	RETURN_ON_NULL(bstrFile);

	if (guidDocViewType != LOGVIEWID_UserChooseView)
	{
		CComPtr<IVsUIHierarchy> pUIHier;
		CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(this);
		hr = pVsUIShellOpenDoc->IsDocumentOpen(spHier, vsid, bstrFile, guidDocViewType,
			IDO_ActivateIfOpen, &pUIHier, &vsidDummy, ppWindowFrame, &fIsOpen);
		VSASSERT(SUCCEEDED(hr), "Unable to determine if a document is open.  Are you in the wrong thread?");
	}

	if (!fIsOpen || !(*ppWindowFrame))
	{
		if (guidDocViewType == LOGVIEWID_ProjectSpecificEditor)
			return pFile->DoDefaultAction(FALSE);
		// REVIEW(kperry): does the file exist on disk ? If not this call will fail
		//					should we create it empty like in V6
		CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(pFile->GetHierarchy());
		hr = pVsUIShellOpenDoc->OpenStandardEditor(OSE_ChooseBestStdEditor, bstrFile, guidDocViewType,
			L"%3", spHier, vsid, punkDocDataExisting, NULL, ppWindowFrame);
	}

	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsProject2
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::RemoveItem( 
	/* [in] */ DWORD dwReserved,
	/* [in] */ VSITEMID itemid,
	/* [retval][out] */ BOOL __RPC_FAR *pfResult)
{
	return DoRemoveItem(itemid, pfResult, TRUE /*close if open*/);
}

HRESULT CVCArchy::DoRemoveItem(VSITEMID itemid, BOOL __RPC_FAR *pfResult, BOOL bCloseIfOpen /*= TRUE*/)
{
	CHECK_POINTER_NULL(pfResult);
	HRESULT hr = DoDeleteItem( DELITEMOP_RemoveFromProject, itemid, bCloseIfOpen );
	if( SUCCEEDED( hr ) )
		*pfResult = TRUE;
	else 
		*pfResult = FALSE;
	return hr;
}

STDMETHODIMP CVCArchy::ReopenItem( 
	/* [in] */ VSITEMID itemid,
	/* [in] */ REFGUID rguidEditorType,
	/* [in] */ LPCOLESTR pszPhysicalView,
	/* [in] */ REFGUID rguidLogicalView,
	/* [in] */ IUnknown __RPC_FAR *punkDocDataExisting,
	/* [retval][out] */ IVsWindowFrame __RPC_FAR *__RPC_FAR *ppWindowFrame)
{
	CHECK_POINTER_NULL(ppWindowFrame);

	CVCNode* pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_FAIL_OR_NULL(hr, pNode);

	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;	
	hr = ExternalQueryService(SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Failed to obtain VSUIShellOpenDocument service.  Did the service ID change?  Are you in the wrong thread?");
	RETURN_ON_FAIL_OR_NULL2(hr, pVsUIShellOpenDoc, E_UNEXPECTED);
  	
	CVCFileNode* pFile = (CVCFileNode *)pNode;
	RETURN_ON_NULL(pFile);

	CComBSTR bstrPath;
	hr = pFile->get_FullPath(&bstrPath);
	RETURN_ON_FAIL(hr);

	CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(pFile->GetHierarchy());
	CComPtr<IVsWindowFrame> srpWindowFrame;
	hr = pVsUIShellOpenDoc->OpenSpecificEditor(0, bstrPath, rguidEditorType, pszPhysicalView, rguidLogicalView, L"%3", 
		spHier, pFile->GetVsItemID(), punkDocDataExisting, NULL, &srpWindowFrame);
	if (SUCCEEDED(hr) && srpWindowFrame)
	{
		if (ppWindowFrame)
			*ppWindowFrame = srpWindowFrame.Detach();
	}

	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsProject3
// AddItemWithSpecific is used to add item(s) to the project and additionally ask the project to
// open the item using the specified editor information.  An extension of IVsProject::AddItem().
STDMETHODIMP CVCArchy::AddItemWithSpecific( VSITEMID itemidLoc, VSADDITEMOPERATION dwAddItemOperation, LPCOLESTR pszItemName, ULONG cFilesToOpen, LPCOLESTR rgpszFilesToOpen[], HWND hwndDlg, VSSPECIFICEDITORFLAGS grfEditorFlags, REFGUID rguidEditorType, LPCOLESTR pszPhysicalView, REFGUID rguidLogicalView, VSADDRESULT* pResult)
{
	HRESULT hr;

	// add the item(s)
	hr = DoAddItem( itemidLoc, dwAddItemOperation, pszItemName, cFilesToOpen, rgpszFilesToOpen, hwndDlg, pResult );
	RETURN_ON_FAIL(hr);
	if( *pResult != ADDRESULT_Success )
		return hr;

	for( unsigned int i = 0; i < cFilesToOpen; i++ )
	{
		// open the item(s)
		// get the itemid for the new item
		VSITEMID itemid;
		BOOL bFound = FALSE;
		IsDocumentInProject(dwAddItemOperation == VSADDITEMOP_CLONEFILE ? pszItemName : rgpszFilesToOpen[i], &bFound, NULL, &itemid );
		if( !bFound )
		{
			*pResult = ADDRESULT_Failure;
			return E_FAIL;
		}

		if( grfEditorFlags & VSSPECIFICEDITOR_DoOpen )
		{
			CComPtr<IVsWindowFrame> pWindowFrame;
			hr = OpenItemWithSpecific( itemid, grfEditorFlags, rguidEditorType, pszPhysicalView, rguidLogicalView, NULL, &pWindowFrame );
			RETURN_ON_FAIL(hr);
			if( pWindowFrame )
				pWindowFrame->Show();
		}
	}
		
	return S_OK;
}

// OpenItemWithSpecific is used to ask the project to open the item using the
// specified editor information.  An extension of IVsProject::OpenItem().
STDMETHODIMP CVCArchy::OpenItemWithSpecific( VSITEMID itemid, VSSPECIFICEDITORFLAGS grfEditorFlags, REFGUID rguidEditorType, LPCOLESTR pszPhysicalView, REFGUID rguidLogicalView, IUnknown* punkDocDataExisting, IVsWindowFrame** ppWindowFrame)
{
	HRESULT hr;

	CVCFileNode* pNode = NULL;
	hr = VSITEMID2Node( itemid, reinterpret_cast<CVCNode**>(&pNode) );
	if( SUCCEEDED( hr ) && pNode )
	{
		CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;
		hr = ExternalQueryService(SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
		VSASSERT(SUCCEEDED(hr), "Unable to obtain IVsUIShellOpenDocument service!  Did the IDs change?  Do you need to investigate threading issues?");

		CComBSTR bstrPath;
		bstrPath = pNode->GetFullPath();

		hr = pVsUIShellOpenDoc->OpenSpecificEditor( grfEditorFlags, bstrPath, rguidEditorType, pszPhysicalView, rguidLogicalView, L"%3", this, itemid, punkDocDataExisting, GetServiceProvider(), ppWindowFrame );
//		ppWindowFrame->Show();
	}
		
	return hr;
}

//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::TransferItem( LPCOLESTR pszMkDocumentOld,
				   LPCOLESTR pszMkDocumentNew,
				   IVsWindowFrame *punkWindowFrame)
{
	HRESULT hr;

	// get the VSITEMID for this document
	VSITEMID itemidNew = ItemIDFromName( m_pRootNode, pszMkDocumentNew );
	if( itemidNew == VSITEMID_NIL )
		RETURN_INVALID();

	// get an IVsRunningDocumentTable ptr
	CComPtr<IVsRunningDocumentTable> spDocTable;
	hr = ExternalQueryService(SID_SVsRunningDocumentTable, __uuidof(IVsRunningDocumentTable), (void **)&spDocTable);
	RETURN_ON_FAIL_OR_NULL(hr, spDocTable);

	// call IVsRunningDocumentTable::RenameDocument to transfer ownership
	// to our hierarchy, and give the document a new itemid within our project
	CComPtr<IVsHierarchy> spHier = VCQI_cast<IVsHierarchy>(this);
	hr = spDocTable->RenameDocument( pszMkDocumentOld, pszMkDocumentNew, spHier, itemidNew );

	// set the caption
	if( punkWindowFrame )
	{
		CComVariant varCaption = CComBSTR(L"%3");
		punkWindowFrame->SetProperty( VSFPROPID_OwnerCaption, varCaption );
	}

	return hr;
}

//---------------------------------------------------------------------------
// ISupportItemHandoff
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::HandoffItem( VSITEMID itemid,			 // itemid in project where document should be removed
				  IVsProject3 *pProjDest,	   // project to which document should be transferred
				  LPCOLESTR pszMkDocumentOld,  // passed as pszDocumentOld to IVsRunningDocumentTable::RenameDocument
				  LPCOLESTR pszMkDocumentNew,  // passed as pszDocumentNew to IVsRunningDocumentTable::RenameDocument
				  IVsWindowFrame *punkWindowFrame) // optional if document not open
{
	HRESULT hr;

	// call TransferItem() on the IVsProject3 that we're handed
	hr = pProjDest->TransferItem( pszMkDocumentOld, pszMkDocumentNew, punkWindowFrame );

	return hr;
}

STDMETHODIMP CVCArchy::GetItemContext (VSITEMID vsid, IServiceProvider **ppSP)
{
	CHECK_POINTER_NULL(ppSP);

	*ppSP = GetServiceProvider();
	VSASSERT(*ppSP != NULL, "This hierarchy doesn't have a service provider!");
	(*ppSP)->AddRef();
	return S_OK;
} 

STDMETHODIMP CVCArchy::GenerateUniqueItemName (
			  VSITEMID itemidLoc,
			  LPCOLESTR pszExt,
			  LPCOLESTR pszSuggestedRoot,
			  BSTR * pbstrItemName)
{
	CHECK_POINTER_NULL(pbstrItemName);

	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	// If there is no extension then we won't have any way of identifying if it in 
	// our project or not. If we fail, the shell does a better job of doing FindFirstFile
	// This is VS7:146503, 150963, 150964
	RETURN_ON_NULL(pProj);

	if (pszExt && !*pszExt)
	{
        // This is a null extension. It is not a file. This means that we have to identify
        // if there is a codeelement with this pszSuggestedRoot name
		RETURN_ON_NULL(pszSuggestedRoot);
        CComVariant var;
        GetProperty( VSITEMID_ROOT, VSHPROPID_ExtObject, &var );
        CComPtr<Project> spShlPrj;
		if (FAILED(var.pdispVal->QueryInterface(__uuidof(Project), reinterpret_cast<void **> (&spShlPrj))))
			return E_FAIL;
        CComPtr<CodeModel> spCM;
        if (FAILED(spShlPrj->get_CodeModel(&spCM)))
            return E_FAIL;
        
        CComPtr<CodeElements> spCEs;
        if (FAILED(spCM->get_CodeElements(&spCEs)))
            return E_FAIL;
        
        VARIANT_BOOL vBool;
        CComBSTR bstrSuggestedRoot(pszSuggestedRoot);
        if (FAILED(spCEs->CreateUniqueID(bstrSuggestedRoot, pbstrItemName, &vBool)))
            return E_FAIL;

        return S_OK;
    }

	CComBSTR bstrProjPath;
	pProj->get_ProjectDirectory(&bstrProjPath);
	
	CComBSTR bstrFile;
	if( pszSuggestedRoot == NULL )
		bstrFile.LoadString(IDS_FILENAME);
	else
		bstrFile = pszSuggestedRoot;

	int i = 0;	
	while( i >= 0 )
	{
		i++;
		CComBSTR bstrName;
		CComBSTR bstrFullName;
		WCHAR pszCount[10];
		_itow(i, pszCount, 10);

		bstrName = bstrFile;
		bstrName.Append( pszCount );
		bstrName.Append( pszExt );
		
		bstrFullName = bstrProjPath;
		bstrFullName.Append( bstrName );

		if( ItemIDFromName(NULL, bstrFullName) != VSITEMID_NIL )
			continue;

		// Does the file exist on disk;
		/*
		REVIEW(kperry) enable this
		DWORD dwAttr = GetFileAttributesW(bstrFullName);
		if( dwAttr != 0xFFFFFFFF && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
			continue;
		*/

		*pbstrItemName = bstrName.Detach();
		return S_OK;
	}

	return E_FAIL; // how many files are in this project ? : )
} 

STDMETHODIMP CVCArchy::AddItem (
			  /* [in] */ VSITEMID itemidLoc,
			  /* [in] */ VSADDITEMOPERATION dwAddItemOperation,
			  /* [in] */ LPCOLESTR pszItemName,
			  /* [in] */ DWORD cFilesToOpen,
			  /* [in, size_is(cFilesToOpen)] */ LPCOLESTR rgpszFilesToOpen[],
			  /* [in] */ HWND hwndDlg,
			  /* [out, retval] */ VSADDRESULT * pResult)
{
	HRESULT hr = DoAddItem(itemidLoc,dwAddItemOperation,pszItemName,cFilesToOpen,rgpszFilesToOpen,hwndDlg,pResult);
	RETURN_ON_FAIL(hr);
	if( *pResult != ADDRESULT_Success )
		return hr;

	if( dwAddItemOperation == VSADDITEMOP_CLONEFILE )
	{
		// open the item(s)
		// get the itemid for the new item
		VSITEMID itemid;
		BOOL bFound = FALSE;
		IsDocumentInProject( pszItemName, &bFound, NULL, &itemid );
		if( !bFound )
		{
			*pResult = ADDRESULT_Failure;
			return E_FAIL;
		}

		CVCFileNode* pNode = NULL;
		hr = VSITEMID2Node( itemid, reinterpret_cast<CVCNode**>(&pNode) );
		if( SUCCEEDED( hr ) && pNode )
		{
			pNode->DoDefaultAction(TRUE);
		}
	}

	return hr;
}

HRESULT CVCArchy::DoAddItem (
			  /* [in] */ VSITEMID itemidLoc,
			  /* [in] */ VSADDITEMOPERATION dwAddItemOperation,
			  /* [in] */ LPCOLESTR pszItemName,
			  /* [in] */ DWORD cFilesToOpen,
			  /* [in, size_is(cFilesToOpen)] */ LPCOLESTR rgpszFilesToOpen[],
			  /* [in] */ HWND hwndDlg,
			  /* [out, retval] */ VSADDRESULT * pResult)
{
	CHECK_POINTER_NULL(pResult);
	*pResult = ADDRESULT_Failure;

	if (cFilesToOpen <= 0)
		return S_OK;
	
	// adding this check because TeamServer wants it.  (VS7 196912)
	if (dwAddItemOperation == VSADDITEMOP_LINKTOFILE)
		return E_FAIL;

	HRESULT hr = S_OK;

	CVCBaseFolderNode* pNode;

	// check the item id for special cases
	switch( itemidLoc )
	{
	case VSITEMID_NIL:
		return S_OK;

	case VSITEMID_ROOT:
		pNode = (CVCBaseFolderNode*)GetProjectNode();
		break;

	default:
		pNode = (CVCBaseFolderNode*)itemidLoc;
		break;
	}

	RETURN_ON_NULL(pNode);

	// do the open
	hr = pNode->HandleAddItemDlg(dwAddItemOperation, pszItemName, cFilesToOpen, rgpszFilesToOpen, hwndDlg, pResult);

	return hr;
}

//---------------------------------------------------------------------------
// interface: IExtractIconW
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetIconLocation(UINT uFlags, LPWSTR szIconFile, UINT cchMax, 
								   int* piIndex, UINT* pwFlags)
{
	VSASSERT(szIconFile != NULL	 && cchMax != 0, "Invalid input parameter");
	CHECK_POINTER_NULL(piIndex);
	CHECK_POINTER_NULL(pwFlags);
	CHECK_READ_POINTER_NULL(szIconFile);
	if(cchMax == 0)
		RETURN_INVALID();

	// Get our path
	CStringW strIconFile = szIconFile;
	if(!UtilGetModuleFileNameW(_Module.GetModuleInstance(), strIconFile))
		return E_FAIL;

	// Return project icon index
	CComBSTR bstr;
	*piIndex = IDI_PROJICON;
	*pwFlags = 0;
	bstr = strIconFile;
	wcsncpy(szIconFile, bstr, cchMax-1);
	szIconFile[cchMax-1] = L'\0';
	return (cchMax <= (UINT)(strIconFile.GetLength()) ? S_OK : S_FALSE);
}

//---------------------------------------------------------------------------
// interface: IExtractIconW
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Extract(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, 
						   HICON *phiconSmall, UINT nIconSize)
{
	VSASSERT(pszFile != NULL  && nIconIndex == IDI_PROJICON, "Invalid input parameter");
#ifdef _DEBUG
	CStringW strOurFile, strTheirFile;
	if (!UtilGetModuleFileNameW(_Module.GetModuleInstance(), strOurFile))
		VSASSERT(FALSE, "Failed to pick up module file name!");
	else
	{
		strTheirFile = pszFile;
		VSASSERT(strTheirFile == strOurFile, "File name mismatch!");
	}
#endif
	if(pszFile == NULL	|| nIconIndex != IDI_PROJICON)
		RETURN_INVALID();

	BOOL bSuccess = FALSE;
	if(phiconLarge)
	{	// Get size
		int size = LOWORD(nIconSize);
		VSASSERT(size != 0, "Icon size is zero!");
		if(size == 0)
			RETURN_INVALID();
		*phiconLarge = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_PROJICON),
								 IMAGE_ICON, size, size, LR_DEFAULTCOLOR );
		if(*phiconLarge)
			bSuccess = TRUE;
	}

	if(phiconSmall)
	{
		int size = HIWORD(nIconSize);
		VSASSERT(size != 0, "Icon size is zero!");
		if(size == 0)
			RETURN_INVALID();
		bSuccess = FALSE;
		*phiconSmall = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_PROJICON),
								 IMAGE_ICON, size, size, LR_DEFAULTCOLOR);
		if(*phiconSmall)
			bSuccess = TRUE;
	}
	if(bSuccess)
		return S_OK;
	return E_FAIL;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Called to close the hierarchy.-- dangerous! Probably should do through solution! 
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Close(void)
{
	VSASSERT( GetRootNode() != NULL, _T("close ignored: CVCArchy"));

	m_srpServiceProvider.Release();
	m_srpMonSel.Release();

	UnregisterSccProject();

	CVCNode *pNode = GetProjectNode();
	CVCProjectNode *pProjNode = static_cast<CVCProjectNode *>(pNode);
	if (pProjNode != NULL)
	{
		// Get rid of any existing dragdrop object
		OnAfterDropOrPaste(FALSE /* no cut */, FALSE /* no move */, TRUE /* drag */, TRUE /* cleanup only */);
		// Get rid of any existing cut/copy/paste object
		OnClear(m_bWasCut);

		pProjNode->CleanUpBeforeDelete();
		pProjNode->Refresh(this);

		pProjNode->SetArchy(NULL);
		SetRootNode(NULL);
	}

	// Unadvise clipboard helper events
	RegisterClipboardNotifications(FALSE);
	
	// Release the IVsCfgProviderEventsHelper
	m_pCfgProviderEventsHelper.Release();

	GetBuildPkg()->ReleaseSolutionRef();	// want the solution to disappear from our view when the last project goes away

	return S_OK; 
}

//---------------------------------------------------------------------------
// interface: IPersist
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetClassID(
			/* [out] */ CLSID *pClassID)
{
	CHECK_POINTER_NULL(pClassID);
	*pClassID = IID_IVCArchy;
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IPersistFile
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::IsDirty(BOOL __RPC_FAR *pfIsDirty)
{
	CHECK_POINTER_NULL(pfIsDirty);
	*pfIsDirty = FALSE;
	if(m_pRootNode)
	{
		if(GetProjectNode() && GetProjectNode()->IsProjectFileDirty())
		{
			*pfIsDirty = TRUE;
			return S_OK;
		}
	}
	return S_FALSE;
}

//---------------------------------------------------------------------------
// interface: IPersistFileFormat
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::InitNew( 
			/* [in] */ DWORD nFormatIndex)
{
	return E_NOTIMPL;	// CVCArchy::InitNew
}

//---------------------------------------------------------------------------
// interface: IPersistFileFormat
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Load(
			/* [in] */ LPCOLESTR pszFilename,
			/* [in] */ DWORD grfMode,
			/* [in] */ BOOL fReadOnly)
{
	return E_NOTIMPL;	// CVCArchy::Load
}

//---------------------------------------------------------------------------
// interface: IPersistFileFormat
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Save(
			/* [in] */ LPCOLESTR pszFilename,
			/* [in] */ BOOL fRemember,
			/* [in] */ DWORD nFormatIndex)
{
	DWORD startTime, endTime;

	// if we're doing performance logging
	VARIANT_BOOL bLog = VARIANT_FALSE;
	if (GetBuildPkg()->GetProjectEngine())
		GetBuildPkg()->GetProjectEngine()->get_PerformanceLogging( &bLog );
	if( bLog == VARIANT_TRUE )
	{
		// start time
		startTime = GetTickCount();
		fprintf( stdout, "Project Save start: %d\n", startTime );
	}

	// do the save:
	
	// get a pointer to the VCProject so we can determine the current file
	// format 
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	RETURN_ON_NULL2(pProj, E_NOINTERFACE);

	// if fRemember is set, we need to do a Save AS (e.g. rename the project
	// file)
	if( fRemember )
		pProj->put_ProjectFile( const_cast<BSTR>(pszFilename) );

	// get the current file format
	enumFileFormat eCurFormat;
	pProj->get_FileFormat( &eCurFormat );
	if( (DWORD)eCurFormat != nFormatIndex )
		pProj->put_FileFormat( (enumFileFormat)nFormatIndex );
	
	// do the save
	CHECK_ZOMBIE(GetProjectNode(), IDS_ERR_PROJ_ZOMBIE);
	HRESULT hr = GetProjectNode()->OnSaveProject( pszFilename );

	if( bLog == VARIANT_TRUE )
	{
		// end time
		endTime = GetTickCount();
		fprintf( stdout, "Project Save end: %d\n", endTime );
	}

	return hr;
}

//---------------------------------------------------------------------------
// interface: IPersistFileFormat
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SaveCompleted(
			/* [unique][in] */ LPCOLESTR pszFileName)
{
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IPersistFileFormat
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetCurFile(
			/* [out] */ LPOLESTR __RPC_FAR *ppszFilename,
			/* [out] */ DWORD __RPC_FAR *pnFormatIndex)
{
	CHECK_POINTER_NULL(ppszFilename);

	// get a pointer to the VCProject so we can determine the current file
	// format
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	CHECK_ZOMBIE(pProj, IDS_ERR_PROJ_ZOMBIE);
	CHECK_ZOMBIE(GetProjectNode(), IDS_ERR_PROJ_ZOMBIE);

	HRESULT hr = S_OK;
	CComPtr<VCProject> pProject;
	GetProjectNode()->GetVCProject(&pProject);
	RETURN_ON_NULL(pProject);

	CComBSTR bstrProjFile;
	pProject->get_ProjectFile( &bstrProjFile );

	DWORD dwLen = (DWORD)(wcslen( bstrProjFile ) + sizeof(OLECHAR));

	*ppszFilename = (LPOLESTR)::CoTaskMemAlloc(dwLen * sizeof(OLECHAR));
	if (NULL != *ppszFilename)
	{
		ocscpy(*ppszFilename, bstrProjFile);
		hr = S_OK;
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	// get the current file format
	enumFileFormat eCurFormat;
	pProject->get_FileFormat( &eCurFormat );
	*pnFormatIndex = (DWORD)eCurFormat;
	
	return hr;
}

STDMETHODIMP CVCArchy::GetFormatList( 
			/* [out] */ LPOLESTR __RPC_FAR *ppszFormatList)
{
	// load the string from resource
	CStringW strFormatList;
	strFormatList.LoadString( IDS_PROJECTSAVEFORMATS );
	// co alloc memory for the return string
	*ppszFormatList = (wchar_t*)CoTaskMemAlloc( (strFormatList.GetLength()+1) * sizeof(wchar_t) );
	if( !ppszFormatList )
		return E_OUTOFMEMORY;
	wcscpy( *ppszFormatList, strFormatList );
	return S_OK;
}

HRESULT CVCArchy::GetCfgOfName(LPCOLESTR szCfgName, VCConfiguration** ppVCCfg)
{
	*ppVCCfg = NULL;
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	RETURN_ON_NULL2(pProj, E_NOINTERFACE);

	CComPtr<IEnumVARIANT> pEnum;
	CComQIPtr<IVCCollection> pCollection;
	CComPtr<IDispatch> pDisp;
	HRESULT hr = pProj->get_Configurations( &pDisp );
	if( SUCCEEDED( hr ) && pDisp )
	{
		pCollection = pDisp;
		RETURN_ON_NULL2(pCollection, E_NOINTERFACE);
		hr = pCollection->_NewEnum( reinterpret_cast<IUnknown **>( &pEnum ) );
	}
	VSASSERT(SUCCEEDED(hr) && pEnum, "Failed to pick up configurations enumerator!");
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	
	CComBSTR bstrCfgName = szCfgName;
	long actualCfgs = 0;
	pEnum->Reset();
	while( true )
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) 
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;

		CComQIPtr<VCConfiguration> pConfig = var.punkVal;
		if (pConfig == NULL)
			continue;
		CComBSTR bstrName;
		hr = pConfig->get_Name(&bstrName);
		RETURN_ON_FAIL(hr);
		if (bstrName == bstrCfgName)
		{
			*ppVCCfg = pConfig.Detach();
			return S_OK;
		}
	}

	// Hmmmm.  Got here, so maybe the config name we started with didn't have a platform on it, so no match
	CStringW strCfgName = bstrCfgName;
	if (strCfgName.Find(L"|") > 0)
		return E_FAIL;	// got told a platform and didn't find it; bye-bye

	bstrCfgName += L"|";
	int nLen = bstrCfgName.Length();

	pEnum->Reset();
	while (true)
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) 
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;

		CComQIPtr<VCConfiguration> pConfig = var.punkVal;
		CComBSTR bstrName;
		if (pConfig == NULL)
			continue;
		hr = pConfig->get_Name(&bstrName);
		RETURN_ON_FAIL(hr);
		if (_wcsnicmp(bstrName.m_str, bstrCfgName.m_str, nLen) == 0)
		{
			*ppVCCfg = pConfig.Detach();
			return S_OK;
		}
	}

	return E_FAIL;
}

//---------------------------------------------------------------------------
// interface: IVsProjectCfgProvider2
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::OpenProjectCfg(/*[in]*/ LPCOLESTR szProjectCfgCanonicalName, IVsProjectCfg **ppIVsProjectCfg)
{
	CHECK_POINTER_NULL(ppIVsProjectCfg);
	CComPtr<VCConfiguration> spConfig;
	HRESULT hr = GetCfgOfName(szProjectCfgCanonicalName, &spConfig);
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVsCfg> pCfg;
	hr = CGenCfg::CreateInstance(&pCfg, this, spConfig);
	RETURN_ON_FAIL_OR_NULL(hr, pCfg);
	return pCfg->QueryInterface(__uuidof(IVsProjectCfg), (void**)ppIVsProjectCfg);
}

STDMETHODIMP CVCArchy::get_UsesIndependentConfigurations(/*[out]*/ BOOL *pfUsesIndependentConfigurations)
{
	CHECK_POINTER_NULL(pfUsesIndependentConfigurations);
	*pfUsesIndependentConfigurations = TRUE;
	return S_OK;
}

STDMETHODIMP CVCArchy::GetCfgNames( 
	/* [in] */ ULONG celt,
	/* [size_is][out][in] */ BSTR rgbstr[  ],
	/* [optional][out] */ ULONG*pcActual)
{
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	RETURN_ON_NULL2(pProj, E_NOINTERFACE);

	CComPtr<IEnumVARIANT> pEnum;
	CComQIPtr<IVCCollection> pCollection;
	CComPtr<IDispatch> pDisp;
	
	//Get config collection
	HRESULT hr = pProj->get_Configurations( &pDisp );
	pCollection = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pCollection, E_NOINTERFACE);

	hr = pCollection->_NewEnum( reinterpret_cast<IUnknown **>( &pEnum ) );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);

	long cPlatforms = 1;
	CComPtr<IDispatch> spDispPlatforms;
	hr = pProj->get_Platforms(&spDispPlatforms);
	CComQIPtr<IVCCollection> spPlatforms = spDispPlatforms;
	if (SUCCEEDED(hr) && spPlatforms)
		spPlatforms->get_Count(&cPlatforms);

	//If there's a pointer to the actual count
	if (pcActual && !IsBadWritePtr(pcActual, sizeof(*pcActual)))
	{
		//Get the count
		long cCount;
		hr = pCollection->get_Count( &cCount );
		RETURN_ON_FAIL(hr);

		if (cPlatforms > 1)
			*pcActual = cCount / cPlatforms;
		else
			*pcActual = cCount;

		//If asking for count, return
		if (celt == 0)
			return S_OK;
	}
	else if (celt == 0) 
		return E_POINTER;	//Asking for count, but null pointer supplied


	//Loop the config name array filling it out
	pEnum->Reset();
	CVCMapStringWToPtr mapNames;
	for (ULONG i = 0, j = 0; i < celt; j++)
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) 
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;
	
		//Get config
		CComQIPtr<VCConfiguration> pConfig;
		pConfig = var.punkVal;
		RETURN_ON_NULL2(pConfig, E_NOINTERFACE);
	
		CComBSTR bstrName;
		hr = pConfig->get_ConfigurationName(&bstrName);
		RETURN_ON_FAIL(hr);

		if (cPlatforms > 1)
		{
			CStringW strName = bstrName;
			int nBar = strName.Find(L'|');
			if (nBar > 0)
				strName = strName.Left(nBar);

			void* pDummy = NULL;
			if (mapNames.Lookup(strName, pDummy))
				continue;
			mapNames.SetAt(strName, pDummy);
			bstrName = strName;
		}

		//Fill out array
		rgbstr[i] = bstrName.Detach();
		i++;
	}
	return S_OK;
}

STDMETHODIMP CVCArchy::GetPlatformNames( 
	/* [in] */ ULONG celt,
	/* [size_is][out][in] */ BSTR rgbstr[  ],
	/* [optional][out] */ ULONG*pcActual)
{
	VSASSERT(NULL != GetProjectNode(), "No project node!  Is this hierarchy zombie?");
	CComPtr<VCProject> spProject;
	if (GetProjectNode())
	{
		GetProjectNode()->GetVCProject(&spProject);
		VSASSERT(spProject != NULL, "No project!  Is this hierarchy zombie?");
	}

	CComQIPtr<IVCCollection> spPlatforms;
	if (spProject)
	{
		CComPtr<IDispatch> spDispPlatforms;
		spProject->get_Platforms(&spDispPlatforms);
		spPlatforms = spDispPlatforms;
	}

	return GetSupportedPlatformNames(spPlatforms, celt, rgbstr, pcActual);
}

STDMETHODIMP CVCArchy::GetCfgOfName( 
	/* [in] */ LPCOLESTR pszCfgName,
	/* [in] */ LPCOLESTR pszPlatformName,
	/* [out] */ IVsCfg* *ppCfg)
{
	CHECK_POINTER_NULL(ppCfg);

	CComBSTR bstrCfgName = pszCfgName;
	bstrCfgName += L"|";
	bstrCfgName += pszPlatformName;

	CComPtr<VCConfiguration> spConfig;
	HRESULT hr = GetCfgOfName(bstrCfgName, &spConfig);
	RETURN_ON_FAIL_OR_NULL(hr, spConfig);

	return CGenCfg::CreateInstance(ppCfg, this, spConfig);
}

STDMETHODIMP CVCArchy::AddCfgsOfCfgName( 
	/* [in] */ LPCOLESTR pszCfgName,
	/* [in] */ LPCOLESTR pszCloneCfgName,
	/* [in] */ BOOL fPrivate)
{
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	CComQIPtr<IVCProjectImpl> pProjImpl = pProj;
	RETURN_ON_NULL2(pProjImpl, E_NOINTERFACE);

	// add a config to the project with the given name
	HRESULT hr = pProjImpl->AddConfigurationInternal(pszCfgName);
	RETURN_ON_FAIL(hr);		// handles the dirty check as well

	// if we're given a name to clone from, then we need to clone from it
	if( pszCloneCfgName && *pszCloneCfgName != L'\0')
	{
		// get the configs collection
		CComPtr<IDispatch> pDisp;
		hr = pProj->get_Configurations( &pDisp );
		CComQIPtr<IVCCollection> pCollection = pDisp;
		RETURN_ON_FAIL_OR_NULL2(hr, pCollection, E_NOINTERFACE);
		
		// iterate through the platforms, copying the config for each
		CComPtr<IDispatch> pDispPlatColl;
		hr = pProj->get_Platforms( &pDispPlatColl );
		CComQIPtr<IVCCollection> pPlatColl = pDispPlatColl;
		RETURN_ON_FAIL_OR_NULL2(hr, pPlatColl, E_NOINTERFACE);
		long num_platforms;
		hr = pPlatColl->get_Count( &num_platforms );
		RETURN_ON_FAIL(hr);
		CComQIPtr<VCConfiguration> pNewCfg;
		for( long i = 1; i <= num_platforms; i++ )
		{
			CComVariant varIdx = i;
			CComPtr<IDispatch> pDispPlatform;
			hr = pPlatColl->Item( varIdx, &pDispPlatform );
			if( FAILED( hr ) )
				continue;
			CComQIPtr<VCPlatform> pPlatform = pDispPlatform;
			if( !pPlatform )
				continue;
			// get the name of the platform
			CComBSTR bstrPlatformName;
			pPlatform->get_Name( &bstrPlatformName );
			// concat it (and the '|' separator) onto the config names
			CComBSTR bstrNewCfgName = CComBSTR( pszCfgName );
			bstrNewCfgName += L"|";
			bstrNewCfgName += bstrPlatformName;
			CComBSTR bstrOldCfgName = CComBSTR( pszCloneCfgName );
			bstrOldCfgName += L"|";
			bstrOldCfgName += bstrPlatformName;
			// look up these names in the config collections
			CComPtr<IDispatch> pDispNewCfg;
			varIdx = bstrNewCfgName;
			hr = pCollection->Item( varIdx, &pDispNewCfg );
			if( FAILED( hr ) )
				continue;
			pNewCfg = pDispNewCfg;
			if( !pNewCfg )
				continue;
			varIdx = bstrOldCfgName;
			CComPtr<IDispatch> pDispOldCfg;
			hr = pCollection->Item( varIdx, &pDispOldCfg );
			if( FAILED( hr ) )
				continue;
			CComQIPtr<VCConfiguration> pOldCfg = pDispOldCfg;
			if( !pOldCfg )
				continue;
			// copy the config
			hr = pOldCfg->CopyTo( pDispNewCfg );
		}

		// set the intermediate and output directories
		// NOTE: by setting them to blank strings we will force the config to
		// regenerate defaults next time it is asked for them,
		// then we ask for them immediately to ensure they aren't left in a
		// bad state, "just in case"
		hr = pNewCfg->put_IntermediateDirectory( CComBSTR( L"" ) );
		RETURN_ON_FAIL(hr);
		hr = pNewCfg->put_OutputDirectory( CComBSTR( L"" ) );
		RETURN_ON_FAIL(hr);
		CComBSTR bstrTemp;
		hr = pNewCfg->get_IntermediateDirectory( &bstrTemp );
		RETURN_ON_FAIL(hr);
		hr = pNewCfg->get_OutputDirectory( &bstrTemp );
		RETURN_ON_FAIL(hr);
	}
	
	return S_OK;
}

STDMETHODIMP CVCArchy::DeleteCfgsOfCfgName( 
	/* [in] */ LPCOLESTR pszCfgName)
{
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	RETURN_ON_NULL2(pProj, E_NOINTERFACE);

	// find the config with this name
	CComPtr<IDispatch> pDispColl;
	HRESULT hr = pProj->get_Configurations( &pDispColl );
	CComQIPtr<IVCCollection> pColl = pDispColl;
	RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
	CComPtr<IDispatch> pDispCfg;
	long lcItems;
	pColl->get_Count( &lcItems );
	for( long i = 1; i <= lcItems && SUCCEEDED(hr); i++ )
	{
		pDispCfg = NULL;
		CComVariant varIdx = i;
		hr = pColl->Item( varIdx, &pDispCfg );
		if( FAILED( hr ) )
			continue;
		CComQIPtr<VCConfiguration> pCfg = pDispCfg;
		if( !pCfg )
			continue;
		CComBSTR bstrCfgName;
		hr = pCfg->get_ConfigurationName( &bstrCfgName );
		if( FAILED( hr ) )
			continue;
		// if we found it, delete it
		if( bstrCfgName == pszCfgName )
		{
			// remove it
			hr = pProj->RemoveConfiguration( pDispCfg );
		}
	}

	return S_OK;
}

STDMETHODIMP CVCArchy::RenameCfgsOfCfgName( 
	/* [in] */ LPCOLESTR pszOldName,
	/* [in] */ LPCOLESTR pszNewName)
{
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	RETURN_ON_NULL2(pProj, E_NOINTERFACE);	// handles the dirty check as well

	// find the config with this name
	CComPtr<IDispatch> pDispColl;
	HRESULT hr = pProj->get_Configurations( &pDispColl );
	CComQIPtr<IVCCollection> pColl = pDispColl;
	RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
	long lcItems;
	pColl->get_Count( &lcItems );
	CComPtr<IDispatch> pDispCfg;
	for( long i = 1; i <= lcItems; i++ )
	{
		pDispCfg = NULL;
		CComVariant varIdx = i;
		hr = pColl->Item( varIdx, &pDispCfg );
		if( FAILED( hr ) )
			continue;
		CComQIPtr<VCConfiguration> pCfg = pDispCfg;
		if( !pCfg )
			continue;
		CComBSTR bstrCfgName;
		hr = pCfg->get_Name( &bstrCfgName );
		if( FAILED( hr ) )
			continue;
		// remove the platform part of the name
		CStringW strCfgName = bstrCfgName;
		int pos = strCfgName.Find( '|' );
		strCfgName = strCfgName.Left( pos );

		// if we found it, rename it
		if( strCfgName == pszOldName )
		{
			// don't need to tack the platform part (e.g. '|win32') on before
			// setting it
			hr = pCfg->put_Name( CComBSTR( pszNewName ) );
			if( FAILED( hr ) )
				break;
		}
	}

	return S_OK;
}

STDMETHODIMP CVCArchy::AddCfgsOfPlatformName(/* [in] */ LPCOLESTR pszPlatformName, /* [in] */ LPCOLESTR pszClonePlatformName)
{
	RETURN_ON_NULL(GetProjectNode());

	CComPtr<VCProject> spProject;
	GetProjectNode()->GetVCProject(&spProject);
	CComQIPtr<IVCProjectImpl> spProjectImpl = spProject;
	RETURN_ON_NULL(spProjectImpl);

	CComBSTR bstrPlatformName = pszPlatformName;

	HRESULT hr = spProjectImpl->AddPlatformInternal(bstrPlatformName);
	RETURN_ON_FAIL(hr);		// handles dirty check as well

	if (!pszClonePlatformName || *pszClonePlatformName == L'\0')
		return S_OK;

	// if we're given a name to clone from, then we need to clone from it
	RETURN_ON_NULL(GetBuildPkg()->GetProjectEngine());

	CComPtr<IDispatch> spDisp;
	GetBuildPkg()->GetProjectEngine()->get_Platforms(&spDisp);
	CComQIPtr<IVCCollection> spColl = spDisp;
	RETURN_ON_NULL(spColl);

	CComPtr<IDispatch> spDispNewPlatform;
	hr = spColl->Item(CComVariant(CComBSTR(pszPlatformName)), &spDispNewPlatform);
	RETURN_ON_FAIL_OR_NULL2(hr, spDispNewPlatform, E_UNEXPECTED);

	CComPtr<IDispatch> spDispClonePlatform;
	hr = spColl->Item(CComVariant(CComBSTR(pszClonePlatformName)), &spDispClonePlatform);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spDispClonePlatform, S_FALSE);	// not a whole lot we can do if we can't find the platform to clone from

	// get the configs collection
	spDisp.Release();
	hr = spProject->get_Configurations( &spDisp );
	spColl = spDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, spColl, E_NOINTERFACE);
	
	// iterate through the configs collection, building up the two collections we need to work with
	CComDynamicListTyped<VCConfiguration> rgClonePlatformConfigs;
	CComDynamicListTyped<VCConfiguration> rgNewPlatformConfigs;

	CComPtr<IEnumVARIANT> spEnumCfgs;
	hr = spColl->_NewEnum(reinterpret_cast<IUnknown **>(&spEnumCfgs));
	RETURN_ON_FAIL_OR_NULL2(hr, spEnumCfgs, E_UNEXPECTED);

	spEnumCfgs->Reset();
	while (TRUE)
	{
		CComVariant var;
		HRESULT hr2 = spEnumCfgs->Next(1, &var, NULL);
		if (hr2 != S_OK)
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;
		CComQIPtr<VCConfiguration> spConfig = var.pdispVal;
		if (spConfig == NULL)
			continue;

		spDisp.Release();
		hr2 = spConfig->get_Platform(&spDisp);
		if (FAILED(hr2))
			continue;
		else if (spDisp == spDispClonePlatform)
			rgClonePlatformConfigs.Add(spConfig);
		else if (spDisp == spDispNewPlatform)
			rgNewPlatformConfigs.Add(spConfig);
	}

	// now copy the configs that match
	long lcCloneConfigs = rgClonePlatformConfigs.GetSize();
	long lcNewConfigs = rgNewPlatformConfigs.GetSize();
	for (long idxClone = 0; idxClone < lcCloneConfigs; idxClone++)
	{
		CComPtr<VCConfiguration> spCloneConfig = rgClonePlatformConfigs.GetAt(idxClone);
		if (spCloneConfig == NULL)
			continue;

		CComBSTR bstrCloneName;
		spCloneConfig->get_Name(&bstrCloneName);
		if (!bstrCloneName)
			continue;

		CStringW strCloneName = bstrCloneName;
		int nBar = strCloneName.Find(L'|');
		if (nBar > 0)
			strCloneName = strCloneName.Left(nBar);
		if (strCloneName.IsEmpty())
			continue;

		BOOL bFoundIt = FALSE;
		for (long idxNew = 0; idxNew < lcNewConfigs && !bFoundIt; idxNew++)
		{
			CComPtr<VCConfiguration> spNewConfig = rgNewPlatformConfigs.GetAt(idxNew);
			if (spNewConfig == NULL)
				continue;

			CComBSTR bstrNewName;
			spNewConfig->get_Name(&bstrNewName);
			if (!bstrNewName)
				continue;

			CStringW strNewName = bstrNewName;
			nBar = strNewName.Find(L'|');
			if (nBar > 0)
				strNewName = strNewName.Left(nBar);

			if (strCloneName != strNewName)
				continue;

			bFoundIt = TRUE;
			// they match, so clone it
			hr = spCloneConfig->CopyTo(spNewConfig);

			// set the intermediate and output directories
			// NOTE: by setting them to blank strings we will force the config to
			// regenerate defaults next time it is asked for them,
			// then we ask for them immediately to ensure they aren't left in a
			// bad state, "just in case"
			hr = spNewConfig->put_IntermediateDirectory( CComBSTR( L"" ) );
			RETURN_ON_FAIL(hr);
			hr = spNewConfig->put_OutputDirectory( CComBSTR( L"" ) );
			RETURN_ON_FAIL(hr);
			CComBSTR bstrTemp;
			hr = spNewConfig->get_IntermediateDirectory( &bstrTemp );
			RETURN_ON_FAIL(hr);
			hr = spNewConfig->get_OutputDirectory( &bstrTemp );
			RETURN_ON_FAIL(hr);

			rgNewPlatformConfigs.Remove(spNewConfig);	// take it out so we don't try to match against it again
		}
	}

	return S_OK;
}

STDMETHODIMP CVCArchy::DeleteCfgsOfPlatformName(/* [in] */ LPCOLESTR pszPlatformName)
{
	RETURN_ON_NULL(GetProjectNode());

	if (!pszPlatformName || *pszPlatformName == L'\0')
		RETURN_INVALID();

	CComPtr<VCProject> spProject;
	GetProjectNode()->GetVCProject(&spProject);
	CComQIPtr<IVCProjectImpl> spProjectImpl = spProject;
	RETURN_ON_NULL(spProjectImpl);

	CComPtr<IDispatch> spDisp;
	spProject->get_Platforms(&spDisp);
	CComQIPtr<IVCCollection> spColl = spDisp;
	RETURN_ON_NULL(spColl);

	spDisp.Release();
	spColl->Item(CComVariant(CComBSTR(pszPlatformName)), &spDisp);
	RETURN_ON_NULL2(spDisp, S_FALSE);

	return spProjectImpl->RemovePlatformInternal(spDisp);
}

STDMETHODIMP CVCArchy::GetSupportedPlatformNames(/* [in] */ ULONG celt, /* [size_is][out][in] */ BSTR rgbstr[],
	/* [optional][out] */ ULONG*pcActual)
{
	CComQIPtr<IVCCollection> spPlatforms;
	VSASSERT(g_pBuildPackage->m_pProjectEngine, "Project engine not initialized!");
	if (g_pBuildPackage && g_pBuildPackage->m_pProjectEngine)
	{
		CComPtr<IDispatch> spDispPlatforms;
		g_pBuildPackage->m_pProjectEngine->get_Platforms(&spDispPlatforms);
		spPlatforms = spDispPlatforms;
	}

	return GetSupportedPlatformNames(spPlatforms, celt, rgbstr, pcActual);
}

HRESULT CVCArchy::GetSupportedPlatformNames(IVCCollection* pPlatforms, ULONG celt, BSTR rgbstr[], ULONG* pcActual)
{
	long cFound = 0;
	HRESULT hr = S_OK;
	if( celt == 0 )
	{
		CHECK_POINTER_NULL(pcActual);
		if (pPlatforms)
		{
			hr = pPlatforms->get_Count(&cFound);
			*pcActual = cFound;
			return hr;
		}
		else
		{
			*pcActual = 1;
			return S_OK;
		}
	}

	if (celt > 1 && pcActual != NULL && !IsBadWritePtr(pcActual, sizeof(*pcActual)))
	{
		if (pPlatforms)
		{
			pPlatforms->get_Count(&cFound);
			*pcActual = cFound;
		}
		else
			*pcActual = 1;
	}

	CHECK_POINTER_NULL(rgbstr);

	if (pPlatforms)
	{
		CComPtr<IEnumVARIANT> spEnum;
		if (SUCCEEDED(pPlatforms->_NewEnum(reinterpret_cast<IUnknown **>(&spEnum))) && spEnum)
		{
			spEnum->Reset();
			ULONG cFetched = 0;
			while (TRUE && cFetched <= celt)
			{
				CComVariant var;
				HRESULT hr2 = spEnum->Next(1, &var, NULL);
				if (hr2 != S_OK)
					break;
				if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
					continue;
				CComQIPtr<VCPlatform> spPlatform = var.pdispVal;
				if (spPlatform == NULL)
					continue;
				CComBSTR bstrName;
				if (FAILED(spPlatform->get_Name(&bstrName)))
					continue;
				rgbstr[cFetched] = bstrName.Detach();
				cFetched++;
			}
			return S_OK;
		}
	}

	CComBSTR bstrPlat = L"Win32";
	rgbstr[0] = bstrPlat.Detach();
	return S_OK;
}

VARIANT_BOOL CVCArchy::SupportsMultiplePlatforms()
{
	long cPlatforms = 1;
	if (GetBuildPkg() && GetBuildPkg()->GetProjectEngine())
	{
		CComPtr<IDispatch> spDispPlatforms;
		if (SUCCEEDED(GetBuildPkg()->GetProjectEngine()->get_Platforms(&spDispPlatforms)))
		{
			CComQIPtr<IVCCollection> spPlatforms = spDispPlatforms;
			if (spPlatforms)
			{
				if (FAILED(spPlatforms->get_Count(&cPlatforms)))
					cPlatforms = 1;
			}
		}
	}

	return (cPlatforms > 1) ? VARIANT_TRUE : VARIANT_FALSE;
}

STDMETHODIMP CVCArchy::GetCfgProviderProperty(/* [in] */ VSCFGPROPID propid, /* [out] */ VARIANT*pOut)
{
	CHECK_POINTER_NULL(pOut);

    // check for bad arg
    if( pOut == NULL || pOut->vt != VT_EMPTY ) 
        return E_POINTER;

	switch( propid )
	{
	case VSCFGPROPID_SupportsCfgEditing:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_TRUE;
		break;
	case VSCFGPROPID_SupportsPlatformEditing:
		pOut->vt = VT_BOOL;
		pOut->boolVal = SupportsMultiplePlatforms();
		break;
	case VSCFGPROPID_SupportsCfgAdd:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_TRUE;
		break;
	case VSCFGPROPID_SupportsCfgDelete:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_TRUE;
		break;
	case VSCFGPROPID_SupportsCfgRename:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_TRUE;
		break;
	case VSCFGPROPID_SupportsPlatformAdd:
		pOut->vt = VT_BOOL;
		pOut->boolVal = SupportsMultiplePlatforms();
		break;
	case VSCFGPROPID_SupportsPlatformDelete:
		pOut->vt = VT_BOOL;
		pOut->boolVal = SupportsMultiplePlatforms();
		break;
	case VSCFGPROPID_SupportsPrivateCfgs:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_IntrinsicExtenderCATID:
		pOut->vt = VT_BSTR;
		LPOLESTR pStr;
		StringFromCLSID(__uuidof(IVCCfg),&pStr);
		pOut->bstrVal = SysAllocString(pStr);
		CoTaskMemFree(pStr);
		break;
	default:
		RETURN_INVALID();
	}
	
	return S_OK;
}

STDMETHODIMP CVCArchy::AdviseCfgProviderEvents( 
	/* [in] */ IVsCfgProviderEvents*pCPE,
	/* [out] */ VSCOOKIE* pdwCookie)
{
	if (m_pCfgProviderEventsHelper)
 		m_pCfgProviderEventsHelper->AdviseCfgProviderEvents( pCPE, pdwCookie );
	return S_OK;
}

STDMETHODIMP CVCArchy::UnadviseCfgProviderEvents( 
	/* [in] */ VSCOOKIE dwCookie)
{
// This assert should be perfectly valid, but this method gets called by the Property Page Frame AFTER the solution is closed!
//	VSASSERT( m_pCfgProviderEventsHelper, "UnadviseCfgProviderEvents() is being called on a VC Hierarchy that has already been Closed!" );
	if( m_pCfgProviderEventsHelper )
		m_pCfgProviderEventsHelper->UnadviseCfgProviderEvents( dwCookie );
	return S_OK;
}

HRESULT CVCArchy::GetCfgs(/*[in]*/ ULONG celt,
				/*[in, out, size_is(celt)]*/ IVsCfg *rgpcfg[],
				/*[out, optional]*/ ULONG *pcActual,
				/*[out, optional]*/ VSCFGFLAGS *prgfFlags)
{
	CComPtr<VCProject> pProj;
	GetVCProject( NULL, &pProj );
	RETURN_ON_NULL2(pProj, E_NOINTERFACE);

	CComPtr<IEnumVARIANT> pEnum;
	CComQIPtr<IVCCollection> pCollection;
	CComPtr<IDispatch> pDisp;
	HRESULT hr = pProj->get_Configurations( &pDisp );
	pCollection = pDisp;
	RETURN_ON_FAIL_OR_NULL(hr, pCollection)

	long actualCfgs = 0;
	if( celt == 0 )
	{
		CHECK_POINTER_NULL(pcActual);

		pCollection->get_Count(&actualCfgs);
		*pcActual = actualCfgs;
		return S_OK;
	}

	CHECK_POINTER_NULL(rgpcfg);

	hr = pCollection->_NewEnum( reinterpret_cast<IUnknown **>( &pEnum ) );
	VSASSERT(SUCCEEDED(hr) && pEnum, "Failed to pick up configurations enumerator!");
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);

	pEnum->Reset();
	ULONG i = 0;
	while( i < celt )
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) 
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;

		CComQIPtr<VCConfiguration> pConfig;
		pConfig = var.punkVal;
		hr = CGenCfg::CreateInstance(&rgpcfg[i], this, pConfig );
		RETURN_ON_FAIL(hr);
		i++;
	}
	return S_OK;
}

// IVsUpdateSolutionEvents
STDMETHODIMP CVCArchy::OnActiveProjectCfgChange(IVsHierarchy* pIVsHierarchy)
{
	if (GetProjectNode())
		GetProjectNode()->OnActiveProjectCfgChange();
	return S_OK;
}

//------------------------------------------------------------------------
// CVCArchy::IVsHierarchyDeleteHandler
//------------------------------------------------------------------------
STDMETHODIMP CVCArchy::QueryDeleteItem(
		/* [in] */ VSDELETEITEMOPERATION dwDelItemOp,
		/* [in] */ VSITEMID itemid,
		/* [retval][out] */ BOOL __RPC_FAR *pfCanDelete)
{
	CHECK_POINTER_NULL(pfCanDelete);
	if (dwDelItemOp != DELITEMOP_RemoveFromProject)
	{
		*pfCanDelete = FALSE;
		return S_OK;
	}

	// only support remove from project
	*pfCanDelete = TRUE;

	CVCNode		*pNode = NULL;
	HRESULT			 hr = VSITEMID2Node(itemid, &pNode);
	CVCNode *pVcNode = static_cast<CVCNode*>(pNode);
	if( pVcNode == NULL )
	{
		*pfCanDelete = FALSE;
		return hr;
	}

	// cannot remove anything while we're building
	if (!(GetBuildPkg()->NoBuildsInProgress()))
	{
		*pfCanDelete = FALSE;
		return hr;
	}

	CVCProjectNode* pProjNode = pVcNode->GetVCProjectNode();
	if (pProjNode == NULL || pProjNode->InBuild())
		*pfCanDelete = FALSE;
	
	return hr;
}
	
STDMETHODIMP CVCArchy::DeleteItem( 
		/* [in] */ VSDELETEITEMOPERATION dwDelItemOp,
		/* [in] */ VSITEMID itemid)
{
	return DoDeleteItem(dwDelItemOp, itemid, TRUE /*close if open*/);
}

HRESULT CVCArchy::DoDeleteItem(VSDELETEITEMOPERATION dwDelItemOp, VSITEMID itemid, BOOL bCloseIfOpen /* = TRUE */)
{
	if (dwDelItemOp != DELITEMOP_RemoveFromProject)
		return E_UNEXPECTED;

	CVCNode* pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_FAIL_OR_NULL(hr, pNode);

	return pNode->OnDelete(NULL, dwDelItemOp, bCloseIfOpen);
}

// helper function for SccGlyphChanged
// recursively call OnPropertyChanged for a node and its children
void CVCArchy::RecurseChildrenAndRefreshGlyphs( CVCNode* pHead )
{
	// refresh this node
	OnPropertyChanged( pHead, VSHPROPID_StateIconIndex, 0 );

	// refresh its children
	if( pHead->GetKindOf() == Type_CVCFileGroup )
	{
		CVCNode *pNode = NULL;
		VSITEMID id = static_cast<CVCBaseFolderNode*>(pHead)->GetFirstChild();
		if( id == VSITEMID_NIL )
			return;
		VSITEMID2Node( id, &pNode );
		if( !pNode )
			return;
		while( pNode )
		{
			RecurseChildrenAndRefreshGlyphs( pNode );
			pNode = pNode->GetNext();
		}
	}
}

//------------------------------------------------------------------------
// CVCArchy::IVsSccProject2::SccGlyphChanged
//------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SccGlyphChanged( 
	/* [in] */ int cAffectedNodes,
	/* [size_is][in] */ const VSITEMID rgitemidAffectedNodes[],
	/* [size_is][in] */ const VsStateIcon rgsiNewGlyphs[],
	/* [size_is][in] */ const DWORD rgdwNewSccStatus[])
{
	HRESULT hr;
	CVCNode* pNode;

	// RefreshAll case:
	if( cAffectedNodes == 0 )
	{
		pNode = GetRootNode();
		OnPropertyChanged( pNode, VSHPROPID_StateIconIndex, 0 );
		pNode = static_cast<CVCBaseFolderNode*>(pNode)->GetHead();
		while( pNode )
		{
			// refresh this node and its children
// 			OnPropertyChanged( pNode, VSHPROPID_StateIconIndex, 0 );
			RecurseChildrenAndRefreshGlyphs( pNode );
			// get the next node
			pNode = pNode->GetNext();
		}
	}
	// normal case
	else
	{
		for( int i = 0; i < cAffectedNodes; i++ )
		{
			pNode = NULL;
			hr = VSITEMID2Node( rgitemidAffectedNodes[i], &pNode );
			m_pCachedNode = pNode;
			m_nCachedIconType = rgsiNewGlyphs[i];

			OnPropertyChanged( pNode, VSHPROPID_StateIconIndex, 0 );
			m_pCachedNode = NULL;
			m_nCachedIconType = 0;
		}
	}

	return S_OK;
}

//---------------------------------------------------------------------------
// Interface: IVsSccProject2
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SetSccLocation(
	/* [in] */ LPCOLESTR pszSccProjectName,
	/* [in] */ LPCOLESTR pszSccAuxPath,
	/* [in] */ LPCOLESTR pszSccLocalPath,
	/* [in] */ LPCOLESTR pszSccProvider)
{
	// get a project pointer
	CComPtr<CVCProjectNode> pVcNode = GetProjectNode();
	RETURN_ON_NULL(pVcNode);

	CComQIPtr<VCProject> pProject = pVcNode->m_dispkeyItem;
	// if this wasn't a project node, we shouldn't be here
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	// store the props
	CComBSTR bstrSccProjectName = pszSccProjectName;
	CComBSTR bstrSccAuxPath = pszSccAuxPath;
	CComBSTR bstrSccLocalPath = pszSccLocalPath;
	CComBSTR bstrSccProvider = pszSccProvider;

	pProject->put_SccProjectName( bstrSccProjectName );
	pProject->put_SccAuxPath( bstrSccAuxPath );
	pProject->put_SccLocalPath( bstrSccLocalPath );
	pProject->put_SccProvider( bstrSccProvider );
	
	return S_OK;
}

//---------------------------------------------------------------------------
// Interface: IVsSccProject2
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetSccFiles(
	/* [in] */ VSITEMID vsitemid,
	/* [out] */ CALPOLESTR* pCaStringsOut,
	/* [out] */ CADWORD* pCaFlagsOut)
{
	// fill the arrays with full path names/flags for the item ids passed in

	CHECK_POINTER_NULL(pCaStringsOut);
	CHECK_POINTER_NULL(pCaFlagsOut);

	CVCNode*	pNode = NULL;
	CComBSTR bstrFullPath;
	HRESULT hr;

	hr = VSITEMID2Node( vsitemid, &pNode );
	CVCNode *pVcNode = static_cast<CVCNode*>(pNode);
	RETURN_ON_NULL2(pVcNode, E_UNEXPECTED);
	CComPtr<IDispatch> pDisp = pVcNode->m_dispkeyItem;

	pCaStringsOut->cElems = 0;
	pCaStringsOut->pElems = NULL;
	pCaFlagsOut->cElems = 0;
	pCaFlagsOut->pElems = NULL;

	// is the node a file node?
	CComQIPtr<VCFile> pFile = pDisp;
	if( pFile )
	{
		CComPtr<IDispatch> pDispParent;
		pFile->get_Parent(&pDispParent);
		CComQIPtr<VCFilter> pFilter = pDispParent;
		if (pFilter != NULL)
		{
		    VARIANT_BOOL bScc = VARIANT_TRUE;
		    pFilter->get_SourceControlFiles(&bScc);
		    if( bScc == VARIANT_FALSE )
				return S_OK;
		}

		hr = pFile->get_FullPath( &bstrFullPath );
		RETURN_ON_FAIL(hr);
		
		// CoTaskMemAlloc arrays
		pCaStringsOut->cElems = 1;
		pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( sizeof(LPOLESTR) );
		pCaFlagsOut->cElems = 1;
		pCaFlagsOut->pElems = (DWORD*)CoTaskMemAlloc( sizeof(DWORD) );
		// set arrays
		pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (bstrFullPath.Length() + 1) * sizeof( OLECHAR ) );
		wcscpy( pCaStringsOut->pElems[0], bstrFullPath );
		pCaFlagsOut->pElems[0] = 0;

		return S_OK;
	}

	// is the node a project node?
	CComQIPtr<VCProject> pProj = pDisp;
	if( pProj )
	{
 		hr = pProj->get_ProjectFile( &bstrFullPath );
		RETURN_ON_FAIL(hr);

		// CoTaskMemAlloc arrays
		pCaStringsOut->cElems = 1;
		pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( pCaStringsOut->cElems * sizeof(LPOLESTR) );
		pCaFlagsOut->cElems = 1;
		pCaFlagsOut->pElems = (DWORD*)CoTaskMemAlloc( pCaFlagsOut->cElems * sizeof(DWORD) );
		// set arrays
		pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (bstrFullPath.Length() + 1) * sizeof( OLECHAR ) );
		wcscpy( pCaStringsOut->pElems[0], bstrFullPath );
		pCaFlagsOut->pElems[0] = 0;

		return S_OK;
	}

	// other kinds of nodes don't have files in scc
	return S_OK;
}

//---------------------------------------------------------------------------
// Interface: IVsSccProject2
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetSccSpecialFiles( 
	/* [in] */ VSITEMID,
	/* [in] */ LPCOLESTR,
	/* [out] */ CALPOLESTR*,
	/* [out] */ CADWORD*)
{
	VSASSERT(false, "Zero flags above means this shouldn't be called, so GetSccSpecialFiles isn't needed.");
	return E_FAIL;
}

//---------------------------------------------------------------------------
// CVCArchy::RegisterSccProject
// Send our opaque source code control settings to the scc manager.
// This called just after opening a project.
//---------------------------------------------------------------------------
HRESULT CVCArchy::RegisterSccProject()
{
	// if we have an SccProjectName property, we're under scc, proceed
	// call the IVsSccManager2 impl to register the project
	
	HRESULT hr = S_OK;
	CComBSTR bstrSccProjectName, bstrSccAuxPath, bstrSccLocalPath, bstrSccProvider;

	CComPtr<CVCProjectNode> pVcNode = GetProjectNode();
	RETURN_ON_NULL2(pVcNode, E_UNEXPECTED);
	CComPtr<IDispatch> pDisp = pVcNode->m_dispkeyItem;
	CComQIPtr<VCProject> pProject = pDisp;
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

 	if( m_fRegisteredWithScc )
		return S_OK;	// already done

    CComPtr<IVsSccManager2> srpSccManager;
	if (GetBuildPkg())
		GetBuildPkg()->GetSccManager(&srpSccManager);
	RETURN_ON_NULL2(srpSccManager, S_FALSE);

	CComPtr<IVsSccProject2> spSccProj = VCQI_cast<IVsSccProject2>(this);
	pProject->get_SccProjectName( &bstrSccProjectName ),
	pProject->get_SccAuxPath( &bstrSccAuxPath ),
	pProject->get_SccLocalPath( &bstrSccLocalPath ),
	pProject->get_SccProvider( &bstrSccProvider ),
 	hr = srpSccManager->RegisterSccProject(spSccProj, bstrSccProjectName, bstrSccAuxPath, bstrSccLocalPath, bstrSccProvider);
	m_fRegisteredWithScc = true;

	return hr;
}

HRESULT CVCArchy::UnregisterSccProject()
{
    if (!m_fRegisteredWithScc)
		return S_OK;	// nothing to do

    CComPtr<IVsSccManager2> srpSccManager;
	if (GetBuildPkg())
		GetBuildPkg()->GetSccManager(&srpSccManager);
	RETURN_ON_NULL2(srpSccManager, S_FALSE);
	m_fRegisteredWithScc = false;

    return srpSccManager->UnregisterSccProject(this);
}

STDMETHODIMP CVCArchy::ReadUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	CHECK_READ_POINTER_NULL(pStream);
		
	CComPtr<VCProject> pProject;
	GetVCProject( NULL, &pProject );
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	CComPtr<IUnknown> spStreamUnk;
	pStream->QueryInterface(IID_IUnknown, (void **) &spStreamUnk);
	pProject->LoadProjectOptions(spStreamUnk);
	return S_OK;
}

STDMETHODIMP CVCArchy::WriteUserOptions(IStream *pStream, LPCOLESTR pszKey)
{
	CHECK_READ_POINTER_NULL(pStream);

	CComPtr<VCProject> pProject;
	GetVCProject( NULL, &pProject );
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	CComPtr<IUnknown> spStreamUnk;
	pStream->QueryInterface(IID_IUnknown, (void **) &spStreamUnk);
	pProject->SaveProjectOptions(spStreamUnk);

	return S_OK;
}

STDMETHODIMP CVCArchy::ParseCanonicalName(LPCOLESTR pszName, VSITEMID *pitemid)
{
	CHECK_POINTER_NULL(pitemid);

	*pitemid = ItemIDFromName(NULL, pszName);
	RETURN_ON_NULL(*pitemid);
	return S_OK;
}

HRESULT CVCArchy::InformConfigurationAdded( LPOLESTR pszCfgName )
{
	if (m_pCfgProviderEventsHelper)
 		return m_pCfgProviderEventsHelper->NotifyOnCfgNameAdded( pszCfgName );
	else
		return S_OK;
}

HRESULT CVCArchy::InformConfigurationRemoved( LPOLESTR pszCfgName )
{
	if (m_pCfgProviderEventsHelper)
 		return m_pCfgProviderEventsHelper->NotifyOnCfgNameDeleted( pszCfgName );
	else
		return S_OK;
}

HRESULT CVCArchy::InformConfigurationRenamed( LPOLESTR pszOldCfgName, LPOLESTR pszNewCfgName )
{
	if (m_pCfgProviderEventsHelper)
 		return m_pCfgProviderEventsHelper->NotifyOnCfgNameRenamed( pszOldCfgName, pszNewCfgName );
	else
		return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Called to set the IServerProvider site. 
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SetSite(
			/* [in] */ IServiceProvider *pSP)
{
	VSASSERT(NULL != pSP, "Trying to SetSite without a service provider!");
	CHECK_READ_POINTER_NULL(pSP);
	m_srpServiceProvider = pSP;

	HRESULT hr;
	hr = pSP->QueryService(SID_SVsShellMonitorSelection,
							IID_IVsMonitorSelection,
							(void **)&m_srpMonSel);
	VSASSERT(SUCCEEDED(hr), "Failed QueryService for SID_SVsShellMonitorSelection");
	VSASSERT(m_srpMonSel != NULL, "Failed to pick up IVsMonitorSelection pointer");
	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Called to get the IServerProvider site.
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetSite(
			/* [out] */ IServiceProvider **ppSP)
{
	CHECK_POINTER_NULL(ppSP);
	return m_srpServiceProvider.CopyTo(ppSP);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// 
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::QueryClose(BOOL *pfCanClose)
{
	CHECK_POINTER_NULL(pfCanClose);
	*pfCanClose = TRUE;

	CVCProjectNode* pProjNode = GetProjectNode();
	RETURN_ON_NULL2(pProjNode, S_OK);

	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = pProjNode->GetActiveConfig(&spGenCfg);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spGenCfg, S_OK);

	BOOL bNoBuild = TRUE;
	spGenCfg->get_NoBuildIsInProgress(&bNoBuild);
	if (bNoBuild)
		return S_OK;

	// if we got here, then we're doing a build and we cannot shut down in that case
	*pfCanClose = FALSE;
	return E_FAIL;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Returns the guidType for the itemid.
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetGuidProperty(
			/* [in] */ VSITEMID itemid,
			/* [in] */ VSHPROPID propid,
			/* [out] */ GUID *pguid)
{
	CHECK_POINTER_NULL(pguid);
	*pguid = IID_NULL;

	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_NULL2(pNode, E_UNEXPECTED);

	return pNode->GetGuidProperty(propid, pguid);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Returns the guidType for the itemid.
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SetGuidProperty(/* [in] */ VSITEMID itemid, /* [in] */ VSHPROPID propid, /* [in] */ REFGUID guid)
{
	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_NULL2(pNode, E_UNEXPECTED);

	return pNode->SetGuidProperty(propid, guid);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Returns the nested hierarchy for item id. 
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetNestedHierarchy(/* [in] */ VSITEMID itemid, /* [in] */ REFIID iidHierarchyNested,
	/* [iid_is][out] */ void  **ppHierarchyNested, /* [out] */ VSITEMID *pitemidNested)
{
	return E_NOTIMPL;	// CVCArchy::GetNestedHierarchy
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Returns the canonical name for itemid.
//
// For web hierarchies this is its absolute url?
// For db hierarchies this is??
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetCanonicalName(
			/* [in] */ VSITEMID itemid,
			/* [out] */ BSTR *pbstrName)
{
	CHECK_POINTER_NULL(pbstrName);

	CVCNode*	pNode = NULL;
	HRESULT		hr = VSITEMID2Node(itemid, &pNode);
	VSASSERT(pNode != NULL, "Failed to convert itemid to hier node!");
	RETURN_ON_FAIL_OR_NULL(hr, pNode);

	return pNode->GetCanonicalName(pbstrName);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Returns our toplevel project automation object
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetAutomationObject(/* [out] */ IDispatch  **ppdisp)
{
	CHECK_POINTER_VALID(ppdisp);
	*ppdisp = NULL;

	return E_NOTIMPL;	// CVCArchy::GetAutomationObject
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::AdviseHierarchyEvents(
			/* [in] */ IVsHierarchyEvents *pEventSink,
			/* [out] */ VSCOOKIE *pdwCookie)
{
	CHECK_READ_POINTER_NULL(pEventSink);
	CHECK_POINTER_NULL(pdwCookie);

	EventSink *pSink = new EventSink;
	RETURN_ON_NULL2(pSink, E_OUTOFMEMORY);

	pSink->m_srpEventSink = pEventSink;
	 
	 ++g_dwCookie;
	pSink->m_dwCookie = (DWORD) g_dwCookie;
	*pdwCookie = g_dwCookie;

	VSASSERT(*pdwCookie, "VsShell doesn't like cookies of 0");

	m_rgEventSinks.Add(pSink);
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::UnadviseHierarchyEvents(
			/* [in] */ VSCOOKIE dwCookie)
{
	int n = m_rgEventSinks.GetSize();
	for (int i = 0; i < n; ++i)
	{
		if (m_rgEventSinks[i]->m_dwCookie == dwCookie)
		{
			delete m_rgEventSinks[i];
			m_rgEventSinks.RemoveAt(i);
			return S_OK;
		}
	}
	VSASSERT(0 != dwCookie && dwCookie <= g_dwCookie, "unadvising an unknown cookie!"); 
	VSASSERT(0 == dwCookie || g_dwCookie < dwCookie, "unadvising a cookie twice!");
	return E_FAIL;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Allows for a binary-comapatible change.	Needed since IVsUIHierarchy 
// derrives from IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Unused0(void)
{
	return E_NOTIMPL;	// CVCArchy::Unused0
}


//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Allows for a binary-comapatible change.	Needed since IVsUIHierarchy 
// derrives from IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Unused1(void)
{
	return E_NOTIMPL;	// CVCArchy::Unused1
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Allows for a binary-comapatible change.	Needed since IVsUIHierarchy 
// derrives from IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Unused2(void)
{
	return E_NOTIMPL;	// CVCArchy::Unused2
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Allows for a binary-comapatible change.	Needed since IVsUIHierarchy 
// derrives from IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Unused3(void)
{
	return E_NOTIMPL;	// CVCArchy::Unused3
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Allows for a binary-comapatible change.	Needed since IVsUIHierarchy 
// derrives from IVsHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Unused4(void)
{
	return E_NOTIMPL;	// CVCArchy::Unused4
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy helper function
// Returns the requested property for the CVCNode.
// There are several of properties handled on the VsHierarchy level
//---------------------------------------------------------------------------
HRESULT CVCArchy::GetProperty(
			/* [in] */ CVCNode *pNode,
			/* [in] */ VSHPROPID propid,
			/* [out] */ VARIANT *pvar)
{
	VSASSERT(!IsZombie(), "Calling GetProperty when zombied!");
	// CHECK_READ_POINTER_NULL(pNode);
	// CHECK_POINTER_NULL(pvar);

	HRESULT hr = S_OK;
	switch (propid)
	{
	case VSHPROPID_Parent:
		V_VT(pvar) = VT_INT_PTR;
		V_INT_PTR(pvar) = (pNode->GetParent() != NULL) ? pNode->GetParent()->GetVsItemID() : VSITEMID_NIL;
		break;

	case VSHPROPID_NextSibling:
		V_VT(pvar) = VT_INT_PTR;
		V_INT_PTR(pvar) = (pNode->GetNext() != NULL) ? pNode->GetNext()->GetVsItemID() : VSITEMID_NIL;
		break;

	case VSHPROPID_Root:			// VsHierarchy property
		V_VT(pvar) = VT_INT_PTR;	// this is useless according to spec
		V_INT_PTR(pvar) = VSITEMID_ROOT;
		break;

	case VSHPROPID_IconImgList:		// VsHierarchy property
		V_VT(pvar) = VT_INT_PTR;
		V_INT_PTR(pvar) = (INT_PTR)(GetImageList());
		break;

	case VSHPROPID_IconIndex:		// VsHierarchy derived property
		V_VT(pvar) = VT_I4;
		V_I4(pvar) = static_cast<INT>(GetIconIndex(pNode, ICON_Closed));
		break;

	case VSHPROPID_OpenFolderIconIndex:
		V_VT(pvar) = VT_I4;
		V_I4(pvar) = static_cast<INT>(GetIconIndex(pNode, ICON_Open));
		break;

	case VSHPROPID_SelContainer:
		// REVIEW: should we return E_NOINTERFACE
		hr = E_NOINTERFACE;
		break;

	case VSHPROPID_StateIconIndex:
		V_VT(pvar) = VT_I4;
		V_I4(pvar) = static_cast<INT>(GetIconIndex(pNode, ICON_StateImage));
		break;
		
	case VSHPROPID_ShowProjInSolutionPage:
		V_VT(pvar) = VT_BOOL;
		V_BOOL(pvar) = VARIANT_TRUE;
		break;


	case VSHPROPID_ParentHierarchy:
		hr = S_OK;
//		VSASSERT(pNode->GetVsItemID() == VSITEMID_ROOT, "Parent hierarchy only available for root node!");
		V_VT(pvar) = VT_UNKNOWN;
		V_UNKNOWN(pvar) = m_pParentHierarchy;
		if (NULL != V_UNKNOWN(pvar))
			V_UNKNOWN(pvar)->AddRef();
		break;

	case VSHPROPID_ParentHierarchyItemid:
		hr = S_OK;
//		VSASSERT(pNode->GetVsItemID() == VSITEMID_ROOT, "Parent hierarchy itemid only available for root node!");
		V_VT(pvar) = VT_INT_PTR;
		V_INT_PTR(pvar) = m_dwParentHierarchyItemid;
		break;

	default:
		return pNode->GetProperty(propid, pvar);
	}
	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Returns the requested property for the itemid.
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetProperty( 
			/* [in] */ VSITEMID itemid,
			/* [in] */ VSHPROPID propid,
			/* [out] */ VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);
	VariantInit(pvar);

	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	VSASSERT(NULL != pNode, "Failed to convert itemid to hierarchy node!");
	RETURN_ON_FAIL_OR_NULL(hr, pNode);
	
	return GetProperty(pNode, propid, pvar);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Set's the given property on the item specified by itemid. 
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SetProperty(
			/* [in] */ VSITEMID itemid,
			/* [in] */ VSHPROPID propid,
			/* [in] */ VARIANT var)
{
	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	VSASSERT(NULL != pNode, "Failed to convert itemid to hier node!");
	RETURN_ON_FAIL_OR_NULL(hr, pNode);

	return SetProperty(pNode, propid, var);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchy
// Set's the given property on the item specified by itemid. 
//---------------------------------------------------------------------------
HRESULT CVCArchy::SetProperty(
			/* [in] */ CVCNode *pNode,
			/* [in] */ VSHPROPID propid,
			/* [in] */ const VARIANT& var)
{
	CHECK_READ_POINTER_NULL(pNode);
	VSASSERT(!IsZombie(), "SetProperty called on zombied object!");

	HRESULT hr = E_INVALIDARG;

	switch (propid)
	{
	case VSHPROPID_ExpandByDefault:		// CVCBaseFolderNode property
	case VSHPROPID_Expanded:
		pNode->SetProperty(propid, var);
		break;

	case VSHPROPID_Caption:			// CVCNode property
		VSASSERT(VT_BSTR == V_VT(&var) && ::SysStringLen(V_BSTR(&var)), "Invalid parameter type passed!");
		if (VT_BSTR == V_VT(&var) && ::SysStringLen(V_BSTR(&var)))
		{	// don't allow empty string setting
			pNode->SetCaption(V_BSTR(&var));
			OnPropertyChanged(pNode, propid, 0);
		}
		break;

	case VSHPROPID_ParentHierarchy:
		VSASSERT(VT_UNKNOWN == V_VT(&var), "Invalid parameter type passed!");
		if (VT_UNKNOWN == V_VT(&var))
		{
			m_pParentHierarchy = V_UNKNOWN(&var);	// NOTE: hold as UNADDREF'ed pointer
			hr = S_OK;
		}
		break;

	case VSHPROPID_ParentHierarchyItemid:
		VSASSERT(VT_INT_PTR == V_VT(&var), "Invalid parameter type passed!");
		if (VT_INT_PTR == V_VT(&var))
		{
			m_dwParentHierarchyItemid = V_INT_PTR(&var);
			hr = S_OK;
		}
		break;

	default:
		hr = pNode->SetProperty(propid, var);
	}
	return	hr;
}

//---------------------------------------------------------------------------
// interface: IVsUIHierarchy
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::QueryStatusCommand( 
			/* [in] */		  VSITEMID	   itemid, 
			/* [in, unique] */ const GUID * pguidCmdGroup,
			/* [in] */		  ULONG cCmds,
			/* [in, out, size_is(cCmds)] */ OLECMD prgCmds[],
			/* [in, out, unique] */ OLECMDTEXT *pCmdText)
{
	HierNodeList rgNodeList;
	HRESULT hr = VSITEMID2Node(itemid, rgNodeList);
	RETURN_ON_FAIL(hr);

	return QueryStatusSelection(pguidCmdGroup, cCmds, prgCmds, pCmdText, rgNodeList, TRUE);
}

//---------------------------------------------------------------------------
// interface: IVsUIHierarchy
// Called to execute the cmdid from the guidCmdSet on the itemid. If itemid = 
// VSITEMID_SELECTED (the normal case), the command is applied to the selected
// items.
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::ExecCommand( 
			/* [in] */		  VSITEMID	   itemid, 
			/* [in, unique] */ const GUID * pguidCmdGroup,
			/* [in] */		  DWORD		   nCmdID,
			/* [in] */		  DWORD		   nCmdexecopt,
			/* [in, unique] */ VARIANT *	pvaIn,
			/* [in, out, unique] */ VARIANT* pvaOut)
{
	CVCNode *pNode = NULL;
	HierNodeList rgNodeList;
	HRESULT hr = VSITEMID2Node(itemid, rgNodeList);
	RETURN_ON_FAIL2(hr, OLECMDERR_E_NOTSUPPORTED);
	
	// Handle std hierarchy commands here
	if(*pguidCmdGroup == GUID_VsUIHierarchyWindowCmds)
	{
		switch(nCmdID)
		{
			case UIHWCMDID_RightClick:
				// NOTE: Normally the IOleCommandTarget for the IVsHierarchy is not allowed to 
				// handle commands like Cut, Copy, Paste, Delete, Renmame during the current
				// hierarchy point in the command routing. These type of commands should only
				// apply to the object with focus. For example, it is very undesierable if 
				// executing the Edit.Delete command while focus is in a document window was
				// handled by the project to delete the select project item (i.e. the open 
				// document). For a hierarchy these commands are normally processed via
				// IVsUIHierarchy::ExecCommand. But in the case of bringing up a context menu
				// we know that the hierarchy has focus, thus these commands are valid. In order
				// to communicate this fact to our IOleCommandTarget implementation we set
				// the "m_fInContextMenu" flag.
				hr = DisplayContextMenu(rgNodeList,pvaIn);
				break;
			case UIHWCMDID_DoubleClick:
			case UIHWCMDID_EnterKey:
				do
				{
					pNode = rgNodeList.RemoveHead();
					hr = pNode->DoDefaultAction(FALSE);
				} while(SUCCEEDED(hr) && !rgNodeList.IsEmpty());
				break;
			default:
				hr = OLECMDERR_E_NOTSUPPORTED;
				break;
		}
	}
	else
	{	// Pass command to nodes Exec command
		hr = ExecSelection(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut, rgNodeList, TRUE);

	}

	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsPersistHierarchyItem
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::IsItemDirty(
		/* [in] */ VSITEMID,	//vsid,
		/* [in] */ IUnknown *punkDocData,
		/* [out] */ BOOL *pfDirty)
{
	CHECK_READ_POINTER_NULL(punkDocData);
	CHECK_POINTER_NULL(pfDirty);
	*pfDirty = FALSE;

	CComQIPtr<IVsPersistDocData> srpPersistDocData;
	HRESULT hr = punkDocData->QueryInterface(IID_IVsPersistDocData, (void**)&srpPersistDocData);
	RETURN_ON_FAIL_OR_NULL(hr, srpPersistDocData);

	return srpPersistDocData->IsDocDataDirty(pfDirty);
}

//---------------------------------------------------------------------------
// interface: IVsPersistHierarchyItem
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::SaveItem(
		/* [in] */ VSSAVEFLAGS dwSave,
		/* [in] */ LPCOLESTR lpstrMkDocument,
		/* [in] */ VSITEMID itemid,
		/* [in] */ IUnknown *punkDocData,
		/* [out] */ BOOL *pfCanceled)
{
	CHECK_READ_POINTER_NULL(punkDocData);
	CHECK_POINTER_NULL(pfCanceled);

	HRESULT hr = S_OK;

	CComQIPtr<IVsPersistDocData> srpPersistDocData;
	srpPersistDocData = punkDocData;
	RETURN_ON_NULL(srpPersistDocData);

	CComBSTR bstrMkDocumentNew;
	hr = srpPersistDocData->SaveDocData(dwSave, &bstrMkDocumentNew, pfCanceled);

	if (FAILED(hr) || dwSave != VSSAVE_SaveAs)
		return hr;

	// get the document window frame
	CComPtr<IVsUIShellOpenDocument> pOpenDoc;
	hr = ExternalQueryService( SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, (void **)&pOpenDoc );
	RETURN_ON_FAIL_OR_NULL(hr, pOpenDoc);

	BOOL bIsOpen;
	CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(this);
	CComPtr<IVsWindowFrame> pWindowFrame;
	hr = pOpenDoc->IsDocumentOpen( spHier, itemid, lpstrMkDocument, GUID_NULL, IDO_IgnoreLogicalView, NULL, NULL, &pWindowFrame, &bIsOpen );
	RETURN_ON_FAIL_OR_NULL(hr, pWindowFrame);

	BOOL bFound;
	VSITEMID itemidFound = VSITEMID_NIL;
	CComPtr<IVsUIHierarchy> pHierarchy;
	CComQIPtr<IVsProject3> pProject3;

	// is this file in a project?
	hr = pOpenDoc->IsDocumentInAProject( bstrMkDocumentNew, &pHierarchy, &itemidFound, NULL, &bFound );
	if( bFound )
	{
		pProject3 = pHierarchy;
		if( !pProject3 )
			return E_FAIL;
		// transfer the document to that project
		hr = pProject3->TransferItem( lpstrMkDocument, bstrMkDocumentNew, pWindowFrame );
	}
	else
	{
		// obtain external files manager and transfer the document
		CComPtr<IVsExternalFilesManager> pExtFilesMgr;
		hr = ExternalQueryService( SID_SVsExternalFilesManager, IID_IVsExternalFilesManager, (void **)&pExtFilesMgr);
		RETURN_ON_FAIL_OR_NULL(hr, pExtFilesMgr);
		// transfer the document to the external files project
		hr = pExtFilesMgr->TransferDocument( lpstrMkDocument, bstrMkDocumentNew, pWindowFrame );
	}

	return hr;
}

//---------------------------------------------------------------------------
// interface: IOleCommandTarget
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::QueryStatus( 
			/* [unique][in] */ const GUID *pguidCmdGroup,
			/* [in] */ ULONG cCmds,
			/* [out][in][size_is] */ OLECMD prgCmds[  ],
			/* [unique][out][in] */ OLECMDTEXT *pCmdText)
{
	VSASSERT(GetRootNode() != NULL, "No root node!");
	RETURN_ON_NULL2(m_srpMonSel, E_UNEXPECTED);

	// Because QueryStatus() is called OFTEN(!) and the selection is almost
	// always a single item, we check for that case FIRST in the following inline code

	// find out if we have a single selection or a multi-selection
	HRESULT hr;
	VSITEMID itemid;						// if VSITEMID_SELECTION then multiselection
	CVCNode *pNode = NULL;
	CComPtr<IVsHierarchy> srpIVsHierarchy;	// if NULL then selection spans VsHierarchies
	CComPtr<IVsMultiItemSelect> srpIVsMultiItemSelect;
	CComPtr<ISelectionContainer> srpISelectionContainer;		// unused?
	CComPtr<IVsHierarchy> spThisHier = VCQI_cast<IVsHierarchy>(this);

	hr = m_srpMonSel->GetCurrentSelection(&srpIVsHierarchy, &itemid, &srpIVsMultiItemSelect, &srpISelectionContainer);
	RETURN_ON_FAIL(hr);

	// if we're not selected, but the shell still calls us (this does happen)
	if (srpIVsHierarchy != NULL && srpIVsHierarchy != spThisHier)
		return E_UNEXPECTED;
	// nothing selected
	if (VSITEMID_NIL == itemid)
	{
		VSASSERT(SUCCEEDED(hr), "Nothing selected!");
		return hr;
	}
	// single selection
	if (VSITEMID_SELECTION != itemid)
	{
		VSASSERT(srpIVsHierarchy == spThisHier, "Hierarchy isn't what we expected!");	// shouldn't be NULL

		hr = VSITEMID2Node(itemid, &pNode);
		if( FAILED( hr ) )
			return hr;
		// QueryStatus on this node only
		hr = pNode->QueryStatus( pguidCmdGroup, cCmds, prgCmds, pCmdText );
	}
	// multi-selection
	else
	{
		HierNodeList rgNodes;

		if (NULL == pguidCmdGroup)
		{
			hr = OLECMDERR_E_UNKNOWNGROUP;
		}
		else 
		{
			hr = GetSelectedNodes(rgNodes);
			if (SUCCEEDED(hr))
			{
				hr = QueryStatusSelection(pguidCmdGroup, cCmds, prgCmds, pCmdText, rgNodes, FALSE);
			}
			else
			{
				// Its safer to return OLECMDERR_E_NOTSUPPORTED to shell rather than return failure
				// indicating that we actually handle the command.
				hr = OLECMDERR_E_NOTSUPPORTED;
			}
		}
	}

	return hr;
}

//---------------------------------------------------------------------------
// interface: IOleCommandTarget
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Exec( 
			/* [unique][in] */ const GUID *pguidCmdGroup,
			/* [in] */ DWORD nCmdID,
			/* [in] */ DWORD nCmdexecopt,
			/* [unique][in] */ VARIANT *pvaIn,
			/* [unique][out][in] */ VARIANT *pvaOut)
{
	VSASSERT(GetRootNode() != NULL, "No root node!");

	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);

	HierNodeList rgNodes;
	HRESULT hr = GetSelectedNodes(rgNodes);
	RETURN_ON_FAIL2(hr, OLECMDERR_E_NOTSUPPORTED);	// Its safer to return OLECMDERR_E_NOTSUPPORTED to shell rather than 
													// return failure indicating that we actually handle the command.

	return ExecSelection(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut, rgNodes, FALSE);
}

//---------------------------------------------------------------------------
// call OnItemAdded for each listed IVsHierarchyEvent sink
//---------------------------------------------------------------------------
HRESULT CVCArchy::OnItemAdded(CVCNode *pNodeParent, CVCNode *pNodePrev, CVCNode *pNodeAdded) const
{
	CHECK_READ_POINTER_NULL(pNodeParent);
	CHECK_READ_POINTER_NULL(pNodeAdded);
	VSITEMID itemidParent = pNodeParent->GetVsItemID();
	VSITEMID itemidSiblingPrev = (NULL != pNodePrev) ? pNodePrev->GetVsItemID(): VSITEMID_NIL;
	VSITEMID itemidAdded = pNodeAdded->GetVsItemID();

	int n = m_rgEventSinks.GetSize();
	for (int i = 0; i < n; ++i)
	{
		HRESULT hr = E_FAIL;
		if (m_rgEventSinks[i]->m_srpEventSink)
			hr = m_rgEventSinks[i]->m_srpEventSink->OnItemAdded(itemidParent, itemidSiblingPrev, itemidAdded);
		VSASSERT(SUCCEEDED(hr), "Failed during OnItemAdded!");
	}
	return S_OK;
}

//---------------------------------------------------------------------------
// call OnItemDeleted for each listed IVsHierarchyEvent sink
//
// ASSUMPTION: pNode may be in the middle of the destructor
//			   but CVCNode::GetVsItemID okay to call
//---------------------------------------------------------------------------
HRESULT CVCArchy::OnItemDeleted(CVCNode *pNode) const
{
	RETURN_ON_NULL(pNode);

	VSITEMID itemid = pNode->GetVsItemID();
	int n = m_rgEventSinks.GetSize();
	for (int i = 0; i < n; ++i)
	{
		HRESULT hr = E_FAIL;
		if (m_rgEventSinks[i]->m_srpEventSink)
			hr = m_rgEventSinks[i]->m_srpEventSink->OnItemDeleted(itemid);
		VSASSERT(SUCCEEDED(hr), "Failed during OnItemDeleted!");
	}
	return S_OK;
}

//---------------------------------------------------------------------------
// call OnPropertyChanged for each listed IVsHierarchyEvent sink
//---------------------------------------------------------------------------
HRESULT CVCArchy::OnPropertyChanged(CVCNode *pNode, VSHPROPID propid, DWORD flags) const
{
	VSITEMID itemid = pNode->GetVsItemID();
	int n = m_rgEventSinks.GetSize();
	for (int i = 0; i < n; ++i)
	{
		HRESULT hr = E_FAIL;
		if (m_rgEventSinks[i]->m_srpEventSink)
			hr = m_rgEventSinks[i]->m_srpEventSink->OnPropertyChanged(itemid, propid, flags);
		VSASSERT(SUCCEEDED(hr), "Failed during OnPropertyChanged!");
	}
	return S_OK;
}

//---------------------------------------------------------------------------
// call OnInvalidateItems for each listed IVsHierarchyEvent sink
//
// ASSUMPTION: pNode may be in the middle of the destructor
//			   but CVCNode::GetVsItemID okay to call
//---------------------------------------------------------------------------
HRESULT CVCArchy::OnInvalidateItems(CVCNode *pNode) const
{
	VSITEMID itemid = pNode->GetVsItemID();
	int n = m_rgEventSinks.GetSize();
	for (int i = 0; i < n; ++i)
	{
		HRESULT hr = E_FAIL;
		if (m_rgEventSinks[i]->m_srpEventSink)
			hr = m_rgEventSinks[i]->m_srpEventSink->OnInvalidateItems(itemid);
		VSASSERT(SUCCEEDED(hr), "Failed during OnInvalidateItems!");
	}
	return S_OK;
}

//---------------------------------------------------------------------------
// call OnInvalidateIcon for each listed IVsHierarchyEvent sink
//---------------------------------------------------------------------------
HRESULT CVCArchy::OnInvalidateIcon(HICON hIcon) const
{
	int n = m_rgEventSinks.GetSize();
	for (int i = 0; i < n; ++i)
	{
		HRESULT hr = E_FAIL;
		if (m_rgEventSinks[i]->m_srpEventSink)
			hr = m_rgEventSinks[i]->m_srpEventSink->OnInvalidateIcon(hIcon);
		VSASSERT(SUCCEEDED(hr), "Failed during OnInvalidateIcon!");	// annoying for other uses, but still needed to find why
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// CVCArchy::DisplayContextMenu
//-----------------------------------------------------------------------------
HRESULT CVCArchy::DisplayContextMenu(HierNodeList &rgSelection, VARIANT *pvaIn)
{
	// if the delete command is called, we could be destroyed
	// when 'm_bInContextMenu = FALSE;' is called
	CComPtr<IVsHierarchy> srpSafety = VCQI_cast<IVsHierarchy>(this);

	CVCNode *pNode = NULL;

	if (rgSelection.GetCount() == 1)
	{
		pNode = rgSelection.GetHead();
		VSASSERT(pNode, "Selection contains a NULL head even though there's an element in the list!");
		if (pNode)
			pNode->DisplayContextMenu(pvaIn);
    }
	// handle multiple selected nodes
	else if (rgSelection.GetCount() > 1)
	{
		VCPOSITION pos;
		unsigned int firstKind;
		bool bNodeTypesDiffer = false;

		// determine if the selection in homogenous
		pos = rgSelection.GetHeadPosition();
		VSASSERT( pos, "Selection count differs from actual contents" );
		pNode = rgSelection.GetNext( pos );
		firstKind = pNode->GetKindOf();
		while( pos != NULL )
		{
			pNode = rgSelection.GetNext( pos );
			if( pNode->GetKindOf() != firstKind )
				bNodeTypesDiffer = true;
			VSASSERT(pNode, "Selection contains a NULL item in the list!");
		}
		VSASSERT(pNode, "Selection contains a NULL item in the list!");

		// display the appropriate menu
		if( bNodeTypesDiffer )
		{
			CComPtr<IOleCommandTarget> spTarget = VCQI_cast<IOleCommandTarget>(this);
			static_cast<CVCNode*>(pNode)->ShowContextMenu( IDM_VS_CTXT_XPROJ_MULTIITEM, pvaIn, guidSHLMainMenu,	 spTarget);
		}
		else
			pNode->DisplayContextMenu(pvaIn);
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// CVCArchy::QueryStatusSelection
//-----------------------------------------------------------------------------
HRESULT CVCArchy::QueryStatusSelection(
	const GUID *pguidCmdGroup,
	ULONG cCmds,
	OLECMD prgCmds[],
	OLECMDTEXT *pCmdText,
	HierNodeList &rgSelection,
	BOOL		 bIsHierCmd)		// TRUE if cmd originated via CVSUiHierarchy::ExecCommand
{
	HRESULT hr = S_OK;
	OLECMD cmdTmp;
	bool bSupported = false;
	bool bEnabled = true;
	bool bInvisible = false;
	bool bLatched = true;
	
	VSASSERT( pguidCmdGroup, "NULL command group GUID!" );
	VSASSERT( cCmds == 1, "We don't know how to handle situation where more than one command is being asked after" );

	for( VCPOSITION pos = rgSelection.GetHeadPosition(); pos != NULL && SUCCEEDED( hr ); )
	{
		cmdTmp.cmdID = prgCmds[0].cmdID;
		cmdTmp.cmdf = 0;
		CVCNode *pNode = rgSelection.GetNext( pos );
		hr = pNode->QueryStatus( pguidCmdGroup, cCmds, &cmdTmp, pCmdText );
		if( SUCCEEDED( hr ) || hr == OLECMDERR_E_NOTSUPPORTED )
		{			
			// cmd is supported if any node supports cmd
			// cmd is enabled if all nodes enable cmd
			// cmd is invisible if any node sets invisibility
			// cmd is latched only if all are latched
			bSupported = bSupported || (cmdTmp.cmdf & OLECMDF_SUPPORTED);
			bEnabled = bEnabled && (cmdTmp.cmdf & OLECMDF_ENABLED);
			bInvisible = bInvisible || (cmdTmp.cmdf & OLECMDF_INVISIBLE);
			bLatched = bLatched && (cmdTmp.cmdf & OLECMDF_LATCHED);
			// optimization
			if( !bSupported || bInvisible )
				break;
		}
		else
		{
			bSupported = false;
			bEnabled = false;
			bInvisible = false;
			bLatched = false;
		}
	}
	prgCmds[0].cmdf = 0;

	if( bSupported )
		prgCmds[0].cmdf |= OLECMDF_SUPPORTED;
	if( bEnabled )
		prgCmds[0].cmdf |= OLECMDF_ENABLED;
	if( bInvisible )
		prgCmds[0].cmdf |= OLECMDF_INVISIBLE;
	if( bLatched )
		prgCmds[0].cmdf |= OLECMDF_LATCHED;

	return hr;
}

//-----------------------------------------------------------------------------
// CVCArchy::ExecSelection
//-----------------------------------------------------------------------------
HRESULT CVCArchy::ExecSelection(
	const GUID *pguidCmdGroup,
	DWORD nCmdID,
	DWORD nCmdexecopt,
	VARIANT *pvaIn,
	VARIANT *pvaOut,
	HierNodeList &rgSelection,
	BOOL		 bIsHierCmd)	// TRUE if cmd originated via CVSUiHierarchy::ExecCommand
{
	VSASSERT(NULL != GetProjectNode(), "No project node!  Is this hierarchy zombie?");
	CHECK_ZOMBIE(GetProjectNode(), IDS_ERR_PROJ_ZOMBIE);

	if (*pguidCmdGroup == guidVSStd2K)
	{
		if (nCmdID == ECMD_COMPILE)
			return CompileFileItems(rgSelection);
	}
	else if (*pguidCmdGroup == guidVSStd97)
	{
		if (nCmdID == cmdidCut)
			return OnCommandCut();
		else if (nCmdID == cmdidCopy)
			return OnCommandCopy();
	}

	HRESULT hr = S_OK;
	VCPOSITION pos = rgSelection.GetHeadPosition();
	if (pos == NULL)
		hr = OLECMDERR_E_NOTSUPPORTED;
	if( SUCCEEDED(hr) )
	{
		HRESULT hr2 = S_OK;
		while( pos != NULL )
		{
			CVCNode *pNode = rgSelection.GetNext(pos);
			//$UNDONE: This enables a superset of commands - not the intersection
			//$CONSIDER: What is correct behavior if command fails or is canceled?
			if (FAILED(hr2 = pNode->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut)))
			{
				// record the failure code, but continue with the exec.
				hr = hr2;
			}
		}
	}
	return hr;
}

CVCNode* CVCArchy::ResolveProjNode(CVCNode* pNode)
{
	CVCNode* pTmpNode = NULL;
	if (pNode)
		pTmpNode = pNode;
	else
	{
		HRESULT hr = VSITEMID2Node(VSITEMID_ROOT, &pTmpNode);
		RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pTmpNode, NULL);
	}
	return static_cast<CVCNode*>(pTmpNode);
}

HRESULT CVCArchy::GetVCProject(CVCNode* pNode, VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;

	CVCNode* pProj = ResolveProjNode(pNode);
	RETURN_ON_NULL(pProj);

	pProj->GetVCProject(ppProject);
	return S_OK;
}

HRESULT CVCArchy::GetDispVCProject(CVCNode* pNode, IDispatch** ppDispProject)
{
	CHECK_POINTER_NULL(ppDispProject);
	*ppDispProject = NULL;

	CVCNode* pProj = ResolveProjNode(pNode);
	RETURN_ON_NULL(pProj);

	pProj->GetDispVCProject(ppDispProject);
	return S_OK;
}

HRESULT CVCArchy::CreateGenCfg(VCConfiguration* pProjCfg, IVCGenericConfiguration** ppGenCfg)
{
	CHECK_READ_POINTER_NULL(pProjCfg);
	CHECK_POINTER_NULL(ppGenCfg);
	*ppGenCfg = NULL;

	CComPtr<IVsCfg> spVsCfg;
	HRESULT hr = CGenCfg::CreateInstance(&spVsCfg, this, pProjCfg);
	CComQIPtr<IVCGenericConfiguration> spVCGenCfg = spVsCfg;

	RETURN_ON_FAIL(hr);
	*ppGenCfg = spVCGenCfg.Detach();
	RETURN_ON_NULL(*ppGenCfg);

	return hr;
}

HRESULT CVCArchy::CompileFileItems(HierNodeList& rgSelection)
{
	VCPOSITION pos = rgSelection.GetHeadPosition();
	RETURN_ON_NULL2(pos, S_OK);	// nothing to do

	CVCPtrList listFiles;
	VCPOSITION oldPos = pos;
	BOOL bFirst = TRUE;
	CVCProjectNode* pProjNode = NULL;
	HRESULT hr = S_OK;
	while (pos != NULL && SUCCEEDED(hr))
	{
		while (pos != NULL)
		{
			CVCNode* pNode = rgSelection.GetNext(pos);
			CVCFileNode* pFileNode = (CVCFileNode *)pNode;
			CVCProjectNode* pThisProjNode = pFileNode->GetVCProjectNode();
			if (bFirst)
			{
				bFirst = FALSE;
				pProjNode = pThisProjNode;
			}
			else if (pThisProjNode != pProjNode)
			{
				pos = oldPos;
				break;
			}
			listFiles.AddTail(pFileNode);
		}
		if (!listFiles.IsEmpty())
		{
			CHECK_ZOMBIE(pProjNode, IDS_ERR_PROJ_ZOMBIE);
			hr = pProjNode->CompileFileItems(listFiles);
			listFiles.RemoveAll();
		}
		bFirst = TRUE;
	}

	if (SUCCEEDED(hr) && !listFiles.IsEmpty())
	{
		hr = pProjNode->CompileFileItems(listFiles);
		listFiles.RemoveAll();
	}

	return hr;
}

VSITEMID CVCArchy::ItemIDFromName(CVCNode *pRoot, LPCOLESTR pszMkDocument) 
{
	VSITEMID vsid = DoItemIDFromName(pRoot, VARIANT_TRUE, pszMkDocument);
	if (vsid != VSITEMID_NIL)
		return vsid;

	return DoItemIDFromName(pRoot, VARIANT_FALSE, pszMkDocument);
}

VSITEMID CVCArchy::DoItemIDFromName(CVCNode *pRoot, VARIANT_BOOL bFullOnly, LPCOLESTR pszMkDocument) 
{
	CVCNode* pNext;
	VSITEMID vsid = VSITEMID_NIL;

	if (pRoot == NULL)
	{
		pRoot = GetRootNode();
		RETURN_ON_NULL2(pRoot, VSITEMID_NIL);
	}
	
	VSASSERT(pRoot, "Unable to obtain root container!");
	pNext = static_cast<CVCBaseFolderNode*>(pRoot)->GetHead();

	while (pNext != NULL)
	{
		CVCNode *pVcNode = static_cast<CVCNode*>(pNext);
		CComPtr<IDispatch> pDisp;
		if (pVcNode)
			pDisp = pVcNode->m_dispkeyItem;
		CComBSTR bstrName;
		VARIANT_BOOL bMatched = VARIANT_FALSE;

		CComQIPtr<VCFile> pFile = pDisp;
		if(pFile)
		{
			bstrName = pszMkDocument;
			pFile->MatchName(bstrName, bFullOnly, &bMatched);
			if (bMatched == VARIANT_TRUE)  
				return pNext->GetVsItemID();
			pNext = pNext->GetNext();
			continue;
		}

		CComQIPtr<VCFilter> pFilter = pDisp;
		if(pFilter)
		{
			vsid = DoItemIDFromName(static_cast<CVCNode*>(pNext), bFullOnly, pszMkDocument);
			if ( vsid != VSITEMID_NIL)
				return vsid;
			else	// see if we're actually looking for the filter itself
			{
				bstrName = pszMkDocument;
				pFilter->MatchName(bstrName, bFullOnly, &bMatched);
				if (bMatched == VARIANT_TRUE)
					return pNext->GetVsItemID();
			}

			pNext = pNext->GetNext();
		}
	}
	return vsid;
}

//---------------------------------------------------------------------------
// converts an VSITEMID to a CVCNode *
// returns:
//		S_OK
//		E_FAIL				(NIL, SELECTED, FOCUSED)
//		E_INVALIDARG		(itemid == 0)
//		E_UNEXPECTED		(zombie state)
//---------------------------------------------------------------------------
HRESULT CVCArchy::VSITEMID2Node(VSITEMID itemid, CVCNode **ppNode)
{
	CHECK_POINTER_VALID(ppNode);

	if( itemid == VSITEMID_NIL || itemid == VSITEMID_SELECTION )
		return E_FAIL;

	if( itemid == VSITEMID_ROOT )
	{
		*ppNode = GetProjectNode();
		RETURN_ON_NULL2(*ppNode, E_UNEXPECTED);
		return S_OK;
	}

	CVCNode *pNode = (CVCNode *)itemid;
	RETURN_ON_NULL(pNode);

	try
	{
		// if the item ID is bad, one of these 2 calls is likely to throw.
		if (NULL == pNode->GetParent()) 	// Make sure this node is not a zombie or dead.
		{
			ATLTRACE(_T("ERROR: invalid VSITEMID -> CVCNode\n"));
			return E_UNEXPECTED;
		}
	
		if(pNode->GetVsItemID() != itemid) // Make sure this node actually is an itemID.
			return E_FAIL;

		*ppNode = pNode;
		return S_OK;
	}
	catch( ... )
	{
		VSASSERT(0, "Someone just handed us a bad itemid");
		return E_FAIL;
	}
}

HRESULT CVCArchy::VSITEMID2Node(VSITEMID itemid, HierNodeList& rgNodeList)
{
	HRESULT hr;
	if (VSITEMID_SELECTION != itemid)
	{
		CVCNode *pNode = NULL;
		hr = VSITEMID2Node(itemid, &pNode);
		if (SUCCEEDED(hr))
		{
			rgNodeList.AddHead(pNode);
		}
	}
	else
	{
		hr = GetSelectedNodes(rgNodeList);
	}
	return hr;
}

//---------------------------------------------------------------------------
// fill out an array of selected nodes
//---------------------------------------------------------------------------
HRESULT CVCArchy::GetSelectedNodes(HierNodeList& rgNodes)
{ 
	VSASSERT(m_srpMonSel != NULL, "SetSite must not have been called yet!");
	RETURN_ON_NULL2(m_srpMonSel, E_UNEXPECTED);
	
	HRESULT hr;
	VSITEMID itemid;						// if VSITEMID_SELECTION then multiselection
	CVCNode *pNode = NULL;
	CComPtr<IVsHierarchy> srpIVsHierarchy;	// if NULL then selection spans VsHierarchies
	CComPtr<IVsMultiItemSelect> srpIVsMultiItemSelect;
	CComPtr<ISelectionContainer> srpISelectionContainer;		// unused?
	CComPtr<IVsHierarchy> spThisHier = VCQI_cast<IVsHierarchy>(this);

	hr = m_srpMonSel->GetCurrentSelection(&srpIVsHierarchy, &itemid, &srpIVsMultiItemSelect, &srpISelectionContainer);
	RETURN_ON_FAIL(hr);

	// if we're not selected, but the shell still calls us (this does happen)
	if (srpIVsHierarchy != NULL && srpIVsHierarchy != spThisHier)
		return E_UNEXPECTED;

	if (VSITEMID_NIL == itemid) // nothing selected
	{
		VSASSERT(SUCCEEDED(hr), "Nothing selected!");
		return hr;
	}

	if (VSITEMID_SELECTION != itemid)
	{	// single selection
		VSASSERT(srpIVsHierarchy == spThisHier, "Hierarchy isn't what we expected!");	// shouldn't be NULL

		hr = VSITEMID2Node(itemid, &pNode);
		if (SUCCEEDED(hr))
			rgNodes.AddHead(pNode);
		else
			ATLTRACE(_T("ERROR: invalid VSITEMID in selection\n"));
		return hr;
	}

	ULONG cItems = 0;
	BOOL  fSingleHierarchy = TRUE;
	hr = srpIVsMultiItemSelect->GetSelectionInfo(&cItems, &fSingleHierarchy);
	RETURN_ON_FAIL(hr);
	if (cItems == 0)	// something could be selected, but it isn't for us
		return S_FALSE;
	VSASSERT(0 < cItems, "nothing selected should already be filtered out");

	VSITEMSELECTION *pItemSel = new VSITEMSELECTION[cItems];
	RETURN_ON_NULL2(pItemSel, E_OUTOFMEMORY);

	VSGSIFLAGS fFlags = (fSingleHierarchy) ? GSI_fOmitHierPtrs : static_cast<VSGSIFLAGS>(0);
	hr = srpIVsMultiItemSelect->GetSelectedItems(fFlags, cItems, pItemSel);
	if (SUCCEEDED(hr))
	{
		ULONG i;
		for (i = 0; i < cItems; ++i)
		{
			if (fSingleHierarchy || pItemSel[i].pHier == spThisHier)
			{
				pNode = NULL;
				hr = VSITEMID2Node(pItemSel[i].itemid, &pNode);
				if (SUCCEEDED(hr))
				{
					rgNodes.AddTail(pNode);
					// Needs to be reset for multi-sel
				}
				else
				{	// why is there an invalid itemid?
					VSASSERT(SUCCEEDED(hr), "why is there an invalid itemid?");
					break;
				}
			}
		}
		if (!fSingleHierarchy)
		{	// release all the hierarchies
			for (i = 0; i < cItems; ++i)
			{
				if (NULL != pItemSel[i].pHier)
				{
					pItemSel[i].pHier->Release();
				}
			}
		}
	}
	delete[] pItemSel;

	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataSource
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetDropInfo(DWORD* pdwOKEffects, IDataObject** ppDataObject, IDropSource** ppDropSource)
{
	CHECK_POINTER_NULL(pdwOKEffects);
	CHECK_POINTER_NULL(ppDataObject);
	CHECK_POINTER_NULL(ppDropSource);

	*pdwOKEffects = DROPEFFECT_NONE;
	*ppDataObject = NULL;
	*ppDropSource = NULL;

	// Get rid of any existing dragdrop object
	OnAfterDropOrPaste(FALSE /* no cut */, FALSE /* no move */, TRUE /* drag */, TRUE /* cleanup only */);

    CVCProjDataSource* pDataSource = GetDataSource(pdwOKEffects);
	RETURN_ON_NULL(pDataSource);

	*ppDataObject = pDataSource;	// Return it
	// Hold onto it.
	m_pDragDropDataObject = pDataSource;
	pDataSource->AddRef();

	// Set a bunch of flags.
	ASSERT(s_bStartedDrag == FALSE);
	s_bStartedDrag = TRUE;
	m_bInternalDrop = FALSE;

	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataSource
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::OnDropNotify(BOOL fDropped, DWORD dwEffects)
{
	ASSERT(s_bStartedDrag); // ASSERT that a drag is in progress

	if (s_bStartedDrag)
	{
		if(fDropped && dwEffects != DROPEFFECT_NONE)
		{	// Process after the drop
			OnAfterDropOrPaste(FALSE /* no cut */, (dwEffects & DROPEFFECT_MOVE) == DROPEFFECT_MOVE, TRUE /* drag */, FALSE /* not cleanup only */);
		}
		else
		{	// Just cleanup the drag
			OnAfterDropOrPaste(FALSE /* no cut */, FALSE /* no move */, TRUE /* drag */, TRUE /* cleanup only */);
		}
	}

	// Clear our internal drop flag.
	m_bInternalDrop = FALSE;
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IPkgDropDataTarget
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::DragEnter(IDataObject* pDataObj, DWORD grfKeyState, VSITEMID itemid, DWORD* pdwEffect)
{
	CHECK_POINTER_NULL(pdwEffect);
	*pdwEffect = DROPEFFECT_NONE;
	CHECK_READ_POINTER_NULL(pDataObj);

	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_FAIL_OR_NULL(hr, pNode);
	hr = DragEnter(pDataObj, pNode);
	RETURN_ON_FAIL(hr);

	return DragOver(grfKeyState, pNode, pdwEffect);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataSource, helper routine
//---------------------------------------------------------------------------
HRESULT CVCArchy::DragEnter(IDataObject* pDataObj, CVCNode* pDropNode)
{
	CHECK_READ_POINTER_NULL(pDataObj);

	// Assume we don't know what it is.
	m_dropType = DT_NONE;

	// Attach an MFC data object - no auto release since we aren't addref'n it
	CVCOleDataObject dataObject;
	dataObject.Attach(pDataObj, FALSE);

	if (dataObject.IsDataAvailable(CVCProjDataSource::s_cfRefProjItems))
	{	// It's a project item drop
		if (dataObject.IsDataAvailable(CVCProjDataSource::s_cfProjectDescriptor))
			m_dropType = DT_PROJITEM;	// VC project
		else
			m_dropType = DT_VSREFITEM;	// any other reference-based project
	}
	else if (dataObject.IsDataAvailable(CVCProjDataSource::s_cfStgProjItems))
	{	// It's a drop from a VS project other than VC
		m_dropType = DT_VSITEM;
	}
	else if (dataObject.IsDataAvailable(CF_HDROP))
	{	// It's a shell drop, but we'll only accept data from it if there's a non-folder in it
		m_dropType = DT_NONE;
		// Attach to the data object.
		CVCOleDataObject dataObj;
		dataObj.Attach(pDataObj, FALSE);
		HDROP hDropInfo = (HDROP)dataObj.GetGlobalData(CF_HDROP);
		if(hDropInfo)
		{
			CShellDropHelper dropHelper;
			int iNumActual = 0;
			bool bContainsFolders = false;
			HRESULT hr = PrepareShellDrop(pDropNode, dropHelper, hDropInfo, iNumActual, bContainsFolders);
			if (SUCCEEDED(hr) && iNumActual)
				m_dropType = DT_SHELL;
			::GlobalFree(hDropInfo);
		}
	}

	return S_OK;	
}

BOOL CVCArchy::IsDropTargetCandidate(CVCNode* pNode)
{
	return (pNode->GetKindOf() == Type_CVCFile || pNode->GetKindOf() == Type_CVCFileGroup || 
		pNode->GetKindOf() == Type_CVCProjectNode);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataTarget, helper routine
// If the target is not connected to the web server, return DROPEFFECT_NONE
//---------------------------------------------------------------------------
HRESULT CVCArchy::DragOver(DWORD grfKeyState, CVCNode *pNode, DWORD *pdwEffect)
{
	CHECK_READ_POINTER_NULL(pNode);
	CHECK_POINTER_NULL(pdwEffect);
	ASSERT(DROPEFFECT_NONE == *pdwEffect);

	if(m_dropType == DT_SHELL && IsDropTargetCandidate(pNode))	// from Windows Explorer
	{
		*pdwEffect = (((grfKeyState & MK_CONTROL) || (grfKeyState & MK_SHIFT)) ? DROPEFFECT_NONE : DROPEFFECT_LINK);
	}
	else if((m_dropType == DT_PROJITEM || m_dropType == DT_VSREFITEM) && IsDropTargetCandidate(pNode))	// reference-based
	{
		*pdwEffect = ((grfKeyState & MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE);
	}
	else if (m_dropType == DT_VSITEM && IsDropTargetCandidate(pNode))	// directory-based
	{
		*pdwEffect = (((grfKeyState & MK_CONTROL) || (grfKeyState & MK_SHIFT)) ? DROPEFFECT_NONE : DROPEFFECT_LINK);
	}
	else
	{	// We don't understand the format
		*pdwEffect = DROPEFFECT_NONE;
	}
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataTarget
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::DragOver(DWORD grfKeyState, VSITEMID itemid, DWORD *pdwEffect)
{
	CHECK_POINTER_NULL(pdwEffect);
	*pdwEffect = DROPEFFECT_NONE;

	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_FAIL_OR_NULL(hr, pNode);

	return DragOver(grfKeyState, pNode, pdwEffect);
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataSource
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::DragLeave(void)
{
	// Reset our drop type
	m_dropType = DT_NONE;
	return S_OK;
}

//---------------------------------------------------------------------------
// interface: IVsHierarchyDropDataSource
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::Drop(IDataObject *pDataObj, DWORD grfKeyState, VSITEMID itemid, DWORD *pdwEffect)
{
	CHECK_POINTER_NULL(pdwEffect);
	*pdwEffect = DROPEFFECT_NONE;
	CHECK_READ_POINTER_NULL(pDataObj);

	CVCNode *pNode = NULL;
	HRESULT hr = VSITEMID2Node(itemid, &pNode);
	RETURN_ON_FAIL_OR_NULL(hr, pNode);

	hr = E_UNEXPECTED;
	if(m_dropType == DT_NONE)
		return hr;

	// Assume it is NOT an internal Drop
	m_bInternalDrop = FALSE;

	CVCNode* pDropNode = NULL;

	if (pNode->GetKindOf() == Type_CVCProjectNode)
		pDropNode = pNode;
	else if (pNode->GetKindOf() == Type_CVCFileGroup)
		pDropNode = pNode;
	else if (pNode->GetKindOf() == Type_CVCFile)
		pDropNode = pNode->GetParent();
	else
		ASSERT(FALSE);

	BOOL bReported = FALSE;
	if (pDropNode)
	{
		CVCExecution multiEx(&GetExecutionCtx());

		// Attach to the data object.
		CVCOleDataObject dataObj;
		dataObj.Attach(pDataObj, FALSE);
		if(m_dropType == DT_SHELL)
		{	// Do shell drop
			ASSERT(dataObj.IsDataAvailable(CF_HDROP));
			HDROP hDropInfo = (HDROP)dataObj.GetGlobalData(CF_HDROP);
			if(hDropInfo)
			{
				// Make sure we are the foreground window
				CComPtr<IVsUIShell> spShell;
				hr = GetBuildPkg()->GetVsUIShell(&spShell, TRUE /* in main thread */);
				ASSERT(spShell);
				if(spShell != NULL)
					spShell->SetForegroundWindow();

				hr = DoShellDrop(pDropNode, hDropInfo, bReported);
				::GlobalFree(hDropInfo);
				*pdwEffect = DROPEFFECT_COPY;
			}
			else
			{	// Just silently skip this one.
				hr = S_OK;
				*pdwEffect = DROPEFFECT_NONE;
			}
		}
		else if (m_dropType == DT_PROJITEM || m_dropType == DT_VSITEM || m_dropType == DT_VSREFITEM)
		{	// Do project item drop
			ASSERT(((m_dropType == DT_PROJITEM || m_dropType == DT_VSREFITEM) && 
				dataObj.IsDataAvailable(CVCProjDataSource::s_cfRefProjItems)) ||
				(m_dropType == DT_VSITEM && dataObj.IsDataAvailable(CVCProjDataSource::s_cfStgProjItems)));

			// Make sure we are the foreground window
			CComPtr<IVsUIShell> spShell;
			hr = GetBuildPkg()->GetVsUIShell(&spShell, TRUE /* in main thread */);
			ASSERT(spShell);
			if(spShell != NULL)
				spShell->SetForegroundWindow();

			if (grfKeyState & MK_CONTROL)
				*pdwEffect = DROPEFFECT_COPY;
			else if (m_dropType == DT_VSITEM)
				*pdwEffect = DROPEFFECT_LINK;
			else
				*pdwEffect =  DROPEFFECT_MOVE;
			hr = DoProjItemDrop(pDropNode, dataObj, TRUE, *pdwEffect, bReported);
		}
		else
		{	// Shouldn't get here.
			ASSERT(FALSE);
		}
	}
	else
	{
		ASSERT(FALSE);
	}

	// We need to report our own errors.
	if(FAILED(hr) && hr != E_UNEXPECTED && hr != OLE_E_PROMPTSAVECANCELLED)
	{
		hr = S_FALSE;
		*pdwEffect = DROPEFFECT_NONE;
	}

	if (FAILED(hr) && m_dropType == DT_SHELL)
	{
		hr = S_FALSE;
		*pdwEffect = DROPEFFECT_NONE;
	}

	return hr;
}

//-----------------------------------------------------------------------------
// Cut command handler
//-----------------------------------------------------------------------------
HRESULT CVCArchy::OnCommandCut()
{
	// Get rid of any existing dragdrop object
	OnAfterDropOrPaste(m_bWasCut, FALSE /* no move */, FALSE /* no drag */, TRUE /* cleanup only */);

	HRESULT hr = E_OUTOFMEMORY;
	DROPEFFECT de;
	CVCProjDataSource* pDataSource = GetDataSource(&de);
	RETURN_ON_NULL2(pDataSource, E_OUTOFMEMORY);

	// Returned with refcount of 1. Keep a hold onto it.
	ASSERT(m_pClipboardDataObject == NULL);
	pDataSource->SetClipboard();

	// Must set this AFTER calling SetClipboard. The shell's clipboard helper
	// will call Clear() and we will release our data source!
	m_pClipboardDataObject = pDataSource;
	m_bWasCut = TRUE;

	// Register clipboard helper events (OK to call multiple times)
	RegisterClipboardNotifications(TRUE);

	// Now set cut highlight on the nodes that were actually cut
	const CVCNodeArray& rgActualNodesAdded = pDataSource->GetNodeList();
	CComPtr<IVsUIHierarchyWindow> spIVsUIHierarchyWindow;
	GetUIHierarchyWindow(&spIVsUIHierarchyWindow);
	RETURN_ON_NULL(spIVsUIHierarchyWindow);
	int num = 1;
	for(int i = 0; i < rgActualNodesAdded.GetSize(); i++)
	{	
		CVCNode* pCutNode = rgActualNodesAdded[i];
		if (pCutNode)
		{
			if(num == 1)
				spIVsUIHierarchyWindow->ExpandItem(GetIVsUIHierarchy(), pCutNode->GetVsItemID(), EXPF_CutHighlightItem);
			else
				spIVsUIHierarchyWindow->ExpandItem(GetIVsUIHierarchy(), pCutNode->GetVsItemID(), EXPF_AddCutHighlightItem);
		}
		num++;
	}

	// Inform the shell of the cut
	CComPtr<IVsUIHierWinClipboardHelper> spClipboardHelper;
	ExternalQueryService(SID_SVsUIHierWinClipboardHelper, IID_IVsUIHierWinClipboardHelper, (void **)&spClipboardHelper);
	if (spClipboardHelper)
		spClipboardHelper->Cut(static_cast<IDataObject*>(pDataSource));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Copy command handler
//-----------------------------------------------------------------------------
HRESULT CVCArchy::OnCommandCopy()
{
	// Get rid of any existing dragdrop object
	OnAfterDropOrPaste(m_bWasCut, FALSE /* no move */, FALSE /* no drag */, TRUE /* cleanup only */);

	DROPEFFECT de;
	CVCProjDataSource* pDataSource = GetDataSource(&de);
	RETURN_ON_NULL2(pDataSource, E_OUTOFMEMORY);

	// Returned with refcount of 1. Save it away
	ASSERT(m_pClipboardDataObject == NULL);
	pDataSource->SetClipboard();
	m_bWasCut = FALSE;

	// Must set this AFTER calling SetClipboard. The shell's clipboard helper
	// will call Clear() and we will release our data source!
	m_pClipboardDataObject = pDataSource;

	// Register clipboard helper events (OK to call multiple times)
	RegisterClipboardNotifications(TRUE);

	// Inform the shell of the copy
	CComPtr<IVsUIHierWinClipboardHelper> spClipboardHelper;
	ExternalQueryService(SID_SVsUIHierWinClipboardHelper, IID_IVsUIHierWinClipboardHelper, (void **)&spClipboardHelper);
	if (spClipboardHelper)
		spClipboardHelper->Copy(static_cast<IDataObject*>(pDataSource));

	return S_OK;
}

//-----------------------------------------------------------------------------
// Handles a paste
//-----------------------------------------------------------------------------
BOOL CVCArchy::CanPasteFromClipboard()
{
	CVCOleDataObject dataObject;
	dataObject.AttachClipboard();
	return(dataObject.IsDataAvailable(CF_HDROP) || dataObject.IsDataAvailable(CVCProjDataSource::s_cfRefProjItems)
		|| dataObject.IsDataAvailable(CVCProjDataSource::s_cfStgProjItems));
}

//-----------------------------------------------------------------------------
// Handles a paste
//-----------------------------------------------------------------------------
HRESULT CVCArchy::PasteFromClipboard(CVCNode *pDropNode)
{
	HRESULT hr = S_OK;
	CVCOleDataObject dataObject;
	dataObject.AttachClipboard();
	BOOL bReported = FALSE;
	DWORD dwDropEffect = DROPEFFECT_LINK;
	if (dataObject.IsDataAvailable(CF_HDROP))
	{
		HDROP hDropInfo = (HDROP)dataObject.GetGlobalData(CF_HDROP);
		if(hDropInfo)
		{
			hr = DoShellDrop(pDropNode, hDropInfo, bReported);
			::GlobalFree(hDropInfo);
		}
	}
	else if (dataObject.IsDataAvailable(CVCProjDataSource::s_cfRefProjItems) || 
		dataObject.IsDataAvailable(CVCProjDataSource::s_cfStgProjItems))
	{
		if (dataObject.IsDataAvailable(CVCProjDataSource::s_cfRefProjItems))
			dwDropEffect = m_bWasCut ? DROPEFFECT_MOVE : DROPEFFECT_COPY;
		hr = DoProjItemDrop(pDropNode, dataObject, FALSE, dwDropEffect, bReported);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	// Inform the shell that the paste happened. 
	CComPtr<IVsUIHierWinClipboardHelper> spClipboardHelper;
	ExternalQueryService(SID_SVsUIHierWinClipboardHelper, IID_IVsUIHierWinClipboardHelper, (void **)&spClipboardHelper);
	ASSERT(spClipboardHelper);
	if (spClipboardHelper)
		spClipboardHelper->Paste(dataObject.GetIDataObject(FALSE), SUCCEEDED(hr)? dwDropEffect : DROPEFFECT_NONE);

	if (bReported && FAILED(hr))
		hr = E_ABORT;	// don't give VS a chance at this error return code...

	return hr;
}

CShellDropHelper::~CShellDropHelper()
{
	if (m_rgFiles || m_rgActualFiles)		// Free everything
	{
		for (int i = 0; i < m_numFiles; i++)
		{	
			if (m_rgFiles[i])
				delete [] m_rgFiles[i];
			if (m_rgActualFiles[i])
				delete [] m_rgActualFiles[i];
		}
		delete [] m_rgFiles;
		delete [] m_rgActualFiles;
	}
}

HRESULT CVCArchy::PrepareShellDrop(CVCNode* pDropNode, CShellDropHelper& dropHelper, HDROP hDropInfo, int& iNumActual,
	bool& bContainsFolders)
{
	CHECK_READ_POINTER_NULL(pDropNode);

	// Walk the list of files/folders
	dropHelper.m_numFiles = ::DragQueryFileW(hDropInfo, 0xFFFFFFFF, (LPWSTR) NULL, 0);
	if (dropHelper.m_numFiles == 0)
		return S_OK;

	dropHelper.m_rgFiles = new LPWSTR [dropHelper.m_numFiles];
	memset(dropHelper.m_rgFiles, 0,dropHelper.m_numFiles*sizeof(LPWSTR));
	if (dropHelper.m_rgFiles == NULL)
	{
		dropHelper.m_hr = E_OUTOFMEMORY;
		return dropHelper.m_hr;
	}

	for (int i = 0; i < dropHelper.m_numFiles; i++)
	{	// Add each item (file or folder)
		dropHelper.m_rgFiles[i] = new WCHAR[_MAX_PATH];
		if (dropHelper.m_rgFiles[i] == NULL)
		{
			dropHelper.m_hr = E_OUTOFMEMORY;
			return dropHelper.m_hr;
		}
		::DragQueryFileW(hDropInfo, i, dropHelper.m_rgFiles[i], _MAX_PATH);
	}

	// add the stuff (DIANEME_TODO: currently - 3/20/2000 - ignoring shell folders altogether)
	dropHelper.m_rgActualFiles = new LPWSTR[dropHelper.m_numFiles];
	memset(dropHelper.m_rgActualFiles, 0, dropHelper.m_numFiles*sizeof(LPWSTR));
	if (dropHelper.m_rgActualFiles == NULL)
	{
		dropHelper.m_hr = E_OUTOFMEMORY;
		return dropHelper.m_hr;
	}

	bContainsFolders = false;
	iNumActual = 0;
	for (i = 0; i < dropHelper.m_numFiles; i++)
	{
		DWORD dwAttribs = GetFileAttributesW(dropHelper.m_rgFiles[i]);
		if (dwAttribs & FILE_ATTRIBUTE_DIRECTORY)	// DIANEME_TODO: handle shell folders
		{
			bContainsFolders = true;
			continue;
		}
		dropHelper.m_rgActualFiles[iNumActual] = new WCHAR[_MAX_PATH];
		if (dropHelper.m_rgActualFiles[iNumActual] == NULL)
		{
			dropHelper.m_hr = E_OUTOFMEMORY;
			return dropHelper.m_hr;
		}
		wcscpy(dropHelper.m_rgActualFiles[iNumActual], dropHelper.m_rgFiles[i]);
		iNumActual++;
	}

	return S_OK;
}

//---------------------------------------------------------------------------
//	Handles drop files from the shell. Note that this function does NOT free the
//	hdrop. The caller is responsible for this.
//---------------------------------------------------------------------------
HRESULT CVCArchy::DoShellDrop(CVCNode* pDropNode, HDROP hDropInfo, BOOL& bReported)
{
	CShellDropHelper dropHelper;
	int iNumActual = 0;
	bool bContainsFolders = false;
	HRESULT hr = PrepareShellDrop(pDropNode, dropHelper, hDropInfo, iNumActual, bContainsFolders);
	RETURN_ON_FAIL(hr);

	if (iNumActual == 0)
	{
		if (bContainsFolders)
		{
			CComBSTR bstrErr;
			bstrErr.LoadString(IDS_W_DROP_SHELL_FOLDERS);
			ReportError(bstrErr);
		}
		return S_OK;	// nothing to do
	}

	// Track documents batcher to batch up all subsequent calls to IVsTrackProjectDocuments
	CVCTrackProjectDocumentsBatcher track(TRUE);

	// we can check whether files can be added at the project level regardless of what the drop node
	// actually is.	 This is because files have to be unique at the project level.	Once we can start
	// adding folders this way, folder checks will need to be done at the drop node level.
	CComPtr<VCProject> spProject;
	pDropNode->GetVCProject(&spProject);
	CComQIPtr<IVCProjectImpl> spProjectImpl = spProject;
	if (spProjectImpl == NULL)
	{
		dropHelper.m_hr = VCPROJ_E_ZOMBIE;
		return dropHelper.m_hr;
	}

	int i;
	for (i = 0; i < iNumActual && SUCCEEDED(dropHelper.m_hr); i++)
	{
		dropHelper.m_hr = spProjectImpl->CanAddFile2(dropHelper.m_rgActualFiles[i]);
		if (FAILED(dropHelper.m_hr))
			return CVCProjectNode::ReportShellCopyError(dropHelper.m_hr, spProject, NULL, dropHelper.m_rgActualFiles[i], 
				bReported);
	}

	CVCNode* pNode = pDropNode;
	if (pDropNode->GetKindOf() == Type_CVCFile)
		pNode = pDropNode->GetParent();

	CComPtr<VCFilter> spFilter;
	if (pDropNode->GetKindOf() == Type_CVCFileGroup)
		((CVCFileGroup*)pDropNode)->GetVCFilter(&spFilter);

	for (i = 0; i < iNumActual && SUCCEEDED(dropHelper.m_hr); i++)
	{
		CComPtr<IDispatch> spFile;
		if (spFilter)
			dropHelper.m_hr = spFilter->AddFile(dropHelper.m_rgActualFiles[i], &spFile);
		else
			dropHelper.m_hr = spProject->AddFile(dropHelper.m_rgActualFiles[i], &spFile);
		if (SUCCEEDED(dropHelper.m_hr) && spFile == NULL)
			dropHelper.m_hr = E_UNEXPECTED;
		if (FAILED(dropHelper.m_hr))
			return CVCProjectNode::ReportShellCopyError(dropHelper.m_hr, spProject, spFilter, dropHelper.m_rgActualFiles[i], 
				bReported);
	}

	if (SUCCEEDED(dropHelper.m_hr) && bContainsFolders)
	{
		CComBSTR bstrErr;
		bstrErr.LoadString(IDS_W_DROP_SHELL_FOLDERS);
		ReportError(bstrErr);
	}

	return dropHelper.m_hr;
}

//---------------------------------------------------------------------------
//	Handles drop files from other projects. Note that this function does NOT free the
//	hdrop. The caller is responsible for this.
//---------------------------------------------------------------------------
HRESULT CVCArchy::DoProjItemDrop(CVCNode* pDropNode, CVCOleDataObject& rDataObject, BOOL bDrag, DWORD dwDropEffect, 
	BOOL& bReported)
{
	CHECK_ZOMBIE(GetProjectNode(), IDS_ERR_PROJ_ZOMBIE);

	HRESULT hr = S_OK;

	// Track documents batcher to batch up all subsequent calls to IVsTrackProjectDocuments
	CVCTrackProjectDocumentsBatcher track(TRUE);

	// We look for our project descriptor format to extract the project file. From this we
	// determine whether we pasted the data or not. We can't just compare IDataObject pointers
	// as the delayrender technique that we use causes us to get a "proxy" IDataObject created by
	// the clipboard.
	m_bInternalDrop = FALSE;
	BOOL bCrossVC = FALSE;
	CVCProjDataSource* pDataSource = bDrag ? m_pDragDropDataObject : m_pClipboardDataObject;
	if (rDataObject.IsDataAvailable(CVCProjDataSource::s_cfProjectDescriptor))
	{
		HGLOBAL hg = rDataObject.GetGlobalData(CVCProjDataSource::s_cfProjectDescriptor);
		if(hg)
		{
			WCHAR* pBuffer = (WCHAR*)::GlobalLock(hg);
			CComBSTR bstrProjFile;
			GetProjectNode()->get_ProjectFile(&bstrProjFile);
			if(pBuffer && bstrProjFile && !_wcsicmp(pBuffer, bstrProjFile))
				m_bInternalDrop = TRUE;
			else
			{
				CPathW pathProj;
				CStringW strSourceProj = pBuffer;
				if (pathProj.Create(strSourceProj))
				{
					CStringW strExt = pathProj.GetExtension();
					if (_wcsicmp(strExt, L".vcproj") == 0)
						bCrossVC = TRUE;		// we're getting the data from another VC project
				}
			}
			::GlobalFree(hg);
		}
	}


	if((dwDropEffect & DROPEFFECT_MOVE) == DROPEFFECT_MOVE || (dwDropEffect & DROPEFFECT_LINK) == DROPEFFECT_LINK)
		hr = GetProjectNode()->OnDropMove(rDataObject, pDropNode, pDataSource, bCrossVC, bDrag, bReported);

	else if((dwDropEffect & DROPEFFECT_COPY) == DROPEFFECT_COPY)
		hr = GetProjectNode()->OnDropCopy(rDataObject, pDropNode, pDataSource, bCrossVC, bDrag, bReported);

	else
		ASSERT(FALSE);

	return hr;
}

class CCleanupAfterDropOrPaste
{
public:
	CCleanupAfterDropOrPaste(CVCArchy* pArchy) : m_pArchy(pArchy), m_hr(S_OK) {}
	~CCleanupAfterDropOrPaste()
	{
		m_pArchy->m_bInternalDrop = FALSE;
		m_pArchy->m_bWasCut = FALSE;
		m_pArchy->s_bStartedDrag = FALSE;
	}
	CVCArchy* m_pArchy;
	HRESULT m_hr;
};

//---------------------------------------------------------------------------
// After a drop or paste, will use the dwEffects and whether it was handled 
// internally to determine whether we need to clean up the source nodes or not. If
// bCleanupOnly is set, it only does the cleanup work.
//---------------------------------------------------------------------------
HRESULT CVCArchy::OnAfterDropOrPaste(BOOL bWasCut, BOOL bWasMove, BOOL bDrag, BOOL bCleanupOnly)
{
	CCleanupAfterDropOrPaste cleanup(this); // let's us do early returns and still fix up the appropriate members for CVCArchy

	// Do we have a clipboard or drag object?
	CVCProjDataSource* pDataSource = bDrag? m_pDragDropDataObject : m_pClipboardDataObject;
	RETURN_ON_NULL2(pDataSource, S_OK);

	if (!bCleanupOnly && !m_bInternalDrop && ((bDrag && bWasMove) || bWasCut))
	{	// Handle deleting the items here: drag-move/cut-paste across projects
		const CVCNodeArray& rgDragNodes = pDataSource->GetNodeList();
		if(rgDragNodes.GetSize())
		{   // Need to check out project file first
			if(CanDirtyProject() == S_OK)
			{
				HierNodeList rgHierList;
				for (int i = 0; i < rgDragNodes.GetSize(); i++)
					rgHierList.AddTail(rgDragNodes[i]);

				CComPtr<IVsUIShellOpenDocument> pOpenDoc;
				CComPtr<IVsSolution> pSolution;
				CComPtr<IVsProject3> pTransferProject;
				ExternalQueryService( SID_SVsUIShellOpenDocument, IID_IVsUIShellOpenDocument, (void **)&pOpenDoc );
				VCPOSITION pos = rgHierList.GetHeadPosition();
				while (pos != NULL)
				{
					CVCNode* pNode = rgHierList.GetNext(pos);
					BOOL bWasTransferred = FALSE;
					BOOL fResult = FALSE;
					if (pOpenDoc)
					{
						if (!bWasCut)
						{
							CComBSTR bstrMoniker;
							GetMkDocument(pNode->GetVsItemID(), &bstrMoniker);
							CComPtr<IVsWindowFrame> pFrame;
							BOOL fOpen = FALSE;
							if (SUCCEEDED(pOpenDoc->IsDocumentOpen(NULL, NULL, bstrMoniker, GUID_NULL, IDO_IgnoreLogicalView, 
								NULL, NULL, &pFrame, &fOpen)) && fOpen)
							{	// no point in bothering with this extra work if the document isn't even open...
								// fair assumption (being made here): all files will be dropped on the same project
								if (pSolution == NULL)
								{
									GetBuildPkg()->GetIVsSolution(&pSolution);
									if (pSolution)
									{
										CComPtr<IEnumHierarchies> pHierarchies;
										pSolution->GetProjectEnum(EPF_ALLPROJECTS, GUID_NULL, &pHierarchies);
										if (pHierarchies)
										{
											CComPtr<IVsProject> spThisProj = VCQI_cast<IVsProject>(this);
											pHierarchies->Reset();
											while (TRUE)
											{
												CComPtr<IVsHierarchy> pTmpHierarchy;
												ULONG cFetched = 0;
												HRESULT hrT = pHierarchies->Next(1, &pTmpHierarchy, &cFetched);
												if (cFetched == 0)
													break;
												CComQIPtr<IVsProject> pProj = pTmpHierarchy;
												if (pProj == NULL)
													continue;
												if (pProj == spThisProj)	// skip ourself
													continue;
												BOOL fFound = FALSE;
												VSITEMID vsid = VSITEMID_NIL;
												VSDOCUMENTPRIORITY dp = DP_Unsupported;
												if (FAILED(pProj->IsDocumentInProject(bstrMoniker, &fFound, &dp, &vsid)) || 
													!fFound)
													continue;
												pTransferProject = pProj;
												if (pTransferProject)
													break;
											}
										}
									}
								}

								if (pTransferProject)
								{
									pTransferProject->TransferItem(bstrMoniker, bstrMoniker, pFrame);
									bWasTransferred = TRUE;
								}
							}
						}
					}
					cleanup.m_hr = DoRemoveItem(pNode->GetVsItemID(), &fResult, !bWasTransferred);
					// Display any failures
//					if(FAILED(hr) && hr != DIRPRJ_E_SKIPPED && hr != OLE_E_PROMPTSAVECANCELLED)
//						LUtilReportErrorInfo(hr);
				}
			}
			else
			{
				cleanup.m_hr = OLE_E_PROMPTSAVECANCELLED;
			}
		}
	}
	else if (bWasCut)
	{	// Just make sure the cut highlight is reset
		const CVCNodeArray& rgNodes = pDataSource->GetNodeList();
		CComPtr<IVsUIHierarchyWindow> spIVsUIHierarchyWindow;
		GetUIHierarchyWindow(&spIVsUIHierarchyWindow);
		for(int i=0; i< rgNodes.GetSize(); i++)
		{	
			CVCNode* pCutNode = rgNodes[i];
			if(pCutNode && !pCutNode->IsZombie())
				spIVsUIHierarchyWindow->ExpandItem(GetIVsUIHierarchy(), pCutNode->GetVsItemID(), EXPF_UnCutHighlightItem);
		}
	}

	// If we just did a cut, or we are told to cleanup, then we need to free the data object. Otherwise, we leave it
	// alone so that you can continue to paste the data in new locations.
	if (bWasCut || bDrag || bCleanupOnly)
	{
		if(bDrag)
		{
			ASSERT(pDataSource == m_pDragDropDataObject);
			if (m_pDragDropDataObject)
				m_pDragDropDataObject->Release();
			m_pDragDropDataObject = NULL;
		}
		else 
		{
			FlushClipboard();
		}
	}

	return cleanup.m_hr;
}

//-----------------------------------------------------------------------------
// Flushes any clipboard data we may have stuffed on the clipboard
//-----------------------------------------------------------------------------
HRESULT CVCArchy::FlushClipboard()
{
	if(m_pClipboardDataObject)
	{
		m_pClipboardDataObject->Release();
		m_pClipboardDataObject = NULL;
	}
	CVCOleDataObject dataObject;
	dataObject.AttachClipboard();
	if (dataObject.IsDataAvailable(CVCProjDataSource::s_cfProjectDescriptor))
	{
		HGLOBAL hg = dataObject.GetGlobalData(CVCProjDataSource::s_cfProjectDescriptor);
		if (hg)
		{
			WCHAR* pBuffer = (WCHAR*)::GlobalLock(hg);
			CComBSTR bstrProjFile;
			CHECK_ZOMBIE(GetProjectNode(), IDS_ERR_PROJ_ZOMBIE);
			GetProjectNode()->get_ProjectFile(&bstrProjFile);
			if (pBuffer && bstrProjFile && _wcsicmp(pBuffer, bstrProjFile) == 0)
			{
				::OleFlushClipboard();
				::OpenClipboard(NULL);
				::EmptyClipboard();
				::CloseClipboard();
			}
			::GlobalFree(hg);
		}
	}

	return S_OK;
}

//---------------------------------------------------------------------------
// Registers for clipboard events. Can be safely called many times
//---------------------------------------------------------------------------
HRESULT CVCArchy::RegisterClipboardNotifications(BOOL bRegister)
{
	if (bRegister && m_dwClipEvtCookie == 0)
	{
		// register advise sink for clipboard helper events
		CComPtr<IVsUIHierWinClipboardHelper> spClipboardHelper;
		HRESULT hr = ExternalQueryService(SID_SVsUIHierWinClipboardHelper, IID_IVsUIHierWinClipboardHelper, 
			(void **)&spClipboardHelper);
		RETURN_ON_FAIL_OR_NULL(hr, spClipboardHelper);

		CComQIPtr<IVsUIHierWinClipboardHelperEvents, &IID_IVsUIHierWinClipboardHelperEvents> pSink 
			= VCQI_cast<IVsUIHierWinClipboardHelperEvents>(this);
		spClipboardHelper->AdviseClipboardHelperEvents(pSink, &m_dwClipEvtCookie);
	}
	else if (!bRegister && m_dwClipEvtCookie != 0)
	{
		// unregister advise sink for clipboard helper events
		CComPtr<IVsUIHierWinClipboardHelper> spClipboardHelper;
		HRESULT hr = ExternalQueryService(SID_SVsUIHierWinClipboardHelper, IID_IVsUIHierWinClipboardHelper, 
			(void **)&spClipboardHelper);
		RETURN_ON_FAIL_OR_NULL(hr, spClipboardHelper);

		spClipboardHelper->UnadviseClipboardHelperEvents(m_dwClipEvtCookie);
		m_dwClipEvtCookie = 0;
	}

	return S_OK;
}

//---------------------------------------------------------------------------
// IVsUIHierWinClipboardHelperEvents
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::OnPaste(BOOL fDataWasCut, DWORD dwEffects)
{	
	if (dwEffects != DROPEFFECT_NONE)
	{
		OnAfterDropOrPaste(fDataWasCut, (dwEffects & DROPEFFECT_MOVE) == DROPEFFECT_MOVE, FALSE /* no drag */, FALSE /* no cleanup only */);
	}
	else
	{	// Just cleanup the drag
		OnAfterDropOrPaste(fDataWasCut, FALSE /* no move */, FALSE /* no drag */, TRUE /* cleanup only */);
	}

	return S_OK;
}

//---------------------------------------------------------------------------
// IVsUIHierWinClipboardHelperEvents
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::OnClear(BOOL fDataWasCut)
{	
	OnAfterDropOrPaste(fDataWasCut, FALSE /* no move */, FALSE /* no drag */, TRUE /* cleanup only */);
	return S_OK;
}

//-----------------------------------------------------------------------------
// Returns a CVCProjDataSource for the selected items. Or NULL if error. Returns the 
// dropeffect in de. Also returns the list of nodes actually added
//-----------------------------------------------------------------------------
CVCProjDataSource* CVCArchy::GetDataSource(DROPEFFECT* pde)
{
	// Get selected nodes
	CComObject<CVCProjDataSource> *pDataSource = NULL;	// has ref count of 0
	HierNodeList rgNodes;
	CVCNode *pNode = NULL;

	*pde = DROPEFFECT_NONE;
	if (FAILED(GetSelectedNodes(rgNodes)))
		return NULL;

	BOOL bHaveCandidates = FALSE;
	VCPOSITION pos = rgNodes.GetHeadPosition();
	while (NULL != pos)
	{	// At least one node must be a CLangBaseNode . Count files and folders
		CVCNode *pTmpNode = rgNodes.GetNext(pos);
		if (pNode == NULL && (pTmpNode->GetKindOf() == Type_CVCFile || pTmpNode->GetKindOf() == Type_CVCFileGroup))
		{	
			bHaveCandidates = TRUE;
			if (pTmpNode->GetKindOf() == Type_CVCFile)
				break;
		}
	}
	
	if (!bHaveCandidates)
		return NULL;

	HRESULT hr = CComObject<CVCProjDataSource>::CreateInstance(&pDataSource);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pDataSource, NULL);

	pDataSource->AddRef();

	// Write the project descriptor (allows us to determine which project sourced the data). We just
	// write the project file path.
	CComBSTR bstrProjFile;
	RETURN_ON_NULL2(GetProjectNode(), NULL);
	GetProjectNode()->get_ProjectFile(&bstrProjFile);
	int bufsz = (bstrProjFile.Length() + 1) * sizeof(WCHAR);
	ASSERT(bufsz > 0);
	HGLOBAL hg = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, bufsz);
	if(hg)
	{	
		WCHAR* pBuffer = static_cast<WCHAR *>(GlobalLock(hg));
		wcscpy(pBuffer, bstrProjFile);
		::GlobalUnlock(hg);
		pDataSource->CacheGlobalData(CVCProjDataSource::s_cfProjectDescriptor, hg);
	}

	// Now go get the actual list of nodes to drag/drop
	CVCNodeArray rgDragDropNodes;
	GetDragDropNodesFromSelection(rgNodes, rgDragDropNodes);

	// Offer CVCProjDataSource::s_cfRefProjItems format but only if there are files and folders
	BOOL bAddedProjItemFormat = FALSE;

	// Delay render our CVCProjDataSource::s_cfRefProjItems. This permits other VC projects to go get the files
	// when the data is requested
	if(rgDragDropNodes.GetSize())
	{
		FORMATETC fmt;
		fmt.cfFormat = CVCProjDataSource::s_cfRefProjItems;
		fmt.ptd		 = NULL;
		fmt.dwAspect = DVASPECT_CONTENT;
		fmt.lindex	 = -1;					// Must be -1!
		fmt.tymed	 = TYMED_HGLOBAL;
		pDataSource->SetNodeList(this, rgDragDropNodes);
		pDataSource->DelayRenderData(CVCProjDataSource::s_cfRefProjItems, &fmt);
		bAddedProjItemFormat = TRUE;
	}

	// Don't support move unless ProjItemFormat offered
	*pde = bAddedProjItemFormat ? DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK : DROPEFFECT_COPY;

	return pDataSource;
}

//-----------------------------------------------------------------------------
// Given the selection list rgSelection, returns all the nodes that need to
// participate in dragdrop.
//-----------------------------------------------------------------------------
HRESULT CVCArchy::GetDragDropNodesFromSelection(HierNodeList& rgSelection, CVCNodeArray& rgDragDropNodes)
{
	// Now we want to go through the nodes and make sure we include the related files.
	rgDragDropNodes.SetSize(0, 20);
	VCPOSITION pos = rgSelection.GetHeadPosition();

	for( int i = 0; pos != NULL; i++)
	{
		CVCNode* pNode = rgSelection.GetNext(pos);
		if (pNode->GetKindOf() == Type_CVCFile || pNode->GetKindOf() == Type_CVCFileGroup)
			rgDragDropNodes.Add(pNode);
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Returns our ui hierarchy.
//-----------------------------------------------------------------------------
HRESULT CVCArchy::GetUIHierarchyWindow(IVsUIHierarchyWindow** ppIVsUIHierarchyWindow)
{
	CHECK_POINTER_NULL(ppIVsUIHierarchyWindow);
	*ppIVsUIHierarchyWindow = NULL;

	// Go get the ui hierarchy window
	CComPtr<IVsUIShell> spIVsUIShell;
	HRESULT hr = GetBuildPkg()->GetVsUIShell(&spIVsUIShell, TRUE /* in main thread */);
	RETURN_ON_FAIL_OR_NULL(hr, spIVsUIShell);

	CComPtr<IVsWindowFrame> spIVsWindowFrame;
	hr = spIVsUIShell->FindToolWindow(NULL, GUID_SolutionExplorer, &spIVsWindowFrame);
	RETURN_ON_FAIL_OR_NULL(hr, spIVsWindowFrame);

	CComVariant srpvt;
	hr = spIVsWindowFrame->GetProperty(VSFPROPID_DocView, &srpvt);
	ASSERT(VT_UNKNOWN == V_VT(&srpvt));
	RETURN_ON_FAIL(hr);
	if (VT_UNKNOWN != V_VT(&srpvt))
		return E_FAIL;

	CComPtr<IVsWindowPane> spIVsWindowPane;
	hr = V_UNKNOWN(&srpvt)->QueryInterface(IID_IVsWindowPane, (void **)&spIVsWindowPane);
	ASSERT(spIVsWindowPane != NULL);
	RETURN_ON_FAIL_OR_NULL(hr, spIVsWindowPane);

	hr = spIVsWindowPane->QueryInterface(IID_IVsUIHierarchyWindow, (void **)ppIVsUIHierarchyWindow);
	ASSERT(ppIVsUIHierarchyWindow != NULL);
	RETURN_ON_FAIL_OR_NULL(hr, ppIVsUIHierarchyWindow);

	return S_OK;
}


// Pass TRUE for bBatch if you want the constructor to immedidately call BeginBatch.
//---------------------------------------------------------------------------
CVCTrackProjectDocumentsBatcher::CVCTrackProjectDocumentsBatcher(BOOL bBatch) : m_cBatches(0)
{
	if (bBatch)
		BeginBatch();
}

//---------------------------------------------------------------------------
// Calls EndBatch() for any outstanding BeginBatches().
//---------------------------------------------------------------------------
CVCTrackProjectDocumentsBatcher::~CVCTrackProjectDocumentsBatcher()
{
	ASSERT(m_cBatches >= 0);
	while (m_cBatches > 0)
		EndBatch();
}

//---------------------------------------------------------------------------
// Calls IVsTrackProjectDocumets::BeginBatch(). Increments count of outstanding
// BeginBatch calls.
//---------------------------------------------------------------------------
HRESULT CVCTrackProjectDocumentsBatcher::BeginBatch()
{
	HRESULT hr = E_NOINTERFACE;
	ASSERT(m_cBatches >= 0);
	if (m_spTracker == NULL)
		ExternalQueryService(SID_SVsTrackProjectDocuments, IID_IVsTrackProjectDocuments, (void **)&m_spTracker);
	if (m_spTracker)
	{
		hr = m_spTracker->BeginBatch();
		ASSERT(SUCCEEDED(hr));
		m_cBatches++;
	}
	return hr;
}

//---------------------------------------------------------------------------
// Calls EndBatch() for any outstanding BeginBatches().
//---------------------------------------------------------------------------
HRESULT CVCTrackProjectDocumentsBatcher::EndBatch()
{
	HRESULT hr = E_NOINTERFACE;
	ASSERT(m_cBatches > 0);
	if(m_spTracker)
	{
		hr = m_spTracker->EndBatch();
		ASSERT(SUCCEEDED(hr));
		m_cBatches--;
	}
	return hr;
}

//---------------------------------------------------------------------------
// IVsExtensibleObject
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetAutomationObject(/*[in]*/ LPCOLESTR  pszPropName, /*[out]*/ IDispatch **ppDisp)
{
	CHECK_POINTER_VALID(ppDisp);
	*ppDisp = NULL;

	CComBSTR bstrCfgName = pszPropName;
	CComPtr<VCConfiguration> spConfig;
	HRESULT hr = GetCfgOfName(bstrCfgName, &spConfig);
	RETURN_ON_FAIL_OR_NULL(hr, spConfig);

	return CVCProjCfgProperties::CreateInstance(spConfig, ppDisp);
}

//---------------------------------------------------------------------------
// interface: IVsProjectResources
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::GetResourceItem(/* [in] */ VSITEMID itemidDocument, /* [in] */ LPCOLESTR pszCulture, 
	/* [in] */ VSPROJRESFLAGS grfPRF, /* [out, retval] */ VSITEMID* pitemidResource)
{

	CHECK_POINTER_NULL(pitemidResource);

	HRESULT hr = E_NOTIMPL; // CVCArchy::GetResourceItem
#if 0
	// Called by the WFC designer to add a resource of specified culture to the project,
	// or to find a culture-specific resource associated with a particular itemid.

	CStringW strResourceFilename;

	// Initialize outparams
	*pitemidResource = VSITEMID_NIL;

	CVCNode *pNode = NULL;
	hr = VSITEMID2Node(itemid, &pNode);

	// Form a filename for the resources
	// REVIEW (kperry) how to mimplement this file name is TBD ...
	GetResourceFilename(pNode, pszCulture, strResourceFilename);
	CPathW path;
	path.CreateFromString(strResourceFilename);

	if(!path.ExistsOnDisk())
	{
		if (!(grfPRF & PRF_CreateIfNotExist))
		{
			// If we didn't find it and we're not told to create it then bail.
			hr = E_FAIL;
			return hr;
		}

		// Create an empty resource file
		if (CreateFile(strResourceFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL) == 0)
		{
			hr = HRESULT_FROM_WIN32(::GetLastError());
			return hr;
		}

		// Create the node
		CComPtr<VCProject> pProj;
		GetVCProject( NULL, &pProj );
		RETURN_ON_NULL2(pProj, E_NOINTERFACE);

		CComPtr<IDispatch> pFileAdded;
		pProject->AddFile(bstrPath, &pFileAdded);
	}
	else
	{
	}

	// Return what the caller wants.
	*pitemidResource = pNode->GetVsItemID();
#endif
	return hr;
}

//---------------------------------------------------------------------------
// interface: IVsProjectResources
//---------------------------------------------------------------------------
STDMETHODIMP CVCArchy::CreateResourceDocData(/* [in] */ VSITEMID itemidResource, /* [out, retval] */ IUnknown** punkDocData)
{
	// Creates the resource doc data for a particular VSITEMID.	 VBA
	// needs to override whatever we do here because we're file-based.
	HRESULT hr = E_NOTIMPL; // CVCArchy::CreateResourceDocData
#if 0
	CHECK_POINTER_NULL(punkDocData);

	CVCNode* pNode = NULL;
	hr = VSITEMID2Node(itemidResource, &pNode);

	CComPtr<ILocalRegistry> srpLocalRegistry;
	CComPtr<IVsPersistDocData> srpPersistDocData;

	if (pNode == NULL )
	{
		// Get a local registry
		ExternalQueryService(SID_SLocalRegistry, IID_ILocalRegistry, (LPVOID*) &srpLocalRegistry) );

		// Make a text buffer instance
		srpLocalRegistry->CreateInstance(CLSID_VsTextBuffer,
												  NULL,
												  IID_IVsPersistDocData,
												  CLSCTX_INPROC_SERVER,
												  (LPVOID*) &srpPersistDocData));

		CComBSTR bstrPath = ((CVCFileNode*)pNode)->GetFullPath( void );
		// Load the doc data
		srpPersistDocData->LoadDocData(bstrPath);

		// Get an IUnknown to return
		hr = srpPersistDocData->QueryInterface(IID_IUnknown, (LPVOID*) punkDocData);
	}
	else if (SUCCEEDED(hr))
	{
		// We could have gotten a node, but it might not have been a file.
		// We need to fail in this case.
		hr = E_FAIL;
	}

#endif
	return hr;
}

//---------------------------------------------------------------------------
// IVsProjectSpecificEditorMap
//---------------------------------------------------------------------------

STDMETHODIMP CVCArchy::GetSpecificEditorType(LPCOLESTR pszMkDocument, GUID *pguidEditorType)
{ 
	if (!IsResourceFile(pszMkDocument))
		return E_NOTIMPL; 

	CHECK_POINTER_NULL(pguidEditorType);
	*pguidEditorType = LOGVIEWID_ProjectSpecificEditor;
	return S_OK;
}

//---------------------------------------------------------------------------
// IVsProjectSpecificEditorMap2
//---------------------------------------------------------------------------

STDMETHODIMP CVCArchy::GetSpecificEditorProperty(LPCOLESTR pszMkDocument, VSPSEPROPID propid, VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);

	if (!IsResourceFile(pszMkDocument))
		return E_NOTIMPL;

	switch( propid )
	{
	case VSPSEPROPID_UseGlobalEditorByDefault:
		pvar->vt = VT_BOOL;
		pvar->boolVal = GetBuildPkg() ? GetBuildPkg()->UseGlobalEditorForResourceFiles() : VARIANT_FALSE;
		break;

	case VSPSEPROPID_ProjectDefaultEditorName:
		{
		CComBSTR bstrEditorName;
		bstrEditorName.LoadString(IDS_RESOURCEVIEW);
		pvar->vt = VT_BSTR;
		pvar->bstrVal = bstrEditorName.Detach();
		}
		break;

	default:
		return E_NOTIMPL;
	}
	return S_OK;
}

STDMETHODIMP CVCArchy::SetSpecificEditorProperty(LPCOLESTR pszMkDocument, VSPSEPROPID propid, VARIANT var)
{
	if (!IsResourceFile(pszMkDocument))
		return E_NOTIMPL;

	switch( propid )
	{
	case VSPSEPROPID_UseGlobalEditorByDefault:
		if (GetBuildPkg())
			GetBuildPkg()->SetUseGlobalEditorForResourceFiles(var.boolVal);
		break;

	default:
		return E_NOTIMPL;
	}

	return S_OK;
}

BOOL CVCArchy::IsResourceFile(LPCOLESTR pszMkDocument)
{
	CPathW pathDoc;
	if (!pathDoc.Create(pszMkDocument))
		return FALSE;

	CStringW strExt = pathDoc.GetExtension();
	strExt.MakeLower();
	if (strExt != L".rc")
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\utils.h ===
// ---------------------------------------------------------------------------
// Microsoft Visual C++
//
// Microsoft Confidential
// Copyright 1994 - 2000 Microsoft Corporation. All Rights Reserved.
//
// utils.h : declarations for a suite of simple utility functions.
// 
// NOTE: All functions here are mbcs/unicode compliant.
//		 Do NOT add non mbcs/unicode compliant functions!
// ---------------------------------------------------------------------------
#ifndef __UTILS_H__
#define __UTILS_H__

class CISBaseFileNode;

// Creates a directory and all the subdirectories up to it.
BOOL UtilCreateDirectory(LPCTSTR name);
BOOL UtilCreateDirectoryW(const wchar_t* name);

int UtilMessageBox(LPCTSTR lpszText, UINT nType = MB_OK|MB_ICONEXCLAMATION, LPCTSTR pszCaption = NULL, HWND hParent = NULL);
int UtilMessageBox(UINT nIDPrompt, UINT nType = MB_OK|MB_ICONEXCLAMATION, LPCTSTR pszCaption = NULL,  HWND hParent = NULL);

void UtilGetProjUIFolder(CString& strProjItemDir);

LRESULT UtilSendMessageW( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
LRESULT UtilSendMessageWString( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );

HRESULT UtilSetErrorInfo(HRESULT hrError, LPCOLESTR pszDescription);

#endif // __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcarchy.h ===
//---------------------------------------------------------------------------
// Microsoft VC++
//
// Microsoft Confidential
// Copyright 1994 - 1997 Microsoft Corporation. All Rights Reserved.
//
// CVCARCHY.h: Definition of the CVCArchy class
//---------------------------------------------------------------------------

#pragma once

#include "vssolutn.h"
#include "fpstfmt.h"
#include "vssccprj.h"
#include "vssccmgr.h"
#include "prjnode.h"
#include "gencfg.h"
#include "vstrkdoc.h"

typedef CVCTypedPtrList<CVCPtrList, CVCNode*> HierNodeList;

// forward decl for helper class
class CShellDropHelper;

//
// When retrieving a shell interface from CVCArchy, perform a QI to get the desired interface.
// We can't perform a simple cast from CVCArchy to any shell interface because that prevents CVCArchy from 
// being aggregated correctly.
//
// Usage:	IVsHierarchy* pHier = VCQI_cast<IVsHierarchy>(this);
//			IVsProject*   pProj = VCQI_cast<IVsProject>(this);
//			etc.
//
template <typename T> CComPtr<T> VCQI_cast( const CVCArchy* pCVCArchy) 
{ 
	CComPtr<T>	pT;
	if( pCVCArchy )
	    ((CVCArchy*)pCVCArchy)->QueryInterface( __uuidof(T), (void**)&pT );
	ASSERT( pT );
	return pT;
}

class CVCArchy : 
	public IVsUIHierarchy,
	public IOleCommandTarget,
	public IVsPersistHierarchyItem,
	public IPersistFileFormat,	// derives from IPersist
	public IVsProject3,		// derives from IProject
	public IVsCfgProvider2,
	public IExtractIconW,
	public IVsHierarchyDeleteHandler,
	public IDispatchImpl<IDispatch, &IID_IDispatch>,
	public IVsProjectCfgProvider,
	public IVsPersistSolutionOpts,
	public IVsSccProject2,
	public IVsProjectResources,
	public IVsSupportItemHandoff,
	public IVsHierarchyDropDataSource,
	public IVsUpdateSolutionEvents,
	public IVsHierarchyDropDataTarget,
	public IVsUIHierWinClipboardHelperEvents,
	public IVsExtensibleObject,
	public IVsProjectSpecificEditorMap2,
	public CComObjectRoot
{
public:
	CVCArchy(void);
	virtual ~CVCArchy(void);

BEGIN_COM_MAP(CVCArchy)
	COM_INTERFACE_ENTRY(IVsHierarchy)		// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsUIHierarchy)		// derives from IVsHierarchy
	COM_INTERFACE_ENTRY(IOleCommandTarget)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsPersistHierarchyItem) // derives from IUnknown
	COM_INTERFACE_ENTRY(IPersist)					// derives from IUnknown
	COM_INTERFACE_ENTRY(IPersistFileFormat)			// derives from IPersist
	COM_INTERFACE_ENTRY(IVsProject)					// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsProject2)				// derives from IVsProject
	COM_INTERFACE_ENTRY(IVsProject3)				// derives from IVsProject2
	COM_INTERFACE_ENTRY(IVsSupportItemHandoff)
	COM_INTERFACE_ENTRY(IVsPersistSolutionOpts)
	COM_INTERFACE_ENTRY(IVsSccProject2)				// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsProjectCfgProvider)		// derives from IVsCfgProvider
	COM_INTERFACE_ENTRY(IVsCfgProvider2)			// derives from IVsCfgProvider
	COM_INTERFACE_ENTRY2(IVsCfgProvider, IVsProjectCfgProvider)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsHierarchyDeleteHandler)				// derives from IUnknown
	COM_INTERFACE_ENTRY_IID(IID_IExtractIcon, IExtractIconW)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsHierarchyDropDataSource)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsHierarchyDropDataTarget)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IVsUIHierWinClipboardHelperEvents)	// derives from IUnknown
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVsProjectResources)
	COM_INTERFACE_ENTRY(IVsUpdateSolutionEvents)
	COM_INTERFACE_ENTRY(IVsExtensibleObject)
	COM_INTERFACE_ENTRY(IVsProjectSpecificEditorMap2)
	COM_INTERFACE_ENTRY(IVsProjectSpecificEditorMap)
END_COM_MAP()
DECLARE_AGGREGATABLE(CVCArchy)
// DECLARE_POLY_AGGREGATABLE(CVCArchy)
// DECLARE_NOT_AGGREGATABLE(CVCArchy)


public:	
// IVsHierarchyEvent propagation
	HRESULT OnItemAdded(CVCNode *pNodeParent, CVCNode *pNodePrev, CVCNode *pNodeAdded) const;
	HRESULT OnItemDeleted(CVCNode *pNode) const;
	HRESULT OnPropertyChanged(CVCNode *pNode, VSHPROPID propid, DWORD flags) const;
	HRESULT OnInvalidateItems(CVCNode *pNode) const;
	HRESULT	OnInvalidateIcon(HICON hIcon) const;

public:
//---------------------------------------------------------------------------
// interface: IVsProject
//---------------------------------------------------------------------------

	STDMETHOD(IsDocumentInProject)(LPCOLESTR pszMkDocument, BOOL* pfFound, VSDOCUMENTPRIORITY* pdwPriority, VSITEMID* pvsid);
	STDMETHOD(GetMkDocument)(VSITEMID vsid, BSTR *pbstrMkDocument); 
	STDMETHOD(OpenItem)(VSITEMID vsid, REFGUID guidDocViewType, IUnknown* punkDocDataExisting, IVsWindowFrame** ppWindowFrame);
	STDMETHOD(GetItemContext)(VSITEMID vsid, IServiceProvider **ppSP);
	STDMETHOD(GenerateUniqueItemName)(VSITEMID itemidLoc, LPCOLESTR pszExt, LPCOLESTR pszSuggestedRoot, BSTR* pbstrItemName);
	STDMETHOD(AddItem)(/*[in]*/ VSITEMID itemidLoc, /*[in]*/ VSADDITEMOPERATION dwAddItemOperation, 
		/*[in]*/ LPCOLESTR pszItemName, /*[in]*/ DWORD cFilesToOpen, 
		/*[in, size_is(cFilesToOpen)]*/ LPCOLESTR rgpszFilesToOpen[], /*[in]*/ HWND hwndDlg, 
		/*[out, retval]*/ VSADDRESULT* pResult);
	STDMETHOD (Close)(void);

//---------------------------------------------------------------------------
// interface: IVsProject2
//---------------------------------------------------------------------------
	STDMETHOD(RemoveItem)(/*[in]*/ DWORD dwReserved, /*[in]*/ VSITEMID itemid, /*[out, retval]*/ BOOL __RPC_FAR *pfResult);
	STDMETHOD(ReopenItem)(/*[in]*/ VSITEMID itemid, /*[in]*/ REFGUID rguidEditorType, /*[in]*/ LPCOLESTR pszPhysicalView,
		/*[in]*/ REFGUID rguidLogicalView, /*[in]*/ IUnknown __RPC_FAR *punkDocDataExisting,
		/*[out, retval]*/ IVsWindowFrame __RPC_FAR *__RPC_FAR *ppWindowFrame);

// helper
protected:
	HRESULT DoRemoveItem(VSITEMID itemid, BOOL __RPC_FAR *pfResult, BOOL bCloseIfOpen = TRUE);
	HRESULT DoAddItem(/*[in]*/ VSITEMID itemidLoc, /*[in]*/ VSADDITEMOPERATION dwAddItemOperation,
		/*[in]*/ LPCOLESTR pszItemName, /*[in]*/ DWORD cFilesToOpen, 
		/*[in, size_is(cFilesToOpen)]*/ LPCOLESTR rgpszFilesToOpen[], /*[in]*/ HWND hwndDlg, 
		/*[out, retval]*/ VSADDRESULT* pResult);

//---------------------------------------------------------------------------
// interface: IVsProject3
//---------------------------------------------------------------------------
public:
	// AddItemWithSpecific is used to add item(s) to the project and additionally ask the project to
	// open the item using the specified editor information.  An extension of IVsProject::AddItem().
	STDMETHOD(AddItemWithSpecific)( VSITEMID itemidLoc, VSADDITEMOPERATION dwAddItemOperation, LPCOLESTR pszItemName,
		ULONG cFilesToOpen, LPCOLESTR rgpszFilesToOpen[], HWND hwndDlg, VSSPECIFICEDITORFLAGS grfEditorFlags,
		REFGUID rguidEditorType, LPCOLESTR pszPhysicalView, REFGUID rguidLogicalView, VSADDRESULT* pResult);
	// OpenItemWithSpecific is used to ask the project to open the item using the
	// specified editor information.  An extension of IVsProject::OpenItem().
	STDMETHOD(OpenItemWithSpecific)( VSITEMID itemid, VSSPECIFICEDITORFLAGS grfEditorFlags, REFGUID rguidEditorType,
		LPCOLESTR pszPhysicalView, REFGUID rguidLogicalView, IUnknown* punkDocDataExisting, IVsWindowFrame** ppWindowFrame);
	// TransferItem is used to transfer ownership of a running document to the project.
	// The project should call IVsRunningDocumentTable::RenameDocument to transfer ownership
	// of the document to its hierarchy and give the document a new itemid within the project.
	STDMETHOD(TransferItem)( LPCOLESTR pszMkDocumentOld,  // passed as pszDocumentOld to IVsRunningDocumentTable::RenameDocument
					   LPCOLESTR pszMkDocumentNew,  // passed as pszDocumentNew to IVsRunningDocumentTable::RenameDocument
					   IVsWindowFrame *punkWindowFrame);  // optional if document not open

//---------------------------------------------------------------------------
// IExtractIconW
//---------------------------------------------------------------------------
public:
	STDMETHOD(GetIconLocation)(UINT uFlags, LPWSTR szIconFile, UINT cchMax, int* piIndex, UINT* pwFlags); 
	STDMETHOD(Extract)(LPCWSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize); 

// IPersist
	STDMETHOD(GetClassID)(/*[out]*/ CLSID *pClassID);

// IPersistFileFormat
public:
	STDMETHOD(IsDirty)(BOOL __RPC_FAR *pfIsDirty);
	STDMETHOD(InitNew)(/*[in]*/ DWORD nFormatIndex);
	STDMETHOD(Load)(/*[in]*/ LPCOLESTR pszFilename, /*[in]*/ DWORD grfMode, /*[in]*/ BOOL fReadOnly);
	STDMETHOD(Save)(/*[in]*/ LPCOLESTR pszFilename, /*[in]*/ BOOL fRemember, /*[in]*/ DWORD nFormatIndex);
	STDMETHOD(SaveCompleted)(/*[unique, in]*/ LPCOLESTR pszFileName);
	STDMETHOD(GetCurFile)(/*[out]*/ LPOLESTR __RPC_FAR *ppszFilename, /*[out]*/ DWORD __RPC_FAR *pnFormatIndex);
	STDMETHOD(GetFormatList)(/*[out]*/ LPOLESTR __RPC_FAR *ppszFormatList);

//	IVsProjectCfgProvider2 IVsCfgProvider2
public:
	STDMETHOD(OpenProjectCfg)(/*[in]*/ LPCOLESTR szProjectCfgCanonicalName, IVsProjectCfg **ppIVsProjectCfg);
	STDMETHOD(get_UsesIndependentConfigurations)(/*[out]*/ BOOL *pfUsesIndependentConfigurations);
	STDMETHOD(GetCfgs)(/*[in]*/ ULONG celt, /*[in, out, size_is(celt)]*/ IVsCfg *rgpcfg[], /*[out, optional]*/ ULONG* pcActual,
		/*[out, optional]*/ VSCFGFLAGS *prgfFlags);
    STDMETHOD(GetCfgNames)(/*[in]*/ ULONG celt, /*[size_is, out, in]*/ BSTR rgbstr[], /*[optional, out]*/ ULONG* pcActual);
    STDMETHOD(GetPlatformNames)(/*[in]*/ ULONG celt, /*[size_is, out, in]*/ BSTR rgbstr[], /*[optional][out]*/ ULONG* pcActual);
    STDMETHOD(GetCfgOfName)(/*[in]*/ LPCOLESTR pszCfgName, /*[in]*/ LPCOLESTR pszPlatformName, /*[out]*/ IVsCfg** ppCfg);
    STDMETHOD(AddCfgsOfCfgName)(/*[in]*/ LPCOLESTR pszCfgName, /*[in]*/ LPCOLESTR pszCloneCfgName, /*[in]*/ BOOL fPrivate);
    STDMETHOD(DeleteCfgsOfCfgName)(/*[in]*/ LPCOLESTR pszCfgName);
    STDMETHOD(RenameCfgsOfCfgName)(/*[in]*/ LPCOLESTR pszOldName, /*[in]*/ LPCOLESTR pszNewName);
    STDMETHOD(AddCfgsOfPlatformName)(/*[in]*/ LPCOLESTR pszPlatformName, /*[in]*/ LPCOLESTR pszClonePlatformName);
    STDMETHOD(DeleteCfgsOfPlatformName)(/*[in]*/ LPCOLESTR pszPlatformName);
    STDMETHOD(GetSupportedPlatformNames)(/*[in]*/ ULONG celt, /*[size_is, out, in]*/ BSTR rgbstr[], 
		/*[optional, out]*/ ULONG*pcActual);
    STDMETHOD(GetCfgProviderProperty)(/*[in]*/ VSCFGPROPID propid, /*[out]*/ VARIANT*pvar);
	STDMETHOD(AdviseCfgProviderEvents)(/*[in]*/ IVsCfgProviderEvents*pCPE, /*[out]*/ VSCOOKIE* pdwCookie);
    STDMETHOD(UnadviseCfgProviderEvents)(/*[in]*/ VSCOOKIE dwCookie);

// IVsHierarchyDeleteHandler
public:
	STDMETHOD(QueryDeleteItem)(/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp, /*[in]*/ VSITEMID itemid,
		/*[out, retval]*/ BOOL __RPC_FAR *pfCanDelete);
	STDMETHOD(DeleteItem)(/*[in]*/ VSDELETEITEMOPERATION dwDelItemOp, /*[in]*/ VSITEMID itemid);

// helpers
protected:
	HRESULT DoDeleteItem(VSDELETEITEMOPERATION dwDelItemOp, VSITEMID itemid, BOOL bCloseIfOpen = TRUE);

// IVsSccProject2
public:
	// helper method for SccGlyphChanged:
	void RecurseChildrenAndRefreshGlyphs( CVCNode* pHead );
    STDMETHOD(SccGlyphChanged)(/*[in]*/ int cAffectedNodes, /*[size_is, in]*/ const VSITEMID rgitemidAffectedNodes[],
        /*[size_is, in]*/ const VsStateIcon rgsiNewGlyphs[], /*[size_is, in]*/ const DWORD rgdwNewSccStatus[]);
    STDMETHOD(SetSccLocation)(/*[in]*/ LPCOLESTR pszSccProjectName, /*[in]*/ LPCOLESTR pszSccAuxPath,
		/*[in]*/ LPCOLESTR pszSccLocalPath, /*[in]*/ LPCOLESTR pszSccProvider);
    STDMETHOD(GetSccFiles)(/*[in]*/ VSITEMID, /*[out]*/ CALPOLESTR* pCaStringsOut, /*[out]*/ CADWORD* pCaFlagsOut);
    STDMETHOD(GetSccSpecialFiles)(/*[in]*/ VSITEMID, /*[in]*/ LPCOLESTR pszSccFile, /*[out]*/ CALPOLESTR *pCaStringsOut,
        /*[out]*/ CADWORD* pCaFlagsOut);

// IVsPersistSolutionOpts
public:
    STDMETHOD(SaveUserOptions)(IVsSolutionPersistence *pPersistence)
		{return E_NOTIMPL; /* CVCArchy::SaveUserOptions */ }
    STDMETHOD(LoadUserOptions)(IVsSolutionPersistence *pPersistence, VSLOADUSEROPTS grfLoadOpts)
		{return E_NOTIMPL; /* CVCArchy::LoadUserOptions */ }
    STDMETHOD(WriteUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);
    STDMETHOD(ReadUserOptions)(IStream *pOptionsStream, LPCOLESTR pszKey);

// IVsHierarchy
public:
	STDMETHOD(SetSite)(/*[in]*/ IServiceProvider *pSP);
	STDMETHOD(GetSite)(/*[out]*/ IServiceProvider **ppSP);
	STDMETHOD(QueryClose)(/*[out]*/ BOOL *pfCanClose);
// 	STDMETHOD(Close)(void);
	STDMETHOD(GetGuidProperty)(/*[in]*/ VSITEMID itemid, /*[in]*/ VSHPROPID propid, /*[out]*/ GUID* pguid);
	STDMETHOD(SetGuidProperty)(/*[in]*/ VSITEMID itemid, /*[in]*/ VSHPROPID propid, /*[in]*/ REFGUID guid);
	STDMETHOD(GetProperty)(/*[in]*/ VSITEMID itemid, /*[in]*/ VSHPROPID propid, /*[out]*/ VARIANT* pvar);
	STDMETHOD(SetProperty)(/*[in]*/ VSITEMID itemid, /*[in]*/ VSHPROPID propid, /*[in]*/ VARIANT var);
 	STDMETHOD(GetNestedHierarchy)(/*[in]*/ VSITEMID itemid, /*[in]*/ REFIID riid, /*[out]*/ void** ppHierarchyNested,
		/*[out]*/ VSITEMID* pitemidNested);
	STDMETHOD(GetCanonicalName)(/*[in]*/ VSITEMID itemid, /*[out]*/ BSTR* ppszName);
	STDMETHOD(ParseCanonicalName)(/*[in]*/ LPCOLESTR pszName, /*[out]*/ VSITEMID* pitemid);
	STDMETHOD(GetAutomationObject)(/*[out]*/ IDispatch** ppdisp);
	STDMETHOD(AdviseHierarchyEvents)(/*[in]*/ IVsHierarchyEvents *pEventSink, /*[out]*/ VSCOOKIE* pdwCookie);
	STDMETHOD(UnadviseHierarchyEvents)(/*[in]*/ VSCOOKIE dwCookie);
	STDMETHOD(Unused0)(void);
	STDMETHOD(Unused1)(void);
    STDMETHOD(Unused2)(void);
    STDMETHOD(Unused3)(void);
    STDMETHOD(Unused4)(void);
       
	// helpers for IVsHierarchy
	virtual HRESULT GetProperty(/*[in]*/ CVCNode* pNode, /*[in]*/ VSHPROPID propid, /*[out]*/ VARIANT* pvar);
	virtual HRESULT SetProperty(/*[in]*/ CVCNode* pNode, /*[in]*/ VSHPROPID propid, /*[in]*/ const VARIANT& var);

// IVsUIHierarchy
public:
    STDMETHOD (QueryStatusCommand)(/*[in]*/ VSITEMID itemid, /*[in, unique]*/ const GUID* pguidCmdGroup, /*[in]*/ ULONG cCmds,
		/*[in, out, size_is(cCmds)]*/ OLECMD prgCmds[], /*[in, out, unique]*/ OLECMDTEXT* pCmdText);
	STDMETHOD(ExecCommand)(/*[in]*/ VSITEMID itemid, /*[in, unique]*/ const GUID* pguidCmdGroup, /*[in]*/ DWORD nCmdID,
		/*[in]*/ DWORD nCmdexecopt, /*[in, unique]*/ VARIANT* pvaIn, /*[in, out, unique]*/ VARIANT* pvaOut);

// IVsPersistHierarchyItem
public:
    STDMETHOD(IsItemDirty)(/*[in]*/ VSITEMID vsid, /*[in]*/ IUnknown __RPC_FAR* punkDocData, /*[out]*/ BOOL __RPC_FAR* pfDirty);
    STDMETHOD(SaveItem)(/*[in]*/ VSSAVEFLAGS dwSave, /*[in]*/ LPCOLESTR lpstrMkDocument, /*[in]*/ VSITEMID vsid,
        /*[in]*/ IUnknown __RPC_FAR* punkDocData, /*[out]*/ BOOL __RPC_FAR* pfCanceled);

// IVsHierarchyDropDataSource
public:
	STDMETHOD(GetDropInfo)(/*[out]*/ DWORD* pdwOKEffects, /*[out]*/ IDataObject** ppDataObject,
		/*[out]*/ IDropSource** pDropSource);
	STDMETHOD(OnDropNotify)(/*[in]*/ BOOL fDropped, /*[in]*/ DWORD dwEffects);

// IVsHierarchyDropDataTarget
public:
	STDMETHOD(DragEnter)(/*[in]*/ IDataObject* pDataObj, /*[in]*/ DWORD grfKeyState, /*[in]*/ VSITEMID itemid,
		/*[out]*/ DWORD* pdwEffect);
	STDMETHOD(DragOver)(/*[in]*/ DWORD grfKeyState, /*[in]*/ VSITEMID itemid, /*[out]*/ DWORD* pdwEffect);
	STDMETHOD(DragLeave)(void);
	STDMETHOD(Drop)(/*[in]*/ IDataObject* pDataObj, /*[in]*/ DWORD grfKeyState, /*[in]*/ VSITEMID itemid,
		/*[out]*/ DWORD* pdwEffect);

// IVsHierarchyDropDataTarget helpers
	HRESULT GetDropEffect(DWORD grfKeyState, VSITEMID itemid, DWORD *pdwEffect);
	HRESULT GetSupportedDropEffects(DWORD *pdwEffects);
	HRESULT DragOver(DWORD grfKeyState, CVCNode *pNode, DWORD *pdwEffect);
	void AdviseClipboardEvents();
	void UnadviseClipboardEvents();

  // IVsUIHierWinClipboardHelperEvents
  STDMETHOD(OnPaste)(BOOL fDataWasCut, DWORD dwEffects);
  STDMETHOD(OnClear)(BOOL fDataWasCut);

// IOleCommandTarget
public:
	STDMETHOD(QueryStatus)(/*[unique, in]*/ const GUID* pguidCmdGroup, /*[in]*/ ULONG cCmds,
		/*[out, in, size_is]*/ OLECMD prgCmds[], /*[unique, out, in]*/ OLECMDTEXT* pCmdText);
	STDMETHOD(Exec)(/*[unique, in]*/ const GUID* pguidCmdGroup, /*[in]*/ DWORD nCmdID, /*[in]*/ DWORD nCmdexecopt,
		/*[unique, in]*/ VARIANT* pvaIn, /*[unique, out, in]*/ VARIANT* pvaOut);

//---------------------------------------------------------------------------
// ISupportItemHandoff
//---------------------------------------------------------------------------
	STDMETHOD(HandoffItem)(VSITEMID itemid, IVsProject3* pProjDest, LPCOLESTR pszMkDocumentOld, LPCOLESTR pszMkDocumentNew,
		IVsWindowFrame* punkWindowFrame);

//---------------------------------------------------------------------------
// IVsExtensibleObject
//---------------------------------------------------------------------------
	STDMETHOD(GetAutomationObject)(/*[in]*/ LPCOLESTR  pszPropName, /*[out]*/ IDispatch **ppDisp);

// IVsUpdateSolutionEvents
public:
    STDMETHOD(UpdateSolution_Begin)(BOOL* pbCancelUpdate) { return S_OK; }
    STDMETHOD(UpdateSolution_Done)(BOOL bSucceeded, BOOL bModified, BOOL bCancelCommand) { return S_OK; }
    STDMETHOD(UpdateSolution_StartUpdate)(BOOL* pbCancelUpdate) { return S_OK; }
    STDMETHOD(UpdateSolution_Cancel)() { return S_OK; }
    STDMETHOD(OnActiveProjectCfgChange)(IVsHierarchy* pIVsHierarchy);

// IVsProjectResources
public:
	STDMETHOD(GetResourceItem)( VSITEMID itemidDocument, LPCOLESTR pszCulture, VSPROJRESFLAGS grfPRF, VSITEMID* pitemidResource); 
	STDMETHOD(CreateResourceDocData)( VSITEMID itemidResource, IUnknown** punkDocData); 

// IVsProjectSpecificEditorMap
public:
	STDMETHOD(GetSpecificEditorType)(LPCOLESTR pszMkDocument, GUID *pguidEditorType);

// IVsProjectSpecificEditorMap2
public:
	STDMETHOD(GetSpecificLanguageService)(LPCOLESTR pszMkDocument, GUID *pguidLanguageService) { return E_NOTIMPL; }
	STDMETHOD(GetSpecificEditorProperty)(LPCOLESTR pszMkDocument, VSPSEPROPID propid, VARIANT *pvar);
	STDMETHOD(SetSpecificEditorProperty)(LPCOLESTR pszMkDocument, VSPSEPROPID propid, VARIANT var);

// helpers for IVsProjectSpecificEditorMap2
protected:
	BOOL IsResourceFile(LPCOLESTR pszMkDocument);

// Non-interface methods:
protected:
    void SetDirty(boolean fDirty) { m_fDirty = fDirty; }

	virtual UINT GetIconIndex(CVCNode* pNode, ICON_TYPE iconType);

	virtual HRESULT ExecSelection(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT* pvaIn, VARIANT *pvaOut,
		HierNodeList &rgSelection, BOOL bIsHierCmd);	// bIsHierCmd is TRUE if cmd originated via CVSUiHierarchy::ExecCommand

	virtual HRESULT QueryStatusSelection(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText,
		HierNodeList &rgSelection, BOOL bIsHierCmd);	// bIsHierCmd is TRUE if cmd originated via CVSUiHierarchy::ExecCommand

public:
// scc helpers that aren't in any interface.
    HRESULT RegisterSccProject(); // called by CVCProjectFactory
    HRESULT UnregisterSccProject();

	virtual HRESULT DisplayContextMenu(HierNodeList &rgSelection, VARIANT *pvaIn);

	CVCProjectNode* GetProjectNode(void)
	{
		VSASSERT(NULL != m_pRootNode, "Hierarchy has no root node!");
		return static_cast<CVCProjectNode *>(m_pRootNode);
	}
	VSITEMID ItemIDFromName (CVCNode *pRoot, LPCOLESTR pszMkDocument);
	HRESULT	VSITEMID2Node(VSITEMID itemid, CVCNode **pNode);
	HRESULT VSITEMID2Node(VSITEMID itemid, HierNodeList& rgNodeList);
	HRESULT GetSelectedNodes(HierNodeList& rgNodes);

public:
	HRESULT GetVCProject(CVCNode* pNode, VCProject** ppProject);
	HRESULT GetDispVCProject(CVCNode* pNode, IDispatch** ppDispProject);
	HRESULT CreateGenCfg(VCConfiguration* pProjCfg, IVCGenericConfiguration** ppGenCfg);
	HRESULT CompileFileItems(HierNodeList& rgSelection);

	// methods to inform the shell that configs have been
	// added/removed/renamed
	HRESULT InformConfigurationAdded( LPOLESTR pszCfgName );
	HRESULT InformConfigurationRemoved( LPOLESTR pszCfgName );
	HRESULT InformConfigurationRenamed( LPOLESTR pszOldCfgName, LPOLESTR pszNewCfgName );

private:
	VSITEMID DoItemIDFromName(CVCNode *pRoot, VARIANT_BOOL bFullOnly, LPCOLESTR pszMkDocument);

protected:
	HRESULT CanDirtyProject( void );
	CVCNode* ResolveProjNode(CVCNode* pNode);
	HRESULT GetCfgOfName(LPCOLESTR szCfgName, VCConfiguration** ppVCCfg);
	HRESULT GetSupportedPlatformNames(IVCCollection* pPlatforms, ULONG celt, BSTR rgbstr[], ULONG* pcActual);
	VARIANT_BOOL SupportsMultiplePlatforms();

public:	// get/set property methods
	void SetRootNode(CVCNode *pRootNode)
	{
		if (m_pRootNode)
			m_pRootNode->Release();
		m_pRootNode = pRootNode;
	}
	CVCNode* GetRootNode(void) const { return m_pRootNode; }
//	IVsHierarchy* GetVsHierarchy(void) const { return VCQI_cast<IVsHierarchy>(const_cast<CVCArchy*>(this)); }
	void SetImageList(HIMAGELIST hImageList) { m_hImageList = hImageList; }
	HIMAGELIST GetImageList(void) const { return m_hImageList; }
	BOOL IsZombie(void) const { return (m_pRootNode == NULL); }

	// return the controlling IUnk. A CComPtr copy is returned so that we don't lose the addref
	CComPtr<IVsHierarchy>	GetIVsHierarchy(void) const { return VCQI_cast<IVsHierarchy>( this ); }
	// return the controlling IUnk. A CComPtr copy is returned so that we don't lose the addref
	CComPtr<IVsUIHierarchy>   GetIVsUIHierarchy(void) const { return VCQI_cast<IVsUIHierarchy>( this ); }

    HRESULT RegisterClipboardNotifications(BOOL bRegister);
    // Returns our ui hierarchy window.
    HRESULT GetUIHierarchyWindow(IVsUIHierarchyWindow** ppIVsUIHierarchyWindow);

	IUnknown *GetParentHierarchy( void ) { return m_pParentHierarchy; }
	VSITEMID GetParentHierarchyItemID( void ) { return m_dwParentHierarchyItemid; }

	// private data members
private:
    boolean m_fDirty;
	boolean m_fRegisteredWithScc;
 	CComPtr<IVsCfgProviderEventsHelper> m_pCfgProviderEventsHelper;
	HIMAGELIST m_hImageList;
	CVCNode *m_pRootNode;
	static VSCOOKIE g_dwCookie;
	// Properties to support being a used as a nested hierarchy
	IUnknown *m_pParentHierarchy;
	VSITEMID m_dwParentHierarchyItemid;
	// cache this pointer to reduce QS
	CComPtr<IVsMonitorSelection> m_srpMonSel;
	CComPtr<IServiceProvider> m_srpServiceProvider;
	struct EventSink
	{		
		CComPtr<IVsHierarchyEvents> m_srpEventSink;
		DWORD m_dwCookie;
	};
	CSimpleArray<EventSink *> m_rgEventSinks;
	CVCNode* m_pCachedNode;
	UINT m_nCachedIconType;

protected:
    HRESULT DoShellDrop(CVCNode* pDropNode, HDROP hDropInfo, BOOL& bReported);
    HRESULT DoProjItemDrop(CVCNode* pDropNode, CVCOleDataObject& rDataObject, BOOL bDrag, DWORD dwDropEffect, BOOL& bReported);
	HRESULT GetDragDropNodesFromSelection(HierNodeList& rgSelection, CVCNodeArray& rgDragDropNodes);
	HRESULT OnAfterDropOrPaste(BOOL bWasCut, BOOL bWasMove, BOOL bDrag, BOOL bCleanupOnly);
	CVCProjDataSource* GetDataSource(DROPEFFECT* pde);
	HRESULT DragEnter(IDataObject* pDataObj, CVCNode* pNode);
	HRESULT OnCommandCut();
	HRESULT OnCommandCopy();
	HRESULT FlushClipboard();
	inline CVCExecutionCtx& GetExecutionCtx() { return CBuildPackage::s_executionCtx; }
	BOOL IsDropTargetCandidate(CVCNode* pNode);
	HRESULT PrepareShellDrop(CVCNode* pDropNode, CShellDropHelper& dropHelper, HDROP hDropInfo, int& iNumActual,
		bool& bContainsFolders);

public:
    HRESULT PasteFromClipboard(CVCNode *pDropNode);
    BOOL    CanPasteFromClipboard();

public:
	static BOOL	s_bStartedDrag;

    enum //Drop types
    {
        DT_NONE,
        DT_SHELL,
        DT_PROJITEM,
		DT_VSITEM,
		DT_VSREFITEM
    };

    int             m_dropType;
    BOOL            m_bInternalDrop;
	VSCOOKIE	    m_dwClipEvtCookie;// cookie for IVsUIHierWinClipboardHelperEvents advise

    // Our drag-drop and clipboard data objects.
    CVCProjDataSource*  m_pDragDropDataObject;
    CVCProjDataSource*  m_pClipboardDataObject;
    BOOL            m_bWasCut;
};

class CVCTrackProjectDocumentsBatcher
{
public:
            CVCTrackProjectDocumentsBatcher(BOOL bBatch);
            ~CVCTrackProjectDocumentsBatcher();

    HRESULT BeginBatch();
    HRESULT EndBatch();

protected:
    int m_cBatches;
	CComPtr<IVsTrackProjectDocuments> m_spTracker;
};

class CShellDropHelper
{
public:
	CShellDropHelper() : m_numFiles(0), m_rgFiles(NULL), m_rgActualFiles(NULL), m_hr(S_OK) {}
	~CShellDropHelper();
	int m_numFiles;
	LPWSTR* m_rgFiles;
	LPWSTR* m_rgActualFiles;
	HRESULT m_hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcbsnode.h ===
// VCBsNode.h: interface for the CVCBaseFolderNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(__VCBSNODE_H__)
#define __VCBSNODE_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "vc.h"
#include "VCNode.h"

class CVCArchy;

class CVCBaseFolderNode :
	public CVCNode
{
public:
	CVCBaseFolderNode();
	virtual ~CVCBaseFolderNode();

	// Message handlers. Public since called by more than just menu cmds.
	// IOleCommandTarget
	STDMETHOD(QueryStatus)(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut);

	UINT GetIconIndex();
	virtual HRESULT DisplayContextMenu();
	virtual HRESULT OnNewFolder();
	virtual HRESULT OnAddNewFiles();
	virtual HRESULT OnAddClass();
	virtual HRESULT OnAddExistingFiles();
	virtual HRESULT OnAddResource();
	virtual HRESULT QueryStatusAtIndex(CVCNode::enumKnownGuidList eGuid, const GUID* pguidCmdGroup, 
		OLECMD prgCmds[], OLECMDTEXT *pCmdText, ULONG nIndex);
	HRESULT	HandleAddItemDlg(
            /* [in] */ VSADDITEMOPERATION dwAddItemOperation,
            /* [in] */ LPCOLESTR pszItemName,
			/* [in] */ DWORD cFilesToOpen,
            /* [in] */ LPCOLESTR rgpszFilesToOpen[],
            /* [in] */ HWND hwndDlg,
            /* [retval][out] */ VSADDRESULT __RPC_FAR *pResult);

	virtual HRESULT OnDelete(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE){return E_NOTIMPL;}	// CVCBaseFolderNode
	virtual HRESULT CleanUpUI(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE){return E_NOTIMPL;} // CVCBaseFolderNode
	virtual UINT GetKindOf( void ){return Type_CVCBaseFolderNode;}
	virtual HRESULT Refresh(CVCArchy *pHierarchy);
	HRESULT OnAddWebRef();
	BOOL CanAddWebRef();

	BOOL HaveChildrenBeenEvaluated(void) const
	{
		return (m_grfStateFlags & ST_ChildrenEnumerated);
	}

	virtual VSITEMID GetFirstChild(void);
	virtual CVCNode* GetHeadEx(void);
	CVCNode* GetHead(void) const
	{
		return m_pHeadNode;
	}
	CVCNode* GetTail(void) const
	{
		return m_pTailNode;
	}
	long GetCount(void) const;	// return number of children
	CVCNode* GetPrevChildOf(const CVCNode* pCurrent) const;

	// Override to get custom add behavior suchas keeping the list sorted.
	// Default calls AddTail(). 
	virtual void Add(CVCNode *const pNode);
	void 	AddAfter(CVCNode* const pCurrNode, CVCNode* const pNewNode);
	void	AddHead(CVCNode *const pNode);
	void	AddTail(CVCNode *const pNode);
	virtual HRESULT Remove(CVCNode* pNode);
	virtual HRESULT Delete(CVCNode* pNode, CVCArchy *pHierarchy);
	virtual void	DeleteAll(CVCArchy *pHierarchy);

	virtual HRESULT GetProperty(VSHPROPID propid, VARIANT* pvar);
	virtual HRESULT SetProperty(VSHPROPID propid, const VARIANT & pvar);

	HRESULT OnPaste();
	BOOL CanPaste();


protected:
    enum    // m_grfStateFlags
    {
        ST_ChildrenEnumerated = (1<<0),
        ST_IsExpanded = (1<<1),
        ST_FirstUserFlag = (1<<16)  // Derived classes are free to use these upper bits
    };

	CVCNode*	m_pHeadNode;
	CVCNode*	m_pTailNode;
	DWORD m_grfStateFlags;
	BOOL m_fAutoExpand;
};

#endif // !defined(__VCBSNODE_H__)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcfile.cpp ===
// VCFile.cpp: implementation of the CVCFileNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VCFile.h"
#include "BldPkg.h"
#include "PrjNode.h"
#include "utils.h"
#include "..\resdll\gpcmd.h"
#include "vcarchy.h"
#include "vstrkdoc.h"
#include <vcguid.h>
#include "filegencfg.h"
#include "vcfgrp.h"
#include "VCPropObject.h"

#include "AutoFile.h"
#include "context.h"

#ifdef AARDVARK
#include <vsmanaged.h>
const GUID IID_ICSharpProject = {0xfae04ec0, 0x301f, 0x11d3, {0xbf, 0x4b, 0x0, 0xc0, 0x4f, 0x79, 0xef, 0xbc} };
#endif // AARDVARK

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// static member initialization

const LPOLESTR CVCFileNode::s_wszCATID = L"{EE8299C9-19B6-4f20-ABEA-E1FD9A33B683}";
extern "C" const GUID GUID_TextEditorFactory = { 0x8b382828L,0x6202,0x11d1,0x88,0x70,0x0, 0x0, 0xf8,0x75,0x79,0xd2 };


CVCFileNode::CVCFileNode() :
#ifdef AARDVARK
	m_eMagic( magicNotSet ),
	m_bstrDeployLoc( L"" ),
#endif // AARDVARK
	m_fDeleted( FALSE )
{
}

CVCFileNode::~CVCFileNode()
{
}

CVCProjectNode* CVCFileNode::GetVCProjectNode()
{
	return (CVCProjectNode*)GetRootNode();
}

UINT CVCFileNode::GetIconIndex(ICON_TYPE iconType)
{
 	UINT index = STATEICON_NOSTATEICON;
	CVCArchy *pArchy = NULL;

#ifdef AARDVARK
	if( iconType == ICON_StateImage )
		return STATEICON_NONE;

	// handle stateimages (SCC)
	else if( iconType == ICON_StateImage )
	{
		pArchy = (CVCArchy *)GetHierarchy();
		if (pArchy)
		{
			CComBSTR bstrPath;
			LPOLESTR pszFullPaths;
			VSSCCSTATUS dwSccStatus;
			
			bstrPath.Attach( GetFullPath() );
			pszFullPaths = bstrPath;
			index = STATEICON_NOSTATEICON;

			CComPtr<IVsSccManager2> srpIVsSccManager2;
			if (GetBuildPkg() && GetBuildPkg()->GetSccManager(&srpIVsSccManager2))
			{
				VsStateIcon siGlyph = STATEICON_NOSTATEICON;
				srpIVsSccManager2->GetSccGlyph(1, &pszFullPaths, &siGlyph, &dwSccStatus);
				index = siGlyph;
			}
		}
	}
	else
	{
		CVCNode *pParent = GetParent();
		UINT kind = pParent->GetKindOf();
		if( kind == Type_CVCFileGroup )
		{
			CComBSTR bstrParentName;
			static_cast<CVCFileGroup*>(pParent)->GetName( &bstrParentName );
			// if we're in the References folder, we're a ref
			if( wcscmp( bstrParentName, L"References" ) == 0 )
				return BMP_REFERENCE;
			// if we're in the Satellite DLLs folder, we're a satellite dll
			if( wcscmp( bstrParentName, L"Satellite DLLs" ) == 0 )
				return BMP_SATELLITE;
			// if we're in the "Built" folder, we're a satellite dll
			if( wcscmp( bstrParentName, L"Built" ) == 0 )
				return BMP_OUTPUTS;
		}

		// get the file 
		CComPtr<VCFile> pVCFile;
		GetVCFile( &pVCFile );
		// get the extension
		CComBSTR bstrExt;
		pVCFile->get_Extension( &bstrExt );

		// C++ file?
		if( _wcsicmp( bstrExt, L".cpp" ) == 0 || _wcsicmp( bstrExt, L".h" ) == 0 )
		{
			if( IsBuildable() )
				index = BMP_BUILDABLEITEM;
			else
				index = BMP_NONBUILDABLEITEM;
		}
		// C# file?
		else if( _wcsicmp( bstrExt, L".cs" ) == 0 )
		{
			// if the magic enum wasn't set, set it
			if( m_eMagic == magicNotSet )
			{
				CComBSTR bstrName;
				GetName( &bstrName );
				// win form?
				if( wcsncmp( bstrName, L"Form", wcslen( L"Form" ) ) == 0 )
					m_eMagic = magicWinForm;
				// user control?
				else if( wcsncmp( bstrName, L"UserControl", wcslen( L"UserControl" ) ) == 0 )
					m_eMagic = magicUserControl;
				// class?
				else if( wcsncmp( bstrName, L"Class", wcslen( L"Class" ) ) == 0 )
					m_eMagic = magicClass;
				// web custom ctrl?
				else if( wcsncmp( bstrName, L"WebCustomControl", wcslen( L"WebCustomControl" ) ) == 0 )
					m_eMagic = magicWebCustomControl;
				// normal source
				else
					m_eMagic = magicNone;
			}
			switch( m_eMagic )
			{
			case magicWinForm:
				index = BMP_WINFORM;
				break;
			case magicUserControl:
				index = BMP_CONTROL;
				break;
			case magicClass:
				index = BMP_CLASS;
				break;
			case magicWebCustomControl:
				index = BMP_WEBCUSTOMCONTROL;
				break;
			default:
				index = BMP_CSFILE;
			}
		}
		// vb file?
		else if( _wcsicmp( bstrExt, L".vb" ) == 0 )
		{
			// if the magic enum wasn't set, set it
			if( m_eMagic == magicNotSet )
			{
				CComBSTR bstrName;
				GetName( &bstrName );
				// win form?
				if( wcsncmp( bstrName, L"Form", wcslen( L"Form" ) ) == 0 )
					m_eMagic = magicWinForm;
				// user control?
				else if( wcsncmp( bstrName, L"UserControl", wcslen( L"UserControl" ) ) == 0 )
					m_eMagic = magicUserControl;
				// class?
				else if( wcsncmp( bstrName, L"Class", wcslen( L"Class" ) ) == 0 )
					m_eMagic = magicClass;
				// web custom ctrl?
				else if( wcsncmp( bstrName, L"WebCustomControl", wcslen( L"WebCustomControl" ) ) == 0 )
					m_eMagic = magicWebCustomControl;
				// normal source
				else
					m_eMagic = magicNone;
			}
			switch( m_eMagic )
			{
			case magicWinForm:
				index = BMP_WINFORM;
				break;
			case magicUserControl:
				index = BMP_CONTROL;
				break;
			case magicClass:
				index = BMP_CLASS;
				break;
			case magicWebCustomControl:
				index = BMP_WEBCUSTOMCONTROL;
				break;
			default:
				index = BMP_VBFILE;
			}
		}
		// xsd file?
		else if( _wcsicmp( bstrExt, L".xsd" ) == 0 )
			index = BMP_XSD;
		// xml file?
		else if( _wcsicmp( bstrExt, L".xml" ) == 0 )
			index = BMP_XML;
		// web form file?
		else if( _wcsicmp( bstrExt, L".aspx" ) == 0 )
			index = BMP_WEBFORM;
		// asax file?
		else if( _wcsicmp( bstrExt, L".asax" ) == 0 )
			index = BMP_GLOBALASAX;
		// web service file?
		else if( _wcsicmp( bstrExt, L".asmx" ) == 0 )
			index = BMP_WEBSERVICE;
		// web user control file?
		else if( _wcsicmp( bstrExt, L".ascx" ) == 0 )
			index = BMP_WEBCONTROL;
		// asp file?
		else if( _wcsicmp( bstrExt, L".asp" ) == 0 )
			index = BMP_ASPPAGE;
		// web.config file?
		else if( _wcsicmp( bstrExt, L".config" ) == 0 )
			index = BMP_WEBCONFIG;
		// html file?
		else if( _wcsicmp( bstrExt, L".html" ) == 0 || _wcsicmp( bstrExt, L".htm" ) == 0 )
			index = BMP_HTML;
		// css file?
		else if( _wcsicmp( bstrExt, L".css" ) == 0 )
			index = BMP_CSS;
		// bmp file?
		else if( _wcsicmp( bstrExt, L".bmp" ) == 0 )
			index = BMP_BMP;
		// ico file?
		else if( _wcsicmp( bstrExt, L".ico" ) == 0 )
			index = BMP_ICO;
		// resx file?
		else if( _wcsicmp( bstrExt, L".resx" ) == 0 )
			index = BMP_RESX;
		// script file?
		else if( _wcsicmp( bstrExt, L".vbs" ) == 0 || _wcsicmp( bstrExt, L".js" ) == 0 )
			index = BMP_SCRIPT;
		// vcstyle file?
		// TODO: need vcstyle icon
		else if( _wcsicmp( bstrExt, L".vcstyle" ) == 0 )
			index = BMP_CSS;
		// unknown file type
		else
			index = BMP_NONBUILDABLEITEM;
	}
	return index;
#else
	if( iconType == ICON_Open )
	{
		index = BMP_FOLDER;
	}
	// handle stateimages (SCC)
	else if( iconType == ICON_StateImage )
	{
		pArchy = (CVCArchy *)GetHierarchy();
		if (pArchy)
		{
			index = STATEICON_NOSTATEICON;
			if (GetServiceProvider() != NULL)
			{
				CComPtr<VCFile> spFile;
				GetVCFile(&spFile);
				VARIANT_BOOL bScc = VARIANT_TRUE;
				if (spFile)
				{
					CComPtr<IDispatch> spDispParent;
					spFile->get_Parent(&spDispParent);
					CComQIPtr<VCFilter> spFilterParent = spDispParent;
					if (spFilterParent)
						spFilterParent->get_SourceControlFiles(&bScc);
				}
				if (bScc)
				{
					CComBSTR bstrPath;
					LPOLESTR pszFullPaths;
					VSSCCSTATUS dwSccStatus;
					
					bstrPath.Attach( GetFullPath() );
					pszFullPaths = bstrPath;

					CComPtr<IVsSccManager2> srpIVsSccManager2;
					if (GetBuildPkg() && GetBuildPkg()->GetSccManager(&srpIVsSccManager2))
					{
						VsStateIcon siGlyph = STATEICON_NOSTATEICON;
						srpIVsSccManager2->GetSccGlyph(1, &pszFullPaths, &siGlyph, &dwSccStatus);
						index = siGlyph;
					}
				}
			}
		}
	}
	else
	{
		if( IsBuildable() )
			index = BMP_BUILDABLEITEM;
		else
			index = BMP_NONBUILDABLEITEM;
	}
	return index;
#endif // AARDVARK
}

HRESULT CVCFileNode::DoPreview()
{
	CComBSTR bstrPath;
	bstrPath = GetFullPath();
	
	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;	
	HRESULT hr = ExternalQueryService(SID_SVsUIShellOpenDocument,
							  IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Unable to obtain IVsUIShellOpenDocument service!  Did the ID change?  Do you need to investigate threading issues?");
	RETURN_ON_FAIL_OR_NULL(hr, pVsUIShellOpenDoc);
						  
	DWORD dwReserved = 0;
	DWORD dwPrevFlags = 0;
	return pVsUIShellOpenDoc->OpenStandardPreviewer(dwPrevFlags, bstrPath, PR_Default, dwReserved);
}

HRESULT CVCFileNode::DoDefaultAction(BOOL fNewFile)
{
	HRESULT hr = S_OK;

#ifdef AARDVARK
	BOOL bHandled = FALSE;
	hr = HandleOpenForm(bHandled);
	if (bHandled)
		return hr;
#endif	// AARDVARK

	CComBSTR bstrPath;
	bstrPath = GetFullPath();

	// special case: RC files should cause the Resource View to open, not the
	// standard editor (which would open the "comp view" stand-alone resource editor)
	CPathW path;
	path.Create( bstrPath );
	const wchar_t* wszExt = path.GetExtension();
	if( _wcsicmp( wszExt, L".rc" ) == 0 )
		return OpenResourceEditor(bstrPath);

	else if( _wcsicmp( wszExt, L".bsc" ) == 0 )
		return OpenBscEditor(bstrPath);

	else if( _wcsicmp( wszExt, L".asmx" ) == 0 || _wcsicmp( wszExt, L".asax" ) == 0 )
		return OpenAsmxEditor(bstrPath);

	else
	{
		return OpenNormalEditor(bstrPath, OSE_ChooseBestStdEditor, GUID_NULL, fNewFile);
	}
}

#ifdef AARDVARK
HRESULT CVCFileNode::HandleOpenForm(BOOL& bHandled)
{
	bHandled = FALSE;
	if( m_eMagic == magicWinForm || m_eMagic == magicUserControl || m_eMagic == magicWebCustomControl )
	{
		bHandled = TRUE;
		// magic...
		CComBSTR bstrFilename;
		GetName( &bstrFilename );
		// look for a C# project in the solution
		CComPtr<IVsSolution> pVsSolution;
		HRESULT hr = ExternalQueryService(__uuidof(IVsSolution), __uuidof(IVsSolution), (void **)&pVsSolution);
		// get the hierarchies enumeration
		CComPtr<IEnumHierarchies> pHierEnum;

		hr = pVsSolution->GetProjectEnum( EPF_ALL, IID_ICSharpProject, &pHierEnum );
		if( FAILED( hr ) || !pHierEnum )
			return hr;
		// for each hierarchy
		CComBSTR bstrProjUniqueName;
		pHierEnum->Reset();
		// find the "WindowsApplication1" project
		while ( true )
		{
			CComQIPtr<IVsHierarchy> pHierarchy;
			hr = pHierEnum->Next( 1, &pHierarchy, NULL );
			if( hr != S_OK || !pHierarchy )
				break;
			// GetProp its VSHPROPID_ExtObject to get the shell project
			CComVariant var;
			CComQIPtr<Project> pProj;
			hr = pHierarchy->GetProperty( VSITEMID_ROOT, VSHPROPID_ExtObject, &var );
			pProj = var.pdispVal;
			if (pProj == NULL)
				return S_OK;
			// is this the right project?
			CComBSTR bstrName;
			hr = pProj->get_Name( &bstrName );
			if( FAILED( hr ) ) return hr;
			if( _wcsicmp( bstrName, L"WindowsApplication1" ) != 0 )
				continue;
			// get the project item of this filename
			CComPtr<ProjectItems> pProjectItems;
			hr = pProj->get_ProjectItems( &pProjectItems );
			if( FAILED( hr ) ) return hr;
			CComPtr<ProjectItem> pProjectItem;
			hr = pProjectItems->Item( CComVariant( bstrFilename ), &pProjectItem );
			if( FAILED( hr ) ) return hr;
			CComPtr<Window> pEditWnd;
			hr = pProjectItem->Open( CComBSTR( L"{7651A702-06E5-11D1-8EBD-00A0C90F26EA}" ), &pEditWnd );
			if( FAILED( hr ) ) return hr;
			// open filename in that project instead...
			CComPtr<_DTE> pDTE;
			hr = ExternalQueryService(SID_SDTE, __uuidof(_DTE), (void **)&pDTE);
			if( FAILED( hr ) ) return hr;
			CComPtr<Windows> pWindows;
			hr = pDTE->get_Windows( &pWindows );
			if( FAILED( hr ) ) return hr;
			CComPtr<Window> pSlnExplorer;
			hr = pWindows->Item( CComVariant( vsWindowKindSolutionExplorer ), &pSlnExplorer );
			if( FAILED( hr ) ) return hr;
// 			// hide sln explorer
// 			hr = pSlnExplorer->put_Visible( VARIANT_FALSE );
// 			if( FAILED( hr ) ) return hr;
			// show designer
			hr = pEditWnd->put_Visible( VARIANT_TRUE );
			if( FAILED( hr ) ) return hr;
			break;
		}
		return S_OK;
	}
}
#endif	// AARDVARK

HRESULT CVCFileNode::OpenResourceEditor(CComBSTR& bstrPath)
{
	if (GetBuildPkg() && GetBuildPkg()->UseGlobalEditorForResourceFiles())
		return OpenNormalEditor(bstrPath, OSE_ChooseBestStdEditor, GUID_NULL, FALSE);
	
	// this is an rc file, open resource view
	CComPtr<IOleCommandTarget> pCmdTgt;
	HRESULT hr = ExternalQueryService( SID_SUIHostCommandDispatcher, IID_IOleCommandTarget, (void**)&pCmdTgt );
	RETURN_ON_FAIL_OR_NULL(hr, pCmdTgt);
	hr = pCmdTgt->Exec( &CLSID_StandardCommandSet97, cmdidResourceView, OLECMDEXECOPT_DODEFAULT, NULL, NULL );
	RETURN_ON_FAIL(hr);

	// Go get the ui hierarchy window
	CComPtr<IVsUIShell> pIVsUIShell;
	hr = GetBuildPkg()->GetVsUIShell(&pIVsUIShell, TRUE /* in main thread */);
	RETURN_ON_FAIL_OR_NULL(hr, pIVsUIShell);

	CComPtr<IVsWindowFrame> pIVsWindowFrame;
	hr = pIVsUIShell->FindToolWindow( NULL, GUID_ResourceView, &pIVsWindowFrame);
	RETURN_ON_FAIL_OR_NULL(hr, pIVsWindowFrame);

	CComVariant var;
	hr = pIVsWindowFrame->GetProperty( VSFPROPID_DocView, &var );
	RETURN_ON_FAIL(hr);
	if( var.vt != VT_UNKNOWN )
		return E_FAIL;

	CComPtr<IVsWindowPane> pIVsWindowPane;
	hr = var.punkVal->QueryInterface( IID_IVsWindowPane, (void **)&pIVsWindowPane );
	VSASSERT( pIVsWindowPane, "Unable to get IVsWindowPane pointer!" );
	RETURN_ON_FAIL_OR_NULL(hr, pIVsWindowPane);

	CVCProjectNode* pProjNode = GetVCProjectNode();
	RETURN_ON_NULL(pProjNode);

	// Save the file
	CComPtr<IVsHierarchy> spHier;
	hr = pProjNode->GetVsHierarchy(&spHier, TRUE);
	RETURN_ON_FAIL_OR_NULL(hr, spHier);

	CComVariant varName;
	spHier->GetProperty(VSITEMID_ROOT, VSHPROPID_Name, &varName);

	// expand to the correct node
	CComPtr<IVsClassView> pClassView;
	hr = pIVsWindowPane->QueryInterface( IID_IVsClassView, (void **)&pClassView );
	VSASSERT( pClassView, "Unable to get IVsClassView pointer!" );
	RETURN_ON_FAIL_OR_NULL(hr, pClassView);
	CComBSTR bstrFileName;
	get_Name( &bstrFileName );
	// don't ask me where the $#@%^ this guid is defined, I can't find it
	// anywhere, but this IS the correct guid
	// guidResviewLibrary = {D22514E7-23AF-4723-B6E5-E17D27626D34}
	CLSID Guid;
	CLSIDFromString( L"{D22514E7-23AF-4723-B6E5-E17D27626D34}", &Guid );
	wchar_t *wszLibName = varName.bstrVal;
	wchar_t *wszNspcName = bstrFileName;
	wchar_t *wszClassName = L"";
	wchar_t *wszMemberName = L"";
	VSOBJECTINFO objInfo;
	objInfo.pguidLib = &Guid;
	objInfo.pszLibName = wszLibName;
	objInfo.pszNspcName = wszNspcName;
	objInfo.pszClassName = wszClassName;
	objInfo.pszMemberName = wszMemberName;
	objInfo.dwCustom      = 0;
	pClassView->NavigateTo( &objInfo, 9);

	return hr;
}

HRESULT CVCFileNode::OpenBscEditor(CComBSTR& bstrPath)
{
	CComPtr<IVsObjBrowser> spOB;
	HRESULT hr = ExternalQueryService( SID_SVsObjBrowser, IID_IVsObjBrowser, (void**)&spOB );
	RETURN_ON_FAIL_OR_NULL(hr, spOB);

	// Navigate to the BSC file
	CComBSTR bstrFileName;
	get_FullPath( &bstrFileName );
	CLSID Guid;
	CLSIDFromString( L"{26E73A17-0D6C-4a33-B833-22C76C50949F}", &Guid );
	wchar_t *wszLibName = bstrFileName;
	wchar_t *wszNspcName = L"";
	wchar_t *wszClassName = L"";
	wchar_t *wszMemberName = L"";
	VSOBJECTINFO objInfo;
	objInfo.pguidLib = &Guid;
	objInfo.pszLibName = wszLibName;
	objInfo.pszNspcName = wszNspcName;
	objInfo.pszClassName = wszClassName;
	objInfo.pszMemberName = wszMemberName;
	objInfo.dwCustom      = 0;
	spOB->NavigateTo( &objInfo, 0);

	return hr;
}

HRESULT CVCFileNode::OpenAsmxEditor(CComBSTR& bstrPath)
{
	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;  
	HRESULT hr = ExternalQueryService(SID_SVsUIShellOpenDocument, 
							  IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Unable to obtain IVsUIShellOpenDocument service!  Did the ID change?  Do you need to investigate threading issues?");
	RETURN_ON_FAIL_OR_NULL(hr, pVsUIShellOpenDoc);
                      
	CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(GetHierarchy());
	CComPtr<IVsWindowFrame> pFrame;
	hr = pVsUIShellOpenDoc->OpenSpecificEditor(NULL,
											bstrPath,
											GUID_TextEditorFactory,
											NULL,
											GUID_NULL,
											L"%3", // base filename
											spHier,
											(VSITEMID)GetVsItemID(),
											DOCDATAEXISTING_UNKNOWN,
											GetServiceProvider(),
											&pFrame);

	if (FAILED(hr))
	{
		CComPtr<IVsUIShell> pUIShell;
		HRESULT hrT;

		hrT = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
		if (SUCCEEDED(hrT) && pUIShell)
		{
			CStringW strMsg;
			CComBSTR bstrMsg = bstrPath;
			bstrMsg.Append(L"\n");
			strMsg.LoadString( g_hInstLocale, IDS_ERROR_OPEN);
			bstrMsg.Append(strMsg);
			pUIShell->SetErrorInfo(E_FAIL, bstrMsg, 0, NULL, NULL);
		}
	}
	if(hr == S_OK && pFrame)
	{
		pFrame->Show();
	}

	return hr;
}

HRESULT CVCFileNode::OpenNormalEditor(CComBSTR& bstrPath, VSOSEFLAGS grfOpenStandard, REFGUID rguidLogicalView, BOOL fNewFile)
{
	CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;  
	HRESULT hr = ExternalQueryService(SID_SVsUIShellOpenDocument, 
							  IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
	VSASSERT(SUCCEEDED(hr), "Unable to obtain IVsUIShellOpenDocument service!  Did the ID change?  Do you need to investigate threading issues?");
	RETURN_ON_FAIL_OR_NULL(hr, pVsUIShellOpenDoc);
                      
	CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(GetHierarchy());
	CComPtr<IVsWindowFrame> pFrame;

	if(fNewFile)
		grfOpenStandard |= OSE_OpenAsNewFile;
	
	hr = pVsUIShellOpenDoc->OpenStandardEditor(grfOpenStandard, bstrPath, rguidLogicalView, L"%3" /* base filename */, 
		spHier, (VSITEMID)GetVsItemID(), DOCDATAEXISTING_UNKNOWN, GetServiceProvider(), &pFrame);
	RETURN_ON_FAIL(hr);

	if (FAILED(hr))
	{
		CComPtr<IVsUIShell> pUIShell;
		HRESULT hrT;

		hrT = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
		if (SUCCEEDED(hrT) && pUIShell)
		{
			CStringW strMsg;
			CComBSTR bstrMsg = bstrPath;
			bstrMsg.Append(L"\n");
			strMsg.LoadString( g_hInstLocale, IDS_ERROR_OPEN);
			bstrMsg.Append(strMsg);
			pUIShell->SetErrorInfo(E_FAIL, bstrMsg, 0, NULL, NULL);
		}
	}
	if(hr == S_OK && pFrame)
	{
		if(fNewFile)
		{
			CComVariant var;
			pFrame->GetProperty(VSFPROPID_DocData, &var);
			CComQIPtr<IVsPersistDocData> pDocData;
			if(V_VT(&var) == VT_UNKNOWN )
				pDocData = V_UNKNOWN(&var);
			if(pDocData != NULL)
				pDocData->SetUntitledDocPath(bstrPath);
		}
		pFrame->Show();
	}

	return hr;
}

HRESULT CVCFileNode::DisplayContextMenu(VARIANT *pvaIn)
{
	CComPtr<IOleCommandTarget> spTarget = VCQI_cast<IOleCommandTarget>(GetHierarchy())/*(this)*/;
	return ShowContextMenu(IDM_VS_CTXT_ITEMNODE, pvaIn, guidSHLMainMenu, spTarget);
}

HRESULT CVCFileNode::GetCanonicalName(BSTR* pbstrName)
{
	CComPtr<VCFile> spFile;
	GetVCFile(&spFile);
	CHECK_ZOMBIE(spFile, IDS_ERR_FILE_ZOMBIE);

	return spFile->get_FullPath(pbstrName);
}

HRESULT CVCFileNode::GetName(BSTR* pbstrName)
{
	CComPtr<VCFile> spFile;
	GetVCFile(&spFile);
	CHECK_ZOMBIE(spFile, IDS_ERR_FILE_ZOMBIE);

	return spFile->get_Name(pbstrName);
}

//-----------------------------------------------------------------------------
//	Called to update the status for each command
//-----------------------------------------------------------------------------
STDMETHODIMP CVCFileNode::QueryStatus(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	CVCNode::enumKnownGuidList eGuid = CVCNode::eGuidUninitialized;
	if (*pguidCmdGroup == guidVSStd2K)
		eGuid = eGuidVSStd2K;
	else	// let the base class handle it
		return CVCNode::QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);

	HRESULT hr = NOERROR;
	for (ULONG i = 0; i < cCmds && SUCCEEDED(hr); i++)
		hr = QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, i);

	return hr;
}

HRESULT CVCFileNode::QueryStatusAtIndex(CVCNode::enumKnownGuidList eGuid, const GUID* pguidCmdGroup, OLECMD prgCmds[],
	OLECMDTEXT *pCmdText, ULONG nIndex)
{
	if (eGuid == CVCNode::eGuidUninitialized)
	{
		if (*pguidCmdGroup == guidVSStd2K)
			eGuid = CVCNode::eGuidVSStd2K;
		else if (*pguidCmdGroup == guidVSStd97)
			eGuid = CVCNode::eGuidVSStd97;
		else
			return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
	}

	enumEnableStates fEnable = eEnableSupported;
	if (eGuid == CVCNode::eGuidVSStd2K)
	{
		switch(prgCmds[nIndex].cmdID)
		{
		case ECMD_COMPILE:
			if( IsBuildable() )
				fEnable = eEnableSupportedAndEnabled;
			else
				fEnable = eEnableSupported;
			break;
		case ECMD_UPDATEWEBREFERENCE:
			if( IsWSDL() )
				fEnable = eEnableSupportedAndEnabled;
			else
				fEnable = eEnableNotSupported;
			break;
		default:
			return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
		}
	}
	else if (eGuid == CVCNode::eGuidVSStd97)
	{	
		// Common VS commands
		switch(prgCmds[nIndex].cmdID)
		{
		case cmdidOpen:
		case cmdidOpenWith:
		case cmdidCut:
		case cmdidCopy:
			fEnable = eEnableSupportedAndEnabled; // && GetProjectNode()->IsSourceControlled() && !IsInSourceControl();
			break;
		case cmdidPaste:
			return GetParent()->QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
		case cmdidPreviewInBrowser:
			if( IsHTML() )
				fEnable = eEnableSupportedAndEnabled;
			else
				fEnable = eEnableNotSupported;
			break;
		case cmdidRename:
			fEnable = eEnableSupportedAndInvisible;
			break;
		default:
			return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
		}
	}

	prgCmds[nIndex].cmdf = TranslateEnableState(fEnable);
	if (prgCmds[nIndex].cmdf == 0)
		return OLECMDERR_E_NOTSUPPORTED;

	return NOERROR;
}

//-----------------------------------------------------------------------------
// Called to execute our commands
//-----------------------------------------------------------------------------
STDMETHODIMP CVCFileNode::Exec(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	if(*pguidCmdGroup == guidVSStd2K)
	{
		switch(nCmdID)
		{
			case ECMD_COMPILE:
				return OnCompileFile();
			case ECMD_PROJSETTINGS:
				return ShowSettings(CLSID_FileNodeProps);
			case ECMD_UPDATEWEBREFERENCE:
				return OnRefreshWebRef();
			default:
				return CVCNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); // OLECMDERR_E_NOTSUPPORTED;
		}
	}
	else if(*pguidCmdGroup == guidVSStd97)
	{	
		switch(nCmdID)
		{
			case cmdidPreviewInBrowser:
				DoPreview();
				return S_OK;
			case cmdidOpen:
				return DoDefaultAction(FALSE); // Open File;
			case cmdidOpenWith:
				return OpenWith(); // Open File;
			case cmdidPaste:
				return static_cast<CVCBaseFolderNode*>(GetParent())->OnPaste();

			default:
				return CVCNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); // OLECMDERR_E_NOTSUPPORTED;
		}
	}

	// Unknown command set
	return OLECMDERR_E_NOTSUPPORTED;
}

HRESULT CVCFileNode::SetProperty(VSHPROPID propid, const VARIANT& var)
{
	// handle file node properties here...
	return CVCNode::SetProperty(propid, var);
}

HRESULT CVCFileNode::GetGuidProperty( VSHPROPID propid, GUID *pguid)
{
	CHECK_POINTER_NULL(pguid);

	*pguid = GUID_ItemType_PhysicalFile;
	return S_OK;
}

//---------------------------------------------------------------------------
//	Returns the requested property in the given variant.
//---------------------------------------------------------------------------
HRESULT CVCFileNode::GetProperty(VSHPROPID propid, VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);
	// handle file node properties here...
	HRESULT hr = E_FAIL;
	CComVariant varRes;
	switch( propid )
	{
	case VSHPROPID_Name:
	case VSHPROPID_SaveName:
	case VSHPROPID_Caption:
	{	// return this node's displayed caption
		V_VT(pvar) = VT_BSTR;
		CComBSTR bstrName;
		hr = GetName(&bstrName);
		if (SUCCEEDED(hr))
			pvar->bstrVal = bstrName.Detach();
		return hr;
	}
	case VSHPROPID_UserContext:
	{
		varRes.ChangeType(VT_UNKNOWN);
		varRes.punkVal = NULL;

		CComPtr<IVsUserContext> pUserCtx;
		CComPtr<IVsMonitorUserContext> pmuc;
		if (SUCCEEDED(ExternalQueryService(SID_SVsMonitorUserContext, IID_IVsMonitorUserContext, (void **)&pmuc)) && pmuc)
		{
			pmuc->CreateEmptyContext(&pUserCtx);
			if (pUserCtx)
			{
				CComQIPtr<VCFile> pFile = m_dispkeyItem;
				RETURN_ON_NULL(pFile);
				CComBSTR bstrName;
				pFile->get_Name( &bstrName );
				CPathW path;
				path.Create( bstrName );
				CStringW strExt = path.GetExtension();
				if( strExt.GetLength()  > 0 )
				{
					strExt = strExt.Right( strExt.GetLength()-1 );
					pUserCtx->AddAttribute(VSUC_Usage_Filter, L"item", strExt);
				}
				varRes = pUserCtx;
				hr = S_OK;
			}
		}
		break;
	}
	case VCPROPID_ProjBldActiveFileConfig:
	{
		hr = GetActiveVCFileConfig(&V_DISPATCH(pvar));
		if (SUCCEEDED(hr))
		{
			V_VT(pvar) = VT_DISPATCH;
			return S_OK;
		}
		break;
	}

	case VCPROPID_ProjBldIncludePath:
	{
		hr = GetVCIncludePath(&V_BSTR(pvar));
		if (hr == S_OK)
		{
			V_VT(pvar) = VT_BSTR;
			return S_OK;
		}
		break;
	}

	case VSHPROPID_ConfigurationProvider:
	{
		varRes.ChangeType(VT_UNKNOWN);
		IUnknown *pUnk = NULL;
		hr = QueryInterface(IID_IUnknown, (void **)&pUnk);
		varRes = pUnk;
		pUnk->Release();
		break;
	}

	default:
		hr = CVCNode::GetProperty(propid, &varRes);
		break;
	}
	varRes.Detach(pvar);
	return hr;
}

HRESULT CVCFileNode::GetActiveVCFileConfig(IDispatch** ppDispFileCfg)
{
	CHECK_POINTER_NULL(ppDispFileCfg);

	CComQIPtr<IVCFileImpl> spFileImpl = m_dispkeyItem;
	RETURN_ON_NULL(spFileImpl);

	CComPtr<IDispatch> spDispProjCfg;
	HRESULT hr = GetActiveVCProjectConfig(&spDispProjCfg);
	CComQIPtr<VCConfiguration> spProjCfg = spDispProjCfg;
	RETURN_ON_FAIL_OR_NULL(hr, spProjCfg);

	CComPtr<VCFileConfiguration> spFileCfg;
	hr = spFileImpl->GetFileConfigurationForProjectConfiguration(spProjCfg, &spFileCfg);
	RETURN_ON_FAIL_OR_NULL(hr, spFileCfg);

	return spFileCfg->QueryInterface(IID_IDispatch, (void **)ppDispFileCfg);
}

HRESULT CVCFileNode::GetVCIncludePath(BSTR* pbstrIncPath)
{
	CHECK_POINTER_NULL(pbstrIncPath);
	*pbstrIncPath = NULL;

	CComPtr<IDispatch> spDispFileCfg;
	HRESULT hr = GetActiveVCFileConfig(&spDispFileCfg);
	RETURN_ON_FAIL(hr);

	CComQIPtr<VCFileConfiguration> spFileCfg = spDispFileCfg;
	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spDispFileCfg;
	if (spFileCfg == NULL || spFileCfgImpl == NULL)
		return hr;

	// first, let's try to pick it up via the tool
	CComPtr<IDispatch> spDispTool;
	hr = spFileCfg->get_Tool(&spDispTool);
	CComQIPtr<VCCustomBuildTool> pCustom = spDispTool;
	CComQIPtr<IVCToolImpl> spToolImpl = spDispTool;
	if( SUCCEEDED(hr) && spToolImpl && (spDispTool == NULL) )
		return spToolImpl->get_FullIncludePathInternal(pbstrIncPath);

	// oh, well.  At least we can fall back on the project level stuff for the C++ tool.
	CComPtr<IDispatch> spDispProjCfg;
	hr = spFileCfgImpl->get_Configuration(&spDispProjCfg);
	CComQIPtr<VCConfiguration> spProjCfg = spDispProjCfg;
	RETURN_ON_FAIL_OR_NULL(hr, spProjCfg);

	CComPtr<IDispatch> pDispColl;
	spProjCfg->get_Tools(&pDispColl);
	CComQIPtr<IVCCollection> pToolsColl = pDispColl;
	if( pToolsColl )
	{
		CComBSTR bstrName( L"VCCLCompilerTool");		// mutli platform ???
		CComPtr<IDispatch> pDispTool;
		hr = pToolsColl->Item( CComVariant( bstrName ), &pDispTool );
		CComQIPtr<IVCToolImpl> spToolImpl = pDispTool;
		if (SUCCEEDED(hr) && spToolImpl)
			return spToolImpl->get_FullIncludePathInternal(pbstrIncPath);
	}

	// oh, well.  At least we can fall back on the platform level stuff.
	// start out by picking up the platform includes
	CComPtr<IDispatch> spDispPlatform;
	hr = spProjCfg->get_Platform(&spDispPlatform);
	CComQIPtr<VCPlatform> spPlatform = spDispPlatform;
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVCPropertyContainer> spPropContainer = spDispFileCfg;
	CComBSTR bstrPlatformIncs;
	if (spPlatform)
	{
		hr = spPlatform->get_IncludeDirectories(&bstrPlatformIncs);
		if (SUCCEEDED(hr) && spPropContainer)
		{
			CComBSTR bstrTemp;
			hr = spPropContainer->Evaluate(bstrPlatformIncs, &bstrTemp);
			*pbstrIncPath = bstrTemp.Detach();
			RETURN_ON_FAIL(hr);
		}
	}

	return S_OK;
}

HRESULT CVCFileNode::OnCompileFile()
{
	CComPtr<VCFile> spFile;
	GetVCFile(&spFile);
	RETURN_ON_NULL(spFile);

	CVCProjectNode* pProjNode = GetVCProjectNode();
	RETURN_ON_NULL(pProjNode);

	// Save the file
	CComPtr<IVsHierarchy> spHier;
	HRESULT hr = pProjNode->GetVsHierarchy(&spHier, TRUE);
	RETURN_ON_FAIL_OR_NULL(hr, spHier);

	CComPtr<IVsSolutionBuildManager> spBldMgr;
	hr = GetBuildPkg()->GetSolutionBuildManager(&spBldMgr, TRUE);
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVsSolutionBuildManager2> spBldMgr2 = spBldMgr;
	VSASSERT(spBldMgr2, "Hey, why no IVsSolutionBuildManager2 for IVsSolutionBuildManager?!?");

	if (spBldMgr2 != NULL)
		spBldMgr2->SaveDocumentsBeforeBuild(spHier, VSITEMID_ROOT, NULL);

	CVCPtrList ptrList;
	ptrList.AddHead(this);
	return GetVCProjectNode()->CompileFileItems(ptrList);
}

HRESULT CVCFileNode::OnRefreshWebRef()
{   

	CComPtr<IDispatch> pDispFileCfg;
	GetActiveVCFileConfig(&pDispFileCfg);
	CComQIPtr<VCFileConfiguration> pFileCfg = pDispFileCfg;
	RETURN_ON_NULL(pFileCfg);

	CComPtr<IDispatch> pDispTool;
	HRESULT hr = pFileCfg->get_Tool(&pDispTool);
	CComQIPtr<VCWebServiceProxyGeneratorTool> pTool = pDispTool;
	RETURN_ON_NULL(pTool);

	CComBSTR bstrURL;
	pTool->get_URL(&bstrURL);
	if( bstrURL )
	{
		CComPtr<IDispatch> pProj;
		((CVCProjectNode*)GetRootNode())->GetDispVCProject(&pProj);
		CComQIPtr<IVCProjectImpl> pProjImpl = pProj;
		CComBSTR bstrFileOut;
		hr = pProjImpl->UpdateWSDL(bstrURL, VARIANT_TRUE /* exists */, &bstrFileOut);
	}

	CVCPtrList ptrList;
	ptrList.AddHead(this);
	CHECK_ZOMBIE(GetVCProjectNode(), IDS_ERR_PROJ_ZOMBIE);
	hr = GetVCProjectNode()->CompileFileItems(ptrList);

	return S_OK;
}

HRESULT CVCFileNode::CleanUpBeforeDelete()
{
	CComPtr<IDispatch> pParentDisp;
	CComPtr<IDispatch> pItemDisp;
	GetObjectsForDelete(&pParentDisp, &pItemDisp);
	return CleanUpObjectModel(pParentDisp, pItemDisp);
}

HRESULT CVCFileNode::GetObjectsForDelete(IDispatch** ppParentDisp, IDispatch** ppItemDisp)
{
	CHECK_POINTER_NULL(ppParentDisp);
	CHECK_POINTER_NULL(ppItemDisp);

	CComPtr<IDispatch> spParentDisp = ((CVCNode*)GetParent())->m_dispkeyItem;
	*ppParentDisp = spParentDisp.Detach();

	CComPtr<IDispatch> spItemDisp = m_dispkeyItem;
	*ppItemDisp = spItemDisp.Detach();

	return S_OK;
}

HRESULT CVCFileNode::CleanUpObjectModel(IDispatch* pParentDisp, IDispatch* pItemDisp)
{
	// Project
	CComQIPtr<VCProject> pProject = pParentDisp;
	if (pProject)
		return pProject->RemoveFile(pItemDisp);

	// Filter
	CComQIPtr<VCFilter> pFilter = pParentDisp;
	if (pFilter)
		return pFilter->RemoveFile(pItemDisp);

	return E_FAIL;
}

// do the UI dll part of delete
HRESULT CVCFileNode::CleanUpUI( CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen /*= TRUE*/ )
{
	HRESULT hr = S_OK;
	BOOL fIsOpen = FALSE;
	CComBSTR bstrPath;

	CComPtr<IVsWindowFrame> pFrame;
	if (bCloseIfOpen || dwDelItemOp == DELITEMOP_DeleteFromStorage)
	{
		CComPtr<IVsUIShellOpenDocument> pVsUIShellOpenDoc;	
		hr = ExternalQueryService(SID_SVsUIShellOpenDocument, 
								  IID_IVsUIShellOpenDocument, (void **)&pVsUIShellOpenDoc);
		VSASSERT(SUCCEEDED(hr), "Unable to obtain IVsUIShellOpenDocument service!  Did the IDs change?  Do you need to investigate threading issues?");
		RETURN_ON_FAIL_OR_NULL(hr, pVsUIShellOpenDoc);
							  
		bstrPath = GetFullPath();
		CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(GetHierarchy());
		hr = pVsUIShellOpenDoc->IsDocumentOpen(spHier, 
											   (VSITEMID)GetVsItemID(), 
												bstrPath,
											   GUID_NULL,
											   IDO_ActivateIfOpen,
											   NULL,
											   NULL,
											   &pFrame,
											   &fIsOpen);
		VSASSERT(SUCCEEDED(hr), "Unable to determine if a document is open!  Are the parameters correct?  Do you need to investigate threading issues?");
	}

	if(dwDelItemOp == DELITEMOP_DeleteFromStorage )
	{
		if (fIsOpen && pFrame)
		{
			// close the file
			hr = pFrame->CloseFrame( FRAMECLOSE_NoSave );
			RETURN_ON_FAIL(hr);
		}

		CComPtr<IDispatch> pDisp = m_dispkeyItem;
		CComBSTR bstrName;

		CComQIPtr<VCFile> pFile = pDisp;
		if(pFile)
		{
			CString strName;
			pFile->get_FullPath(&bstrName);

			strName = bstrName;
			// SHFileOperation requires this field to have a double NULL
			// to indicate its termination
			strName += '\0';

			SHFILEOPSTRUCT fop;
			fop.hwnd = NULL;
			fop.wFunc = FO_DELETE;
			fop.pFrom = strName;
			fop.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION;			
			fop.fAnyOperationsAborted = NULL;
			fop.hNameMappings = NULL;
			fop.lpszProgressTitle = NULL;
			fop.pTo = NULL;

			// ignore failures, we want to continue on so files are still removed, 
			// even if they can't be deleted from disk
			SHFileOperation(&fop);
		}
	}
	else
	{
		if( fIsOpen && bCloseIfOpen && pFrame )
		{
			// close the file
			hr = pFrame->CloseFrame( FRAMECLOSE_PromptSave );
			RETURN_ON_FAIL(hr);
		}
	}

	m_fDeleted = TRUE;
	CVCBaseFolderNode* pParent = static_cast<CVCBaseFolderNode*>(GetParent());
	if (pParent)
		pParent->Delete(this, GetHierarchy());

	// IVsTrackProjectDocuments::OnAfterRemoveFiles called by VCProjectEngine, so not needed here
	return hr;
}

HRESULT CVCFileNode::OnDelete(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen /*= TRUE*/)
{
	CComPtr<IDispatch> pParentDisp;
	CComPtr<IDispatch> pItemDisp;
	GetObjectsForDelete( &pParentDisp, &pItemDisp );
	if( !pParentDisp || !pItemDisp )
		return E_FAIL;
	return CleanUpObjectModel( pParentDisp, pItemDisp );
}

//-----------------------------------------------------------------------------
// create an instance of a project node with refrence count 1
//-----------------------------------------------------------------------------
HRESULT CVCFileNode::CreateInstance(CVCFileNode **ppProjectNode, IDispatch* pItem)
{
	CComObject<CVCFileNode> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CVCFileNode>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL(hr, pPrjObj);

	pPrjObj->AddRef();
	pPrjObj->Initialize(pItem);
	*ppProjectNode = pPrjObj;

	return hr;
}


//-----------------------------------------------------------------------------
// Called by CreateInstance to initialize us.
//-----------------------------------------------------------------------------
void CVCFileNode::Initialize(IDispatch* pItem)
{	
	m_dispkeyItem = pItem;
}

//-----------------------------------------------------------------------------
// Reads the project file (if we havent' already done so), and loads the project 
// into memory.
//-----------------------------------------------------------------------------
BOOL CVCFileNode::Open()
{
	BOOL bRetVal = TRUE;
	// open the project file. For now, we pretend we have one.
	return bRetVal;
}

//-----------------------------------------------------------------------------
// Shell's OpenWith
//-----------------------------------------------------------------------------
HRESULT CVCFileNode::OpenWith()
{
	CComBSTR bstrPath;
	bstrPath = GetFullPath();
	return OpenNormalEditor(bstrPath, OSE_UseOpenWithDialog, LOGVIEWID_UserChooseView, FALSE);
}

bool CVCFileNode::IsBuildable( void )
{
	if (!(GetBuildPkg()->NoBuildsInProgress()))
		return false;

	RETURN_ON_NULL2(GetVCProjectNode(), false);

	HRESULT hr;
	CComPtr<IDispatch> pDisp;

	// get the active IVCGenericConfiguration
	CComPtr<IVCGenericConfiguration> pGenCfg;
	hr = GetVCProjectNode()->GetActiveConfig( &pGenCfg );
	if( FAILED( hr ) || !pGenCfg )
	{
		// if we couldn't get an active config, just use the first config in
		// the list of configs
		CComPtr<VCProject> spProject;
		hr = GetVCProjectNode()->GetVCProject(&spProject);
		RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spProject, false);
		hr = spProject->get_Configurations( &pDisp );
		CComQIPtr<IVCCollection> pColl = pDisp;
		RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pColl, false);
		pDisp = NULL;
		hr = pColl->Item( CComVariant( 1 ), &pDisp );
		if( hr != S_OK )
			return false;
	}
	// otherwise we have an active config
	else
	{
		// QI for IVCCfg
		CComQIPtr<IVCCfg> pVCCfg = pGenCfg;
		if( !pVCCfg )
		{
			VSASSERT( false, "QI from IVCGenericConfiguration to IVCCfg failed" );
			return false;
		}
		// get_Object to get the "internal object"
		hr = pVCCfg->get_Object( &pDisp );
		VSASSERT( SUCCEEDED( hr ), "IVCCfg::get_Object failed" );
	}

	// QI for VCConfiguration
	CComQIPtr<VCConfiguration> pVCConfig = pDisp;
	if( !pVCConfig )
	{
		VSASSERT( false, "QI from IDispatch to VCConfiguration failed" );
		return false;
	}
	// check for an active spawner
	CComQIPtr<IVCConfigurationImpl> pVCConfigImpl = pDisp;
	if (pVCConfigImpl)
	{
		VARIANT_BOOL bCanBuild;
		hr = pVCConfigImpl->get_CanStartBuild(&bCanBuild);
		VSASSERT(SUCCEEDED(hr), "IVCConfigurationImpl::get_CanStartBuild failed");
		if (bCanBuild == VARIANT_FALSE)
			return false;
	}

	// check for a makefile configuration (NO individual files are buildable
	// in makefile configs)
	ConfigurationTypes cfgType;
	hr = pVCConfig->get_ConfigurationType( &cfgType );
	VSASSERT( SUCCEEDED( hr ), "VCConfiguration::get_ConfigurationType failed" );
	if( cfgType == typeUnknown )
		return false;
	// get our internal VCFile 
	CComPtr<VCFile> pFile;
	GetVCFile(&pFile);
	// QI for IVCFileImpl
	CComQIPtr<IVCFileImpl> pFileImpl = pFile;
	if( !pFileImpl )
	{
		VSASSERT( false, "QI from VCFile to IVCFileImpl failed" );
		return false;
	}
	// get the VCFileConfiguration for the VCConfiguration we have
	CComPtr<VCFileConfiguration> pFileCfg;
	hr = pFileImpl->GetFileConfigurationForProjectConfiguration( pVCConfig, &pFileCfg );
	VSASSERT( SUCCEEDED( hr ), "IVCFileImpl::GetFileConfigurationFromProjectConfiguration failed" );
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pFileCfg, false);
	// get the ExcludedFromBuild prop from the VCFileConfiguration
	VARIANT_BOOL bExcludedFromBuild;
	hr = pFileCfg->get_ExcludedFromBuild( &bExcludedFromBuild );
	VSASSERT( SUCCEEDED( hr ), "VCFileConfiguration::get_ExcludedFromBuild failed" );
	
	if( bExcludedFromBuild == VARIANT_TRUE )
		return false;
	// if it wasn't excluded from build, it may still not be
	// buildable
	// get its tool and find out
	pDisp = NULL;
	hr = pFileCfg->get_Tool( &pDisp );
	VSASSERT( SUCCEEDED( hr ), "VCFileConfiguration:get_Tool failed" );
	RETURN_ON_NULL2(pDisp, false);

	// is it a custom build tool?
	CComQIPtr<VCCustomBuildTool> pCustBldTool = pDisp;
	if( pCustBldTool )
	{
		// does it have a non-blank output?
		CComBSTR bstrOutputs;
		pCustBldTool->get_Outputs( &bstrOutputs );
		if( bstrOutputs.Length() != 0 )
			return true;
	}
	// if not, it's buildable
	else
		return true;

	return false;
}

bool CVCFileNode::IsHTML( void )
{
	CComBSTR bstrPath;
	bstrPath = GetFullPath();

	CPathW path;
	path.Create( bstrPath );
	
	const wchar_t* wszExt = path.GetExtension();
	if( _wcsicmp( wszExt, L".html" ) == 0 )
		return true;
	if( _wcsicmp( wszExt, L".htm" ) == 0 )
		return true;

	return false;
}

bool CVCFileNode::IsWSDL( void )
{
	CComBSTR bstrPath;
	bstrPath = GetFullPath();

	CPathW path;
	path.Create( bstrPath );
	
	const wchar_t* wszExt = path.GetExtension();
	if( _wcsicmp( wszExt, L".wsdl" ) == 0 )
		return true;

	return false;
}

//-----------------------------------------------------------------------------
// IVCFileNodeProps
//-----------------------------------------------------------------------------
STDMETHODIMP CVCFileNode::get_Name( BSTR *pVal )
{
	CComQIPtr<VCFile> spFile = m_dispkeyItem;
	RETURN_ON_NULL2(spFile, E_NOINTERFACE);

	return spFile->get_Name( pVal );
}

STDMETHODIMP CVCFileNode::get_FullPath( BSTR *pVal )
{
	CComQIPtr<VCFile> spFile = m_dispkeyItem;
	RETURN_ON_NULL2(spFile, E_NOINTERFACE);

	return spFile->get_FullPath( pVal );
}
STDMETHODIMP CVCFileNode::get_RelativePath(BSTR *pVal)
{
	CComQIPtr<VCFile> spFile = m_dispkeyItem;
	RETURN_ON_NULL2(spFile, E_NOINTERFACE);

	return spFile->get_RelativePath( pVal );
}

STDMETHODIMP CVCFileNode::put_RelativePath(BSTR newVal)
{
	CComQIPtr<VCFile> spFile = m_dispkeyItem;
	RETURN_ON_NULL2(spFile, E_NOINTERFACE);
	
	return spFile->put_RelativePath( newVal );
}

STDMETHODIMP CVCFileNode::get_DeploymentContent( VARIANT_BOOL *pVal )
{
	CComQIPtr<VCFile> spFile = m_dispkeyItem;
	RETURN_ON_NULL2(spFile, E_NOINTERFACE);

	return spFile->get_DeploymentContent( pVal );
}

STDMETHODIMP CVCFileNode::put_DeploymentContent( VARIANT_BOOL newVal )
{
	CComQIPtr<VCFile> spFile = m_dispkeyItem;
	RETURN_ON_NULL2(spFile, E_NOINTERFACE);
		
	return spFile->put_DeploymentContent( newVal );
}

STDMETHODIMP CVCFileNode::GetLocalizedPropertyInfo( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
{
	CComQIPtr<IDispatch> pdisp;
	QueryInterface(__uuidof(IDispatch), (void**)&pdisp);
	RETURN_ON_NULL(pdisp);

	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
	CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
	RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);

	CComBSTR bstrDoc;
	hr = pTypeInfo2->GetDocumentation2(dispid, localeID, &bstrDoc, NULL, NULL);
	RETURN_ON_FAIL_OR_NULL(hr, bstrDoc.m_str);

	LPOLESTR pDesc = wcsstr( bstrDoc, L": " );
	RETURN_ON_NULL(pDesc);

	int nSize = (int)(pDesc - bstrDoc);
	pDesc+=2;

	CComBSTR bstrName( nSize-1, bstrDoc );
	if (pbstrName != NULL)
		*pbstrName = bstrName.Detach();

	CComBSTR bstrDesc( pDesc );
	if (pbstrDesc != NULL)
		*pbstrDesc = bstrDesc.Detach();
	
	return S_OK;
}

STDMETHODIMP CVCFileNode::GetClassName(BSTR* pbstrClassName)
{
	CHECK_POINTER_NULL(pbstrClassName);
	CComBSTR bstrClassName;
	bstrClassName.LoadString(IDS_FILE_PROPERTIES);
	*pbstrClassName = bstrClassName.Detach();
	if (*pbstrClassName)
		return S_OK;
	else
		return E_OUTOFMEMORY;
}

//---------------------------------------------------------------------------
// IVsExtensibleObject
//---------------------------------------------------------------------------
STDMETHODIMP CVCFileNode::GetAutomationObject(/*[in]*/ LPCOLESTR  pszPropName, /*[out]*/ IDispatch **ppDisp)
{
	CHECK_POINTER_VALID(ppDisp);
	*ppDisp = NULL;

	CComPtr<VCFileConfiguration> spConfig;
	CComBSTR bstrCfgName = pszPropName;
	HRESULT hr = GetCfgOfName(bstrCfgName, &spConfig);
	RETURN_ON_FAIL_OR_NULL(hr, spConfig);

	return CVCFileCfgProperties::CreateInstance(spConfig, ppDisp);
}

//-----------------------------------------------------------------------------
// IVsCfgProvider2
//-----------------------------------------------------------------------------
STDMETHODIMP CVCFileNode::GetCfgs( ULONG celt, IVsCfg *rgpcfg[], ULONG *pcActual, VSCFGFLAGS *prgfFlags )
{
	HRESULT hr;
	CComPtr<IEnumVARIANT>		pEnum;
	CComPtr<IDispatch>			pDisp;
	CComQIPtr<IVCCollection>	pCollection;
	
	// get the file object
	CComPtr<VCFile>			pFile;
	GetVCFile(&pFile);
	RETURN_ON_NULL2(pFile, E_NOINTERFACE);

	// Get config collection
	hr = pFile->get_FileConfigurations( &pDisp );
	pCollection = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pCollection, E_NOINTERFACE);

	hr = pCollection->_NewEnum( reinterpret_cast<IUnknown **>( &pEnum ) );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);

	//If there's a pointer to the actual count
	if (pcActual)
	{
		//Get the count
		long cCount;
		hr = pCollection->get_Count( &cCount );
		RETURN_ON_FAIL(hr);

		*pcActual = cCount;

		//If asking for count, return
		if (celt == 0) return S_OK;
	}
	else if (celt == 0) return E_POINTER;	//Asking for count, but null pointer supplied

	// loop the file config array 
	pEnum->Reset();
	for (unsigned int i = 0; i < celt; i++)
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) break;
	
		//Get file config
		CComQIPtr<VCFileConfiguration> pFileConfig;
		pFileConfig = var.punkVal;
		RETURN_ON_NULL2(pFileConfig, E_NOINTERFACE);

		// create the config for return
		hr = CFileGenCfg::CreateInstance( &rgpcfg[i], pFileConfig );
		RETURN_ON_FAIL_OR_NULL(hr, pFileConfig);
	}
	return S_OK;
} 

STDMETHODIMP CVCFileNode::GetCfgNames( ULONG celt,BSTR rgbstr[], ULONG *pcActual )
{
	HRESULT hr;
	CComPtr<IEnumVARIANT>		pEnum;
	CComPtr<IDispatch>			pDisp;
	CComQIPtr<IVCCollection>	pCollection;
	
	// get the file object
	CComPtr<VCFile>			pFile;
	GetVCFile(&pFile);
	RETURN_ON_NULL2(pFile, E_NOINTERFACE);

	//Get config collection
	hr = pFile->get_FileConfigurations( &pDisp );
	pCollection = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pCollection, E_NOINTERFACE);

	hr = pCollection->_NewEnum( reinterpret_cast<IUnknown **>( &pEnum ) );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);

	//If there's a pointer to the actual count
	if (pcActual)
	{
		//Get the count
		long cCount;
		hr = pCollection->get_Count( &cCount );
		RETURN_ON_FAIL(hr);

		*pcActual = cCount;

		//If asking for count, return
		if (celt == 0) return S_OK;
	}
	else if (celt == 0) return E_POINTER;	//Asking for count, but null pointer supplied

	//Loop the config name array filling it out
	pEnum->Reset();
	for (unsigned int i = 0; i < celt; i++)
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) break;
	
		//Get file config
		CComQIPtr<VCFileConfiguration> pFileConfig;
		pFileConfig = var.punkVal;
		RETURN_ON_NULL2(pFileConfig, E_NOINTERFACE);

		// get file config internal interface
		CComQIPtr<IVCFileConfigurationImpl> pFileConfigImpl = pFileConfig;
		RETURN_ON_NULL2(pFileConfigImpl, E_NOINTERFACE);
	
		// get config
		CComPtr<IDispatch> pDispConfig;
		CComQIPtr<VCConfiguration> pConfig;
		hr = pFileConfigImpl->get_Configuration( &pDispConfig );
		pConfig = pDispConfig;
		RETURN_ON_FAIL_OR_NULL2(hr, pConfig, E_NOINTERFACE);
		
		CComBSTR bstrName;
 		hr = pConfig->get_ConfigurationName(&bstrName);
		RETURN_ON_FAIL(hr);

		//Fill out array
		rgbstr[i] = bstrName.Detach();
	}
	return S_OK;
}

STDMETHODIMP CVCFileNode::GetPlatformNames( ULONG celt, BSTR rgbstr[],	ULONG *pcActual)
{
	if( celt == 0 )
	{
		if( pcActual == NULL )
			return E_POINTER;
		*pcActual = 1;
		return S_OK;
	}

	if (celt > 1 && pcActual != NULL)
		*pcActual = 1;

	CComBSTR bstrPlat = L"Win32";
	rgbstr[0] = bstrPlat.Detach();
	return S_OK;
}

HRESULT CVCFileNode::GetCfgOfName(BSTR szCfgName, VCFileConfiguration** ppFileCfg)
{
	CComBSTR bstrCfgName = szCfgName;

	CComPtr<IDispatch> pDisp;
	CComQIPtr<VCFile> pFile = m_dispkeyItem;
	RETURN_ON_NULL2(pFile, E_NOINTERFACE);
	
	// get the collection of file configs
	pDisp = NULL;
	CComQIPtr<IVCCollection> pColl;
	HRESULT hr = pFile->get_FileConfigurations( &pDisp );
	pColl = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
	
	// get a new enum from the collection
	CComPtr<IEnumVARIANT> pEnum;
	hr = pColl->_NewEnum( reinterpret_cast<IUnknown**>(&pEnum) );
	RETURN_ON_FAIL_OR_NULL(hr, pEnum);
	
	long actualCfgs = 0;
	pEnum->Reset();
	while( true )
	{
		CComVariant var;
		hr = pEnum->Next( 1, &var, NULL );
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE )
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			return E_FAIL;

		CComQIPtr<VCFileConfiguration> pConfig = var.punkVal;
		RETURN_ON_NULL(pConfig);
		CComBSTR bstrName;
		hr = pConfig->get_Name( &bstrName );
		RETURN_ON_FAIL(hr);
		if( bstrName == bstrCfgName )
		{
			*ppFileCfg = pConfig.Detach();
			return S_OK;
		}
	}
	// Hmmmm.  Got here, so maybe the config name we started with didn't have a platform on it, so no match
	CStringW strCfgName = bstrCfgName;
	if (strCfgName.Find(L"|") > 0)
		return E_FAIL;	// got told a platform and didn't find it; bye-bye

	bstrCfgName += L"|";
	int nLen = bstrCfgName.Length();

	pEnum->Reset();
	while (true)
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		RETURN_ON_FAIL(hr);
		if( hr == S_FALSE ) 
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			return E_FAIL;

		CComQIPtr<VCFileConfiguration> pConfig = var.punkVal;
		RETURN_ON_NULL(pConfig);
		CComBSTR bstrName;
		hr = pConfig->get_Name(&bstrName);
		RETURN_ON_FAIL(hr);
		if (bstrName.m_str && bstrCfgName.m_str && _wcsnicmp(bstrName.m_str, bstrCfgName.m_str, nLen) == 0)
		{
			*ppFileCfg = pConfig.Detach();
			return S_OK;
		}
	}

	return E_FAIL;
}

STDMETHODIMP CVCFileNode::GetCfgOfName( LPCOLESTR pszCfgName, LPCOLESTR pszPlatformName, IVsCfg **ppCfg )
{
	CHECK_POINTER_NULL(ppCfg);

	CComBSTR bstrCfgName = pszCfgName;
	bstrCfgName += L"|";
	bstrCfgName += pszPlatformName;

	CComPtr<VCFileConfiguration> spFileCfg;
	HRESULT hr = GetCfgOfName(bstrCfgName, &spFileCfg);
	RETURN_ON_FAIL_OR_NULL(hr, spFileCfg);

	return CFileGenCfg::CreateInstance( ppCfg, spFileCfg );
}

STDMETHODIMP CVCFileNode::AddCfgsOfCfgName( LPCOLESTR pszCfgName, LPCOLESTR pszCloneCfgName, BOOL fPrivate )
{
	return E_NOTIMPL;	// CVCFileNode::AddCfgsOfCfgName
}

STDMETHODIMP CVCFileNode::DeleteCfgsOfCfgName( LPCOLESTR pszCfgName )
{
	return E_NOTIMPL;	// CVCFileNode::DeleteCfgsOfCfgName
}

STDMETHODIMP CVCFileNode::RenameCfgsOfCfgName( LPCOLESTR pszOldName, LPCOLESTR pszNewName )
{
	return E_NOTIMPL;	// CVCFileNode::RenameCfgsOfCfgName
}
		
STDMETHODIMP CVCFileNode::AddCfgsOfPlatformName( LPCOLESTR pszPlatformName, LPCOLESTR pszClonePlatformName )
{
	return E_NOTIMPL;	// CVCFileNode::AddCfgsOfPlatformName
}

STDMETHODIMP CVCFileNode::DeleteCfgsOfPlatformName( LPCOLESTR pszPlatformName )
{
	return E_NOTIMPL;	// CVCFileNode::DeleteCfgsOfPlatformName
}

STDMETHODIMP CVCFileNode::GetSupportedPlatformNames( ULONG celt, BSTR rgbstr[], ULONG *pcActual )
{
	return E_NOTIMPL;	// CVCFileNode::GetSupportedPlatformNames
}

STDMETHODIMP CVCFileNode::GetCfgProviderProperty( VSCFGPROPID propid, VARIANT *pOut )
{
    // check for bad arg
	CHECK_POINTER_NULL(pOut);
    if( pOut->vt != VT_EMPTY ) 
        return E_POINTER;

	switch( propid )
	{
	case VSCFGPROPID_SupportsCfgEditing:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsPlatformEditing:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsCfgAdd:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsCfgDelete:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsCfgRename:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsPlatformAdd:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsPlatformDelete:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_SupportsPrivateCfgs:
		pOut->vt = VT_BOOL;
		pOut->boolVal = VARIANT_FALSE;
		break;
	case VSCFGPROPID_IntrinsicExtenderCATID:
		pOut->vt = VT_BSTR;
		LPOLESTR pStr;
		StringFromCLSID(__uuidof(IVCCfg),&pStr);
		pOut->bstrVal = SysAllocString(pStr);
		CoTaskMemFree(pStr);
		break;
	default:
		RETURN_INVALID();
	}
	
	return S_OK;
}

STDMETHODIMP CVCFileNode::AdviseCfgProviderEvents( IVsCfgProviderEvents *pCPE, VSCOOKIE *pdwCookie )
{
	return E_NOTIMPL;	// CVCFileNode::AdviseCfgProviderEvents
}

STDMETHODIMP CVCFileNode::UnadviseCfgProviderEvents( VSCOOKIE dwCookie )
{
	return E_NOTIMPL;	// CVCFileNode::UnadviseCfgProviderEvents
}

HRESULT CVCFileNode::GetExtObject(CComVariant& varRes)
{
	CComPtr<IDispatch> spDispFile;
	GetVCItem(&spDispFile);
	CComQIPtr<VCFile> spFile = spDispFile;
	RETURN_ON_NULL(spFile);

	CComPtr<IDispatch> spDispParent;
	spFile->get_Parent(&spDispParent);
	CComQIPtr<VCProject> spProject = spDispParent;
	CComQIPtr<VCFilter> spFilter = spDispParent;
	if (spProject == NULL && spFilter == NULL)
		return E_UNEXPECTED;

	HRESULT hr = S_OK;

	// need the project regardless
	CVCProjectNode* pProjNode = GetVCProjectNode();
	RETURN_ON_NULL(pProjNode);
	CComVariant var;
	pProjNode->GetExtObject(var);
	if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
		return E_FAIL;
	CComQIPtr<IDispatch> spDispProj = var.pdispVal;

	CComPtr<IDispatch> spDispItems;
	CComQIPtr<IDispatch> spAutoParent;
	if (spProject)	// project is parent
	{
		spAutoParent = spDispProj;
		hr = spProject->get_Items(&spDispItems);
	}
	else	// filter is parent
	{
		CComQIPtr<IVCExternalCookie> spCookie = spFilter;
		RETURN_ON_NULL(spCookie);
		void* pCookie = NULL;
		spCookie->get_ExternalCookie(&pCookie);
		RETURN_ON_NULL(pCookie);
		CVCFileGroup* pParentGroup = (CVCFileGroup*)pCookie;
		RETURN_ON_NULL(pParentGroup);
		CComVariant var2;
		pParentGroup->GetExtObject(var2);
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			return E_FAIL;
		spAutoParent = var.pdispVal;
		hr = spFilter->get_Items(&spDispItems);
	}
	RETURN_ON_FAIL_OR_NULL(hr, spDispItems);

	CComPtr<CAutoItems> pAutoItems;
	hr = CAutoItems::CreateInstance(&pAutoItems, spAutoParent, spDispProj, spDispItems);
	RETURN_ON_FAIL(hr);

	CComPtr<CAutoFile> pAutoFile;
	hr = CAutoFile::CreateInstance(&pAutoFile, spDispItems, spDispProj, spDispFile);
	RETURN_ON_FAIL(hr);

	varRes.vt = VT_DISPATCH;
	varRes.pdispVal = (IDispatch *)pAutoFile.Detach();

	return S_OK;
}

BSTR CVCFileNode::GetFullPath( void )
{
	CComPtr<VCFile> spFile;
	GetVCFile(&spFile);
	RETURN_ON_NULL2(spFile, NULL);

	CComBSTR bstrFullPath;
	spFile->get_FullPath( &bstrFullPath );
	return bstrFullPath.Detach();
}

// automation extender methods
STDMETHODIMP CVCFileNode::get_Extender(BSTR bstrName, IDispatch **ppDisp)
{
	return GetExtender( s_wszCATID, bstrName, ppDisp );
}

STDMETHODIMP CVCFileNode::get_ExtenderNames(VARIANT *pvarNames)
{
	return GetExtenderNames( s_wszCATID, pvarNames );
}

STDMETHODIMP CVCFileNode::get_ExtenderCATID(BSTR *pbstrGuid)
{
	CHECK_POINTER_NULL( pbstrGuid );
	CComBSTR bstrRetVal = s_wszCATID;
	*pbstrGuid = bstrRetVal.Detach();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcfgrp.cpp ===
// VCFGrp.cpp: implementation of the CVCFileGroup class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VCFGrp.h"
#include "BldPkg.h"
#include "..\resdll\gpcmd.h"
#include "PrjNode.h"
#include "utils.h"
#include "vcfile.h"
#include <vcguid.h>
#include "vcarchy.h"
#include "context.h"
#include "AutoFilter.h"
#include "AutoFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// static member initialization

const LPOLESTR CVCFileGroup::s_wszCATID = L"{EE8299CA-19B6-4f20-ABEA-E1FD9A33B683}";

CVCFileGroup::CVCFileGroup() :
#ifdef AARDVARK
	m_eMagic( magicNotSet ),
	m_bstrDirectory( L"" ),
#endif // AARDVARK
	m_fDeleted( FALSE )
{
}

CVCFileGroup::~CVCFileGroup()
{
}

CVCProjectNode* CVCFileGroup::GetVCProjectNode()
{
	return (CVCProjectNode*)GetRootNode();
}

UINT CVCFileGroup::GetIconIndex(ICON_TYPE iconType)
{
#ifdef AARDVARK
	UINT index = BMP_FOLDER;

	if( iconType == ICON_StateImage )
		return STATEICON_NONE;

	// if the magic enum wasn't set, set it
	if( m_eMagic == magicNotSet )
	{
		CComBSTR bstrName;
		GetName( &bstrName );
		// references?
		if( wcsncmp( bstrName, L"References", wcslen( L"References" ) ) == 0 )
			m_eMagic = magicReferenceFolder;
		// satellite dlls?
		else if( wcsncmp( bstrName, L"Satellite DLLs", wcslen( L"Satellite DLLs" ) ) == 0 )
			m_eMagic = magicSatelliteFolder;
		// normal folder
		else
			m_eMagic = magicNone;
	}
	switch( m_eMagic )
	{
	case magicReferenceFolder:
		if( iconType == ICON_Open )
			index = BMP_OPENREFERENCEFOLDER;
		else
			index = BMP_REFERENCEFOLDER;
		break;
		break;
	case magicSatelliteFolder:
		if( iconType == ICON_Open )
			index = BMP_OPENSATELLITEFOLDER;
		else
			index = BMP_SATELLITEFOLDER;
		break;
	default:
		if( iconType == ICON_Open )
			index = BMP_OPENFOLDER;
		else
			index = BMP_FOLDER;
	}
	return index;
#else
	switch( iconType )
	{
	case ICON_StateImage:
		return STATEICON_NONE;
	case ICON_Closed:
		return BMP_FOLDER;
	case ICON_Open:
		return BMP_OPENFOLDER;
	default:
		return BMP_FOLDER;
	}
#endif // AARDVARK
}

HRESULT CVCFileGroup::CreateInstance(CVCFileGroup **ppProjectNode, IDispatch* pItem)
{
	CComObject<CVCFileGroup> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CVCFileGroup>::CreateInstance(&pPrjObj);
	RETURN_ON_FAIL_OR_NULL2(hr, pPrjObj, E_OUTOFMEMORY);

	pPrjObj->AddRef();
	pPrjObj->Initialize(pItem);
	*ppProjectNode = pPrjObj;

	return hr;
}


//-----------------------------------------------------------------------------
// Called by CreateInstance to initialize us.
//-----------------------------------------------------------------------------
void CVCFileGroup::Initialize(IDispatch* pItem)
{	
	// Only once
	m_dispkeyItem = pItem;
}


//-----------------------------------------------------------------------------
// Reads the project file (if we havent' already done so), and loads the project 
// into memory.
//-----------------------------------------------------------------------------
BOOL CVCFileGroup::Open()
{
	BOOL bRetVal = TRUE;
// open the project file. For now, we pretend we have one.
	return bRetVal;
}

HRESULT CVCFileGroup::DisplayContextMenu( VARIANT *pvaIn )
{
	return ShowContextMenu(IDM_VS_CTXT_FOLDERNODE, pvaIn, guidSHLMainMenu, static_cast<IOleCommandTarget *>(this));
}

//-----------------------------------------------------------------------------
// Command status updater
//-----------------------------------------------------------------------------
STDMETHODIMP CVCFileGroup::QueryStatus(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);

	CVCNode::enumKnownGuidList eGuid;
	if (*pguidCmdGroup == guidVSStd97)
		eGuid = CVCNode::eGuidVSStd97;
	else if (*pguidCmdGroup == guidVSStd2K)
		eGuid = CVCNode::eGuidVSStd2K;
	else	// let the base class deal with it
		return CVCBaseFolderNode::QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);

	HRESULT hr = S_OK;
	for (ULONG i = 0; i < cCmds && SUCCEEDED(hr); i++)
		hr = QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, i);

	return hr;
}

HRESULT CVCFileGroup::QueryStatusAtIndex(CVCNode::enumKnownGuidList eGuid, const GUID* pguidCmdGroup, OLECMD prgCmds[],
	OLECMDTEXT *pCmdText, ULONG nIndex)
{
	if (eGuid == eGuidUninitialized)
	{
		if (*pguidCmdGroup == guidVSStd2K)
			eGuid = CVCNode::eGuidVSStd2K;
		else if (*pguidCmdGroup == guidVSStd97)
			eGuid = CVCNode::eGuidVSStd97;
		else
			return CVCBaseFolderNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
	}

	enumEnableStates fEnable = eEnableSupported;
	if (eGuid == CVCNode::eGuidVSStd97)
	{
		switch( prgCmds[nIndex].cmdID )
		{
		case cmdidPropertyPages:
			fEnable = eEnableSupported;
			break;
		case cmdidPaste:
			fEnable = CanPaste() ? eEnableSupportedAndEnabled : eEnableSupported;
			break;
		case cmdidCut:
			fEnable = eEnableSupportedAndEnabled;
			break;
		case cmdidCopy:
			fEnable = eEnableSupportedAndEnabled;
			break;
		default:
			return CVCBaseFolderNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex); 
		}
	}
	else
		return CVCBaseFolderNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);

	prgCmds[nIndex].cmdf = TranslateEnableState(fEnable);
	return NOERROR;
}

//-----------------------------------------------------------------------------
// Command Executor
//-----------------------------------------------------------------------------
STDMETHODIMP CVCFileGroup::Exec(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	if(*pguidCmdGroup == guidVSStd2K)
	{
		switch( nCmdID )
		{
		case ECMD_PROJSETTINGS:
			return ShowSettings(CLSID_FolderNodeProps);
		default:
			return CVCBaseFolderNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); //OLECMDERR_E_NOTSUPPORTED;
		}
	}
	else if(*pguidCmdGroup == guidVSStd97)
	{
		return CVCBaseFolderNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); //OLECMDERR_E_NOTSUPPORTED;
	}

	// Unknown command set
	return OLECMDERR_E_NOTSUPPORTED;
}

HRESULT CVCFileGroup::CleanUpBeforeDelete()
{
	CComPtr<IDispatch> pParentDisp;
	CComPtr<IDispatch> pItemDisp;
	GetObjectsForDelete( this, &pParentDisp, &pItemDisp);
	return CleanUpObjectModel(pParentDisp, pItemDisp);
}

HRESULT CVCFileGroup::GetObjectsForDelete(CVCFileGroup *pFilter, IDispatch** ppParentDisp, IDispatch** ppItemDisp)
{
	CHECK_POINTER_NULL(ppParentDisp);
	CHECK_POINTER_NULL(ppItemDisp);

	CComPtr<IDispatch> spParentDisp = ((CVCNode*)pFilter->GetParent())->m_dispkeyItem;
	*ppParentDisp = spParentDisp.Detach();

	CComPtr<IDispatch> spItemDisp = pFilter->m_dispkeyItem;
	*ppItemDisp = spItemDisp.Detach();

	return S_OK;
}

HRESULT CVCFileGroup::CleanUpObjectModel(IDispatch* pParentDisp, IDispatch* pItemDisp)
{
	// Project
	CComQIPtr<VCProject> pProject = pParentDisp;
	if(pProject)
		return pProject->RemoveFilter(pItemDisp);

	// Filter
	CComQIPtr<VCFilter> pFilter = pParentDisp;
	if( pFilter )
		return pFilter->RemoveFilter(pItemDisp);

	return E_FAIL;
}

HRESULT CVCFileGroup::CleanUpUI( CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen /*= TRUE*/ )
{
	if (pRoot == NULL)
		pRoot = this;

	CVCNode* pNext, *pNextT;
	CVCBaseFolderNode *pParent;

	pParent = static_cast<CVCBaseFolderNode*>(pRoot->GetParent());

	pNext = static_cast<CVCBaseFolderNode*>(pRoot)->GetHead();

	while (pNext)
	{
		if( pNext->GetKindOf() == Type_CVCFileGroup || pNext->GetKindOf() == Type_CVCProjectNode )
		{
			pNextT = pNext->GetNext();
			CleanUpUI(static_cast<CVCNode*>(pNext), dwDelItemOp, bCloseIfOpen);
			pNext = pNextT;
		}
		else
		{
			// delete files
			pNextT = pNext->GetNext();
			((CVCNode*)pNext)->CleanUpUI(static_cast<CVCNode*>(this), dwDelItemOp, bCloseIfOpen);
			pNext = pNextT;
		}
	}	
	((CVCFileGroup *)pRoot)->m_fDeleted = TRUE;
	HRESULT hr = pParent->Delete((CVCFileGroup *)pRoot, GetHierarchy());
	return S_OK;
}

HRESULT CVCFileGroup::OnDelete(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen /* = TRUE */)
{
	if( pRoot == NULL )
		pRoot = this;

	// get the objects before we wipe out the links to them
	CComPtr<IDispatch> spParentDisp;
	CComPtr<IDispatch> spItemDisp;
	GetObjectsForDelete( (CVCFileGroup*)pRoot, &spParentDisp, &spItemDisp);

	CleanUpObjectModel(spParentDisp, spItemDisp);
	return S_OK;
}

HRESULT CVCFileGroup::GetGuidProperty( VSHPROPID propid, GUID *pguid)
{
	CHECK_POINTER_NULL(pguid);
	*pguid = GUID_ItemType_VirtualFolder;
	return S_OK;
}

//---------------------------------------------------------------------------
//	Sets the given property to the value specified in the variant
//---------------------------------------------------------------------------
HRESULT CVCFileGroup::SetProperty(VSHPROPID propid, const VARIANT& var)
{
	CComVariant vt = VARIANT_TRUE;

	if( propid == VSHPROPID_EditLabel )
	{
		// check and make sure the name is actually different before we try to
		// set it...
		CComBSTR bstrOldName;
		CComPtr<VCFilter> spFilter;
		GetVCFilter(&spFilter);
		RETURN_ON_NULL2(spFilter, E_NOINTERFACE);
		spFilter->get_Name( &bstrOldName );
		if( bstrOldName != var.bstrVal )
		{
			CComPtr<IDispatch> spParent;
			HRESULT hr = spFilter->get_Parent(&spParent);
			RETURN_ON_FAIL_OR_NULL(hr, spParent);
			CComQIPtr<VCProject> spProjectParent = spParent;
			CComQIPtr<VCFilter> spFilterParent = spParent;
			CComQIPtr<IVCProjectImpl> spProjectParentImpl = spProjectParent;
			CComQIPtr<IVCFilterImpl> spFilterParentImpl = spFilterParent;
			if (spProjectParentImpl)
				hr = spProjectParentImpl->CanAddFilter2(var.bstrVal, VARIANT_FALSE /* no errorinfo */);
			else if (spFilterParentImpl)
				spFilterParentImpl->CanAddFilter2(var.bstrVal, VARIANT_FALSE /* no errorinfo */);
			else
				hr = E_FAIL;
			if (FAILED(hr))
			{
				if (hr != E_FAIL)
				{
					if (CVCProjectNode::VsHandlesError(hr))
						return hr;	// let VS handle the error message

					long nErrID = 0;
					CStringW strParam, strItemName;
					strItemName.Format(IDS_FILTER, var.bstrVal);
					int cParams = 1;
					switch (hr)
					{
					case E_INVALIDARG:
						nErrID = IDS_E_INVALID_NAME;
						strParam = strItemName;
						break;

					case VCPROJ_E_ZOMBIE:
						nErrID = IDS_E_ZOMBIE;
						cParams = 0;
						break;

					case E_ACCESSDENIED:
						nErrID = IDS_E_READ_ONLY_PROJ_FILE;
						CVCProjectNode::GetProjectNameString(spParent, strParam);
						break;

					case VCPROJ_E_FILTER_EXISTS:
						nErrID = IDS_E_FILTER_ALREADY_EXISTS;
						strParam = var.bstrVal;
						break;
					default:
						return hr;
					}
					CStringW strErr;
					if (nErrID)
					{
						if (cParams == 0)
							strErr.LoadString(nErrID);
						else if (cParams == 1)
							strErr.Format(nErrID, strParam);
						else
						{
							VSFAIL("Wrong number of parameters for error formatting!");
							return E_FAIL;
						}
						CComBSTR bstrErr = strErr;
						ReportError(bstrErr);
						return S_FALSE;
					}
				}
				return E_FAIL;
			}
			put_Name( var.bstrVal );
		}
		return S_OK;
	}
	// handle project node properties here...
	else 
		return CVCBaseFolderNode::SetProperty(propid, var);

	return E_UNEXPECTED;
}

//---------------------------------------------------------------------------
//	Returns the requested property in the given variant.
//---------------------------------------------------------------------------
HRESULT CVCFileGroup::GetProperty(VSHPROPID propid, VARIANT *pvar)
{
	CHECK_POINTER_NULL(pvar);

	// handle file node properties here...
	HRESULT hr = E_FAIL;
	CComVariant varRes;
	switch( propid )
	{
	case VSHPROPID_Name:
	case VSHPROPID_SaveName:
	case VSHPROPID_Caption:
	case VSHPROPID_EditLabel:
	{	// return this node's displayed caption
		V_VT(pvar) = VT_BSTR;
		CComBSTR bstrName;
		CComPtr<VCFilter> spFilter;
		GetVCFilter(&spFilter);
		RETURN_ON_NULL2(spFilter, E_NOINTERFACE);
		spFilter->get_Name( &bstrName );
		pvar->bstrVal = bstrName.Detach();
		return S_OK;
	}
	case VSHPROPID_UserContext:
	{
		varRes.ChangeType(VT_UNKNOWN);
		varRes.punkVal = NULL;

		CComPtr<IVsUserContext> pUserCtx;
		CComPtr<IVsMonitorUserContext> pmuc;
		if (SUCCEEDED(ExternalQueryService(SID_SVsMonitorUserContext, IID_IVsMonitorUserContext, (void **)&pmuc)) && pmuc)
		{
			pmuc->CreateEmptyContext(&pUserCtx);
			if (pUserCtx)
			{
				pUserCtx->AddAttribute(VSUC_Usage_Filter, L"item", L"folder");
				varRes = pUserCtx;
				hr = S_OK;
			}
		}
		break;
	}
	default:
		hr = CVCBaseFolderNode::GetProperty(propid, &varRes);
		break;
	}
	if (SUCCEEDED(hr))
		varRes.Detach(pvar);
	return hr;
}

HRESULT CVCFileGroup::GetCanonicalName(BSTR* pbstrName)
{
	CComPtr<VCFilter> spFilter;
	GetVCFilter(&spFilter);
	CHECK_ZOMBIE(spFilter, IDS_ERR_FILTER_ZOMBIE);
	return spFilter->get_CanonicalName(pbstrName);
}

HRESULT CVCFileGroup::GetName(BSTR* pbstrName)
{
	CComPtr<VCFilter> spFilter;
	GetVCFilter(&spFilter);
	CHECK_ZOMBIE(spFilter, IDS_ERR_FILTER_ZOMBIE);
	return spFilter->get_Name(pbstrName);
}

/////////////////////////////////////////////////////////////////////////////
// IVCFolderNodeProps
// 

STDMETHODIMP CVCFileGroup::get_Name( BSTR *pVal )
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);
	return pFilter->get_Name( pVal );
}

STDMETHODIMP CVCFileGroup::put_Name( BSTR newVal )
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->put_Name( newVal );
}

STDMETHODIMP CVCFileGroup::get_Filter( BSTR *pVal )
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->get_Filter( pVal );
}

STDMETHODIMP CVCFileGroup::put_Filter( BSTR newVal )
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->put_Filter( newVal );
}

STDMETHODIMP CVCFileGroup::get_ParseFiles(VARIANT_BOOL* pbParse)
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->get_ParseFiles( pbParse );
}

STDMETHODIMP CVCFileGroup::put_ParseFiles(VARIANT_BOOL bParse)
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->put_ParseFiles( bParse );
}

STDMETHODIMP CVCFileGroup::get_SourceControlFiles(VARIANT_BOOL* pbSCC)
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->get_SourceControlFiles( pbSCC );
}

STDMETHODIMP CVCFileGroup::put_SourceControlFiles(VARIANT_BOOL bSCC)
{
	CComQIPtr<VCFilter> pFilter = m_dispkeyItem;
	RETURN_ON_NULL2(pFilter, E_NOINTERFACE);

	return pFilter->put_SourceControlFiles( bSCC );
}

//-----------------------------------------------------------------------------
// Used to implement RTTI without the overhead. Derived classes should check for
// their type and if not return their parents type.
//-----------------------------------------------------------------------------
UINT CVCFileGroup::GetKindOf(void) const
{
	return Type_CVCFileGroup;
}

HRESULT CVCFileGroup::GetExtObject(CComVariant& varRes)
{
	CComPtr<IDispatch> spDispFilter;
	GetVCItem(&spDispFilter);
	CComQIPtr<VCFilter> spFilter = spDispFilter;
	RETURN_ON_NULL(spFilter);

	HRESULT hr = S_OK;

	CComPtr<IDispatch> spDispParent;
	spFilter->get_Parent(&spDispParent);
	CComQIPtr<VCProject> spProjectParent = spDispParent;
	CComQIPtr<VCFilter> spFilterParent = spDispParent;
	if (spProjectParent == NULL && spFilterParent == NULL)
		return E_UNEXPECTED;

	// need the project regardless
	CVCProjectNode* pProjNode = GetVCProjectNode();
	RETURN_ON_NULL(pProjNode);
	CComVariant var;
	pProjNode->GetExtObject(var);
	if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
		return E_FAIL;
	CComPtr<IDispatch> spDispProj = var.pdispVal;

	CComPtr<IDispatch> spDispItems;
	CComQIPtr<IDispatch> spAutoParent;
	if (spProjectParent)	// project is parent
	{
		spAutoParent = spDispProj;
		hr = spProjectParent->get_Items(&spDispItems);
	}
	else	// filter is parent
	{
		CComQIPtr<IVCExternalCookie> spCookie = spFilterParent;
		RETURN_ON_NULL(spCookie);
		void* pCookie = NULL;
		spCookie->get_ExternalCookie(&pCookie);
		RETURN_ON_NULL(pCookie);
		CVCFileGroup* pParentGroup = (CVCFileGroup*)pCookie;
		CComVariant var2;
		pParentGroup->GetExtObject(var2);
		if (var2.vt != VT_DISPATCH && var2.vt != VT_UNKNOWN)
			return E_FAIL;
		spAutoParent = var2.pdispVal;
		hr = spFilterParent->get_Items(&spDispItems);
	}
	RETURN_ON_FAIL_OR_NULL(hr, spDispItems);

	CComPtr<CAutoItems> pAutoItems;
	hr = CAutoItems::CreateInstance(&pAutoItems, spAutoParent, spDispProj, spDispItems);
	RETURN_ON_FAIL(hr);

	CComPtr<CAutoFilter> pAutoFilter;
	hr = CAutoFilter::CreateInstance(&pAutoFilter, pAutoItems, spDispProj, spDispFilter);	
	RETURN_ON_FAIL(hr);

	varRes.vt = VT_DISPATCH;
	varRes.pdispVal = (IDispatch *)pAutoFilter.Detach();

	return S_OK;
}

// automation extender methods
STDMETHODIMP CVCFileGroup::get_Extender(BSTR bstrName, IDispatch **ppDisp)
{
	return GetExtender( s_wszCATID, bstrName, ppDisp );
}

STDMETHODIMP CVCFileGroup::get_ExtenderNames(VARIANT *pvarNames)
{
	return GetExtenderNames( s_wszCATID, pvarNames );
}

STDMETHODIMP CVCFileGroup::get_ExtenderCATID(BSTR *pbstrGuid)
{
	CHECK_POINTER_NULL( pbstrGuid );
	CComBSTR bstrRetVal = s_wszCATID;
	*pbstrGuid = bstrRetVal.Detach();
	return S_OK;
}

STDMETHODIMP CVCFileGroup::MapPropertyToCategory( DISPID dispid, PROPCAT* ppropcat)
{
	switch( dispid )
	{
		case VCFOLDNODID_ParseFiles:
		case VCFOLDNODID_SourceControlFiles:
			*ppropcat = (PROPCAT)IDS_ADVANCEDCAT;
			break;
		case VCFOLDNODID_Name:
		case VCFOLDNODID_Filter:
		default:
			*ppropcat = (PROPCAT)IDS_GENERALCAT;
			break;
	}
	return S_OK;
}

STDMETHODIMP CVCFileGroup::GetCategoryName( PROPCAT propcat, LCID lcid, BSTR* pbstrName)
{
	CComBSTR bstrCat;
	if( propcat )
	    bstrCat.LoadString((UINT)propcat);
	return bstrCat.CopyTo(pbstrName);
}

STDMETHODIMP CVCFileGroup::GetLocalizedPropertyInfo( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
{
	CComQIPtr<IDispatch> pdisp;
	QueryInterface(__uuidof(IDispatch), (void**)&pdisp);
	RETURN_ON_NULL(pdisp);

	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
	CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
	RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);

	CComBSTR bstrDoc;
	hr = pTypeInfo2->GetDocumentation2(dispid, localeID, &bstrDoc, NULL, NULL);
	RETURN_ON_FAIL_OR_NULL(hr, bstrDoc.m_str);
	
	LPOLESTR pDesc = wcsstr( bstrDoc, L": " );
	RETURN_ON_NULL(pDesc);

	int nSize = (int)(pDesc - bstrDoc);
	pDesc+=2;

	CComBSTR bstrName( nSize-1, bstrDoc );
	if (pbstrName != NULL)
		*pbstrName = bstrName.Detach();

	CComBSTR bstrDesc( pDesc );
	if (pbstrDesc != NULL)
		*pbstrDesc = bstrDesc.Detach();
	
	return S_OK;
}

STDMETHODIMP CVCFileGroup::GetClassName(BSTR* pbstrClassName)
{
	CHECK_POINTER_NULL(pbstrClassName);
	CComBSTR bstrClassName;
	bstrClassName.LoadString(IDS_FILTER_PROPERTIES);
	*pbstrClassName = bstrClassName.Detach();
	if (*pbstrClassName)
		return S_OK;
	else
		return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcfgrp.h ===
// VCFGrp.h: interface for the CVCFileGroup class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VCGROUP_H__7F438FBE_AB8B_11D0_8D1E_01A0C91BC943__INCLUDED_)
#define AFX_VCGROUP_H__7F438FBE_AB8B_11D0_8D1E_01A0C91BC943__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "vc.h"
#include "VCNode.h"
#include "VCBsNode.h"
#include "vcarchy.h"
#include "vssolutn.h"

class CVCFileGroup :	public CVCBaseFolderNode,
						public IDispatchImpl<Filter, &IID_Filter, &LIBID_VCPrivateProjectLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
						public IOleCommandTarget,
						public IVsPerPropertyBrowsing,
						public ICategorizeProperties,
						public IPerPropertyBrowsing
{
public:
	CVCFileGroup(void);
	virtual ~CVCFileGroup();

	BOOL Open();
	static HRESULT CreateInstance(CVCFileGroup **, IDispatch* pItem);
	virtual HRESULT OnDelete(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE);

BEGIN_COM_MAP(CVCFileGroup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(Filter)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY_IID(IID_ICategorizeProperties, ICategorizeProperties)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCFileGroup)

// ICategorizeProperties
public:
	STDMETHOD(MapPropertyToCategory)( DISPID dispid, PROPCAT* ppropcat);
	STDMETHOD(GetCategoryName)( PROPCAT propcat, LCID lcid, BSTR* pbstrName);

// IPerPropertyBrowsing
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr ) { return E_NOTIMPL; /* CVCFileGroup::GetDisplayString */ }
	STDMETHOD(MapPropertyToPage)( DISPID dispID, CLSID *pClsid ) { return E_NOTIMPL; /* CVCFileGroup::MapPropertyToPage */ }
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut )
		{ return E_NOTIMPL; /* CVCFileGroup::GetPredefinedStrings */ }
	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut )
		{ return E_NOTIMPL; /* CVCFileGroup::GetPredefinedValue */ }

// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide) { return E_NOTIMPL; /* CVCFileGroup::HideProperty */ }
	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay) { return E_NOTIMPL; /* CVCFileGroup::DisplayChildProperties */ }
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault) { return E_NOTIMPL; /* CVCFileGroup::HasDefaultValue */ }
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly) { return E_NOTIMPL; /* CVCFileGroup::IsPropertyReadOnly */ }
	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc);
	STDMETHOD(GetClassName)(BSTR* pbstrClassName);
    STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
    STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}

public:
	UINT GetIconIndex(ICON_TYPE);
	HRESULT GetGuidProperty( VSHPROPID propid, GUID *pguid);
	HRESULT SetProperty(VSHPROPID propid, const VARIANT& var);
	HRESULT GetProperty(VSHPROPID propid, VARIANT *pvar);

	// Filter
	STDMETHOD(get_Name)( BSTR *pVal );
	STDMETHOD(put_Name)( BSTR newVal );
	STDMETHOD(get_Filter)( BSTR *pVal );
	STDMETHOD(put_Filter)( BSTR newVal );
	STDMETHOD(get_ParseFiles)(VARIANT_BOOL* pbParse);
	STDMETHOD(put_ParseFiles)(VARIANT_BOOL bParse);
	STDMETHOD(get_SourceControlFiles)(VARIANT_BOOL* pbSCC);
	STDMETHOD(put_SourceControlFiles)(VARIANT_BOOL bSCC);
#ifdef AARDVARK
	CComBSTR m_bstrDirectory;
	STDMETHOD(get_Directory)( BSTR *pVal ){ m_bstrDirectory.CopyTo( pVal ); return S_OK; }
	STDMETHOD(put_Directory)( BSTR newVal ){ m_bstrDirectory = newVal; return S_OK; }
#endif // AARDVARK

	// automation extender methods
	STDMETHOD(get_Extender)(BSTR bstrName, IDispatch **ppDisp);
	STDMETHOD(get_ExtenderNames)(VARIANT *pvarNames);
	STDMETHOD(get_ExtenderCATID)(BSTR *pbstrGuid);

	// IOleCommandTarget
	STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);

	virtual HRESULT QueryStatusAtIndex(CVCNode::enumKnownGuidList eGuid, const GUID* pguidCmdGroup, 
		OLECMD prgCmds[], OLECMDTEXT *pCmdText, ULONG nIndex);

	virtual HRESULT DisplayContextMenu(VARIANT *pvaIn);
	virtual UINT GetKindOf(void) const;
	virtual	HRESULT	CleanUpBeforeDelete();
	virtual HRESULT CleanUpUI( CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE );
	HRESULT CleanUpObjectModel(IDispatch* pParentDisp, IDispatch* pItemDisp);
	HRESULT GetObjectsForDelete(CVCFileGroup* pFilter, IDispatch** ppParentDisp, IDispatch** ppItemDisp);

	virtual UINT GetKindOf( void )
	{
		return Type_CVCFileGroup;
	}

	
	virtual HRESULT DoDefaultAction(BOOL fNewFile){ return E_NOTIMPL; };
	virtual HRESULT GetCanonicalName(BSTR* pbstrCanonicalName);
	virtual HRESULT GetName(BSTR* pbstrName);

	virtual CVCProjectNode* GetVCProjectNode();
	virtual HRESULT GetExtObject(CComVariant& varRes);
	HRESULT GetVCFilter(VCFilter** ppFilter)
	{	
		CHECK_POINTER_NULL(ppFilter);
		CComQIPtr<VCFilter> spFilter = m_dispkeyItem;
		*ppFilter = spFilter.Detach();
		return S_OK;
	}

protected:
	void Initialize(IDispatch* pItem);
	BOOL m_fDeleted;

private:
	// automation extender CATID
	static const LPOLESTR s_wszCATID;

#ifdef AARDVARK
public:
	eMagic m_eMagic;
#endif // AARDVARK
};

#endif // !defined(AFX_VCGROUP_H__7F438FBE_AB8B_11D0_8D1E_01A0C91BC943__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcbsnode.cpp ===
// VCBsNode.cpp: implementation of the CVCBaseFolderNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <wininet.h>
#include "VCBsNode.h"
#include "BldPkg.h"
#include "..\resdll\gpcmd.h"
#include "vcarchy.h"
#include <vcguid.h>
interface CommandBars;
#include "compsvcspkg.h"
#include "utils.h"
#include "vcpkg.h"
#include "respkg.h"
#include "atlsafe.h"
#include <vcvsutil.h>
#include "locale.h"
#include "uilocale.h"
#include "vccodemodels.h"
#include "vcclsvw.h"
#include "vcfile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVCBaseFolderNode::CVCBaseFolderNode() :
	m_grfStateFlags( 0 ),
	m_pHeadNode( NULL ),
	m_pTailNode( NULL )
{
	m_fAutoExpand = FALSE;
}

CVCBaseFolderNode::~CVCBaseFolderNode()
{
	DeleteAll( NULL );
}

UINT CVCBaseFolderNode::GetIconIndex()
{
	if( m_grfStateFlags & ST_IsExpanded )
		return BMP_OPENFOLDER;
	else
		return BMP_FOLDER;
}

HRESULT CVCBaseFolderNode::DisplayContextMenu()
{
	return S_OK;
}

HRESULT CVCBaseFolderNode::HandleAddItemDlg(
            /* [in] */ VSADDITEMOPERATION dwAddItemOperation,
            /* [in] */ LPCOLESTR pszItemName,
			/* [in] */ DWORD cFilesToAdd,
            /* [in] */ LPCOLESTR rgpszFilesToAdd[],
            /* [in] */ HWND hwndDlg,
            /* [retval][out] */ VSADDRESULT __RPC_FAR *pResult)

{
	CHECK_POINTER_NULL(pResult);
	// default return value is success
	HRESULT hr = S_OK;
	*pResult = ADDRESULT_Success;

	if ((dwAddItemOperation == VSADDITEMOP_CLONEFILE) && (cFilesToAdd > 0))
	{

		CComPtr<IDispatch> pParentDisp = m_dispkeyItem;
		CComQIPtr<VCProject> pProject = pParentDisp;
		CComQIPtr<VCFilter> pFilter = pParentDisp;

		// if we got a filter, we need to get the project associated with it
		if( pFilter )
		{
			VSASSERT( !pProject, "we shouldn't have gotten both a project and a filter" );

			CComPtr<IDispatch> pDisp;
			CComQIPtr<VCFilter> pParentFilter = pFilter;
			while( true )
			{
				pDisp = NULL;
				pParentFilter->get_Parent( &pDisp );
				// did we get a filter or a project?
 				pParentFilter.Release();
				pParentFilter = pDisp;
				// didn't get a filter, try for a project
				if( !pParentFilter )
				{
					pProject = pDisp;
					VSASSERT( pProject, "No parent filter or project!" );
					break;
				}
			}
		}

		if ( cFilesToAdd == 1 )
		{
			CComPtr<IDispatch> pFileAdded;
			CComBSTR bstrFile = pszItemName;
			CComBSTR bstrPath;
			pProject->get_ProjectDirectory(&bstrPath);
			CDirW dir;
			dir.CreateFromString(bstrPath);
			CPathW path;
			path.CreateFromDirAndRelative(dir,bstrFile);
			bstrPath = path;
			CStringW strFrom = rgpszFilesToAdd[0];
			CStringW strTo = bstrPath;

			// does this file already exist in the project??
			// get the project object
			CComPtr<VCProject> pProject;
			GetVCProject(&pProject);
			if (pProject != NULL)
			{
				CComPtr<IDispatch> spDispFiles;
				if (SUCCEEDED(pProject->get_Files(&spDispFiles)))
				{
					CComQIPtr<IVCCollection> spFiles = spDispFiles;
					if (spFiles != NULL)
					{
						CComPtr<IEnumVARIANT> spEnum;
						if (SUCCEEDED(spFiles->_NewEnum(reinterpret_cast<IUnknown **>(&spEnum))) && spEnum != NULL)
						{
							spEnum->Reset();
							while (TRUE)
							{
								CComVariant var;
								hr = spEnum->Next(1, &var, NULL);
								if (hr != S_OK)
									break;
								if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
									continue;

								IDispatch* pDispFile = var.pdispVal;
								CComQIPtr<VCFile> spFile = pDispFile;
								if (spFile == NULL)
									continue;

								// compare the names
								CComBSTR bstrFileName;
								spFile->get_Name( &bstrFileName );
								CComBSTR bstrNewName = pszItemName;
								bstrFileName.ToLower();
								bstrNewName.ToLower();
								
								// if they are the same, msgbox an error and
								// set return to indicate failure
								if( bstrFileName == bstrNewName )
								{
									CStringW strErrMsgFormat;
									strErrMsgFormat.LoadString( IDS_FILE_EXISTS_ERR );
									CStringW strMessage;
									strMessage.Format( strErrMsgFormat, CStringW( bstrNewName ) );
									CComBSTR bstrMsg = strMessage;
									ReportError(bstrMsg);

									*pResult = ADDRESULT_Failure;
									return S_OK;
								}
							}
						}
					}
				}
			}

			// make sure it the destination dir exists. (make it if needed)
			CDirW dirTo;
			BOOL bOK = dirTo.CreateFromPath(path);
			if( !dirTo.CreateOnDisk() )
			{
				*pResult = ADDRESULT_Failure;
				return S_OK;
			}

			// Now check if its already on disk.
			DWORD dwAttr = GetFileAttributesW(strTo);
			if( dwAttr != 0xFFFFFFFF )
			{
				CStringW strErrMsgFormat;
				strErrMsgFormat.LoadString( IDS_FILE_ONDISK_ERR );
				CStringW strMessage;
				strMessage.Format( strErrMsgFormat, strTo );
				CComBSTR bstrMsg = strMessage;
				ReportError(bstrMsg);

				*pResult = ADDRESULT_Failure;
				return S_OK;
			}

			// is it okay to change the project file?
			hr = CanDirtyProject();
			if (FAILED(hr))
			{
				*pResult = ADDRESULT_Cancel;
				return S_OK;
			}


			// file isn't already in the project, so it's okay to clone it
			if( !CopyFileW( strFrom, strTo, FALSE) )
			{
				CStringW strErrMsgFormat;
				strErrMsgFormat.LoadString( IDS_FILE_CREATION_ERR );
				CStringW strMessage;
				strMessage.Format( strErrMsgFormat, strTo );
				CComBSTR bstrMsg = strMessage;
				ReportError(bstrMsg);

				*pResult = ADDRESULT_Failure;
				return S_OK;
			}
			SetFileAttributesW( strTo, FILE_ATTRIBUTE_NORMAL);

			GetBuildPkg()->m_fAddNewItem = 1;

			// and to add it to the project
 			if(pFilter)
 				pFilter->AddFile(bstrPath, &pFileAdded);
 			else if(pProject)
 				pProject->AddFile(bstrPath, &pFileAdded);

			GetBuildPkg()->m_fAddNewItem = 0;
		}
	}
	else if ((dwAddItemOperation == VSADDITEMOP_OPENFILE) && (cFilesToAdd > 0))
	{
		ULONG cFilesT;
		CComPtr<IDispatch> pParentDisp = m_dispkeyItem;
		CComQIPtr<VCProject> pProject = pParentDisp;
		CComQIPtr<VCFilter> pFilter = pParentDisp;

		*pResult = ADDRESULT_Failure;

		// get the project object
		if (pProject == NULL)
			GetVCProject(&pProject);
		RETURN_ON_NULL2(pProject, S_OK);
		CComQIPtr<IVCProjectImpl> spProjectImpl = pProject;
		RETURN_ON_NULL(spProjectImpl);

		for (cFilesT = 0; cFilesT < cFilesToAdd; cFilesT++)
		{
			if (GetBuildPkg())
				GetBuildPkg()->m_fAddNewItem = cFilesToAdd;

			CComPtr<IDispatch> pFileAdded;
			CComBSTR bstrNewName = rgpszFilesToAdd[cFilesT];
			// try adding the file to the project
			if(pFilter)
				hr = pFilter->AddFile(bstrNewName, &pFileAdded);
			else if(pProject)
				hr = pProject->AddFile(bstrNewName, &pFileAdded);

			if (GetBuildPkg())
				GetBuildPkg()->m_fAddNewItem = 0;
				
			// if we get E_ACCESSDENIED back, the file is under SCC, and the
			// user has cancelled the check-out dlg: return with failure code
			if( hr == E_ACCESSDENIED )
			{
				*pResult = ADDRESULT_Cancel;
				return S_OK;
			}
			// if they are the same, msgbox an error and
			// skip to the next file
			if( hr == VCPROJ_E_FILE_EXISTS)
			{
				CStringW strErrMsg;
				strErrMsg.Format( IDS_FILE_EXISTS_ERR, CStringW( bstrNewName ) );
				CComBSTR bstrMsg = strErrMsg;
				ReportError(bstrMsg);
				continue;
			}
			else if( hr == VCPROJ_E_URL_INVALID )
			{
				CStringW strErrMsg;
				strErrMsg.Format( IDS_E_URL_INVALID, CStringW( bstrNewName ) );
				CComBSTR bstrMsg = strErrMsg;
				ReportError(bstrMsg);
				continue;
			}
			else if( FAILED(hr) )
			{
				CStringW strErrMsg;
				strErrMsg.Format( IDS_E_INVALID_NAME, CStringW( bstrNewName ) );
				CComBSTR bstrMsg = strErrMsg;
				ReportError(bstrMsg, hr);
				continue;
			}

			*pResult = ADDRESULT_Success;
		}
	}

	else if(dwAddItemOperation ==  VSADDITEMOP_RUNWIZARD)
	{   // Wizard was selected. 
		VSASSERT(cFilesToAdd >= 1, "Must add at least one file here...");
		if(cFilesToAdd < 1)
			return E_FAIL;

		CComPtr<IVsExtensibility> pVsExt;
		hr = ExternalQueryService(SID_SVsExtensibility, IID_IVsExtensibility, (void **)&pVsExt);
		RETURN_ON_FAIL_OR_NULL(hr, pVsExt);
		// Must be a VC++ Project
		//

		CComPtr<VCProject> pProject;
		GetVCProject(&pProject);
		RETURN_ON_NULL2(pProject, E_NOINTERFACE);

		CComSafeArray<VARIANT> saWizardParameters(6);

		// [0] = Wizard type guid  (bstr)
		//

		#define GUID_AddItemWizard  L"{0F90E1D1-4999-11D1-B6D1-00A0C90F2744}"
		CComVariant(GUID_AddItemWizard).Detach(&saWizardParameters.GetAt(0));

		//  [1] = Project name  (bstr)
		//

		CComBSTR bstrProjectName;
		pProject->get_Name(&bstrProjectName);
		CComVariant(bstrProjectName).Detach(&saWizardParameters.GetAt(1));
		
		//  [2] = ProjectItems collection (IDispatch)
		//

		CComVariant varPrj;
		hr = GetExtObject(varPrj);
		CComQIPtr<_Project> pPrj = varPrj.pdispVal;
		CComPtr<ProjectItems> spItems;

		if( pPrj )
		{
			pPrj->get_ProjectItems(&spItems);
		}
		else
		{
			CComQIPtr<_ProjectItem> pPrjItem = varPrj.pdispVal;
			if( pPrjItem )
			{
				pPrjItem->get_ProjectItems(&spItems);
			}
		}

		CComVariant(spItems).Detach(&saWizardParameters.GetAt(2));

		// [3] = Local Directory (bstr)
		//

		CComBSTR bstrPath;
		pProject->get_ProjectDirectory(&bstrPath);
		CComVariant(bstrPath).Detach(&saWizardParameters.GetAt(3));

		//  [4] = Filename the user typed (rgpszFilesToOpen[1])(bstr)
		//

		CComVariant(CComBSTR(pszItemName)).Detach(&saWizardParameters.GetAt(4));
		

		//  [5] = Product install Directory (bstr)
		//

		CComPtr<IVsShell> spVsShell;
		CComBSTR bstrValue;
		if (SUCCEEDED(ExternalQueryService(SID_SVsShell, IID_IVsShell, (void**)&spVsShell)))
		{
			CComVariant vVirtualRegRoot;
			if (SUCCEEDED(spVsShell->GetProperty(VSSPROPID_VirtualRegistryRoot, &vVirtualRegRoot)) && vVirtualRegRoot.vt == VT_BSTR)
			{
				CStringW strProductKey(vVirtualRegRoot.bstrVal);
				strProductKey += L"\\Setup\\VC";
				CRegKey key;
				if (key.Open(HKEY_LOCAL_MACHINE, strProductKey, KEY_READ) == ERROR_SUCCESS)
				{
					wchar_t szValue[2048];
					DWORD dwCount = 2048;
					// deprecated LONG lRes = key.QueryValue(szValue, L"ProductDir", &dwCount);
					LONG lRes = key.QueryStringValue(L"ProductDir", szValue, &dwCount);
					key.Close();
					bstrValue = szValue;
				}
			}
		}

		if (!bstrValue.Length())
		{
			bstrValue = L"c:\\";
		}

		CComVariant(bstrValue).Detach(&saWizardParameters.GetAt(5)); 

		// REVIEW64(MikhailA): I am casting HWND to 32bits since this parameter
		// is actually never used by VS Environment (talk to CraigS about this)
		if (GetBuildPkg())
			GetBuildPkg()->m_fAddNewItem = 1;
		// The first filename is the name of the wizard

		CComBSTR bstrWizardName(rgpszFilesToAdd[0]);
		wizardResult eExecResult;

		hr = pVsExt->RunWizardFile(bstrWizardName, PtrToLong(hwndDlg), &(saWizardParameters.m_psa), &eExecResult);
		if (GetBuildPkg())
			GetBuildPkg()->m_fAddNewItem = 0;
		
		*pResult = ADDRESULT_Failure;
		if(hr == OLE_E_PROMPTSAVECANCELLED || hr == VS_E_WIZARDBACKBUTTONPRESS)
		{
			*pResult = ADDRESULT_Failure;
			return S_OK;
//			*pResult = ADDRESULT_Cancel;
		}
		else
		{
			if (SUCCEEDED(hr))
			{
				if(eExecResult == wizardResultSuccess)
					*pResult = ADDRESULT_Success;
				else if(eExecResult == wizardResultCancel)
				{
					*pResult = ADDRESULT_Cancel;
					hr = OLE_E_PROMPTSAVECANCELLED;
				}
				else if(eExecResult == wizardResultBackOut)
				{
					*pResult = ADDRESULT_Failure;
					hr = VS_E_WIZARDBACKBUTTONPRESS;
						 
				}
			}
		}
	}
	return hr;
}

//-----------------------------------------------------------------------------
// Called via IOleCommandTgt to update the status of our commands
//-----------------------------------------------------------------------------
STDMETHODIMP CVCBaseFolderNode::QueryStatus(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	CVCNode::enumKnownGuidList eGuid;
	if (*pguidCmdGroup == guidVSStd97)
		eGuid = CVCNode::eGuidVSStd97;
	else if (*pguidCmdGroup == guidVSStd2K)
		eGuid = CVCNode::eGuidVSStd2K;
	else	// let the base class deal with it
		return CVCNode::QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);

	HRESULT hr = NOERROR;
	for (ULONG i = 0; i < cCmds && SUCCEEDED(hr); i++)
		hr = QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, i);

	return hr;
}

HRESULT CVCBaseFolderNode::QueryStatusAtIndex(CVCNode::enumKnownGuidList eGuid, const GUID* pguidCmdGroup, 
	OLECMD prgCmds[], OLECMDTEXT *pCmdText, ULONG nIndex)
{
	if (eGuid == eGuidUninitialized)
	{
		if (*pguidCmdGroup == guidVSStd2K)
			eGuid = CVCNode::eGuidVSStd2K;
		else if (*pguidCmdGroup == guidVSStd97)
			eGuid = CVCNode::eGuidVSStd97;
		else
			return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
	}

	enumEnableStates fEnable = eEnableSupported;
	if (eGuid == CVCNode::eGuidVSStd2K)
	{
		switch(prgCmds[nIndex].cmdID)
		{
			case ECMD_ADDWEBREFERENCECTX:
				fEnable = CanAddWebRef() ? eEnableSupportedAndEnabled : eEnableSupported;
				break;
			case ECMD_ADDRESOURCE:
				fEnable = eEnableSupportedAndEnabled;
				break;
			default:
				return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
		}
	}
	else if(eGuid== CVCNode::eGuidVSStd97)
	{	// Common VB commands
		switch(prgCmds[nIndex].cmdID)
		{
			case cmdidAddClass:
			case cmdidAddExistingItem:
			case cmdidAddNewItem:
			case cmdidNewFolder:
				fEnable = eEnableSupportedAndEnabled;
				break;
			default:
				return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);
		}
	}
	else
		return CVCNode::QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, nIndex);

	prgCmds[nIndex].cmdf = TranslateEnableState(fEnable);
	return NOERROR;
}


//-----------------------------------------------------------------------------
// Command executor
//-----------------------------------------------------------------------------
STDMETHODIMP CVCBaseFolderNode::Exec(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	HRESULT hr = S_OK;
	if(*pguidCmdGroup == guidVSStd2K)
	{
		switch(nCmdID)
		{
			case ECMD_ADDRESOURCE:
				hr = OnAddResource();
				break;
			case ECMD_ADDWEBREFERENCECTX:
			case ECMD_ADDWEBREFERENCE:
				OnAddWebRef();	// we've already reported any errors, don't let the shell add lame message boxes after the fact
				break;
			default:
				hr = CVCNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); //OLECMDERR_E_NOTSUPPORTED;
				break;
		}
	}
	else if(*pguidCmdGroup == guidVSStd97)
	{	// Common VB commands
		switch(nCmdID)
		{
			case cmdidAddClass:
				hr = OnAddClass();
				break;
			case cmdidAddNewItem:
				hr = OnAddNewFiles();
				break;
			case cmdidAddExistingItem:
				hr = OnAddExistingFiles();
				break;
			case cmdidNewFolder:
				hr = OnNewFolder();
				break;
            case cmdidPaste:
                hr = OnPaste();
				break;
			default:
				hr = CVCNode::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut); //OLECMDERR_E_NOTSUPPORTED;
				break;
		}
	}
	else
	{	// Unknown command set
		hr = OLECMDERR_E_NOTSUPPORTED;
	}
	
	return hr;
}

HRESULT CVCBaseFolderNode::OnNewFolder()
{
	IDispatch *pContainer = GetPropertyContainer();
	VSASSERT(pContainer != NULL, "Failed to get property container!");
	RETURN_ON_NULL2(pContainer, S_FALSE);

	CComPtr<IDispatch> pDispFilter;
	CComQIPtr<VCFilter> pFilter = pContainer;
	CComQIPtr<VCProject> pProject = pContainer;
	CComQIPtr<IVCFilterImpl> pFilterImpl = pFilter;
	CComQIPtr<IVCProjectImpl> pProjectImpl = pProject;
	VSASSERT(pFilter || pProject, "Container wasn't a filter or a project!");
	if (pFilter == NULL && pProject == NULL)
		return E_FAIL;

	// new name = "NewFolder" + the first available number
	CComBSTR bstrGroup;
	CComBSTR bstrNewName;
	bstrNewName.LoadString( IDS_NEWFOLDER );
	bstrGroup = bstrNewName + L"1";
	CComBSTR bstrGroupFilter = L"";
	unsigned short i = 2;
	// 10 (decimal) digit equals 32 bit short
	wchar_t wszNum[10] = {0};
	HRESULT hr = S_OK;
	if (pFilterImpl)
		hr = pFilterImpl->CanAddFilter2(bstrGroup, VARIANT_FALSE /* no errorinfo */);
	else if (pProjectImpl)
		hr = pProjectImpl->CanAddFilter2(bstrGroup, VARIANT_FALSE /* no errorinfo */);
	else
		hr = E_UNEXPECTED;
	if (FAILED(hr) && hr != VCPROJ_E_FILTER_EXISTS)
		return hr;

	while (hr == VCPROJ_E_FILTER_EXISTS && i < USHRT_MAX)
	{
		_itow( i, wszNum, 10 );
		// is there a filter with this name already??
		bstrGroup = bstrNewName + wszNum;
		if (pFilterImpl)
			hr = pFilterImpl->CanAddFilter2(bstrGroup, VARIANT_FALSE /* no errorinfo */);
		else
			hr = pProjectImpl->CanAddFilter2(bstrGroup, VARIANT_FALSE /* no errorinfo */);
		i++;
	}
	if( i == USHRT_MAX )
		return E_FAIL;

	// Filter
	if( pFilter )
	{
		// Add a new group now
		hr = pFilter->AddFilter(bstrGroup, &pDispFilter);
		if(SUCCEEDED(hr) && pFilter)
		{
			CComQIPtr<VCFilter> pFilterImpl = pDispFilter;
			pFilterImpl->put_Filter(bstrGroupFilter);
		}
	}
	// Project
	else
	{
		// Add a new group now
		hr = pProject->AddFilter(bstrGroup, &pDispFilter);
		// AddFilter returns S_FALSE if folder already exists, 
		// so check for S_OK explicitly
		if( hr == S_OK )
		{
			CComQIPtr<VCFilter> pFilterImpl = pDispFilter;
			if (pFilterImpl)
				pFilterImpl->put_Filter(bstrGroupFilter);
		}
	}

	// select the added folder for naming by the user
	CComVariant pvt;
	CComPtr<IVsWindowPane> pIVsWindowPane;
	CComPtr<IVsWindowFrame> pIVsWindowFrame;
	CComPtr<IVsUIHierarchyWindow> pIVsUIHierarchyWindow;

	CComPtr<IVsUIShell> pUIShell;
	hr = GetBuildPkg()->GetVsUIShell(&pUIShell, TRUE /* in main thread */);
	RETURN_ON_FAIL(hr);

	hr = pUIShell->FindToolWindow( NULL, GUID_SolutionExplorer, &pIVsWindowFrame );
	RETURN_ON_FAIL_OR_NULL(hr, pIVsWindowFrame);

	hr = pIVsWindowFrame->GetProperty( VSFPROPID_DocView, &pvt );
	RETURN_ON_FAIL(hr);
	if( pvt.vt != VT_UNKNOWN )
 		return E_FAIL;

	hr = pvt.punkVal->QueryInterface( IID_IVsWindowPane, (void **)&pIVsWindowPane );
	RETURN_ON_FAIL_OR_NULL(hr, pIVsWindowPane);

	hr = pIVsWindowPane->QueryInterface( IID_IVsUIHierarchyWindow, (void **)&pIVsUIHierarchyWindow );
	RETURN_ON_FAIL_OR_NULL(hr, pIVsUIHierarchyWindow);

	// need to get the itemid for the new folder
	// walk the children of this node, looking for the folder
	CVCNode *pNode, *pHeadNode;
	pNode = pHeadNode = GetHead();
	do
	{
		if (pNode)
		{
			// if this is the node, break
			if( pNode->GetKindOf() == Type_CVCFileGroup )
			{
				CComBSTR bstrName;
				pNode->GetName( &bstrName );
				if( bstrName && _wcsicmp( bstrName, bstrGroup ) == 0 )
					break;
			}
			// get the next node
			pNode = pNode->GetNext();
		}
	}
	while( pNode );
	RETURN_ON_NULL(pNode);

	CComPtr<IVsUIHierarchy> spHier = VCQI_cast<IVsUIHierarchy>(GetHierarchy());
	hr = pIVsUIHierarchyWindow->ExpandItem( spHier, pNode->GetVsItemID(), EXPF_SelectItem );
	RETURN_ON_FAIL(hr);
	return pIVsUIHierarchyWindow->ExpandItem( spHier, pNode->GetVsItemID(), EXPF_EditItemLabel );
}

HRESULT CVCBaseFolderNode::OnAddExistingFiles()
{
	CComPtr<IVsAddProjectItemDlg> srpIVsAddItemDlg;
	HRESULT hr = ::ExternalQueryService(SID_SVsAddProjectItemDlg, IID_IVsAddProjectItemDlg, (void**)&srpIVsAddItemDlg);
	VSASSERT(srpIVsAddItemDlg, "Failed to get VsAddProjectItemDlg service.  Did the ID change?  Do you need to investigate threading issues?");
	RETURN_ON_FAIL_OR_NULL(hr, srpIVsAddItemDlg);

	BOOL bDontShowAgain;
	LPCWSTR pszExpandDir = NULL;
	LPCWSTR pszSelectItem = NULL;
	CStringW strFilter;
	strFilter.LoadString(g_hInstLocale, IDS_FILTER_ALL);
	CComBSTR bstrFilter = strFilter;

	CComPtr<IVsProject> spProj = VCQI_cast<IVsProject>(static_cast<CVCArchy*>(GetHierarchy()));
	hr = srpIVsAddItemDlg->AddProjectItemDlg((VSITEMID) this, IID_IVCArchy, 
				spProj,
				VSADDITEM_AllowMultiSelect | VSADDITEM_AddExistingItems | VSADDITEM_AllowStickyFilter,
				pszExpandDir, pszSelectItem, NULL, &bstrFilter, &bDontShowAgain);

	// Note that HandleAddItemDlg will be called via the hierarchy IVsProject
	// to add the items.

	return hr;
}

HRESULT CVCBaseFolderNode::OnAddNewFiles()
{
	CComPtr<IVsAddProjectItemDlg> srpIVsAddItemDlg;
	HRESULT hr = ::ExternalQueryService(SID_SVsAddProjectItemDlg, IID_IVsAddProjectItemDlg, (void**)&srpIVsAddItemDlg);
	VSASSERT(srpIVsAddItemDlg, "Failed to get VsAddProjectItemDlg service.  Did the ID change?  Do you need to investigate threading issues?");
	RETURN_ON_FAIL_OR_NULL(hr, srpIVsAddItemDlg);

	BOOL bDontShowAgain;
	LPCWSTR pszExpandDir = NULL;
	LPCWSTR pszSelectItem = NULL;
	CStringW strFilter;
	strFilter.LoadString(g_hInstLocale, IDS_FILTER_ALL);
	CComBSTR bstrFilter = strFilter;

	CComPtr<VCProject> pProject;
	GetVCProject(&pProject);
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);
		
	CComBSTR bstrPath;
	pProject->get_ProjectDirectory(&bstrPath);

	CComPtr<IVsProject> spProj = VCQI_cast<IVsProject>(static_cast<CVCArchy*>(GetHierarchy()));
	hr = srpIVsAddItemDlg->AddProjectItemDlg((VSITEMID) this, IID_IVCArchy, 
				spProj,
				VSADDITEM_AddNewItems | VSADDITEM_SuggestTemplateName | VSADDITEM_ShowLocationField,
				pszExpandDir, pszSelectItem, &bstrPath, &bstrFilter, &bDontShowAgain);

	// Note that HandleAddItemDlg will be called via the hierarchy IVsProject
	// to add the items.

	return hr;
}

HRESULT CVCBaseFolderNode::OnAddClass()
{
	CComPtr<IVsAddProjectItemDlg2> srpIVsAddItemDlg;
	HRESULT hr = ::ExternalQueryService(SID_SVsAddProjectItemDlg, IID_IVsAddProjectItemDlg2, (void**)&srpIVsAddItemDlg);
	VSASSERT(srpIVsAddItemDlg, "Failed to get VsAddProjectItemDlg service.  Did the ID change?  Do you need to investigate threading issues?");
	RETURN_ON_FAIL_OR_NULL(hr, srpIVsAddItemDlg);

	CComBSTR bstrFilter;
	bstrFilter.LoadString(IDS_FILTER_ALL);

	CComPtr<VCProject> pProject;
	GetVCProject(&pProject);
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	// Note that HandleAddItemDlg will be called via the hierarchy IVsProject
	// to add the items.

	BOOL bDontShowAgain;
	LPCWSTR pszExpandDir = NULL;
	LPCWSTR pszSelectItem = NULL;

	CComBSTR bstrPath;
	pProject->get_ProjectDirectory(&bstrPath);
	
	CComBSTR bstrName;
	pProject->get_Name(&bstrName);
	CComBSTR bstrDialogTitle;
	bstrDialogTitle.LoadString(IDS_ADDCLASS);
	bstrDialogTitle += L" - ";
	bstrDialogTitle += bstrName;

	CComPtr<IVsProject> spProj = VCQI_cast<IVsProject>(static_cast<CVCArchy*>(GetHierarchy()));
	hr = srpIVsAddItemDlg->AddProjectItemDlgTitledEx(
				(VSITEMID) this, IID_IVCAddClassHierarchy,
				spProj,
				VSADDITEM_AddNewItems | VSADDITEM_HideNameField | VSADDITEM_AllowSingleTreeRoot | VSADDITEM_ExpandSingleTreeRoot,
				bstrDialogTitle, NULL, L"vc.addclass", bstrPath, pszSelectItem, NULL, &bstrFilter, &bDontShowAgain);
	return hr;
}

// we can only add a web reference for non-makefile configuration types
BOOL CVCBaseFolderNode::CanAddWebRef()
{
	CVCProjectNode* pProjNode = GetVCProjectNode();
	RETURN_ON_NULL2(pProjNode, FALSE);

	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = pProjNode->GetActiveConfig(&spGenCfg);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spGenCfg, FALSE);

	CComQIPtr<IVCCfg> spCfg = spGenCfg;
	RETURN_ON_NULL2(spCfg, FALSE);

	CComPtr<IDispatch> spDispProjCfg;
	hr = spCfg->get_Object(&spDispProjCfg);
	CComQIPtr<VCConfiguration> spProjCfg = spDispProjCfg;
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spProjCfg, FALSE);

	ConfigurationTypes configType;
	if (FAILED(spProjCfg->get_ConfigurationType(&configType)) || configType == typeUnknown ||
		configType == typeGeneric)
		return FALSE;

	return TRUE;
}

//-----------------------------------------------------------------------------
// Called to add a web reference. Puts up the web references ui to allow the
// user to select a web reference.
//-----------------------------------------------------------------------------
HRESULT CVCBaseFolderNode::OnAddWebRef()
{   
	CComPtr<IVsAddWebReferenceDlg> srpAddWebRefDlg;
	HRESULT hr = ExternalQueryService(SID_SVsAddWebReferenceDlg, IID_IVsAddWebReferenceDlg, (void**)&srpAddWebRefDlg);
	RETURN_ON_FAIL_OR_NULL(hr, srpAddWebRefDlg);

	BOOL bCancelled = FALSE;
	CComBSTR bstrUrl;
	hr = srpAddWebRefDlg->AddWebReferenceDlg(&bstrUrl, &bCancelled);
	RETURN_ON_FAIL(hr);

	if(bCancelled)
		return OLE_E_PROMPTSAVECANCELLED;

	CComQIPtr<VCProject> spProject = m_dispkeyItem;
	CComQIPtr<VCFilter> spFilter = m_dispkeyItem;
	if (spFilter == NULL && spProject == NULL)
		return E_UNEXPECTED;

	// Go add the requested reference
	CComPtr<IDispatch> spDispFile;
	if (spFilter)
		hr = spFilter->AddWebReference(bstrUrl, &spDispFile);
	else
		hr = spProject->AddWebReference(bstrUrl, &spDispFile);
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVCExternalCookie> spFileCookie = spDispFile;
	RETURN_ON_NULL2(spFileCookie, E_UNEXPECTED);

	CVCFileNode* pFileNode = NULL;
	hr = spFileCookie->get_ExternalCookie((void **)&pFileNode);
	RETURN_ON_FAIL_OR_NULL2(hr, pFileNode, E_UNEXPECTED);

	CVCPtrList ptrList;
	ptrList.AddHead(pFileNode);
	CHECK_ZOMBIE(GetVCProjectNode(), IDS_ERR_PROJ_ZOMBIE);
	hr = GetVCProjectNode()->CompileFileItems(ptrList);


	// Get The file code model for the stdafx.h

	// Find the project Node
	CComVariant varPrj;
	hr = GetExtObject(varPrj);
	CComQIPtr<_Project> pPrj = varPrj.pdispVal;
	if( spFilter )
	{
		CComQIPtr<_ProjectItem> pPrjItem = varPrj.pdispVal;
		hr = pPrjItem->get_ContainingProject(&pPrj);
	}
	RETURN_ON_NULL2(pPrj, S_OK);

	// Get the active config
	CVCProjectNode* pProjNode = GetVCProjectNode();
	RETURN_ON_NULL2(pProjNode, S_OK);

	CComPtr<IVCGenericConfiguration> spGenCfg;
	if (FAILED(pProjNode->GetActiveConfig(&spGenCfg)) || spGenCfg == NULL)
		return S_OK;

	CComQIPtr<IVCCfg> spCfg = spGenCfg;
	RETURN_ON_NULL2(spCfg, S_OK);

	CComPtr<IDispatch> spDispProjCfg;
	if (FAILED(spCfg->get_Object(&spDispProjCfg)) || spDispProjCfg == NULL)
		return S_OK;

	CComQIPtr<VCConfiguration> spProjCfg = spDispProjCfg;
	RETURN_ON_NULL2(spProjCfg, S_OK);

	// if we are managed.
	// find the output file from the WSDL
	CComQIPtr<IVCFileImpl> pFileImpl = spDispFile;
	RETURN_ON_NULL2(pFileImpl, S_OK);

	CComPtr<VCFileConfiguration> spFileCfg;
	hr = pFileImpl->GetFileConfigurationForProjectConfiguration(spProjCfg, &spFileCfg);

	// get the tool and Check the MC++ wrapper
	VARIANT_BOOL b = VARIANT_FALSE;
	spProjCfg->get_ManagedExtensions(&b);

	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spFileCfg;
	RETURN_ON_NULL2(spFileCfgImpl, S_OK);

	CComPtr<IDispatch> spDispTool;
	spFileCfg->get_Tool(&spDispTool);
	CComQIPtr<VCWebServiceProxyGeneratorTool> pWebTool = spDispTool;
	CComBSTR bstrOutputTemp;
	RETURN_ON_NULL2(pWebTool, S_OK);
	pWebTool->get_Output(&bstrOutputTemp);
	CComQIPtr<IVCPropertyContainer> spPropContainer = spFileCfg;
	RETURN_ON_NULL2(spPropContainer, S_OK);
	CComBSTR bstrOutput;
	hr = spPropContainer->Evaluate(bstrOutputTemp, &bstrOutput);
	
	if( b == VARIANT_TRUE )
	{
		// Check if the WebService.h is in the project
		CComPtr<ProjectItems> pItems;
		pPrj->get_ProjectItems(&pItems);
		CComQIPtr<ProjectItem> pItem;
		CComVariant var = L"WebService.h";
		RETURN_ON_NULL2(pItems, S_OK);
		hr = pItems->Item(var, &pItem);
		// if no, add it

		if( pItem == NULL )
		{
			CComBSTR bstrProjDir;
			spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
			RETURN_ON_NULL2(bstrProjDir, S_OK);
			CDirW dirProj;
			dirProj.CreateFromKnown(bstrProjDir);
			CPathW pathFile;
		    CComBSTR bstrH = L"WebService.h";
			if (!pathFile.CreateFromDirAndFilename(dirProj, bstrH) || !pathFile.CreateOnDisk())
				return S_OK;

		    CComPtr<IDispatch> pDispFile;
			if (spProject)
				spProject->AddFile( bstrH, &pDispFile );
			else
				spFilter->AddFile( bstrH, &pDispFile );
			CComQIPtr<IVCExternalCookie> spFileCookie = pDispFile;
			RETURN_ON_NULL2(spFileCookie, S_OK);

			CVCFileNode* pFileNode = NULL;
			hr = spFileCookie->get_ExternalCookie((void **)&pFileNode);
			RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pFileNode, S_OK);
			CComVariant var;
			pFileNode->GetExtObject(var);
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
			    pItem = var.pdispVal;
		}

		// now get the code model
		CComPtr<FileCodeModel> pCM;
		RETURN_ON_NULL2(pItem, S_OK);

		pItem->get_FileCodeModel(&pCM);
		CComQIPtr<VCFileCodeModel> pFCM = pCM;
		RETURN_ON_NULL2(pFCM, S_OK);

		// add to the end of it this web ref
		CComVariant Pos;
		CComPtr<VCCodeUsing> pVCCodeUsing;
	
		CComPtr<CodeElements> spCodeElements;
		long nCount = 0;
		if (FAILED(hr = pFCM->get_Usings(&spCodeElements)))
			return hr;
		if (FAILED(hr = spCodeElements->get_Count(&nCount)))
			return hr;

		bool SystemVal = false;
		bool SystemDataVal = false;
		bool SystemWebVal = false;

		for(int cnt=1; cnt<=nCount; cnt++)
		{
			CComPtr<CodeElement> spCodeElement;
			if (FAILED(hr = spCodeElements->Item(CComVariant(cnt), &spCodeElement)))
				return hr;
			CComBSTR bstrValue;
			if (FAILED(hr = spCodeElement->get_Name(&bstrValue)))
				return hr;
			if (0 == _wcsicmp (bstrValue, L"<System.DLL>"))
				SystemVal = true;
			else if (0 == _wcsicmp (bstrValue, L"<System.Data.DLL>"))
				SystemDataVal = true;
			else if (0 == _wcsicmp (bstrValue, L"<System.Web.Services.DLL>"))
				SystemWebVal = true;
			spCodeElement.Release();
		}
		if (!SystemVal)
		{
			pFCM->AddUsing(L"<System.DLL>", Pos, &pVCCodeUsing);
			pVCCodeUsing.Release();
		}

		if (!SystemDataVal)
		{
			pFCM->AddUsing(L"<System.Data.DLL>", Pos, &pVCCodeUsing);
			pVCCodeUsing.Release();
		}

		if (!SystemWebVal)
		{
			pFCM->AddUsing(L"<System.Web.Services.DLL>", Pos, &pVCCodeUsing);
			pVCCodeUsing.Release();
		}

		CComBSTR bstrTemp = L"<" + bstrOutput + L">";
		pFCM->AddUsing(bstrTemp, Pos, &pVCCodeUsing);
	}
	else
	{
		// add that file to the project in the generated file folder.
		CComPtr<IDispatch> pDispFile;
		if (spProject)
			spProject->AddFile( bstrOutput, &pDispFile );
		else
			spFilter->AddFile( bstrOutput, &pDispFile );
	}

	return S_OK;
}

HRESULT CVCBaseFolderNode::OnAddResource()
{
    // get the resource editor service
    CComPtr<IVCWin32CompositionService> pCompSvc;
    HRESULT hr = ExternalQueryService( SID_SVCWin32ResourceService, _uuidof(IVCWin32CompositionService), (void**)&pCompSvc );
	RETURN_ON_FAIL_OR_NULL(hr, pCompSvc);

    // get the project
    CComPtr<VCProject> pProject;
    hr = GetVCProject( &pProject );
	RETURN_ON_FAIL_OR_NULL(hr, pProject);

    // file to add resource to:
    // for VS7 beta 1:
    // 1) <project name>.rc
    // 2) first .rc file found
    // 3) create a new .rc file
    
    // find the default rc file (same name as project)
    // get its name, concat .rc extension to it
    CComBSTR bstrName;
    hr = pProject->get_Name( &bstrName );
	RETURN_ON_FAIL(hr);
    bstrName += L".rc";

    // iterate through each file, looking for the rc file
    CComPtr<IDispatch> pDisp;
    hr = pProject->get_Files( &pDisp );
    CComQIPtr<IVCCollection> pColl = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
    // look for the file
    long i, iMac;
    hr = pColl->get_Count( &iMac );
	RETURN_ON_FAIL(hr);
    CComBSTR bstrPath;
    CComPtr<IDispatch> pDispFile;

    hr = pColl->Item( CComVariant( bstrName ), &pDispFile );
    CComQIPtr<VCFile> pFile = pDispFile;
    if( pFile )
    {
        // get the full path to the file
        pFile->get_FullPath( &bstrPath );
    }
    
    // if we've found no exact file to add to, look for any .rc file
    if( bstrPath.Length() == 0 )
    {
        for( i = 1; i <= iMac; i++ )
        {
            CComPtr<IDispatch> pDispFile;
            hr = pColl->Item( CComVariant( i ), &pDispFile );
            if( FAILED( hr ) )
                continue;
            CComQIPtr<VCFile> pFile = pDispFile;
            if( pFile )
            {
                // get the file extension
                CComBSTR bstrExt;
                hr = pFile->get_Extension( &bstrExt );
                if( SUCCEEDED( hr ) && _wcsicmp( bstrExt, L".rc" ) == 0 )
                {
                    // get the full path to the file
                    pFile->get_FullPath( &bstrPath );
                    break;
                }
            }
        }
    }
    
    CComBSTR bstrTemplatePath;
    CComBSTR bstrHPath;
    CComPtr<IDispatch> pDispHFile;

    // if we've found no rc file to add to, create one
    // and create the corr. header file. Fix Bug: Add Resource 
    // does not work if rc file exists and resource.h does not exist
    // (happens when resource includes has been modified).
    if( bstrPath.Length() == 0 )
    {
        // first, will SCC allow us to add files to the project?
        hr = CanDirtyProject();
        RETURN_ON_FAIL(hr);

        // get the template dir
        CComPtr<_DTE> pDTE;
        hr = ExternalQueryService( SID_SDTE, IID__DTE, (void **)&pDTE );
        RETURN_ON_FAIL_OR_NULL2(hr, pDTE, E_NOINTERFACE);

        CComPtr<_Solution> pSln = NULL;
        hr = pDTE->get_Solution((Solution**)&pSln);
        RETURN_ON_FAIL_OR_NULL2(hr, pSln, E_NOINTERFACE);

        // this is the guid for the vc project system
        hr = pSln->ProjectItemsTemplatePath( L"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}", &bstrTemplatePath );
        RETURN_ON_FAIL(hr);

        CStringW strRCWiz = bstrTemplatePath;
        long pos = strRCWiz.ReverseFind( L'\\' );
        if( pos <= 0 )
            return E_FAIL;
        strRCWiz = strRCWiz.Left( pos );
        strRCWiz += L"\\VCContextItems\\addresource.vsz";
        
        CComBSTR bstrRCWiz = strRCWiz;

        CComVariant varPrj;
        hr = GetExtObject(varPrj);
        CComQIPtr<_Project> pPrj = varPrj.pdispVal;
        CComPtr<ProjectItems> spItems;

        if( pPrj )
        {
            pPrj->get_ProjectItems(&spItems);
        }
        else
        {
            CComQIPtr<_ProjectItem> pPrjItem = varPrj.pdispVal;
            if( pPrjItem )
            {
                pPrjItem->get_ProjectItems(&spItems);
            }
        }

        CComBSTR bstrPrjDir;
        pProject->get_ProjectDirectory( &bstrPrjDir );

        bstrPath = bstrPrjDir;
        bstrPath += bstrName;
        if (FAILED(hr = spItems->AddFromTemplate(bstrRCWiz, bstrPath, (ProjectItem**)&pDispFile)))
            return hr;
        if(!pDispFile)
            return hr;

    }

    // insert the resource
    // (the composition returned is not add-ref'd: don't use a smart ptr here)
    CComPtr <IVCWin32Composition> spComp;
    if (bstrPath)
        hr = pCompSvc->CreateCompositionFromRC( bstrPath, &spComp );
    else
        return E_FAIL;
    CComQIPtr<IOleCommandTarget> pCmdTarget = spComp;
    RETURN_ON_FAIL_OR_NULL2(hr, pCmdTarget, E_NOINTERFACE);
    hr = pCmdTarget->Exec( &guidVSStd2K, ECMD_RESOURCENEW, 0, NULL, NULL );

    return hr;
}

//-----------------------------------------------------------------------------
//	This method instructs the node to refresh its children. (which in our
//	case will lose all the children, and then set a flag to FALSE, indicating
//	that the next time someone asks for our children, we have to enumerate
//	them again).
//-----------------------------------------------------------------------------
HRESULT CVCBaseFolderNode::Refresh(CVCArchy *pHierarchy)
{
	DeleteAll(pHierarchy);
	m_grfStateFlags &= ~ST_ChildrenEnumerated;
	return S_OK;
}

VSITEMID CVCBaseFolderNode::GetFirstChild(void)
{
	return (NULL != GetHeadEx()) ? GetHead()->GetVsItemID() : VSITEMID_NIL;
}

CVCNode* CVCBaseFolderNode::GetHeadEx(void)
{
	if (!HaveChildrenBeenEvaluated())
	{
		HRESULT hr = EnumerateChildren();
		if (SUCCEEDED(hr))
			m_grfStateFlags |= ST_ChildrenEnumerated;
		else
			return NULL;
	}
	return GetHead();
}

//-----------------------------------------------------------------------------
// Loops over all this object's children, counting them and returns that count
//-----------------------------------------------------------------------------
long CVCBaseFolderNode::GetCount(void) const
{
	long n = 0;
	CVCNode *pNext = GetHead();

	while (pNext != NULL)
	{
		pNext = pNext->GetNext();
		++n;
	}
	return n;
}

//-----------------------------------------------------------------------------
// Returns the previous child, given the current child. (or NULL)
//-----------------------------------------------------------------------------
CVCNode* CVCBaseFolderNode::GetPrevChildOf(const CVCNode* pCurrent) const
{
	VSASSERT(m_pHeadNode != NULL, "No child list!");
	if (pCurrent == m_pHeadNode)
	{
		return NULL;
	}
	CVCNode* pNodePrev = m_pHeadNode;
	while (pNodePrev != NULL && pNodePrev->GetNext() != pCurrent)
	{
		pNodePrev = pNodePrev->GetNext();
	}
	return pNodePrev;
}

//-----------------------------------------------------------------------------
// Adds pNewNode after pCurrNode
//-----------------------------------------------------------------------------
void CVCBaseFolderNode::AddAfter(CVCNode* const pCurrNode, CVCNode* const pNewNode)
{
	VSASSERT(pNewNode != NULL, "Invalid input parameter!");

	if (pCurrNode)
	{
		pNewNode->SetNext(pCurrNode->GetNext());
		pCurrNode->SetNext(pNewNode);

		//NotifyHierarchyOfAdd(pCurrNode, pNewNode);
		if (HaveChildrenBeenEvaluated() && GetHierarchy())
			GetHierarchy()->OnItemAdded(this, pCurrNode, pNewNode);
	}
	else
		AddHead(pNewNode);
}

//-----------------------------------------------------------------------------
// Adds the given node to the head of this containers list.
//-----------------------------------------------------------------------------
void CVCBaseFolderNode::AddHead(CVCNode *const pNode)
{
	VSASSERT(pNode != NULL, "Invalid input parameter!");

	pNode->SetParent(this);
	pNode->SetNext(m_pHeadNode);

	m_pHeadNode = pNode;
	if (m_pTailNode == NULL)
		m_pTailNode = pNode;

	if( GetHierarchy() )
		GetHierarchy()->OnItemAdded(this, NULL, pNode);	// NOT an interface call...
}

//-----------------------------------------------------------------------------
//	Adds the given node to the tail of this containers list.
//-----------------------------------------------------------------------------
void CVCBaseFolderNode::AddTail(CVCNode *const pNode)
{
	VSASSERT(pNode != NULL, "Invalid input parameter!");

	pNode->SetParent(this);
	pNode->SetNext(NULL);

	CVCNode * pNodePrev = m_pTailNode;

	if (m_pTailNode != NULL)
	{
		VSASSERT(m_pHeadNode != NULL, "No head node to match tail node!");
		m_pTailNode->SetNext(pNode);
		m_pTailNode = pNode;
	}
	else
	{
		VSASSERT(m_pHeadNode == NULL, "Better not be a head node if no tail node...");
		m_pHeadNode = m_pTailNode = pNode;
	}

	if( GetHierarchy() )
		GetHierarchy()->OnItemAdded(this, pNodePrev, pNode);	// NOT an interface call...
}

//-----------------------------------------------------------------------------
//	Generic Add function calls AddTail. Override to get custom add behavior.
//-----------------------------------------------------------------------------
void CVCBaseFolderNode::Add(CVCNode *const pNode)
{
	VSASSERT(pNode != NULL, "Invalid input parameter!");
	AddTail(pNode);
}

//-----------------------------------------------------------------------------
//	Remove the given node from this container, does not delete the node
//	Return Values:
//		S_OK - success
//		E_FAIL - The node is not in the list of children (also _ASSERTEs)
//-----------------------------------------------------------------------------
HRESULT CVCBaseFolderNode::Remove(CVCNode *pNode)
{
	VSASSERT(pNode != NULL, "Invalid input parameter!");
	RETURN_ON_NULL(pNode);

	CVCNode *pNodeCur  = m_pHeadNode;	// The node to be removed
	CVCNode *pNodePrev = NULL;		// fix this node's next pointer

	while (pNode != pNodeCur && pNodeCur != NULL)
	{	// find pNode in list of children
		pNodePrev = pNodeCur;
		pNodeCur = pNodeCur->GetNext();
	}
	// TODO: investigate chance pNode will not be in this list
	VSASSERT(pNodeCur != NULL, "caller gave a node not in the list!");

	if (pNodeCur != NULL)
	{	// Then we found the node in the list. (this is a good thing!)
		if (pNodeCur == m_pHeadNode)
		{	// pNode is the HeadNode
			VSASSERT(pNode == m_pHeadNode, "Current node is head node, but our input parameter isn't?!?");
			m_pHeadNode = pNode->GetNext();
			if (m_pHeadNode == NULL)
			{	// single child case
				m_pTailNode = NULL;
			}
		}
		else if (pNodeCur == m_pTailNode)
		{	// We are removing the last node.
			m_pTailNode = pNodePrev;
			pNodePrev->SetNext(NULL);
		}
		else
		{	// We are just removing a node in the middle.
			pNodePrev->SetNext(pNode->GetNext());
		}

		pNode->SetParent(NULL);
		pNode->SetNext(NULL);
		return S_OK;
	}
	return E_FAIL;
}

//-----------------------------------------------------------------------------
//	This method removes a child from the container and deletes it.
//	Return Values:
//		S_OK - successfully removed & deleted node
//		E_FAIL - Remove from the list failed. It probably _ASSERTEed too.
//-----------------------------------------------------------------------------
HRESULT CVCBaseFolderNode::Delete(CVCNode *pNode, CVCArchy *pHierarchy)
{	// TODO: investigate chance pNode will not be in this list
	VSASSERT(pNode != NULL, "Invalid input parameter!");
	RETURN_ON_NULL(pNode);
	if (NULL != pHierarchy)
	{
		HRESULT hr = pHierarchy->OnItemDeleted(pNode);
		VSASSERT(SUCCEEDED(hr), "OnItemDeleted notification failed!");
	}
	HRESULT hr = Remove(pNode);
	if (SUCCEEDED(hr))
	{	// remove item from hierarchy (and its selection) before release
		pNode->Release();
	}
	return hr;
}

//-----------------------------------------------------------------------------
// This method removes all children from the container and destroys them.
//-----------------------------------------------------------------------------
void CVCBaseFolderNode::DeleteAll(CVCArchy *pHierarchy)
{
	while (GetHead() != NULL)
	{
		HRESULT hr = Delete(GetHead(), pHierarchy);
		VSASSERT(SUCCEEDED(hr), "Delete of an item failed!");
	}
}

HRESULT CVCBaseFolderNode::GetProperty(VSHPROPID propid, VARIANT *pvar)
{
	HRESULT hr = E_FAIL;
	CComVariant varRes;
	switch( propid )
	{
	case VSHPROPID_Expandable:
		V_VT(pvar) = VT_I4;
		V_I4(pvar) = TRUE;
		return S_OK;
	case VSHPROPID_FirstChild:
		V_VT(pvar) = VT_I4;
		V_INT_PTR(pvar) = (NULL != GetHeadEx()) ? GetHead()->GetVsItemID() : VSITEMID_NIL;
		return S_OK;
	case VSHPROPID_ExpandByDefault:
		V_VT(pvar) = VT_BOOL;
		V_BOOL(pvar) = m_fAutoExpand ?  VARIANT_TRUE : VARIANT_FALSE;
		return S_OK;
	default:
		hr = CVCNode::GetProperty(propid, &varRes);
		break;
	}
	varRes.Detach(pvar);
	return hr;
}

HRESULT CVCBaseFolderNode::SetProperty(VSHPROPID propid, const VARIANT & var)
{
	CComVariant vt = VARIANT_TRUE;

	if (VSHPROPID_ExpandByDefault == propid || VSHPROPID_Expanded == propid)
	{
		if (VSHPROPID_ExpandByDefault == propid)
			m_fAutoExpand = vt == var; 
		GetHierarchy()->OnPropertyChanged(this, propid, 0);	// NOT an interface call...
		return S_OK;
	}
	VSASSERT(0, _T("error: unknown property"));
	return E_UNEXPECTED;
}

//---------------------------------------------------------------------------
// Paste handler. Delegate to hierarchy.
//---------------------------------------------------------------------------
HRESULT CVCBaseFolderNode::OnPaste()
{ 
	if (GetHierarchy())
		return GetHierarchy()->PasteFromClipboard(this);	// NOT an interface call...
	else
		return S_FALSE;
}

//---------------------------------------------------------------------------
// Returns TRUE if OK to paste
//---------------------------------------------------------------------------
BOOL CVCBaseFolderNode::CanPaste()
{ 
	if (GetHierarchy())
		return GetHierarchy()->CanPasteFromClipboard();	// NOT an interface call...
	else
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcnode.cpp ===
// VCNode.cpp: implementation of the CVCNode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BldPkg.h"
#include "VCNode.h"   // coming from HierLib
#include "VCArchy.h"
#include "..\resdll\gpcmd.h"
#include "oleipc.h"
#include <vcguid.h>
#include "context.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVCNode::CVCNode( void ) :
	m_pNodeParent( NULL ),
	m_pNodeNext( NULL ),
	m_fDragDropMoved( FALSE )
{
}

HRESULT CVCNode::GetVCProject(VCProject** ppProject) 
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;

	VSASSERT(g_pBuildPackage->m_pProjectEngine, "Project engine not initialized!");
	if (g_pBuildPackage->m_pProjectEngine)
	{
		CHECK_ZOMBIE(GetRootNode(), IDS_ERR_PROJ_ZOMBIE);
		CComPtr<IDispatch> pDispPropertyContainer = ((CVCProjectNode*)GetRootNode())->m_dispkeyItem;
		if (pDispPropertyContainer)
		{
			CComQIPtr<VCProject> pProj = pDispPropertyContainer;
			*ppProject = pProj.Detach();
		}
	}
	return S_OK; 
}

HRESULT CVCNode::GetDispVCProject(IDispatch** ppProject) 
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;

	VSASSERT(g_pBuildPackage->m_pProjectEngine, "Project engine not initialized!");
	if (g_pBuildPackage->m_pProjectEngine)
	{
		CHECK_ZOMBIE(GetRootNode(), IDS_ERR_PROJ_ZOMBIE);
		CComPtr<IDispatch> pDispPropertyContainer = ((CVCProjectNode*)GetRootNode())->m_dispkeyItem;
		*ppProject = pDispPropertyContainer.Detach();
	}
	return S_OK; 
}

HRESULT CVCNode::GetVCItem(IDispatch** ppItem)
{
	CHECK_POINTER_NULL(ppItem);
	*ppItem = m_dispkeyItem;
	if (*ppItem)
		(*ppItem)->AddRef();
	return S_OK;
}

HRESULT CVCNode::CanDirtyProject( void )
{
	CHECK_ZOMBIE(GetRootNode(), IDS_ERR_PROJ_ZOMBIE);
	// see if we are allowed to touch the project
	CComPtr<IDispatch> pProj;
	((CVCProjectNode*)GetRootNode())->GetDispVCProject(&pProj);
	CComQIPtr<IVCProjectImpl> pProjImpl = pProj;
	RETURN_ON_NULL2(pProjImpl, E_NOINTERFACE);
	VARIANT_BOOL bCanDirty = VARIANT_TRUE;
	if( pProjImpl->get_CanDirty( &bCanDirty ) != S_OK || bCanDirty == VARIANT_FALSE)
		return E_ACCESSDENIED;
	return S_OK;
}

// automation extender helper functions
HRESULT CVCNode::GetExtender( LPOLESTR wszGuid, BSTR bstrExtenderName, IDispatch **ppExtender )
{
	CHECK_POINTER_NULL(ppExtender);
	*ppExtender = NULL;

	CComBSTR bstrCATID( wszGuid );
	if( !bstrCATID )
		return S_OK;

	// validate params
	if( !bstrExtenderName )
		return S_FALSE;

	// get internal ExtensionManager svc
	CComPtr<ObjectExtenders> spExtMgr;
	HRESULT hr = ExternalQueryService( SID_SExtensionManager, IID_ObjectExtenders, (void **)&spExtMgr );
	RETURN_ON_FAIL_OR_NULL(hr, spExtMgr);

	// call GetExtension on svc
	return spExtMgr->GetExtender( bstrCATID, bstrExtenderName, (LPDISPATCH)this, ppExtender );
}

HRESULT CVCNode::GetExtenderNames( LPOLESTR wszGuid, VARIANT *pvarExtenderNames )
{
	// validate params
	CHECK_POINTER_NULL( pvarExtenderNames );

	CComBSTR bstrCATID( wszGuid );
	if( !bstrCATID )
		return S_OK;

	// get internal ExtensionManager svc
	CComPtr<ObjectExtenders> spExtMgr;
	HRESULT hr = ExternalQueryService( SID_SExtensionManager, IID_ObjectExtenders, (void **)&spExtMgr );
	RETURN_ON_FAIL_OR_NULL(hr, spExtMgr);

	// call GetExtensionNames on svc
	return spExtMgr->GetExtenderNames( bstrCATID, (LPDISPATCH) this, pvarExtenderNames );
}

IDispatch * CVCNode::GetPropertyContainer(void)
{
	CComPtr<IDispatch> pDispPropertyContainer;

	VSASSERT(g_pBuildPackage->m_pProjectEngine, "Project engine not initialized!");
	if (g_pBuildPackage->m_pProjectEngine)
	{
		pDispPropertyContainer = m_dispkeyItem;
	}
	return pDispPropertyContainer; 
}

DWORD CVCNode::TranslateEnableState(enumEnableStates eState)
{
	switch (eState)
	{
	case eEnableNotSupported:
		return 0;
	case eEnableInvisible:
		return OLECMDF_INVISIBLE;
	case eEnableLatchedAndEnabled:
		return OLECMDF_ENABLED|OLECMDF_LATCHED; // OLECMDF_NINCHED
	case eEnableSupportedAndEnabled:
		return OLECMDF_SUPPORTED|OLECMDF_ENABLED;
	case eEnableEnabled:
		return OLECMDF_ENABLED;
	case eEnableLatched:
		return OLECMDF_LATCHED;
	case eEnableSupported:
		return OLECMDF_SUPPORTED;
	case eEnableSupportedAndInvisible:
		return OLECMDF_SUPPORTED | OLECMDF_INVISIBLE;
	default:
		VSASSERT(FALSE, "Unhandled state for TranslateEnableState");
		return OLECMDF_SUPPORTED;
	}
}

//-----------------------------------------------------------------------------
// Called to execute our commands
//-----------------------------------------------------------------------------
STDMETHODIMP CVCNode::Exec(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	if(*pguidCmdGroup == guidVSStd2K)
	{
		switch(nCmdID)
		{
			// WARNING: When adding commands to this list, they must be implemented
			//          in either VCProjectNode, or VCBsFolderNode, or we well recurse
			//          infinitely and crash !
			case ECMD_ADDRESOURCE:
			case ECMD_ADDWEBREFERENCE:
			{
				CVCProjectNode* pProjNode = GetVCProjectNode();
				RETURN_ON_NULL2(pProjNode, OLECMDERR_E_NOTSUPPORTED);
				return pProjNode->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
			}
			default:
				return OLECMDERR_E_NOTSUPPORTED;
		}
	}
	else if(*pguidCmdGroup == guidVSStd97)
	{	
		switch(nCmdID)
		{
			// WARNING: When adding commands to this list, they must be implemented
			//          in either VCProjectNode, or VCBsFolderNode, or we well recurse
			//          infinitely and crash !
			case cmdidAddNewItem:
			case cmdidAddExistingItem:
			case cmdidNewFolder:
			case cmdidAddClass:
			{
				CVCProjectNode* pProjNode = GetVCProjectNode();
				RETURN_ON_NULL2(pProjNode, OLECMDERR_E_NOTSUPPORTED);
				return pProjNode->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
			}
			default:
					return OLECMDERR_E_NOTSUPPORTED;
		}
	}
 	return OLECMDERR_E_NOTSUPPORTED;
}


//-----------------------------------------------------------------------------
//	Called to update the status for each command
//-----------------------------------------------------------------------------
STDMETHODIMP CVCNode::QueryStatus(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText)
{
	RETURN_ON_NULL2(pguidCmdGroup, OLECMDERR_E_UNKNOWNGROUP);
	
	enumKnownGuidList eGuid = eGuidUninitialized;
	if (*pguidCmdGroup == guidVSStd2K)
		eGuid = eGuidVSStd2K;
	else if (*pguidCmdGroup == guidVSStd97)
		eGuid = eGuidVSStd97;	// Common VB commands
	else
		return OLECMDERR_E_UNKNOWNGROUP;

	HRESULT hr = NOERROR;
	for (ULONG i = 0; i < cCmds && SUCCEEDED(hr); i++)
		hr = QueryStatusAtIndex(eGuid, pguidCmdGroup, prgCmds, pCmdText, i);

	if (FAILED(hr))
	{
		VSASSERT(cCmds == 1, "We're not set up right to handle a failed command if more than one present");
	}

	return hr;
}

HRESULT CVCNode::QueryStatusAtIndex(enumKnownGuidList eGuid, const GUID* pguidCmdGroup, OLECMD prgCmds[],
	OLECMDTEXT *pCmdText, ULONG nIndex)
{
	if (eGuid == eGuidUninitialized)
	{
		if (*pguidCmdGroup == guidVSStd2K)
			eGuid = eGuidVSStd2K;
		else if (*pguidCmdGroup == guidVSStd97)
			eGuid = eGuidVSStd97;
		else
			return OLECMDERR_E_UNKNOWNGROUP;
	}

	enumEnableStates fEnable = eEnableSupported;
	HRESULT hr = NOERROR;
	switch (eGuid)
	{
		case eGuidVSStd2K:
		{
			switch(prgCmds[nIndex].cmdID)
			{
				case ECMD_ADDRESOURCE:
				case ECMD_PROJSETTINGS:
				case ECMD_ADDWEBREFERENCE:
#ifdef AARDVARK
				case ECMD_SHOWALLFILES:
				case ECMD_COPYPROJECT:
				case ECMD_SLNREFRESH:
#endif
					fEnable = eEnableSupportedAndEnabled; //GetProjectNode()->IsSourceControlled() && !IsInSourceControl();
					break;
				default:
					fEnable = eEnableNotSupported;
					break;
			}
			break;
		}
		case eGuidVSStd97:
		{
			switch(prgCmds[nIndex].cmdID)
			{
				case cmdidAddClass:
				case cmdidAddExistingItem:
				case cmdidAddNewItem:
				case cmdidNewFolder:
				case cmdidPropertyPages:
				case cmdidShowProperties:
					fEnable = eEnableSupportedAndEnabled;
					break;
				default:
					return OLECMDERR_E_NOTSUPPORTED;
			}
			break;
		}
		default:
			break;
	}

	prgCmds[nIndex].cmdf = TranslateEnableState(fEnable);
	if (prgCmds[nIndex].cmdf == 0)
		return OLECMDERR_E_NOTSUPPORTED;

	return hr;
}

//---------------------------------------------------------------------------
//	Shows context-sensitive menu
//---------------------------------------------------------------------------
HRESULT CVCNode::ShowContextMenu(UINT imxMenuID, VARIANT *pvaIn, GUID guidMenuGroup, IOleCommandTarget *pOleCommandTarget /*=NULL*/)
{
	CComPtr<IOleComponentUIManager> srpOleComponentUImanager;
	HRESULT hr = ExternalQueryService(SID_OleComponentUIManager, __uuidof(IOleComponentUIManager), (void**)&srpOleComponentUImanager);
	RETURN_ON_FAIL_OR_NULL(hr, srpOleComponentUImanager);

    CComQIPtr<IOleInPlaceComponentUIManager> srpComponentUImanager = srpOleComponentUImanager;
	if (srpComponentUImanager)
		srpComponentUImanager->UpdateUI(0, FALSE, 0);

	if (!pOleCommandTarget)
	{
		CVCArchy *pVsHierarchy = GetHierarchy();
		VSASSERT(pVsHierarchy, "Unable to get the hierarchy!");

		pOleCommandTarget = VCQI_cast<IOleCommandTarget>(pVsHierarchy);
	}

	// POINT  pnt;
	// GetCursorPos(&pnt);
	// POINTS pnts; = { (SHORT)pnt.x, (SHORT)pnt.y };
	POINTS pnts;
	ULONG ulPts = V_UI4(pvaIn);
    memcpy((void*)&pnts, &ulPts, sizeof(POINTS));
	
	return srpOleComponentUImanager->ShowContextMenu(0, guidMenuGroup, imxMenuID, pnts, pOleCommandTarget);
}

HRESULT CVCNode::GetGuidProperty( VSHPROPID propid, GUID *pguid)
{
	return E_NOTIMPL;	// CVCNode::GetGuidProperty
}

HRESULT CVCNode::SetGuidProperty( VSHPROPID propid, GUID guid)
{
	return E_NOTIMPL;	// CVCNode::SetGuidProperty
}

HRESULT CVCNode::SetProperty(VSHPROPID propid, const VARIANT& var)
{
	return E_NOTIMPL;	// CVCNode::SetProperty
}

//---------------------------------------------------------------------------
//	Returns the requested property in the given variant.
//---------------------------------------------------------------------------
HRESULT CVCNode::GetProperty(VSHPROPID propid, VARIANT *pvar)
{
	HRESULT hr = E_FAIL;
	CComVariant varRes;
	switch( propid )
	{
		case VSHPROPID_ProjectDir:
		{
			CComBSTR bstrProjDir;
			CComPtr<VCProject> pProject;
			GetVCProject(&pProject);
			if (pProject)
			{
				hr = pProject->get_ProjectDirectory( &bstrProjDir );
				varRes = bstrProjDir;
			}
			break;
		}
		case VSHPROPID_ExtObject:
		{
			hr = GetExtObject(varRes);
			break;
		}
		case VSHPROPID_TypeName:
		{
			CString strTitle;
	
			strTitle.LoadString(g_hInstLocale, IDS_PROJECTS_TITLE);
			varRes = strTitle;
			hr = S_OK;
			break;
		}
		case VSHPROPID_ReloadableProjectFile:
		{
			varRes.ChangeType(VT_BOOL);
			varRes = VARIANT_FALSE;
			hr = S_OK;
			break;
		}
		case VSHPROPID_IsNonLocalStorage:
		{
			varRes.ChangeType(VT_BOOL);
			varRes = VARIANT_FALSE;
			hr = S_OK;
			break;
		}
		case VSHPROPID_ConfigurationProvider:
		{
			varRes.ChangeType(VT_UNKNOWN);
			varRes.punkVal = NULL;
			CVCArchy *pVsHierarchy = (CVCArchy *)GetHierarchy();
			IUnknown *pUnk = NULL;
			if (pVsHierarchy)
			{
				hr = pVsHierarchy->QueryInterface(IID_IUnknown, (void **)&pUnk);
				varRes = pUnk;
				pUnk->Release();
			}
			break;
		}
		case VSHPROPID_Expandable:
		{
			V_VT(pvar) = VT_I4;
			V_I4(pvar) = FALSE;
			return S_OK;
		}
		case VSHPROPID_AltHierarchy:
		{
			V_VT(pvar) = VT_I4;
			V_UI4(pvar) = NULL;
			return E_FAIL;
		}
		case VSHPROPID_SortPriority:
		{
			V_VT(pvar) = VT_BOOL;
			V_UI4(pvar) = VARIANT_FALSE;
			return E_FAIL;
		}
		case VSHPROPID_ParentHierarchy :
		{
			V_VT(pvar) = VT_UNKNOWN;
			V_UNKNOWN(pvar) = NULL;
			return S_OK;
		}
		case VSHPROPID_ParentHierarchyItemid:
		{
			V_VT(pvar) = VT_INT_PTR;
			V_INT_PTR(pvar) = VSITEMID_NIL;
			return S_OK;
		}
		case VSHPROPID_BrowseObject :
		{
			VariantInit(pvar);
			if(SUCCEEDED(QueryInterface(IID_IDispatch, (void **)&V_DISPATCH(pvar))))
			{
				V_VT(pvar) = VT_DISPATCH;
			}
			return S_OK;
		}
		case VSHPROPID_ItemDocCookie:
		case VSHPROPID_ImplantHierarchy:
		case VSHPROPID_FirstVisibleChild:
		case VSHPROPID_NextVisibleSibling:
		case VSHPROPID_IsHiddenItem:
		case VSHPROPID_IsNonMemberItem:
        case VSHPROPID_OverlayIconIndex:
			return E_NOTIMPL;	// CVCNode::GetProperty, properties we specifically don't support

		case VCPROPID_ProjBldActiveFileConfig:
		case VCPROPID_ProjBldIncludePath:
			return E_NOTIMPL;	// CVCNode::GetProperty, properties we specifically don't support
	
		case VCPROPID_ProjBldObject:
			if (SUCCEEDED(GetVCItem(&V_DISPATCH(pvar))))
			{
				V_VT(pvar) = VT_DISPATCH;
				return S_OK;
			}
			break;

		case VCPROPID_ProjBldProject:
			if (SUCCEEDED(GetDispVCProject(&V_DISPATCH(pvar))))
			{
				V_VT(pvar) = VT_DISPATCH;
				return S_OK;
			}
			break;

		case VCPROPID_ProjBldActiveProjConfig:
			hr = GetActiveVCProjectConfig(&V_DISPATCH(pvar));
			if (SUCCEEDED(hr))
			{
				V_VT(pvar) = VT_DISPATCH;
				return S_OK;
			}
			break;

		default:
			hr = E_FAIL;
			break;
	}
	varRes.Detach(pvar);
	return hr;
}

HRESULT CVCNode::GetActiveVCProjectConfig(IDispatch** ppProjCfg)
{
	CHECK_POINTER_NULL(ppProjCfg);

	CVCArchy* pArchy = GetHierarchy();
	RETURN_ON_NULL(pArchy);

	CVCProjectNode* pProjNode = pArchy->GetProjectNode();
	RETURN_ON_NULL(pProjNode);

	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = pProjNode->GetActiveConfig(&spGenCfg);
	CComQIPtr<IVCCfg> spCfg = spGenCfg;
	RETURN_ON_FAIL_OR_NULL(hr, spCfg);

	return spCfg->get_Object(ppProjCfg);
}

void CVCNode::SetCaption(BSTR bstrNewCaption)
{	
	// inform the ui
	if (GetHierarchy())
		GetHierarchy()->OnPropertyChanged(this, /*VSHPROPID_NIL*/ VSHPROPID_Caption, 0);	// NOT an interface call...
}

HRESULT CVCNode::ShowSettings(REFGUID guidProps)
{
	// for this one command, set the focus to Project Explorer before letting shell actually do what
	// it wants to do
	CComPtr<IOleCommandTarget> srpCmdTgt;
	if (SUCCEEDED(ExternalQueryService( SID_SUIHostCommandDispatcher, IID_IOleCommandTarget, 
		(void**)&srpCmdTgt)) && srpCmdTgt != NULL)
	{
		srpCmdTgt->Exec(&CLSID_StandardCommandSet97, cmdidProjectExplorer, OLECMDEXECOPT_DODEFAULT, 
			NULL, NULL);
	}

	CComPtr<IVsPropertyPageFrame> pPPFrame;
	HRESULT hr = ExternalQueryService(SID_SVsPropertyPageFrame, IID_IVsPropertyPageFrame, (void**)&pPPFrame);
	RETURN_ON_FAIL_OR_NULL(hr, pPPFrame);

	hr = pPPFrame->ShowFrame(guidProps);
	if (FAILED(hr))
	{
		pPPFrame->ReportError(hr);
		pPPFrame->HideFrame();
	}

	return hr;
}

CVCArchy* CVCNode::GetHierarchy(void) const
{
	// if parent is NULL, then this should be in CHierRoot
	// or this is a serious programming mistake
	VSASSERT(NULL != GetParent(), "No parent?  Deep trouble somewhere.");

	CVCNode *pNode = GetParent();
	RETURN_ON_NULL2(pNode, NULL);

	while (NULL != pNode->GetParent())
		pNode = pNode->GetParent();
	return pNode->GetHierarchy();
}

//---------------------------------------------------------------------------
//	Iteratively get the root node of the tree
//---------------------------------------------------------------------------
CVCNode* CVCNode::GetRootNode(void) const
{
	CVCNode *pNode = const_cast<CVCNode *>(this);	// safe
	for (; pNode->GetParent() != NULL; pNode = pNode->GetParent());
	return pNode;
}

//---------------------------------------------------------------------------
// return the VSITEMID value for this node
// a cast of the this pointer to the VSITEMID (dword) type
// exception will be for root nodes which should return VSITEMID_ROOT
//---------------------------------------------------------------------------
VSITEMID CVCNode::GetVsItemID(void) const
{
	return reinterpret_cast<VSITEMID>(this);
}

//-----------------------------------------------------------------------------
// class CVCWaitCursor
//-----------------------------------------------------------------------------
HCURSOR CVCWaitCursor::m_hWaitCur = ::LoadCursor(NULL, IDC_WAIT);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcfile.h ===
// VCFile.h: interface for the CVCFileNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VCFILE_H__7F438FBE_AB8B_11D0_8D1E_00A0C91BC942__INCLUDED_)
#define AFX_VCFILE_H__7F438FBE_AB8B_11D0_8D1E_00A0C91BC942__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "vc.h"
#include "VCNode.h"
#include "prjnode.h"


class CVCFileNode : public CVCNode,	 
				public IDispatchImpl<File, &IID_File, &LIBID_VCPrivateProjectLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
				public IVsPerPropertyBrowsing,
				public IPerPropertyBrowsing,
				public IOleCommandTarget,
				public IVsExtensibleObject,
				public IVsCfgProvider2
{
public:
	CVCFileNode(void);
	virtual ~CVCFileNode();

	BOOL Open();
	HRESULT OpenWith();
	static HRESULT CreateInstance(CVCFileNode **, IDispatch* pItem);
	virtual HRESULT DoDefaultAction(BOOL fNewFile);
	virtual HRESULT DoPreview();
	virtual HRESULT GetCanonicalName(BSTR* pbstrCanonicalName);
	virtual HRESULT GetName(BSTR* pbstrName);
	virtual HRESULT OnDelete(CVCNode *pRoot, DWORD dwFileOp, BOOL bCloseIfOpen = TRUE);
	virtual HRESULT CleanUpUI( CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE );
	virtual HRESULT OnCompileFile();
	virtual HRESULT OnRefreshWebRef();
	virtual HRESULT CleanUpBeforeDelete();
	HRESULT CleanUpObjectModel(IDispatch* pParentDisp, IDispatch* pItemDisp);
	HRESULT GetObjectsForDelete(IDispatch** ppParentDisp, IDispatch** ppItemDisp);
	bool IsBuildable( void );
	bool IsHTML( void );
	bool IsWSDL( void );

	HRESULT GetActiveVCFileConfig(IDispatch** ppDispFileCfg);
	HRESULT GetVCIncludePath(BSTR* pbstrIncPath);

BEGIN_COM_MAP(CVCFileNode)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(File)
	COM_INTERFACE_ENTRY(IVsCfgProvider2)
	COM_INTERFACE_ENTRY(IVsCfgProvider)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(IVsExtensibleObject)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCFileNode)

// IPerPropertyBrowsing
public:
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr )
		{ return E_NOTIMPL; /* CVCFileNode::GetDisplayString */ }
	STDMETHOD(MapPropertyToPage)( DISPID dispID, CLSID *pClsid )
		{ return E_NOTIMPL; /* CVCFileNode::MapPropertyToPage */ }
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut )
		{ return E_NOTIMPL; /* CVCFileNode::GetPredefinedStrings */ }
	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut )
		{ return E_NOTIMPL; /* CVCFileNode::GetPredefinedValue */ }
// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide)
		{ return E_NOTIMPL; /* CVCFileNode::HideProperty */ }
	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay)
		{ return E_NOTIMPL; /* CVCFileNode::DisplayChildProperties */ }
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault)
		{ return E_NOTIMPL; /* CVCFileNode::HasDefaultValue */ }
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly)
		{ return E_NOTIMPL; /* CVCFileNode::IsPropertyReadOnly */ }
	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc);
	STDMETHOD(GetClassName)(BSTR* pbstrClassName);
	STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
	STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}


// IVsCfgProvider, IVsCfgProvider2
	STDMETHOD(GetCfgs)( ULONG celt, IVsCfg *rgpcfg[], ULONG *pcActual, VSCFGFLAGS *prgfFlags );
	STDMETHOD(GetCfgNames)( ULONG celt,BSTR rgbstr[], ULONG *pcActual );
	STDMETHOD(GetPlatformNames)( ULONG celt, BSTR rgbstr[], ULONG *pcActual);
	STDMETHOD(GetCfgOfName)( LPCOLESTR pszCfgName, LPCOLESTR pszPlatformName, IVsCfg **ppCfg );
	STDMETHOD(AddCfgsOfCfgName)( LPCOLESTR pszCfgName, LPCOLESTR pszCloneCfgName, BOOL fPrivate );
	STDMETHOD(DeleteCfgsOfCfgName)( LPCOLESTR pszCfgName );
	STDMETHOD(RenameCfgsOfCfgName)( LPCOLESTR pszOldName, LPCOLESTR pszNewName );
	STDMETHOD(AddCfgsOfPlatformName)( LPCOLESTR pszPlatformName, LPCOLESTR pszClonePlatformName );
	STDMETHOD(DeleteCfgsOfPlatformName)( LPCOLESTR pszPlatformName );
	STDMETHOD(GetSupportedPlatformNames)( ULONG celt, BSTR rgbstr[], ULONG *pcActual );
	STDMETHOD(GetCfgProviderProperty)( VSCFGPROPID propid, VARIANT *pvar );
	STDMETHOD(AdviseCfgProviderEvents)( IVsCfgProviderEvents *pCPE, VSCOOKIE *pdwCookie );
	STDMETHOD(UnadviseCfgProviderEvents)( VSCOOKIE dwCookie );

// File
	STDMETHOD(get_Name)( BSTR *pVal );
	STDMETHOD(get_FullPath)(BSTR *pVal);
	STDMETHOD(get_RelativePath)(BSTR *pVal);
	STDMETHOD(put_RelativePath)(BSTR newVal);
	STDMETHOD(get_DeploymentContent)(VARIANT_BOOL *pVal);
	STDMETHOD(put_DeploymentContent)(VARIANT_BOOL newVal);
#ifdef AARDVARK
	CComBSTR m_bstrDeployLoc;
	STDMETHOD(get_DeploymentLocation)(BSTR *pVal){ m_bstrDeployLoc.CopyTo( pVal ); return S_OK; }
	STDMETHOD(put_DeploymentLocation)(BSTR newVal){ m_bstrDeployLoc = newVal; return S_OK;}
#endif// AARDVARK

	// automation extender methods
	STDMETHOD(get_Extender)(BSTR bstrName, IDispatch **ppDisp);
	STDMETHOD(get_ExtenderNames)(VARIANT *pvarNames);
	STDMETHOD(get_ExtenderCATID)(BSTR *pbstrGuid);

//---------------------------------------------------------------------------
// IVsExtensibleObject
//---------------------------------------------------------------------------
public:
	STDMETHOD(GetAutomationObject)(/*[in]*/ LPCOLESTR  pszPropName, /*[out]*/ IDispatch **ppDisp);

public:
	UINT GetIconIndex(ICON_TYPE);
	HRESULT GetGuidProperty( VSHPROPID propid, GUID *pguid);
	HRESULT SetProperty(VSHPROPID propid, const VARIANT& var);
	HRESULT GetProperty(VSHPROPID propid, VARIANT *pvar);

	// Command Routing
	STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);

	virtual HRESULT QueryStatusAtIndex(CVCNode::enumKnownGuidList eGuid, const GUID* pguidCmdGroup, 
		OLECMD prgCmds[], OLECMDTEXT *pCmdText, ULONG nIndex);
	virtual HRESULT DisplayContextMenu(VARIANT *pvaIn);

	BSTR GetFullPath( void );
	virtual UINT GetKindOf( void ) { return Type_CVCFile; }

protected:
	void Initialize(IDispatch* pItem);
	HRESULT GetCfgOfName(BSTR pszCfgName, VCFileConfiguration** ppFileCfg);

public:
	BOOL m_fDeleted;

	virtual CVCProjectNode* GetVCProjectNode();
	virtual HRESULT GetExtObject(CComVariant& varRes);
	HRESULT GetVCFile(VCFile** ppFile) 
	{ 
		CHECK_POINTER_NULL(ppFile);
		CComQIPtr<VCFile> spFile = m_dispkeyItem;
		*ppFile = spFile.Detach();
		return S_OK;
	}

protected:
	HRESULT OpenResourceEditor(CComBSTR& bstrPath);
	HRESULT OpenBscEditor(CComBSTR& bstrPath);
	HRESULT OpenAsmxEditor(CComBSTR& bstrPath);
	HRESULT OpenNormalEditor(CComBSTR& bstrPath, VSOSEFLAGS grfOpenStandard, REFGUID rguidLogicalView, BOOL fNewFile);

private:
	// automation extender CATID
	static const LPOLESTR s_wszCATID;

#ifdef AARDVARK
public:
	HRESULT HandleOpenForm(BOOL& bHandled);
	eMagic m_eMagic;
#endif // AARDVARK
};

#endif // !defined(AFX_VCFILE_H__7F438FBE_AB8B_11D0_8D1E_00A0C91BC942__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\VCNode.h ===
// VCNode.h: interface for the CVCNode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VCNODE_H__1FAE18F3_9021_11D0_8D12_00A0C91BC942__INCLUDED_)
#define AFX_VCNODE_H__1FAE18F3_9021_11D0_8D12_00A0C91BC942__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <bldtypes.h>

#ifdef AARDVARK
enum eMagic
{
	magicNone,
	magicReferenceFolder,
	magicOpenReferenceFolder,
	magicReference,
	magicBadReference,
	magicWinForm,
	magicUserControl,
	magicClass,
	magicWebCustomControl,
	magicSatelliteFolder,
	magicSatellite,
	// always leave this last:
	magicNotSet
};
#endif // AARDVARK

enum enumEnableStates 
{
	eEnableSupported = 0,
	eEnableSupportedAndEnabled = 1,
	eEnableInvisible = -1,
	eEnableNotSupported = -2,
	eEnableLatchedAndEnabled = -3,
	eEnableEnabled = -4,
	eEnableLatched = -5,
	eEnableSupportedAndInvisible = -6
};

enum {
	 Type_CHierNode = 1
	,Type_CHierContainer = 2
	,Type_CHierNestedContainer = 3
	,Type_CVCNode = 4
	,Type_CVCFile = 5
	,Type_CVCBaseFolderNode = 6
	,Type_CVCFileGroup = 7
	,Type_CVCProjectNode = 8
};

typedef enum ICON_TYPE
{
	ICON_Open,
	ICON_Closed,
	ICON_StateImage
} ICON_TYPE;

class CVCArchy;
class CVCProjectNode;

class CVCNode : 
	public IUnknown,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCNode)
	COM_INTERFACE_ENTRY(IUnknown)
END_COM_MAP()

public:
	enum enumKnownGuidList { eGuidUninitialized, eGuidVSStd2K, eGuidVSStd97 };

 	CVCNode(void);
	virtual ~CVCNode(void){};

	virtual UINT GetIconIndex( ICON_TYPE idx ) = 0;
	virtual CVCProjectNode* GetVCProjectNode() = 0;

	// Command Routing
	STDMETHOD(QueryStatus)(
		const GUID *pguidCmdGroup,
		ULONG cCmds,
		OLECMD prgCmds[],
		OLECMDTEXT *pCmdText);
	STDMETHOD(Exec)(
		const GUID *pguidCmdGroup,
		DWORD nCmdID,
		DWORD nCmdexecopt,
		VARIANT *pvaIn,
		VARIANT *pvaOut);

	virtual HRESULT QueryStatusAtIndex(enumKnownGuidList eGuid, const GUID* pguidCmdGroup, OLECMD prgCmds[],
		OLECMDTEXT *pCmdText, ULONG nIndex);
	// REVIEW: This is only for debugging purposes
	virtual const GUID* PGuidGetType(void) const { return NULL; }
	virtual HRESULT	EnumerateChildren() { return S_OK; }
	virtual HRESULT GetProperty(VSHPROPID propid, VARIANT* pvar);
	virtual HRESULT SetProperty(VSHPROPID propid, const VARIANT& var);
	virtual HRESULT GetGuidProperty( VSHPROPID propid, GUID *pguid);
	virtual HRESULT SetGuidProperty( VSHPROPID propid, GUID guid);

	HRESULT ShowContextMenu(UINT imxMenuID, VARIANT *pvaIn, GUID guidMenuGroup, IOleCommandTarget *pOleCommandTarget  = NULL);

	static DWORD TranslateEnableState(enumEnableStates eState);

	CComQIPtr<IDispatch> m_dispkeyItem;

	virtual HRESULT GetVCProject(VCProject** ppProject);
	virtual HRESULT GetDispVCProject(IDispatch** ppDispProject);
	HRESULT GetVCItem(IDispatch** ppItem);
	IDispatch* GetPropertyContainer();
	virtual HRESULT GetExtObject(CComVariant& varRes) { return E_FAIL; }
	virtual CVCArchy* GetHierarchy(void) const;
	HRESULT GetActiveVCProjectConfig(IDispatch** ppProjCfg);

 	void SetCaption(BSTR bstrNewCaption);
	virtual HRESULT OnDelete(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE) = 0;
	virtual HRESULT CleanUpUI(CVCNode *pRoot, DWORD dwDelItemOp, BOOL bCloseIfOpen = TRUE) = 0;
	HRESULT ShowSettings(REFGUID guidProps);
	virtual HRESULT DoDefaultAction(BOOL fNewFile){ return E_NOTIMPL; };
	virtual HRESULT GetCanonicalName(BSTR* pbstrCanonicalName) = 0;
	virtual HRESULT GetName(BSTR* pbstrName) = 0;

	CVCNode* GetParent(void) const
	{
		return m_pNodeParent;
	}
	void SetParent(CVCNode *pNode)
	{
		m_pNodeParent = pNode;
	}
	CVCNode* GetNext(void) const
	{
		return m_pNodeNext;
	}
	void SetNext(CVCNode *pHierNode)
	{
		m_pNodeNext = pHierNode;
	}
	CVCNode* GetPrev(void) const;
 	CVCNode* GetRootNode(void) const;

	virtual UINT GetKindOf( void ) = 0;

	// return a CHierNode typecasted to a VSITEMID or VISTEMID_ROOT
	// Override in each derived class that can also be a VSITEMID_ROOT
	virtual VSITEMID GetVsItemID(void) const;

	virtual HRESULT DisplayContextMenu(VARIANT *pvaIn) = 0;

protected:
	// helper functions
 	HRESULT CanDirtyProject( void );
	// automation extender helper functions
	HRESULT GetExtender( LPOLESTR wszGuid, BSTR bstrName, IDispatch **ppDisp );
	HRESULT GetExtenderNames( LPOLESTR wszGuid, VARIANT *pvarNames );

	// inheritable data members
	CVCNode* m_pNodeParent;
	CVCNode* m_pNodeNext;	// this node is a part of a singly-linked list

public:
	virtual BOOL IsZombie() { return (m_dispkeyItem == NULL); }

public:
  BOOL m_fDragDropMoved;
};

//-----------------------------------------------------------------------------
// class CVCWaitCursor
//-----------------------------------------------------------------------------
class CVCWaitCursor
{
public:
	CVCWaitCursor() {m_hPrevCur = ::SetCursor(m_hWaitCur);}
	~CVCWaitCursor() {::SetCursor(m_hPrevCur); }
	void Restore() {::SetCursor(m_hWaitCur);}

protected:
	HCURSOR m_hPrevCur;
	static HCURSOR m_hWaitCur;
};

#endif // !defined(AFX_VCNODE_H__1FAE18F3_9021_11D0_8D12_00A0C91BC942__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcpropobject.h ===
#pragma once

class CVCProjCfgProperties :
	public IDispatchImpl<VCProjectConfigurationProperties, &__uuidof(VCProjectConfigurationProperties), &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber, 0, CVsTypeInfoHolder>,
	public CComObjectRoot
{
public:
	CVCProjCfgProperties() {}
	virtual ~CVCProjCfgProperties() {}
	static HRESULT CreateInstance(VCConfiguration* pConfig, IDispatch** ppProjCfgProperties);

BEGIN_COM_MAP(CVCProjCfgProperties)
	COM_INTERFACE_ENTRY(VCProjectConfigurationProperties)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// VCProjectConfigurationProperties
public:
	STDMETHOD(get_OutputDirectory)(BSTR *Val);
	STDMETHOD(put_OutputDirectory)(BSTR newVal);
	STDMETHOD(get_IntermediateDirectory)(BSTR *Val);
	STDMETHOD(put_IntermediateDirectory)(BSTR newVal);
	STDMETHOD(get_ConfigurationType)(ConfigurationTypes* ConfigType);		// configuration type: application, DLL, etc.
	STDMETHOD(put_ConfigurationType)(ConfigurationTypes ConfigType);
	STDMETHOD(get_BuildBrowserInformation)(VARIANT_BOOL* Bsc);	// build .bsc file
	STDMETHOD(put_BuildBrowserInformation)(VARIANT_BOOL Bsc);
	STDMETHOD(get_UseOfMFC)(useOfMfc* useMfc);	// how are we using MFC?
	STDMETHOD(put_UseOfMFC)(useOfMfc useMfc);
	STDMETHOD(get_UseOfATL)(useOfATL* useATL);	// how are we using ATL?
	STDMETHOD(put_UseOfATL)(useOfATL useATL);
	STDMETHOD(get_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL* UseCRT);	// does the user want to link with the static or dynamic CRT?
	STDMETHOD(put_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL UseCRT);
	STDMETHOD(get_CharacterSet)(charSet* optSetting);	// character set to use: Unicode, MBCS, default
	STDMETHOD(put_CharacterSet)(charSet optSetting);
	STDMETHOD(get_ManagedExtensions)(VARIANT_BOOL* Managed);	// is this a managed C++ project?
	STDMETHOD(put_ManagedExtensions)(VARIANT_BOOL Managed);
	STDMETHOD(get_DeleteExtensionsOnClean)(BSTR* Ext);	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	STDMETHOD(put_DeleteExtensionsOnClean)(BSTR Ext);
	STDMETHOD(get_WholeProgramOptimization)(VARIANT_BOOL* Optimize);	// perform whole program optimization on build; more or less requires optimization turned on to be effective
	STDMETHOD(put_WholeProgramOptimization)(VARIANT_BOOL Optimize);
	STDMETHOD(get_Command)(BSTR *Val);
	STDMETHOD(put_Command)(BSTR newVal);
	STDMETHOD(get_WorkingDirectory)(BSTR *Val);
	STDMETHOD(put_WorkingDirectory)(BSTR newVal);
	STDMETHOD(get_CommandArguments)(BSTR *Val);
	STDMETHOD(put_CommandArguments)(BSTR newVal);
	STDMETHOD(get_Attach)(VARIANT_BOOL *Val);
	STDMETHOD(put_Attach)(VARIANT_BOOL newVal);
	STDMETHOD(get_Remote)(RemoteDebuggerType *Val);
	STDMETHOD(put_Remote)(RemoteDebuggerType newVal);
	STDMETHOD(get_RemoteMachine)(BSTR *Val);
	STDMETHOD(put_RemoteMachine)(BSTR newVal);
	STDMETHOD(get_DebuggerType)(TypeOfDebugger *Val);
	STDMETHOD(put_DebuggerType)(TypeOfDebugger newVal);
	STDMETHOD(get_RemoteCommand)(BSTR *Val);
	STDMETHOD(put_RemoteCommand)(BSTR newVal);
	STDMETHOD(get_HttpUrl)(BSTR *Val);
	STDMETHOD(put_HttpUrl)(BSTR newVal);
	STDMETHOD(get_PDBPath)(BSTR *Val);
	STDMETHOD(put_PDBPath)(BSTR NewVal);
	STDMETHOD(get_SQLDebugging)(VARIANT_BOOL *Val);
	STDMETHOD(put_SQLDebugging)(VARIANT_BOOL newVal);

protected:
	void Initialize(VCConfiguration* pConfig);

// data
protected:
	CComPtr<VCConfiguration> m_spConfig;
	CComQIPtr<VCDebugSettings> m_spDbgSettings;
};

class CVCFileCfgProperties :
	public IDispatchImpl<VCFileConfigurationProperties, &__uuidof(VCFileConfigurationProperties), &LIBID_VCProjectLibrary, PublicProjBuildTypeLibNumber, 0, CVsTypeInfoHolder>,
	public CComObjectRoot
{
public:
	CVCFileCfgProperties() {}
	virtual ~CVCFileCfgProperties() {}
	static HRESULT CreateInstance(VCFileConfiguration* pConfig, IDispatch** ppFileCfgProperties);

BEGIN_COM_MAP(CVCFileCfgProperties)
	COM_INTERFACE_ENTRY(VCFileConfigurationProperties)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// VCFileConfigurationProperties
public:
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL* ExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL ExcludedFromBuild);

protected:
	void Initialize(VCFileConfiguration* pConfig);

// data
protected:
	CComPtr<VCFileConfiguration> m_spConfig;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldactions.h ===
#pragma once

#include "FileRegistry.h"
#include "bldhelpers.h"
#include "ConfigRecords.h"
#include "BldTool.h"
#include "bldspawner.h"
#include "BldActions.h"

// classes in this header
class CBldAction;
class CBldActionSets;
class CBldActionList;
class CBldActionListHolder;

// other classes we need
class CBldIncludeEntryList;

// definition of the CBldActionList class
class CBldActionList : 
	public IVCBuildActionList,
	public CComObjectRoot,
	protected CVCPtrList
{
public:
	CBldActionList() : CVCPtrList(1) {}
	~CBldActionList() 
	{ 
		Clear(); 
	}
BEGIN_COM_MAP(CBldActionList)
	COM_INTERFACE_ENTRY(IVCBuildActionList)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CBldActionList) 

	static HRESULT CreateInstance(CBldActionList** ppActionList);
	static HRESULT CreateInstance(IVCBuildActionList** ppActionList);
	static HRESULT CreateInstance(CBldActionList** ppActionList, IVCBuildActionList** ppVCActionList);

// IVCBuildActionList
public:
	STDMETHOD(Find)(IVCToolImpl* pTool, IVCBuildAction** ppAction);
	STDMETHOD(FindByName)(BSTR bstrToolName, IVCBuildAction** ppAction);
	STDMETHOD(get_Count)(long * pceltFetched);
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum);
	STDMETHOD(Add)(IVCBuildAction* pAction);
	STDMETHOD(Next)(IVCBuildAction** ppAction, void** ppPos);
	STDMETHOD(Reset)(void** ppPos);
	STDMETHOD(RemoveAtPosition)(void* pPos);
	STDMETHOD(FreeOutputFiles)();
	STDMETHOD(get_Project)(VCProject** ppProject);
	STDMETHOD(get_LastAction)(IVCBuildAction** ppAction);
	STDMETHOD(get_ProjectConfigurationDependencies)(IVCBuildStringCollection** ppDependencies);	// dependencies of this action; i.e., libs, etc.
	STDMETHOD(get_ProjectConfigurationBuildOutputs)(IVCBuildStringCollection** ppOutputs);		// outputs of this action; i.e., foo.exe, foo.pdb, etc.
	STDMETHOD(RefreshOutputs)(long nPropID, IVCBuildErrorContext* pEC);
	STDMETHOD(HandlePossibleCommandLineOptionsChange)(IVCBuildErrorContext* pEC);

protected:	// IVCBuildActionList helpers
	VCPOSITION m_posEnumerator;

public:
	// find a tool and return the postion of the action
	VCPOSITION Find(CBldToolWrapper* pTool);
	void Clear(BOOL bDoRelease = TRUE);
	void AddToEnd(CBldAction* pAction, BOOL bDoAddRef = TRUE);
	void AddToEnd(CVCPtrList* pActionList, BOOL bDoAddRef = TRUE);
	void AddToEnd(CBldActionList* pActionList, BOOL bDoAddRef = TRUE);
	long Count() { return (long) GetCount(); }
	BOOL NotEmpty() { return GetCount() != 0; }
	VCPOSITION GetStart() { return GetHeadPosition(); }
	CBldAction* Next(VCPOSITION& pos) { return (CBldAction*)GetNext(pos); }
};

class CBldActionListHolder
{
public:
	CBldActionListHolder()
	{
		CBldActionList::CreateInstance(&m_pActions);
	}
	~CBldActionListHolder()
	{
		if (m_pActions)
		{
			IVCBuildActionList* pVCActions = (IVCBuildActionList*)m_pActions;
			pVCActions->Release();
		}
	}
	CBldActionList* m_pActions;
};

#include "DependencyGraph.h"

// state of an action 
typedef enum ActionState
{
	_SrcMissing,		// source missing for action
	_SrcOutOfDate,		// output out of date wrt sources
	_DepsOutOfDate,		// source out of date wrt deps
	_Current,			// output is current wrt to output and deps
	_Unknown			// unknown action state
};

// Scanned source dependency list state
#define DEPSTATE	CBldIncludeEntryList *
#define DEP_Empty	((DEPSTATE)NULL)	// empty deps
#define DEP_None	((DEPSTATE)-1)		// forced to have no deps

// type and stage of the action to be performed

// action stage
#define TOB_Pre		0x0				// perform pre-action processing
#define TOB_Stage	0x1				// perform the action type
#define TOB_Post	0x2				// perform post-action processing

class CBldAction : 
	public CBldFileRegNotifyRx,
	public IVCBuildAction,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CBldAction)
	COM_INTERFACE_ENTRY(IVCBuildAction)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CBldAction) 

	// Associate this action to a particular project item. This project item's
	// configuration reocrd will be accessed to retrieve configuration specific
	// action information.
	// Associate this action with a particular tool. It will access the CBuildToolWrapper's
	// methods in order to modify the action's build information.
	CBldAction();
	~CBldAction();
	static HRESULT CreateInstance(VCFileConfiguration* pFileCfg, CBldToolWrapper* pTool, 
		CBldCfgRecord* pcr, BOOL bIsProject, BOOL bNoFilter, IVCBuildAction** ppBldAction);

protected:
	void Initialize(VCFileConfiguration* pFileCfg, CBldToolWrapper* pTool, CBldCfgRecord* pcr, BOOL bNoFilter, BOOL bIsProject);

// IVCBuildAction
public:
	STDMETHOD(MatchesOldTool)(IVCToolImpl* pTool, BOOL* pbMatches);
	STDMETHOD(get_VCToolImpl)(IVCToolImpl** pVal);
	STDMETHOD(RefreshOutputs)(long nPropID, IVCBuildErrorContext* pEC);
	STDMETHOD(HandlePossibleCommandLineOptionsChange)(IVCBuildErrorContext* pEC);
	STDMETHOD(get_Project)(VCProject** ppProject);
	STDMETHOD(get_FileConfiguration)(VCFileConfiguration** ppFileCfg);
	STDMETHOD(get_ProjectConfiguration)(VCConfiguration** ppProjCfg);
	STDMETHOD(GetOutput)(IVCBuildErrorContext* pEC, void** ppFileRegSet);
	STDMETHOD(get_Registry)(void** ppFileRegistry);
	STDMETHOD(get_ItemFilePath)(BSTR* pbstrFilePath);
	STDMETHOD(get_Item)(IVCBuildableItem** ppItem);
	STDMETHOD(get_PropertyContainer)(IVCPropertyContainer** ppPropContainer);
	STDMETHOD(get_ThisPointer)(void** ppThis);
	STDMETHOD(get_IsTargetAction)(VARIANT_BOOL* pbIsTargetAction);
	STDMETHOD(InitSets)();	// new up the dependency set structures
	STDMETHOD(LateBind)(IVCBuildErrorContext* pEC);
	// Used for figuring out filenames controlled by option flags, e.g. /MAP:foo.map 
	// 'nPathId' is the path prop, may or may not return fullpath, might be dir. only
	// 'fIsDirectoryLocation' says whether to force the path prop as directory
	// 'bstrDefExtension' is the new extension to use
	// 'pDirBase' is the directory to re-base the filename in
	// 'bstrDefFilename' is the new filename (if none supplied from nPathId) (default is use filebase)
	// 'nEnablePropId' is the enabling prop., if FALSE then no output added
	// 'fWithAction' if TRUE will associate the output with an action in the graph
	STDMETHOD(AddOutputFromID)(long nPathId, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, BSTR bstrDirBase, 
		BSTR bstrDefFilename, long nEnablePropId, VARIANT_BOOL fWithAction, IVCToolImpl* pTool);
	STDMETHOD(AddOutputInSubDirectory)(BSTR bstrSubDirectory, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, BSTR bstrDirBase, 
		BSTR bstrDefFilename, long nEnablePropId, VARIANT_BOOL fWithAction, long nErrPropID, IVCToolImpl* pTool);
    STDMETHOD(AddOutputFromDirectory)(BSTR bstrDirBase, IVCBuildErrorContext* pEC, long nEnablePropId, BSTR bstrExt, 
		long nErrPropID, IVCToolImpl* pTool);
	STDMETHOD(AddOutputFromPath)(BSTR bstrPath, IVCBuildErrorContext* pEC, VARIANT_BOOL fWithAction, VARIANT_BOOL fAllowFilter, 
		long nPropID, IVCToolImpl* pTool);
	STDMETHOD(AddOutputFromFileName)(BSTR bstrFileName, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, BSTR bstrDirBase, 
		VARIANT_BOOL fWithAction, long nErrPropID, IVCToolImpl* pTool);
	STDMETHOD(get_SourceDependencies)(void** ppFileRegSet);
	STDMETHOD(get_ScannedDependencies)(void** ppFileRegSet);
	STDMETHOD(AddSourceDependencyFromString)(BSTR bstrDep, IVCBuildErrorContext* pEC);
	STDMETHOD(AddSourceDependencyFromFrh)(void* pFileRegHandle, IVCBuildErrorContext* pEC);
	STDMETHOD(RemoveSourceDependencyForFrh)(void* pFileRegHandle, IVCBuildErrorContext* pEC);
	STDMETHOD(ClearSourceDependencies)(IVCBuildErrorContext* pEC);
	STDMETHOD(AddScannedDependencyFromString)(BSTR bstrDep, IVCBuildErrorContext* pEC);
	STDMETHOD(AddScannedDependencyFromFrh)(void* pFileRegHandle, IVCBuildErrorContext* pEC);
	STDMETHOD(AddScannedDependencyOfType)(int type, BSTR bstrFile, int line, BOOL fScan, IVCBuildErrorContext* pEC);
	STDMETHOD(ClearScannedDependencies)(IVCBuildErrorContext* pEC);
	STDMETHOD(SetDependencyState)(enumDependencyState depState);
	STDMETHOD(MarkMissingDependencies)(BOOL bHaveMissing);
	STDMETHOD(GetRelativePathsToInputs)(BOOL bFilterOutSpecial, BOOL bUseMultiLine, IVCBuildErrorContext* pEC, BSTR *pVal);
	STDMETHOD(UpdateDependencyInformationTimeStamp)();
	STDMETHOD(get_Dependencies)(IVCBuildStringCollection** ppDependencies);	// dependencies of this action; i.e., libs, headers, etc.
	STDMETHOD(ScanToolDependencies)(IVCToolImpl* pTool, IVCBuildErrorContext* pEC, VARIANT_BOOL bWriteOutput);
	STDMETHOD(get_BuildOutputs)(IVCBuildStringCollection** ppOutputs);		// outputs of this action; i.e., foo.exe, foo.pdb, foo.obj, etc.
	STDMETHOD(GetFileNameForFileRegHandle)(void* pRegHandle, BSTR* pbstrFileName);
	STDMETHOD(GetFileRegHandleForFileName)(BSTR bstrFileName, void** ppRegHandle);
	STDMETHOD(ReleaseRegHandle)(void* pRegHandle);
	STDMETHOD(GetDeploymentDependencies)(IVCBuildStringCollection** ppDeployDeps);

public:
	// Binding and un-binding to tools
	void Bind(CBldToolWrapper * pTool, IVCBuildErrorContext* pEC = NULL, BOOL bNoFilter = FALSE);	// UnBind and LateBind are above under the COM stuff
	BOOL IsInitialized(){ return m_pdepgraph->IsInitialized(); };

	//
	// Assigning/unassigning of actions to project items (default is active config.)
	//
	static void AssignActions(CBldCfgRecord* pcr, VCFileConfiguration* pFileCfg, BOOL fAssignContained = TRUE, 
		BOOL fAssignContainedOnly = FALSE);
	static void UnAssignActions(CBldCfgRecord* pcr, VCFileConfiguration* pFileCfg, BOOL fUnassignContained = TRUE);

	static void IgnoreCachedOptions(BOOL bIgnore)  { s_bIgnoreCachedOptions = bIgnore; }
	static BOOL s_bIgnoreCachedOptions;

	// Assoc. target level action (iff we are not one ourselves)
	CBldAction* GetTargetAction();

	// 
	// Options at last perform etc.
	//
	__inline void DirtyCommand() {m_fDirtyCommand = TRUE;}

	// Retrieve and refresh the command-line options
	__inline BOOL GetCommandOptions(CStringW & strOptions) {strOptions = m_strOptions; return TRUE;}
	BOOL RefreshCommandOptions(BOOL & fChanged, BOOL fNoSet = FALSE);
	BOOL HaveMissingDeps() { return m_fDepMissing; }

	void MakeFilesDirty();
	void CalcFileAttributes(BOOL fOn = TRUE);

	//
	// Generate outputs
	//

	// Use when just a simple file reg. handle
	__inline HRESULT AddOutput(BldFileRegHandle frh, IVCBuildErrorContext* pEC, BOOL fWithAction = TRUE)
		{frh->AddFRHRef(); return AddOutputI(frh, pEC, fWithAction);}
	HRESULT FinishAddOutputFromID(CStringW& rstrFileName, IVCBuildErrorContext* pEC, BOOL fIsDirectoryLocation, 
		BSTR bstrDefExtension, CDirW& dirBase, BSTR bstrDefFilename, BOOL fWithAction, long nErrPropID, IVCToolImpl* pTool);

	static CComBSTR s_bstrDefVCFile;
	static LPCOLESTR s_szDefVCFile;

	// Used when path is already known
	HRESULT AddOutput(const CPathW* pPath, IVCBuildErrorContext* pEC, BOOL fWithAction = TRUE, BOOL fAllowFilter = TRUE, 
		long nPropID = -1, IVCToolImpl* pTool = NULL);
	HRESULT AddOutputFromFileName(CStringW& rstrFileName, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, CDirW* pDirBase, 
		BOOL fWithAction, BOOL fMakeItRelativeToProject, long nErrPropID, IVCToolImpl* pTool);


	// retrieve our 'actual' input(s)
	CBldFileRegSet * GetInput(IVCBuildErrorContext* pEC);
	__inline void DirtyInput(BOOL fDirty = TRUE) {m_fDirtyInput = fDirty;}
	void ClearInput();

	// retrieve our list of outputs (list of file registry handles)
	CBldFileRegSet * GetOutput(IVCBuildErrorContext* pEC);
	CVCWordArray * GetOutputAttrib();
	__inline void DirtyOutput(BOOL fDirty = TRUE) {m_fDirtyOutput = fDirty;}
	void ClearOutput(IVCBuildErrorContext* pEC);

	__inline CBldToolWrapper* BuildToolWrapper()	{ return m_pTool; }

protected:
	void FindDeletions(CBldFileRegSet& Deletions, IVCBuildErrorContext* pEC);
	void HandleDeletions(CBldFileRegSet& Deletions, IVCBuildErrorContext* pEC);

	//
	// Scanned dependencies
	//
public:
	__inline CBldIncludeEntryList * GetIncludeDep() {return m_pIncludeList;}
	BOOL ScanDependencies(IVCBuildErrorContext* pEC, BOOL bUseAnyMethod = FALSE, BOOL bWriteOutput = TRUE);

	CBldFileRegSet * GetScannedDep();
	__inline void ClearScannedDep(IVCBuildErrorContext* pEC = NULL) {ClearDepI(DEP_Scanned, pEC);}

	// add scanned dependency (unresolved)
	BOOL AddScannedDep(int type, IVCBuildErrorContext* pEC, CStringW & strFile, int nLine = 0, BOOL fScan = TRUE);

	// add/remove scanned dependency (resolved)
	__inline BOOL AddScannedDep(CStringW & strFile, IVCBuildErrorContext* pEC) {return AddDepI(DEP_Scanned, strFile, pEC);}
	__inline BOOL AddScannedDep(BldFileRegHandle frhDep, IVCBuildErrorContext* pEC) {return AddDepI(DEP_Scanned, frhDep, pEC);}

	//
	// Source dependencies
	//
	CBldFileRegSet * GetSourceDep();
	__inline void ClearSourceDep(IVCBuildErrorContext* pEC = NULL) {ClearDepI(DEP_Source, pEC);}

	// add/remove source dependency
 	__inline BOOL AddSourceDep(CStringW & strFile, IVCBuildErrorContext* pEC) {return AddDepI(DEP_Source, strFile, pEC);}
	__inline BOOL AddSourceDep(BldFileRegHandle frhDep, IVCBuildErrorContext* pEC) {return AddDepI(DEP_Source, frhDep, pEC);}
	__inline BOOL RemoveSourceDep(BldFileRegHandle frhDep, IVCBuildErrorContext* pEC) {return RemoveDepI(DEP_Source, frhDep, pEC);}

	__inline void SetDepState(DEPSTATE stateDep)
		{m_pIncludeList = stateDep;}

	//
	// Notification of input changing
	//
 
	// Rx for file change events
	virtual void OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint);

	// Batched notification?
	__inline void BatchNotify(BOOL fBatch) {m_fBatchNotify = fBatch;}

	// FUTURE: make private (currently used to Refresh() etc.)
	// Internal helper to set tool
	void SetToolI(CBldToolWrapper* pTool, BOOL bNoFilter = FALSE);

	BOOL IsProject() { return (m_fIsProject != 0); }

protected:
	void LoadDepArray(CBldFileRegSet* pDeps, CVCStringWArray& rstrDepsArray);
	HRESULT GetBuildEngineImplFromEC(IVCBuildErrorContext* pEC, IVCBuildEngineImpl** ppBldEngineImpl);
	void UnBind();

// some nice helpers
public:
	static HRESULT GetFileCollection(VCConfiguration* pProjCfg, IEnumVARIANT** ppFiles);
	static BOOL GetFileCfgForProjCfg(CComVariant& var, VCConfiguration* pProjCfg, VCFileConfiguration** ppFileCfg);
	static BOOL GetFileCfgActions(VCFileConfiguration* pFileCfg, IVCBuildActionList** ppActions);
	static void InformUserAboutBadFileName(IVCBuildErrorContext* pEC, IVCPropertyContainer* pPropContainer, IVCToolImpl* pTool, 
		long nErrPropID, CStringW& strFile);

private:
	static void BindSingleAction(CBldConfigurationHolder& cfgHolder);
	static void UnBindSingleAction(CBldConfigurationHolder& cfgHolder);
	static void AssignSingleAction(CBldConfigurationHolder& cfgHolder);
	static void UnAssignSingleAction(CBldConfigurationHolder& cfgHolder);

public:
	// Current action mark to use
	static WORD m_wActionMarker;

	// Associated project cfg(s) and tool (+ tool user-data)
	CBldCfgRecord* m_pcrOur;
	IVCBuildableItem* m_pItem;	// intentionally not ref-conted; should have same or lesser lifetime than associated item
	CBldToolWrapper* m_pTool;
	CBldToolWrapper* m_pOldTool;

	// Build process information
	CBldFileRegistry* m_pregistry;	// registry our build files are in
	CBldFileDepGraph* m_pdepgraph;	// build process graph

	// Used as mark during dep. graph analysis and build process
	WORD m_wMark;

	// Used during command-options refresh
	WORD m_wMarkRefCmdOpt;

	// Input file or files (filter) 'possibly' consumed by this action
	BldFileRegHandle m_frhInput;

	//  All bitfields are intentionally placed here to get best packing

	BOOL m_fPossibleOptionChange:1;
	// Used during command-options refresh
	BOOL m_fCmdOptChanged:1;
	// Used during input dep generation
	BOOL m_fDepMissing:1;

private:
	BOOL m_fDirtyInput:1;	// Dirty input?
	BOOL m_fDirtyOutput:1;	// Dirty output?
	BOOL m_fDirtyCommand:1;	// Dirty command-line?
	BOOL m_fBatchNotify:1;	// Batched input/output notify? .. ignore if TRUE
	BOOL m_fInGenOutput:1;	// Updating output?
	BOOL m_fIsProject:1;	// is this a project?

	CBldAction* m_pTrgAction;	// Assoc. target level action (iff we are not one ourselves)

	CStringW m_strOptions;

	CBldActionSets* m_pSets;

//REVIEW : good candidates for the CAction Sets class
	// Attributes of the output
	// Currently non-zero == 'has action', zero == 'no action'
	CVCWordArray* m_paryOldOutputAttrib;

	// Scanned dependencies
	CBldIncludeEntryList* m_pIncludeList;		// unresolved

	//
	// Time of last dependency update on this CBldAction.
	// Zero if uninitialized.
	//
	FILETIME m_LastDepUpdate;

private:
	static int s_nMyMarker;

public:
	//
	// Update dependency stuff.
	//
	BOOL IsDepInfoInitialized();
	BOOL IsNewDepInfoAvailable(IVCBuildErrorContext* pEC);

	//
	// Update dependency information if new information is available.
	// Set bForceUpdate = TRUE to force update if updating has been turned off
	// minimal rebuild info is not available.
	BOOL UpdateDepInfo(IVCBuildErrorContext* pEC, BOOL bForceUpdate = FALSE);

	void UpdateDepInfoTimeStamp();
private:
	static BOOL IsBuildableConfiguration(IVCConfigurationImpl* pProjCfgImpl);
	static BOOL IsValidConfiguration(IVCConfigurationImpl* pProjCfgImpl);
	BOOL GetStringProperty(long nPropID, CStringW& rstrValue, BOOL bEvaluate = FALSE);
	void GetItemFileName(CStringW& rstrName);

	// Internal dependency
	void ClearDepI(UINT depType, IVCBuildErrorContext* pEC);
	BOOL AddDepI(UINT depType, CStringW & strFile, IVCBuildErrorContext* pEC);
	BOOL AddDepI(UINT depType, BldFileRegHandle frh, IVCBuildErrorContext* pEC);
	BOOL RemoveDepI(UINT depType, BldFileRegHandle frh, IVCBuildErrorContext* pEC);

	// Internal input/output refreshers
	void RefreshOutputI(IVCBuildErrorContext* pEC);

	// Internal add output (assumes ref. count is correct)
	HRESULT AddOutputI(BldFileRegHandle frh, IVCBuildErrorContext* pEC, BOOL fWithAction = TRUE);
	BOOL EnabledOutput(long nEnablePropId);

	// Add and remove the input (helpers)
	void AddInput(BOOL bNoFilter = FALSE);
	void RemoveInput();
	
	// Valid input file? ie. no in the output
	BOOL ValidInput(BldFileRegHandle frh);
};


class CBldActionSets
{
public:
	CBldActionSets(CBldAction *pAction): m_frsInput(37), m_frsOutput(7), m_frsSchmoozableOutput(7)
	{
		// set up our input and output to use this target registry
		m_frsSchmoozableOutput.SetFileRegistry(pAction->m_pregistry);
		// FUTURE: For now we don't care about the incr. update
		// of input and output properties, eg. timestamp, exist on disk etc.

		// This was the review comment but I don't really understand these sets
		// completely and there is no way in hell I am changing anything about this
		// two days before building the release candidate. I am changing this to FUTURE
		// and we should understand this review comment and fix if necessary for 4.1
		m_frsInput.CalcAttributes(FALSE);
		m_frsOutput.CalcAttributes(FALSE);
		m_frsSchmoozableOutput.CalcAttributes(FALSE);
	}

	void MakeFilesDirty(CBldFileRegistry* pRegistry)
	{
		m_frsInput.MakeContentsDirty(pRegistry);
		m_frsOutput.MakeContentsDirty(pRegistry);
		m_frsSchmoozableOutput.MakeContentsDirty(pRegistry);
		m_frsScannedDep.MakeContentsDirty(pRegistry);
		m_frsSourceDep.MakeContentsDirty(pRegistry);
	}

	void CalcFileAttributes(BOOL fOn = TRUE)
	{
		m_frsInput.CalcAttributes(fOn);
		m_frsOutput.CalcAttributes(fOn);
		m_frsSchmoozableOutput.CalcAttributes(fOn);
		m_frsScannedDep.CalcAttributes(fOn);
		m_frsSourceDep.CalcAttributes(fOn);
	}

	// one bit per output (IsPrimary ?) 
	CVCWordArray m_aryOutputAttrib;
	
	// Temp. 'actual' input file set
	CBldFileRegSet m_frsInput;

	// Output files generated by this action
	CBldFileRegSet m_frsOutput;

	// Output files that can be used as input to schmooze tools.
	CBldFileRegSet m_frsSchmoozableOutput;

	CBldFileRegSet *m_pfrsOldOutput;

	CBldFileRegSet m_frsScannedDep;			// resolved (in the graph...)

	// Source dependencies
	CBldFileRegSet m_frsSourceDep;			// resolved (in the graph...)
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldeventtool.cpp ===
#include "stdafx.h"
#include "BldEventTool.h"

// static initializers
CComBSTR CVCPreBuildEventTool::s_bstrDescription = L"";
GUID CVCPreBuildEventTool::s_pPages[1];
BOOL CVCPreBuildEventTool::s_bPagesInit;
CComBSTR CVCPreBuildEventTool::s_bstrToolName = L"";
CComBSTR CVCPreBuildEventTool::s_bstrExtensions = L"";

CComBSTR CVCPreLinkEventTool::s_bstrDescription = L"";
GUID CVCPreLinkEventTool::s_pPages[1];
BOOL CVCPreLinkEventTool::s_bPagesInit;
CComBSTR CVCPreLinkEventTool::s_bstrToolName = L"";
CComBSTR CVCPreLinkEventTool::s_bstrExtensions = L"";

CComBSTR CVCPostBuildEventTool::s_bstrDescription = L"";
GUID CVCPostBuildEventTool::s_pPages[1];
BOOL CVCPostBuildEventTool::s_bPagesInit;
CComBSTR CVCPostBuildEventTool::s_bstrToolName = L"";
CComBSTR CVCPostBuildEventTool::s_bstrExtensions = L"";

HRESULT CVCPreBuildEventTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool)
{
	CHECK_POINTER_NULL(ppTool);
	*ppTool = NULL;

	CComObject<CVCPreBuildEventTool> *pObj;
	HRESULT hr = CComObject<CVCPreBuildEventTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCPreBuildEventTool *pVar = pObj;
		pVar->AddRef();
		*ppTool = pVar;
	}
	return hr;
}

HRESULT CVCPreLinkEventTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool)
{
	CHECK_POINTER_NULL(ppTool);
	*ppTool = NULL;

	CComObject<CVCPreLinkEventTool> *pObj;
	HRESULT hr = CComObject<CVCPreLinkEventTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCPreLinkEventTool *pVar = pObj;
		pVar->AddRef();
		*ppTool = pVar;
	}
	return hr;
}

HRESULT CVCPostBuildEventTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool)
{
	CHECK_POINTER_NULL(ppTool);
	*ppTool = NULL;

	CComObject<CVCPostBuildEventTool> *pObj;
	HRESULT hr = CComObject<CVCPostBuildEventTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCPostBuildEventTool *pVar = pObj;
		pVar->AddRef();
		*ppTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCPreBuildEventPage::get_CommandLine(BSTR *pVal)
{
	HRESULT hr = S_OK;
	CStringW str;
	if(GetTruncatedStringForProperty(PREBLDID_CommandLine, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	else
	{
		hr = GetStrProperty(PREBLDID_CommandLine, pVal);
		if (hr == S_FALSE)
			GetDefaultValue( PREBLDID_CommandLine, pVal );
	}
	return hr;
}

STDMETHODIMP CVCPreBuildEventPage::put_CommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(PREBLDID_CommandLine, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCPreBuildEventPage::get_Description(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(PREBLDID_Description, pVal);
	if (hr == S_FALSE)
		GetDefaultValue( PREBLDID_Description, pVal );
	return hr;
}

STDMETHODIMP CVCPreBuildEventPage::put_Description(BSTR newVal)
{
	return SetStrProperty(PREBLDID_Description, newVal);
}

STDMETHODIMP CVCPreBuildEventPage::get_ExcludedFromBuild(enumBOOL* pbExcludedFromBuild)
{
	return GetEnumBoolProperty(PREBLDID_ExcludedFromBuild, pbExcludedFromBuild);
}

STDMETHODIMP CVCPreBuildEventPage::put_ExcludedFromBuild(enumBOOL bExcludedFromBuild)
{
	return SetBoolProperty(PREBLDID_ExcludedFromBuild, bExcludedFromBuild);
}

void CVCPreBuildEventPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == PREBLDID_Description)
	{
		CComBSTR bstrVal;
		GetDefaultValue( PREBLDID_Description, &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

STDMETHODIMP CVCPreLinkEventPage::get_CommandLine(BSTR *pVal)
{
	HRESULT hr = S_OK;
	CStringW str;
	if(GetTruncatedStringForProperty(PRELINKID_CommandLine, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	else
	{
		hr = GetStrProperty(PRELINKID_CommandLine, pVal);
		if (hr == S_FALSE)
			GetDefaultValue( PRELINKID_CommandLine, pVal );
	}
	return hr;
}

STDMETHODIMP CVCPreLinkEventPage::put_CommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(PRELINKID_CommandLine, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCPreLinkEventPage::get_Description(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(PRELINKID_Description, pVal);
	if (hr == S_FALSE)
		GetDefaultValue( PRELINKID_Description, pVal );
	return hr;
}

STDMETHODIMP CVCPreLinkEventPage::put_Description(BSTR newVal)
{
	return SetStrProperty(PRELINKID_Description, newVal);
}

STDMETHODIMP CVCPreLinkEventPage::get_ExcludedFromBuild(enumBOOL* pbExcludedFromBuild)
{
	return GetEnumBoolProperty(PRELINKID_ExcludedFromBuild, pbExcludedFromBuild);
}

STDMETHODIMP CVCPreLinkEventPage::put_ExcludedFromBuild(enumBOOL bExcludedFromBuild)
{
	return SetBoolProperty(PRELINKID_ExcludedFromBuild, bExcludedFromBuild);
}

void CVCPreLinkEventPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == PRELINKID_Description)
	{
		CComBSTR bstrVal;
		GetDefaultValue( PRELINKID_Description, &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

STDMETHODIMP CVCPostBuildEventPage::get_CommandLine(BSTR *pVal)
{
	HRESULT hr = S_OK;
	CStringW str;
	if(GetTruncatedStringForProperty(POSTBLDID_CommandLine, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	else
	{
		hr = GetStrProperty(POSTBLDID_CommandLine, pVal);
		if (hr == S_FALSE)
			GetDefaultValue( POSTBLDID_CommandLine, pVal );
	}
	return hr;
}

STDMETHODIMP CVCPostBuildEventPage::put_CommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(POSTBLDID_CommandLine, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCPostBuildEventPage::get_Description(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(POSTBLDID_Description, pVal);
	if (hr == S_FALSE)
		GetDefaultValue( POSTBLDID_Description, pVal );
	return hr;
}

STDMETHODIMP CVCPostBuildEventPage::put_Description(BSTR newVal)
{
	return SetStrProperty(POSTBLDID_Description, newVal);
}

STDMETHODIMP CVCPostBuildEventPage::get_ExcludedFromBuild(enumBOOL* pbExcludedFromBuild)
{
	return GetEnumBoolProperty(POSTBLDID_ExcludedFromBuild, pbExcludedFromBuild);
}

STDMETHODIMP CVCPostBuildEventPage::put_ExcludedFromBuild(enumBOOL bExcludedFromBuild)
{
	return SetBoolProperty(POSTBLDID_ExcludedFromBuild, bExcludedFromBuild);
}

void CVCPostBuildEventPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == POSTBLDID_Description)
	{
		CComBSTR bstrVal;
		GetDefaultValue( POSTBLDID_Description, &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldactions.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "BuildEngine.h"
#include "msgboxes2.h"
#include "scanner.h"

HRESULT CBldActionList::CreateInstance(CBldActionList **ppBldActionList)
{
	return CreateInstance(ppBldActionList, NULL);
}

HRESULT CBldActionList::CreateInstance(IVCBuildActionList **ppBldActionList)
{
	return CreateInstance(NULL, ppBldActionList);
}

HRESULT CBldActionList::CreateInstance(CBldActionList **ppBldActionList, IVCBuildActionList **ppVCBldActionList)
{
	if (ppBldActionList == NULL && ppVCBldActionList == NULL)
		RETURN_INVALID();
	
	if (ppBldActionList)
		*ppBldActionList = NULL;
	if (ppVCBldActionList)
		*ppVCBldActionList = NULL;

	HRESULT hr;
	CBldActionList *pVar;
	CComObject<CBldActionList> *pObj;
	hr = CComObject<CBldActionList>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		if (ppBldActionList)
			*ppBldActionList = pObj;
		if (ppVCBldActionList)
			*ppVCBldActionList = pVar;
	}
	return hr;
}

// gets the next celt elements; cookie is optional
STDMETHODIMP CBldActionList::Next(IVCBuildAction** ppAction, void** ppPos)
{
	long lMax = (long) GetCount();
	HRESULT hr = S_FALSE;

	if (lMax > 0 && m_posEnumerator != NULL)
	{
		VCPOSITION oldPos = m_posEnumerator;
		CBldAction* pAction = (CBldAction*)GetNext(m_posEnumerator);
		*ppAction = (IVCBuildAction *)(pAction);
		if (*ppAction)
			(*ppAction)->AddRef();
		if (ppPos != NULL)
			*ppPos = (void *)oldPos;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CBldActionList::get_Count(long* pceltFetched)
{
	CHECK_POINTER_NULL(pceltFetched);
	*pceltFetched = (long) GetCount();
	return S_OK;
}

// reset the enumeration
STDMETHODIMP CBldActionList::Reset(void** ppPos)
{
	m_posEnumerator = GetHeadPosition();
	if (ppPos != NULL)
		*ppPos = (void *)m_posEnumerator;
	return S_OK;
}

// clone the enumerator
STDMETHODIMP CBldActionList::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
	return E_NOTIMPL; // don't have capability for clone and don't expect to, either
}

// Try to find a tool in an action in our list
STDMETHODIMP CBldActionList::Find(IVCToolImpl *pTool, IVCBuildAction **ppBldAction)
{
	VCPOSITION pos = GetHeadPosition();
	CStringW strToolName;
	while (pos != (VCPOSITION)NULL)
	{
		VCPOSITION posCurr = pos;
		CBldAction* pAction = (CBldAction *)GetNext(pos);
		if (strToolName.IsEmpty() && pAction->BuildToolWrapper())
			pAction->BuildToolWrapper()->GetToolName(pTool, strToolName);
		if ((pAction->BuildToolWrapper() && pAction->BuildToolWrapper()->SameToolType(strToolName)) ||
			(pAction->BuildToolWrapper() == NULL && pTool == NULL))
		{
			if (ppBldAction)
			{
				IVCBuildAction* pVCAction = (IVCBuildAction*)pAction;
				pVCAction->AddRef();
				*ppBldAction = pVCAction;
			}
			return S_OK;
		}
	}

	return S_FALSE;
}

STDMETHODIMP CBldActionList::FindByName(BSTR bstrName, IVCBuildAction** ppBldAction)
{
	CStringW strToolName = bstrName;

	VCPOSITION pos = GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		VCPOSITION posCurr = pos;
		CBldAction* pAction = (CBldAction *)GetNext(pos);
		if ((pAction->BuildToolWrapper() && pAction->BuildToolWrapper()->SameToolType(strToolName)) ||
			(pAction->BuildToolWrapper() == NULL && strToolName.IsEmpty()))
		{
			if (ppBldAction)
			{
				IVCBuildAction* pVCAction = (IVCBuildAction*)pAction;
				pVCAction->AddRef();
				*ppBldAction = pVCAction;
			}
			return S_OK;
		}
	}

	return S_FALSE;
}

STDMETHODIMP CBldActionList::get_LastAction(IVCBuildAction** ppAction)
{
	CHECK_POINTER_NULL(ppAction);
	*ppAction = NULL;

	CBldAction* pBldAction = (CBldAction *)GetTail();
	if (pBldAction)
	{
		*ppAction = pBldAction;
		(*ppAction)->AddRef();
	}

	return (*ppAction != NULL) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldActionList::get_ProjectConfigurationDependencies(IVCBuildStringCollection** ppDependencies)	// dependencies of this action i.e., libs, etc.
{
	CHECK_POINTER_NULL(ppDependencies);
	*ppDependencies = NULL;

	Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = Next(&spAction, NULL);
		if (hr != S_OK)
			break;
		CONTINUE_ON_NULL(spAction);
		VARIANT_BOOL bIsTargetAction = VARIANT_FALSE;
		hr = spAction->get_IsTargetAction(&bIsTargetAction);
		CONTINUE_ON_FAIL(hr);
		if (bIsTargetAction == VARIANT_TRUE)
		{
			CComPtr<IVCToolImpl> spToolImpl;
			spAction->get_VCToolImpl(&spToolImpl);
			if (spToolImpl != NULL)
			{
				VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
				spToolImpl->HasPrimaryOutputFromTool(NULL, VARIANT_TRUE, &bHasPrimaryOutput);
				if (bHasPrimaryOutput == VARIANT_TRUE)
					return spAction->get_Dependencies(ppDependencies);
			}
		}
	}

	return S_FALSE;
}

STDMETHODIMP CBldActionList::get_ProjectConfigurationBuildOutputs(IVCBuildStringCollection** ppOutputs)		// outputs of this action i.e., foo.exe, foo.pdb, etc.
{
	CHECK_POINTER_NULL(ppOutputs);
	*ppOutputs = NULL;

	Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = Next(&spAction, NULL);
		if (hr != S_OK)
			break;
		CONTINUE_ON_NULL(spAction);
		VARIANT_BOOL bIsTargetAction = VARIANT_FALSE;
		hr = spAction->get_IsTargetAction(&bIsTargetAction);
		CONTINUE_ON_FAIL(hr);
		if (bIsTargetAction == VARIANT_TRUE)
		{
			CComPtr<IVCToolImpl> spToolImpl;
			spAction->get_VCToolImpl(&spToolImpl);
			if (spToolImpl != NULL)
			{
				VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
				spToolImpl->HasPrimaryOutputFromTool(NULL, VARIANT_TRUE, &bHasPrimaryOutput);
				if (bHasPrimaryOutput == VARIANT_TRUE)
					return spAction->get_BuildOutputs(ppOutputs);
			}
		}
	}

	return S_FALSE;
}

STDMETHODIMP CBldActionList::RefreshOutputs(long nPropID, IVCBuildErrorContext* pEC)
{
	HRESULT hrFinal = S_FALSE;
	Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = Next(&spAction, NULL);
		if (hr != S_OK)
			break;
		CONTINUE_ON_NULL(spAction);
		if (spAction->RefreshOutputs(nPropID, pEC) == S_OK)
			hrFinal = S_OK;
	}

	return hrFinal;
}

STDMETHODIMP CBldActionList::HandlePossibleCommandLineOptionsChange(IVCBuildErrorContext* pEC)
{
	HRESULT hrFinal = S_FALSE;
	Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = Next(&spAction, NULL);
		if (hr != S_OK)
			break;
		CONTINUE_ON_NULL(spAction);
		if (spAction->HandlePossibleCommandLineOptionsChange(pEC) == S_OK)
			hrFinal = S_OK;
	}

	return hrFinal;
}

// Try to find a tool in an action in our list
VCPOSITION CBldActionList::Find(CBldToolWrapper* pTool)
{
	VCPOSITION pos = GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		VCPOSITION posCurr = pos;
		CBldAction* pAction = (CBldAction *)GetNext(pos);
		if (pTool == pAction->BuildToolWrapper())
			return posCurr;
	}

	return (VCPOSITION)NULL;
}

STDMETHODIMP CBldActionList::Add(IVCBuildAction *pVCAction)
{
	CHECK_POINTER_NULL(pVCAction);

	CBldAction* pAction = NULL;
	pVCAction->get_ThisPointer((void **)&pAction);
	VSASSERT(pAction != NULL, "Attempting to add NULL or bad object to action list.");
	RETURN_ON_NULL2(pAction, E_OUTOFMEMORY);

	pVCAction->AddRef();
	AddTail(pAction);
	return S_OK;
}

STDMETHODIMP CBldActionList::RemoveAtPosition(void* pPos)
{
	VCPOSITION pos = (VCPOSITION)pPos;
	RETURN_ON_NULL2(pos, S_FALSE);

	CBldAction* pAction = (CBldAction *)GetAt(pos);
	if (pAction != NULL)
	{
		IVCBuildAction* pVCAction = pAction;
		pVCAction->Release();
	}
	RemoveAt(pos);

	return S_OK;
}

STDMETHODIMP CBldActionList::FreeOutputFiles()
{
	return E_NOTIMPL;	// CBldActionList::FreeOutputFiles -- possible optimization point
}

STDMETHODIMP CBldActionList::get_Project(VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;
	if (IsEmpty())
		return S_FALSE;

	VCPOSITION pos = GetHeadPosition();
	CBldAction* pAction = (CBldAction *)GetNext(pos);
	if (pAction == NULL)
	{
		VSASSERT(FALSE, "Unexpected action in action list");
		return E_UNEXPECTED;
	}

	return pAction->get_Project(ppProject);
}

void CBldActionList::Clear(BOOL bDoRelease /* = TRUE */)
{
	while (!IsEmpty())
	{
		CBldAction* pAction = (CBldAction*)RemoveHead();
		if (pAction != NULL && bDoRelease)
		{
			IVCBuildAction* pVCAction = (IVCBuildAction*)pAction;
			pVCAction->Release();
		}
	}
}

void CBldActionList::AddToEnd(CBldAction* pAction, BOOL bDoAddRef /* = TRUE */)
{
	if (pAction == NULL)
		return;

	if (bDoAddRef)
	{
		IVCBuildAction* pVCAction = (IVCBuildAction *)pAction;
		pVCAction->AddRef();
	}
	AddTail(pAction);
}

void CBldActionList::AddToEnd(CVCPtrList* pActions, BOOL bDoAddRef /* = TRUE */)
{
	if (pActions == NULL)
		return;

	VCPOSITION pos = pActions->GetHeadPosition();
	while (pos != NULL)
	{
		CBldAction* pAction = (CBldAction *)pActions->GetNext(pos);
		AddToEnd(pAction, bDoAddRef);
	}
}

void CBldActionList::AddToEnd(CBldActionList* pActions, BOOL bDoAddRef /* = TRUE */)
{
	if (pActions == NULL)
		return;

	VCPOSITION pos = pActions->GetHeadPosition();
	while (pos != NULL)
	{
		CBldAction* pAction = (CBldAction *)pActions->GetNext(pos);
		AddToEnd(pAction, bDoAddRef);
	}
}

CComBSTR CBldAction::s_bstrDefVCFile = L"vc70";
LPCOLESTR CBldAction::s_szDefVCFile = L"vc70";

// our action marker
WORD CBldAction::m_wActionMarker = 0;
BOOL CBldAction::s_bIgnoreCachedOptions = TRUE;
int CBldAction::s_nMyMarker = 0;


CBldAction::CBldAction()
{
	// default
	m_pIncludeList = (CBldIncludeEntryList *)NULL;
	m_fBatchNotify = m_fInGenOutput = FALSE;
	m_wMark = 0; 
	m_pSets = NULL;

	m_pTool = m_pOldTool = (CBldToolWrapper *)NULL;
	m_pTrgAction = (CBldAction *)NULL;
	m_frhInput = (BldFileRegHandle)NULL;
	m_pcrOur = NULL;

	// assume that our settings are ok, but dirty
	m_fDirtyCommand = TRUE;
	m_fPossibleOptionChange = FALSE;
	m_fCmdOptChanged = FALSE;
	m_fDepMissing = FALSE;

	m_wMarkRefCmdOpt = 0;

	m_LastDepUpdate.dwLowDateTime = 0;
	m_LastDepUpdate.dwHighDateTime = 0;
}

void CBldAction::Initialize(VCFileConfiguration* pFileCfg, CBldToolWrapper* pTool, CBldCfgRecord* pcr, 
	BOOL fIsProject, BOOL bNoFilter)
{
	// associate
	m_pcrOur = pcr;
	VSASSERT(m_pcrOur != NULL, "Must specify CfgRecord for an action");
	m_fIsProject = fIsProject;

	CComQIPtr<IVCBuildableItem> spItem;
	if (pFileCfg)
		spItem = pFileCfg;
	else 
		spItem = pcr->GetVCConfiguration();
	m_pItem = spItem.Detach();	
	m_pItem->Release(); // yes, intentionally dropping ref-count to be zero change from when we came in

	// registry & dep.graph??
	m_pregistry = g_StaticBuildEngine.GetRegistry(m_pcrOur);
	m_pdepgraph = g_StaticBuildEngine.GetDepGraph(m_pcrOur);

	// bind to our tool?
	if (pTool != (CBldToolWrapper *)NULL)
		Bind(pTool, NULL, bNoFilter);
}

HRESULT CBldAction::CreateInstance(VCFileConfiguration* pFileCfg, CBldToolWrapper* pTool, 
	CBldCfgRecord* pcr, BOOL bIsProject, BOOL bNoFilter, IVCBuildAction** ppBldAction)
{
	CHECK_POINTER_NULL(ppBldAction);
	*ppBldAction = NULL;

	CComObject<CBldAction> *pObj;
	HRESULT hr = CComObject<CBldAction>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		CBldAction *pVar = pObj;
		pVar->AddRef();
		*ppBldAction = pVar;
		pObj->Initialize(pFileCfg, pTool, pcr, bIsProject, bNoFilter);
	}
	return hr;
}

CBldAction::~CBldAction()
{
	// clean up our source, missing and scanned deps.
	ClearSourceDep();
	ClearScannedDep();

	// unbind from the tool?
	if (m_pTool != (CBldToolWrapper *)NULL)
	{
		// remember if we had a tool so we can use this info. after UnBind()
		CBldToolWrapper* pTool = m_pTool;
		UnBind();
	}
	if (m_pSets)
		delete m_pSets;
}

STDMETHODIMP CBldAction::MatchesOldTool(IVCToolImpl *pTool, BOOL *pbMatches)
{
	CHECK_POINTER_NULL(pbMatches);
	if (pTool == NULL && m_pTool == NULL)
		*pbMatches = TRUE;
	else if (pTool == NULL || m_pTool == NULL)
		*pbMatches = FALSE;
	else
		*pbMatches = m_pTool->SameToolType(pTool);

	return S_OK;
}

STDMETHODIMP CBldAction::get_VCToolImpl(IVCToolImpl **pVal)
{
	CHECK_POINTER_NULL(pVal);

	if (m_pTool == NULL)
		*pVal = NULL;
	else
	{
		*pVal = m_pTool->GetVCToolImpl();
		(*pVal)->AddRef();
	}
	return S_OK;
}

STDMETHODIMP CBldAction::get_Project(VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);

	VSASSERT(m_pcrOur != NULL, "Action was not initialized correctly; missing CfgRecord pointer");
	CHECK_ZOMBIE(m_pcrOur, IDS_ERR_CFG_ZOMBIE);

	VCConfiguration* pProjCfg = m_pcrOur->GetVCConfiguration();
	CHECK_ZOMBIE(pProjCfg, IDS_ERR_CFG_ZOMBIE);

	CComPtr<IDispatch> pDispProject;
	HRESULT hr = pProjCfg->get_Project(&pDispProject);
	CComQIPtr<VCProject> spProject = pDispProject;
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(spProject, IDS_ERR_CFG_ZOMBIE);

	spProject.CopyTo(ppProject);
	return S_OK;
}

STDMETHODIMP CBldAction::get_FileConfiguration(VCFileConfiguration** ppFileCfg)
{
	CHECK_POINTER_NULL(ppFileCfg);
	*ppFileCfg = NULL;

	m_pItem->QueryInterface(__uuidof(VCFileConfiguration), (LPVOID *)ppFileCfg);
	return ((*ppFileCfg) != NULL) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldAction::get_ProjectConfiguration(VCConfiguration** ppProjCfg)
{
	CHECK_POINTER_NULL(ppProjCfg);

	VSASSERT(m_pcrOur != NULL, "Action was not initialized correctly; missing CfgRecord pointer");
	CHECK_ZOMBIE(m_pcrOur, IDS_ERR_CFG_ZOMBIE);

	*ppProjCfg = m_pcrOur->GetVCConfiguration();
	(*ppProjCfg)->AddRef();
	return S_OK;
}

STDMETHODIMP CBldAction::get_ItemFilePath(BSTR* pbstrFilePath)
{
	CHECK_POINTER_NULL(pbstrFilePath);
	return m_pItem->get_ItemFileName(pbstrFilePath);
}

STDMETHODIMP CBldAction::get_Item(IVCBuildableItem** ppItem)
{
	CHECK_POINTER_NULL(ppItem);
	*ppItem = m_pItem;
	if (m_pItem)
		(*ppItem)->AddRef();
	return S_OK;
}

STDMETHODIMP CBldAction::get_PropertyContainer(IVCPropertyContainer** ppPropContainer)
{
	CHECK_POINTER_NULL(ppPropContainer);
	CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
	return spPropContainer.CopyTo(ppPropContainer);
}

STDMETHODIMP CBldAction::get_ThisPointer(void** ppThis)
{
	CHECK_POINTER_NULL(ppThis);
	*ppThis = (void *)this;
	return S_OK;
}

STDMETHODIMP CBldAction::get_IsTargetAction(VARIANT_BOOL* pbIsTargetAction)
{
	CHECK_POINTER_NULL(pbIsTargetAction);

	if (m_pTool == NULL)
	{
		*pbIsTargetAction = VARIANT_FALSE;
		return S_FALSE;
	}

	*pbIsTargetAction = m_pTool->IsTargetTool(this) ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CBldAction::GetOutput(IVCBuildErrorContext* pEC, void** ppOutput)
{
	CHECK_POINTER_NULL(ppOutput);

	CBldFileRegSet* pRegSet = GetOutput(pEC);
	*ppOutput = (void *)pRegSet;
	return S_OK;
}

STDMETHODIMP CBldAction::get_Registry(void** ppFileRegistry)
{
	CHECK_POINTER_NULL(ppFileRegistry);
	*ppFileRegistry = (void *)m_pregistry;
	return S_OK;
}

STDMETHODIMP CBldAction::InitSets()
{
	m_pSets = new CBldActionSets(this);
	return S_OK;
}

STDMETHODIMP CBldAction::AddSourceDependencyFromString(BSTR bstrDep, IVCBuildErrorContext* pEC)
{
	CStringW strDep = bstrDep;
	return AddSourceDep(strDep, pEC) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldAction::AddSourceDependencyFromFrh(void* pFileRegHandle, IVCBuildErrorContext* pEC)
{
	BldFileRegHandle frh = (BldFileRegHandle)pFileRegHandle;
	return AddSourceDep(frh, pEC) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldAction::AddScannedDependencyFromString(BSTR bstrDep, IVCBuildErrorContext* pEC)
{
	CStringW strDep = bstrDep;
	return AddScannedDep(strDep, pEC) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldAction::AddScannedDependencyFromFrh(void *pDep, IVCBuildErrorContext* pEC)
{
	BldFileRegHandle frh = (BldFileRegHandle)pDep;
	return AddScannedDep(frh, pEC) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldAction::AddScannedDependencyOfType(int type, BSTR bstrFile, int line, BOOL fScan, IVCBuildErrorContext* pEC)
{
	CStringW strFile = bstrFile;
	return AddScannedDep(type, pEC, strFile, line, fScan) ? S_OK : S_FALSE;
}

STDMETHODIMP CBldAction::ClearScannedDependencies(IVCBuildErrorContext* pEC)
{
	ClearScannedDep(pEC);
	return S_OK;
}

STDMETHODIMP CBldAction::SetDependencyState(enumDependencyState depState)
{
	switch (depState)
	{
	case depNone:
		SetDepState(DEP_None);
		break;
	case depEmpty:
		SetDepState(DEP_Empty);
		break;
	default:
		RETURN_INVALID();
	}
	return S_OK;
}

STDMETHODIMP CBldAction::MarkMissingDependencies(BOOL bHaveMissing)
{
	m_fDepMissing = bHaveMissing;
	return S_OK;
}

STDMETHODIMP CBldAction::UpdateDependencyInformationTimeStamp()
{
	UpdateDepInfoTimeStamp();
	return S_OK;
}

STDMETHODIMP CBldAction::get_Dependencies(IVCBuildStringCollection** ppDependencies)	// dependencies of this action i.e., libs, headers, etc.
{
	CHECK_POINTER_NULL(ppDependencies);
	*ppDependencies = NULL;

	CBldFileRegSet* pScannedDeps = GetScannedDep();
	CBldFileRegSet* pSourceDep = GetSourceDep();
	if (pScannedDeps == NULL && pSourceDep == NULL)
		return S_FALSE;	// nothing to do

	CVCBuildStringCollection* pStringCol;
	HRESULT hr = CVCBuildStringCollection::CreateInstance(ppDependencies, &pStringCol);
	RETURN_ON_FAIL(hr);

	if (pScannedDeps != NULL)
		LoadDepArray(pScannedDeps, pStringCol->m_strStrings);
	if (pSourceDep != NULL)
		LoadDepArray(pSourceDep, pStringCol->m_strStrings);

	if (pStringCol->m_strStrings.GetSize() == 0)	// no deps, so release our collection...
	{
		(*ppDependencies)->Release();
		*ppDependencies = NULL;
		return S_FALSE;
	}

	return S_OK;
}

void CBldAction::LoadDepArray(CBldFileRegSet* pDeps, CVCStringWArray& rstrDepsArray)
{
	BldFileRegHandle frh;
	pDeps->InitFrhEnum();
	while ((frh = pDeps->NextFrh()) != (BldFileRegHandle)NULL)
	{
		if (frh->IsNodeType(nodetypeRegSet))
			LoadDepArray((CBldFileRegSet *)frh, rstrDepsArray);
		else if (frh->IsNodeType(nodetypeRegFile))
		{
			const CPathW* pPath = frh->GetFilePath();
			if (pPath != NULL)
			{
				CStringW strPath = *pPath;
				rstrDepsArray.Add(strPath);
			}
		}
		frh->ReleaseFRHRef();
	}
}

STDMETHODIMP CBldAction::GetDeploymentDependencies(IVCBuildStringCollection** ppDeployDeps)
{
	if (m_pTool)
		m_pTool->GetDeploymentDependencies(this, ppDeployDeps);
	return S_OK;
}

STDMETHODIMP CBldAction::get_BuildOutputs(IVCBuildStringCollection** ppOutputs)		// outputs of this action i.e., foo.exe, foo.pdb, foo.obj, etc.
{
	CHECK_POINTER_NULL(ppOutputs);
	*ppOutputs = NULL;

	CBldFileRegSet* pregset = &m_pSets->m_frsOutput;
	RETURN_ON_NULL2(pregset, S_FALSE);

	CVCBuildStringCollection* pStringCol;
	HRESULT hr = CVCBuildStringCollection::CreateInstance(ppOutputs, &pStringCol);
	RETURN_ON_FAIL(hr);

	LoadDepArray(pregset, pStringCol->m_strStrings);
	return S_OK;
}

STDMETHODIMP CBldAction::GetFileNameForFileRegHandle(void* pRegHandle, BSTR* pbstrFileName)
{
	CHECK_POINTER_NULL(pbstrFileName);
	*pbstrFileName = NULL;
	RETURN_ON_NULL2(pRegHandle, S_FALSE);

	BldFileRegHandle frh = (BldFileRegHandle)pRegHandle;
	const CPathW* pPath = frh->GetFilePath();
	RETURN_ON_NULL2(pPath, S_FALSE);

	CStringW strName;
	pPath->GetFullPath(strName);

	*pbstrFileName = strName.AllocSysString();
	return S_OK;
}

STDMETHODIMP CBldAction::GetFileRegHandleForFileName(BSTR bstrFileName, void** ppRegHandle)
{
	CHECK_POINTER_NULL(ppRegHandle);
	CStringW strFile = bstrFileName;
	if (strFile.IsEmpty())
		RETURN_INVALID();

	BldFileRegHandle frh = CBldFileRegFile::LookupFileHandleByName(strFile, TRUE);
	*ppRegHandle = (void *)frh;
	return S_OK;
}

STDMETHODIMP CBldAction::ReleaseRegHandle(void* pRegHandle)
{
	RETURN_ON_NULL2(pRegHandle, S_FALSE);

	BldFileRegHandle frh = (BldFileRegHandle)pRegHandle;
	frh->ReleaseFRHRef();
	return S_OK;
}

// Binding and un-binding to tools
void CBldAction::Bind(CBldToolWrapper* pTool, IVCBuildErrorContext* pEC /* = NULL */, BOOL bNoFilter /* = FALSE */)
{
	// Set our tool
	SetToolI(pTool, bNoFilter);

	// update our output
	if (m_pdepgraph && m_pdepgraph->IsInitialized())
		LateBind(pEC);
}

// Binding and un-binding to tools
HRESULT CBldAction::LateBind(IVCBuildErrorContext* pEC)
{
	// update our output
	if (m_pTool)
	{
		if (m_pSets == NULL)
			InitSets();
		RefreshOutputs(0, pEC);
	}

	return S_OK;
}

void CBldAction::UnBind()
{
	ClearSourceDep(NULL);	// un-bind our source deps
	ClearScannedDep(NULL);	// nuke our other deps

	// clean up our input & output file/set references
	ClearOutput(NULL);
	ClearInput();

	SetToolI((CBldToolWrapper *)NULL);	// set our tool					   
}

// Notification of input or output changing
// Rx for file change events
void CBldAction::OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint)
{
	// interested in this?
	if (!(idChange == FRI_ADD || idChange == FRI_DESTROY))
		return;	// no

	// ignore due to batching?
	if (m_fBatchNotify)
		return;	// yes
												
	// convert hint into a file registry handle
	BldFileRegHandle frhHint = (BldFileRegHandle)pHint;
									    
	// must be concerning our 'possible' input!
	VSASSERT(hndFileReg == m_frhInput, "receiving notification about something we do not care about!");

	// valid input?
	if (m_pTool && m_pTool->IsTargetTool(this) && !ValidInput(frhHint))
		return;

	// add/remove these input dependencies to/from the graph
	if (m_pdepgraph != NULL)
	{
		BOOL bOK = m_pdepgraph->ModifyDep(frhHint, this, DEP_Input, idChange == FRI_ADD /* add or remove? */, pEC);
		VSASSERT(bOK, "Failed to modify dependency graph!");
	}

	// dirty input
	m_fDirtyInput = TRUE;
}

// replaces OnInform for those few things that need it...
STDMETHODIMP CBldAction::RefreshOutputs(long nPropID, IVCBuildErrorContext* pEC)
{
	// don't bother with output changes 'til there's a dep graph.
	RETURN_ON_NULL2(m_pSets, S_OK);
		
	if (nPropID != 0)	// only refresh if we need to
	{
		if (m_pTool && !m_pTool->AffectsOutput(nPropID))
			return S_OK;
	}

	RefreshOutputI(pEC);

	HRESULT hrFinal = S_FALSE;
	if (nPropID == 0)	// on a force like this, always say to cascade changes through if needed
		hrFinal = S_OK;
	else if (m_pTool && !m_pTool->IsTargetTool(this))
		hrFinal = S_OK;

	return hrFinal;
}

STDMETHODIMP CBldAction::HandlePossibleCommandLineOptionsChange(IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(m_pTool, S_FALSE);	// nothing to bother with here

	if (m_pTool->CommandLineOptionsAreDirty(m_pItem))
	{
		m_fPossibleOptionChange = TRUE;
		if (m_pTool->OutputsAreDirty(m_pItem))
		{
			RefreshOutputs(0, pEC);
			m_pTool->ClearDirtyOutputs(m_pItem);
		}
		return S_OK;
	}

	return S_FALSE;		// not for us
}

void CBldAction::AddInput(BOOL bNoFilter /* = FALSE */)
{
	// no tool, no input to add!
	if (m_pTool == (CBldToolWrapper *)NULL)
		return;

	// create the input set or file
	if (m_pTool->IsTargetTool(this))
	{
		// 'possible' input is a file filter
		CStringW strFilter;
		if (m_pTool->GetDefaultExtensions(strFilter))
			m_frhInput = m_pregistry->RegisterFileFilter((const CStringW *)&strFilter);
	}
	else
	{
		CComBSTR bstrPath;
		// 'possible' input is the file itself
		if (m_fIsProject)
		{
			VSASSERT(m_pcrOur != NULL, "Action was not initialized correctly; missing CfgRecord pointer");
			VCConfiguration* pCfg = m_pcrOur->GetVCConfiguration();
			if (pCfg)
				pCfg->get_PrimaryOutput(&bstrPath);
		}
		else
		{
			CComPtr<IDispatch> pDispFile;
			VSASSERT(m_pItem != NULL, "Action was not initialized correctly; missing BuildableItem pointer");
			if (m_pItem != NULL)
			{
				CComQIPtr<VCFileConfiguration> spFileCfg = m_pItem;
				if (spFileCfg != NULL && SUCCEEDED(spFileCfg->get_File(&pDispFile)) && pDispFile != NULL)
				{
					CComQIPtr<VCFile> pFile = pDispFile;
					if (pFile != NULL)
						pFile->get_FullPath(&bstrPath);
				}
			}
		}

		CStringW strPath = bstrPath;
		if (!strPath.IsEmpty())
		{
			CPathW Path;
			// both get_PrimaryOutput and get_FullPath already verify that this path is valid and actual case
			if (Path.CreateFromKnown(strPath))
				m_frhInput = m_pregistry->RegisterFile(&Path, TRUE, bNoFilter);
		}
	}
}

void CBldAction::RemoveInput()
{
	// no tool or no input to remove?
	if (m_pTool == (CBldToolWrapper*)NULL || m_frhInput == (BldFileRegHandle)NULL)
		return;

	// clean up our 'possible' input file/set references
	if (m_frhInput->IsNodeType(nodetypeRegFile))
		m_pregistry->ReleaseRegRef(m_frhInput);
	else
		m_frhInput->ReleaseFRHRef();
	m_frhInput=NULL;
}

BOOL CBldAction::ValidInput(BldFileRegHandle frhIn)
{
	if (m_pSets)
		return !m_pSets->m_frsOutput.RegHandleExists(frhIn);	// ok?
	return FALSE;
}

// FUTURE: remove this
void CBldAction::SetToolI(CBldToolWrapper* pTool, BOOL bNoFilter /* = FALSE */)
{
	// DIANEME_TODO (CBldAction::SetToolI): need to figure out way to make ourselves dependent on the outputs of this tool...
	if (m_pTool != (CBldToolWrapper*)NULL)
	{
		// make sure we *don't* get input change events
		if (m_frhInput != (BldFileRegHandle)NULL)
			m_frhInput->RemoveNotifyRx(this);

		// remove the input for the old tool
 		RemoveInput();
	}
								   
	// add our input for this new tool?
	m_pOldTool = m_pTool;
	m_pTool = pTool;

	if (m_pTool != (CBldToolWrapper*)NULL)
	{
		AddInput(bNoFilter);

		// make sure we get 'possible' input and output change events
		if (m_frhInput != (BldFileRegHandle)NULL)
			m_frhInput->AddNotifyRx(this, TRUE);
	}

	// input and output is dirty
	m_fDirtyInput = TRUE;
	m_fDirtyOutput = TRUE;
}

BOOL CBldAction::IsBuildableConfiguration(IVCConfigurationImpl* pProjCfgImpl)
{
	RETURN_ON_NULL2(pProjCfgImpl, FALSE);
	VARIANT_BOOL bIsBuildable = VARIANT_FALSE;
	return (SUCCEEDED(pProjCfgImpl->get_IsBuildable(&bIsBuildable)) && (bIsBuildable == VARIANT_TRUE));
}

BOOL CBldAction::IsValidConfiguration(IVCConfigurationImpl* pProjCfgImpl)
{
	RETURN_ON_NULL2(pProjCfgImpl, FALSE);
	VARIANT_BOOL bIsValid = VARIANT_FALSE;
	return (SUCCEEDED(pProjCfgImpl->get_IsValidConfiguration(&bIsValid)) && 
		(bIsValid == VARIANT_TRUE));
}

void CBldAction::AssignActions(CBldCfgRecord* pcr, VCFileConfiguration* pFileCfg, 
	BOOL fAssignContained /* = TRUE */, BOOL fAssignContainedOnly /* = FALSE */)
{
	VSASSERT(pcr != NULL, "Cannot assign an action where we do not know the associated CfgRecord");
	if (pcr == NULL)
		return;

	VCConfiguration* pProjCfg = pcr->GetVCConfiguration();	// not ref-counted
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pProjCfg;
	if (spProjCfgImpl == NULL)
		return;

	// valid?
	if (!IsValidConfiguration(spProjCfgImpl))
		return;

	// Buildable configuration?
	if (!IsBuildableConfiguration(spProjCfgImpl))
		return;

	if (!fAssignContainedOnly)
	{
		CBldConfigurationHolder cfgHolder(pcr, pFileCfg, pProjCfg);
		AssignSingleAction(cfgHolder);
	}

	BOOL bIsProject = (pFileCfg == NULL);
	if (!fAssignContained || !bIsProject)
		return;		// all done

	CComPtr<IEnumVARIANT> pFiles;
	HRESULT hr = GetFileCollection(pProjCfg, &pFiles);
	VOID_RETURN_ON_FAIL_OR_NULL(pFiles, hr);

	while (TRUE)
	{
		CComVariant var;
		hr = pFiles->Next(1, &var, NULL);
		BREAK_ON_DONE(hr);
		CComPtr<VCFileConfiguration> pFileCfg;
		if (!GetFileCfgForProjCfg(var, pProjCfg, &pFileCfg))
			continue;

		CBldConfigurationHolder cfgHolder(pcr, pFileCfg, pProjCfg);
		AssignSingleAction(cfgHolder);
	}
}

void CBldAction::AssignSingleAction(CBldConfigurationHolder& cfgHolder)
{
	BldFileRegHandle frh = cfgHolder.GetFileRegHandle();
	VARIANT_BOOL bExcluded = VARIANT_FALSE;

	if (!cfgHolder.IsProject() && SUCCEEDED(cfgHolder.GetFileCfg()->get_ExcludedFromBuild(&bExcluded)) && 
		(bExcluded == VARIANT_FALSE))
	{
		VSASSERT(NULL != cfgHolder.GetPCR(), "Trying to assign an action without a valid CfgRecord");
		// Add to dependency graph as possible input to schmooze tool.
		CBldFileRegistry *preg = g_StaticBuildEngine.GetRegistry(cfgHolder.GetPCR());
		VSASSERT(NULL != preg, "No file registry available for the CfgRecord.  Big trouble.");
		VSASSERT(NULL != frh, "No frh associated with this file.  Big trouble.");
		if( preg )
		    preg->AddRegRef(frh);
	}

	// Get the list of actions; put these actions on the configuration
	CComPtr<IVCBuildActionList> pActions;
	cfgHolder.GetActionList(&pActions);

	// Go through them and attach any to this item that want to be
	CBldToolWrapper * pTool = NULL;
	CVCPtrList* pToolList = cfgHolder.GetToolList();
	VCPOSITION pos = pToolList == NULL ? NULL : pToolList->GetHeadPosition();

	// 	No need to loop through tools.
	CComQIPtr<IVCToolImpl> pVCTool;
	CStringW strToolName;
	if (!cfgHolder.IsProject())
	{
		if (NULL == frh)
			pos = NULL;
		else
		{
			long cActions = 0;
			if (SUCCEEDED(pActions->get_Count(&cActions))  && (cActions > 0))
				pos = NULL;
		}
		if (cfgHolder.GetFileCfg())
		{
			CComPtr<IDispatch> spDispTool;
			cfgHolder.GetFileCfg()->get_Tool(&spDispTool);		// this will pick up default, if any, if nothing set
			pVCTool = spDispTool;
			if (pVCTool)
			{
				CComBSTR bstrToolName;
				pVCTool->get_ToolShortName(&bstrToolName);
				strToolName = bstrToolName;
			}
		}
	}

	// Check to see if forced to a different tool than the default.
	BOOL bFound = FALSE;

	if (pVCTool)
	{
		while (pos != (VCPOSITION)NULL)
		{
			pTool = (CBldToolWrapper *)pToolList->GetNext(pos);
			if (pTool->SameToolType(strToolName))
			{
				bFound = TRUE;
				break;
			}

		}
		if(bFound)
		{
			CComPtr<IVCBuildAction> pAction;
			CBldAction::CreateInstance(cfgHolder.GetFileCfg(), pTool, cfgHolder.GetPCR(), cfgHolder.IsProject(), 
				(bExcluded == VARIANT_TRUE), &pAction);

			// check for multiple assignment
			VSASSERT(pActions->Find(pTool->GetVCToolImpl(), NULL) == S_FALSE, "Cannot have multiple assignments of same tool to same object.");

			pActions->Add(pAction);
			pAction->RefreshOutputs(0, NULL);
		}
	}
	else if (cfgHolder.IsProject())
	{
		while (pos != (VCPOSITION)NULL)
		{
			pTool = (CBldToolWrapper *)pToolList->GetNext(pos);
			
			if (!pTool->IsTargetTool(NULL))
				continue;

			if (pActions->Find(pTool->GetVCToolImpl(), NULL) == S_OK)
				continue;	// already have one

			// allocate a 'building' action to list
			CComPtr<IVCBuildAction> pAction;
			CBldAction::CreateInstance(cfgHolder.GetFileCfg(), pTool, cfgHolder.GetPCR(), cfgHolder.IsProject(), 
				FALSE, &pAction);

			pActions->Add(pAction);
			pAction->RefreshOutputs(0, NULL);
		}
	}
}

void CBldAction::UnAssignActions(CBldCfgRecord* pcr, VCFileConfiguration* pFileCfg, 
	BOOL fUnassignContained /* = TRUE */)
{
	VSASSERT(pcr != NULL, "Trying to unassign action where CfgRecord is not known.  How could we manage to get here, even?");
	VCConfiguration* pProjCfg = pcr->GetVCConfiguration();	// not ref-counted
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pProjCfg;
	if (spProjCfgImpl == NULL)
		return;

	// valid?
	if (!IsValidConfiguration(spProjCfgImpl))
		return;

	// Buildable configuration?
	if (!IsBuildableConfiguration(spProjCfgImpl))
		return;

	{	// unassign the item we came in with..
		CBldConfigurationHolder cfgHolder(pcr, pFileCfg, pProjCfg);
		UnAssignSingleAction(cfgHolder);
	}

	if (!fUnassignContained || (pFileCfg != NULL))
		return;		// either not a config, or we don't want to unassign the config contents

	CComPtr<IEnumVARIANT> pFiles;
	HRESULT hr = GetFileCollection(pProjCfg, &pFiles);
	VOID_RETURN_ON_FAIL_OR_NULL(pFiles, hr);
	while (TRUE)
	{
		CComVariant var;
		hr = pFiles->Next(1, &var, NULL);
		BREAK_ON_DONE(hr);
		CComPtr<VCFileConfiguration> pFileCfg;
		if (!GetFileCfgForProjCfg(var, pProjCfg, &pFileCfg))
			continue;

		CBldConfigurationHolder cfgHolder(pcr, pFileCfg, pProjCfg);
		UnAssignSingleAction(cfgHolder);
	}
}

void CBldAction::UnAssignSingleAction(CBldConfigurationHolder& cfgHolder)
{
	BldFileRegHandle frh = cfgHolder.GetFileRegHandle();

	VARIANT_BOOL bExcluded = VARIANT_FALSE;
	if (!cfgHolder.IsProject() && SUCCEEDED(cfgHolder.GetFileCfg()->get_ExcludedFromBuild(&bExcluded)) && 
		(bExcluded == VARIANT_FALSE))
	{
		VSASSERT(NULL != cfgHolder.GetPCR(), "Trying to unassign action without valid CfgRecord.  How could we get here, even?");
		// Add to dependency graph as possible input to schmooze tool.
		CBldFileRegistry *preg = g_StaticBuildEngine.GetRegistry(cfgHolder.GetPCR());
		VSASSERT(NULL != preg, "No file registry associated with the CfgRecord.  Big trouble.");
		if (frh && preg )
			preg->ReleaseRegRef(frh, TRUE /* pull out filtering */);
	}
			
	// Get the list of actions
	CComPtr<IVCBuildActionList> pActions;
	cfgHolder.GetActionList(&pActions);

	// If unassigning 'en masse' then clear up our output files
	if (cfgHolder.IsProject())
		pActions->FreeOutputFiles();

	// Go through them and detach them 
	pActions->Reset(NULL);
	HRESULT hr = S_OK;
	while (hr == S_OK)
	{
		void* pPos;
		CComPtr<IVCBuildAction> pAction;
		hr = pActions->Next(&pAction, (void **)&pPos);
		BREAK_ON_DONE(hr);
		VALID_CONTINUE_ON_NULL(pAction);

		// Remove from list and de-allocate?
		CComPtr<IVCToolImpl> pVCTool;
		pAction->get_VCToolImpl(&pVCTool);
		if (pVCTool)
		{
			CComPtr<IVCBuildActionList> spBldActionList;
			cfgHolder.GetActionList(&spBldActionList, !cfgHolder.IsProject());
			if (spBldActionList != NULL && spBldActionList->Find(pVCTool, NULL) == S_FALSE)
				continue;	// no, it's not in our list
		}
		pActions->RemoveAtPosition(pPos);
	}
}	    

CBldAction* CBldAction::GetTargetAction()
{
	// link it to the target-level action if we need to?
	if (m_fIsProject)
	{
		// Get the target-level actions
		CBldConfigurationHolder cfgHolder(m_pcrOur, NULL, m_pcrOur->GetVCConfiguration());
		CComPtr<IVCBuildActionList> spActionList;
		cfgHolder.GetActionList(&spActionList, FALSE);

		IVCToolImpl* pVCTool = NULL;
		if (m_pTool != NULL)
			pVCTool = m_pTool->GetVCToolImpl();

		CComPtr<IVCBuildAction> spAction;
		spActionList->Find(pVCTool, &spAction);
		if (spAction != NULL)
		{
			spAction->get_ThisPointer((void **)&m_pTrgAction);
			VSASSERT(m_pTrgAction != NULL, "Gotta have a target action...");
		}
	}

	return m_pTrgAction;
}

void CBldAction::RefreshOutputI(IVCBuildErrorContext* pEC)
{
	// is this item being excluded from the build?
	BOOL fExcluded = FALSE;
	VARIANT_BOOL bvExcluded = VARIANT_FALSE;
	CComQIPtr<VCFileConfiguration> spFileCfg = m_pItem;
	if (spFileCfg == NULL)
		fExcluded = FALSE;
	else if (FAILED(spFileCfg->get_ExcludedFromBuild(&bvExcluded)) || bvExcluded == VARIANT_TRUE)
		fExcluded = TRUE;	// assume yes

	if (fExcluded)
	{
		// clear our source dep. on the output
		ClearSourceDep(pEC);

		// clear the actual output
		ClearOutput(pEC);
	}
	else
	{
		// make our outputs dirty so that we update the output
		m_fDirtyOutput = TRUE;
		(void) GetOutput(pEC);
	}
}

void CBldAction::ClearOutput(IVCBuildErrorContext* pEC)
{
	// ignore FRN_LCL_DESTROY changes to input
	// that may occur because of removal
	// of 'input->output' deps. in graph
	m_fBatchNotify = TRUE;

	int i = 0;
	if (m_pSets != NULL)
	{
		CBldFileRegSet* pregset = &m_pSets->m_frsOutput;
		BldFileRegHandle frh = NULL;
		pregset->InitFrhEnum();
		frh = pregset->NextFrh();
		while (frh != NULL)
		{
			// re-gen'ing the output?
			if (m_fInGenOutput)
			{
				// remember the old outputs...
				m_pSets->m_pfrsOldOutput->AddRegHandle(frh, pEC);
				m_paryOldOutputAttrib->Add(m_pSets->m_aryOutputAttrib.GetAt(i++));
 			}
			else
			{
				// remove this output dependency from the graph
				if (m_pdepgraph != NULL)
				{
					BOOL bOK = m_pdepgraph->ModifyDep(frh, this, DEP_Output, FALSE /* remove */, pEC);
					VSASSERT(bOK, "Failed to modify dependency graph!");
				}
			}

			// remove the entry in the registry if we created it in ::AddOutput()
			VSASSERT(m_pSets->m_frsOutput.RegHandleExists(frh), "Trying to remove a reg handle we did not add.");
			m_pSets->m_frsOutput.RemoveRegHandle(frh);

			if (m_pSets->m_frsSchmoozableOutput.RegHandleExists(frh))
				m_pSets->m_frsSchmoozableOutput.RemoveRegHandle(frh);

			// Next.
			frh->ReleaseFRHRef();
			frh = pregset->NextFrh();
		}

		// empty our output contents and assoc. attributes ...
		VSASSERT(m_pSets->m_frsOutput.IsEmpty(), "Failed to remove all the reg handles in the output set.");
		VSASSERT(m_pSets->m_frsSchmoozableOutput.IsEmpty(), "Failed to remove all the reg handles in the schoomzable output set.");
		m_pSets->m_aryOutputAttrib.RemoveAll();
	}

	// take notice of all input changes....
	m_fBatchNotify = FALSE;
}

// retrieve our scanned dependencies
CBldFileRegSet* CBldAction::GetScannedDep()
{
	if (!m_pSets)
		return NULL;
	return &m_pSets->m_frsScannedDep;
}

// retrieve our source dependencies
CBldFileRegSet* CBldAction::GetSourceDep()
{
	if (!m_pSets)
		return NULL;
	return &m_pSets->m_frsSourceDep;
}

STDMETHODIMP CBldAction::get_SourceDependencies(void** ppFileRegSet)
{
	CHECK_POINTER_NULL(ppFileRegSet);

	CBldFileRegSet* pDeps = GetSourceDep();
	*ppFileRegSet = (void *)pDeps;
	return S_OK;
}

STDMETHODIMP CBldAction::get_ScannedDependencies(void** ppFileRegSet)
{
	CHECK_POINTER_NULL(ppFileRegSet);

	CBldFileRegSet* pDeps = GetScannedDep();
	*ppFileRegSet = (void *)pDeps;
	return S_OK;
}


STDMETHODIMP CBldAction::RemoveSourceDependencyForFrh(void* pFileRegHandle, IVCBuildErrorContext* pEC)
{
	BldFileRegHandle frh = (BldFileRegHandle)pFileRegHandle;
	if (RemoveSourceDep(frh, pEC))
		return S_OK;
	
	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CBldAction::ClearSourceDependencies(IVCBuildErrorContext* pEC)
{
	ClearSourceDep(pEC);
	return S_OK;
}

void CBldAction::ClearDepI(UINT depType, IVCBuildErrorContext* pEC)
{
	if (m_pSets == NULL)
		return;	// nothing to do!

	CBldFileRegSet * pfrsDep = NULL;
	if (depType == DEP_Scanned)
		pfrsDep = &m_pSets->m_frsScannedDep;

	else if (depType == DEP_Source)
		pfrsDep = &m_pSets->m_frsSourceDep;
	
	if (pfrsDep == (CBldFileRegSet *)NULL)
		return;	// nothing to do!

	pfrsDep->InitFrhEnum();
	BldFileRegHandle frh = pfrsDep->NextFrh();
	while (frh != NULL)
	{
		BOOL bOK = RemoveDepI(depType, frh, pEC);
		VSASSERT(bOK, "Failed to remove dependency!");
		frh->ReleaseFRHRef();
		frh = pfrsDep->NextFrh();
	}

	// empty our dependency contents...
	pfrsDep->EmptyContent();
}

BOOL CBldAction::AddDepI(UINT depType, CStringW & strFile, IVCBuildErrorContext* pEC)
{
	BldFileRegHandle frh;

	// if we're not a target tool try to form absolute relative to source
	CPathW pathFile;
	if (!m_pTool->IsTargetTool(this))
	{
		const CPathW* pPath = m_pregistry->GetRegEntry(m_frhInput)->GetFilePath();
		CDirW dirFile;
		if (dirFile.CreateFromPath(*pPath) && 
			pathFile.CreateFromDirAndFilename(dirFile, strFile))
			strFile = (const wchar_t *)pathFile;
		else if (!pathFile.Create(strFile))
			return FALSE;
	}
	else if (!pathFile.Create(strFile))
		return FALSE;

	// do we need to register this?
	frh = CBldFileRegFile::GetFileHandle(pathFile.GetFullPath(), !pathFile.IsActualCase());	// incr. ref

	if (frh == (BldFileRegHandle)NULL)
		return FALSE;

	BOOL bResult = AddDepI(depType,frh, pEC);
	frh->ReleaseFRHRef();
	return bResult;
}

BOOL CBldAction::RemoveDepI(UINT depType, BldFileRegHandle frh, IVCBuildErrorContext* pEC)
{
	CBldFileRegSet* pfrsDep = NULL;
	if (depType == DEP_Scanned)
		pfrsDep = &m_pSets->m_frsScannedDep;

	else if (depType == DEP_Source)
		pfrsDep = &m_pSets->m_frsSourceDep;

	if (pfrsDep == (CBldFileRegSet *)NULL)
		return TRUE;	// nothing to do!

	if (depType == DEP_Scanned || depType == DEP_Missing)
	{
		// added as a source dep.?
		if (GetSourceDep() && GetSourceDep()->RegHandleExists(frh))
			if (!RemoveSourceDep(frh, pEC))	// remove as a source dep. as well!
				return FALSE;
	}
	else if (depType == DEP_Source)
	{
		if (m_pdepgraph != NULL)
		{
			// remove this source dependency from the graph now...
			BOOL bOK = m_pdepgraph->ModifyDep(frh, this, DEP_Source, FALSE /* remove */, pEC);
			VSASSERT(bOK, "Failed to modify dependency graph!");
		}
	}

	if (pfrsDep->RegHandleExists(frh))
	{
		pfrsDep->RemoveRegHandleI(frh, pEC);
	}

	return TRUE;
}

BOOL CBldAction::AddDepI(UINT depType, BldFileRegHandle frh, IVCBuildErrorContext* pEC)
{
	// is this a scanned dep. that should really be a source dep.?
	CDepGrNode * pgrnDep;

	CBldFileRegSet * pfrsDep = NULL;
	if (depType == DEP_Scanned)
		pfrsDep = GetScannedDep();

	else if (depType == DEP_Source)
		pfrsDep = GetSourceDep();

	else
		VSASSERT(0, "Invalid dependency type");


	if (depType == DEP_Scanned)
	{
		// not found on disk?
		// so add as a missing dep.
	}

	if (depType == DEP_Scanned )
	{
		// found this dep.?
		if (m_pdepgraph != NULL )
		{
			if( !m_pdepgraph->IsInitialized() )
				return FALSE;
			// make it a source dep. as well?
			if (m_pdepgraph->FindDep(frh, pgrnDep) && !AddSourceDep(frh, pEC))
				return FALSE;
		}
	}
	// no dependency set by this point == unsupported platform config
	if (pfrsDep == (CBldFileRegSet *)NULL)
		return FALSE;

	// add this source dependencies to the graph now...
	BOOL fOldInGenOutput = m_fInGenOutput;
	m_fInGenOutput = FALSE;

	if (depType == DEP_Source)
	{
		if (m_pdepgraph != NULL)
		{
			BOOL bOK = m_pdepgraph->ModifyDep(frh, this, DEP_Source, TRUE /* add */, pEC);
			VSASSERT(bOK, "Failed modify dependency graph!");
		}
	}
	
	m_fInGenOutput = fOldInGenOutput;
	if (pfrsDep->RegHandleExists(frh))
	{
		// frh is already in pfrsDep.
		return TRUE;
	}
	else
	{
		// Assume that handle is *always* added!
		return pfrsDep->AddRegHandle(frh, pEC);
	}
}

// retrieve our input(s) (may be a file set)
CBldFileRegSet* CBldAction::GetInput(IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(m_pSets, NULL);

	// dirty?
	if (m_fDirtyInput)
	{
		if ((m_frhInput == NULL) && (m_pTool != NULL) && m_pTool->CustomToolType() && m_fIsProject)
			AddInput();	// HACK: try adding it now

		if (m_frhInput != NULL)
		{
			ClearInput();

			// initialize the input
			// just return our input?
			if (!m_pTool->IsTargetTool(this))
				m_pSets->m_frsInput.AddRegHandle(m_frhInput, pEC, FALSE);		// *don't* incr. ref.
			// else validate our inputs
			else
			{
				CBldFileRegSet* psetInput = (CBldFileRegSet *)m_pregistry->GetRegEntry(m_frhInput);

				BldFileRegHandle frh;
				psetInput->InitFrhEnum();
				while ((frh = psetInput->NextFrh()) != (BldFileRegHandle)NULL)
				{
					if (ValidInput(frh))
						m_pSets->m_frsInput.AddRegHandle(frh, pEC, FALSE);	// *don't* incr. ref.
					frh->ReleaseFRHRef();
				}
			}
			m_fDirtyInput = FALSE;
		}
	}

	return &m_pSets->m_frsInput;
}

// retrieve our input(s) (may be a file set)
HRESULT CBldAction::GetRelativePathsToInputs(BOOL bFilterOutSpecial, BOOL bUseMultiLine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CBldFileRegSet *pset = GetInput(pEC);
	BldFileRegHandle  frhInput;
	pset->InitFrhEnum();
	CStringW strInput;
	CStringW strObjs;

	CComBSTR bstrDir;
	CComPtr<VCProject> spProject;
	get_Project(&spProject);
	spProject->get_ProjectDirectory(&bstrDir);
	
	CStringW strDir = bstrDir;
	CDirW dir;
	dir.CreateFromKnown(strDir);
	bool bFirst = true;

	while ((frhInput = pset->NextFrh()) != (BldFileRegHandle)NULL)
	{
		const CPathW * pPath = m_pregistry->GetRegEntry(frhInput)->GetFilePath();
		if (pPath == NULL)
		{
			VSASSERT(FALSE, "Reg entry without an associated path?!?");
			continue;
		}

		if (bFilterOutSpecial)
		{
			CStringW strPath = *pPath;
			CComBSTR bstrPath = strPath;
			if (m_pTool && m_pTool->IsSpecialConsumable(bstrPath))
				continue;
		}

		// quote this input and make relative to project directory?
		pPath->GetRelativeName(dir, strInput, TRUE, FALSE);
		// If GetRelativeName failed, it's probably because the two
		// paths are on different drives, so we just can't make a 
		// relative path.  In this case, however, pPath must contain
		// at least a drive letter (and will probably be a full path)
		// Even if relativization fails, the string will still be quoted

		if (bFirst)
			bFirst = false;
		else if (bUseMultiLine)
			strObjs += L'\n';
		else
			strObjs += L' ';
		strObjs += strInput;
		frhInput->ReleaseFRHRef();
	}
	CComBSTR bstr = strObjs;
	bstr.CopyTo(pVal);
	return S_OK;
}

void CBldAction::ClearInput()
{
	// clear our input
	// (perhaps a file set containing file sets so just remove files...)
	if (m_pSets)
		m_pSets->m_frsInput.EmptyContent();
}

CVCWordArray* CBldAction::GetOutputAttrib()
{
	if (m_fInGenOutput)
		return m_paryOldOutputAttrib;
	if (m_pSets)
		return &(m_pSets->m_aryOutputAttrib);
	return NULL;
}

// retrieve our list of outputs (list of file registry handles)
CBldFileRegSet* CBldAction::GetOutput(IVCBuildErrorContext* pEC)
{
	// return old output if we're currently re-gen'ing new output...
	RETURN_ON_NULL2(m_pSets, NULL);

	if (m_fInGenOutput)
		return m_pSets->m_pfrsOldOutput;

	// got dirty output?
	if (m_fDirtyOutput)
	{
		// set up temporary regset and array until we are done generating outputs
		CBldFileRegSet	frsOldOutput;
		CVCWordArray	aryOldOutputAttrib;
		frsOldOutput.SetFileRegistry(m_pregistry);
	    frsOldOutput.CalcAttributes(FALSE);
		m_pSets->m_pfrsOldOutput = &frsOldOutput;
		m_paryOldOutputAttrib = &aryOldOutputAttrib;

		// the output is no longer dirty
		m_fDirtyOutput = FALSE;

		// we're currently re-gen'ing the output
		m_fInGenOutput = TRUE;
	
		// clear and remember the old output
		ClearOutput(pEC);

	 	// re-initialise the output

		CBldActionListHolder lstActions;
		lstActions.m_pActions->AddToEnd(this);
		{	// scope output regset attribute recalculation...
			CBldTurnRegRecalcOff recalcOff(&m_pSets->m_frsOutput);
			if (!m_pTool->GenerateOutput(AOGO_Default, lstActions.m_pActions, pEC))
			{
				ClearSourceDep(pEC);
				CBldFileRegSet Deletions;
				FindDeletions(Deletions, pEC);
				m_pSets->m_pfrsOldOutput->EmptyContent();
				if (m_pdepgraph != NULL)
					HandleDeletions(Deletions, pEC);
				m_paryOldOutputAttrib->RemoveAll();
				m_fInGenOutput = FALSE;
				return &m_pSets->m_frsOutput;
			}
		}

		if (m_fInGenOutput)
		{
			//
			// modify the graph with any differences we detect
			//

			BldFileRegHandle frh = NULL;
			int i = 0;

			// additions and same
			CBldFileRegSet* pregset = &m_pSets->m_frsOutput;

			CBldFileRegSet	Additions;
			CBldFileRegSet	Deletions;
			CVCWordArray	AdditionsAttrib;

			pregset->InitFrhEnum();
			frh = pregset->NextFrh();
			while (frh != NULL)
			{
				WORD attrib = m_pSets->m_aryOutputAttrib.GetAt(i++);
				BOOL fWithAction = !!attrib;

				// found in our old outputs?
				if (!m_pSets->m_pfrsOldOutput->RegHandleExists(frh))
				{
					// new dep.
					// not found, so add this output dependencies to the graph
					Additions.AddRegHandle(frh, pEC);
					AdditionsAttrib.Add((WORD)fWithAction);
				}
				else
					m_pSets->m_pfrsOldOutput->RemoveRegHandleI(frh, pEC);	// same dep.
				// Next.
				frh->ReleaseFRHRef();
				frh = pregset->NextFrh();
			}

			// deletions
			FindDeletions(Deletions, pEC);

			m_pSets->m_pfrsOldOutput->EmptyContent();

			if (m_pdepgraph != NULL)
			{
				pregset = &Additions;
				pregset->InitFrhEnum();
				frh = pregset->NextFrh();
				int iAdd = 0;
				while (frh != NULL)
				{
					BOOL bOK = m_pdepgraph->ModifyDep(frh, this, DEP_Output, TRUE /* add */, pEC,
						AdditionsAttrib.GetAt(iAdd));
					VSASSERT(bOK, "Failed to modify dependency!");

					// Next.
					frh->ReleaseFRHRef();
					frh = pregset->NextFrh();
					iAdd++;
				}

				HandleDeletions(Deletions, pEC);
			}

			m_paryOldOutputAttrib->RemoveAll();

			// no longer re-gen'ing the output
			m_fInGenOutput = FALSE;
		}
	}

	return &m_pSets->m_frsOutput;
}

void CBldAction::FindDeletions(CBldFileRegSet& Deletions, IVCBuildErrorContext* pEC)
{
	CBldFileRegSet* pregset = m_pSets->m_pfrsOldOutput;
	pregset->InitFrhEnum();
	BldFileRegHandle frh = pregset->NextFrh();
	while (frh != NULL)
	{
		// remove this output dependency from the graph
		Deletions.AddRegHandle(frh, pEC);

		// Next.
		frh->ReleaseFRHRef();
		frh = pregset->NextFrh();
	}
}

void CBldAction::HandleDeletions(CBldFileRegSet& Deletions, IVCBuildErrorContext* pEC)
{
	CBldFileRegSet* pregset = &Deletions;
	pregset->InitFrhEnum();
	BldFileRegHandle frh = pregset->NextFrh();
	while (frh != NULL)
	{
		BOOL bOK = m_pdepgraph->ModifyDep(frh, this, DEP_Output, FALSE /* remove */, pEC);
		VSASSERT(bOK, "Failed to modify dependency graph!");

		// Next.
		frh->ReleaseFRHRef();
		frh = pregset->NextFrh();
	}
}

HRESULT CBldAction::AddOutputI(BldFileRegHandle frh, IVCBuildErrorContext* pEC, BOOL fWithAction /* = TRUE */)
{
	m_fDirtyOutput = FALSE;

	if (!m_pSets->m_frsOutput.RegHandleExists(frh))
		m_pSets->m_frsOutput.AddRegHandle(frh, pEC);

	// re-gen'ing the output
	if (m_fInGenOutput)
		m_pSets->m_aryOutputAttrib.Add((WORD)fWithAction);
	else
	{
		// add this output dependencies to the graph
		if (m_pdepgraph != NULL)
		{
			BOOL bOK = m_pdepgraph->ModifyDep(frh, this, DEP_Output, TRUE /* add */, pEC, fWithAction);
			VSASSERT(bOK, "Failed to modify dependency graph!");
		}
	}

	return S_OK;
}

STDMETHODIMP CBldAction::AddOutputFromPath(BSTR bstrPath, IVCBuildErrorContext* pEC, VARIANT_BOOL fWithAction, 
	VARIANT_BOOL fAllowFilter, long nPropID, IVCToolImpl* pTool)
{
	CPathW path;
	if (!path.CreateFromKnown(bstrPath))
	{
		if (nPropID > 0)
		{
			CStringW strPath = bstrPath;
			CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
			InformUserAboutBadFileName(pEC, spPropContainer, pTool, nPropID, strPath);
		}
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}

	return AddOutput(&path, pEC, fWithAction == VARIANT_TRUE, fAllowFilter == VARIANT_TRUE, nPropID, pTool);
}

HRESULT CBldAction::AddOutput(const CPathW* pPath, IVCBuildErrorContext* pEC, BOOL fWithAction /* = TRUE */, 
	BOOL fAllowFilter /* = TRUE */, long nPropID /* = -1 */, IVCToolImpl* pTool /* = NULL */)
{
	BldFileRegHandle frh;

	CBldFileRegFile * pFileReg;

	// do we need to register this?
	frh = CBldFileRegFile::GetFileHandle(*pPath, !pPath->IsActualCase());	// incr. ref, no filter

	if (NULL==frh)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	pFileReg = (CBldFileRegFile *)m_pregistry->GetRegEntry(frh);

	// set default output dir type
	pFileReg->SetOutDirType(m_pTool->IsTargetTool(this) ? 1 : 2);

	HRESULT hRet = AddOutputI(frh, pEC, fWithAction);
	frh->ReleaseFRHRef();

	// we delayed the filtering until after it was in our output
	// now filter the file it	
	if (SUCCEEDED(hRet) && fAllowFilter && !m_pSets->m_frsSchmoozableOutput.RegHandleExists(frh))
		m_pSets->m_frsSchmoozableOutput.AddRegHandle(frh, pEC);

	return hRet;
}
   
BOOL CBldAction::EnabledOutput(long nEnablePropId)
{
	if (nEnablePropId == -1)
		return TRUE;

	CComQIPtr<IVCPropertyContainer> spPropertyContainer = m_pItem;
	RETURN_ON_NULL2(spPropertyContainer, TRUE);

	CComVariant var;
	if (FAILED(spPropertyContainer->GetProp(nEnablePropId, &var)))
		return TRUE;

	if (var.vt == VT_EMPTY)
		return FALSE;
	else if (var.vt == VT_BOOL)
		return (var.boolVal == VARIANT_TRUE);
	else if (var.vt == VT_I4)
		return (var.lVal != 0);
	else
		return TRUE;
}

BOOL CBldAction::GetStringProperty(long nPropID, CStringW& rstrValue, BOOL bEvaluateProperty /* = FALSE */)
{
	rstrValue.Empty();
	CComQIPtr<IVCPropertyContainer> spPropCntr = m_pItem;
	RETURN_ON_NULL2(spPropCntr, FALSE);

	CComBSTR bstrVal;
	BOOL bRet = TRUE;
	{
		CComVariant var;
		bRet = (S_OK == spPropCntr->GetProp(nPropID, &var) );
		if (bRet && var.vt == VT_BSTR)
			bstrVal = var.bstrVal;
	}

	if (bRet && bEvaluateProperty)
	{
		CComBSTR bstrOut;
		bRet = SUCCEEDED(spPropCntr->Evaluate(bstrVal, &bstrOut));
		rstrValue = bstrOut;
	}
	else
		rstrValue = bstrVal;

	return bRet;
}

void CBldAction::GetItemFileName(CStringW& rstrName)
{
	rstrName.Empty();

	CComBSTR bstrName;
	if (m_pItem == NULL || FAILED(m_pItem->get_ItemFileName(&bstrName)))
		return;

	rstrName = bstrName;
}

HRESULT CBldAction::AddOutputFromFileName(CStringW& rstrFileName, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, 
	CDirW* pDirBase, BOOL fWithAction, BOOL fMakeItRelativeToProject, long nErrPropID, IVCToolImpl* pTool)
{
	// create a path for this filename and add it as an output
	CPathW tp;
	BOOL fContinue = TRUE;
	CStringW strErrFileName;
	fContinue = tp.CreateFromDirAndFilename(*pDirBase, rstrFileName);
	if (!fContinue && fMakeItRelativeToProject)
	{
		CDirW dirBaseProj;
		CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
		if (m_pItem == NULL)
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
		CComBSTR bstrProjDir;
		if (FAILED(spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir)))	// should never have macros in it
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
		CStringW strProjDir = bstrProjDir;
		fContinue = dirBaseProj.CreateFromKnown(strProjDir);
		if (fContinue)
			fContinue = tp.CreateFromDirAndFilename(dirBaseProj, rstrFileName);
		else if (nErrPropID > 0)
			strErrFileName = strProjDir;
	}

	if (fContinue)
	{
		CStringW strDefExtension = bstrDefExtension;
		tp.ChangeExtension (strDefExtension);
		tp.GetActualCase(TRUE);
		return AddOutput((const CPathW *)&tp, pEC, fWithAction, TRUE, nErrPropID, pTool);
	}
	else if (nErrPropID > 0 && strErrFileName.IsEmpty())
		strErrFileName = rstrFileName;

	CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
	InformUserAboutBadFileName(pEC, spPropContainer, pTool, nErrPropID, strErrFileName);
	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CBldAction::AddOutputFromFileName(BSTR bstrFileName, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, 
	BSTR bstrDirBase, VARIANT_BOOL fWithAction, long nErrPropID, IVCToolImpl* pTool)
{
	CDirW dirBase;
	if (!dirBase.CreateFromKnown(bstrDirBase))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	CStringW strFileName = bstrFileName;
	return FinishAddOutputFromID(strFileName, pEC, FALSE, bstrDefExtension, dirBase, NULL, fWithAction == VARIANT_TRUE, 
		nErrPropID, pTool);
}

STDMETHODIMP CBldAction::AddOutputInSubDirectory(BSTR bstrSubDirectory, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, 
	BSTR bstrDirBase, BSTR bstrDefFilename, long nEnablePropId, VARIANT_BOOL fWithAction, long nErrPropID, IVCToolImpl* pTool)
{
	// First check the enabling prop
	if (!EnabledOutput(nEnablePropId))
		return S_OK;

	CDirW dirBase;
	if (!dirBase.CreateFromKnown(bstrDirBase))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	CStringW strSubDirectory = bstrSubDirectory;
	return FinishAddOutputFromID(strSubDirectory, pEC, TRUE, bstrDefExtension, dirBase, bstrDefFilename,
		fWithAction == VARIANT_TRUE, nErrPropID, pTool);
}

STDMETHODIMP CBldAction::AddOutputFromID(long nFileNameId, IVCBuildErrorContext* pEC, BSTR bstrDefExtension, BSTR bstrDirBase, 
	BSTR bstrDefFilename, long nEnablePropID, VARIANT_BOOL fWithAction, IVCToolImpl* pTool)
{
	// First check the enabling prop
	if (!EnabledOutput(nEnablePropID))
		return S_OK;

	CDirW dirBase;
	if (!dirBase.CreateFromKnown(bstrDirBase))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	// Output filename? 
	CStringW strFileName;
	GetStringProperty(nFileNameId, strFileName, TRUE);
	return FinishAddOutputFromID(strFileName, pEC, FALSE, bstrDefExtension, dirBase, bstrDefFilename,
		fWithAction == VARIANT_TRUE, nFileNameId, pTool);
}

HRESULT CBldAction::FinishAddOutputFromID(CStringW& rstrFileName, IVCBuildErrorContext* pEC, BOOL fIsDirectoryLocation, 
	BSTR bstrDefExtension, CDirW& dirBase, BSTR bstrDefFilename, BOOL fWithAction, long nErrPropID, IVCToolImpl* pTool)
{
	BOOL fGotFileName = FALSE;
	BOOL fMakeItRelativeToProject = !rstrFileName.IsEmpty();

	// Output filename? 
	if (!rstrFileName.IsEmpty())
	{
		// Okay, the item has an apparently non empty-name entry.  See if it's a directory by checking 
		// last character.
		int len = rstrFileName.GetLength();
		const wchar_t * pc = (const wchar_t *) rstrFileName;
		pc = _wcsdec(pc, (wchar_t *)(pc+len));
	
		// need a filename?
		if (pc && (*pc != L'/' && *pc != L'\\') )
		{
			if (fIsDirectoryLocation)	// need to add that slash...
				rstrFileName += L"\\";
			else
				fGotFileName = TRUE;	// no ... it doesn't appear to be a dir.
		}
	}

	// got a filename?
	if (!fGotFileName)
	{
		// no, create a default..
		if (bstrDefFilename)
		{
			CStringW strDefFilename = bstrDefFilename;
			rstrFileName += strDefFilename;
		}
		else
		{
			CStringW strTmp;
			// just append and change extension later
			GetItemFileName(strTmp);
			rstrFileName += strTmp;
		}
	}

	return AddOutputFromFileName(rstrFileName, pEC, bstrDefExtension, &dirBase, fWithAction, fMakeItRelativeToProject, 
		nErrPropID, pTool);
}

// Used to add output files that don't use a property to determine their path -
// that is, output files which are co-resident with the input files generating
// them
STDMETHODIMP CBldAction::AddOutputFromDirectory(BSTR bstrDirBase, IVCBuildErrorContext* pEC, long nEnablePropId, BSTR bstrExt, 
	long nErrPropID, IVCToolImpl* pTool)
{
    CStringW strOutFile;
    CPathW   outFile;
    
    // Check whether the enabling property is present
    if (!EnabledOutput(nEnablePropId))
        return S_OK;

    // Formulate the path
	GetItemFileName(strOutFile);
	CDirW baseDir;
	if (!baseDir.CreateFromKnown(bstrDirBase))
	{
		CStringW strDirBase = bstrDirBase;
		CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
		InformUserAboutBadFileName(pEC, spPropContainer, pTool, nErrPropID, strDirBase);
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}
    if (!outFile.CreateFromDirAndFilename(baseDir, strOutFile))
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
		InformUserAboutBadFileName(pEC, spPropContainer, pTool, nErrPropID, strOutFile);
		return E_FAIL;
	}
	CStringW strExt = bstrExt;
    outFile.ChangeExtension(strExt);
    
    // Add the output file
    return AddOutput(&outFile, pEC, FALSE, TRUE, nErrPropID, pTool);
}

void CBldAction::InformUserAboutBadFileName(IVCBuildErrorContext* pEC, IVCPropertyContainer* pPropContainer, IVCToolImpl* pTool, 
	long nErrPropID, CStringW& strFile)
{
	if (nErrPropID < 0 || pEC == NULL || pTool == NULL)
		return;

	pTool->InformUserAboutBadFileName(pEC, pPropContainer, nErrPropID, strFile);
}

BOOL CBldAction::RefreshCommandOptions(BOOL& fChanged, BOOL fNoSet /* = FALSE */)
{
	BOOL fRet = TRUE;

	CBldAction* pTrgAction = GetTargetAction();

	// dirty command-line?
	if (!m_fDirtyCommand)
	{
		// if we've already done this return whether we changed
		if (m_wMarkRefCmdOpt == CBldAction::m_wActionMarker)
		{
			// what was the status of the last refresh?
			fChanged = m_fCmdOptChanged;
			return TRUE;
		}

		// don't if there's no possible change at our level
		if (!m_fPossibleOptionChange &&
			// and at the target-level if we are a file-level action
			(pTrgAction == (CBldAction *)NULL ||
			 (!pTrgAction->m_fPossibleOptionChange && !pTrgAction->m_fDirtyCommand))
		   )
		{
			// no change....
			fChanged = FALSE;
			return TRUE;
		}
	}

	BOOL fCheckTargetAction = FALSE;

	// get target actions from the tool
	CStringW strOldOptions(m_strOptions);

	// just make the check and not actually set the new command-line
	if (fNoSet)
	{
		// changed?

		// dirty command-line?
		if (m_fDirtyCommand)
			fChanged = m_fPossibleOptionChange;	// want to allow for forced option change *before* first build
		else
		{
			CStringW strDummyOptions; 
			fRet = m_pTool->GetCommandLineOptions(m_pItem, this, strDummyOptions);
			fChanged = strDummyOptions != strOldOptions;
		}
	}
	else
	{
		// changed?
		m_strOptions = L""; 
		fRet = m_pTool->GetCommandLineOptions(m_pItem, this, m_strOptions);

		// dirty command-line?
		if (m_fDirtyCommand)
		{
			fChanged = m_fPossibleOptionChange;
			m_fDirtyCommand = FALSE;	// we've got the command-line -> not dirty!
		}
		else
			fChanged = m_strOptions != strOldOptions;
	}

	if (!fNoSet && m_fPossibleOptionChange)
	{
		m_fPossibleOptionChange = FALSE;
		m_pItem->ClearDirtyCommandLineOptionsFlag();
	}

	// make sure we don't attempt to retrieve it again
	m_fCmdOptChanged = fChanged;
	m_wMarkRefCmdOpt = CBldAction::m_wActionMarker;

	return fRet;
}

BOOL CBldAction::AddScannedDep(int type, IVCBuildErrorContext* pEC, CStringW& strFile, int nLine, BOOL fScan)
{
	VSASSERT(m_pIncludeList != DEP_None, "About add a dependency to a non-dependency list...");

	// is this a system include? ignore?
	if( !g_SysInclReg.IsSysInclude(strFile) )
	{
		// need to allocate our include entry list?
		if (m_pIncludeList == DEP_Empty)
		{
			if ((m_pIncludeList = new CBldIncludeEntryList(5)) == (CBldIncludeEntryList *)NULL)
				return FALSE;	// failure
		}

		// construct the include entry
		CBldIncludeEntry * pEntry = new CBldIncludeEntry;
		pEntry->m_EntryType = type;	  	
		pEntry->m_nLineNumber = nLine;
		pEntry->m_bShouldBeScanned = fScan;
		pEntry->m_FileReference = strFile;

		pEntry->CheckAbsolute();	// check the absoluteness of scanned dep.

		// add this to ourselves
		m_pIncludeList->AddTail(pEntry);
	}

	return TRUE; // success
}

//
// Update dependency stuff for CBldAction
//
BOOL CBldAction::IsDepInfoInitialized()
{
	return 0 != m_LastDepUpdate.dwLowDateTime || 0 != m_LastDepUpdate.dwLowDateTime;
}


BOOL CBldAction::IsNewDepInfoAvailable(IVCBuildErrorContext* pEC)
{
	if (m_fIsProject)
	{
		RETURN_ON_NULL2(m_pTool, FALSE);
		return m_pTool->HasPrimaryOutput();	// rescan any project dependencies we might have for primary target tool
	}
	else if (NULL != m_pTool && m_pTool->HasDependencies(this))
	{
		//
		// Dependency information from minimal rebuild engine.
		// See if .obj date is newer than m_LastDepUpdate.
		//
		CBldFileRegSet* pRegSet = GetOutput(pEC);
		VSASSERT(NULL != pRegSet, "Failed to initialize output list (somewhere well before here)");
		if (NULL != pRegSet)
		{
			BldFileRegHandle frh = pRegSet->GetFirstFrh();
			if (NULL!=frh)
			{
				FILETIME ftime;

				VSASSERT(!g_bInProjClose, "Bad timestamp due to being in project close.");	// GetTimeProp will not return correct timestamp if closing project.
				frh->RefreshAttributes();

				BOOL bOK = frh->GetTimeProp(P_NewTStamp, ftime, FALSE);
				VSASSERT(bOK, "Failed to pick up time stamp property!");
				frh->ReleaseFRHRef();

				return ftime > m_LastDepUpdate;
			}
		}
	}
	else
	{
		//
		// Dependency information from scanner or NCB.
		//	See dependency file set date is later than m_LastDepUpdate.
		//

		VSASSERT(!g_bInProjClose, "Bad timestamp due to being in project close.");	// GetTimeProp will not return correct timestamp if closing project.

		// Check self
		// Note: GetFileRegHandle() doesn't ref count...yet.
		CComQIPtr<VCFileConfiguration> spFileCfg = m_pItem;
		CBldConfigurationHolder cfgHolder(m_pcrOur, spFileCfg, m_pcrOur->GetVCConfiguration());
		BldFileRegHandle frh = cfgHolder.GetFileRegHandle();
		VSASSERT(NULL!=frh, "Bad initialization way back when we created this action; frh cannot be NULL");
		FILETIME ftime;
		BOOL bOK = frh->GetTimeProp(P_NewTStamp, ftime);
		VSASSERT(bOK, "Failed to pick up time stamp property!");
		if (ftime > m_LastDepUpdate)
			return TRUE;

		// Check sources.
		bOK = GetSourceDep()->GetTimeProp(P_NewTStamp, ftime);
		VSASSERT(bOK, "Failed to pick up time stamp property!");
		if (ftime > m_LastDepUpdate)
			return TRUE;

		// Check dependencies.
		bOK = GetScannedDep()->GetTimeProp(P_NewTStamp, ftime);
		VSASSERT(bOK, "Failed to pick up time stamp property!");

		return ftime > m_LastDepUpdate;
	}
	return FALSE;
}

//
// Update dependency information if new information is available.
// Set bForceUpdate = TRUE to force update if updating has been turned off
// minimal rebuild info is not available.
BOOL CBldAction::UpdateDepInfo(IVCBuildErrorContext* pEC, BOOL bForceUpdate /* = FALSE */)
{
	// Not ready for bForceUpdate yet.
	VSASSERT(!bForceUpdate, "Not ready for bForceUpdate yet in UpdateDepInfo");

	// Don't update if new information is not available.
	if (!m_fDepMissing && !IsNewDepInfoAvailable(pEC))
		return FALSE;

	m_fDepMissing = FALSE;
	return ScanDependencies(pEC);
}

void CBldAction::UpdateDepInfoTimeStamp()
{
	GetSystemTimeAsFileTime(&m_LastDepUpdate);
}

HRESULT CBldAction::GetBuildEngineImplFromEC(IVCBuildErrorContext* pEC, IVCBuildEngineImpl** ppBldEngineImpl)
{
	CHECK_POINTER_NULL(ppBldEngineImpl);
	*ppBldEngineImpl = NULL;
	RETURN_ON_NULL2(pEC, S_FALSE);

	CComPtr<IDispatch> spDispBldEngine;
	pEC->get_AssociatedBuildEngine(&spDispBldEngine);
	CComQIPtr<IVCBuildEngineImpl> spBldEngineImpl = spDispBldEngine;
	*ppBldEngineImpl = spBldEngineImpl.Detach();
	return S_OK;
}

BOOL CBldAction::ScanDependencies(IVCBuildErrorContext* pEC, BOOL bUseAnyMethod /* = FALSE */, BOOL bWriteOutput /* = TRUE */ )
{
	BOOL bRetval = TRUE;

	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl;
	if (!m_fIsProject)
	{
		if (NULL == m_pcrOur || NULL == m_pTool || !m_pTool->HasDependencies(this))
		{
			CBldConfigCacheEnabler EnableCaching;

			if (m_pTool != NULL && m_pTool->CanScanForDependencies())
			{
				GetBuildEngineImplFromEC(pEC, &spBuildEngineImpl);
				if (spBuildEngineImpl)
				{
					CBldScannerCache* pScannerCache = NULL;
					spBuildEngineImpl->get_ScannerCache((void **)&pScannerCache);
					if (pScannerCache)
					{
						pScannerCache->BeginCache();
						bRetval = m_pTool->ScanDependencies(this, pEC, bWriteOutput);
						pScannerCache->EndCache();
					}
				}
			}

			return TRUE;
		}
	}

	CComPtr<IVCBuildAction> spAction;
	CVCStringWArray strArray;

	if (m_pTool->GetDependencies(this, strArray))
	{
		// See if dependencies have changed and then update if necessary
		BOOL bDirty = FALSE;
		if (m_pItem != NULL)
		{
			CComPtr<IVCBuildActionList> spActionList;
			if (FAILED(m_pItem->get_ActionList(&spActionList)) || spActionList == NULL)
				return FALSE;

			spActionList->Reset(NULL);
			while (TRUE)
			{
				CComPtr<IVCBuildAction> spThisAction;
				HRESULT hr = spActionList->Next(&spThisAction, NULL);
				if (hr != S_OK)
					break;
				if (spThisAction == NULL)
					continue;

				IVCToolImpl* pToolImpl = (m_pTool == NULL) ? NULL : m_pTool->GetVCToolImpl();
				BOOL bMatchesOldTool = FALSE;
				if (FAILED(spThisAction->MatchesOldTool(pToolImpl, &bMatchesOldTool)))
					continue;
				if (bMatchesOldTool)
				{
					spAction = spThisAction;
					break;
				}
			}

			RETURN_ON_NULL2(spAction, FALSE);
		}

		//
		// Determine if dependencies have changed.
		//
		{
			// remember previously scanned deps.
			// and also any old ones (so we can compare diffs)
			CVCMapPtrToPtr depsPrevious;

			// construct the map of current deps
			BldFileRegHandle frh = NULL;
			CBldFileRegSet* pfrs = NULL;
			
			if (SUCCEEDED(spAction->get_ScannedDependencies((void **)&pfrs)) && pfrs != NULL)
			{
				pfrs->InitFrhEnum();
				while ((frh = pfrs->NextFrh()) != (BldFileRegHandle)NULL)
				{
					depsPrevious.SetAt(frh, (void*)DEP_Scanned);
					frh->ReleaseFRHRef();
				}
			}

			bDirty = (strArray.GetSize() != depsPrevious.GetCount());
			if (!bDirty)
			{
				for (int i=0; i < strArray.GetSize(); i++)
				{
					CPathW path;
					BOOL bOK = path.Create(strArray[i]);
					VSASSERT(bOK, "Failed to create path for a dependency!");	
					BldFileRegHandle frh = CBldFileRegFile::LookupFileHandleByName(path.GetFullPath(), TRUE);
					if (NULL != frh)
						frh->ReleaseFRHRef();
					if (NULL == frh)
					{
						bDirty = TRUE;
						break;
					}
					else if (!depsPrevious.RemoveKey((void *)frh))
					{
						bDirty = TRUE;
						break;
					}
				}
				bDirty = bDirty || !depsPrevious.IsEmpty();
			}
		}

		if (bDirty)
		{
			CBldHoldRegRecalcs holdRecalcs(spAction, CBldHoldRegRecalcs::eScannedRegSet);	// don't do regset updates 'til we're done here
			// clear the action's dependencies list
			spAction->ClearScannedDependencies(pEC);

			// add new ones
			for (int i = 0; i < strArray.GetSize(); i++)
			{
				CPathW path;
				BOOL bOK = path.Create(strArray[i]);
				if (!bOK)	// not a real path
					continue;
				VSASSERT(bOK, "Failed to create path for a dependency!");	
				BldFileRegHandle frh = CBldFileRegFile::GetFileHandle(path, TRUE);
				if (NULL != frh)
				{
					spAction->AddScannedDependencyFromFrh((void *)frh, pEC);
					frh->ReleaseFRHRef();
				}
			}
		}

		spAction->UpdateDependencyInformationTimeStamp();

		bRetval = TRUE;
	}
	else if (bUseAnyMethod)
	{
		//
		// Try to use the scanner.  
		// review(tomse): May try to use NCB information if available.
		//
		CBldConfigCacheEnabler EnableCaching;

		if (m_pTool != NULL && m_pTool->CanScanForDependencies())
		{
			if (spBuildEngineImpl == NULL)
				GetBuildEngineImplFromEC(pEC, &spBuildEngineImpl);
			if (spBuildEngineImpl)
			{
				CBldScannerCache* pScannerCache = NULL;
				spBuildEngineImpl->get_ScannerCache((void **)&pScannerCache);
				if (pScannerCache)
				{
					pScannerCache->BeginCache();
					bRetval = m_pTool->ScanDependencies(this, pEC, bWriteOutput);
					pScannerCache->EndCache();
				}
			}
		}
	}
	else
	{
		bRetval = FALSE;
	}

	return bRetval;
}

STDMETHODIMP CBldAction::ScanToolDependencies(IVCToolImpl* pToolImpl, IVCBuildErrorContext* pEC, VARIANT_BOOL bWriteOutput)
{
	RETURN_INVALID_ON_NULL(pToolImpl);
	if (m_pItem == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	
	CComPtr<IVCBuildActionList> spActionList;
	if (FAILED(m_pItem->get_ActionList(&spActionList)) || spActionList == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

#ifdef _DEBUG
	{
		long cCount = 0;
		spActionList->get_Count(&cCount);
		// FUTURE: handle more than one tool on this source file
		VSASSERT(cCount == 1, "Cannot handle more than one tool on a source file at a time.");
	}
#endif	// _DEBUG

	// remember previously scanned deps. and also any old ones (so we can compare diffs)
	CVCMapPtrToPtr depsPrevious;

	// construct the map of current deps
	CComPtr<IVCBuildAction> spAction;
	spActionList->get_LastAction(&spAction);
	if (spAction == NULL)
	{
		VSASSERT(FALSE, "Failed to get last action!");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}

	BldFileRegHandle frh;
	CBldFileRegSet* pfrs = GetScannedDep();
	if (pfrs != NULL)
	{
		pfrs->InitFrhEnum();
		while ((frh = pfrs->NextFrh()) != (BldFileRegHandle)NULL)
		{
			depsPrevious.SetAt(frh, (void*)DEP_Scanned);
			frh->ReleaseFRHRef();
		}
	}

	// This marker is incremented once every call to this function. 
	// It is used to prevent processing of an include file that is seen
	// multiple times when scanning a particular compiland (.cpp). 
	s_nMyMarker++;

	// get the include path for this item
	CComBSTR bstrIncludePath;
	CComQIPtr<IVCPropertyContainer> spPropContainer = m_pItem;
	pToolImpl->GetAdditionalIncludeDirectoriesInternal(spPropContainer, &bstrIncludePath);

	// should temporarily change to the project directory so we
	// could scan appropriately (since relative SEARCH path should be from the project level)
	CComBSTR bstrProjPath;
	if (spPropContainer != NULL)
		spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjPath);	// should never have macros in it

	CStringW strProjPath = bstrProjPath;
	CCurDirW currentDir(strProjPath);

	// file's registry handle  
	BldFileRegHandle hndItemFile = NULL;
	m_pItem->get_FileRegHandle((void **)&hndItemFile);
	VSASSERT(hndItemFile != NULL, "All files must have reg handles! Is this file properly in the project and project config?");

	// directory of this file to be scanned
	CDirW dirFile; 
	dirFile.CreateFromPath(*g_FileRegistry.GetRegEntry(hndItemFile)->GetFilePath());
	
	// add our file name to the scan list to start the process:
	VARIANT_BOOL fDontScanItem = VARIANT_FALSE;
	CComQIPtr<VCFileConfiguration> spFileCfg = m_pItem;
	if (spFileCfg != NULL)
		spFileCfg->get_ExcludedFromBuild(&fDontScanItem);
	else
		fDontScanItem = VARIANT_FALSE;

	// list of FileRegHandles for files to be examined. Entries in this
	// list have their own references:
	CVCPtrList lToBeScanned; 	
	BldFileRegHandle hndFileReg = NULL;
	BldFileRegHandle hndIncludeEntryItem = NULL;

	if (fDontScanItem == VARIANT_FALSE)
		lToBeScanned.AddTail((void *) hndItemFile);

	CVCPtrList lstDeps;
	BOOL bDirty = FALSE;
	
	CBldScannerCache* pScannerCache = NULL;
	if (!lToBeScanned.IsEmpty() && pEC)
	{
		CComPtr<IDispatch> spDispBuildEngine;
		pEC->get_AssociatedBuildEngine(&spDispBuildEngine);
		CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = spDispBuildEngine;
		if (spBuildEngineImpl)
			spBuildEngineImpl->get_ScannerCache((void **)&pScannerCache);
	}

	while (!lToBeScanned.IsEmpty())	
	{
		hndFileReg = (BldFileRegHandle) lToBeScanned.GetHead();
		
		CBldIncludeEntryList * pEntryList = NULL;
		if (pScannerCache)
			pEntryList = pScannerCache->LookupFile(hndFileReg);
		if (!pEntryList)
		{
   			lToBeScanned.RemoveHead();	// scanned this file

			SetDepState(DEP_Empty);	// FUTURE: remove hack init.

			if (FAILED(pToolImpl->GenerateDependencies(spAction, (void *)hndFileReg, NULL)))
			{
				if (hndFileReg == hndItemFile)
					break;	// failure
				else
					continue;
			}

			pEntryList = GetIncludeDep();

			// FUTURE: remove hack init.
			// do we need an 'dummy' list?
			if (pEntryList == DEP_Empty)
				pEntryList = new CBldIncludeEntryList(5);

			if (pScannerCache)
  				pScannerCache->Add(hndFileReg, pEntryList);

			if (pEntryList == DEP_None)
			{
				continue;
			}

			// Go through an mark all the include entries with the path of the
			// file we scanned, so we can use it to check later
			CDirW dir;
	 		const CPathW * pPath = g_FileRegistry.GetRegEntry(hndFileReg)->GetFilePath();
			if (dir.CreateFromPath(*pPath))
			{
				for (VCPOSITION pos = pEntryList->GetHeadPosition (); pos != NULL ; )
				{
					CBldIncludeEntry * pEntry = (CBldIncludeEntry *) pEntryList->GetNext(pos);
					pEntry->m_strReferenceIn = *pPath;
					if (pEntry->m_EntryType & IncTypeCheckOriginalDir)
					{
						pEntry->m_OriginalDir = dir;
					}
		  		}
		  	}
			else
			{
				for (VCPOSITION pos = pEntryList->GetHeadPosition (); pos != NULL ; )
				{
					CBldIncludeEntry * pEntry = (CBldIncludeEntry *) pEntryList->GetNext(pos);
					pEntry->m_strReferenceIn = *pPath;
		  		}
		  	}

			// Certainly haven't seen this file, so add it to dep. list,
			// unless its the initial path:
			if (hndFileReg != hndItemFile)
			{
				// check to see if this dependency was here before
				UINT depType;
				// If we know we have to change the dependencies anyway (bDirty = TRUE)  
				// avoid doing these costly lookups
				if (!bDirty && depsPrevious.Lookup((void *)hndFileReg, (void *&)depType))
				{
					// may be dirty if the dep. is no longer same type
					// ie. missing or scanned
					if (hndFileReg->ExistsOnDisk())
					{
						if (depType == DEP_Missing)
							bDirty = TRUE;
					}
					else if (hndIncludeEntryItem != NULL)
					{
						CBldFileRegEntry* preg = g_FileRegistry.GetRegEntry(hndIncludeEntryItem);
						CPathW* pPath = (CPathW *)preg->GetFilePath();
						if (pPath && !pPath->ExistsOnDisk())
						{
							if (depType == DEP_Scanned)	
								bDirty = TRUE;
						}
					}

					// move it to the current dep list
					depsPrevious.RemoveKey((void *)hndFileReg);

				}
				else
				{
					bDirty = TRUE;
				}

				lstDeps.AddTail((void *)hndFileReg);
				hndFileReg->AddFRHRef();
			}						
			
			//  Mark list as seen by this file:
			pEntryList->m_LastTouch = s_nMyMarker;
		}
		else if (pEntryList == DEP_None)
		{
		    // this is a file that should not be listed
			lToBeScanned.RemoveHead();
			continue;	
		}
		else
		{
			lToBeScanned.RemoveHead();
			if (pEntryList->m_LastTouch == s_nMyMarker)
			{
				continue;				// Already went through this file.
			}
			else						// Add to list;
			{
				pEntryList->m_LastTouch = s_nMyMarker;
				if (hndFileReg != hndItemFile)
				{
					// check to see if this dependency was here before
					UINT depType;
					// If we know we have to change the dependencies anyway (bDirty = TRUE)  
					// avoid doing these costly lookups
					if (!bDirty && depsPrevious.Lookup((void *)hndFileReg, (void *&)depType))
					{
						// may be dirty if the dep. is no longer same type
						// ie. missing or scanned
						if (hndFileReg->ExistsOnDisk())
						{
							if (depType == DEP_Missing)
								bDirty = TRUE;
						}
						else if (hndIncludeEntryItem != NULL)
						{
							CBldFileRegEntry* preg = g_FileRegistry.GetRegEntry(hndIncludeEntryItem);
							CPathW* pPath = (CPathW *)preg->GetFilePath();
							if (pPath && !pPath->ExistsOnDisk())
							{
								if (depType == DEP_Scanned)	
									bDirty = TRUE;
							}
						}

						// move it to the current dep list
						depsPrevious.RemoveKey((void *)hndFileReg);

					}
					else
					{
						bDirty = TRUE;
					}

					// lstDeps takes the existing ref.
					lstDeps.AddTail(hndFileReg);
					hndFileReg->AddFRHRef();
				}
			}
		}

		//	Loop through all the files references by this file, and get the
		//	absolute path name from the reference.  Add this name to our
		//	dependencies list and to the to be scanned list if we haven't
		//	touched it before.
		VCPOSITION posEntryList = pEntryList->GetHeadPosition();
		CStringW strProjectDirectory;
		if (posEntryList != (VCPOSITION)NULL)
		{
			if (spPropContainer != NULL)
			{
				CComBSTR bstrProjDir;
				spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);	// should never have macros in it
				strProjectDirectory = bstrProjDir;
			}
		}
		while (posEntryList != (VCPOSITION)NULL)		
		{
			CBldIncludeEntry *pIncludeEntry = (CBldIncludeEntry *)pEntryList->GetAt(posEntryList);

			if (!pIncludeEntry->FindFile
									((const wchar_t *)bstrIncludePath,
									 dirFile,
									 (const wchar_t *)strProjectDirectory,
									 hndIncludeEntryItem, 
									 m_pItem, 
									 pScannerCache,
									 NULL))
			{
				if (bWriteOutput == VARIANT_TRUE)
				{
					// can't find dependency file so give an error message			
					CStringW str, strFormat;
					BOOL bOK = strFormat.LoadString(IDS_INCLUDE_NOT_FOUND);
					VSASSERT(bOK, "String not found!  Are we pointing at the right place to get our strings from?");

					str.Format(strFormat, pIncludeEntry->m_strReferenceIn, pIncludeEntry->m_nLineNumber,
						pIncludeEntry->m_FileReference);

					if (pEC != NULL)
					{
						CComBSTR bstr = str;
						pEC->AddLine( bstr );
					}
				}

				if (hndIncludeEntryItem == (BldFileRegHandle)NULL)
				{
					pIncludeEntry = (CBldIncludeEntry *)pEntryList->GetNext(posEntryList);
					continue;
				}
			}

			// Try to keep relative paths relative
			if (pIncludeEntry->m_FileReference[0] == L'.')
				g_FileRegistry.GetRegEntry(hndIncludeEntryItem)->SetRelative(TRUE);

			// If this is not a scannble entry, then just check to see if its
			// already a dependendent.  If its not, then add to dependencies
			// list:
			if (!pIncludeEntry->m_bShouldBeScanned)
			{
				VCPOSITION pos;
				for (pos = lstDeps.GetHeadPosition (); pos != NULL; )
				{
					hndFileReg = (BldFileRegHandle) lstDeps.GetAt(pos);
					if (hndFileReg == hndIncludeEntryItem)
						break;

					lstDeps.GetNext (pos);
				}

				// check to see if this dependency was here before
				UINT depType;
				if (!bDirty && depsPrevious.Lookup((void *)hndIncludeEntryItem, (void *&)depType))
				{
					// may be dirty if the dep. is no longer same type
					// ie. missing or scanned
					if (hndIncludeEntryItem->ExistsOnDisk())
					{
						if (depType == DEP_Missing)
							bDirty = TRUE;
					}
					else
					{
						CBldFileRegEntry* preg = g_FileRegistry.GetRegEntry(hndIncludeEntryItem);
						CPathW* pPath = (CPathW *)preg->GetFilePath();
						if (pPath && !pPath->ExistsOnDisk())
						{
							if (depType == DEP_Scanned)	
								bDirty = TRUE;
						}
					}

					// move it to the current dep list
					depsPrevious.RemoveKey((void *)hndIncludeEntryItem);
					lstDeps.AddTail((void *)hndIncludeEntryItem);
					hndIncludeEntryItem->AddFRHRef();
				}
 				else if (pos == (VCPOSITION)NULL && hndFileReg != hndIncludeEntryItem)
				{
					// move it to the current dep list
					lstDeps.AddTail((void *)hndIncludeEntryItem);
					hndIncludeEntryItem->AddFRHRef();
					bDirty = TRUE;
				}
			}
			else
			{
				lToBeScanned.AddTail((void *) hndIncludeEntryItem);
			}

			pEntryList->GetNext(posEntryList);

			hndIncludeEntryItem->ReleaseFRHRef();
		} 	// End of loop through pEntryList.

		if (posEntryList != NULL) 
			break; 	// Bailed from previous loop.
	
	}	// End of loop through lToBeScanned.

	//
	//	We know if we aborted because there are still files to be scanned:
	//
	if (!lToBeScanned.IsEmpty())
	{
		VCPOSITION vcpos = lstDeps.GetHeadPosition();
		while (vcpos != (VCPOSITION)NULL)
		{
			BldFileRegHandle frh = (BldFileRegHandle)lstDeps.GetNext(vcpos);
			frh->ReleaseFRHRef();
		}
		return E_FAIL;
	}

	// if we left entries in the depsPrevious map, free them
	if (depsPrevious.GetStartPosition() != (VCPOSITION)NULL)
		bDirty = TRUE;

	// if we dirtied the dependency list, dirty the project
	if (bDirty)
	{
		CBldHoldRegRecalcs holdRecalc(this, CBldHoldRegRecalcs::eScannedRegSet);

		// clear our dependencies list
		ClearScannedDependencies(pEC);

		// add new ones
		VCPOSITION vcpos = lstDeps.GetHeadPosition();
		while (vcpos != (VCPOSITION)NULL)
		{
			BldFileRegHandle frh = (BldFileRegHandle)lstDeps.GetNext(vcpos);
			AddScannedDependencyFromFrh(frh, pEC);
			frh->ReleaseFRHRef();
		}
	}
	else
	{
		VCPOSITION pos = lstDeps.GetHeadPosition();
		while (pos != (VCPOSITION)NULL)
		{
			BldFileRegHandle frh = (BldFileRegHandle)lstDeps.GetNext(pos);
			frh->ReleaseFRHRef();
		}
	}
	UpdateDependencyInformationTimeStamp();

	return S_OK;
}

void CBldAction::MakeFilesDirty()
{
	if (m_frhInput)
		m_frhInput->MakeDirty();
	if (m_pSets)
		m_pSets->MakeFilesDirty(m_pregistry);
}
void CBldAction::CalcFileAttributes(BOOL fOn)
{
	if (m_frhInput)
		m_frhInput->UpdateAttributes();
	if (m_pSets)
		m_pSets->CalcFileAttributes(fOn);
}

HRESULT CBldAction::GetFileCollection(VCConfiguration* pProjCfg, IEnumVARIANT** ppFiles)
{
	CComPtr<IDispatch> pDispProj;
	HRESULT hr = pProjCfg->get_Project(&pDispProj);
	HR_RETURN_ON_FAIL_OR_NULL(pDispProj, hr);
	CComQIPtr<VCProject> pProj = pDispProj;
	HR_RETURN_ON_NULL(pProj, E_UNEXPECTED);

	CComQIPtr<IVCCollection> pColl;
	CComPtr<IDispatch> pDisp;
	hr = pProj->get_Files(&pDisp);
	pColl = pDisp;
	HR_RETURN_ON_FAIL_OR_NULL(pColl, hr);
	hr = pColl->_NewEnum(reinterpret_cast<IUnknown **>(ppFiles));
	HR_RETURN_ON_FAIL_OR_NULL(*ppFiles, hr);
	(*ppFiles)->Reset();
	return hr;
}

BOOL CBldAction::GetFileCfgForProjCfg(CComVariant& var, VCConfiguration* pProjCfg, VCFileConfiguration** ppFileCfg)
{
	if (var.vt != VT_UNKNOWN && var.vt != VT_DISPATCH)
	{
		VSASSERT(FALSE, "Bad element in file collection.");
		return FALSE;
	}
	IDispatch* pDispFile = var.pdispVal;
	CComQIPtr<IVCFileImpl> pFileImpl = pDispFile;
	RETURN_ON_NULL2(pFileImpl, FALSE);
	HRESULT hr = pFileImpl->GetFileConfigurationForProjectConfiguration(pProjCfg, ppFileCfg);
	if (hr != S_OK || *ppFileCfg == NULL)
		return FALSE;

	return TRUE;
}

BOOL CBldAction::GetFileCfgActions(VCFileConfiguration* pFileCfg, IVCBuildActionList** ppActions)
{
	CComQIPtr<IVCBuildableItem> spItem = pFileCfg;
	RETURN_ON_NULL2(spItem, FALSE);
	return (SUCCEEDED(spItem->get_ActionList(ppActions)));
}

BOOL IsRealProp(long id)
{
	switch (id)
	{
	case VCCFGID_IntrinsicAppliedStyleSheets:
	case VCCFGID_BuildBrowserInformation:
	case VCCFGID_AllOutputsDirty:
	case VCCFGID_PrimaryOutputDirty:
	case VCCFGID_AnyOutputDirty:
	case VCCFGID_AnyToolDirty:
	case VCCFGID_DirtyDuringBuild:
	case VCCLID_CmdLineOptionsDirty:
	case VCCLID_OutputsDirty:
	case VCCLID_ResolvedPdbName:
	case VCLINKID_DependentInputs:
	case VCLINKID_CmdLineOptionsDirty:
	case VCLINKID_OutputsDirty:
	case VCLINKID_LinkerCommandLineGenerated:
	case VCLIBID_DependentInputs:
	case VCLIBID_CmdLineOptionsDirty:
	case VCLIBID_OutputsDirty:
	case VCLIBID_LibCommandLineGenerated:
	case VCMIDLID_CmdLineOptionsDirty:
	case VCMIDLID_OutputsDirty:
	case VCRCID_CmdLineOptionsDirty:
	case VCRCID_OutputsDirty:
	case VCBSCID_RunBSCMakeTool:
	case VCBSCID_SuppressStartupBanner:
	case VCBSCID_OutputFile:
	case VCBSCID_CmdLineOptionsDirty:
	case VCBSCID_OutputsDirty:
	case VCCUSTID_CmdLineOptionsDirty:
	case VCCUSTID_OutputsDirty:
	case VCFCSTID_CmdLineOptionsDirty:
	case VCFCSTID_OutputsDirty:
	case PREBLDID_CmdLineOptionsDirty:
	case PRELINKID_CmdLineOptionsDirty:
	case POSTBLDID_CmdLineOptionsDirty:
	case VCNMAKEID_CmdLineOptionsDirty:
	case VCNMAKEID_OutputsDirty:
	case VCWEBID_CmdLineOptionsDirty:
	case VCWEBID_OutputsDirty:
	case VCDPLYID_CmdLineOptionsDirty:
	case XBOXDPLYID_CmdLineOptionsDirty:
	case XBOXIMAGEID_CmdLineOptionsDirty:
	case XBOXIMAGEID_OutputsDirty:
	case XBOXIMAGEID_ImageCommandLineGenerated:
		return FALSE;
	default:
		return TRUE;	// by default, everything is a real prop that can be saved in the .vcproj file
	}
}
BOOL IsBuildEvent(bldActionTypes buildType)
{
	switch (buildType)
	{
	case TOB_PreBuildEvent:
	case TOB_PreLinkEvent:
	case TOB_PostBuildEvent:
	case TOB_Deploy:
	case TOB_XboxDeploy:
		return TRUE;
	default:
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\ui_dll\src\vcpropobject.cpp ===
#include "stdafx.h"

#include "VCPropObject.h"

HRESULT CVCProjCfgProperties::CreateInstance(VCConfiguration* pConfig, IDispatch** ppProjCfgProperties)
{
	CComObject<CVCProjCfgProperties> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CVCProjCfgProperties>::CreateInstance(&pPrjObj);
	if (SUCCEEDED(hr))
	{
		pPrjObj->AddRef();
		pPrjObj->Initialize(pConfig);
	}
	*ppProjCfgProperties = pPrjObj;
	return hr;
}

void CVCProjCfgProperties::Initialize(VCConfiguration* pConfig)
{
	m_spConfig = pConfig;

	CComPtr<IDispatch> spDispDbgSettings;
	if (m_spConfig)
		m_spConfig->get_DebugSettings(&spDispDbgSettings);
	m_spDbgSettings = spDispDbgSettings;
}

STDMETHODIMP CVCProjCfgProperties::get_OutputDirectory(BSTR *Val)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_OutputDirectory(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_OutputDirectory(BSTR newVal)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_OutputDirectory(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_IntermediateDirectory(BSTR *Val)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_IntermediateDirectory(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_IntermediateDirectory(BSTR newVal)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_IntermediateDirectory(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_ConfigurationType(ConfigurationTypes* ConfigType)		// configuration type: application, DLL, etc.
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_ConfigurationType(ConfigType);
}

STDMETHODIMP CVCProjCfgProperties::put_ConfigurationType(ConfigurationTypes ConfigType)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_ConfigurationType(ConfigType);
}

STDMETHODIMP CVCProjCfgProperties::get_BuildBrowserInformation(VARIANT_BOOL* Bsc)	// build .bsc file
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_BuildBrowserInformation(Bsc);
}

STDMETHODIMP CVCProjCfgProperties::put_BuildBrowserInformation(VARIANT_BOOL Bsc)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_BuildBrowserInformation(Bsc);
}

STDMETHODIMP CVCProjCfgProperties::get_UseOfMFC(useOfMfc* useMfc)	// how are we using MFC?
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_UseOfMFC(useMfc);
}

STDMETHODIMP CVCProjCfgProperties::put_UseOfMFC(useOfMfc useMfc)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_UseOfMFC(useMfc);
}

STDMETHODIMP CVCProjCfgProperties::get_UseOfATL(useOfATL* useATL)	// how are we using ATL?
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_UseOfATL(useATL);
}

STDMETHODIMP CVCProjCfgProperties::put_UseOfATL(useOfATL useATL)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_UseOfATL(useATL);
}

STDMETHODIMP CVCProjCfgProperties::get_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL* UseCRT)	// does the user want to link with the static or dynamic CRT?
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_ATLMinimizesCRunTimeLibraryUsage(UseCRT);
}

STDMETHODIMP CVCProjCfgProperties::put_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL UseCRT)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_ATLMinimizesCRunTimeLibraryUsage(UseCRT);
}

STDMETHODIMP CVCProjCfgProperties::get_CharacterSet(charSet* optSetting)	// character set to use: Unicode, MBCS, default
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_CharacterSet(optSetting);
}

STDMETHODIMP CVCProjCfgProperties::put_CharacterSet(charSet optSetting)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_CharacterSet(optSetting);
}

STDMETHODIMP CVCProjCfgProperties::get_ManagedExtensions(VARIANT_BOOL* Managed)	// is this a managed C++ project?
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_ManagedExtensions(Managed);
}

STDMETHODIMP CVCProjCfgProperties::put_ManagedExtensions(VARIANT_BOOL Managed)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_ManagedExtensions(Managed);
}

STDMETHODIMP CVCProjCfgProperties::get_DeleteExtensionsOnClean(BSTR* Ext)	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_DeleteExtensionsOnClean(Ext);
}

STDMETHODIMP CVCProjCfgProperties::put_DeleteExtensionsOnClean(BSTR Ext)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_DeleteExtensionsOnClean(Ext);
}

STDMETHODIMP CVCProjCfgProperties::get_WholeProgramOptimization(VARIANT_BOOL* Optimize)	// perform whole program optimization on build more or less requires optimization turned on to be effective
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_WholeProgramOptimization(Optimize);
}

STDMETHODIMP CVCProjCfgProperties::put_WholeProgramOptimization(VARIANT_BOOL Optimize)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_WholeProgramOptimization(Optimize);
}

STDMETHODIMP CVCProjCfgProperties::get_Command(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_Command(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_Command(BSTR newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_Command(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_WorkingDirectory(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_WorkingDirectory(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_WorkingDirectory(BSTR newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_WorkingDirectory(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_CommandArguments(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_CommandArguments(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_CommandArguments(BSTR newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_CommandArguments(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_Attach(VARIANT_BOOL *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_Attach(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_Attach(VARIANT_BOOL newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_Attach(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_SQLDebugging(VARIANT_BOOL *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_SQLDebugging(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_SQLDebugging(VARIANT_BOOL newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_SQLDebugging(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_Remote(RemoteDebuggerType *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_Remote(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_Remote(RemoteDebuggerType newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_Remote(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_RemoteMachine(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_RemoteMachine(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_RemoteMachine(BSTR newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_RemoteMachine(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_DebuggerType(TypeOfDebugger *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_DebuggerType(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_DebuggerType(TypeOfDebugger newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_DebuggerType(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_RemoteCommand(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_RemoteCommand(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_RemoteCommand(BSTR newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_RemoteCommand(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_HttpUrl(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_HttpUrl(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_HttpUrl(BSTR newVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_HttpUrl(newVal);
}

STDMETHODIMP CVCProjCfgProperties::get_PDBPath(BSTR *Val)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->get_PDBPath(Val);
}

STDMETHODIMP CVCProjCfgProperties::put_PDBPath(BSTR NewVal)
{
	CHECK_ZOMBIE(m_spDbgSettings, IDS_ERR_CFG_ZOMBIE);
	return m_spDbgSettings->put_PDBPath(NewVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CVCFileCfgProperties::CreateInstance(VCFileConfiguration* pConfig, IDispatch** ppFileCfgProperties)
{
	CComObject<CVCFileCfgProperties> *pPrjObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CVCFileCfgProperties>::CreateInstance(&pPrjObj);
	if (SUCCEEDED(hr))
	{
		pPrjObj->AddRef();
		pPrjObj->Initialize(pConfig);
	}
	*ppFileCfgProperties = pPrjObj;
	return hr;
}

void CVCFileCfgProperties::Initialize(VCFileConfiguration* pConfig)
{
	m_spConfig = pConfig;
}

STDMETHODIMP CVCFileCfgProperties::get_ExcludedFromBuild(VARIANT_BOOL* ExcludedFromBuild)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->get_ExcludedFromBuild(ExcludedFromBuild);
}

STDMETHODIMP CVCFileCfgProperties::put_ExcludedFromBuild(VARIANT_BOOL ExcludedFromBuild)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);
	return m_spConfig->put_ExcludedFromBuild(ExcludedFromBuild);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.h ===
#ifndef __BLDHELPERS_H__
#define __BLDHELPERS_H__

#pragma once

#include <vccolls.h>
#include <path2.h>
#include <VCFileClasses.h>
#include "BuildLogging.h"
#include "bldspawner.h"

// classes in this header
class CTempMaker;
class CBldSpawner;
class CVCBuildStringCollection;
class CBldOptionList;

// classes used by this header 
class CBldFileRegSet;		// requires FileRegistry.h anywhere we actually use this...
class CDynamicBuildEngine;	// requires BuildEngine.h anywhere we actually use this...

#define FILE_RESPONSE	0
#define FILE_BATCH		1
#define FILE_TEMP		2
#define FILE_XML		3

// creating and deleting a list of temporary files
class CTempMaker
{
public:
	// FUTURE: pick better size? (prime)
	CTempMaker() : m_bMustBeNew(false) { m_Files.InitHashTable(17); }
	~CTempMaker();	

	BOOL CreateTempFile(CVCStdioFile*& pFile, CPathW& rPath, IVCBuildErrorContext* pEC, CBldCfgRecord* pCfgRecord,
		int fFileType = FILE_RESPONSE);
	BOOL CreateTempFileFromString(CStringW& str, CPathW& rPath, CDynamicBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, 
		CBldCfgRecord* pCfgRecord, int fFileType = FILE_RESPONSE);

	// Remove all the files from disk:
	void NukeFiles(IVCBuildErrorContext* pEC = NULL);

private:
	CMapPathWToPtr m_Files;
	CDirW m_DirTempPath;
	bool m_bMustBeNew;
	static unsigned long s_ulSeed;
};

///////////////////////////////////////////////////////////////////////////////
//
//	Class for spawning a process and invoking a tool.  Also, this is the global
//	reposititory about building/spawning state information:  
//
class CBldSpawner 
{
public:
	CBldSpawner();

	BOOL CanSpawn();

	//	Calls InitSpawn down in the IDE
	HRESULT InitSpawn(BOOL bHidden = FALSE);
	int DoSpawn(IVCCommandLineList* pCmds, CDirW& dir, CDynamicBuildEngine* pBldEngine, CBldCfgRecord* pCfgRecord, 
		BOOL fCheckForComspec = FALSE, BOOL fIgnoreErrors = FALSE, IVCBuildErrorContext* pEC = NULL, BOOL fAsyncSpawn = TRUE);

	void TermSpawn();
	void DoSpawnCancel();
	void ReInitSpawn();

	__inline BOOL SpawnActive() {return m_InitCount > 0 && !m_bHidden;}

	__inline BOOL HiddenSpawnActive() {return m_InitCount > 0 && m_bHidden;}

	BOOL UserStoppedBuild();

	UINT GetCodePage(IVCBuildErrorContext* pEC);

private:
	int WaitForSpawnTerm(BOOL bPump, BOOL *pbUserCancel);
	void FormatError(int nIDError, CStringW& strCmdLine, CStringW& rstrError);
	void IdleAndPump(HANDLE hEventEarlyOut, BOOL fIdleAndPump);
	BOOL OkToSpawn(IVCCommandLineList* pCmds);
	void BuildCommandLineList(IVCCommandLineList* pCmds, CVCStringWList& slCmds, CVCStringWList& slDesc);
	int HandleUserCancel(CDynamicBuildEngine* pBldEngine);
	void CreateSpawner(CDirW &dir);
	void ClearSpawner();
	void HandleCheckForComspec(CBldCfgRecord* pCfgRecord, CStringW& strCmdLine, int& nRetVal, int& iCmd);
	void DoActualSpawn(CVCStringWList& slSpawnCmds, CDynamicBuildEngine* pBldEngine, BOOL fUseConsoleCP, int& nRetval, 
		int& iCmd, BOOL& bUserCancel, BOOL& bSpawnFailed);
	int DetermineSpawnRetval(CVCStringWList& slSpawnCmds, CDynamicBuildEngine* pBldEngine, CBldCfgRecord* pCfgRecord, int& nRetval, 
		int& iCmd, BOOL& bUserCancel, BOOL& bSpawnFailed);
	
private:
	// OS command shell specification
	CStringW m_strComspec;

	BOOL m_bBuildTerminated;
	BOOL m_fUserStoppedBuild;

	// Count of requests for InitSpawn
	int	m_InitCount;

	// spawner object (defined in shell) used to actually run the build
	CBldConsoleSpawner *m_pSpawner;
	DWORD m_dwFileWarnings;
	DWORD m_dwFileErrors;
	CComPtr<IVCBuildErrorContext> m_pEC;

	// m_bHidden implies a spawn that is not noticeable by the user
	// and is automatically terminated before a regular spawn occurs
	// A hidden spawn is useful for Edit and Continue performance,
	// as it allows the compiler to preload the PCH while the user is
	// editing a file during a debugging session.
	BOOL m_bHidden;
};

/////////////////////////////////////////////////////////////////////////////
// CVCBuildStringCollection

class CVCBuildStringCollection : 
	IVCBuildStringCollection,
	public CComObjectRoot
{
public:
	CVCBuildStringCollection() : m_nIndex(0) {}
	static HRESULT CreateInstance(IVCBuildStringCollection** ppCollection, CVCBuildStringCollection** ppCollectionObj = NULL);

BEGIN_COM_MAP(CVCBuildStringCollection)
	COM_INTERFACE_ENTRY(IUnknown)
	COM_INTERFACE_ENTRY(IVCBuildStringCollection)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCBuildStringCollection) 

// IVCBuildStringCollection
public:
	STDMETHOD(Reset)();
	STDMETHOD(get_Count)(long *pVal);
	STDMETHOD(Next)(BSTR* pbstrElem);
	STDMETHOD(Add)(BSTR bstrVal);
	STDMETHOD(AddAtLocation)(long nLocation, BSTR bstrVal);	// add the element at the specified index; 1-based
	STDMETHOD(Remove)(long nLocation);	// remove the element at the specified index; 1-based
	STDMETHOD(Clear)();	// remove all elements
	STDMETHOD(RemoveDuplicates)(VARIANT_BOOL bIsPaths, VARIANT_BOOL bIsCaseSensitive);

public:
	CVCStringWArray m_strStrings;

protected:
	int m_nIndex;
};

class CBldTurnRegRecalcOff
{
public:
	CBldTurnRegRecalcOff(CBldFileRegSet* pRegSet);
	~CBldTurnRegRecalcOff();
protected:
	CBldFileRegSet* m_pRegSet;
	BOOL m_fOldOn;
};

// NOTE: no duplicates are allowed in the option list

typedef struct tagBldOptEl {
	BYTE cref;		// ref. count
	int cch;		// # of chars. in pch (incl. '\0')
	wchar_t pch[1];	// space for single terminator
} BldOptEl;

class  CBldOptionList
{
public:
	// ConstrucTORs
	CBldOptionList(wchar_t chJoin = L',', BOOL fUseDefJoins = TRUE, BOOL fAllowDupes = FALSE)
	{
		m_cchStr = 0;
		m_bAllowDuplicates = fAllowDupes; 
		SetJoinUsage(chJoin, fUseDefJoins);
	}

	CBldOptionList(const wchar_t * pch, wchar_t chJoin = L',', BOOL fUseDefJoins = TRUE, BOOL fAllowDupes = FALSE)
	{
		m_cchStr = 0;
		m_bAllowDuplicates = fAllowDupes; 
		SetJoinUsage(chJoin, fUseDefJoins); 
		SetString(pch);
	}

	__inline void SetJoinUsage(wchar_t chJoin = L',', BOOL fUseDefJoins = TRUE)
	{
		m_strJoin = (CStringW)chJoin + (fUseDefJoins ? L",;\t" : L"");
	}

	// DestrucTOR
	virtual ~CBldOptionList()
		{ Empty(); }

	void Empty();										// empty
	void GetString(CStringW& str);						// conversion
	void SetString(const wchar_t* pch);					// conversion
	__inline const CBldOptionList& operator=(CBldOptionList& optlst)	// assignment
	{
		Empty(); 
		Append(optlst); 
		return *this;
	}	
	void Append(const wchar_t* pch, int cch);			// element append
	void Append(CBldOptionList& optlst);				// list append
	__inline BOOL Exists(const wchar_t* pch)			// existence?
	{
		VCPOSITION posOurWord; 
		return m_bAllowDuplicates? FALSE : m_mapStrToPtr.Lookup(pch, (void *&)posOurWord);
	}

	// enumeration
	__inline VCPOSITION GetHeadPosition()
		{ return m_lstStr.GetHeadPosition(); }
	__inline wchar_t * GetNext(VCPOSITION & pos)
		{ return ((BldOptEl *)m_lstStr.GetNext(pos))->pch; }
	__inline int GetCount()
		{ return (int) m_lstStr.GetCount(); }

protected:
	// addition/deletion of elements using ref. counting
	void Add(BldOptEl* poptel);

	CStringW m_strJoin;					// our join chars
	CVCMapStringWToPtr	m_mapStrToPtr;	// our hash lookup
	CVCPtrList m_lstStr;				// our actual list
	int m_cchStr;						// total length of string (bytes, incl. join char. seps.)
	BOOL m_bAllowDuplicates;
};


extern BOOL GetItemOutputFile(IVCBuildAction* pBldAction, IUnknown* pItem, long nFileNameID,
	BldFileRegHandle& frh, const wchar_t * pcDefExtension, const CDirW* pBaseDir, BOOL bIsDefinitelyDir = FALSE);
extern BOOL GetItemOutputFile(IVCBuildAction* pBldAction, IUnknown* pItem, long nFileNameID,
	BldFileRegHandle& frh, const wchar_t * pcDefExtension, BSTR bstrDir, BOOL bIsDefinitelyDir = FALSE);

extern BOOL GetQuotedString(const wchar_t*& pBase, const wchar_t*& pEnd); 
	// Look through the string to find a quoted substring. On return
	// pBase points to first char after first pEnd points to last quote.
	// Return FALSE if < 2 quotes or 0 length substring.
extern BOOL BldFileNameMatchesExtension(LPCOLESTR szPath, const  wchar_t* pExtensions);
extern BOOL BldFileNameMatchesExtension(const CPathW* pPath, const wchar_t* pExtensions);

// some useful macros
#define CHECK_REQUIRED_VT(vt, vttype) \
	if ((vt) != (vttype)) \
	{	\
		VSASSERT(FALSE, "Wrong vt type on VARIANT"); \
		continue; \
	}
#define CHECK_REQUIRED_VT2(vt, vttype1, vttype2) \
	if ((vt) != (vttype1) && (vt) != (vttype2)) \
	{	\
		VSASSERT(FALSE, "Wrong vt type on VARIANT"); \
		continue; \
	}
#define CONTINUE_ON_NULL(val) \
	if ((val) == NULL) \
	{ \
		VSASSERT(FALSE, "NULL pointer in enumeration"); \
		continue; \
	}
#define VALID_CONTINUE_ON_NULL(val) \
	if ((val) == NULL) \
		continue; 
#define CONTINUE_ON_FAIL_OR_NULL(ptr, hr) \
	if ((val) == NULL || FAILED(hr)) \
	{ \
		VSASSERT(val != NULL, "NULL pointer in enumeration"); \
		VSASSERT(SUCCEEDED(hr), "Failed Next in enumeration"); \
		continue; \
	}
#define CONTINUE_ON_FAIL(hr) \
	if (FAILED(hr)) \
	{ \
		VSASSERT(FALSE, "Failed Next in enumeration"); \
		continue; \
	}
#define VOID_RETURN_ON_FAIL_OR_NULL(ptr, hr) \
	if ((ptr) == NULL || FAILED(hr)) \
	{ \
		VSASSERT(ptr != NULL, "Unexpected NULL pointer"); \
		VSASSERT(SUCCEEDED(hr), "Unexpected failure code"); \
		return; \
	}
#define VOID_RETURN_ON_NULL(ptr) \
	if ((ptr) == NULL) \
	{ \
		VSASSERT(FALSE, "Unexpected NULL pointer"); \
		return; \
	}

#define HR_RETURN_ON_FAIL_OR_NULL(ptr, hr) \
	if ((ptr) == NULL || FAILED(hr)) \
	{ \
		VSASSERT(ptr != NULL, "Unexpected NULL pointer"); \
		VSASSERT(SUCCEEDED(hr), "Unexpected failure code"); \
		return (hr); \
	}

#define HR_RETURN_ON_NULL(ptr, hr) \
	if ((ptr) == NULL) \
	{ \
		VSASSERT(FALSE, "Unexpected NULL pointer"); \
		return (hr); \
	}

#endif	// __BLDHELPERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldhelpers.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <vccolls.h>
#include "BuildEngine.h"
#include "msgboxes2.h"
#include "util2.h"
#include "vcprojectengine.h"
#include "BldThread.h"

// #define SHOW_SPAWNER_DIAGNOSTICS		// uncomment this if you want the ATLTRACE calls related to spawning in this file

#define MAX_PROCESS_SIZE 32768 - _MAX_PATH		// this is all the more characters the OS can handle in a single CreateProcess

CTestableSection g_sectionSpawner;

///////////////////////////////////////////////////////////////////////////////
CBldSpawner::CBldSpawner()
{
	m_pSpawner = NULL;
	m_InitCount = 0;
	m_bBuildTerminated = FALSE;

	m_bHidden = FALSE;
	m_fUserStoppedBuild = FALSE;
}

BOOL CBldSpawner::UserStoppedBuild()
{
	return m_fUserStoppedBuild;
}

BOOL CBldSpawner::CanSpawn()
{
	// Prevent access to spawner by other threads.
	CritSectionT cs(g_sectionSpawner);

	return(m_pSpawner == NULL || 
		// return TRUE if we have a hidden active spawn.
		// A hidden spawn will be implicitly terminated 
		// when a regular spawn request is made
		m_bHidden
		);
}

HRESULT CBldSpawner::InitSpawn(BOOL bHidden /* = FALSE */)
{
	if (bHidden) 
		VSASSERT(m_InitCount == 0, "can only init a hidden spawn once");

	m_bBuildTerminated = FALSE;

	if (!m_InitCount)
	{
		// our COMSPEC environment variable
		m_strComspec = L"command.com";

		CComBSTR bstrComspec;
		HRESULT hr = ::VCGetEnvironmentVariableW(L"COMSPEC", &bstrComspec);
		if( SUCCEEDED(hr) && bstrComspec.Length() > 0 )
		{
			// use this and normalise
			// REVIEW: What happens if there are quotes in the comspec already ?
			m_strComspec = L"\"";
			m_strComspec += bstrComspec;
			m_strComspec += L"\"";
			m_strComspec.MakeLower();
		}
		m_InitCount++;
	}

	return S_OK;
}

// implemented somewhere below
extern void GetFirstFile(CStringW&, CStringW&, CStringW&);

#define szVCSpawnEchoCmd	L"~vcecho!"
#ifdef NO	// don't bother showing spawn time anymore
#define szVCSpawnTimeCmd	L"~vctime!"
#endif	// NO

// Note the the integer error codes returned by this function are
// actually	 exit codes of NTSPAWN.	 Look there if you want to know
// what they mean.
int CBldSpawner::DoSpawn(IVCCommandLineList* pCmds, CDirW &dir, CDynamicBuildEngine* pBldEngine, CBldCfgRecord* pCfgRecord,
	BOOL fCheckForComspec, BOOL fIgnoreErrors, IVCBuildErrorContext* pEC, BOOL fAsyncSpawn)
{
	// create the spawner object here--InitSpawn() not called for every DoSpawn()
	VSASSERT(m_pSpawner == NULL, "Can only have one spawn in progress at a time.");
	VSASSERT(!fIgnoreErrors, "Spawner does not support ability to ignore errors."); // not supported

	if (!OkToSpawn(pCmds))
		return 0;

	m_pEC = pEC;
	BOOL fUseConsoleCP;
	{	// block just so we don't use the VARIANT_BOOL version anywhere else but here...
		VARIANT_BOOL bUseConsoleCP;
		pCmds->get_UseConsoleCodePageForSpawner(&bUseConsoleCP);
		fUseConsoleCP = (bUseConsoleCP == VARIANT_TRUE);
	}

	// Just join all the lists together for now.
	// NOTE this must be changed to support parrallel stuff.
	CVCStringWList slCmds;
	CVCStringWList slDesc;
	BuildCommandLineList(pCmds, slCmds, slDesc);

	if (pBldEngine->m_bUserCanceled)
		return HandleUserCancel(pBldEngine);

	// two words
	// - loword == return value
	// - hiword == command that returned the value
	int nRetval = 0;
	int iCmd = 1;

	int nMaxCmdLen = MAX_PROCESS_SIZE;
	CVCStringWList slSpawnCmds;

	BOOL bUserCancel = FALSE;
	BOOL bSpawnFailed = FALSE;
	BOOL bFinished = FALSE;
	BOOL bFirst = TRUE;
	m_fUserStoppedBuild = FALSE;

	VCPOSITION posCmd = slCmds.GetHeadPosition();
	VCPOSITION posDesc = slDesc.GetHeadPosition();
	VCPOSITION posCmdLast = posCmd;
	VCPOSITION posDescLast = posDesc;
	while (!bFinished && !nRetval && !bUserCancel && !bSpawnFailed)
	{
		CreateSpawner(dir); 

		slSpawnCmds.RemoveAll();
		nRetval = 0;
		iCmd = 1;
		int nCurrentLen = 0;

		BOOL bContinue = TRUE;
		while (posCmd != (VCPOSITION)NULL && bContinue)
		{
			posCmdLast = posCmd;
			CStringW& strCmdLine = slCmds.GetNext(posCmd);

			// check to see if we need to prefix with a comspec?
			if (fCheckForComspec)
				HandleCheckForComspec(pCfgRecord, strCmdLine, nRetval, iCmd);

			// add the description
			// as '~vcecho<desc>'
			CStringW strDescLine = szVCSpawnEchoCmd;
			if (fUseConsoleCP)
				strDescLine += L"c";	// tell vcspawn we want the description back in the console CP
			else
				strDescLine += L"s";	// tell vcspawn we want the description back in the system CP
			posDescLast = posDesc;
			strDescLine += slDesc.GetNext(posDesc);

			int nCmdLen = strCmdLine.GetLength();
			int nDescLen = strDescLine.GetLength();

			bContinue = (nCurrentLen + nCmdLen + nDescLen + 2 /* for sep chars */ < nMaxCmdLen);
			if (bContinue)
			{
				slSpawnCmds.AddTail(strDescLine);	// first, add the description
				slSpawnCmds.AddTail(strCmdLine);	// now, add the command
				nCurrentLen += nCmdLen + nDescLen + 2;
			}
			else if (iCmd == 1) // hmmm, didn't get at least one command on the list
				slSpawnCmds.AddTail(strCmdLine);	// give 'em at least the command line we want run...
			else
			{
				posCmd = posCmdLast;
				posDesc = posDescLast;
			}

			// index of the next command
			iCmd += 2;
		}
		bFinished = (posCmd == (VCPOSITION)NULL);

		// already failed the execute in pre-check above?
		if (nRetval)
			ClearSpawner();
		else
			DoActualSpawn(slSpawnCmds, pBldEngine, fUseConsoleCP, nRetval, iCmd, bUserCancel, bSpawnFailed);
	}

	return DetermineSpawnRetval(slSpawnCmds, pBldEngine, pCfgRecord, nRetval, iCmd, bUserCancel, bSpawnFailed);
}

void CBldSpawner::BuildCommandLineList(IVCCommandLineList* pCmds, CVCStringWList& slCmds, CVCStringWList& slDesc)
{
	pCmds->Reset();
	HRESULT hr = S_OK;
	while (hr == S_OK)
	{
		CComPtr<IVCCommandLine> pCmd;
		hr = pCmds->Next(&pCmd);
		BREAK_ON_DONE(hr);
		CComBSTR bstrCmdLine;
		HRESULT hr1 = pCmd->get_CommandLineContents(&bstrCmdLine);
		CONTINUE_ON_FAIL(hr1);
		CComBSTR bstrDescription;
		hr1 = pCmd->get_Description(&bstrDescription);
		CONTINUE_ON_FAIL(hr1);
		CStringW strCmdLine = bstrCmdLine;
		CStringW strDescription = bstrDescription;
		slCmds.AddTail(strCmdLine);
		slDesc.AddTail(strDescription);
	}
	pCmds->RemoveAll();

	VSASSERT(slCmds.GetCount() == slDesc.GetCount(), "Need to make sure number of commands and number of descriptions match.");
}

BOOL CBldSpawner::OkToSpawn(IVCCommandLineList* pCmds)
{
	RETURN_ON_NULL2(pCmds, FALSE);

	long cCmds = 0;
	pCmds->get_Count(&cCmds);
	return (cCmds > 0);
}

int CBldSpawner::HandleUserCancel(CDynamicBuildEngine* pBldEngine)
{
	pBldEngine->InformUserCancel();
	TermSpawn();
	return -2;
}

void CBldSpawner::CreateSpawner(CDirW &dir)
{
	// Prevent access to spawner by other threads.
	CritSectionT cs(g_sectionSpawner);

	m_pSpawner = new CBldConsoleSpawner(&m_pSpawner);

	BOOL bOK = m_pSpawner->InitializeSpawn(dir, FALSE, FALSE, m_pEC);
	VSASSERT(bOK, "Failed to initialize spawner!");
}

void CBldSpawner::ClearSpawner()
{
	// Prevent access to spawner by other threads.
	CritSectionT cs(g_sectionSpawner);

	if (m_pSpawner == NULL)
		return;

	delete m_pSpawner;
	m_pSpawner = NULL;
}

void CBldSpawner::HandleCheckForComspec(CBldCfgRecord* pCfgRecord, CStringW& strCmdLine, int& nRetval, int& iCmd)
{
	// split into command and arguments
	CStringW strCaller, strArgs;
	GetFirstFile(strCmdLine, strCaller, strArgs);

	// found this command?
	wchar_t * psz, szCmdPath[_MAX_PATH + 1];
	BOOL fGotPath = SearchPathW(NULL, strCaller, L".exe", _MAX_PATH, szCmdPath, &psz);
	if (!fGotPath)
	{
		wcscpy(szCmdPath, strCaller);	// we failed, so just use the name
		if (m_pEC)
		{
			CStringW strCaller2 = strCaller;
			if (strCaller != strCaller2)	// uh, oh, conversion problem...
			{
				CStringW strMsg;
				strMsg.Format(IDS_ERR_UNICODE_PATH_PRJ0024, strCaller);
				CVCProjectEngine::AddProjectError(m_pEC, strMsg, L"PRJ0024", pCfgRecord);
			}
		}
	}

	// is this a GUI command? (assume no if not found)
	BOOL fIsGUI = FALSE;
	BOOL fUseComSpec = TRUE;
	if (fGotPath)
	{
		WORD wSubSystem;
		WORD wExeType = (WORD)GetExeType(szCmdPath, &wSubSystem);

		fIsGUI = wExeType == EXE_WIN || ((wExeType == EXE_NT) && (wSubSystem == IMAGE_SUBSYSTEM_WINDOWS_GUI));
		fUseComSpec = wExeType == EXE_NONE || wExeType == EXE_FAIL;
	}

	// make sure not executing command shell
	BOOL fIsShell = FALSE;
	if (!fIsGUI)
	{
		CPathW pathComspec;
		if( pathComspec.Create(m_strComspec) )	
		{
			CStringW strCmdPathTmp = szCmdPath;		
			strCmdPathTmp.MakeLower();
			fIsShell = wcsstr(strCmdPathTmp, pathComspec) != NULL;
			fUseComSpec = fUseComSpec && !fIsShell;
		}
		else if (m_pEC)
		{
			// hmmmm, Unicode problem, maybe?
			// REVIEW: this is a weird test. Do we need it ?
			CStringA strTmpA = m_strComspec;
			CStringW strTmpW = strTmpA;
			if (strTmpW != m_strComspec)
			{
				CStringW strMsg;
				strMsg.Format(IDS_ERR_UNICODE_PATH_PRJ0024, m_strComspec);
				CVCProjectEngine::AddProjectError(m_pEC, strMsg, L"PRJ0024", pCfgRecord);
			}
		}
	}

	// use the command-spec if we have re-direction chars.
	fUseComSpec = fUseComSpec || (strCmdLine.FindOneOf(L"<>|&^") != -1);

	// don't allow spawning just the shell!
	if (fIsShell && strArgs.IsEmpty())
	{
		// fail the execute
		// make a note + index of command for multi-commands
		nRetval = 1 | (iCmd << 16);
	}

	// need to prefix with comspec?
	else if (fUseComSpec)
	{
		strCmdLine = szCmdPath;
		strCmdLine += L" ";
		strCmdLine += strArgs;
	}
}

void CBldSpawner::DoActualSpawn(CVCStringWList& slSpawnCmds, CDynamicBuildEngine* pBldEngine, BOOL fUseConsoleCP, 
	int& nRetval, int& iCmd, BOOL& bUserCancel, BOOL& bSpawnFailed)
{
	{
		// Prevent access to spawner by other threads.
		CritSectionT cs(g_sectionSpawner);

		if (m_pSpawner)
			m_pSpawner->m_hNotifyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	}
	if (!m_pSpawner || !m_pSpawner->PerformSpawnMultiple(&slSpawnCmds, pBldEngine, fUseConsoleCP))
	{
		bSpawnFailed = TRUE;
	}
	else
	{
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("DoActualSpawn: About to wait for hNotifyEvent\n");
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		BOOL bDoIdleAndPump = FALSE;
		if (m_pEC)
		{
			CComPtr<IDispatch> spDispBuildEngine;
			m_pEC->get_AssociatedBuildEngine(&spDispBuildEngine);
			CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = spDispBuildEngine;
			if (spBuildEngineImpl)
				spBuildEngineImpl->get_DoIdleAndPump(&bDoIdleAndPump);
		}
		if (m_pSpawner && m_pSpawner->m_hNotifyEvent)
			IdleAndPump(m_pSpawner->m_hNotifyEvent, bDoIdleAndPump);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("DoActualSpawn: Finished waiting for hNotifyEvent\n");
#endif	// SHOW_SPAWNER_DIAGNOSTICS

		{
			// Prevent access to spawner by other threads.
			CritSectionT cs(g_sectionSpawner);

			if (m_pSpawner)
				nRetval = m_pSpawner->m_dwTermStatus;
		}
					
		// check to see if user cancelled the build
		if (WaitForSingleObject(m_pSpawner->m_hCancelEvent, 0) == WAIT_OBJECT_0)
			bUserCancel = TRUE;
		
		HANDLE hProcess = GetCurrentProcess();
		HANDLE hThread = NULL;
		BOOL bOK;
		{
			// Prevent access to spawner by other threads.
			CritSectionT cs(g_sectionSpawner);

			bOK = DuplicateHandle(hProcess, m_pSpawner->m_hWaitThread, hProcess, &hThread, DUPLICATE_SAME_ACCESS, TRUE, 
				DUPLICATE_SAME_ACCESS);
			VSASSERT(bOK, "Failed to duplicate handle for spawner wait thread!");
#ifdef SHOW_SPAWNER_DIAGNOSTICS
			ATLTRACE("DoActualSpawn: Set hCleanEvent\n");
#endif	// SHOW_SPAWNER_DIAGNOSTICS
			SetEvent(m_pSpawner->m_hCleanEvent);
		}
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("DoActualSpawn: About to wait for hWaitThread\n");
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		WaitForSingleObject(hThread, INFINITE);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("DoActualSpawn: Finished waiting for  hWaitThread\n");
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		{
			// Prevent access to spawner by other threads.
			CritSectionT cs(g_sectionSpawner);
			bOK = CloseHandle(hThread);
			VSASSERT(bOK, "Failed to close handle for spawner wait thread!");
		}
		if( m_fUserStoppedBuild )
			m_InitCount=0;
	}
}

int CBldSpawner::DetermineSpawnRetval(CVCStringWList& slSpawnCmds, CDynamicBuildEngine* pBldEngine, CBldCfgRecord* pCfgRecord, 
	int& nRetval, int& iCmd, BOOL& bUserCancel, BOOL& bSpawnFailed)
{
	// unpack return value and index of command that failed
	// for multiple commands
	iCmd = (int)((nRetval >> 16) & 0xffff);
	nRetval = (int)(short)(nRetval & 0xffff);

	// why did we fail the execute?
	VCPOSITION pos = slSpawnCmds.FindIndex(iCmd);
	if (nRetval && pos != (VCPOSITION)NULL)
	{
		CStringW& strCmdLine = slSpawnCmds.GetAt(pos);
		// load the error string
		UINT nIDError;
		CComBSTR bstrPrjErrCode;
		if (nRetval == -1)
		{
			nIDError = IDS_FAIL_SPAWN_PRJ0003;
			bstrPrjErrCode = L"PRJ0003";
		}
		else if (bUserCancel)
		{
			pBldEngine->InformUserCancel();
			nRetval = -2;
			m_fUserStoppedBuild = FALSE;
			return nRetval;
		}
		else
		{
			long nError = 0;
			if (m_pEC)
				m_pEC->get_Errors( &nError );
			if( nError )
			{
				// we have already printed this error probably so bail now
				m_fUserStoppedBuild = FALSE;
				return nRetval;
			}
			nIDError = IDS_FAIL_EXECUTE_PRJ0002;
			bstrPrjErrCode = L"PRJ0002";
		}

		CStringW strErr;
		FormatError(nIDError, strCmdLine, strErr);

		m_fUserStoppedBuild = FALSE;
		CVCProjectEngine::AddProjectError(m_pEC, strErr, bstrPrjErrCode, pCfgRecord);
	}
	else if (bSpawnFailed)
	{
		nRetval = -1;	// since it obviously didn't get set some other way...
	}

	if (bUserCancel)
		nRetval = -2;

	m_fUserStoppedBuild = FALSE;
	return nRetval;
}

void CBldSpawner::FormatError(int nIDError, CStringW& strCmdLine, CStringW& rstrError)
{
	// Get end of exe name:
	const wchar_t * pchCmdLine = (const wchar_t *)strCmdLine;
	unsigned short nExeNameLen = 0;
	const wchar_t * pchEndQuote = 0;
	if (pchCmdLine[0] == L'"' && GetQuotedString(pchCmdLine, pchEndQuote)) {
		// ENC: handle quoted commands that may contain spaces
		// 12/22/97 georgiop [vs98 23180]
		nExeNameLen = (unsigned short)(pchEndQuote - pchCmdLine);
	}
	else while (pchCmdLine[nExeNameLen] != L'\0' &&
		   !iswspace(pchCmdLine[nExeNameLen])
		  )
	{
		nExeNameLen++;
	}

	CStringW strErr;
	BOOL bOK = strErr.LoadString(nIDError);
	VSASSERT(bOK, "Failed to load a string; are the resources initialized properly?");
		
	// format the error message
	rstrError.Format(strErr, nExeNameLen, nExeNameLen, pchCmdLine);
}

void CBldSpawner::TermSpawn()
{
//	Called at end of spawning session.
	if (--m_InitCount > 0) 
		return;

	m_InitCount = 0;
}

void CBldSpawner::DoSpawnCancel()
{
	VSASSERT (!m_bHidden, "DoSpawnCancel called from hidden spawn.");
	m_bBuildTerminated = TRUE;

//	VSASSERT(m_pSpawner != NULL, "Cannot cancel spawner if we did not start it to begin with...");
	m_fUserStoppedBuild = TRUE;
	{
		// Prevent access to spawner by other threads.
		CritSectionT cs(g_sectionSpawner);

		if (m_pSpawner)
			m_pSpawner->CancelSpawn();
		else
			TermSpawn();
	}
}

void CBldSpawner::ReInitSpawn()
{
//	Called after DoSpawnCancel to reinitialise the
//	cancelled spawner
	VSASSERT(!m_bHidden, "ReInitSpawn called from hidden spawn.");
	m_bBuildTerminated = FALSE;
	m_InitCount = 1;
}

// REVIEW: is this really needed anymore?  Apparently in the old shell it was (VS98 9177), but is that
// still relevant in VS7?  Maybe WaitForSingleObject is sufficient...
void CBldSpawner::IdleAndPump(HANDLE hEventEarlyOut, BOOL fIdleAndPump)
{
	// This is the essence of Idle and pump (without the idle part)
	if (fIdleAndPump)
	{
		while (::MsgWaitForMultipleObjects(1, &hEventEarlyOut, FALSE, INFINITE, QS_ALLEVENTS) == WAIT_OBJECT_0 + 1) 
		{
			// we have a message
			MSG msg;
			if (!::GetMessage(&msg, NULL, NULL, NULL))
			{
				continue;
			}

			::TranslateMessage(&msg);
			::DispatchMessage(&msg);
		}
	}
	else
	{
		WaitForSingleObject(hEventEarlyOut, INFINITE);
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------- CTempMaker ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////

unsigned long CTempMaker::s_ulSeed = 0;

CTempMaker::~CTempMaker()
{
	if (!m_Files.IsEmpty())
		NukeFiles();
}

BOOL CTempMaker::CreateTempFile(CVCStdioFile *&pFile, CPathW& rPath, IVCBuildErrorContext* pEC, 
	CBldCfgRecord* pCfgRecord, int fFileType /* =FILE_RESPONSE */)
{
	// Get the temp path if we don't alread have it:
	if (m_Files.IsEmpty())
	{
		BOOL bContinue = FALSE;
		if (pCfgRecord)
		{
			VCConfiguration* pProjCfg = pCfgRecord->GetVCConfiguration();	// not ref-counted
			CComQIPtr<IVCPropertyContainer> spPropContainer = pProjCfg;
			if (spPropContainer)
			{
				ConfigurationTypes configType = typeUnknown;
				spPropContainer->GetIntProperty(VCCFGID_ConfigurationType, (long *)&configType);
				switch (configType)
				{
				case typeApplication:
				case typeDynamicLibrary:
				case typeStaticLibrary:
					{
						CComBSTR bstrProjDir, bstrIntDir;
						spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);	// never contains macros
						spPropContainer->GetEvaluatedStrProperty(VCCFGID_IntermediateDirectory, &bstrIntDir);
						if (bstrIntDir.Length() > 2)	// need AT LEAST three characters to be valid...
						{
							if (bstrIntDir[0] != L'/' && bstrIntDir[0] != L'\\' && bstrIntDir[1] != L'/' && bstrIntDir[1] != L'\\')
							{	// don't allow UNC paths for temp files...
								CDirW dirProj;
								CPathW pathIntDir;
								if (dirProj.CreateFromKnown(bstrProjDir)
									&& pathIntDir.CreateFromDirAndFilename(dirProj, bstrIntDir)
									&& m_DirTempPath.CreateFromPath(pathIntDir, TRUE))
									bContinue = TRUE;
							}
						}
					}
					break;
//				case typeUnknown:
//				case typeGeneric:
				default:
					bContinue = FALSE;	// gonna need to use TEMP
					break;
				}
			}
		}
		if (!bContinue)	// fall back and try to use TEMP
		{
			bContinue = m_DirTempPath.CreateTemporaryName();
			m_bMustBeNew = true;
		}
		if (!bContinue)
		{
			if (pEC)
			{
				CComBSTR bstrError;
				bstrError.LoadString(IDS_COULD_NOT_GET_TEMP_PATH);
				pEC->AddInfo(bstrError);
			}
			// OS call failed, use CWD:
			if (!m_DirTempPath.CreateFromCurrent())
			{
				if (pEC)
				{
					CComBSTR bstrError;
					bstrError.LoadString(IDS_COULD_NOT_GET_CWD);
					pEC->AddInfo(bstrError);
				}
				return FALSE;
			}
		}
	}

	CStringW strPre, strExt, strName;
	switch(fFileType)
	{
	case FILE_RESPONSE:
		strPre = L"RSP";
		strExt = L".rsp";
		break;
	case FILE_BATCH:
		strPre = L"BAT";
		strExt = L".bat";
		break;
	case FILE_XML:
		strPre = L"XML";
		strExt = L".xml";
		break;
//	case FILE_TEMP:
	default:
		strPre = L"TMP";
		strExt = L".tmp";
	}

	s_ulSeed++;
	strName.Format(L"%s%.6X%s", strPre, s_ulSeed, strExt);
	if (!rPath.CreateFromDirAndFilename(m_DirTempPath, strName))
	{
		if (pEC)
		{
			CStringW strErr;
			strErr.Format(IDS_COULD_NOT_GET_TEMP_NAME_PRJ0005, (const wchar_t*)m_DirTempPath);
			CComBSTR bstrError = strErr;
			CVCProjectEngine::AddProjectError(pEC, bstrError, L"PRJ0005", pCfgRecord);
		}
		return FALSE;
	}
	if (m_bMustBeNew && rPath.ExistsOnDisk())
	{
		while (rPath.ExistsOnDisk())
		{
			s_ulSeed++;
			strName.Format(L"%s%.6X%s", strPre, s_ulSeed, strExt);
			if (!rPath.CreateFromDirAndFilename(m_DirTempPath, strName))
			{
				if (pEC)
				{
					CStringW strErr;
					strErr.Format(IDS_COULD_NOT_GET_TEMP_NAME_PRJ0005, (const wchar_t*)m_DirTempPath);
					CComBSTR bstrError = strErr;
					CVCProjectEngine::AddProjectError(pEC, bstrError, L"PRJ0005", pCfgRecord);
				}
				return FALSE;
			}
		}
	}

	CStringW strPathW;
	rPath.GetFullPath(strPathW);
	CStringA strPathA = strPathW;	// yes, ANSI -- 'cause CVCFile wants ANSI
	DWORD fOpen = CVCFile::modeWrite | CVCFile::modeCreate | CVCFile::typeText;
	pFile = new CVCStdioFile;	

	if (!pFile->Open(strPathA, fOpen, FILE_ATTRIBUTE_TEMPORARY))
	{
		if (pEC)
		{
			CStringW str;
			CComBSTR bstrErr;
			CStringW strPath2 = strPathA;
			if (strPath2 != strPathW)
			{
				str.Format(IDS_ERR_UNICODE_PATH_PRJ0024, strPathW);
				bstrErr = L"PRJ0024";
			}
			else
			{
				::VCMsgTextW(str, IDS_COULD_NOT_OPEN_TEMP_FILE_PRJ0006, rPath.GetFullPath());
				bstrErr = L"PRJ0006";
			}
			CVCProjectEngine::AddProjectError(pEC, str, bstrErr, pCfgRecord);
		}
		delete (pFile);
		return FALSE;
	}

	m_Files.SetAt(rPath, pFile);
	return TRUE;
}	

// Remove all the files from disk:
void CTempMaker::NukeFiles(IVCBuildErrorContext* pEC/*=NULL*/)
{
	CPathW cp;
	VCPOSITION pos;
	CVCStdioFile *pFile;

	for (pos = m_Files.GetStartPosition(); pos != NULL; )
	{
		m_Files.GetNextAssoc(pos, cp, (void *&)pFile);

		// Check that the file has already been closed:
		VSASSERT(pFile->m_hFile == CVCFile::hFileNull, "File isn't closed before nuking!");
		delete (pFile);

		if (!::DeleteFileW((const wchar_t *) cp))
		{
			CStringW str;
			::VCMsgTextW(str, cp, IDS_COULD_NOT_DELETE_TEMP_FILE);
			CComBSTR bstrInfo = str;
			pEC->AddInfo(bstrInfo);
		}
	}
	m_Files.RemoveAll();
}

BOOL CTempMaker::CreateTempFileFromString(CStringW& str, CPathW &rPath, CDynamicBuildEngine* pBuildEngine, 
	IVCBuildErrorContext* pEC, CBldCfgRecord* pCfgRecord, int fFileType /* = FILE_RESPONSE */)
{
	CVCStdioFile *pFile;
	if (!CreateTempFile(pFile, rPath, pEC, pCfgRecord, fFileType))
		return FALSE;
	BOOL bRetval;
	CStringW strCreate;
	strCreate.LoadString(IDS_CREATING_TEMPFILE);

	VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
	if (pBuildEngine)
		pBuildEngine->get_HaveLogging(&bHaveLogging);
	if (bHaveLogging == VARIANT_TRUE)
	{
		CStringW strTranslatedContents;
		// have to escape any '<' characters we see or they won't show in the build log properly
		int nLen = str.GetLength();
		int nLastBracket = -1;
		int nNextBracket = str.Find(L'<');
		if (nNextBracket < 0)	// nothing to escape
			strTranslatedContents = str;
		else
		{
			if (nNextBracket == 0)	// started with one
			{
				strTranslatedContents = L"&lt;";
				nLastBracket = 0;
				nNextBracket = str.Find(L'<', 1);
			}
			while (nNextBracket > 0)
			{
				CStringW strMid = str.Mid(nLastBracket+1, nNextBracket-nLastBracket-1);
				strTranslatedContents += strMid;
				strTranslatedContents += L"&lt;";
				nLastBracket = nNextBracket;
				nNextBracket = str.Find(L'<', nLastBracket+1);
			}
			if (nLastBracket < nLen-1)
				strTranslatedContents += str.Right(nLen-nLastBracket-1);
		}

		CStringW strContents;
		strContents.Format((const wchar_t *)strCreate, (const wchar_t *)rPath, (const wchar_t *)strTranslatedContents);
		CComBSTR bstrContents = strContents;
		pBuildEngine->LogTrace((int)eLogCommand, (BSTR)bstrContents);
	}

	CStringA strA;	// yes, ANSI -- 'cause we're writing an ANSI file
	BOOL bUsedDefault = FALSE;
	UINT iCodePage = pBuildEngine->GetCodePage(fFileType == FILE_BATCH);
	if (iCodePage)
	{
		int nLen = str.GetLength();
		wchar_t* szOriginal = str.GetBuffer(nLen+1);
		unsigned int buf_size = CVCProjectEngine::ConvertFromUnicodeMlang(iCodePage, TRUE, TRUE, szOriginal, nLen, NULL, 0, NULL);
		if (buf_size)
		{
			char* buffer = new char[buf_size+1];
			RETURN_ON_NULL2(buffer, FALSE);
			buffer[buf_size] = 0;

			// convert
			CVCProjectEngine::ConvertFromUnicodeMlang(iCodePage, TRUE, TRUE, szOriginal, nLen, buffer, buf_size, &bUsedDefault);
			strA = buffer;
			delete[] buffer;
		}
		str.ReleaseBuffer();
	}
	else
	{
		strA = str;
		CStringW strW = strA;	// checking for whether it translated back the same
		bUsedDefault = (str != strW);
	}
	if (bUsedDefault && pEC)
	{
		CStringW strMsg;
		CComBSTR bstrErr;
		switch (fFileType)
		{
		case FILE_BATCH:
			strMsg.Format(IDS_ERR_UNICODE_BAT_PRJ0025, (const wchar_t*)rPath, str);
			bstrErr = L"PRJ0025";
			break;
		case FILE_TEMP:
			strMsg.Format(IDS_ERR_UNICODE_TEMP_PRJ0028, (const wchar_t*)rPath, str);
			bstrErr = L"PRJ0028";
			break;
		case FILE_XML:
			strMsg.Format(IDS_ERR_UNICODE_XML_PRJ0035, (const wchar_t*)rPath, str);
			bstrErr = L"PRJ0035";
			break;
//		case FILE_RESPONSE:
		default:
			strMsg.Format(IDS_ERR_UNICODE_RSP_PRJ0026, (const wchar_t*)rPath, str);
			bstrErr = L"PRJ0026";
			break;
		}
		CVCProjectEngine::AddProjectError(pEC, strMsg, bstrErr, pCfgRecord);
	}

	bRetval = pFile->WriteString(strA);
	if (bRetval)
		pFile->Close();
	else
	{
		if (bHaveLogging)
		{
			CComBSTR bstrCmd;
			bstrCmd.LoadString(IDS_ERR_CREATE_TEMP_FILE);
			pBuildEngine->LogTrace((int)eLogCommand, (BSTR)bstrCmd);
		}
		pFile->Abort();
	}
	return bRetval;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CVCBuildStringCollection::CreateInstance(IVCBuildStringCollection** ppStrings, CVCBuildStringCollection** ppStringColl)
{
	CHECK_POINTER_NULL(ppStrings);
	*ppStrings = NULL;
	if (ppStringColl)
		*ppStringColl = NULL;

	CComObject<CVCBuildStringCollection> *pObj = NULL;
	HRESULT hr = CComObject<CVCBuildStringCollection>::CreateInstance(&pObj);
	if (SUCCEEDED(hr) && pObj != NULL)
	{
		CVCBuildStringCollection *pVar = pObj;
		if (pVar)
			pVar->AddRef();
		*ppStrings = pVar;
		if (ppStringColl)
			*ppStringColl = pVar;
	}
	return(hr);
}

STDMETHODIMP CVCBuildStringCollection::Reset() 
{ 
	m_nIndex = 0;
	return S_OK; 
}

STDMETHODIMP CVCBuildStringCollection::get_Count(long *pVal)
{ 
	CHECK_POINTER_NULL(pVal);
	*pVal = (long) m_strStrings.GetSize();
	return S_OK;
}

STDMETHODIMP CVCBuildStringCollection::Next(BSTR* pbstrElem)
{
	CHECK_POINTER_NULL(pbstrElem);
	*pbstrElem = NULL;
	if (m_nIndex == m_strStrings.GetSize())
		return S_FALSE;
	CStringW strElem = m_strStrings.GetAt(m_nIndex);
	m_nIndex++;
	*pbstrElem = strElem.AllocSysString();
	return S_OK;
}

STDMETHODIMP CVCBuildStringCollection::Add(BSTR bstrVal)
{
	m_strStrings.Add(bstrVal);
	return S_OK;
}

STDMETHODIMP CVCBuildStringCollection::AddAtLocation(long nLocation, BSTR bstrVal)
{	// add the element at the specified index; 1-based
	if (nLocation < 1)
		RETURN_INVALID();
	m_strStrings.InsertAt(nLocation-1, bstrVal);
	return S_OK;
}

STDMETHODIMP CVCBuildStringCollection::Remove(long nLocation)
{	// remove the element at the specified index; 1-based
	if (nLocation < 1)
		RETURN_INVALID();
	m_strStrings.RemoveAt(nLocation-1);
	return S_OK;
}

STDMETHODIMP CVCBuildStringCollection::Clear()	// remove all elements
{
	m_strStrings.RemoveAll();
	return S_OK;
}

STDMETHODIMP CVCBuildStringCollection::RemoveDuplicates(VARIANT_BOOL bIsPaths, VARIANT_BOOL bIsCaseSensitive)
{
	// weed out any dupes we may have in the list
	CVCMapStringWToStringW mapStrings;
	CStringW strString, strStringLower;
	INT_PTR cStrings = m_strStrings.GetSize();
	for (INT_PTR idx = 0; idx < cStrings; idx++)
	{
		strString = m_strStrings.GetAt(idx);
		if (strString.IsEmpty())
			continue;

		strStringLower = strString;
		if (!bIsCaseSensitive)
			strStringLower.MakeLower();
		mapStrings.SetAt(strStringLower, strString);
	}
	m_strStrings.RemoveAll();

	VCPOSITION pos = mapStrings.GetStartPosition();
	while (pos != (VCPOSITION)NULL)
	{
		mapStrings.GetNextAssoc(pos, strStringLower, strString);
		m_strStrings.Add(strString);
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////

CBldTurnRegRecalcOff::CBldTurnRegRecalcOff(CBldFileRegSet* pRegSet)
{ 
	m_pRegSet = pRegSet; 
	if (pRegSet != NULL)
		m_fOldOn = m_pRegSet->CalcAttributes(FALSE);
	else
		m_fOldOn = FALSE;
}

CBldTurnRegRecalcOff::~CBldTurnRegRecalcOff()
{ 
	if (m_pRegSet != NULL)
		m_pRegSet->CalcAttributes(m_fOldOn); 
}

//////////////////////////////////////////////////////////////////////////////
// implementation of the CBldOptionList class
#pragma intrinsic(memcpy)

void CBldOptionList::SetString(const wchar_t* pch)
{
	VSASSERT(pch != (const wchar_t *)NULL, "Trying to set the option list to a NULL string.");

	// empty the old one
	Empty();

	const wchar_t* rgchJoin = (const wchar_t *)m_strJoin;

	//
	// Use rgchJoinAndSpace to eliminate spaces surrounding separators.	 This is a quick
	// fix to prevent the usability problem of leading and trailing spaces in tokens. (Speed:49).
	//
	// NOTE: This fix will prevent the obscure but legal use of path names with leading spaces.
	//

	// allocate enough to copy grchJoin and append space.
	wchar_t* rgchJoinAndSpace = new wchar_t[wcslen(rgchJoin)+2];
	wcscpy(rgchJoinAndSpace,rgchJoin);
	wcscat(rgchJoinAndSpace,L" ");

	// skip leading join chars and spaces.
	while (*pch != L'\0' && wcschr(rgchJoinAndSpace, (unsigned int)(int)*pch) != (wchar_t *)NULL)	
		pch++;	// join chars assumed to be SBC

	// anything to do?
	if (*pch == L'\0')
	{
		delete [] rgchJoinAndSpace;
		return; // do nothing
	}

	wchar_t chVal, chJoin = m_strJoin[0];
	VSASSERT(chJoin != L'\0', "Trying to use \0 as separator character in build option list");

	BOOL fQuoted = FALSE;
	const wchar_t * pchWord = pch;
	size_t cch, cchWord = 0;
	do
	{
		chVal = *pch;

		// are we quoted?
		if (chVal == L'"')
			fQuoted = !fQuoted;

		// look for a non-quoted join char, or terminator
		if (chVal == L'\0' || (wcschr(rgchJoin, chVal) != NULL && (chVal == L'\t' || !fQuoted)))
		{
			// skip any extra join chars (and spaces) with this one, ie. ' , '
			if (chVal != L'\0')
			{
				chVal = *(++pch);	// join chars assumed to be SBC
				while (chVal != L'\0' && wcschr(rgchJoinAndSpace, chVal) != NULL)
				{												
					pch++; chVal = *pch;	// join chars assumed to be SBC
				}
			}

			// Remove trailing blanks from pchWord.
			while (0 != cchWord && 0 == _wccmp(_wcsdec(pchWord, pchWord+cchWord), L" "))
				--cchWord;

			// do we have any word characters?
			if (cchWord != 0)	
				Append(pchWord, (int) cchWord);

			cchWord = 0;	// ready for start of next word
			pchWord = pch;
		}
		else
		{
			// skip non-join char
			cch = _wclen(pch);
			cchWord += cch; pch += cch;
		}
	}
	while (chVal != L'\0');

	delete [] rgchJoinAndSpace;
	return;
}

void CBldOptionList::GetString(CStringW& str)
{
	wchar_t chJoin = m_strJoin[0];
	VSASSERT(chJoin != L'\0', "Trying to use \0 as separator character in build option list.");

	// allocate our buffer
	wchar_t* pch;
	if (!m_cchStr ||	// empty string?
		(pch = new wchar_t[m_cchStr]) == (wchar_t *)NULL)
	{
		str = L""; // in case of error
		return;
	}

	wchar_t* pchWord = pch;
	VCPOSITION pos = m_lstStr.GetHeadPosition();
	VSASSERT(pos != (VCPOSITION)NULL, "Option list is empty.");
	for (;;)	// we'll break (more efficient!)
	{
		BldOptEl* poptel = (BldOptEl *)m_lstStr.GetNext(pos);

		int cch = poptel->cch;
		if( cch > 0 )
		{
			memcpy(pchWord, poptel->pch, cch*sizeof(wchar_t));
	
			if (pos != (VCPOSITION)NULL)
				pchWord[cch-1] = chJoin;	// join *not* terminate
			else
				break;	// terminate!
	
			pchWord += cch;
		}
	}

	// return string and then delete our local buffer
	str = pch;
	delete [] pch;
}

void CBldOptionList::Empty()
{
	// free-up our string memory
	VCPOSITION pos = m_lstStr.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		BldOptEl* poptel = (BldOptEl *)m_lstStr.GetNext(pos);
		poptel->cref--; // decr. the ref. count
		if (poptel->cref == 0)	// if zero, then free-up the element
			delete [] (BYTE *)poptel;
	}
	m_lstStr.RemoveAll();
	m_mapStrToPtr.RemoveAll();
}

void CBldOptionList::Add(BldOptEl* poptel)
{
	// put this into our list
	poptel->cref++; // bump. ref. count.
	VCPOSITION posOurWord = m_lstStr.AddTail((void *)poptel);
	m_cchStr += poptel->cch;

	// remember this for quick 'does string exist in list?' query
	// (in the case of dupes, we might nuke the old duplicate but that
	//	doesn't matter, it'll still solve its purpose)
	m_mapStrToPtr.SetAt(poptel->pch, (void *)posOurWord);
}

void CBldOptionList::Append(const wchar_t* pch, int cch)
{
	BldOptEl* poptel = (BldOptEl *)new BYTE[sizeof(BldOptEl) + cch*sizeof(wchar_t)];
	if (poptel == (BldOptEl *)NULL) return;

	// initialise with a ref. count of 1
	memcpy(poptel->pch, pch, cch*sizeof(wchar_t));
	poptel->pch[cch] = L'\0';
	poptel->cch = cch + 1;
	poptel->cref = 0;

	// can we add, ie. 
	// do we want to check for duplicates?
	if (!Exists(poptel->pch))
		Add(poptel);	// put this into our list
	else
		delete [] (BYTE *)poptel;	// duplicate
}

void CBldOptionList::Append(CBldOptionList & optlst)
{
	VCPOSITION pos = optlst.m_lstStr.GetHeadPosition();
	while (pos != NULL)
	{
		BldOptEl* poptel = (BldOptEl *)optlst.m_lstStr.GetNext(pos);
		if (!Exists(poptel->pch))
			Add(poptel);
	}
}

/////////////////////////////////////////////////////////////////////////////////

BOOL BldFileNameMatchesExtension(LPCOLESTR szPath, const wchar_t* pExtensions)
{
	CStringW strPath = szPath;
	if (strPath.IsEmpty())
		return FALSE;

	CPathW path;
	path.CreateFromKnown(strPath);	// don't really care what the case is...

	return BldFileNameMatchesExtension(&path, pExtensions);
}

BOOL BldFileNameMatchesExtension(const CPathW* pPath, const wchar_t* pExtensions)
{
	RETURN_ON_NULL2(pPath, FALSE);

	const wchar_t * pExtNext = pExtensions;
	const wchar_t * pFileExt = pPath->GetExtension();
	if (*pFileExt) pFileExt++;
		// GetExtension() returns pointer to '.'

	INT_PTR n = wcslen (pFileExt);

	if (n)
	{
		while (*pExtNext != L'\0')

		{
			pExtNext = pExtensions;
			while (*pExtNext != L';' && *pExtNext != L',' && *pExtNext != L'\0') 
				pExtNext++;

			// skip over the optional '*.'
			if (pExtensions[0] == L'*' && pExtensions[1] == L'.')
				pExtensions += 2;
			else if (pExtensions[0] == L'.')
				pExtensions += 1;

			// compare extensions in case-insensitive fashion
			if ((n == (pExtNext - pExtensions)) &&			// check for ext. length equivalence
				_wcsnicmp (pFileExt, pExtensions, n) == 0)	// check for ext. string equivalence
				return TRUE;

			pExtensions = pExtNext + 1; // skip over the sep.
		}
	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
void SkipInitialWSpace(CStringW& strSrc, CStringW& strDest)
{
	// strip initial whitespace
	size_t cchWhiteSpace = 0;
	wchar_t * pch = (wchar_t *)(const wchar_t *)strSrc; wchar_t ch = *pch;
	while (ch != L'\0')
	{
		// is this whitespace?
		if (ch != L' ' && ch != L'\t' && ch != L'\r' && ch != L'\n') 
			break;

		cchWhiteSpace += _wclen(pch);
		ch = *(pch + cchWhiteSpace);
	}

	strDest = (wchar_t *)(const wchar_t *)strSrc + cchWhiteSpace;
}

/////////////////////////////////////////////////////////////////////////////////
void GetFirstFile(CStringW& strSrc, CStringW& strFirstFile, CStringW& strRemainder)
{
	// get rid of white space first
	CStringW strTemp;
	SkipInitialWSpace(strSrc, strTemp);
	if (!strTemp.IsEmpty() && strTemp[0]==L'\"') // For NTFS command args, need to handled quoted names
	{
		strFirstFile = L'\"' + strTemp.Mid(1).SpanExcluding(L"\"") + L'\"';
		BOOL bBatchFile = (strFirstFile.Find(L".bat") != -1) || (strFirstFile.Find(L".cmd") != -1);

		if (strFirstFile.CompareNoCase(L"\"\"")==0)
			bBatchFile = (strTemp.Find(L".bat") != -1) || (strTemp.Find(L".cmd") != -1);

		if (bBatchFile && (strTemp.GetAt(strTemp.GetLength()-1) == L'\"'))
			strFirstFile = strTemp; // we are looking at batch file, we need to take the whole command
	}
	else
		strFirstFile = strTemp.SpanExcluding (L" \r\t\n") ;
	strRemainder = strTemp.Mid(strFirstFile.GetLength());
}

BOOL GetQuotedString(const wchar_t*& pBase, const wchar_t*& pEnd)
{				
	VSASSERT(pBase, "Cannot quote a NULL string.");

	while (*pBase && *pBase != L'"')
		 pBase++;

	if (*pBase != L'"')
		return FALSE;

	pEnd = ++pBase;		// Go past quote.

	while (*pEnd && *pEnd != L'"')
		pEnd++;

	if (pBase == pEnd || *pEnd != L'"') 
		return FALSE;

	return TRUE;
} 

///////////////////////////////////////////////////////////////////////////////
// Get output file name for a projitem based on options pairs like /Fm and
// map file name, accounting for output directories.
//
// Basic plan is to check the generate flag (if present) and then get the name
// from the item.  If the returned name ends in a back slash (or forward slash)
// then its acutally an output directory, relative the the _project_ directory,
// since this is what the compiler & linker do.	 If the output directory starts
// in a backslash or drive letter combo then its an absolute name.

// To get the filename (if needed), we take the item's file name and change
// extension to the supplied extension.
BOOL GetItemOutputFile(IVCBuildAction* pBldAction, IUnknown* pItem, long nFileNameID, 
	BldFileRegHandle& frh, const wchar_t * pcDefExtension, BSTR bstrDir, BOOL bIsDefinitelyDir /* = FALSE */)
{
	CStringW strDir = bstrDir;
	CDirW dir;
	dir.CreateFromKnown(strDir);
	return GetItemOutputFile(pBldAction, pItem, nFileNameID, frh, pcDefExtension, &dir, bIsDefinitelyDir);
}

BOOL GetItemOutputFile(IVCBuildAction* pBldAction, IUnknown* pItem, long nFileNameID, 
	BldFileRegHandle& frh, const wchar_t * pcDefExtension, const CDirW* pBaseDir, BOOL bIsDefinitelyDir /* = FALSE */)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	if (spPropContainer == NULL)
	{
		VSASSERT(FALSE, "GetItemOutputFile requires a non-NULL property container to work correctly.");
		return FALSE;
	}
	VSASSERT(pBaseDir, "GetItemOutputFile requires a non-NULL base directory to work correctly.");

	CStringW strFileName;
	CPathW tp;
	frh = NULL;
	const wchar_t *pc;
	int len;
	BOOL bChangeEx = FALSE;

	CComVariant var;
	BOOL bHaveIt = spPropContainer->GetProp(nFileNameID, &var) == S_OK;
	if (bHaveIt && var.vt == VT_BSTR)
	{
		strFileName = var.bstrVal;
		bHaveIt = !strFileName.IsEmpty();
		if (bHaveIt)
		{
			CComBSTR bstrName = var.bstrVal;
			CComBSTR bstrOut;
			HRESULT hr = spPropContainer->Evaluate(bstrName, &bstrOut);
			VSASSERT(SUCCEEDED(hr), "Failed to evaluate string; is there something wrong with the way it is formed?");
			strFileName = bstrOut;
			bHaveIt = !strFileName.IsEmpty();
		}
	}
	else
		bHaveIt = FALSE;

	// Output filename? 
	if (bHaveIt)
	{
		// Okay, the item has an apparently non empty-name entry.  See if it's a directory by checking last character.  If it is,
		len = strFileName.GetLength();
		pc = (const wchar_t *) strFileName;
		pc = _wcsdec(pc, (wchar_t *)(pc+len));
		BOOL bIsDir = FALSE;
		if( pc )
			bIsDir = (*pc == L'/' || *pc == L'\\');

		if (!bIsDefinitelyDir)
			bIsDefinitelyDir = bIsDir;
	
		if ( bIsDefinitelyDir )
		{
			CComBSTR bstrFileName;
			pBldAction->get_ItemFilePath(&bstrFileName);
			CStringW strTmp = bstrFileName;
			if (!bIsDir)	// don't have the slash we need...
				strFileName += L'/';
			// just append and change extension later
			strFileName += strTmp;
			bChangeEx = TRUE;
		}
		if (tp.CreateFromDirAndFilename(*pBaseDir, strFileName))
		{
			if (bChangeEx)
				tp.ChangeExtension(pcDefExtension);
			if ((frh = CBldFileRegFile::GetFileHandle(tp, !tp.IsActualCase())) != NULL)
				return TRUE;
		}

		return FALSE;
	}

	// No filename or is empty filename
	CComBSTR bstrFileName;
	pBldAction->get_ItemFilePath(&bstrFileName);
	strFileName = bstrFileName;
	if (tp.CreateFromDirAndFilename(*pBaseDir, strFileName))
	{
		tp.ChangeExtension (pcDefExtension);
		if ((frh = CBldFileRegFile::GetFileHandle(tp, !tp.IsActualCase())) != NULL)
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldeventtool.h ===
// VCBuildEventTool.h: Definition of the CVCBuildEventTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

#include "ProjWriter.h"

const wchar_t* const wszBldEventDefaultExtensions = L"*.bat";	// remember to update vcpb.rgs if you change this...

// default value handlers
// string props
static void GetDefaultValue( long id, BSTR *pbstrVal )
{
// 	PREBLDID_CommandLine:
// 	PRELINKID_CommandLine:
// 	POSTBLDID_CommandLine:
	*pbstrVal = NULL;
}
// integer props
static void GetDefaultValue( long id, int *piVal )
{
	*piVal = 0;
}
// boolean props
static void GetDefaultValue( long id, VARIANT_BOOL *pbVal )
{
// 	PREBLDID_ExcludedFromBuild:
// 	PRELINKID_ExcludedFromBuild:
// 	POSTBLDID_ExcludedFromBuild:
	COptionHandlerBase::GetValueFalse( pbVal );
}

class CVCPreBuildEventTool;
class CVCPreLinkEventTool;
class CVCPostBuildEventTool;

class CVCPreBuildEventPage;
class CVCPreLinkEventPage;
class CVCPostBuildEventPage;

/////////////////////////////////////////////////////////////////////////////
// CVCBuildEventTool

template <class ContainClass, class PrimaryIface, const IID* piid = &__uuidof(PrimaryIface), 
			const long TBucket, const long TCmdLineID, const long TDescID,
			const long TExcludeID, const long TDirtyID, const long TToolID>
class CVCBuildEventTool : 
	public IDispatchImpl<PrimaryIface, piid, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCBuildEventToolInternal,
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CVCBuildEventTool() 
	{
		m_nLowKey = TCmdLineID;
		m_nHighKey = TExcludeID;
		m_nDirtyKey = TDirtyID;
	}

BEGIN_COM_MAP(ContainClass)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(PrimaryIface)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildEventToolInternal)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(ContainClass) 

// static member data:
protected:
	static CComBSTR s_bstrDescription;
	static GUID s_pPages[1];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;

// event interface
public:
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName) PURE;
	STDMETHOD(get_CommandLine)(BSTR *pVal)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		CHECK_POINTER_VALID(pVal);
		HRESULT hr = m_spPropertyContainer->GetStrProperty(TCmdLineID, pVal);
		if (hr == S_FALSE)
			GetDefaultValue( TCmdLineID, pVal ); 			
		return hr;
	}
	STDMETHOD(put_CommandLine)(BSTR newVal)
	{
		CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );

		// grab each line and strip leading/trailing whitespace from it
		CStringW strCommandLine = newVal;
		CStringW strLine, strNewCommandLine;
		int length = strCommandLine.GetLength();
		int left = 0;
		int right;
		// are there any newlines in the string?
		if( strCommandLine.Find( L'\n' ) != -1 )
		{
			while( true )
			{
				// find the next newline
				right = strCommandLine.Find( L'\n', left );
				// if we couldn't find one
				if( right == -1 )
				{
					// if we're at the end of the cmd line, we're done	
					if( left >= length )
						break;
					// otherwise this is the last line
					else
						right = length;
				}

				// grab this portion (logical line) of the cmd line
				strLine = strCommandLine.Mid( left, right - left );
				// trim the leading/trailing whitespace
				strLine.TrimLeft();
				strLine.TrimRight();
				// append it to the new command line
				strNewCommandLine += strLine;
				strNewCommandLine += L"\r\n";
				// move along to the next logical line
				left = right + 1;
			}
		}
		else
 			strNewCommandLine = strCommandLine;
		
		return m_spPropertyContainer->SetStrProperty(TCmdLineID, CComBSTR( strNewCommandLine ) );
	}
	STDMETHOD(get_Description)(BSTR *pVal) PURE;
	STDMETHOD(put_Description)(BSTR newVal)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		if (newVal == NULL || newVal[0] == L'\0')
			return m_spPropertyContainer->Clear(TDescID);
		else
			return m_spPropertyContainer->SetStrProperty(TDescID, newVal);
	}
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL* pbExcludedFromBuild)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		CHECK_POINTER_VALID(pbExcludedFromBuild);
		HRESULT hr = m_spPropertyContainer->GetBoolProperty(TExcludeID, pbExcludedFromBuild);
		if (hr == S_FALSE)
			GetDefaultValue( TExcludeID, pbExcludedFromBuild );
		return hr;
	}
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL bExcludedFromBuild)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		return m_spPropertyContainer->SetBoolProperty(TExcludeID, bExcludedFromBuild);
	}
	STDMETHOD(get_ToolPath)(BSTR* pbstrToolPath)
	{
		CHECK_POINTER_VALID(pbstrToolPath);
		CComBSTR bstrToolPath(szBuildEventToolPath);
		*pbstrToolPath = bstrToolPath.Detach();
		return S_OK;
	}
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCBuildEventToolInternal
public:
	STDMETHOD(get_CommandLineInternal)(BSTR *pVal)
	{
		return get_CommandLine(pVal);
	}
	STDMETHOD(put_CommandLineInternal)(BSTR newVal)
	{
		return put_CommandLine(newVal);
	}
	STDMETHOD(get_DescriptionInternal)(BSTR *pVal)
	{
		return get_Description(pVal);
	}
	STDMETHOD(put_DescriptionInternal)(BSTR newVal)
	{
		return put_Description(newVal);
	}
	STDMETHOD(get_ExcludedFromBuildInternal)(VARIANT_BOOL* pbExcludedFromBuild)
	{
		return get_ExcludedFromBuild(pbExcludedFromBuild);
	}
	STDMETHOD(put_ExcludedFromBuildInternal)(VARIANT_BOOL bExcludedFromBuild)
	{
		return put_ExcludedFromBuild(bExcludedFromBuild);
	}

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal)
	{
		return DoGetDefaultExtensions(s_bstrExtensions, wszBldEventDefaultExtensions, pVal);
	}
	STDMETHOD(put_DefaultExtensions)(BSTR newVal)
	{
		s_bstrExtensions = newVal;
		return S_OK;
	}
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName) PURE;
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject) PURE;
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches) PURE;
// 	{
//		return DoMatchName(bstrName, szPreLinkEventToolType, szPreLinkEventToolShortName, pbMatches);
// 	}
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		CComBSTR bstrDesc;
		HRESULT hr = get_Description(&bstrDesc);
		RETURN_ON_FAIL(hr);
		return m_spPropertyContainer->Evaluate(bstrDesc, pbstrBuildDescription);
	}
	STDMETHOD(get_IsComspecTool)(VARIANT_BOOL* pbIsComspecTool)
	{
		CHECK_POINTER_NULL(pbIsComspecTool);
		*pbIsComspecTool = VARIANT_TRUE;
		return S_OK;
	}
	STDMETHOD(get_Bucket)(long* pnBucket)
	{
		CHECK_POINTER_NULL(pnBucket);
		*pnBucket = TBucket;
		return S_OK;
	}
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool) // tool always operates on target, not on file
	{
		return COptionHandlerBase::GetValueTrue(pbTargetTool);
	}
	STDMETHOD(get_IsFileTool)(VARIANT_BOOL* pbIsFileTool)
	{
		return COptionHandlerBase::GetValueFalse(pbIsFileTool);
	}
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrOptions)
	{ 
		return E_NOTIMPL;	// don't have any; but don't want assert
	}
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath)
	{ 
		return get_ToolPath(pbstrToolPath);
	}
	STDMETHOD(GetCommandLineEx)(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR *pVal)
	{
		CHECK_POINTER_NULL(pVal);
		*pVal = NULL;
		CHECK_READ_POINTER_NULL(pBuildableItem);

		CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
		CHECK_ZOMBIE(spPropContainer, IDS_ERR_TOOL_ZOMBIE);

		CComBSTR bstrCmdLineEnd;
		HRESULT hr = spPropContainer->GetEvaluatedStrProperty(TCmdLineID, &bstrCmdLineEnd);
		RETURN_ON_FAIL(hr);
			
		CComBSTR bstrCmdLine;
		BuildCommandLineBatchFile(pAction, bstrCmdLineEnd, bstrCmdLine);

		if (hr != S_OK)
		{
			bstrCmdLine.CopyTo(pVal);
			return S_FALSE;
		}

		CHECK_READ_POINTER_NULL(pBuildEngine);
		if (pBuildEngine == NULL)
			return bstrCmdLine.CopyTo(pVal);

		return pBuildEngine->FormBatchFile(bstrCmdLine, pEC, pVal);
	}
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
	{
		VSASSERT(pPropCnt, "Cannot save build event properties without property container.");
		CHECK_READ_POINTER_NULL(pPropCnt);
		CHECK_READ_POINTER_NULL(xml);

		StartNodeHeader( xml, L"Tool", false );

		// Name
		CComBSTR bstrToolShortName;
		get_ToolShortName(&bstrToolShortName);
		if (bstrToolShortName.Length() > 0)
		{
			NodeAttribute( xml, L"Name", bstrToolShortName ); 					
		}
		// Description
		AddSaveLine( xml, pPropCnt, L"Description", TDescID );
		// CommandLine
		AddSaveLine( xml, pPropCnt, L"CommandLine", TCmdLineID );
		// ExcludedFromBuild
		AddSaveLine( xml, pPropCnt, L"ExcludedFromBuild", TExcludeID, FALSE );

		// end of node header
		EndNodeHeader( xml, false );
		// end of node
		EndNode( xml, L"Tool", false );

		return S_OK;
	}

// helpers
protected:
	virtual long GetToolID() { return TToolID; }

public:
	virtual BOOL HaveCommandLine(IVCBuildAction* pAction)
	{
		RETURN_ON_NULL2(pAction, FALSE);
		CComPtr<VCConfiguration> spProjCfg;
		if (FAILED(pAction->get_ProjectConfiguration(&spProjCfg)) || spProjCfg == NULL)
			return FALSE;
		CComQIPtr<IVCPropertyContainer> spPropContainer = spProjCfg;
		RETURN_ON_NULL2(spPropContainer, FALSE);
		CComBSTR bstrCommandLine;
		if (spPropContainer->GetStrProperty(TCmdLineID, &bstrCommandLine) != S_OK || !bstrCommandLine || bstrCommandLine.Length() == 0)
			return FALSE;
		return TRUE;
	}

	void AddSaveLine(IStream *xml, IVCPropertyContainer* pPropContainer, LPOLESTR bszPropertyName, long nPropertyID, BOOL bIsString = TRUE)
	{
		CComBSTR bstrProp;
		VARIANT_BOOL bProp;
		HRESULT hr = S_OK;
		if (bIsString)
			hr = pPropContainer->GetStrProperty(nPropertyID, &bstrProp);
		else
		{
			hr = pPropContainer->GetBoolProperty(nPropertyID, &bProp);
			if (hr == S_OK)
			{
				if (bProp == VARIANT_TRUE)
					bstrProp = L"TRUE";
				else
					bstrProp = L"FALSE";
			}
		}
		if (hr != S_OK)
			return;

		NodeAttributeWithSpecialChars( xml, bszPropertyName, bstrProp );
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVCPreBuildEventTool

class CVCPreBuildEventTool : 
	public CVCBuildEventTool<CVCPreBuildEventTool, VCPreBuildEventTool, &IID_VCPreBuildEventTool,
		BUCKET_PREBUILD, PREBLDID_CommandLine, PREBLDID_Description, 
		PREBLDID_ExcludedFromBuild, PREBLDID_CmdLineOptionsDirty, IDS_PreBuildEvent>
{
public:
	CVCPreBuildEventTool() {}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

// VCPreBuildEventTool
public:
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName)
	{
		CHECK_POINTER_VALID(pbstrToolName);
		InitToolName();
		s_bstrToolName.CopyTo(pbstrToolName);
		return S_OK;
	}
	STDMETHOD(get_Description)(BSTR *pVal)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		CHECK_POINTER_VALID(pVal);
		HRESULT hr = m_spPropertyContainer->GetStrProperty(PREBLDID_Description, pVal);
		if (hr == S_FALSE || pVal == NULL || *pVal == L'\0')
		{
			if (s_bstrDescription.Length() == 0)
				s_bstrDescription.LoadString(IDS_PREBUILDEVENT_DESC);
			s_bstrDescription.CopyTo(pVal);
		}
		return hr;
	}

// IVCToolImpl
public:
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName)
	{
		CHECK_POINTER_NULL(pbstrToolName);
		*pbstrToolName = SysAllocString( szPreBuildEventToolShortName );
		return S_OK;
	}
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
	{
		return CreateInstance(pPropContainer, ppToolObject);
	}
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
	{
		return DoMatchName(bstrName, szPreBuildEventToolType, szPreBuildEventToolShortName, pbMatches);
	}
	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_PREBLD;
		return S_OK;
	}

	STDMETHOD(CreatePageObject)(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
	{
		if( CLSID_VCPreBldGeneral == *pCLSID )
			CPageObjectImpl< CVCPreBuildEventPage, VCPREBLDEVENTTOOL_MIN_DISPID, VCPREBLDEVENTTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
		else
			return S_FALSE;
			
		return S_OK;
	}

	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs()
	{
		if (s_bPagesInit == FALSE)
		{
			s_pPages[0] = __uuidof(VCPreBldGeneral);
			s_bPagesInit = TRUE;
		}
		return s_pPages; 
	}

	virtual LPCOLESTR GetToolFriendlyName()
	{
		InitToolName();
		return s_bstrToolName;
	}

	void InitToolName()
	{
		if (s_bstrToolName.Length() == 0)
		{
			if (!s_bstrToolName.LoadString(IDS_PREBUILDEVENT_TOOLNAME))
				s_bstrToolName = szPreBuildEventToolType;
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVCPreLinkEventTool

class CVCPreLinkEventTool : 
	public CVCBuildEventTool<CVCPreLinkEventTool, VCPreLinkEventTool, &IID_VCPreLinkEventTool,
		BUCKET_PRELINK, PRELINKID_CommandLine, PRELINKID_Description,
		PRELINKID_ExcludedFromBuild, PRELINKID_CmdLineOptionsDirty, IDS_PreLinkEvent>
{
public:
	CVCPreLinkEventTool() {}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

// VCPreLinkEventTool
public:
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName)
	{
		CHECK_POINTER_VALID(pbstrToolName);
		InitToolName();
		s_bstrToolName.CopyTo(pbstrToolName);
		return S_OK;
	}
	STDMETHOD(get_Description)(BSTR *pVal)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		CHECK_POINTER_VALID(pVal);
		HRESULT hr = m_spPropertyContainer->GetStrProperty(PRELINKID_Description, pVal);
		if (hr == S_FALSE || pVal == NULL || *pVal == L'\0')
		{
			if (s_bstrDescription.Length() == 0)
				s_bstrDescription.LoadString(IDS_PRELINKEVENT_DESC);
			s_bstrDescription.CopyTo(pVal);
		}
		return hr;
	}

// IVCToolImpl
public:
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName)
	{
		CHECK_POINTER_NULL(pbstrToolName);
		*pbstrToolName = SysAllocString( szPreLinkEventToolShortName );
		return S_OK;
	}
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
	{
		return CreateInstance(pPropContainer, ppToolObject);
	}
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
	{
		return DoMatchName(bstrName, szPreLinkEventToolType, szPreLinkEventToolShortName, pbMatches);
	}
	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_PRELINK;
		return S_OK;
	}
	STDMETHOD(CreatePageObject)(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
	{
		if( CLSID_VCPreLinkGeneral == *pCLSID )
			CPageObjectImpl< CVCPreLinkEventPage, VCPRELINKEVENTTOOL_MIN_DISPID, VCPRELINKEVENTTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
		else
			return S_FALSE;
			
		return S_OK;
	}
	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs()
	{
		if (s_bPagesInit == FALSE)
		{
			s_pPages[0] = __uuidof(VCPreLinkGeneral);
			s_bPagesInit = TRUE;
		}
		return s_pPages; 
	}
	virtual LPCOLESTR GetToolFriendlyName()
	{
		InitToolName();
		return s_bstrToolName;
	}

	void InitToolName()
	{
		if (s_bstrToolName.Length() == 0)
		{
			if (!s_bstrToolName.LoadString(IDS_PRELINKEVENT_TOOLNAME))
				s_bstrToolName = szPreLinkEventToolType;
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVCPostBuildEventTool

class CVCPostBuildEventTool : 
	public CVCBuildEventTool<CVCPostBuildEventTool, VCPostBuildEventTool, &IID_VCPostBuildEventTool,
		BUCKET_POSTBUILDEVT, POSTBLDID_CommandLine, POSTBLDID_Description,
		POSTBLDID_ExcludedFromBuild, POSTBLDID_CmdLineOptionsDirty, IDS_PostBuildEvent>
{
public:
	CVCPostBuildEventTool() {}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

// VCPostBuildEventTool
public:
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName)
	{
		CHECK_POINTER_VALID(pbstrToolName);
		s_bstrToolName.CopyTo(pbstrToolName);
		return S_OK;
	}
	STDMETHOD(get_Description)(BSTR *pVal)
	{
		CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
		CHECK_POINTER_VALID(pVal);
		HRESULT hr = m_spPropertyContainer->GetStrProperty(POSTBLDID_Description, pVal);
		if (hr == S_FALSE || pVal == NULL || *pVal == L'\0')
		{
			if (s_bstrDescription.Length() == 0)
				s_bstrDescription.LoadString(IDS_POSTBUILDEVENT_DESC);
			s_bstrDescription.CopyTo(pVal);
		}
		return hr;
	}

// IVCToolImpl
public:
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName)
	{
		CHECK_POINTER_NULL(pbstrToolName);
		*pbstrToolName = SysAllocString( szPostBuildEventToolShortName );
		return S_OK;
	}
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
	{
		return CreateInstance(pPropContainer, ppToolObject);
	}
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
	{
		return DoMatchName(bstrName, szPostBuildEventToolType, szPostBuildEventToolShortName, pbMatches);
	}
	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_POSTBLD;
		return S_OK;
	}
	STDMETHOD(CreatePageObject)(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
	{
		if( CLSID_VCPostBldGeneral == *pCLSID )
			CPageObjectImpl< CVCPostBuildEventPage, VCPOSTBLDEVENTTOOL_MIN_DISPID, VCPOSTBLDEVENTTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
		else
			return S_FALSE;
			
		return S_OK;
	}
	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs()
	{
		if (s_bPagesInit == FALSE)
		{
			s_pPages[0] = __uuidof(VCPostBldGeneral);
			s_bPagesInit = TRUE;
		}
		return s_pPages; 
	}
	virtual LPCOLESTR GetToolFriendlyName()
	{
		InitToolName();
		return s_bstrToolName;
	}

	void InitToolName()
	{
		if (s_bstrToolName.Length() == 0)
		{
			if (!s_bstrToolName.LoadString(IDS_POSTBUILDEVENT_TOOLNAME))
				s_bstrToolName = szPostBuildEventToolType;
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVCPreBuildEventPage

class ATL_NO_VTABLE CVCPreBuildEventPage :
	public IDispatchImpl<IVCPreBuildEventPage, &IID_IVCPreBuildEventPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCPreBuildEventPage,VCPREBLDEVENTTOOL_MIN_DISPID,VCPREBLDEVENTTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCPreBuildEventPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPreBuildEventPage)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCPreBuildEventPage, &IID_IVCPreBuildEventPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCPreBuildEventPage
public:
	STDMETHOD(get_CommandLine)(BSTR *pVal);
	STDMETHOD(put_CommandLine)(BSTR newVal);
	STDMETHOD(get_Description)(BSTR *pVal);
	STDMETHOD(put_Description)(BSTR newVal);
	STDMETHOD(get_ExcludedFromBuild)(enumBOOL* pbExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuild)(enumBOOL bExcludedFromBuild);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseCommandsDialog(long id) { return (id == PREBLDID_CommandLine); }
};

/////////////////////////////////////////////////////////////////////////////
// CVCPreLinkEventPage

class ATL_NO_VTABLE CVCPreLinkEventPage :
	public IDispatchImpl<IVCPreLinkEventPage, &IID_IVCPreLinkEventPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCPreLinkEventPage,VCPRELINKEVENTTOOL_MIN_DISPID,VCPRELINKEVENTTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCPreLinkEventPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPreLinkEventPage)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCPreLinkEventPage, &IID_IVCPreLinkEventPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCPreLinkEventPage
public:
	STDMETHOD(get_CommandLine)(BSTR *pVal);
	STDMETHOD(put_CommandLine)(BSTR newVal);
	STDMETHOD(get_Description)(BSTR *pVal);
	STDMETHOD(put_Description)(BSTR newVal);
	STDMETHOD(get_ExcludedFromBuild)(enumBOOL* pbExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuild)(enumBOOL bExcludedFromBuild);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseCommandsDialog(long id) { return (id == PRELINKID_CommandLine); }
};

/////////////////////////////////////////////////////////////////////////////
// CVCPostBuildEventPage

class ATL_NO_VTABLE CVCPostBuildEventPage :
	public IDispatchImpl<IVCPostBuildEventPage, &IID_IVCPostBuildEventPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCPostBuildEventPage,VCPOSTBLDEVENTTOOL_MIN_DISPID,VCPOSTBLDEVENTTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCPostBuildEventPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPostBuildEventPage)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCPostBuildEventPage, &IID_IVCPostBuildEventPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCPostBuildEventPage
public:
	STDMETHOD(get_CommandLine)(BSTR *pVal);
	STDMETHOD(put_CommandLine)(BSTR newVal);
	STDMETHOD(get_Description)(BSTR *pVal);
	STDMETHOD(put_Description)(BSTR newVal);
	STDMETHOD(get_ExcludedFromBuild)(enumBOOL* pbExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuild)(enumBOOL bExcludedFromBuild);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseCommandsDialog(long id) { return (id == POSTBLDID_CommandLine); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldoptions.h ===
#pragma once

#include "PerPropBrowsing.h"
#include <vccolls.h>
#include <vcmap.h>
#include "settingspage.h"

/////////////////////////////////////////////////////////////////////////////
// CVCBuildOptionsPage
class ATL_NO_VTABLE CVCBuildOptionsPage :
	public IDispatchImpl<IVCBuildOptionsPage, &IID_IVCBuildOptionsPage, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCBuildOptionsPage, BUILDOPTIONS_MIN_DISPID, BUILDOPTIONS_MAX_DISPID>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCBuildOptionsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildOptionsPage)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCBuildOptionsPage, &IID_IVCBuildOptionsPage, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCBuildOptionsPage
public:
	STDMETHOD(get_BuildLogging)(VARIANT_BOOL *pbLog);
	STDMETHOD(put_BuildLogging)(VARIANT_BOOL bLog);
	STDMETHOD(get_BuildTiming)(VARIANT_BOOL *pbTime);
	STDMETHOD(put_BuildTiming)(VARIANT_BOOL bTime);
};

/////////////////////////////////////////////////////////////////////////////
// CVCBuildOptionsObject - use this for automation, but otherwise matches CVCBuildOptionsPage class above
class ATL_NO_VTABLE CVCBuildOptionsObject :
	public IDispatchImpl<IVCBuildOptionsPage, &IID_IVCBuildOptionsPage, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCBuildOptionsObject)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildOptionsPage)
END_COM_MAP()

// IVCBuildOptionsPage
public:
	STDMETHOD(get_BuildLogging)(VARIANT_BOOL *pbLog);
	STDMETHOD(put_BuildLogging)(VARIANT_BOOL bLog);
	STDMETHOD(get_BuildTiming)(VARIANT_BOOL *pbTime);
	STDMETHOD(put_BuildTiming)(VARIANT_BOOL bTime);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.cpp ===
// bldspawner.cpp
//
// low-level build routines to spawn tools

#include "stdafx.h"

#include <direct.h>
#include <string.h>
#include <register.h>
#include "bldspawner.h"
#include "dllapi.h"
#include "path2.h"
#include "BuildEngine.h"
#include "util2.h"

// #define SHOW_SPAWNER_DIAGNOSTICS		// uncomment this if you want the ATLTRACE calls in this file

#define MAX_TOOL_MACRO  16					// max length of macro name
#define MAX_LINE_SIZE   2048
#define MAX_USER_LINE   MAX_LINE_SIZE
#define TMP_STRING_SIZE MAX_LINE_SIZE + 60	// all purpose strings

extern CTestableSection g_sectionSpawner;

PfnReadPipe pfnReadPipe = (GetVersion() & 0x80000000) ? FWin95ReadPipe : FWinNTReadPipe;

// characters that indicate to us that we need to spawn a command
// processor in front of tools (redirection and command chaining)
const wchar_t rgchCmdProcChar[] = L"<>&|";


#define MSG_ERR		0
#define MSG_WARN	1
#define MSG_INFO	2
#define MSG_LINE	3
#define MSG_LOG		4

int GetMessageFileAndLine(CStringW &strIn, CStringW &strMsg, CStringW &strFile, ULONG *ulLine, CStringW &strErrNumber)
{
	int nSect = -1;
	//int nOff = 1;
	int nType = MSG_INFO;
	
	// Determine if it is meant straight for the log
	if (strIn.GetLength() > 16 && _wcsnicmp(strIn, L"/*/*/LOGLOG/*/*/", 16) == 0)
	{
		strMsg = strIn.Right(strIn.GetLength()-16);
		return MSG_LOG;
	}

    // Find the end of section 1
	nSect = strIn.Find(L": ");
	if(nSect == -1 )
	{
		strMsg = strIn;
		*ulLine = 0;
		return nType;
	} 
	strFile = strIn.Left(nSect);

	// Now look for the end of section 2
	CStringW strRemainder = strIn.Mid(nSect+2);
	nSect = strRemainder.Find(L": ");
	if( nSect == -1 )
	{
		strMsg = strIn;
		*ulLine = 0;
		return nType;
	}

	// Now check section 2 to see what kind of message this is.
	CStringW strError = strRemainder.Left(nSect);
	int nErr = 0;
	nErr = strError.Find(L"error");
	if( nErr == -1)
	{
		nErr = strError.Find(L"warning");
		if( nErr == -1)
		{
			// this is an info message
			nType = MSG_INFO;
			strMsg = strIn;
			*ulLine = 0;
			return nType;
		}
		else
		{
			// this is an warning message
			nType = MSG_WARN;
		}
	}
	else
	{
		// this is an error message
		nType = MSG_ERR;
	}

	// Now try to get the error number XXX0000
	strError.TrimRight();
	int nErrNumberPos = strError.ReverseFind(L' ');
	if( nErrNumberPos > -1 )
	{
		strErrNumber = strError.Right(strError.GetLength()-nErrNumberPos -1);
	}

	strMsg = strRemainder;

	// Its an error or a warning so try and find the line number
	int nBeg = strFile.Find(L"("); // FIXME : these should use reverse find.
	int nEnd = strFile.Find(L")");
	if( nBeg == -1 || nBeg > nEnd )
	{
		// couldn't find a line number buts thats ok.
		*ulLine = 0;
		return nType;  
	}
	else
	{
		CStringW strLine = strIn.Mid(nBeg+1, nBeg+nEnd);
		int nComma = strLine.Find(L",");
		if( nComma > -1 )
		{
		    strLine = strLine.Left(nComma);
		}
		*ulLine = (ULONG)_wtoi(strLine);
		strFile = strFile.Left(nBeg);
		return nType;
	}
}

STDMETHODIMP ParseLine(IVCBuildErrorContext *pEC, BSTR bstr)
{
	CStringW str;
	str = bstr;
	if( bstr[0] != NULL )
		str += L"\n";
	
	CStringW strFileName;
	CStringW strMsg;
	CStringW strError;
	CComBSTR bstrFileName;
	
	ULONG ulLine = 0;
	int nType = GetMessageFileAndLine(str, strMsg, strFileName, &ulLine, strError);
	if( (!strFileName.IsEmpty()) && (ulLine != 0) )
	{

		strFileName.TrimLeft();
		CPathW path;
		CComBSTR bstrBaseDir;
		pEC->get_BaseDirectory(&bstrBaseDir);
		CDirW dir;
		dir.CreateFromString(bstrBaseDir);
		path.CreateFromDirAndFilename(dir, strFileName);
		if( path.ExistsOnDisk() )
		{
		    bstrFileName = path;
		}
		else
		{
		    bstrFileName = strFileName;
		}
	}
	else
	{
		pEC->get_ProjectName(&bstrFileName);
	}
	
	CComBSTR bstrError = strError;
	CComBSTR bstrMsg = strMsg;
	
	switch( nType )
	{
		case MSG_ERR:
			pEC->AddError(bstrMsg, bstrError, bstrFileName, ulLine, bstr );
			break;
		case MSG_WARN:
			pEC->AddWarning(bstrMsg, bstrError, bstrFileName, ulLine, bstr );
			break;
		case MSG_INFO:
			pEC->AddInfo(bstrMsg);
			break;
		case MSG_LINE:
			pEC->AddLine(bstrMsg);
			break;
		case MSG_LOG:
			pEC->WriteLog(bstrMsg);
			break;
		default:
			break;
	}
	return S_OK;
}

//-----------------------------------------------------------------------------
// FWin95ReadPipe
//
// Necessary function to be able to always return from a ReadFile on a pipe
// when Win95 doesn't realize the pipe has been broken.  We use an auxilliary
// event to stop on.  In this case, it will be the handle to the process that
// we spawn.  When both the process handle is signalled AND the pipe is empty,
// we consider the connection broken.  Otherwise, we pseudo-block until either
// there is data to be read (and we read it) or the process is gone.
//-----------------------------------------------------------------------------
BOOL FWin95ReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE hAuxStop)
{
	DWORD cbAvail = 0;
	
	// while the pipe is still valid, we don't have data, and the aux stop event
	// is not signalled, we pseudo-block
	while (PeekNamedPipe(hpipe, NULL, 0, NULL, &cbAvail, NULL) && cbAvail == 0 &&
			WaitForSingleObject(hAuxStop, 0) == WAIT_TIMEOUT)
	{
		Sleep(10);	// give up our timeslice in a pseudo-block
	}

	cbRead = 0;
	if (cbAvail)
	{
		return ReadFile(hpipe, pvBuf, __min(cbToRead, cbAvail), &cbRead, NULL);
	}

	// else, the only other reason to get out of the loop above is if the pipe
	// has been broken or the aux stop event is signalled.
	return FALSE;
}

//-----------------------------------------------------------------------------
// FWinNTReadPipe
//
// Thunk to ReadFile
//-----------------------------------------------------------------------------
BOOL FWinNTReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE /*hAuxStop*/)
{
	return ReadFile(hpipe, pvBuf, cbToRead, &cbRead, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CBldConsoleSpawner

#ifdef _WIN64
wchar_t CBldConsoleSpawner::s_szSpawnToolArgs[] = L" -e %I64u %s ";
#else
wchar_t CBldConsoleSpawner::s_szSpawnToolArgs[] = L" -e %lu %s ";
#endif // _WIN64
wchar_t CBldConsoleSpawner::s_szSpawnForCodePageToolArgs[] = L" -c";

const wchar_t * szVCSpawn = L"vcspawn";

unsigned _stdcall CBldConsoleSpawner::ReadChildProcessOutput(LPVOID lpv)
{
	CBldConsoleSpawner *pSpawner = (CBldConsoleSpawner *)lpv;
	DWORD cb = 0;	// bytes in output buffer
	char rgchProcOutputBuf[cbProcOutputBuf];
	HRESULT hr;

	hr = CoInitialize(NULL);
	VSASSERT(SUCCEEDED(hr), "Failed to CoInitialize for the build spawner");

	SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
	do {
		// wait until process has been spawned
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : ReadChildProcessOutput: waiting for process spawn event: hSpawnEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		WaitForSingleObject(pSpawner->m_hSpawnEvent, INFINITE);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : ReadChildProcessOutput: returned from wait for process spawn event\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS

		if (pSpawner->m_fThreadDie)
			break;

#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : ReadChildProcessOutput: going to read from pipe handle = 0x%08x\n", pSpawner, pSpawner->m_hReadPipe);
#endif	// SHOW_SPAWNER_DIAGNOSTICS

		// read pipe until it's empty
		while ((*pfnReadPipe)(pSpawner->m_hReadPipe, rgchProcOutputBuf, cbProcOutputBuf - 1,
						cb, pSpawner->m_procinfo.hProcess) && cb > 0)
		{
			// append '\0' to end of buffer
			// NOTE: always okay because only filled up to cbProcOutputBuf-1 bytes
			rgchProcOutputBuf[cb] = '\0';

			// write buffer to output window
#ifdef SHOW_SPAWNER_DIAGNOSTICS
			ATLTRACE("spawner 0x%08x : ReadChildProcessOutput: going to DisplayOutputFromConsole\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
			pSpawner->DisplayOutputFromConsole(rgchProcOutputBuf);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
			ATLTRACE("spawner 0x%08x : ReadChildProcessOutput: returned from to read from DisplayOutputFromConsole\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		}

#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : ReadChildProcessOutput: GetLastError() from ReadFile = 0x%08x\n", pSpawner, GetLastError());
#endif	// SHOW_SPAWNER_DIAGNOSTICS

		// send window message to main thread
		// PostMessage(hwndFrame, WM_NULL, 0, 0);
	} while (TRUE);

	pSpawner->CloseDisplay();
	CoUninitialize();

#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : ReadChildProcessOutput thread committing suicide\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	_endthreadex(0);
	return 0;
}

unsigned _stdcall CBldConsoleSpawner::WaitChildProcessFinish(LPVOID lpv)
{
	CBldConsoleSpawner *pSpawner = (CBldConsoleSpawner *)lpv;

	// wait until process has been terminated
#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: waiting for process to terminate: m_procinfo.hProcess\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	WaitForSingleObject(pSpawner->m_procinfo.hProcess, INFINITE);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: returned from wait for process to terminate: m_procingo.hProcess\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS

	GetExitCodeProcess(pSpawner->m_procinfo.hProcess, &(pSpawner->m_dwTermStatus));

	pSpawner->m_fThreadDie = TRUE;
#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: SetEvent hSpawnEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	SetEvent(pSpawner->m_hSpawnEvent);

#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: waiting for ReadChildProcessOutput thread to terminate: hSpawnThread\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	WaitForSingleObject(pSpawner->m_hSpawnThread, INFINITE);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: returned from wait for ReadChildProcessOutput thread to terminate\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	pSpawner->CloseOneHandle(pSpawner->m_hSpawnThread);

	// if there's text in the output hold buffer (m_szOutput), flush it now
	if (pSpawner->m_ichOutput)
		pSpawner->DisplayOutputFromConsole("\r\n");

	if (pSpawner->m_hNotifyEvent != NULL)
	{
		// assume that notified owner will output termination messages
		VSASSERT(pSpawner->m_hCleanEvent == NULL, "Spawner CleanEvent already set!");
		pSpawner->m_hCleanEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		VSASSERT(pSpawner->m_hCleanEvent != NULL, "Spawner CleanEvent cannot be created.");
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: SetEvent hNotifyEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		SetEvent(pSpawner->m_hNotifyEvent);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: waiting for hCleanEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		WaitForSingleObject(pSpawner->m_hCleanEvent, INFINITE);
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: returned from wait for hCleanEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		VSASSERT(pSpawner == *(pSpawner->m_ppSpawner), "Unmatched spawner!!!");
		*(pSpawner->m_ppSpawner) = NULL;
		BOOL bOK = pSpawner->CloseOneHandle(pSpawner->m_hNotifyEvent);
		VSASSERT(bOK, "Failed to close handle for spawner's notify event thread!");
		bOK = pSpawner->CloseOneHandle(pSpawner->m_hCleanEvent);
		VSASSERT(bOK, "Failed to close handle for spawner's clean event thread!");
	}
	else
	{
		VSASSERT(FALSE, "Spawner NotifyEvent was NULL"); // TODO: DRA (remove some time) catch this in the debugger.
		// check to see if we killed the process so we can put a message out
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: waiting for process to terminate: hCancelEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		if (WaitForSingleObject(pSpawner->m_hCancelEvent, 0) == WAIT_OBJECT_0)
		{
		}
		else
		{
			pSpawner->m_strOutput.Format(pSpawner->m_strError, pSpawner->m_dwTermStatus);
		}
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: returned from wait for process to terminate : hCancelEvent\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		VSASSERT(pSpawner == *(pSpawner->m_ppSpawner), "Unmatched spawner!!!");
		*(pSpawner->m_ppSpawner) = NULL;
	}
	
#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: cleaning up spawner object\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	pSpawner->CleanupHandles();

	// reset flag enabling subsequent spawns
	pSpawner->m_fEnableSpawn = TRUE;

#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish: deleting spawner object\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	delete pSpawner;

#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : WaitChildProcessFinish thread committing suicide\n", pSpawner);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	_endthreadex(0);
	return 0;
}

CBldConsoleSpawner::CBldConsoleSpawner(CBldConsoleSpawner **ppSpawner)
{
	// set up the back pointer which is set to NULL upon spawn termination
	m_ppSpawner = ppSpawner;
	// Create an error context
	m_ichOutput = 0;
	memset((void *)&m_startinfo, 0, sizeof(STARTUPINFO));
	memset((void *)&m_procinfo, 0, sizeof(PROCESS_INFORMATION));
	m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	m_sa.lpSecurityDescriptor = NULL;
	m_sa.bInheritHandle = TRUE;
	m_fEnableSpawn = TRUE;
	m_fUseConsoleCP = FALSE;
	m_hNotifyEvent = NULL;
	m_hCleanEvent = NULL;
	m_hSpawnThread = NULL;
	m_hWaitThread = NULL;
	m_hSpawnEvent = NULL;
	m_hCancelEvent = NULL;
	m_hReadPipe = INVALID_HANDLE_VALUE;
	m_hNulStdin = INVALID_HANDLE_VALUE;
	m_fThreadDie = FALSE;
	m_dwTermStatus = 0;
	m_hpipeWriteOut = INVALID_HANDLE_VALUE;	// stdout handle for child process
	m_hpipeWriteErr = INVALID_HANDLE_VALUE;	// stderr handle for child process
	m_hGeneric = NULL;
	m_CompileState = CS_START;
}

CBldConsoleSpawner::~CBldConsoleSpawner()
{
	CleanupHandles();
}

BOOL CBldConsoleSpawner::CloseOneHandle(HANDLE& hHandle, HANDLE hNewHandleValue /* = NULL */)
{
	BOOL bOK = TRUE;
	if (hHandle != hNewHandleValue)
	{
		bOK = CloseHandle(hHandle);
		hHandle = hNewHandleValue;
	}
	return bOK;
}

void CBldConsoleSpawner::CleanupHandles()
{
	// Prevent access to spawner by other threads.
	CritSectionT cs(g_sectionSpawner);

	// Destroy any remaining handles
	BOOL bOK = CloseOneHandle(m_procinfo.hThread);
	VSASSERT(bOK, "Failed to close handle for spawner's m_procinfo.hThread!");
	bOK = CloseOneHandle(m_procinfo.hProcess);
	VSASSERT(bOK, "Failed to close handle for spawner's m_procinfo.hProcess!");
	bOK = CloseOneHandle(m_hNulStdin, INVALID_HANDLE_VALUE);
	VSASSERT(bOK, "Failed to close handle for spawner's m_hNulStdin!");
	bOK = CloseOneHandle(m_hReadPipe, INVALID_HANDLE_VALUE);
	VSASSERT(bOK, "Failed to close handle for spawner's m_hReadPipe!");
	bOK = CloseOneHandle(m_hCancelEvent);
	VSASSERT(bOK, "Failed to close handle for spawner's cancel event thread!");
	bOK = CloseOneHandle(m_hSpawnEvent);
	VSASSERT(bOK, "Failed to close handle for spawner's spawn event thread!");
	bOK = CloseOneHandle(m_hWaitThread);
	VSASSERT(bOK, "Failed to close handle for spawner's wait thread!");
	bOK = CloseOneHandle(m_hNotifyEvent);
	VSASSERT(bOK, "Failed to close handle for spawner's notify event thread!");
	bOK = CloseOneHandle(m_hCleanEvent);
	VSASSERT(bOK, "Failed to close handle for spawner's clean event thread!");
	bOK = CloseOneHandle(m_hSpawnThread);
	VSASSERT(bOK, "Failed to close handle for spawner's spawn thread!");
	bOK = CloseOneHandle(m_hpipeWriteOut, INVALID_HANDLE_VALUE);
	VSASSERT(bOK, "Failed to close handle to pipe's write end!");
	bOK = CloseOneHandle(m_hpipeWriteErr, INVALID_HANDLE_VALUE);
	VSASSERT(bOK, "Failed to close handle to pipe's read end!");
	CloseOneHandle(m_hGeneric);
}

BOOL CBldConsoleSpawner::InitializeSpawn(LPCOLESTR lpszSpawnDir, BOOL bClearOutputWindow, BOOL bSaveAll /* = TRUE */, 
	IVCBuildErrorContext *pEC)
{
	m_ichOutput = 0;
	m_pEC = pEC;

	// create semaphore for indicating process spawned
	if ((m_hSpawnEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
	{
		AddSpawnerError(IDS_ERR_RESOURCES_EVENT_PRJ0011, L"PRJ0011");
		return FALSE;
	}

	// create thread for reading output from process
#ifdef SHOW_SPAWNER_DIAGNOSTICS
	ATLTRACE("spawner 0x%08x : InitializeSpawn: Starting thread : hSpawnThread\n", this);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
	unsigned int dwThreadID;
	if ( (m_hSpawnThread = (HANDLE)_beginthreadex( NULL, cbThrdStack, CBldConsoleSpawner::ReadChildProcessOutput, this, 0, &dwThreadID)) == (HANDLE)0 )
	{
		AddSpawnerError(IDS_ERR_RESOURCES_THREAD_PRJ0012, L"PRJ0012");
		return FALSE;
	}

	// save away the project build directory for the call to CreateProcess
	m_strSpawnDir = lpszSpawnDir;
	return TRUE;
}

BOOL CBldConsoleSpawner::PerformSpawnMultiple(CVCStringWList *plistCommands, CDynamicBuildEngine* pBldEngine, 
	BOOL fUseConsoleCP)
{
	static const wchar_t szCmdSep[] = { chCmdSep, 0 };
	CStringW strCommands;
	INT_PTR  nCommands = plistCommands->GetCount();
	BOOL bMultipleCommand = nCommands > 1;

	VCPOSITION pos = plistCommands->GetHeadPosition();
	while (pos)
	{
		strCommands += plistCommands->GetNext(pos);
		if (pos)
			strCommands += szCmdSep;
	}

	if (pBldEngine->m_bUserCanceled)
	{
		pBldEngine->InformUserCancel();
		return FALSE;
	}

	if (!strCommands.IsEmpty())
		return PerformSpawn(strCommands, bMultipleCommand, pBldEngine, fUseConsoleCP);

	return FALSE;
}

void CBldConsoleSpawner::CancelSpawn()
{
	if (m_hCancelEvent != (HANDLE)0)
	{
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : CancelSpawn: SetEvent hCancelEvent\n", this);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		BOOL bOK = SetEvent(m_hCancelEvent);
		VSASSERT(bOK, "Failed to set Cancel Event for spawner!");
	}
}

void CBldConsoleSpawner::CloseDisplay()
{
	if (m_pEC)
		m_pEC->Close();
}

void CBldConsoleSpawner::DisplayOutputFromConsole(const char *lpszTextIn)
{
	int cb;
	const char *lpszText = lpszTextIn;
	const char *lpszBegin = lpszText;

	// loop through all characters in string
	while (*lpszText)
	{
		// process special characters
		//
		switch (*lpszText)
		{
			case '\t':
				// if enough room, convert tabs into spaces
				if (m_ichOutput < MAX_USER_LINE)
					m_szOutput[m_ichOutput ++] = ' ';
				else
					// no room
					goto OverFlow ;
				break;

			case '\r':
				// Ignore CR
				break;

			case '\n':
				// treat LF as end of line marker, but only if the next character is NOT a tab or space...
				if (*(lpszText + 1) != '\t')
				{
					bool bContinuation = false;
					if ( (*(lpszText + 1) == ' ') && ((*(lpszText + 2) == ' ') || (*(lpszText + 2) == '\t')) )
						bContinuation = true;
					if (!bContinuation)
					{
						// terminate string*
						m_szOutput[m_ichOutput] = '\0';
						// add to output window
						if (m_pEC != NULL)
						{
							CComBSTR bstrOutput;
							wchar_t wszOutput[CB_COMM_BUF+1];
							MultiByteToWideChar(CDynamicBuildEngine::GetCodePage(m_fUseConsoleCP), MB_PRECOMPOSED, m_szOutput, -1, wszOutput, CB_COMM_BUF+1);
							bstrOutput = wszOutput;
							ParseLine(m_pEC, bstrOutput);
						}
						// set up for next line
						m_ichOutput = 0;
					}
					else
						m_szOutput[m_ichOutput++] = '\n';
				}
				break;

			default:
				// we have a regular character.  Save it if
				// we've got the room
				if (m_ichOutput + (cb = (int) _mbclen((const unsigned char *)lpszText)) < MAX_USER_LINE + 1)
				{
					// olympus 1281:  The read from the pipe may have truncated
					// a double-byte character.  Make sure we don't copy a bogus
					// trail byte into the buffer.  NOTE that the input buffer *MUST*
					// be null-terminated!
					cb = (*(lpszText + 1) == '\0') ? 1 : cb;
					_mbccpy((unsigned char *)m_szOutput + m_ichOutput, (const unsigned char *)lpszText);
					m_ichOutput += cb;
				}
				else
				{
					// we don't have the room.  Terminate the
					// string here
OverFlow:
					// terminate
					//
					m_szOutput[m_ichOutput] = '\0';
					// Make sure that the character we just boofed gets included
					// in the next line.  (I.e., negate the inc that happens at the
					// bottom of the loop.)
					if (lpszText > lpszBegin)
						lpszText = (const char *)_mbsdec((const unsigned char *)lpszBegin, (const unsigned char *)lpszText);

					// add to output window
					if (m_pEC != NULL)
					{
						CComBSTR bstrOutput;
						if (CDynamicBuildEngine::GetCodePage(m_fUseConsoleCP) == 0)
							bstrOutput = m_szOutput;
						else	// need to convert it properly
						{
							wchar_t wszOutput[CB_COMM_BUF+1];
							MultiByteToWideChar(CDynamicBuildEngine::GetCodePage(m_fUseConsoleCP), MB_PRECOMPOSED, m_szOutput, -1, wszOutput, CB_COMM_BUF+1);
							bstrOutput = wszOutput;
						}
						ParseLine(m_pEC, bstrOutput);
					}
					// set up for next line
					m_ichOutput = 0;
				}
				break;
		} // switch

		// advance to next character
		//
		// olympus 1281:  We don't know if a DBC has been split...
		cb = (int) _mbclen((const unsigned char *)lpszText);
		cb = (*(lpszText + 1) == '\0') ? 1 : cb;
		lpszText += cb;
	} // while
}


BOOL CBldConsoleSpawner::PerformSpawn(LPCOLESTR lpszCommandLine, BOOL bMultipleCommand, CDynamicBuildEngine* pBldEngine,
	BOOL fUseConsoleCP)
{
	CStringW strSpawn;
	m_fUseConsoleCP = fUseConsoleCP;
	BOOL fCreateSuccess;	// create process succeeded?
	DWORD dwError;

	CStringW strSpawnTool;
	DWORD dwLen = ::SearchPathW(NULL, szVCSpawn, L".exe", 0, NULL, NULL);
	if (dwLen > 0)
	{
		wchar_t* szPath = strSpawnTool.GetBuffer(dwLen+1);
		if (szPath == NULL)		// out of memory
		{
			DoCleanUp();
			return FALSE;
		}
		::SearchPathW(NULL, szVCSpawn, L".exe", dwLen, szPath, NULL);
		strSpawnTool.ReleaseBuffer();
		strSpawnTool = L"\"" + strSpawnTool;
		strSpawnTool += L"\"";
	}
	else	// not found on the path
	{
		CStringW strMsvcPath;
		UtilGetCommon7Folder(strMsvcPath);
		strMsvcPath += L"Tools\\";
		strSpawnTool = L"\"" + strMsvcPath;
		strSpawnTool += szVCSpawn;
		strSpawnTool += L".exe\"";
	}
	
	// set flag disabling subsequent spawns
	m_fEnableSpawn = FALSE;

	m_CompileState = CS_START;

	if (pBldEngine->m_bUserCanceled)
	{
		DoCleanUp();
		pBldEngine->InformUserCancel();
		return FALSE;
	}

	m_CompileState = CS_CREATEALLOC;

	// create an event object to signal vcspawn.exe when to kill
	//  the child process tree.  note that we have the manual reset
	//  option set so that we can detect when we killed the process
	//  w/o using another flag.
	if (!(m_hCancelEvent = CreateEvent(&m_sa, TRUE, FALSE, NULL)))
	{
		AddSpawnerError(IDS_ERR_RESOURCES_EVENT_PRJ0011, L"PRJ0011");
		DoCleanUp();
		return FALSE;
	}

	m_CompileState = CS_CREATEEVENT;

	// Create the spawn string with the vcspawn prepended
	strSpawn.Format(s_szSpawnToolArgs, (DWORD_PTR)m_hCancelEvent, bMultipleCommand ? szMultCmd : L"");
	strSpawn = strSpawnTool + strSpawn;

	// create string for combined lpUtil and lpCmdLine
	// form the rest of the command line
	strSpawn += lpszCommandLine;

	if (!CreatePipe(&m_hReadPipe, &m_hpipeWriteOut, &m_sa, cbPipeBuf))
	{
		AddSpawnerError(IDS_ERR_RESOURCES_PIPE_PRJ0013, L"PRJ0013");
		DoCleanUp();
		return FALSE;
	}

	m_CompileState = CS_CREATEPIPE;

	// must use a different handle for stderr because some apps (like cl.exe)
	// use dup2() which closes the current target handle if open.  this has
	// the effect of closing both handles if we only pass in the one handle
	// in both hStdOutput and hStdError fields of STARTUPINFO
	m_hGeneric = GetCurrentProcess();
	if (!DuplicateHandle(
			m_hGeneric,					// source process
			m_hpipeWriteOut,			// source handle to dupe
			m_hGeneric,					// target process
			&m_hpipeWriteErr,			// new handle
			DUPLICATE_SAME_ACCESS,		// access flags
			TRUE,						// make it inheritable
			DUPLICATE_SAME_ACCESS))		// option flags
	{
		AddSpawnerError(IDS_ERR_DEVNULL_PRJ0015, L"PRJ0015");
		DoCleanUp();
		return FALSE;
	}

	m_CompileState = CS_DUPLICATEHANDLES;

	// create a handle to /dev/nul
	m_hNulStdin = CreateFileW(L"NUL", GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		&m_sa, OPEN_ALWAYS, 0, INVALID_HANDLE_VALUE);

	if (m_hNulStdin == INVALID_HANDLE_VALUE)
	{
		AddSpawnerError(IDS_ERR_DEVNULL_PRJ0015, L"PRJ0015");
		DoCleanUp();
		return FALSE;
	}

	m_CompileState = CS_CREATENULFILE;

	m_startinfo.cb = sizeof(STARTUPINFOW);
	m_startinfo.lpReserved = NULL;
	m_startinfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	m_startinfo.hStdOutput = m_hpipeWriteOut;
	m_startinfo.hStdError = m_hpipeWriteErr;
	m_startinfo.hStdInput = m_hNulStdin;
	m_startinfo.wShowWindow = SW_HIDE;

	// check to see if we're allowed to run vcspawn
	if( !CanCreateProcess( szVCSpawn ) )
	{
		fCreateSuccess = FALSE;
		AddSpawnerError(IDS_ERR_SECURITY_PRJ0016, L"PRJ0016");
	}
	else
	{
		if (pBldEngine->m_bUserCanceled)
		{
			DoCleanUp();
			CancelSpawn();
			return FALSE;
		}

		fCreateSuccess = CreateProcessW(NULL, strSpawn.GetBuffer(strSpawn.GetLength()), NULL, NULL, TRUE,
			CREATE_NEW_CONSOLE, NULL, m_strSpawnDir, &m_startinfo, &m_procinfo);
		strSpawn.ReleaseBuffer();

		dwError = GetLastError();
		// GetLastError() returns ERROR_ACCESS_DENIED on NT German when path contains extended chars!
		if (!fCreateSuccess && (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_ACCESS_DENIED))
		{
			// Unable to run vcspawn with explicit path, try without...
			strSpawn.Format(s_szSpawnToolArgs, (DWORD_PTR)m_hCancelEvent, bMultipleCommand ? szMultCmd : L"");
			strSpawnTool = L"\"";
			strSpawnTool += szVCSpawn;
			strSpawnTool += L".exe\"";
			strSpawn = strSpawnTool + strSpawn;
			strSpawn += lpszCommandLine;
			fCreateSuccess = CreateProcessW(NULL, strSpawn.GetBuffer(strSpawn.GetLength()), NULL, NULL, TRUE,
				CREATE_NEW_CONSOLE, NULL, m_strSpawnDir, &m_startinfo, &m_procinfo);
			strSpawn.ReleaseBuffer();
		}

		// Unable to run vcspawn (either explicitly pathed or not)...
		if( !fCreateSuccess )
		{
			dwError = GetLastError();
			if( dwError == ERROR_FILE_NOT_FOUND)
			{
				// vc spawn really missing.
				AddSpawnerError(IDS_FAIL_VCSPAWN_PRJ0001, L"PRJ0001");
			}
			else if( dwError == ERROR_DIRECTORY)
			{
				// INVALID WORKING DIR
				AddSpawnerError(IDS_ERR_NOCWD_PRJ0017, L"PRJ0017");
			}
			else
			{
				VSASSERT(0, "Unrecognized Error code from CreateProcess");
				AddSpawnerError(IDS_FAIL_VCSPAWN_PRJ0001, L"PRJ0001");
			}
		}
	}

	if (fCreateSuccess)
	{
		if (pBldEngine->m_bUserCanceled)
		{
			CancelSpawn();
			DoCleanUp();
			return FALSE;
		}

		// create thread which waits for process termination
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : PerformSpawn: Starting thread : hWaitThread\n", this);
#endif	// SHOW_SPAWNER_DIAGNOSTICS

		unsigned int dwThreadID;
		m_hWaitThread = (HANDLE)_beginthreadex( NULL, cbThrdStack, CBldConsoleSpawner::WaitChildProcessFinish, this, 0, &dwThreadID);

		VSASSERT(m_hWaitThread != (HANDLE)0, "Could not create WaitThread");	// REVIEW: UNDONE report error: could not create thread

		// indicate process spawned
#ifdef SHOW_SPAWNER_DIAGNOSTICS
		ATLTRACE("spawner 0x%08x : PerformSpawn: SetEvent hSpawnEvent\n", this);
#endif	// SHOW_SPAWNER_DIAGNOSTICS
		m_fThreadDie = FALSE;
		SetEvent(m_hSpawnEvent);

		// Prevent access to spawner by other threads.
		CritSectionT cs(g_sectionSpawner);

		BOOL bOK;
		// close our copies of pipe write handles
		bOK = CloseOneHandle(m_hpipeWriteOut, INVALID_HANDLE_VALUE);
		VSASSERT(bOK, "Failed to close handle m_hpipeWriteOut!");
		bOK = CloseOneHandle(m_hpipeWriteErr, INVALID_HANDLE_VALUE);
		VSASSERT(bOK, "Failed to close handle m_hpipeWriteErr!");
		// Do NOT call DoCleanUp here no matter HOW tempting it looks.  That's a real good way to
		// cause us to crash while waiting on the cancel event elsewhere...
		return TRUE;
	}

	DoCleanUp();
	return FALSE;
}

void CBldConsoleSpawner::DoCleanUp()
{
	// Prevent access to spawner by other threads.
	CritSectionT cs(g_sectionSpawner);

	BOOL bOK;
	switch(m_CompileState)
	{
		default:
			VSASSERT(FALSE, "No legal default state for CompileState...");
			break;
		case CS_SUCCESSFUL:
		case CS_KILLEDPROCESS:
		case CS_CREATEPROCESS:
			// Successful CreateProcess
			bOK = CloseOneHandle(m_procinfo.hThread);
			VSASSERT(bOK, "Failed to close handle m_procinfo.hThread!");
			bOK = CloseOneHandle(m_procinfo.hProcess);
			VSASSERT(bOK, "Failed to close handle m_procinfo.hProcess!");
		case CS_CREATENULFILE:
			// Successful CreateFile("NUL")
			bOK = CloseOneHandle(m_hNulStdin, INVALID_HANDLE_VALUE);
			VSASSERT(bOK, "Failed to close handle m_hNulStdin!");
		case CS_DUPLICATEHANDLES:
		case CS_CREATEPIPE:
			// Successful DuplicateHandle
			// Successful CreatePipe
			bOK = CloseOneHandle(m_hReadPipe, INVALID_HANDLE_VALUE);
			VSASSERT(bOK, "Failed to close handle m_hReadPipe!");
		case CS_CREATEEVENT:
			// Successful CreateEvent
			bOK = CloseOneHandle(m_hCancelEvent);
			VSASSERT(bOK, "Failed to close handle m_hCancelEvent!");
		case CS_CREATEALLOC:
		case CS_START:
			bOK = CloseOneHandle(m_hSpawnEvent);
			VSASSERT(bOK, "Failed to close handle m_hSpawnEvent!");
			break;
	}
	
	// reset flag enabling subsequent spawns
	m_fEnableSpawn = TRUE;
	*m_ppSpawner = NULL;
}



void CBldConsoleSpawner::AddSpawnerError(UINT idErr, BSTR bstrHelpID)
{
	CComBSTR bstrMsg;
	bstrMsg.LoadString(idErr);
	CComBSTR bstrProj;
	bstrProj.LoadString(IDS_PROJECT_WORD);
	m_pEC->AddError(bstrMsg, bstrHelpID, bstrProj, 0, NULL );
}

void CBldConsoleSpawner::AddSpawnerWarning(UINT idWarn, BSTR bstrHelpID)
{
	CComBSTR bstrMsg;
	bstrMsg.LoadString(idWarn);
	CComBSTR bstrProj;
	bstrProj.LoadString(IDS_PROJECT_WORD);
	m_pEC->AddWarning(bstrMsg, bstrHelpID, bstrProj, 0, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldthread.h ===
// bldthread.h: interface for the CVCBuildThread class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <bldmarshal.h>

class CVCMarshallableEventHandler : 
	public IVCMarshallableEventHandler,
	public CComObjectRoot
{
public:
	CVCMarshallableEventHandler() {}
	~CVCMarshallableEventHandler() {}
	static HRESULT CreateInstance(IVCMarshallableEventHandler** ppHandler);

BEGIN_COM_MAP(CVCMarshallableEventHandler)
	COM_INTERFACE_ENTRY(IVCMarshallableEventHandler)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCMarshallableEventHandler) 

public:
	STDMETHOD(FireProjectBuildFinished)(IDispatch *pCfg, long errors, long warnings, VARIANT_BOOL bCancelled);
};

class CVCBuildThread : 
	public IVCBuildThread,
	public CComObjectRoot
{
public:
	CVCBuildThread();
	~CVCBuildThread();
	static HRESULT CreateInstance(IVCBuildThread** ppThread);
BEGIN_COM_MAP(CVCBuildThread)
	COM_INTERFACE_ENTRY(IVCBuildThread)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCBuildThread) 

// IVCBuildThread
public:
	STDMETHOD(InitializeForBuild)(IVCGenericConfiguration* pGenCfg, VCConfiguration* pProjCfg, ULONG celtFiles,
		VCFile* pFiles[], bldActionTypes bldType, BOOL bVerbose, BOOL bProvideBanner, IVCBuildEngine* pBuildEngine,
		IVCBuildErrorContext* pErrorContext);
	STDMETHOD(StartThread)();
	STDMETHOD(ExitThread)();
	STDMETHOD(Wait)();

public:
	void StopThread();
	void CleanupThread();

protected:
	static DWORD WINAPI BuildThread(LPVOID pvBldThread);

	DWORD m_dwThreadId;
	BOOL m_fThreadDie;

	bldActionTypes m_bldType;
	CComPtr<VCConfiguration> m_spProjCfg;
	VCFile** m_ppFiles;
	ULONG m_cFiles;
	BOOL m_bRecurse;
	BOOL m_bProvideBanner;

public:
	CComPtr<IVCGenericConfiguration> m_spGenCfg;
	CComPtr<IVCBuildErrorContext> m_spBuildErrorContext;
	CComPtr<IVCBuildEngine> m_spBuildEngine;
	CComPtr<IVCMarshallableEventHandler> m_spEventHandler;
	CBldMarshaller<IVCMarshallableEventHandler> m_marshalledEventHandler;

	HANDLE m_hThread;
	HANDLE m_hThreadExitEvent;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldspawner.h ===
// bldspawner.h
//

#ifndef __BLDSPAWNER_H__
#define __BLDSPAWNER_H__

#pragma once

#include <process.h>
#include <vccolls.h>

// classes defined elsewhere
class CDynamicBuildEngine;

/////////////////////////////////////////////////////////////////////////////

#ifndef __SPAWNER_H__

interface IVCBuildErrorContext;

/////////////////////////////////////////////////////////////////////////////
// define some shared data structures between the VC ide and VcSpawn
// in order to do batched commands via named shared memory (aka mapped files)
#define chMultipleCmdFlag	L'm'
#define chEventFlag			L'e'
#define chToolFlag			L't'
#define chPauseFlag			L'p'
#define chCodePageFlag		L'c'
#define chCmdSep			L'\n'
#define szVCSpawnCmd		L"vcspawn"
#define szVCSpawnEchoCmd	L"~vcecho!"
#define szVCSpawnTimeCmd	L"~vctime!"
// for multiple commands to be spawned, use the following:
// 'vcspawn -e -m commands-separated-by-chCmdSep'
// is the format of a command line that should be used.
//
// The return code of vcspawn is formatted thusly:
//	DWORD	dwRet, where:
//		index of failing command is HIWORD(dwRet)
//		return code of failing command is LOWORD(dwRet)
//	dwRet == 0 implies all commands were successful.

#define CB_COMM_BUF     (2048+1)

#define SPAWN_ERROR_DEPTH 10	// Depth of the error context stack
#define cbThrdStack 32768		// thread stack size

// shared buffer size for communication between spawned process and us
#define cbProcOutputBuf 4096
#define cbPipeBuf       (1L * cbProcOutputBuf)

static const wchar_t szMultCmd[] = { L'-', chMultipleCmdFlag, 0 };

typedef enum CompileState
{
	CS_START,
	CS_CREATEALLOC,
	CS_CREATEEVENT,
	CS_CREATEPIPE,
	CS_DUPLICATEHANDLES,
	CS_CREATENULFILE,
	CS_CREATEPROCESS,
	CS_KILLEDPROCESS,
	CS_SUCCESSFUL
} COMPILESTATE;

// ReadFile for pipes handling is different on Win95 from NT due to bugs in Win95.
BOOL FWin95ReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE hAuxStop);
BOOL FWinNTReadPipe(HANDLE hpipe, LPVOID pvBuf, DWORD cbToRead, DWORD &cbRead, HANDLE hAuxStop);
typedef BOOL (*PfnReadPipe)(HANDLE, LPVOID, DWORD, DWORD &, HANDLE);

#endif	// __SPAWNER_H__

///////////////////////////////////////////////////////////////////
// CBldConsoleSpawner

class CBldConsoleSpawner
{
// Construction
public:
	CBldConsoleSpawner(CBldConsoleSpawner **ppSpawner);
	~CBldConsoleSpawner();

// Implementation
	BOOL CanSpawn() { return m_fEnableSpawn; }
	BOOL InitializeSpawn(LPCOLESTR lpszSpawnDir, BOOL bClearOutputWindow, BOOL bSaveAll = TRUE, IVCBuildErrorContext *pEC = NULL);
	BOOL PerformSpawn(LPCOLESTR lpszCommandLine, BOOL bMultipleCommand, CDynamicBuildEngine* pBldEngine, BOOL fUseConsoleCP);
	BOOL PerformSpawnMultiple(CVCStringWList *plistCommands, CDynamicBuildEngine* pBldEngine, BOOL fUseConsoleCP);
	void CancelSpawn();
	BOOL GetConsoleCodePage();
	void DisplayOutputFromConsole(const char *lpszText);
	void CloseDisplay();
	void DoCleanUp();
	void CleanupHandles();
	BOOL CloseOneHandle(HANDLE& hHandle, HANDLE hNewHandleValue = NULL);

public:
	CBldConsoleSpawner **m_ppSpawner;	// back pointer
	HANDLE m_hNotifyEvent;
	HANDLE m_hCleanEvent;
	HANDLE m_hSpawnThread;
	HANDLE m_hWaitThread;
	HANDLE m_hSpawnEvent;
	HANDLE m_hCancelEvent;
	HANDLE m_hReadPipe;
	HANDLE m_hNulStdin;		// handle to null device for input
	BOOL   m_fThreadDie;
	BOOL   m_fEnableSpawn;
	BOOL   m_fUseConsoleCP;
	PROCESS_INFORMATION m_procinfo;
	SECURITY_ATTRIBUTES m_sa;
	int    m_ichOutput;
	char   m_szOutput[CB_COMM_BUF+1];  // yes, ANSI - This is a buffer used from the tool
	DWORD  m_dwTermStatus;

	CStringW   m_strError;
	CStringW   m_strOutput;
	CStringW   m_strSpawnDir;
	CComPtr<IVCBuildErrorContext> m_pEC;

private:
	void AddSpawnerError(UINT idErr, BSTR bstrHelpID);
	void AddSpawnerWarning(UINT idWarn, BSTR bstrHelpID);

	static unsigned _stdcall ReadChildProcessOutput(LPVOID lpv);
	static unsigned _stdcall WaitChildProcessFinish(LPVOID lpv);

	HANDLE m_hpipeWriteOut;	// stdout handle for child process
	HANDLE m_hpipeWriteErr;	// stderr handle for child process
	HANDLE m_hGeneric;

//	LPTERROR  m_hSpawnErrors;

	COMPILESTATE m_CompileState;
	STARTUPINFOW m_startinfo;

//	static BOOL m_fUserWarned;					// has user been warned about missing VCSPAWN.EXE?
	static wchar_t	s_szSpawnToolArgs[];		// string with which CreateProcess string is generated
	static wchar_t	s_szSpawnForCodePageToolArgs[];	// string with which we get a fast call to vcspawn to get the code page
};

///////////////////////////////////////////////////////////////////

#endif	// __BLDSPAWNER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldtool.h ===
#pragma once

#include "vccolls.h"
#include "CmdLines.h"

// classes in this header
class CBldToolWrapper;

// classes needed by this header
class CBldAction;
class CBldActionList;

// action events
#define ACTEVT_Create		0x0	// action is being created
#define ACTEVT_Destroy		0x1	// action is being destroyed
#define ACTEVT_PreGenDep	0x2	// action input file dep. generate is about to start
#define ACTEVT_PostGenDep	0x3	// action input file dep. generate is finished
#define ACTEVT_QueryBrowse	0x4	// ask action if it is browsing
#define ACTEVT_SetBrowse	0x5	// ask action to set it browsing

class CBldToolWrapper
{
public:
	CBldToolWrapper(IVCToolImpl* pTool);
	~CBldToolWrapper();
	IVCToolImpl* GetVCToolImpl() { return m_spTool; }
	BOOL IsTargetTool(IVCBuildAction* pAction);
	BOOL SameToolType(IVCToolImpl* pCheckTool);
	BOOL SameToolType(CStringW& rstrToolName);
	BOOL CustomToolType();
	BOOL GetDefaultExtensions(CStringW& rstrExtensions);
	void GetToolName(IVCToolImpl* pTool, CStringW& rstrToolName);
	long GetOrder();
	BOOL PerformIfAble();
	actReturnStatus PerformBuildActions(bldActionTypes type, CBldActionList* plstActions, bldAttributes aob, 
		IVCBuildErrorContext* pEC, IVCBuildEngine* pBuildEngine);
	BOOL HasDependencies(IVCBuildAction* pAction);
	BOOL GenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC);
	BOOL AffectsOutput(long nPropID);
	BOOL GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, CStringW& rstrOptions);
	BOOL CanScanForDependencies();
	BOOL ScanDependencies(IVCBuildAction* pBldAction, IVCBuildErrorContext* pEC, BOOL bWriteOutput);
	BOOL GetDependencies(IVCBuildAction* pBldAction, CVCStringWArray& rstrArray, BOOL* pbUpToDate = NULL);
	BOOL HasPrimaryOutput();
	BOOL IsSpecialConsumable(LPCOLESTR szPath);
	BOOL AffectsTool(long nLowPropID, long nHighPropID);
	BOOL CommandLineOptionsAreDirty(IVCBuildableItem* pItem);
	BOOL OutputsAreDirty(IVCBuildableItem* pItem);
	BOOL ClearDirtyOutputs(IVCBuildableItem* pItem);
	BOOL GetDeploymentDependencies(IVCBuildAction* pBldAction, IVCBuildStringCollection** ppDeployDeps);

protected:
	void InitToolName();

protected:
	BOOL m_fCustomTool:1;		// is this tool a kind of custom tool?
	BOOL m_fCustomToolInit:1;	// m_fCustomTool initialized?
	BOOL m_fToolNameInit:1;		// m_strToolName initialized?
	BOOL m_fCustomBuildToolNameInit:1;	// m_strCustomBuildToolName initialized?
	BOOL m_fExtensionsInit:1;	// m_strExtensions initialized?
	BOOL m_fExtensionsValid:1;	// m_strExtensions valid?
	BOOL m_fOrderInit:1;		// m_nOrder initialized?
	BOOL m_fPerformIfAbleInit:1;	// m_fPerformIfAble initialized?
	BOOL m_fPerformIfAble:1;	// perform actions even if previous errors
	BOOL m_fPrimaryOutputInit:1;	// m_fPrimaryOutput initialized?
	BOOL m_fPrimaryOutput:1;		// tool generates primary output

	CComPtr<IVCToolImpl> m_spTool;	// the underlying, config/platform/toolset tool
	CStringW m_strToolName;	// name of this tool (ex: C/C++ Compiler Tool)
	CStringW m_strExtensions;	// default extension list for this tool
	CStringW m_strCustomBuildToolName;	// name of the custom build tool
	long m_nOrder;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldthread.cpp ===
// BldThrd.cpp: implementation of the CVCBuildThread class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "bldthread.h"
#include "FileRegistry.h"
#include "BldHelpers.h"
#include "BuildEngine.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVCBuildThread::CVCBuildThread()
{
	m_hThread = NULL;
	m_hThreadExitEvent = NULL;
	m_fThreadDie = TRUE;
	m_dwThreadId = NULL;
	m_ppFiles = NULL;
	m_cFiles = 0;
}

CVCBuildThread::~CVCBuildThread()
{
	StopThread();
}

HRESULT CVCBuildThread::CreateInstance(IVCBuildThread** ppThread)
{
	CHECK_POINTER_NULL(ppThread);
	*ppThread = NULL;

	CComObject<CVCBuildThread> *pObj;
	HRESULT hr = CComObject<CVCBuildThread>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		CVCBuildThread *pVar = pObj;
		pVar->AddRef();
		*ppThread = pVar;
	}
	return hr;
}

STDMETHODIMP CVCBuildThread::StartThread()
{
	HRESULT hr = S_OK;

	VSASSERT(m_spBuildErrorContext != NULL, "NULL ErrorContext!!!");

	if (m_hThread)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BLD_ALREADY_INIT, IDS_ERR_BLD_THREAD_ALREADY_INIT);
	RETURN_INVALID_ON_NULL(m_spBuildErrorContext);

	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = m_spProjCfg;
	RETURN_INVALID_ON_NULL(spProjCfgImpl);

	// setup thread
	m_hThreadExitEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	m_fThreadDie = FALSE;

	RETURN_ON_NULL(m_hThreadExitEvent);

	// need to fire the build start event *before* we start up the thread
	CComQIPtr<IDispatch> spDispCfg = m_spProjCfg;
	CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
	if (spProjEngineImpl)
		spProjEngineImpl->DoFireProjectBuildStarted(spDispCfg);

	// run thread
	m_hThread = CreateThread(NULL, 0, CVCBuildThread::BuildThread, this, 0, &m_dwThreadId);
	RETURN_ON_NULL(m_hThread);

	return hr;	
}

void CVCBuildThread::CleanupThread()
{
	// WARNING: MUST RELEASE COM POINTERS NOW (before ExitThread)!!!
	m_spProjCfg.Release();
	if (m_ppFiles != NULL)
	{
		for (ULONG idx = 0; idx < m_cFiles; idx++)
		{
			VCFile* pVCFile = m_ppFiles[idx];
			if (pVCFile != NULL)
				pVCFile->Release();
		}
		::CoTaskMemFree(m_ppFiles);
		m_ppFiles = NULL;
	}
	if (m_spBuildErrorContext != NULL)
	{
		m_spBuildErrorContext->Close();
		m_spBuildErrorContext.Release();
		m_spBuildErrorContext = NULL;
	}

	m_spBuildEngine.Release();
	m_spGenCfg.Release();
	m_marshalledEventHandler.Clear();
	m_spEventHandler.Release();
}

STDMETHODIMP CVCBuildThread::ExitThread()
{
	CoUninitialize();

	// exit thread
	if (m_hThread)
		::CloseHandle(m_hThread);
	m_hThread = NULL;
	SetEvent(m_hThreadExitEvent);	

	return S_OK;
}

void CVCBuildThread::StopThread()
{	
    if (m_hThread)
    {
		::ExitThread(0);
	    m_fThreadDie = TRUE;
	    WaitForSingleObject(m_hThreadExitEvent, INFINITE);
		::CloseHandle(m_hThread);
	    m_hThread = NULL;
    }

    if (m_hThreadExitEvent)
    {
	    CloseHandle(m_hThreadExitEvent);
	    m_hThreadExitEvent = NULL;
    }
}

STDMETHODIMP CVCBuildThread::InitializeForBuild(IVCGenericConfiguration* pGenCfg, VCConfiguration* pProjCfg, 
	ULONG celtFiles, VCFile* pFiles[], bldActionTypes bldType, BOOL bRecurse, BOOL bProvideBanner, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pErrorContext)
{
	if (m_hThread || pProjCfg == NULL || pBuildEngine == NULL || pGenCfg == NULL)
		RETURN_INVALID();	// bad input parameter...

	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = pBuildEngine;
	RETURN_INVALID_ON_NULL(spBuildEngineImpl); // bad input parameter...
	spBuildEngineImpl->InitializeForBuild();

	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pProjCfg;
	RETURN_INVALID_ON_NULL(spProjCfgImpl);		// bad config

	VARIANT_BOOL bCanStartBuild = VARIANT_FALSE;
	spProjCfgImpl->get_CanStartBuild(&bCanStartBuild);
	if (bCanStartBuild == VARIANT_FALSE)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BLD_IN_PROG, IDS_ERR_BLD_THREAD_ALREADY_INIT); // can't have more than one thread going....

	m_spGenCfg = pGenCfg;
	m_bldType = bldType;
	m_spProjCfg = pProjCfg;
	m_cFiles = celtFiles;

	if (pFiles != NULL)
	{
		m_ppFiles = (VCFile**) ::CoTaskMemAlloc(celtFiles * sizeof(VCFile *));
		if( m_ppFiles )
		{
			for (ULONG idx = 0; idx < celtFiles; idx++)
			{
				VCFile* pVCFile = pFiles[idx];
				if (pVCFile != NULL)
					pVCFile->AddRef();
				m_ppFiles[idx] = pVCFile;
			}
		}
	}

	m_bRecurse = bRecurse;
	m_bProvideBanner = bProvideBanner;
	m_spBuildErrorContext = pErrorContext;
	m_spBuildEngine = pBuildEngine;

	if (SUCCEEDED(CVCMarshallableEventHandler::CreateInstance(&m_spEventHandler)))
		m_marshalledEventHandler.Init(m_spEventHandler);

	return S_OK;
}

STDMETHODIMP CVCBuildThread::Wait()
{
	if (m_hThread)
		WaitForSingleObject(m_hThread, 0);

	return S_OK;	// return value not checked
}

class CThreadHelper
{
public:
	CThreadHelper(CVCBuildThread* pThread) : m_pBldThrd(pThread), m_fOK(FALSE), m_warnings(-1), m_errors(-1), m_bCancelled(FALSE) 
	{
		CoInitialize(NULL); // make sure we can do ole in this thread
	}
	~CThreadHelper()
	{
		if (m_pBldThrd->m_spBuildErrorContext)
			m_pBldThrd->m_spBuildErrorContext->put_AssociatedBuildEngine(NULL);
		if (m_spBuildEngineImpl)
			m_spBuildEngineImpl->put_ErrorContext(NULL);
		m_pBldThrd->m_spBuildEngine.Release();

		// send our own project build event
		if (m_spEventHandler)
			m_spEventHandler->FireProjectBuildFinished( m_pDispCfg, m_warnings, m_errors, (m_bCancelled ? VARIANT_TRUE : VARIANT_FALSE ) );
		else	// must not be registered, so fire for those who can handle cross-thread
		{
			CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
			if (spProjEngineImpl)
				spProjEngineImpl->DoFireProjectBuildFinished( m_pDispCfg, m_warnings, m_errors, (m_bCancelled ? VARIANT_TRUE : VARIANT_FALSE ) );
		}
		m_spEventHandler.Release();

		// tell the build thread to clean itself up
		CComPtr<IVCGenericConfiguration> spGenCfg = m_pBldThrd->m_spGenCfg;	// need this 'cause the thread's going to release its refcount
		m_pBldThrd->CleanupThread();

		// increase our priority so that we'll definitely get a chance to finish up before the primary thread
		// can possibly go away
		SetThreadPriority(m_pBldThrd->m_hThread, THREAD_PRIORITY_HIGHEST);

		// inform the shell the build has completed
		spGenCfg->InformBuildEnd(m_fOK);	// NOTE: this releases the thread

		// DO ABSOLUTELY **NOTHING** BEYOND THIS POINT.  We can get into threading issues if we do ANYTHING after
		// we tell the shell we're done with a build...

		// (The spGenCfg above had BETTER have exited our thread for us or we're toast, though...)
	}

public:
	CComQIPtr<IVCMarshallableEventHandler> m_spEventHandler;
	CComQIPtr<IDispatch> m_pDispCfg;
	CComQIPtr<IVCBuildEngineImpl> m_spBuildEngineImpl;
	CVCBuildThread* m_pBldThrd;
	BOOL m_fOK;
	long m_warnings;
	long m_errors;
	BOOL m_bCancelled;
};

/* static */ DWORD WINAPI CVCBuildThread::BuildThread(LPVOID pvBldThread)
{
	CVCBuildThread *pBldThrd = (CVCBuildThread *)pvBldThread;  // this is a static function; replace use of "this" with pBldThrd.
	VSASSERT(pBldThrd, "Starting the build thread without creating it first!");

	CThreadHelper threadHelper(pBldThrd);

	IVCGenericConfiguration *pGenCfg = pBldThrd->m_spGenCfg;	
	VSASSERT(pGenCfg != NULL, "Hey, how did we get this far with a NULL gencfg?!?");
	VSASSERT(pBldThrd->m_spProjCfg != NULL, "Must supply project config to build thread for things to work");

	// inform the shell the build has begun
	threadHelper.m_fOK = SUCCEEDED(pGenCfg->InformBuildBegin());
	if (!threadHelper.m_fOK)	// continue?
		return FALSE;

	// send our own project build event
	threadHelper.m_pDispCfg = pBldThrd->m_spProjCfg;
	pBldThrd->m_marshalledEventHandler.UnmarshalPtr(&threadHelper.m_spEventHandler);
	threadHelper.m_spBuildEngineImpl = pBldThrd->m_spBuildEngine;
	if (threadHelper.m_spBuildEngineImpl)
		threadHelper.m_spBuildEngineImpl->put_ErrorContext(pBldThrd->m_spBuildErrorContext);

	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pBldThrd->m_spProjCfg;
	if (spProjCfgImpl == NULL)
	{
		VSASSERT(FALSE, "Project config should support IVCConfigurationImpl...");
		return FALSE;
	}

	HRESULT hr = S_OK;
	if (pBldThrd->m_bldType == TOB_Compile)
	{
		hr = spProjCfgImpl->TopLevelBuild(TOB_Compile, pBldThrd->m_cFiles, pBldThrd->m_ppFiles, 
			pBldThrd->m_spBuildEngine, pBldThrd->m_spBuildErrorContext, pBldThrd->m_bRecurse, FALSE /* no idle*/, 
			TRUE /* do cleanup */, pBldThrd->m_bProvideBanner, &threadHelper.m_warnings, &threadHelper.m_errors, 
			&threadHelper.m_bCancelled);
	}
	else if (pBldThrd->m_bldType == TOB_ReBuild)
	{
		// don't do a clean-before-build for makefile config types!
		ConfigurationTypes cfgType;
		pBldThrd->m_spProjCfg->get_ConfigurationType( &cfgType );
		if( cfgType != typeUnknown )
		{
			hr = spProjCfgImpl->TopLevelBuild(TOB_Clean, pBldThrd->m_cFiles, pBldThrd->m_ppFiles, 
				pBldThrd->m_spBuildEngine, pBldThrd->m_spBuildErrorContext, TRUE /* recurse */, TRUE /* do idle */, 
				TRUE /* no cleanup */, pBldThrd->m_bProvideBanner, &threadHelper.m_warnings, &threadHelper.m_errors,
				&threadHelper.m_bCancelled);
		}
	}

	if (pBldThrd->m_bldType != TOB_Compile && !threadHelper.m_bCancelled)
		hr = spProjCfgImpl->TopLevelBuild(pBldThrd->m_bldType, pBldThrd->m_cFiles, pBldThrd->m_ppFiles, 
			pBldThrd->m_spBuildEngine, pBldThrd->m_spBuildErrorContext, pBldThrd->m_bRecurse, FALSE /* no idle */, 
			TRUE /* do cleanup */, pBldThrd->m_bProvideBanner, &threadHelper.m_warnings, &threadHelper.m_errors, 
			&threadHelper.m_bCancelled);

	if (pBldThrd->m_spBuildErrorContext)
		pBldThrd->m_spBuildErrorContext->Close();
	threadHelper.m_fOK = (hr == S_OK) ? TRUE: FALSE;

	return threadHelper.m_fOK;
}

HRESULT CVCMarshallableEventHandler::CreateInstance(IVCMarshallableEventHandler** ppEventHandler)
{
	CHECK_POINTER_NULL(ppEventHandler);
	*ppEventHandler = NULL;

	CComObject<CVCMarshallableEventHandler> *pObj;
	HRESULT hr = CComObject<CVCMarshallableEventHandler>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		CVCMarshallableEventHandler *pVar = pObj;
		pVar->AddRef();
		*ppEventHandler = pVar;
	}
	return hr;
}

STDMETHODIMP CVCMarshallableEventHandler::FireProjectBuildFinished(IDispatch *pCfg, long errors, long warnings, 
	VARIANT_BOOL bCancelled)
{
	CComQIPtr<IVCProjectEngineImpl> spProjEngImpl = g_pProjectEngine;
	RETURN_ON_NULL2(spProjEngImpl, E_UNEXPECTED);
	return spProjEngImpl->DoFireProjectBuildFinished(pCfg, errors, warnings, bCancelled);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bldtool.cpp ===
#include "stdafx.h"
#include "BldTool.h"
#include "BuildEngine.h"
#include "msgboxes2.h"

CBldToolWrapper::CBldToolWrapper(IVCToolImpl* pTool)
{
	m_spTool = pTool;

	m_fCustomTool = FALSE;
	m_fCustomToolInit = FALSE;
	m_fToolNameInit = FALSE;
	m_fCustomBuildToolNameInit = FALSE;
	m_fExtensionsInit = FALSE;
	m_fExtensionsValid = FALSE;
	m_fOrderInit = FALSE;
	m_nOrder = 0;
	m_fPerformIfAbleInit = FALSE;
	m_fPerformIfAble = FALSE;
	m_fPrimaryOutputInit = FALSE;
	m_fPrimaryOutput = FALSE;
}

CBldToolWrapper::~CBldToolWrapper()
{
}

BOOL CBldToolWrapper::IsTargetTool(IVCBuildAction* pAction)
{
	VARIANT_BOOL bVal = VARIANT_FALSE;
	if (!m_spTool || FAILED(m_spTool->IsTargetTool(pAction, &bVal)))
		bVal = VARIANT_FALSE;

	return (bVal == VARIANT_TRUE);
}

BOOL CBldToolWrapper::HasPrimaryOutput()
{
	if (!m_fPrimaryOutputInit)
	{
		m_fPrimaryOutputInit = TRUE;
		VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
		if (m_spTool != NULL && SUCCEEDED(m_spTool->HasPrimaryOutputFromTool(NULL, VARIANT_TRUE, &bHasPrimaryOutput)) 
			&& bHasPrimaryOutput == VARIANT_TRUE)
			m_fPrimaryOutput = TRUE;
	}
	return m_fPrimaryOutput;
}

void CBldToolWrapper::InitToolName()
{
	if (m_fToolNameInit)
		return;		// already initialized

	m_fToolNameInit = TRUE;
	GetToolName(m_spTool, m_strToolName);
}

void CBldToolWrapper::GetToolName(IVCToolImpl* pTool, CStringW& rstrToolName)
{
	rstrToolName.Empty();
	if (pTool == NULL)	// want current tool
	{
		InitToolName();
		rstrToolName = m_strToolName;
		return;
	}

	CComBSTR bstrToolName;
	pTool->get_ToolShortName(&bstrToolName);
	rstrToolName = bstrToolName;	
}

BOOL CBldToolWrapper::SameToolType(IVCToolImpl* pTool)
{
	InitToolName();
	CStringW strCheckName;
	GetToolName(pTool, strCheckName);
	return (m_strToolName == strCheckName);
}

BOOL CBldToolWrapper::SameToolType(CStringW& rstrCheckName)
{
	InitToolName();
	return (m_strToolName == rstrCheckName);
}

BOOL CBldToolWrapper::CustomToolType()
{
	if (!m_fCustomToolInit)
	{
		m_fCustomToolInit = TRUE;
		m_fCustomTool = FALSE;
		VARIANT_BOOL bVal = VARIANT_FALSE;
		if (m_spTool != NULL && SUCCEEDED(m_spTool->get_IsCustomBuildTool(&bVal)))
			m_fCustomTool = (bVal == VARIANT_TRUE);
	}
	return m_fCustomTool;
}

BOOL CBldToolWrapper::GetDefaultExtensions(CStringW& rstrExtensions)
{
	if (!m_fExtensionsInit)
	{
		m_fExtensionsInit = TRUE;
		CComBSTR bstrExtensions;
		HRESULT hr = VCPROJ_E_INTERNAL_ERR;
		if (m_spTool)
			hr = m_spTool->get_DefaultExtensions(&bstrExtensions);
		m_strExtensions = bstrExtensions;
		m_fExtensionsValid = SUCCEEDED(hr);
	}
	rstrExtensions = m_strExtensions;
	return m_fExtensionsValid;
}

long CBldToolWrapper::GetOrder()
{
	if (m_fOrderInit == FALSE)
	{
		m_fOrderInit = TRUE;
		if (m_spTool != NULL)
		{
			HRESULT hr = m_spTool->get_Bucket(&m_nOrder);
			VSASSERT(SUCCEEDED(hr), "All tools must provide a bucket number!");
		}
	}
	return m_nOrder;
}

BOOL CBldToolWrapper::PerformIfAble()
{
	if (m_fPerformIfAbleInit == FALSE)
	{
		m_fPerformIfAbleInit = TRUE;
		if (m_spTool != NULL)
		{
			VARIANT_BOOL bPerformIfAble = VARIANT_FALSE;
			HRESULT hr = m_spTool->get_PerformIfAble(&bPerformIfAble);
			VSASSERT(SUCCEEDED(hr), "All tools must be able to say whether they can perform an action if able!");
			m_fPerformIfAble = (bPerformIfAble == VARIANT_TRUE);
		}
	}
	return m_fPerformIfAble;
}

actReturnStatus CBldToolWrapper::PerformBuildActions(bldActionTypes type, CBldActionList* plstActions, 
	bldAttributes attrib, IVCBuildErrorContext* pEC, IVCBuildEngine* pBuildEngine)
{
	if (m_spTool == NULL || plstActions == NULL || !plstActions->NotEmpty())
		return ACT_Complete;	// nothing more to do

	actReturnStatus act = ACT_Complete;
	IVCBuildActionList* pIActions = plstActions;
	HRESULT hr = m_spTool->PrePerformBuildActions(type, pIActions, attrib, pEC, &act);
	if (FAILED(hr))
		return ACT_Error;
	else if (act != ACT_Complete || hr == S_FALSE)
		return act;

	CComPtr<VCProject> spProject;
	hr = plstActions->get_Project(&spProject);
	VSASSERT(SUCCEEDED(hr), "Actions list must have a project!");

	// perform the pre-build?
//	if (stage == TOB_Pre)
	{
		BOOL bSchmooze = IsTargetTool(NULL);
		VCPOSITION pos = plstActions->GetStart(); 
		while (pos != (VCPOSITION)NULL && (act == ACT_Complete) /* failure */)
		{
			CBldAction* pAction = (CBldAction *)plstActions->Next(pos);
			CBldFileRegSet* psetOutput = pAction->GetOutput(pEC); // want full list of output files
			if(psetOutput)
			{
				psetOutput->InitFrhEnum();
				BldFileRegHandle frh;
				while ((frh = psetOutput->NextFrh()) != (BldFileRegHandle)NULL)
				{
					// need to create directory for output?
					if (type != TOB_Clean) 
					{
						CDirW dir;	// directory of output file
						if (dir.CreateFromPath(*pAction->m_pregistry->GetRegEntry(frh)->GetFilePath()))
						{
							if (pBuildEngine->AddToOutputDirectoryList((wchar_t *)(const wchar_t *)dir) == S_OK)	// not there before
							{
								if (!dir.ExistsOnDisk())
								{
									// directory doesn't exist on disk?
									// try to create
									if (!dir.CreateOnDisk())
									{
										// error, 'failed to create directory'
										CStringW str;
										::VCMsgTextW(str, IDS_COULD_NOT_CREATE_DIR_PRJ0007, (const wchar_t *) dir);
										CVCProjectEngine::AddProjectError(pEC, str, L"PRJ0007", plstActions);
			
										if (!(attrib & AOB_IgnoreErrors))
										{
											act = ACT_Error; 
											break;
										}
									}
								}
							}
						}
					}
					else // delete output files
					{		
						// Special handling is required for schmooze tool users, since we may need to
						// explicitly delete certain targets (such as .ILK files) in order to
						// guarantee a clean build, however we may not want to delete other targets
						// (such as the browser file) which are useful during the build.  Thus we keep
						// separate filters for targets which are "Products" (i.e. time-stamping) and
						// targets to "Delete on Rebuild" for a clean buld.
						if (bSchmooze)
						{
							// FUTURE: fix this stuff when CSchmoozeTool merges with CSourceTool
							// linker deletes all outputs, bscmake none
							if (type != TOB_Clean)
							{
								CStringW strPath = *(g_FileRegistry.GetRegEntry(frh)->GetFilePath());
								CComBSTR bstrPath = strPath;
								VARIANT_BOOL bDelOnRebuild = VARIANT_FALSE;
								if (SUCCEEDED(m_spTool->IsDeleteOnRebuildFile(bstrPath, &bDelOnRebuild)) &&
									(bDelOnRebuild == VARIANT_TRUE))
								{
									frh->ReleaseFRHRef();
									continue;
								}
							}
						}
	
						// if we can't delete this output and we're not forcing a build then error
						if (!g_StaticBuildEngine.DeleteFile(frh, pEC, NULL, pIActions) && !(attrib & AOB_IgnoreErrors))		  
						{
							act = ACT_Error; 
							break;
						}
					}
					frh->ReleaseFRHRef();
				}
			}
		}
	}

	// get the tool type
	bool bIsNMakeTool = false;
	CComQIPtr<VCNMakeTool> pNMakeTool = m_spTool;
	if( pNMakeTool )
		bIsNMakeTool = true;
	
	// actually perform the build?
//	else if (stage == TOB_Stage)
	// build, clean or rebuild for makefile tool
	if( type != TOB_Clean || ((type == TOB_Clean || type == TOB_ReBuild) && bIsNMakeTool) )
	{
		CComPtr<IVCCommandLineList> spCmds;

		if (pBuildEngine == NULL)
			act = ACT_Error;	// failure
		else if( bIsNMakeTool && type == TOB_Clean )
		{
			// handle the makefile tool clean case here
			// (build a clean command line and run it)
			if( FAILED( m_spTool->GetCommandLinesForClean( pIActions, attrib, pBuildEngine, pEC, &spCmds ) ) )
			{
				CStringW strError;
				strError.LoadString(IDS_GET_COMMAND_LINE_FAILED_PRJ0004);

				CStringW strTmp;
				GetToolName(NULL, strTmp);
				strError += strTmp;
				CComBSTR bstrError = strError + strTmp;

				CVCProjectEngine::AddProjectError(pEC, bstrError, L"PRJ0004", pIActions);
				if( !(attrib & AOB_IgnoreErrors ) )
					act = ACT_Error; // failure
			}
			// clean can't batch
			if( attrib & AOB_IgnoreErrors )
				attrib = AOB_Default;
		}
		else if( bIsNMakeTool && type == TOB_ReBuild )
		{
			// handle the makefile tool rebuild case here
			// (build a rebuild command line and run it)
			if( FAILED( m_spTool->GetCommandLinesForRebuild( pIActions, attrib, pBuildEngine, pEC, &spCmds ) ) )
			{
				CStringW strError;
				strError.LoadString(IDS_GET_COMMAND_LINE_FAILED_PRJ0004);

				CStringW strTmp;
				GetToolName(NULL, strTmp);
				strError += strTmp;
				CComBSTR bstrError = strError + strTmp;

				CVCProjectEngine::AddProjectError(pEC, bstrError, L"PRJ0004", pIActions);
				if( !(attrib & AOB_IgnoreErrors ) )
					act = ACT_Error; // failure
			}
// 			// clean can't batch
// 			if( attrib & AOB_IgnoreErrors )
// 				attrib = AOB_Default;
		}
 		else if (FAILED(m_spTool->GetCommandLinesForBuild(pIActions, attrib, pBuildEngine, pEC, &spCmds)))
		{
			CComBSTR bstrError;
			bstrError.LoadString(IDS_GET_COMMAND_LINE_FAILED_PRJ0004);
			CVCProjectEngine::AddProjectError(pEC, bstrError, L"PRJ0004", pIActions);
			if (!(attrib & AOB_IgnoreErrors))
				act = ACT_Error;	// failure
		}

		// ok to continue with what we have?
		if (act == ACT_Complete && spCmds != NULL)
		{
			// check for need to preprend command with comspec if custom build tool
			VARIANT_BOOL bCheckForComSpec = VARIANT_FALSE;
			hr = m_spTool->get_IsComspecTool(&bCheckForComSpec);
			VSASSERT(SUCCEEDED(hr), "All tools must be able to specify whether or not they're a comspec tool!");
			CMD cmd = CMD_Complete;

			CComBSTR bstrProjDir;
			if (spProject != NULL)
			{
				hr = spProject->get_ProjectDirectory(&bstrProjDir);
				VSASSERT(SUCCEEDED(hr), "Must always be able to the project directory!");
			}
			VARIANT_BOOL bIgnoreErrs = (attrib & AOB_IgnoreErrors) ? VARIANT_TRUE : VARIANT_FALSE;
			pBuildEngine->ExecuteCommandLines(spCmds, bstrProjDir, bCheckForComSpec, bIgnoreErrs, pEC, &cmd);
			
			switch (cmd)
			{
				case CMD_Complete:
					act = ACT_Complete;
					break;
				case CMD_Canceled:
					act = ACT_Canceled;
					break;
				case CMD_Error:
					act = ACT_Error;
					break;
				default:
					VSASSERT(FALSE, "Unhandled CMD type");
					break;
			}
		}
	// perform the post-build?
//	else if (stage == TOB_Post)
//			// all of our outputs of the action are dirty
		VCPOSITION pos = plstActions->GetStart();
		while (pos != (VCPOSITION)NULL)
		{
			CBldAction* pAction = (CBldAction *)plstActions->Next(pos);
			CBldFileRegSet* pregset = pAction->GetOutput(pEC);
			pregset->MakeContentsDirty(pAction->m_pregistry);
		}
	}

	if (m_spTool != NULL)
		m_spTool->PostPerformBuildActions(type, pIActions, attrib, pEC, &act);

	return act;
}

BOOL CBldToolWrapper::HasDependencies(IVCBuildAction* pAction)
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	RETURN_ON_NULL2(pAction, FALSE);

	VARIANT_BOOL bHasDependencies = VARIANT_FALSE;
	if (FAILED(m_spTool->HasDependencies(pAction, &bHasDependencies)))
		return FALSE;

	return (bHasDependencies == VARIANT_TRUE);
}

BOOL CBldToolWrapper::CanScanForDependencies()
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	
	VARIANT_BOOL bCanScan = VARIANT_FALSE;
	if (FAILED(m_spTool->CanScanForDependencies(&bCanScan)))
		return FALSE;

	return (bCanScan == VARIANT_TRUE);
}

BOOL CBldToolWrapper::ScanDependencies(IVCBuildAction* pBldAction, IVCBuildErrorContext* pEC, BOOL bWriteOutput)
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	HRESULT hr = m_spTool->ScanDependencies(pBldAction, pEC, (bWriteOutput == TRUE) ? VARIANT_TRUE : VARIANT_FALSE);
	return (hr == S_OK);
}

BOOL CBldToolWrapper::GetDependencies(IVCBuildAction* pAction, CVCStringWArray& rstrArray, BOOL* pbUpToDate /* = NULL */)
{
	if (m_spTool == NULL || pAction == NULL)
		return FALSE;

	CComPtr<IVCBuildStringCollection> spStrings;
	VARIANT_BOOL bUpToDate = VARIANT_FALSE;
	HRESULT hr = m_spTool->GetDependencies(pAction, &spStrings, &bUpToDate);
	if (pbUpToDate != NULL)
		*pbUpToDate = (bUpToDate == VARIANT_TRUE);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spStrings, FALSE);

	spStrings->Reset();
	while (TRUE)
	{
		CComBSTR bstrString;
		HRESULT hr = spStrings->Next(&bstrString);
		if (hr != S_OK)
			break;
		CStringW strString = bstrString;
		if (strString.IsEmpty())
			continue;
		rstrArray.Add(strString);
	}

	return TRUE;
}

BOOL CBldToolWrapper::GetDeploymentDependencies(IVCBuildAction* pBldAction, IVCBuildStringCollection** ppDeployDeps)
{
	if (m_spTool == NULL || pBldAction == NULL)
		return FALSE;

	return (SUCCEEDED(m_spTool->GetDeploymentDependencies(pBldAction, ppDeployDeps)));
}

// Generate the corresponding outputs for each of the input file sets in each of the actions
// (errors should be pushed into the error context pEC)
// The 'type' is an AOGO_.
BOOL CBldToolWrapper::GenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	RETURN_ON_NULL2(pActions, FALSE);

	HRESULT hr = m_spTool->GenerateOutput(type, pActions, pEC);
	return (hr == S_OK);
}

BOOL CBldToolWrapper::AffectsOutput(long nPropID)
{
	RETURN_ON_NULL2(m_spTool, FALSE);

	VARIANT_BOOL bAffectsOutput = VARIANT_FALSE;
	if (FAILED(m_spTool->AffectsOutput(nPropID, &bAffectsOutput)))
		return FALSE;

	return (bAffectsOutput == VARIANT_TRUE);
}

BOOL CBldToolWrapper::GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, CStringW& rstrOptions)
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	CComBSTR bstrOptions;
	HRESULT hr = m_spTool->GetCommandLineOptions(pItem, pAction, VARIANT_TRUE, cmdLineForRefresh, &bstrOptions);
	rstrOptions = bstrOptions;
	return (SUCCEEDED(hr));
}

BOOL CBldToolWrapper::IsSpecialConsumable(LPCOLESTR szPath)
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	VARIANT_BOOL bSpecial = VARIANT_FALSE;
	m_spTool->IsSpecialConsumable(szPath, &bSpecial);
	return (bSpecial == VARIANT_TRUE);
}

BOOL CBldToolWrapper::AffectsTool(long nLowPropID, long nHighPropID)
{
	RETURN_ON_NULL2(m_spTool, FALSE);
	return (m_spTool->AffectsTool(nLowPropID, nHighPropID, NULL) == S_OK);
}

BOOL CBldToolWrapper::CommandLineOptionsAreDirty(IVCBuildableItem* pItem)
{
	RETURN_ON_NULL2(m_spTool, FALSE);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, FALSE);

	VARIANT_BOOL bDirty = VARIANT_FALSE;
	if (m_spTool->CommandLineOptionsAreDirty(spPropContainer, &bDirty) != S_OK)
		return FALSE;

	return (bDirty == VARIANT_TRUE);
}

BOOL CBldToolWrapper::OutputsAreDirty(IVCBuildableItem* pItem)
{
	RETURN_ON_NULL2(m_spTool, FALSE);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, FALSE);

	VARIANT_BOOL bDirty = VARIANT_FALSE;
	if (m_spTool->OutputsAreDirty(spPropContainer, &bDirty) != S_OK)
		return FALSE;

	return (bDirty == VARIANT_TRUE);
}

BOOL CBldToolWrapper::ClearDirtyOutputs(IVCBuildableItem* pItem)
{
	RETURN_ON_NULL2(m_spTool, FALSE);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, FALSE);

	return (m_spTool->ClearDirtyOutputs(spPropContainer) == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bsctool.h ===
// VCBscMakeTool.h: Definition of the CVCBscMakeTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "stdafx.h"
#include "vctool.h"
#include "SettingsPage.h"

// classes in this header:
class CVCBscMakeTool;
class CBscMakeToolOptionHandler;

class CBscMakeToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE();

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *bstrVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *iVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *bVal, IVCPropertyContainer *pPropCnt = NULL );

protected:
	virtual BOOL SetEvenIfDefault(VARIANT *pVarDefault, long idOption);
};

/////////////////////////////////////////////////////////////////////////////
// CVCBscMakeTool

class ATL_NO_VTABLE CVCBscMakeTool : 
	public IDispatchImpl<VCBscMakeTool, &IID_VCBscMakeTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CVCToolImpl,
	public CComObjectRoot
{
public:
	CVCBscMakeTool() 
	{
		m_nLowKey = VCBSCMAKETOOL_MIN_DISPID;
		m_nHighKey = VCBSCMAKETOOL_MAX_DISPID;
		m_nDirtyKey = VCBSCID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCBSCID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCBscMakeTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(VCBscMakeTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCBscMakeTool) 

protected:
	// static member data
	static GUID s_pPages[2];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrExtensions;

// VCBscMakeTool
public:
	// general; @response deliberately left out
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "BSCMake Tool"
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other switches
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_SuppressStartupBanner)(VARIANT_BOOL* pbNoLogo);	// (/nologo) enable suppression of copyright message
	STDMETHOD(put_SuppressStartupBanner)(VARIANT_BOOL bNoLogo);
	STDMETHOD(get_OutputFile)(BSTR* pbstrOutputFile);	// (/o [file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	STDMETHOD(put_OutputFile)(BSTR bstrOutputFile);
	STDMETHOD(get_RunBSCMakeTool)(VARIANT_BOOL* pbRun);	// run the BSCMake tool; acts as inverse of ExcludeFromBuild
	STDMETHOD(put_RunBSCMakeTool)(VARIANT_BOOL bRun);

	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pbstrToolPath);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal)
	{ return DoGetPropertyOption(bstrProp, dispidProp, pVal); }
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbIsTargetTool);
	STDMETHOD(get_PerformIfAble)(VARIANT_BOOL* pbPerformIfAble);
	STDMETHOD(get_IsFileTool)(VARIANT_BOOL* pbIsFileTool);
	STDMETHOD(PrePerformBuildActions)(bldActionTypes type, IVCBuildActionList* pActions, bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn);
	STDMETHOD(PostPerformBuildActions)(bldActionTypes type, IVCBuildActionList* pActions, bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn);
	STDMETHOD(IsDeleteOnRebuildFile)(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent) { return S_FALSE; }	// not sharable
	STDMETHOD(WriteToStream)(IStream *pStream, IVCPropertyContainer* pPropContainer);
	STDMETHOD(ReadFromStream)(IStream *pStream, IVCPropertyContainer* pPropContainer);

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		*pIndex = TOOL_DISPLAY_INDEX_BSC;
		return S_OK;
	}

	virtual long GetPageCount() { return 2; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath);	// return a value only if tool generates a primary output (ex: linker)

protected:
	virtual BOOL UsesResponseFiles() { return TRUE; }
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_BSC; }

public:
	static CBscMakeToolOptionHandler s_optHandler;

protected:
	static CComBSTR s_bstrToolName;
};

class ATL_NO_VTABLE CVCBscMakePage :
	public IDispatchImpl<IVCBscMakePage, &IID_IVCBscMakePage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCBscMakePage,VCBSCMAKETOOL_MIN_DISPID,VCBSCMAKETOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCBscMakePage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IVCBscMakePage)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCBscMakePage, &IID_IVCBscMakePage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCBscMakePage
public:
	// general; @response deliberately left out
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_SuppressStartupBanner)(enumSuppressStartupBannerBOOL* pbNoLogo);	// (/nologo) enable suppression of copyright message
	STDMETHOD(put_SuppressStartupBanner)(enumSuppressStartupBannerBOOL bNoLogo);
	STDMETHOD(get_OutputFile)(BSTR* pbstrOutputFile);	// (/o [file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	STDMETHOD(put_OutputFile)(BSTR bstrOutputFile);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\bsctool.cpp ===
// BscTool.cpp : Implementation of the BscMake Tool

#include "stdafx.h"
#include "BscTool.h"
#include "ProjWriter.h"

// constants
const wchar_t* const wszBscDefaultExtensions = L"*.sbr";	// remember to update vcpb.rgs if you change this...

// static initializers
CBscMakeToolOptionHandler CVCBscMakeTool::s_optHandler;
GUID CVCBscMakeTool::s_pPages[2];
BOOL CVCBscMakeTool::s_bPagesInit;
CComBSTR CVCBscMakeTool::s_bstrBuildDescription = L"";
CComBSTR CVCBscMakeTool::s_bstrToolName = L"";
CComBSTR CVCBscMakeTool::s_bstrExtensions = L"";


////////////////////////////////////////////////////////////////////////////////
// Option Table for BscMake switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// NOTE 2: if you add anything here, make sure to add it to ReadFromStream and WriteToStream as well.  With only a few 
// properties, it wasn't worth writing something to traverse the table for that.  Also make sure that all of these props
// go into the big case statement in IsRealProp as NOT being real props.  Otherwise, the project file gets dirtied as part
// of project load if any of the BSC settings are set and it shouldn't be.
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CBscMakeToolOptionHandler, L"VCBscMakeTool", IDS_BSC, TRUE /* pre & post */, TRUE /* case sensitive */)
	// general
	OPT_BOOL(SuppressStartupBanner,		L"|nologo",		L"SuppressStartupBanner",			IDS_BSCGeneral, VCBSCID)
	OPT_BSTR(OutputFile,				L"o %s",		L"OutputFile",			single,		IDS_BSCGeneral, VCBSCID)
END_OPTION_TABLE()

BOOL CBscMakeToolOptionHandler::SetEvenIfDefault(VARIANT *pvarDefault, long idOption)
{
	CComVariant varDefault;
	BOOL bRet = FALSE;

	switch (idOption)
	{
	case VCBSCID_SuppressStartupBanner:
		varDefault = VARIANT_TRUE;
		varDefault.vt = VT_BOOL;
		bRet = TRUE;
		break;
	}
	varDefault.Detach(pvarDefault);
	return bRet;
}

void CBscMakeToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	GetDefaultString( pVal );
}

void CBscMakeToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	*pVal = 0;
}

void CBscMakeToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCBSCID_SuppressStartupBanner:
		GetValueTrue( pVal );
		break;
	default:
		GetValueFalse( pVal );
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////
// implementation of CVCBscMakeTool

HRESULT CVCBscMakeTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppBscTool)
{
	CHECK_POINTER_NULL(ppBscTool);
	*ppBscTool = NULL;

	CComObject<CVCBscMakeTool> *pObj;
	HRESULT hr = CComObject<CVCBscMakeTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCBscMakeTool *pVar = pObj;
		pVar->AddRef();
		*ppBscTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCBscMakeTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_VCBSCGeneral == *pCLSID )
	{
		CPageObjectImpl<CVCBscMakePage,VCBSCMAKETOOL_MIN_DISPID,VCBSCMAKETOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CVCBscMakeTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(VCBSCGeneral);
		s_pPages[1] = __uuidof(BSCAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

LPCOLESTR CVCBscMakeTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCBscMakeTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_BSCMAKE_TOOLNAME))
			s_bstrToolName = szBscMakeToolType;
	}
}

STDMETHODIMP CVCBscMakeTool::get_IsFileTool(VARIANT_BOOL* pbIsFileTool)
{
	return COptionHandlerBase::GetValueFalse(pbIsFileTool);
}

STDMETHODIMP CVCBscMakeTool::PrePerformBuildActions(bldActionTypes type, IVCBuildActionList* pActions, 
	bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn)
{
	CHECK_POINTER_NULL(pActReturn);
	*pActReturn = ACT_Complete;

	// DIANEME_TODO: old build engine sent an IDE-level inform of start of BSCMAKE build here
	
	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::PostPerformBuildActions(bldActionTypes type, IVCBuildActionList* pActions, 
	bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn)
{
	// DIANEME_TODO: old build engine sent an IDE-level inform of end of BSCMAKE build here

	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::IsDeleteOnRebuildFile(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild)
{
	return COptionHandlerBase::GetValueTrue(pbDelOnRebuild);
}

HRESULT CVCBscMakeTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	if (spPropContainer == NULL)
		return E_UNEXPECTED;

	CComBSTR bstrName;
	HRESULT hr = spPropContainer->GetEvaluatedStrProperty(VCBSCID_OutputFile, &bstrName);
	if (hr != S_OK)
		return hr;

	CStringW strName = bstrName;
	if (strName.IsEmpty())
		return E_FAIL;

	CComBSTR bstrProjName;
	hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjName);	// should never have macros in it
	RETURN_ON_FAIL(hr);
	CStringW strDirName = bstrProjName;
	CDirW dirProj;
	if (!dirProj.CreateFromKnown(strDirName))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	if( !rpath.CreateFromDirAndFilename(dirProj, strName))
		return E_FAIL;
	rpath.GetActualCase(TRUE);

	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = VCBSCID_OutputFile;

	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	if (plstActions == NULL)
		return S_OK;	// nothing to do

	plstActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCBuildableItem> spItem;
		spAction->get_Item(&spItem);

		CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
		if (spPropContainer == NULL)
			continue;

		VARIANT_BOOL bRunTool = VARIANT_FALSE;
		if (spPropContainer->GetBoolProperty(VCBSCID_RunBSCMakeTool, &bRunTool) != S_OK || bRunTool != VARIANT_TRUE)
			continue;

		CPathW pathOutput;
		if (GetPrimaryOutputFromTool(spItem, VARIANT_TRUE, pathOutput) != S_OK)
			continue;

		HRESULT hrT = spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathOutput, pEC, VARIANT_TRUE, VARIANT_TRUE,
			VCBSCID_OutputFile, this);
		RETURN_ON_FAIL(hrT);
	}

	return S_OK; // success
}

STDMETHODIMP CVCBscMakeTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	switch (nPropID)
	{
	case VCBSCID_OutputFile:
	case VCBSCID_OutputsDirty:
	case VCBSCID_RunBSCMakeTool:
		*pbAffectsOutput = VARIANT_TRUE;
	}

	return S_OK;
}

// general; @response deliberately left out
STDMETHODIMP CVCBscMakeTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "BSCMake Tool"
	CHECK_POINTER_VALID(pbstrToolName);
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other switches
	return ToolGetStrProperty(VCBSCID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCBscMakeTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCBSCID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCBscMakeTool::get_SuppressStartupBanner(VARIANT_BOOL* pbNoLogo)
{	// (/nologo) enable suppression of copyright message
	return ToolGetBoolProperty(VCBSCID_SuppressStartupBanner, pbNoLogo);
}

STDMETHODIMP CVCBscMakeTool::put_SuppressStartupBanner(VARIANT_BOOL bNoLogo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoLogo );
	return m_spPropertyContainer->SetBoolProperty(VCBSCID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCBscMakeTool::get_OutputFile(BSTR* pbstrOutputFile)
{	// (/o [file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(VCBSCID_OutputFile, pbstrOutputFile);
}

STDMETHODIMP CVCBscMakeTool::put_OutputFile(BSTR bstrOutputFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCBSCID_OutputFile, bstrOutputFile);
}

STDMETHODIMP CVCBscMakeTool::get_RunBSCMakeTool(VARIANT_BOOL* pbRun)
{	// run the BSCMake tool; acts as inverse of ExcludeFromBuild
	return ToolGetBoolProperty(VCBSCID_RunBSCMakeTool, pbRun);
}

STDMETHODIMP CVCBscMakeTool::put_RunBSCMakeTool(VARIANT_BOOL bRun)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bRun );
	return m_spPropertyContainer->SetBoolProperty(VCBSCID_RunBSCMakeTool, bRun);
}

// Automation properties
STDMETHODIMP CVCBscMakeTool::get_ToolPath(BSTR *pbstrToolPath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pbstrToolPath );
	HRESULT hr = m_spPropertyContainer->GetStrProperty(VCBSCID_ToolPath, pbstrToolPath);
	if (hr == S_FALSE)
	{
		CComBSTR bstrPath( szBscMakeToolPath );
		*pbstrToolPath = bstrPath.Detach();
	}
	return hr;
}

// IVCToolImpl
STDMETHODIMP CVCBscMakeTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszBscDefaultExtensions, pVal); 
}

STDMETHODIMP CVCBscMakeTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCBscMakeTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CComBSTR bstrShortName( szBscMakeToolShortName );
	*pbstrToolName = bstrShortName.Detach();
	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{
	return CreateInstance(pPropContainer, ppToolObject);
}

STDMETHODIMP CVCBscMakeTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCBSCID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCBscMakeTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szBscMakeToolType, szBscMakeToolShortName, pbMatches);
}

STDMETHODIMP CVCBscMakeTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_BSCMAKING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCBscMakeTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_BSC;
	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbIsTargetTool)
{
	return COptionHandlerBase::GetValueTrue(pbIsTargetTool);
}

STDMETHODIMP CVCBscMakeTool::get_PerformIfAble(VARIANT_BOOL* pbPerformIfAble)
{
	return COptionHandlerBase::GetValueTrue(pbPerformIfAble);
}

STDMETHODIMP CVCBscMakeTool::ReadFromStream(IStream* pStream, IVCPropertyContainer *pPropContainer)
{
	CHECK_READ_POINTER_NULL(pStream);
	CHECK_READ_POINTER_NULL(pPropContainer);
	
	VARTYPE		type;
	ULONG		iByteCount;
	DISPID		dispid;
	HRESULT		hr;

	while (true)
	{
		//Read in type
		hr = pStream->Read(&type, sizeof(VARTYPE), &iByteCount);
		RETURN_ON_FAIL(hr);

		//End of list marker
		if (type == VT_EMPTY) break;

		//Read in dispid
		hr = pStream->Read(&dispid, sizeof(DISPID), &iByteCount);
		RETURN_ON_FAIL(hr);

		switch (type)	//Switch the property types
		{
			case VT_BOOL:
			case VT_I2:
				switch (dispid)
				{
					case VCBSCID_RunBSCMakeTool:
						{
							VARIANT_BOOL bRun = VARIANT_FALSE;
							hr = pStream->Read(&bRun, sizeof(VARIANT_BOOL), &iByteCount);
							RETURN_ON_FAIL(hr);
							hr = pPropContainer->SetBoolProperty(VCBSCID_RunBSCMakeTool, bRun);
						}
						break;
					case VCBSCID_SuppressStartupBanner:
						{
							VARIANT_BOOL bNoLogo = VARIANT_FALSE;
							hr = pStream->Read(&bNoLogo, sizeof(VARIANT_BOOL), &iByteCount);
							RETURN_ON_FAIL(hr);
							hr = pPropContainer->SetBoolProperty(VCBSCID_SuppressStartupBanner, bNoLogo);
						}
						break;

					default:
						return E_UNEXPECTED;
				}
				RETURN_ON_FAIL(hr);
				break;
	
			case VT_BSTR:
				if (dispid == VCBSCID_OutputFile)
				{
					CComBSTR bstrFile;
					hr = bstrFile.ReadFromStream(pStream);
					RETURN_ON_FAIL(hr);
					hr = pPropContainer->SetStrProperty(VCBSCID_OutputFile, bstrFile);
				}
				else
					hr = E_UNEXPECTED;
				RETURN_ON_FAIL(hr);
				break;

			default:
				return E_UNEXPECTED;
		}
	}
	return S_OK;
}

STDMETHODIMP CVCBscMakeTool::WriteToStream(IStream *pStream, IVCPropertyContainer *pPropContainer)
{
	CHECK_READ_POINTER_NULL(pStream);
	CHECK_READ_POINTER_NULL(pPropContainer);

	CComBSTR bstrName = L"VCBscMakeTool";
	HRESULT hr = bstrName.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	// RunBSCMakeTool
	CComVariant varRun;
	hr = pPropContainer->GetLocalProp(VCBSCID_RunBSCMakeTool, &varRun);
	if (hr == S_OK && (varRun.vt == VT_BOOL || varRun.vt == VT_I2))
	{
		VARIANT_BOOL bRun = varRun.boolVal;
		hr = CPropertyContainerImpl::WritePropertyToStream(pStream, bRun, VCBSCID_RunBSCMakeTool);
		RETURN_ON_FAIL(hr);
	}

	// SuppressStartupBanner
	CComVariant varNoLogo;
	hr = pPropContainer->GetLocalProp(VCBSCID_SuppressStartupBanner, &varNoLogo);
	if (hr == S_OK && (varNoLogo.vt == VT_BOOL || varNoLogo.vt == VT_I2))
	{
		VARIANT_BOOL bNoLogo = varNoLogo.boolVal;
		hr = CPropertyContainerImpl::WritePropertyToStream(pStream, bNoLogo, VCBSCID_SuppressStartupBanner);
		RETURN_ON_FAIL(hr);
	}

	// OuputFile
	CComVariant varOutputFile;
	hr = pPropContainer->GetLocalProp(VCBSCID_OutputFile, &varOutputFile);
	if (hr == S_OK && varOutputFile.vt == VT_BSTR)
	{
		CComBSTR bstrOutputFile= varOutputFile.bstrVal;
		hr = CPropertyContainerImpl::WritePropertyToStream(pStream, bstrOutputFile, VCBSCID_OutputFile);
		RETURN_ON_FAIL(hr);
	}

	//Write "end of property list" marker
	VARTYPE type = VT_EMPTY;
	ULONG	iByteCount;
	hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	return S_OK;
}


/**********************************************************/

STDMETHODIMP CVCBscMakePage::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCBSCID_AdditionalOptions, &(CVCBscMakeTool::s_optHandler), pbstrAdditionalOptions);
}

STDMETHODIMP CVCBscMakePage::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	return SetStrProperty(VCBSCID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCBscMakePage::get_SuppressStartupBanner(enumSuppressStartupBannerBOOL* pbNoLogo)
{	// (/nologo) enable suppression of copyright message
	return GetEnumBoolProperty2(VCBSCID_SuppressStartupBanner, (long *)pbNoLogo);
}

STDMETHODIMP CVCBscMakePage::put_SuppressStartupBanner(enumSuppressStartupBannerBOOL bNoLogo)
{
	return SetBoolProperty(VCBSCID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCBscMakePage::get_OutputFile(BSTR* pbstrOutputFile)
{	// (/o [file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(VCBSCID_OutputFile, &(CVCBscMakeTool::s_optHandler), pbstrOutputFile);
}

STDMETHODIMP CVCBscMakePage::put_OutputFile(BSTR bstrOutputFile)
{
	return SetStrProperty(VCBSCID_OutputFile, bstrOutputFile);
}

void CVCBscMakePage::GetBaseDefault(long id, CComVariant& varValue)
{
	VARIANT_BOOL bVal;
	switch (id)
	{
	case VCBSCID_SuppressStartupBanner:
		CVCBscMakeTool::s_optHandler.GetDefaultValue( id, &bVal );
		varValue = bVal;
		break;
	default:
		CBase::GetBaseDefault(id, varValue);
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.h ===
#ifndef __BUILDENGINE_H__
#define __BUILDENGINE_H__

#pragma once

#include "FileRegistry.h"
#include "bldhelpers.h"
#include "ConfigRecords.h"
#include "BldTool.h"
#include "bldspawner.h"
#include "BldActions.h"
#include "vcbuild.h"            // built by ..\idl\vcbuild.idl
#include "encbldthrd.h"
#include "scanner.h"

// classes in this header
class CStaticBuildEngine;
class CDynamicBuildEngine;
class CBldHoldRegRecalcs;

// FUTURE - clean this CMD_ and ACT_ stuff up so the build engine is clearer.
// Make these enums (the type will then be int, which is what it should be anyway
// since that's what DoSpawn returns) and then update the return type on some of
// the build funcs (like ExecuteCmdLines)
// The same should be done to a lot of the #defines in this file.

// CStaticBuildEngine debugging bits
#define DBG_BS_OFF		0x0		// (no debugging)
#define DBG_BS_GRP		0x1		// show graph ctor/dtor info

#define ENABLE_BS_GRP	0x10	// enable graph ctor/dtor 

class CStaticBuildEngine
{
public:
	CStaticBuildEngine();
	virtual ~CStaticBuildEngine();
	void Close();

	// a build instance
	typedef struct
	{
		CBldFileRegistry* s_preg;		// registry
		CBldFileDepGraph* s_pgraph;	// dependency graph
	} SBldInst;

	SBldInst* AddBuildInst(CBldCfgRecord* pCfgRecord);
	void RemoveBuildInst(CBldCfgRecord* pCfgRecord);

	// \/ Build instance (graph + registry) manipulation for items
	CBldFileRegistry* GetRegistry(VCProject* pProject, VCConfiguration* pCfg);
	CBldFileRegistry* GetRegistry(CBldCfgRecord* pCfgRecord);
	CBldFileDepGraph* GetDepGraph(VCProject* pProject, VCConfiguration* pCfg);
	CBldFileDepGraph* GetDepGraph(CBldCfgRecord* pCfgRecord);

	CBldCfgRecord* GetCfgRecord(IDispatch* pProject, IDispatch* pCfg);
	void RemoveCfgRecord(IDispatch* pProject, IDispatch* pCfg);
	CBldProjectRecord* GetProjectRecord(IDispatch* pProject, BOOL bCreateIfNeeded = TRUE);
	void RemoveProjectRecord(IDispatch* pProject);

	// Set the graph mode for all dep graphs of this project
	void SetGraphMode(UINT mode, IDispatch* pProject);

	// Return a character pointer to a memory mapped file (also close the file)

	// NOTE: That this function is explicitly MBCS, because source code is MBCS ( yes, ANSI )
	// 	  We may / will need to rewrite when we start supporting UTF8/Unicode source code.
	BOOL OpenMemFile(BldFileRegHandle frh, HANDLE& hMap, const char *& pcFileMap, DWORD& dwFileSize,
		IVCBuildErrorContext* pEC = NULL, IVCBuildAction* pAction = NULL);
 	BOOL CloseMemFile(HANDLE& hMap, IVCBuildErrorContext* pEC = NULL);

	// Delete a file from the disk
	BOOL DeleteFile(BldFileRegHandle, IVCBuildErrorContext* pEC = NULL, VCConfiguration* pConfig = NULL,
		IVCBuildActionList* pActionList = NULL);

private:
	// Build instance map
	CVCMapPtrToPtr m_mapBldInst;

	CBldSolutionRecord m_SolutionRecord;
	CVCPtrList	m_MemFiles;

public:
	// debugging options
	DWORD m_dwDebugging;

public:
	int GetNextItem(CStringW& strList, int nNextIdx, int nMaxIdx, CStringW& strSeparator, CStringW& strItem);	// helper for traversing strSeparator delimited lists
	int FindFirstSeparator(CStringW& strList, CStringW& strSeparatorList, int nStartIdx);

protected:
	int GetNextQuotedItem(CStringW& strList, int nStartIdx, int nMaxIdx, int nSep, int nLastQuote, BOOL bOddQuote, 
		CStringW& strSeparator, CStringW& strItem);	// helper for GetNextItem
};

class CDynamicBuildEngine : 
	public IDispatchImpl<IVCBuildEngine, &IID_IVCBuildEngine, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCBuildEngineImpl,
    public IENCBuildSpawner,
	public CComObjectRoot
{
public:
	CDynamicBuildEngine();
	~CDynamicBuildEngine() {}
	static HRESULT CreateInstance(IVCBuildEngine** ppEngine);

BEGIN_COM_MAP(CDynamicBuildEngine)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCBuildEngine)
	COM_INTERFACE_ENTRY(IVCBuildEngineImpl)
	COM_INTERFACE_ENTRY(IENCBuildSpawner)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDynamicBuildEngine) 

// IVCBuildEngine
public:
	STDMETHOD(get_SpawnerActive)(VARIANT_BOOL* pbSpawnerActive);
	STDMETHOD(get_CanSpawnBuild)(VARIANT_BOOL* pbCanSpawn);
	STDMETHOD(get_UserStoppedBuild)(VARIANT_BOOL *pVal);
	STDMETHOD(get_HaveLogging)(VARIANT_BOOL *pVal);
	STDMETHOD(LogTrace)(int fFlags, BSTR bstrMessage);
	STDMETHOD(get_CurrentLogSection)(eLogSectionTypes* peSection);
	STDMETHOD(put_CurrentLogSection)(eLogSectionTypes eSection);
	STDMETHOD(FormCommandLine)(BSTR bstrToolExeName, BSTR bstrCmdLineIn, IVCBuildErrorContext* pEC, BOOL fRspFileOK, 
		BOOL fLogCommand, BSTR* pbstrCmdLineOut);
	STDMETHOD(FormBatchFile)(BSTR bstrCmdLineIn, IVCBuildErrorContext* pEC, BSTR* pbstrCmdLineOut);
	STDMETHOD(FormTempFile)(BSTR bstrCmdLineIn, BSTR bstrComment, BSTR* pbstrCmdLineOut);
	STDMETHOD(FormXMLCommand)(BSTR bstrCmdLineIn, BSTR bstrExe, BSTR bstrExtraArgs, BSTR* pbstrCmdLineOut);
	STDMETHOD(ExecuteCommandLines)(IVCCommandLineList* pCmds, BSTR bstrDir, VARIANT_BOOL fCheckForComSpec, 
		VARIANT_BOOL fIgnoreErrors, IVCBuildErrorContext* pEC, CMD* pCmdRet);
	STDMETHOD(AddMissingEnvironmentVariable)(BSTR bstrMissingVar);
	STDMETHOD(ClearPendingEnvironmentVariableWarnings)();
	STDMETHOD(AddToOutputDirectoryList)(BSTR bstrDir);
	STDMETHOD(StopBuild)();
	STDMETHOD(get_ReuseLogFile)(VARIANT_BOOL* pbReuse);
	STDMETHOD(put_ReuseLogFile)(VARIANT_BOOL bReuse);

public:
	BOOL m_bUserCanceled;
	BOOL m_bUserInformedAboutCancel;

// IVCBuildEngineImpl
public:
	STDMETHOD(get_BuildThread)(IVCBuildThread** ppThread);
	STDMETHOD(get_ErrorContext)(IVCBuildErrorContext** ppErrContext);
	STDMETHOD(put_ErrorContext)(IVCBuildErrorContext* pErrContext);
	STDMETHOD(get_DoIdleAndPump)(BOOL* pbDoIdleAndPump);
	STDMETHOD(put_DoIdleAndPump)(BOOL bIdleAndPump);
	STDMETHOD(OpenProjectConfigurationLog)(VCConfiguration *pProjCfg);
	STDMETHOD(CloseProjectConfigurationLog)();
	STDMETHOD(DoBuild)(void* pcrBuild, BOOL bIsProjectBuild, IVCBuildErrorContext* pEC, void* frhStart, bldAttributes aob, 
		bldActionTypes type, BOOL fRecurse, IVCBuildAction* pAction, BuildResults* pbrResults);
	STDMETHOD(HasBuildState)(void* pcrBuild, IVCBuildErrorContext* pEC, VARIANT_BOOL* pbUpToDate);
	STDMETHOD(get_ScannerCache)(void ** ppScannerCache);
	STDMETHOD(InitializeSpawner)(BOOL bHidden);
	STDMETHOD(TerminateSpawner)();
	STDMETHOD(SpawnBuild)(IVCCommandLineList* pCmds, LPCOLESTR szDir, BOOL fCheckForComspec, BOOL fIgnoreErrors, 
		IVCBuildErrorContext* pEC, BOOL fAsyncSpawn, long* pnRetVal);
	STDMETHOD(InitializeForBuild)();
	STDMETHOD(get_LogFile)( BSTR *bstrLogFile );
	STDMETHOD(GetDeploymentDependencies)(void* pcrBuild, IVCBuildStringCollection** ppDeployStrings);

// IENCBuildSpawner
public:
	STDMETHOD(StartSpawn)(LPCOLESTR szCurrentDir, LPCOLESTR szCmdLine, IVCBuildErrorContext *pIVCBuildErrorContext, IENCBuildSpawnerCallback *pCallback, BOOL fUseConsoleCP);
	STDMETHOD(StopSpawn)();
	STDMETHOD(IsSysHeader)(LPCOLESTR szIncFileName);

// helper for multi-threading build cancel
	void InformUserCancel();

// helpers for IVCBuildEngine
protected:
	BOOL HaveLogging();
	void AddBuildEventTool(IVCBuildActionList* pBuildActions, LPOLESTR szBuildEventToolShortName, 
		CBldActionListHolder& lstActions);
	void AddNMakeTool(IVCBuildActionList* pBuildActions, CBldActionListHolder& lstActions);
	HRESULT DoWildCardCleanup(VCConfiguration* pConfig, bldActionTypes type, IVCBuildErrorContext* pEC);

	// Form a command-line, may use a response file if too long
	BOOL FormCmdLine(CStringW& strToolExeName, CStringW& strCmdLine, IVCBuildErrorContext* pEC, BOOL fRspFileOk = TRUE, 
		BOOL fLogCommand = TRUE);
	BOOL FormBatchFile(CStringW& strCmdLine, IVCBuildErrorContext* pEC);
	BOOL FormTempFile(CStringW& strCmdLine, CStringW& strComment);
	BOOL FormXMLCommand(CStringW& strCmdLine, CStringW& strExtraArgs, CStringW& strExe);

	// Batching command-lines
	// 1) FALSE->TRUE == start batching
	// 2) TRUE->FALSE == flush currently batched command-lines
	// Returns ExecuteCmdLines() error value if flushing command-lines in 2)
	CMD BatchCmdLines(BOOL fBatch = TRUE);
	CMD FlushCmdLines();
    void ClearCmdLines();

	// /\ File Utility functions 

	// /\ Build instance manipulation items

	// \/ Building of project
	//
	// 'pcrBuild' is the configuration of the build
	//
	// 'EC' is the destination of error messages during build
	//
	// 'frhStart' is the file to build (default is all target files in graph)
	//
	// 'aob' is the attributes of the build
	// o AOB_Default		- default
	// o AOB_IgnoreErrors	- ignore errors
	//
	// 'type' is the type of build
	// o TOB_Build			- build
	// o TOB_ReBuild		- rebuild
	//
	// 'statefilter' is the state to check for in BuildState()
	// 'lstFrh' is the list of files that match 'statefilter' approp.
	//
	// 'fVerbose' will cause the build to prompt, eg. 'settings changed' etc.
	BuildResults DoBuild(CBldCfgRecord* pcrBuild, BOOL bIsProjectBuild, IVCBuildErrorContext* pEC,
		BldFileRegHandle frhStart = (BldFileRegHandle)NULL, bldAttributes aob = AOB_Default, 
		bldActionTypes type = TOB_Build, BOOL fRecurse = TRUE, IVCBuildAction* pAction = NULL);
	// /\ Building of project

	void GetDeploymentDependencies(CBldCfgRecord* pcrBuild, IVCBuildStringCollection** ppDeployStrings);

// IVCBuildEngineImpl
protected:
	BOOL m_bDoIdleAndPump;
	BOOL m_bReuseLogFile;

	// stuff for build logging
	void CDECL LogTrace(eLogSectionTypes logSection, LPCOLESTR szBuffer);
	void FlushLogSection(eLogSectionTypes logSection);
	void SetCurrentLogSection(eLogSectionTypes logSection);
	eLogSectionTypes GetCurrentLogSection();

	// \/ Command Tool Interface functions
	// Execute some command-lines
	CMD ExecuteCmdLines(IVCCommandLineList* pCmds, CStringW& rstrDir, BOOL fCheckForComSpec, BOOL fIgnoreErrors, 
		IVCBuildErrorContext* pEC = NULL);

	// /\ Command Tool Interface functions 	
	
	__inline void NukeTempFiles(IVCBuildErrorContext* pEC)
		{ TmpMaker.NukeFiles(pEC); }

// some helpers
public:
	CBldCfgRecord* GetAssociatedCfgRecord() { return m_pCfgRecord; }
	static UINT GetCodePage(BOOL bWantConsoleCP = TRUE);

private:
	// internal
	CMD ExecuteCmdLinesI(IVCCommandLineList*, CDirW&, BOOL fCheckForComSpec, BOOL fIgnoreErrors, 
		IVCBuildErrorContext* pEC = NULL);
	BuildResults ConvertFromCMDToBuildResults(CMD cmd);
	void DeleteOneFile(WIN32_FIND_DATAW& findWild, CStringW& strWild, CDirW& dirIntDir, IVCBuildErrorContext* pEC,
		VCConfiguration* pConfig);

	void FlushSingleLogSection(CVCStringWList* pLogList);
	CVCStringWList* FindLogBuffer(eLogSectionTypes logSection, BOOL bAdvanceOne = FALSE, 
		eLogSectionTypes* pNewLogSection = NULL);

private:
	FILE *m_pLogFile;
	CStringW m_strLogFile;
	int m_cReuseLogFile;
	BOOL m_bFirstUsage;
	eLogSectionTypes m_logCurrentSection;
	CVCStringWList m_logHeaderLines;
	CVCStringWList m_logEnvironmentLines;
	CVCStringWList m_logCommandLines;
	CVCStringWList m_logOutputLines;
	CVCStringWList m_logResultsLines;
	CVCStringWList m_logFooterLines;
	CBldSpawner m_Spawner;	// our spawner

	CVCMapStringWToPtr m_mapMissingEnvVars;
	CVCMapStringWToPtr m_mapMissingEnvVarsNoCase;
	CVCMapStringWToPtr m_mapOutputDirs;
	int m_actualErrs;
	int m_warns;

	BOOL		m_fBatchCmdLines;
	CTempMaker	TmpMaker;

	// an output window error context
	CComPtr<IVCBuildErrorContext> m_spBuildErrorContext;
	CComPtr<IVCCommandLineList>	m_spCmds;
	CBldCfgRecord*	m_pCfgRecord;

	CDirW			m_dirLast;
	BOOL			m_fLastCheckForComSpec;
	BOOL			m_fLastIgnoreErrors;
	IVCBuildErrorContext*	m_pECLast;

	CBldScannerCache m_ScannerCache;
	static UINT s_iConsoleCodePage;
	static UINT s_iANSICodePage;

// IENCBuildSpawner
protected:
    CEncBldThrd m_encBldThread;
};

class CBldHoldRegRecalcs
{
public:
	enum enumRegSet { eNullRegSet, eScannedRegSet, eSourceRegSet };
	CBldHoldRegRecalcs(IVCBuildAction* pAction, enumRegSet eSet);
	~CBldHoldRegRecalcs();
protected:
	CBldFileRegSet* m_pRegSet;
	BOOL m_fOldOn;
};

extern CStaticBuildEngine g_StaticBuildEngine;
extern BOOL g_bInProjClose;			// project close in progress
extern BOOL g_bInStyleClose;		// style sheet close in progress
extern BOOL g_bInStyleLoad;			// style sheet load in progress
extern BOOL g_bInFileChangeMode;	// file is being changed (added, removed, etc.)

#endif	// __BUILDENGINE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\buildlogging.h ===
#pragma once

// #include <ErrContext.h>
#include "VCProjectEngine.h"

class CBldCommandLineEC :
	public IDispatchImpl<IVCBuildErrorContext, &IID_IVCBuildErrorContext, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot
{
public:
	CBldCommandLineEC()
	{
		s_cnt++;
		m_nContext = s_cnt;
		m_nErrors = 0;
		m_nWarnings = 0;
		m_bShowOutput = VARIANT_TRUE;
	}
	virtual ~CBldCommandLineEC() {}
	static HRESULT CreateInstance(IVCBuildErrorContext** ppContext, CBldCommandLineEC** ppContextObj, 
		IVCBuildEngine* pBuildEngine);
	static void CloseOutputWindow();

BEGIN_COM_MAP(CBldCommandLineEC)
	COM_INTERFACE_ENTRY(IVCBuildErrorContext)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CBldCommandLineEC) 

// IVCBuildErrorContext
public:
	STDMETHOD(AddError)(BSTR bstrMessage, BSTR bstrHelp ,BSTR bstrFile, long nLine, BSTR bstrFullMsg );
	STDMETHOD(AddWarning)(BSTR bstrMessage, BSTR bstrHelp, BSTR bstrFile, long nLine, BSTR bstrFullMsg );
	STDMETHOD(AddInfo)(BSTR bstrMessage);
	STDMETHOD(AddLine)(BSTR bstrMessage);
	STDMETHOD(WriteLog)(BSTR bstrMessage);
	STDMETHOD(ActivateWindow)(VARIANT_BOOL bForce) { return S_OK; }
	STDMETHOD(ActivateTaskList)(VARIANT_BOOL bForce) { return S_OK; }
	STDMETHOD(Close)() { return S_OK; }
	STDMETHOD(ClearWindow)();
	STDMETHOD(get_BaseDirectory)(BSTR* pbstrBaseDir);
	STDMETHOD(put_BaseDirectory)(BSTR bstrBaseDir);
	STDMETHOD(get_ProjectName)(BSTR* pbstrName);
	STDMETHOD(put_ProjectName)(BSTR bstrName);
	STDMETHOD(get_Warnings)( long *pnWrn );
	STDMETHOD(get_Errors)( long *pnErr );
	STDMETHOD(get_AssociatedBuildEngine)(IDispatch** ppBldEngine);
	STDMETHOD(put_AssociatedBuildEngine)(IDispatch* pBldEngine);
	STDMETHOD(get_ShowOutput)(VARIANT_BOOL* pbShow);
	STDMETHOD(put_ShowOutput)(VARIANT_BOOL bShow);

protected:
	int m_nContext;
	static int s_cnt;
	long m_nErrors;
	long m_nWarnings;
	VARIANT_BOOL m_bShowOutput;
	CComBSTR m_bstrDir;
	CComBSTR m_bstrName;
	CComQIPtr<IVCBuildEngine> m_spBuildEngine;
};

class CBldLogEnabler 
{ 
public:
	CBldLogEnabler(VCConfiguration *pProjCfg, IVCBuildEngine* pBuildEngine);
	~CBldLogEnabler();
protected:
	CComQIPtr<IVCBuildEngineImpl> m_spBuildEngineImpl;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\buildengine.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include "BuildEngine.h"
#include "msgboxes2.h"
#include "scanner.h"
#include "BldThread.h"
#include <mbctype.h>
#include "EnvDaemon.h"
#include "BldEventTool.h"
#include "MRDependencies.h"
#include "util2.h"
#include "register.h"
#include "xmlfile.h"

BOOL g_bInProjClose = FALSE;		// project close in progress
BOOL g_bInProjLoad = FALSE;			// project load in progres
BOOL g_bInStyleClose = FALSE;		// style sheet close in progress
BOOL g_bInStyleLoad = FALSE;		// style sheet load in progress
BOOL g_bInFileChangeMode = FALSE;	// file is being changed (added, removed, etc.)

CTestableSection g_sectionMemFiles;
CTestableSection g_sectionCfgRecords;

#ifdef	DIANEME_DEP_CHECK_DIAGNOSTICS
static int s_nCurrentBuild = 0;
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

typedef struct tagMEMFILE
{
	HANDLE	        hFile;
	HANDLE	        hMap;
	const char *	pcFileMap;
} MEMFILE;			  

// our instance of the static build engine
CStaticBuildEngine g_StaticBuildEngine;		// build engine housekeeping stuff

CBldHoldRegRecalcs::CBldHoldRegRecalcs(IVCBuildAction* pAction, enumRegSet eSet)
{
	m_pRegSet = NULL;

	switch (eSet)
	{
	case eScannedRegSet:
		pAction->get_ScannedDependencies((void **)&m_pRegSet);
		break;
	case eSourceRegSet:
		pAction->get_SourceDependencies((void **)&m_pRegSet);
		break;
	case eNullRegSet:	// want ability to have this object do no work
		m_pRegSet = NULL;
		break;
	default:
		VSASSERT(FALSE, "No default state for which regset to hold recalculations for...");
		return;
	}

	if (m_pRegSet)
		m_fOldOn = m_pRegSet->CalcAttributes(FALSE);
}

CBldHoldRegRecalcs::~CBldHoldRegRecalcs()
{
	if (m_pRegSet)
		m_pRegSet->CalcAttributes(m_fOldOn);
}

/////////////////////////////////////////////////////////////////////////////////////////////
// CStaticBuildEngine
//		This class handles all the solution-wide, more or less static bookkeeping stuff
//		for building.
//
//		There is only one instance of this class: g_StaticBuildEngine
/////////////////////////////////////////////////////////////////////////////////////////////
CStaticBuildEngine::CStaticBuildEngine()
{
#ifdef DIANEME_TODO	// CStaticBuildEngine::CStaticBuildEngine; debugging reg key
#ifdef _DEBUG
	DWORD dwDbg = 0;

	// construct our registry key
	CStringW strKeyName(::GetRegistryKeyNameW());


	strKeyName += L"\\";
	strKeyName += szRegKey;

	HKEY hKey;
	// load the '\\Debugging' key
	if (RegOpenKeyExW(HKEY_CURRENT_USER, strKeyName, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType, dwValueSize = sizeof(DWORD);
		if (RegQueryValueExW(hKey, L"Debugging", NULL, &dwType, (LPBYTE)&dwDbg, &dwValueSize) == ERROR_SUCCESS)
		{
		  	// make sure we get the value we expect
			VSASSERT(dwType == REG_DWORD, "Unexpected registry value type for Debugging key");
			VSASSERT(dwValueSize == sizeof(DWORD), "Unexpected registry value type for Debugging key");
		}

		RegCloseKey(hKey); // close the key we just opened
	} 

#endif
#endif	// DIANEME_TODO -- CStaticBuildEngine::CStaticBuildEngine

#ifdef _DEBUG
#ifdef DIANEME_TODO // CStaticBuildEngine::CStaticBuildEngine; debugging reg key
	m_dwDebugging = dwDbg;
#else	// DIANEME_TODO -- CStaticBuildEngine::CStaticBuildEngine
	m_dwDebugging = 0;
#endif	// DIANEME_TODO -- CStaticBuildEngine::CStaticBuildEngine
#else // _DEBUG
	m_dwDebugging = 0;	// off
#endif // !_DEBUG
}

CStaticBuildEngine::~CStaticBuildEngine()
{
	VSASSERT(m_MemFiles.IsEmpty(), "Failed to empty out the collection of mem files before closing down build system");
}

void CStaticBuildEngine::Close()
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	VCPOSITION pos;
	pos = m_mapBldInst.GetStartPosition();
	while (pos)
	{
		SBldInst* pbldinst;
		CBldCfgRecord* pCfgRecord;
		void *pItem;

		m_mapBldInst.GetNextAssoc(pos, (void*&)pCfgRecord, pItem);
		pbldinst = (SBldInst *)pItem;
		if (pbldinst)
		{
			delete pbldinst->s_pgraph;
			pbldinst->s_preg->EmptyContent();
			delete pbldinst->s_preg;
			delete pbldinst;
		}
		m_mapBldInst.RemoveKey((void *)pCfgRecord);
	}
	m_SolutionRecord.Close();
}

CStaticBuildEngine::SBldInst* CStaticBuildEngine::AddBuildInst(CBldCfgRecord* pCfgRecord)
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	SBldInst* pbldinst;

	if (m_mapBldInst.Lookup(pCfgRecord, (void *&)pbldinst))
		return pbldinst;	// already got one!

	// add a build instance for the currently active config.

	// allocate
	pbldinst = new SBldInst;
	pbldinst->s_preg = new CBldFileRegistry(pCfgRecord);
	pbldinst->s_pgraph = new CBldFileDepGraph(pbldinst->s_preg);

	// set in our lookup map
	m_mapBldInst.SetAt((void *)pCfgRecord, (void *)pbldinst);

	return pbldinst;
}

void CStaticBuildEngine::RemoveBuildInst(CBldCfgRecord* pCfgRecord)
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	// remove a build instance for the currently active config.
	SBldInst* pbldinst = NULL;
	if (m_mapBldInst.Lookup((void *)pCfgRecord, (void *&)pbldinst) && pbldinst)
	{
		// de-allocate
		delete pbldinst->s_pgraph;
		delete pbldinst->s_preg;
		delete pbldinst;
	}

	// remove from our lookup map
	m_mapBldInst.RemoveKey((void *)pCfgRecord);
}

CBldFileRegistry* CStaticBuildEngine::GetRegistry(CBldCfgRecord* pCfgRecord)
{
	// get build instance for specified project/config/toolset combination
	// if one doesn't exist, create one on demand
	SBldInst* pbldinst = AddBuildInst(pCfgRecord);

	return pbldinst->s_preg;
}

CBldFileDepGraph* CStaticBuildEngine::GetDepGraph(CBldCfgRecord* pCfgRecord)
{
	// get build instance for specified project/config/toolset combination
	// if one doesn't exist, create one on demand
	SBldInst* pbldinst = AddBuildInst(pCfgRecord);

	return pbldinst->s_pgraph;
}

CBldFileDepGraph* CStaticBuildEngine::GetDepGraph(VCProject* pProject, VCConfiguration* pCfg)
{
	CBldCfgRecord* pCfgRecord = GetCfgRecord(pProject, pCfg);
	if (pCfgRecord == NULL)
	{
		VSASSERT(FALSE, "Failed to get a matching registry for a CfgRecord");
		return NULL;
	}

	return GetDepGraph(pCfgRecord);
}

CBldFileRegistry* CStaticBuildEngine::GetRegistry(VCProject* pProject, VCConfiguration* pCfg)
{
	CBldCfgRecord* pCfgRecord = GetCfgRecord(pProject, pCfg);
	if (pCfgRecord == NULL)
	{
		VSASSERT(FALSE, "Failed to get a matching registry for a CfgRecord");
		return NULL;
	}

	return GetRegistry(pCfgRecord);
}

CBldCfgRecord* CStaticBuildEngine::GetCfgRecord(IDispatch* pProject, IDispatch* pCfg)
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	return m_SolutionRecord.GetCfgRecord(pProject, pCfg);
}

void CStaticBuildEngine::RemoveCfgRecord(IDispatch* pProject, IDispatch* pCfg)
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	CBldCfgRecord* pCfgRecord = m_SolutionRecord.GetCfgRecord(pProject, pCfg, FALSE);

	if (pCfgRecord == NULL)
		return;

	RemoveBuildInst(pCfgRecord);
	m_SolutionRecord.RemoveCfgRecord(pProject, pCfg);
}

CBldProjectRecord* CStaticBuildEngine::GetProjectRecord(IDispatch* pProject, BOOL bCreateIfNeeded /* = TRUE */)
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	return m_SolutionRecord.GetProjectRecord(pProject, bCreateIfNeeded);
}

void CStaticBuildEngine::RemoveProjectRecord(IDispatch* pProject)
{
	// Prevent access to cfg record list by other threads.
	CritSectionT cs(g_sectionCfgRecords);

	CBldProjectRecord* pProjectRecord = m_SolutionRecord.GetProjectRecord(pProject, FALSE);

	if (pProjectRecord == NULL)
		return;

	VCPOSITION pos = pProjectRecord->GetPtrRecordMap()->GetStartPosition();
	while (pos != (VCPOSITION)NULL)
	{
		CBldCfgRecord* pCfgRecord;
		void* pDummy;
		pProjectRecord->GetPtrRecordMap()->GetNextAssoc(pos, (void*&)pCfgRecord, pDummy);
		RemoveBuildInst(pCfgRecord);
	}
	m_SolutionRecord.RemoveProjectRecord(pProject);
}

void CStaticBuildEngine::SetGraphMode(UINT mode, IDispatch* pProject)
{
	if (pProject == NULL)
		return;
	CBldProjectRecord* pProjRecord = GetProjectRecord(pProject);
	if (pProjRecord == NULL)
		return;
	CVCMapPtrToPtr* pCfgRecordMap = pProjRecord->GetPtrRecordMap();

	VCPOSITION pos = pCfgRecordMap->GetStartPosition();
	while (pos != (VCPOSITION)NULL)
	{
		CBldCfgRecord* pCfgRecord = NULL;
		void* pDummy;
		pCfgRecordMap->GetNextAssoc(pos, (void *&)pCfgRecord, pDummy);
		GetDepGraph(pCfgRecord)->SetGraphMode(mode);
	}
}

BOOL CStaticBuildEngine::OpenMemFile(BldFileRegHandle frh, HANDLE& hMap, const char *& pcFileMap, DWORD& dwFileSize,
	IVCBuildErrorContext* pEC, IVCBuildAction* pAction)
{
    	// NOTE: Because we assume this function is being used to open source code which is MBCS, the output paramater is MBCS
	// Its explicitly NOT TCHAR. When dealing with the contents of the file we should use mbs  and char * NOT _tcs and TCHAR
	// ALL other aspects of this function should be compeltely UNICODE.
    	// yes, ANSI
	
	BOOL fRet = FALSE;	// success?
	HANDLE hFile = INVALID_HANDLE_VALUE;

	// pointer to memory mapped file (== (const TCHAR *)NULL if not available)
	pcFileMap = (const char *)NULL;	// default

	const CPathW* pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();

	for	(;;)
	{
		hMap = NULL;
		pcFileMap = NULL;
		CStringW strPathW;
		*pPath->GetFullPath(strPathW);
		hFile = CreateFileW(strPathW, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			if (pEC)
			{
			    	// REVIEW(KiP) : this is a weird test for error conditions.
				CStringA strPathA = strPathW;
				CStringW strPath2 = strPathA;
				if (strPath2 != strPathW)
				{
					CStringW strMsg;
					strMsg.Format(IDS_ERR_UNICODE_PATH_PRJ0024, strPathW);
					CVCProjectEngine::AddProjectError(pEC, strMsg, L"PRJ0024", pAction);
				}
			}
			break;	// failure
		}

		DWORD dwFileSize2;
		dwFileSize = GetFileSize(hFile, &dwFileSize2);			

		if (dwFileSize == 0xffffffff)
			break;	// failure

		if (dwFileSize == 0)
		{
			CloseHandle(hFile);
			return TRUE;	// ignore
		}

		hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);	// yes, looking for ANSI

		if (hMap == NULL)
			break;	// failure

		pcFileMap = (const char *)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

		break;			// break-out
	}

	if (pcFileMap == (const char *)NULL)
	{
	  	wchar_t errstring [4096];
		DWORD dw = GetLastError();

		if (hMap != NULL)
			CloseHandle(hMap);

		if (hFile != INVALID_HANDLE_VALUE)
			CloseHandle(hFile);
				
		//	Try to get a text message for the error.  This fails if NT doesn't have its error resource:
		errstring[0] = 0;
	 	FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0 /* ignored */, dw,
			LOCALE_USER_DEFAULT, errstring, 4096, 0 /* ignored */);

		VCRemoveNewlines(errstring);
	}
	else
	{
		// Prevent access to memory mapped files list by other threads.
		CritSectionT cs(g_sectionMemFiles);

		fRet = TRUE;	// success
		MEMFILE * pMemFile = new MEMFILE;
		pMemFile->hFile = hFile;
		pMemFile->hMap = hMap;
		pMemFile->pcFileMap = pcFileMap;

		m_MemFiles.AddTail(pMemFile);
	}

	return fRet;
}

BOOL CStaticBuildEngine::CloseMemFile(HANDLE& hMap, IVCBuildErrorContext* pEC)
{
	// Prevent access to memory mapped files list by other threads.
	CritSectionT cs(g_sectionMemFiles);

	// Look for a memory mapped file entry in our list which has the same mapping object handle
    MEMFILE * pMemFile; 
	VCPOSITION posCurr;
	VCPOSITION pos = m_MemFiles.GetHeadPosition();
	while (pos != NULL)
	{
        posCurr = pos;
		pMemFile = (MEMFILE *) m_MemFiles.GetNext(pos);
		if (pMemFile->hMap == hMap)
		{
			// close this memory mapped file
			UnmapViewOfFile((LPVOID) pMemFile->pcFileMap);
			CloseHandle(pMemFile->hMap);
			CloseHandle(pMemFile->hFile);

            // Remove the MEMFILE entry from our list
            delete pMemFile;
            m_MemFiles.RemoveAt(posCurr);

			return TRUE;
		}		
	}

	// We failed to close the requested file	
	return FALSE;
}

BOOL CStaticBuildEngine::DeleteFile(BldFileRegHandle frh, IVCBuildErrorContext* pEC, VCConfiguration* pConfig,
	IVCBuildActionList* pActionList)
{
	BOOL fRet = TRUE;	// default is success

	if (!g_FileRegistry.DeleteFile(frh))
	{
		DWORD dw = GetLastError();
		if (dw !=  ERROR_FILE_NOT_FOUND && dw != ERROR_PATH_NOT_FOUND)
		{
			wchar_t buf[4096]; buf[0] = L'\0';

			// we get NO_ERROR sometimes!
			if (dw != NO_ERROR)
			{
				// place a ': ' between 'cannot delete' and system messages
				buf[0] = L':'; buf[1] = L' ';

				FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 0 /* ignored */,
					dw, LOCALE_USER_DEFAULT, buf + 2, 4094, 0 /* ignored */);
				VCRemoveNewlines(buf);
			}

			CStringW strError;
			::VCMsgTextW(strError, IDS_PROJ_COULD_NOT_DELETE_FILE_PRJ008,
				(const wchar_t *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath(), buf);

			if (pEC != NULL)
			{
				CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
				if (pConfig)
					CVCProjectEngine::AddProjectError(pEC, strError, L"PRJ0008", spPropContainer);
				else
					CVCProjectEngine::AddProjectError(pEC, strError, L"PRJ0008", pActionList);
			}

			fRet = FALSE;	// failure
		}
	}

	return fRet;
}

int CStaticBuildEngine::FindFirstSeparator(CStringW& strList, CStringW& strSeparatorList, int nStartIdx)
{
	int cSeparators = strSeparatorList.GetLength();
	if (cSeparators == 0)	// no separators means give back first char of list
		return 0;
	else if (cSeparators == 1)
		return strList.Find(strSeparatorList, nStartIdx);

	// got here; means we have the potential for multiple separator possibilities
	int nMinSep = -1, nThisSep = -1;
	for (int idx = 0; idx < cSeparators; idx++)
	{
		nThisSep = strList.Find(strSeparatorList.GetAt(idx), nStartIdx);
		if (nThisSep >= 0 && ((nThisSep < nMinSep) || (nMinSep < 0)))
			nMinSep = nThisSep;
	}

	return nMinSep;
}

int CStaticBuildEngine::GetNextItem(CStringW& strList, int nStartIdx, int nMaxIdx, CStringW& strSeparator, CStringW& strItem)
{
	strItem.Empty();
	if (nStartIdx < 0)
		return nStartIdx;
	else if (nStartIdx >= nMaxIdx)
		return -1;

	int nSep = FindFirstSeparator(strList, strSeparator, nStartIdx);
	if (nSep >= 0)
	{
		int nQuote = strList.Find(L'"', nStartIdx);
		if (nQuote >= nStartIdx && nQuote < nSep)	// need to get outside the quoted string
			return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, TRUE, strSeparator, strItem);
		strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
		nSep++;
		return nSep;
	}

	if (nStartIdx < nMaxIdx)
		strItem = strList.Right(nMaxIdx-nStartIdx);

	return -1;
}

int CStaticBuildEngine::GetNextQuotedItem(CStringW& strList, int nStartIdx, int nMaxIdx, int nSep, int nLastQuote,
	BOOL bOddQuote, CStringW& strSeparator, CStringW& strItem)
{
	if (bOddQuote)
	{
		int nQuote = strList.Find(L'"', nLastQuote+1);
		if (nQuote < nSep)	// doesn't matter that we found a quote
		{
			strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
			nSep++;
			return nSep;
		}
		else
			return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, FALSE, strSeparator, strItem);
	}
	else	// even quote
	{
		nSep = FindFirstSeparator(strList, strSeparator, nLastQuote+1);
		if (nSep >= 0)
		{
			int nQuote = strList.Find(L'"', nLastQuote+1);
			if (nQuote > nLastQuote && nQuote < nSep)	// still need to get outside the quoted string
				return GetNextQuotedItem(strList, nStartIdx, nMaxIdx, nSep, nQuote, TRUE, strSeparator, strItem);
			strItem = strList.Mid(nStartIdx, nSep-nStartIdx);
			nSep++;
			return nSep;
		}

		if (nStartIdx < nMaxIdx)
			strItem = strList.Right(nMaxIdx-nStartIdx);
		
		return -1;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CDynamicBuildEngine
//		This class handles all the stuff for actually doing a build.  It owns the spawner, log file, etc.
//		Ideally, you would spin up one of these every time you do a build.  If you don't, be sure to
//		reinitialize things before doing a build (InitializeForBuild).
////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT CDynamicBuildEngine::s_iConsoleCodePage = 0;
UINT CDynamicBuildEngine::s_iANSICodePage = 0;

CDynamicBuildEngine::CDynamicBuildEngine()
{
	InitializeForBuild();
}

STDMETHODIMP CDynamicBuildEngine::StopBuild()
{
	m_bUserCanceled = TRUE;
	if (m_Spawner.SpawnActive())
		m_Spawner.DoSpawnCancel();
	return S_OK;
}

CMD CDynamicBuildEngine::FlushCmdLines()
{
	CMD cmd = CMD_Complete;

	// execute our currently batched commands
	cmd = ExecuteCmdLinesI(m_spCmds, m_dirLast, m_fLastCheckForComSpec, m_fLastIgnoreErrors, m_pECLast);

	// flush
	if (m_spCmds != NULL)
		m_spCmds->RemoveAll();

	return cmd;
}

void CDynamicBuildEngine::ClearCmdLines()
{
    // Clear out any batched cmds - important if we stop a build in the