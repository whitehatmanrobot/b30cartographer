ath='docs/doc[@for="VSStd2KCmdID.CallBrowser11ShowCallsFrom"]/*' />
            CallBrowser11ShowCallsFrom = 2040,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12ShowCallsFrom"]/*' />
            CallBrowser12ShowCallsFrom = 2041,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13ShowCallsFrom"]/*' />
            CallBrowser13ShowCallsFrom = 2042,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14ShowCallsFrom"]/*' />
            CallBrowser14ShowCallsFrom = 2043,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15ShowCallsFrom"]/*' />
            CallBrowser15ShowCallsFrom = 2044,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16ShowCallsFrom"]/*' />
            CallBrowser16ShowCallsFrom = 2045,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1ShowFullNames"]/*' />
            CallBrowser1ShowFullNames = 2046,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2ShowFullNames"]/*' />
            CallBrowser2ShowFullNames = 2047,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3ShowFullNames"]/*' />
            CallBrowser3ShowFullNames = 2048,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4ShowFullNames"]/*' />
            CallBrowser4ShowFullNames = 2049,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5ShowFullNames"]/*' />
            CallBrowser5ShowFullNames = 2050,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6ShowFullNames"]/*' />
            CallBrowser6ShowFullNames = 2051,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7ShowFullNames"]/*' />
            CallBrowser7ShowFullNames = 2052,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8ShowFullNames"]/*' />
            CallBrowser8ShowFullNames = 2053,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9ShowFullNames"]/*' />
            CallBrowser9ShowFullNames = 2054,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10ShowFullNames"]/*' />
            CallBrowser10ShowFullNames = 2055,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11ShowFullNames"]/*' />
            CallBrowser11ShowFullNames = 2056,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12ShowFullNames"]/*' />
            CallBrowser12ShowFullNames = 2057,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13ShowFullNames"]/*' />
            CallBrowser13ShowFullNames = 2058,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14ShowFullNames"]/*' />
            CallBrowser14ShowFullNames = 2059,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15ShowFullNames"]/*' />
            CallBrowser15ShowFullNames = 2060,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16ShowFullNames"]/*' />
            CallBrowser16ShowFullNames = 2061,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1Settings"]/*' />
            CallBrowser1Settings = 2062,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2Settings"]/*' />
            CallBrowser2Settings = 2063,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3Settings"]/*' />
            CallBrowser3Settings = 2064,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4Settings"]/*' />
            CallBrowser4Settings = 2065,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5Settings"]/*' />
            CallBrowser5Settings = 2066,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6Settings"]/*' />
            CallBrowser6Settings = 2067,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7Settings"]/*' />
            CallBrowser7Settings = 2068,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8Settings"]/*' />
            CallBrowser8Settings = 2069,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9Settings"]/*' />
            CallBrowser9Settings = 2070,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10Settings"]/*' />
            CallBrowser10Settings = 2071,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11Settings"]/*' />
            CallBrowser11Settings = 2072,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12Settings"]/*' />
            CallBrowser12Settings = 2073,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13Settings"]/*' />
            CallBrowser13Settings = 2074,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14Settings"]/*' />
            CallBrowser14Settings = 2075,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15Settings"]/*' />
            CallBrowser15Settings = 2076,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16Settings"]/*' />
            CallBrowser16Settings = 2077,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SortAlpha"]/*' />
            CallBrowser1SortAlpha = 2078,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SortAlpha"]/*' />
            CallBrowser2SortAlpha = 2079,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SortAlpha"]/*' />
            CallBrowser3SortAlpha = 2080,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SortAlpha"]/*' />
            CallBrowser4SortAlpha = 2081,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SortAlpha"]/*' />
            CallBrowser5SortAlpha = 2082,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SortAlpha"]/*' />
            CallBrowser6SortAlpha = 2083,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SortAlpha"]/*' />
            CallBrowser7SortAlpha = 2084,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SortAlpha"]/*' />
            CallBrowser8SortAlpha = 2085,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SortAlpha"]/*' />
            CallBrowser9SortAlpha = 2086,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SortAlpha"]/*' />
            CallBrowser10SortAlpha = 2087,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SortAlpha"]/*' />
            CallBrowser11SortAlpha = 2088,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SortAlpha"]/*' />
            CallBrowser12SortAlpha = 2089,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SortAlpha"]/*' />
            CallBrowser13SortAlpha = 2090,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SortAlpha"]/*' />
            CallBrowser14SortAlpha = 2091,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SortAlpha"]/*' />
            CallBrowser15SortAlpha = 2092,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SortAlpha"]/*' />
            CallBrowser16SortAlpha = 2093,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SortAccess"]/*' />
            CallBrowser1SortAccess = 2094,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SortAccess"]/*' />
            CallBrowser2SortAccess = 2095,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SortAccess"]/*' />
            CallBrowser3SortAccess = 2096,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SortAccess"]/*' />
            CallBrowser4SortAccess = 2097,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SortAccess"]/*' />
            CallBrowser5SortAccess = 2098,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SortAccess"]/*' />
            CallBrowser6SortAccess = 2099,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SortAccess"]/*' />
            CallBrowser7SortAccess = 2100,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SortAccess"]/*' />
            CallBrowser8SortAccess = 2101,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SortAccess"]/*' />
            CallBrowser9SortAccess = 2102,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SortAccess"]/*' />
            CallBrowser10SortAccess = 2103,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SortAccess"]/*' />
            CallBrowser11SortAccess = 2104,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SortAccess"]/*' />
            CallBrowser12SortAccess = 2105,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SortAccess"]/*' />
            CallBrowser13SortAccess = 2106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SortAccess"]/*' />
            CallBrowser14SortAccess = 2107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SortAccess"]/*' />
            CallBrowser15SortAccess = 2108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SortAccess"]/*' />
            CallBrowser16SortAccess = 2109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ShowCallBrowser"]/*' />
            ShowCallBrowser = 2120,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1"]/*' />
            CallBrowser1 = 2121,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2"]/*' />
            CallBrowser2 = 2122,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3"]/*' />
            CallBrowser3 = 2123,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4"]/*' />
            CallBrowser4 = 2124,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5"]/*' />
            CallBrowser5 = 2125,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6"]/*' />
            CallBrowser6 = 2126,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7"]/*' />
            CallBrowser7 = 2127,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8"]/*' />
            CallBrowser8 = 2128,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9"]/*' />
            CallBrowser9 = 2129,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10"]/*' />
            CallBrowser10 = 2130,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11"]/*' />
            CallBrowser11 = 2131,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12"]/*' />
            CallBrowser12 = 2132,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13"]/*' />
            CallBrowser13 = 2133,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14"]/*' />
            CallBrowser14 = 2134,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15"]/*' />
            CallBrowser15 = 2135,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16"]/*' />
            CallBrowser16 = 2136,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser17"]/*' />
            CallBrowser17 = 2137,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GlobalUndo"]/*' />
            GlobalUndo = 2138,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GlobalRedo"]/*' />
            GlobalRedo = 2139,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsToCmd"]/*' />
            CallBrowserShowCallsToCmd = 2140,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowCallsFromCmd"]/*' />
            CallBrowserShowCallsFromCmd = 2141,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsToCmd"]/*' />
            CallBrowserShowNewCallsToCmd = 2142,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowserShowNewCallsFromCmd"]/*' />
            CallBrowserShowNewCallsFromCmd = 2143,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1Search"]/*' />
            CallBrowser1Search = 2145,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2Search"]/*' />
            CallBrowser2Search = 2146,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3Search"]/*' />
            CallBrowser3Search = 2147,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4Search"]/*' />
            CallBrowser4Search = 2148,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5Search"]/*' />
            CallBrowser5Search = 2149,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6Search"]/*' />
            CallBrowser6Search = 2150,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7Search"]/*' />
            CallBrowser7Search = 2151,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8Search"]/*' />
            CallBrowser8Search = 2152,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9Search"]/*' />
            CallBrowser9Search = 2153,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10Search"]/*' />
            CallBrowser10Search = 2154,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11Search"]/*' />
            CallBrowser11Search = 2155,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12Search"]/*' />
            CallBrowser12Search = 2156,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13Search"]/*' />
            CallBrowser13Search = 2157,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14Search"]/*' />
            CallBrowser14Search = 2158,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15Search"]/*' />
            CallBrowser15Search = 2159,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16Search"]/*' />
            CallBrowser16Search = 2160,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1Refresh"]/*' />
            CallBrowser1Refresh = 2161,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2Refresh"]/*' />
            CallBrowser2Refresh = 2162,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3Refresh"]/*' />
            CallBrowser3Refresh = 2163,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4Refresh"]/*' />
            CallBrowser4Refresh = 2164,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5Refresh"]/*' />
            CallBrowser5Refresh = 2165,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6Refresh"]/*' />
            CallBrowser6Refresh = 2166,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7Refresh"]/*' />
            CallBrowser7Refresh = 2167,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8Refresh"]/*' />
            CallBrowser8Refresh = 2168,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9Refresh"]/*' />
            CallBrowser9Refresh = 2169,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10Refresh"]/*' />
            CallBrowser10Refresh = 2170,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11Refresh"]/*' />
            CallBrowser11Refresh = 2171,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12Refresh"]/*' />
            CallBrowser12Refresh = 2172,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13Refresh"]/*' />
            CallBrowser13Refresh = 2173,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14Refresh"]/*' />
            CallBrowser14Refresh = 2174,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15Refresh"]/*' />
            CallBrowser15Refresh = 2175,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16Refresh"]/*' />
            CallBrowser16Refresh = 2176,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SearchCombo"]/*' />
            CallBrowser1SearchCombo = 2180,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SearchCombo"]/*' />
            CallBrowser2SearchCombo = 2181,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SearchCombo"]/*' />
            CallBrowser3SearchCombo = 2182,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SearchCombo"]/*' />
            CallBrowser4SearchCombo = 2183,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SearchCombo"]/*' />
            CallBrowser5SearchCombo = 2184,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SearchCombo"]/*' />
            CallBrowser6SearchCombo = 2185,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SearchCombo"]/*' />
            CallBrowser7SearchCombo = 2186,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SearchCombo"]/*' />
            CallBrowser8SearchCombo = 2187,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SearchCombo"]/*' />
            CallBrowser9SearchCombo = 2188,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SearchCombo"]/*' />
            CallBrowser10SearchCombo = 2189,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SearchCombo"]/*' />
            CallBrowser11SearchCombo = 2190,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SearchCombo"]/*' />
            CallBrowser12SearchCombo = 2191,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SearchCombo"]/*' />
            CallBrowser13SearchCombo = 2192,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SearchCombo"]/*' />
            CallBrowser14SearchCombo = 2193,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SearchCombo"]/*' />
            CallBrowser15SearchCombo = 2194,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SearchCombo"]/*' />
            CallBrowser16SearchCombo = 2195,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TaskListProviderCombo"]/*' />
            TaskListProviderCombo = 2200,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.TaskListProviderComboList"]/*' />
            TaskListProviderComboList = 2201,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CreateUserTask"]/*' />
            CreateUserTask = 2202,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ErrorListShowErrors"]/*' />
            ErrorListShowErrors = 2210,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ErrorListShowWarnings"]/*' />
            ErrorListShowWarnings = 2211,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ErrorListShowMessages"]/*' />
            ErrorListShowMessages = 2212,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Registration"]/*' />
            Registration = 2214,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser1SearchComboList"]/*' />
            CallBrowser1SearchComboList = 2215,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser2SearchComboList"]/*' />
            CallBrowser2SearchComboList = 2216,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser3SearchComboList"]/*' />
            CallBrowser3SearchComboList = 2217,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser4SearchComboList"]/*' />
            CallBrowser4SearchComboList = 2218,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser5SearchComboList"]/*' />
            CallBrowser5SearchComboList = 2219,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser6SearchComboList"]/*' />
            CallBrowser6SearchComboList = 2220,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser7SearchComboList"]/*' />
            CallBrowser7SearchComboList = 2221,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser8SearchComboList"]/*' />
            CallBrowser8SearchComboList = 2222,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser9SearchComboList"]/*' />
            CallBrowser9SearchComboList = 2223,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser10SearchComboList"]/*' />
            CallBrowser10SearchComboList = 2224,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser11SearchComboList"]/*' />
            CallBrowser11SearchComboList = 2225,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser12SearchComboList"]/*' />
            CallBrowser12SearchComboList = 2226,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser13SearchComboList"]/*' />
            CallBrowser13SearchComboList = 2227,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser14SearchComboList"]/*' />
            CallBrowser14SearchComboList = 2228,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser15SearchComboList"]/*' />
            CallBrowser15SearchComboList = 2229,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CallBrowser16SearchComboList"]/*' />
            CallBrowser16SearchComboList = 2230,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SnippetProp"]/*' />
            SnippetProp = 2240,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SnippetRef"]/*' />
            SnippetRef = 2241,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SnippetRepl"]/*' />
            SnippetRepl = 2242,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.StartPage"]/*' />
            StartPage = 2245,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EditorLineFirstColumn"]/*' />
            EditorLineFirstColumn = 2250,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.EditorLineFirstColumnExtend"]/*' />
            EditorLineFirstColumnExtend = 2251,

            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEServerExplorer"]/*' />
            SEServerExplorer = 2260,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEDataExplorer"]/*' />
            SEDataExplorer = 2261,
            
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_VALIDATION_TARGET"]/*' />
            ECMD_VALIDATION_TARGET = 11281,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_VALIDATION_TARGET_GET_LIST"]/*' />
            ECMD_VALIDATION_TARGET_GET_LIST = 11282,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CSS_TARGET"]/*' />
            ECMD_CSS_TARGET = 11283,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ECMD_CSS_TARGET_GET_LIST"]/*' />
            ECMD_CSS_TARGET_GET_LIST = 11284,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Design"]/*' />
            Design = 0x3000,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DesignOn"]/*' />
            DesignOn = 0x3001,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEDesign"]/*' />
            SEDesign = 0x3003,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDiagram"]/*' />
            NewDiagram = 0x3004,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewTable"]/*' />
            NewTable = 0x3006,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDBItem"]/*' />
            NewDBItem = 0x300E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewTrigger"]/*' />
            NewTrigger = 0x3010,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Debug"]/*' />
            Debug = 0x3012,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewProcedure"]/*' />
            NewProcedure = 0x3013,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewQuery"]/*' />
            NewQuery = 0x3014,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RefreshLocal"]/*' />
            RefreshLocal = 0x3015,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbAddDataConnection"]/*' />
            DbAddDataConnection = 0x3017,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DBDefDBRef"]/*' />
            DBDefDBRef = 0x3018,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RunCmd"]/*' />
            RunCmd = 0x3019,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RunOn"]/*' />
            RunOn = 0x301A,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDBRef"]/*' />
            NewDBRef = 0x301B,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SetAsDef"]/*' />
            SetAsDef = 0x301C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CreateCmdFile"]/*' />
            CreateCmdFile = 0x301D,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Cancel"]/*' />
            Cancel = 0x301E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewDatabase"]/*' />
            NewDatabase = 0x3020,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewUser"]/*' />
            NewUser = 0x3021,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewRole"]/*' />
            NewRole = 0x3022,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ChangeLogin"]/*' />
            ChangeLogin = 0x3023,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewView"]/*' />
            NewView = 0x3024,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ModifyConnection"]/*' />
            ModifyConnection = 0x3025,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.Disconnect"]/*' />
            Disconnect = 0x3026,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CopyScript"]/*' />
            CopyScript = 0x3027,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddSCC"]/*' />
            AddSCC = 0x3028,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RemoveSCC"]/*' />
            RemoveSCC = 0x3029,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.GetLatest"]/*' />
            GetLatest = 0x3030,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CheckOut"]/*' />
            CheckOut = 0x3031,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CheckIn"]/*' />
            CheckIn = 0x3032,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UndoCheckOut"]/*' />
            UndoCheckOut = 0x3033,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddItemSCC"]/*' />
            AddItemSCC = 0x3034,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewPackageSpec"]/*' />
            NewPackageSpec = 0x3035,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewPackageBody"]/*' />
            NewPackageBody = 0x3036,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.InsertSQL"]/*' />
            InsertSQL = 0x3037,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RunSelection"]/*' />
            RunSelection = 0x3038,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UpdateScript"]/*' />
            UpdateScript = 0x3039,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewScript"]/*' />
            NewScript = 0x303C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewFunction"]/*' />
            NewFunction = 0x303D,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewTableFunction"]/*' />
            NewTableFunction = 0x303E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.NewInlineFunction"]/*' />
            NewInlineFunction = 0x303F,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddDiagram"]/*' />
            AddDiagram = 0x3040,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddTable"]/*' />
            AddTable = 0x3041,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddSynonym"]/*' />
            AddSynonym = 0x3042,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddView"]/*' />
            AddView = 0x3043,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddProcedure"]/*' />
            AddProcedure = 0x3044,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddFunction"]/*' />
            AddFunction = 0x3045,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddTableFunction"]/*' />
            AddTableFunction = 0x3046,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddInlineFunction"]/*' />
            AddInlineFunction = 0x3047,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddPkgSpec"]/*' />
            AddPkgSpec = 0x3048,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddPkgBody"]/*' />
            AddPkgBody = 0x3049,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.AddTrigger"]/*' />
            AddTrigger = 0x304A,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.ExportData"]/*' />
            ExportData = 0x304B,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsAdd"]/*' />
            DbnsVcsAdd = 0x304C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsRemove"]/*' />
            DbnsVcsRemove = 0x304D,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsCheckout"]/*' />
            DbnsVcsCheckout = 0x304E,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsUndoCheckout"]/*' />
            DbnsVcsUndoCheckout = 0x304F,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DbnsVcsCheckin"]/*' />
            DbnsVcsCheckin = 0x3050,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SERetrieveData"]/*' />
            SERetrieveData = 0x3060,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.SEEditTextObject"]/*' />
            SEEditTextObject = 0x3061,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.DesignSQLBlock"]/*' />
            DesignSQLBlock = 0x3064,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.RegisterSQLInstance"]/*' />
            RegisterSQLInstance = 0x3065,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.UnregisterSQLInstance"]/*' />
            UnregisterSQLInstance = 0x3066,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowSaveScript"]/*' />
            CommandWindowSaveScript = 0x3106,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowRunScript"]/*' />
            CommandWindowRunScript = 0x3107,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorUp"]/*' />
            CommandWindowCursorUp = 0x3108,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorDown"]/*' />
            CommandWindowCursorDown = 0x3109,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorLeft"]/*' />
            CommandWindowCursorLeft = 0x310A,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowCursorRight"]/*' />
            CommandWindowCursorRight = 0x310B,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowHistoryUp"]/*' />
            CommandWindowHistoryUp = 0x310C,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSStd2KCmdID.CommandWindowHistoryDown"]/*' />
            CommandWindowHistoryDown = 0x310D,
        }

        // Editor factory constants

        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_CLONEFILE"]/*' />
        /// <devdoc>Mutually exclusive w/_OPENFILE</devdoc>
        public const uint CEF_CLONEFILE = 0x00000001;
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_OPENFILE"]/*' />
        /// <devdoc>Mutually exclusive w/_CLONEFILE</devdoc>
        public const uint CEF_OPENFILE = 0x00000002;
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_SILENT"]/*' />
        /// <devdoc>Editor factory should create editor silently.</devdoc>
        public const uint CEF_SILENT = 0x00000004;
        /// <include file='doc\VSContants.uex' path='docs/doc[@for="VSConstants.CEF_OPENASNEW"]/*' />
        /// <devdoc>Editor factory should perform necessary fixups.</devdoc>
        public const uint CEF_OPENASNEW = 0x00000008;


        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsUIHierarchyWindowCmds"]/*' />
        /// <summary>Command Group GUID for commands that only apply to the UIHierarchyWindow.</summary>
        public static readonly Guid GUID_VsUIHierarchyWindowCmds = new Guid("{60481700-078b-11d1-aaf8-00a0c9055a90}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VsUIHierarchyWindowCmdIds"]/*' />
        /// <summary>
        /// The following commands are special commands that only apply to the UIHierarchyWindow.
        /// They are defined as part of the command group GUID: GUID_VsUIHierarchyWindowCmds.
        /// </summary>
        [Guid("60481700-078b-11d1-aaf8-00a0c9055a90")]
        public enum VsUIHierarchyWindowCmdIds
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_RightClick"]/*' />
            /// <summary></summary>
            UIHWCMDID_RightClick = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_DoubleClick"]/*' />
            /// <summary></summary>
            UIHWCMDID_DoubleClick = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_EnterKey"]/*' />
            /// <summary></summary>
            UIHWCMDID_EnterKey = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_StartLabelEdit"]/*' />
            /// <summary></summary>
            UIHWCMDID_StartLabelEdit = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_CommitLabelEdit"]/*' />
            /// <summary></summary>
            UIHWCMDID_CommitLabelEdit = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VsUIHierarchyWindowCmdIds.UIHWCMDID_CancelLabelEdit"]/*' />
            /// <summary></summary>
            UIHWCMDID_CancelLabelEdit = 6
        }

        // Special values for IVsHierarchy and SelectionContainer pointers
        public static readonly IntPtr
            HIERARCHY_DONTCHANGE = new IntPtr(-1),
            SELCONTAINER_DONTCHANGE = new IntPtr(-1),
            HIERARCHY_DONTPROPAGATE = new IntPtr(-2),
            SELCONTAINER_DONTPROPAGATE = new IntPtr(-2);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSSELELEMID"]/*' />
        /// <summary>
        /// These element IDs are the only element IDs that can be used with the selection service.
        /// </summary>
        public enum VSSELELEMID
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_UndoManager"]/*' />
            /// <summary></summary>
            SEID_UndoManager = 0,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_WindowFrame"]/*' />
            /// <summary></summary>
            SEID_WindowFrame = 1,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_DocumentFrame"]/*' />
            /// <summary></summary>
            SEID_DocumentFrame = 2,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_StartupProject"]/*' />
            /// <summary></summary>
            SEID_StartupProject = 3,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_PropertyBrowserSID"]/*' />
            /// <summary></summary>
            SEID_PropertyBrowserSID = 4,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_UserContext"]/*' />
            /// <summary></summary>
            SEID_UserContext = 5,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_ResultList"]/*' />
            /// <summary></summary>
            SEID_ResultList = 6,
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSSELELEMID.SEID_LastWindowFrame"]/*' />
            /// <summary></summary>
            SEID_LastWindowFrame = 7
        }

        // VS Guids

        // Note: We don't define here the GUIDs for the standard tool windows because these
        // GUIDs are defined in System.ComponentModel.Design.StandardToolWindows

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_HtmDocData"]/*' />
        /// <summary>The document's data is HTML.</summary>
        public static readonly Guid CLSID_HtmDocData = new Guid("{62C81794-A9EC-11D0-8198-00A0C91BBEE3}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_HtmedPackage"]/*' />
        /// <summary>GUID of the HTML package.</summary>
        public static readonly Guid CLSID_HtmedPackage = new Guid("{1B437D20-F8FE-11D2-A6AE-00104BCC7269}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_HtmlLanguageService"]/*' />
        /// <summary>GUID of the HTML language service.</summary>
        public static readonly Guid CLSID_HtmlLanguageService = new Guid("{58E975A0-F8FE-11D2-A6AE-00104BCC7269}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_HtmlEditorFactory"]/*' />
        /// <summary>GUID of the HTML editor factory.</summary>
        public static readonly Guid GUID_HtmlEditorFactory = new Guid("{C76D83F8-A489-11D0-8195-00A0C91BBEE3}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_TextEditorFactory"]/*' />
        /// <summary>GUID of the Text editor factory.</summary>
        public static readonly Guid GUID_TextEditorFactory = new Guid("{8B382828-6202-11d1-8870-0000F87579D2}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_HTMEDAllowExistingDocData"]/*' />
        /// <summary>GUID used to mark a TextBuffer in order to tell to the HTML editor factory to accept preexisting doc data.</summary>
        public static readonly Guid GUID_HTMEDAllowExistingDocData = new Guid("{5742D216-8071-4779-BF5F-A24D5F3142BA}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsEnvironmentPackage"]/*' />
        /// <summary>GUID for the environment package.</summary>
        public static readonly Guid CLSID_VsEnvironmentPackage = new Guid("{DA9FB551-C724-11d0-AE1F-00A0C90FFFC3}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsNewProjectPseudoFolder"]/*' />
        /// <summary>GUID for the "Visual Studio" pseudo folder in the registry.</summary>
        public static readonly Guid GUID_VsNewProjectPseudoFolder = new Guid("{DCF2A94A-45B0-11d1-ADBF-00C04FB6BE4C}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_MiscellaneousFilesProject"]/*' />
        /// <summary>GUID for the "Miscellaneous Files" project.</summary>
        public static readonly Guid CLSID_MiscellaneousFilesProject = new Guid("{A2FE74E1-B743-11d0-AE1A-00A0C90FFFC3}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_SolutionItemsProject"]/*' />
        /// <summary>GUID for Solution Items project.</summary>
        public static readonly Guid CLSID_SolutionItemsProject = new Guid("{D1DCDB85-C5E8-11d2-BFCA-00C04F990235}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SID_SVsGeneralOutputWindowPane"]/*' />
        /// <summary>Pseudo service that returns a IID_IVsOutputWindowPane interface of the General output pane in the VS environment.
        /// Querying for this service will cause the General output pane to be created if it hasn't yet been created.
        /// </summary>
        public static readonly Guid SID_SVsGeneralOutputWindowPane = new Guid("{65482c72-defa-41b7-902c-11c091889c83}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SID_SUIHostCommandDispatcher"]/*' />
        /// <summary>
        /// SUIHostCommandDispatcher service returns an object that implements IOleCommandTarget.
        /// This object handles command routing for the Environment. Use this service if you need to
        /// route a command based on the current selection/state of the Environment.
        /// </summary>
        public static readonly Guid SID_SUIHostCommandDispatcher = new Guid("{e69cd190-1276-11d1-9f64-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsUIHierarchyWindow"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsUIHierarchyWindow = new Guid("{7D960B07-7AF8-11D0-8E5E-00A0C911005A}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_DefaultEditor"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_DefaultEditor = new Guid("{6AC5EF80-12BF-11D1-8E9B-00A0C911005A}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ExternalEditor"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_ExternalEditor = new Guid("{8137C9E8-35FE-4AF2-87B0-DE3C45F395FD}");

        //--------------------------------------------------------------------
        // GUIDs for some panes of the Output Window
        //--------------------------------------------------------------------
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_BuildOutputWindowPane"]/*' />
        /// <summary>GUID of the build pane inside the output window.</summary>
        public static readonly Guid GUID_BuildOutputWindowPane = new Guid("{1BD8A850-02D1-11d1-BEE7-00A0C913D1F8}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_OutWindowDebugPane"]/*' />
        /// <summary>GUID of the debug pane inside the output window.</summary>
        public static readonly Guid GUID_OutWindowDebugPane = new Guid("{FC076020-078A-11D1-A7DF-00A0C9110051}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_OutWindowGeneralPane"]/*' />
        /// <summary>GUID of the general output pane inside the output window.</summary>
        public static readonly Guid GUID_OutWindowGeneralPane = new Guid("{3c24d581-5591-4884-a571-9fe89915cd64}");

        // Guids for GetOutputPane.
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.BuildOrder"]/*' />
        public static readonly Guid BuildOrder = new Guid("2032b126-7c8d-48ad-8026-0e0348004fc0");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.BuildOutput"]/*' />
        public static readonly Guid BuildOutput = new Guid("1BD8A850-02D1-11d1-BEE7-00A0C913D1F8");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugOutput"]/*' />
        public static readonly Guid DebugOutput = new Guid("FC076020-078A-11D1-A7DF-00A0C9110051");

        //--------------------------------------------------------------------
        // standard item types, to be returned from VSHPROPID_TypeGuid
        //--------------------------------------------------------------------

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_PhysicalFile"]/*' />
        /// <summary>Physical file on disk or web (IVsProject::GetMkDocument returns a file path).</summary>
        public static readonly Guid GUID_ItemType_PhysicalFile = new Guid("{6bb5f8ee-4483-11d3-8bcf-00c04f8ec28c}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_PhysicalFolder"]/*' />
        /// <summary>Physical folder on disk or web (IVsProject::GetMkDocument returns a directory path).</summary>

        public static readonly Guid GUID_ItemType_PhysicalFolder = new Guid("{6bb5f8ef-4483-11d3-8bcf-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_VirtualFolder"]/*' />
        /// <summary>Non-physical folder (folder is logical and not a physical file system directory).</summary>

        public static readonly Guid GUID_ItemType_VirtualFolder = new Guid("{6bb5f8f0-4483-11d3-8bcf-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ItemType_SubProject"]/*' />
        /// <summary>A nested hierarchy project.</summary>
        public static readonly Guid GUID_ItemType_SubProject = new Guid("{EA6618E8-6E24-4528-94BE-6889FE16485C}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_BrowseFilePage"]/*' />
        /// <summary>The BrowseFile page.</summary>
        public static readonly Guid GUID_BrowseFilePage = new Guid("2483F435-673D-4fa3-8ADD-B51442F65349");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.guidCOMPLUSLibrary"]/*' />
        public static readonly Guid guidCOMPLUSLibrary = new Guid(0x1ec72fd7, 0xc820, 0x4273, 0x9a, 0x21, 0x77, 0x7a, 0x5c, 0x52, 0x2e, 0x03);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_ComPlusOnlyDebugEngine"]/*' />
        public static readonly Guid CLSID_ComPlusOnlyDebugEngine = new Guid("449EC4CC-30D2-4032-9256-EE18EB41B62B");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines"]/*' />
        public static class DebugEnginesGuids
        {
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.ManagedOnly "]/*' />
            public static readonly Guid ManagedOnly = new Guid("449EC4CC-30D2-4032-9256-EE18EB41B62B");
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.NativeOnly "]/*' />
            public static readonly Guid NativeOnly = new Guid("{3B476D35-A401-11D2-AAD4-00C04F990171}");
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.Script "]/*' />
            public static readonly Guid Script = new Guid("{F200A7E7-DEA5-11D0-B854-00A0244A1DE2}");
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.ManagedAndNative "]/*' />
            public static readonly Guid ManagedAndNative = new Guid("{92EF0900-2251-11D2-B72E-0000F87572EF}");
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.SQLLocalEngine "]/*' />
            public static readonly Guid SQLLocalEngine = new Guid("{E04BDE58-45EC-48DB-9807-513F78865212}");
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.SqlDebugEngine2 "]/*' />
            public static readonly Guid SqlDebugEngine2 = new Guid("{3B476D30-A401-11D2-AAD4-00C04F990171}");
            /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DebugEngines.SqlDebugEngine3 "]/*' />
            public static readonly Guid SqlDebugEngine3 = new Guid("{3B476D3A-A401-11D2-AAD4-00C04F990171}");
        }

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VS_DEPTYPE_BUILD_PROJECT"]/*' />
        public static readonly Guid GUID_VS_DEPTYPE_BUILD_PROJECT = new Guid("707d11b6-91ca-11d0-8a3e-00a0c91e2acd");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_ProjectDesignerEditor"]/*' />
        /// <summary>The propejct designer guid.</summary>
        public static readonly Guid GUID_ProjectDesignerEditor = new Guid("04b8ab82-a572-4fef-95ce-5222444b6b64");

        // Build options from the idl file.
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_REBUILD"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_REBUILD = 1;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_BUILD_SELECTION_ONLY"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_BUILD_SELECTION_ONLY = 2;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_BUILD_ACTIVE_DOCUMENT_ONLY"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_BUILD_ACTIVE_DOCUMENT_ONLY = 4;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_BUILDABLEPROJECTCFGOPTS_PRIVATE"]/*' />
        public const uint VS_BUILDABLEPROJECTCFGOPTS_PRIVATE = 0xFFFF0000;    // flags private to a particular implementation

        //--------------------------------------------------------------------
        // GUIDs used in calling IVsMonitorSelection::GetCmdUIContextCookie()
        //--------------------------------------------------------------------
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionBuilding"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionBuilding = new Guid("{adfc4e60-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_Debugging"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_Debugging = new Guid("{adfc4e61-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_Dragging"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_Dragging = new Guid("{b706f393-2e5b-49e7-9e2e-b1825f639b63}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_FullScreenMode"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_FullScreenMode = new Guid("{adfc4e62-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_DesignMode"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_DesignMode = new Guid("{adfc4e63-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_NoSolution"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_NoSolution = new Guid("{adfc4e64-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionExists"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionExists = new Guid("{f1536ef8-92ec-443c-9ed7-fdadf150da82}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_EmptySolution"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_EmptySolution = new Guid("{adfc4e65-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionHasSingleProject"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionHasSingleProject = new Guid("{adfc4e66-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_SolutionHasMultipleProjects"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_SolutionHasMultipleProjects = new Guid("{93694fa0-0397-11d1-9f4e-00a0c911004f}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UICONTEXT_CodeWindow"]/*' />
        /// <summary></summary>
        public static readonly Guid UICONTEXT_CodeWindow = new Guid("{8fe2df1d-e0da-4ebe-9d5c-415d40e487b5}");

        //--------------------------------------------------------------------
        // GUIDS for built in task list views
        //--------------------------------------------------------------------
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewAll"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewAll = new Guid("{1880202e-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewUserTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewUserTasks = new Guid("{1880202f-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewShortcutTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewShortcutTasks = new Guid("{18802030-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewHTMLTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewHTMLTasks = new Guid("{36ac1c0d-fe86-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCompilerTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCompilerTasks = new Guid("{18802033-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCommentTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCommentTasks = new Guid("{18802034-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCurrentFileTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCurrentFileTasks = new Guid("{18802035-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewCheckedTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewCheckedTasks = new Guid("{18802036-fc20-11d2-8bb1-00c04f8ec28c}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_VsTaskListViewUncheckedTasks"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_VsTaskListViewUncheckedTasks = new Guid("{18802037-fc20-11d2-8bb1-00c04f8ec28c}");

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsTaskList"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsTaskList = new Guid("{BC5955D5-aa0d-11d0-a8c5-00a0c921a4d2}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsTaskListPackage"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsTaskListPackage = new Guid("{4A9B7E50-aa16-11d0-a8c5-00a0c921a4d2}");


        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SID_SVsToolboxActiveXDataProvider"]/*' />
        /// <summary></summary>
        public static readonly Guid SID_SVsToolboxActiveXDataProvider = new Guid("{35222106-bb44-11d0-8c46-00c04fc2aae2}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsDocOutlinePackage"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsDocOutlinePackage = new Guid("{21af45b0-ffa5-11d0-b63f-00a0c922e851}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CLSID_VsCfgProviderEventsHelper"]/*' />
        /// <summary></summary>
        public static readonly Guid CLSID_VsCfgProviderEventsHelper = new Guid("{99913f1f-1ee3-11d1-8a6e-00c04f682e21}");


        //--------------------------------------------------------------------
        // Component Selector page GUIDs
        //--------------------------------------------------------------------
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_COMPlusPage"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_COMPlusPage = new Guid("{9A341D95-5A64-11d3-BFF9-00C04F990235}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_COMClassicPage"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_COMClassicPage = new Guid("{9A341D96-5A64-11d3-BFF9-00C04F990235}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.GUID_SolutionPage"]/*' />
        /// <summary></summary>
        public static readonly Guid GUID_SolutionPage = new Guid("{9A341D97-5A64-11d3-BFF9-00C04F990235}");

        //--------------------------------------------------------------------
        // Logical View GUIDs
        //--------------------------------------------------------------------
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Any"]/*' />
        /// <summary>Kind of view for document or data: Any defined view.</summary>
        public static readonly Guid LOGVIEWID_Any = new Guid(0xffffffff, 0xffff, 0xffff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Primary"]/*' />
        /// <summary>Kind of view for document or data: Primary (default) view.</summary>
        public static readonly Guid LOGVIEWID_Primary = Guid.Empty;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Debugging"]/*' />
        /// <summary>Kind of view for document or data: Debugger view.</summary>
        public static readonly Guid LOGVIEWID_Debugging = new Guid("{7651A700-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Code "]/*' />
        /// <summary>Kind of view for document or data: Code editor view.</summary>
        public static readonly Guid LOGVIEWID_Code = new Guid("{7651A701-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_Designer"]/*' />
        /// <summary>Kind of view for document or data: Designer view.</summary>
        public static readonly Guid LOGVIEWID_Designer = new Guid("{7651A702-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_TextView"]/*' />
        /// <summary>Kind of view for document or data: Text editor view.</summary>
        public static readonly Guid LOGVIEWID_TextView = new Guid("{7651A703-06E5-11D1-8EBD-00A0C90F26EA}");
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.LOGVIEWID_UserChooseView"]/*' />
        /// <summary>Kind of view for document or data: A user defined view.</summary>
        public static readonly Guid LOGVIEWID_UserChooseView = new Guid("{7651A704-06E5-11D1-8EBD-00A0C90F26EA}");

        // VS Constants

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSITEMID_NIL"]/*' />
        /// <summary>Special items inside a VsHierarchy: no node.</summary>
        public const uint VSITEMID_NIL = unchecked((uint)-1);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSITEMID_ROOT"]/*' />
        /// <summary>Special items inside a VsHierarchy: the hierarchy itself.</summary>
        public const uint VSITEMID_ROOT = unchecked((uint)-2);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSITEMID_SELECTION"]/*' />
        /// <summary>Special items inside a VsHierarchy: all the currently selected items.</summary>
        public const uint VSITEMID_SELECTION = unchecked((uint)-3);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSCOOKIE_NIL"]/*' />
        /// <summary>Special value for a cookie (e.g. returned from IVsRunningDocumentTable.FindAndLockDocument): no cookie.</summary>
        public const uint VSCOOKIE_NIL = 0;

        // for IVsSelectionEvents flags
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UndoManager"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The undo manager.</summary>
        public const uint UndoManager = 0x0;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.WindowFrame"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A window frame.</summary>
        public const uint WindowFrame = 0x1;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.DocumentFrame"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A document frame.</summary>
        public const uint DocumentFrame = 0x2;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.StartupProject"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The startup project.</summary>
        public const uint StartupProject = 0x3;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.PropertyBrowserSID"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: The property borowser.</summary>
        public const uint PropertyBrowserSID = 0x4;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UserContext"]/*' />
        /// <summary>IVsSelectionEvents.OnElementValueChanged flag: A user context.</summary>
        public const uint UserContext = 0x5;

        // VS HRESULTS

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PROJECTALREADYEXISTS"]/*' />
        /// <summary>VS specific error HRESULT for "Project already exists".</summary>
        public const int VS_E_PROJECTALREADYEXISTS = unchecked((int)0x80041FE0);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PACKAGENOTLOADED"]/*' />
        /// <summary>VS specific error HRESULT for "Package not loaded".</summary>
        public const int VS_E_PACKAGENOTLOADED = unchecked((int)0x80041FE1);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PROJECTNOTLOADED"]/*' />
        /// <summary>VS specific error HRESULT for "Project not loaded".</summary>
        public const int VS_E_PROJECTNOTLOADED = unchecked((int)0x80041FE2);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_SOLUTIONNOTOPEN"]/*' />
        /// <summary>VS specific error HRESULT for "Solution not open".</summary>
        public const int VS_E_SOLUTIONNOTOPEN = unchecked((int)0x80041FE3);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_SOLUTIONALREADYOPEN"]/*' />
        /// <summary>VS specific error HRESULT for "Solution already open".</summary>
        public const int VS_E_SOLUTIONALREADYOPEN = unchecked((int)0x80041FE4);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_PROJECTMIGRATIONFAILED"]/*' />
        /// <summary>VS specific error HRESULT for "Project configuration failed".</summary>
        public const int VS_E_PROJECTMIGRATIONFAILED = unchecked((int)0x80041FE5);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_INCOMPATIBLEDOCDATA"]/*' />
        /// <summary>VS specific error HRESULT for "Incompatible document data".</summary>
        public const int VS_E_INCOMPATIBLEDOCDATA = unchecked((int)0x80041FEA);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_UNSUPPORTEDFORMAT"]/*' />
        /// <summary>VS specific error HRESULT for "Unsupported format".</summary>
        public const int VS_E_UNSUPPORTEDFORMAT = unchecked((int)0x80041FEB);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_WIZARDBACKBUTTONPRESS"]/*' />
        /// <summary>VS specific error HRESULT for "Wizard back button pressed".</summary>
        public const int VS_E_WIZARDBACKBUTTONPRESS = unchecked((int)0x80041fff);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_S_PROJECTFORWARDED"]/*' />
        /// <summary>VS specific success HRESULT for "Project forwarded".</summary>
        public const int VS_S_PROJECTFORWARDED = unchecked((int)0x41ff0);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_S_TBXMARKER"]/*' />
        /// <summary>VS specific success HRESULT for "Toolbox marker".</summary>
        public const int VS_S_TBXMARKER = unchecked((int)0x41ff1);

        // Selection Containter Constants
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.ALL"]/*' />
        public const uint ALL = 0x1;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.SELECTED"]/*' />
        public const uint SELECTED = 0x2;

        // OLE HRESULTS - may be returned by OLE or related VS methods
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSConstants.OleErrors"]/*' />
        public const int
        OLE_E_OLEVERB = unchecked((int)0x80040000),
        OLE_E_ADVF = unchecked((int)0x80040001),
        OLE_E_ENUM_NOMORE = unchecked((int)0x80040002),
        OLE_E_ADVISENOTSUPPORTED = unchecked((int)0x80040003),
        OLE_E_NOCONNECTION = unchecked((int)0x80040004),
        OLE_E_NOTRUNNING = unchecked((int)0x80040005),
        OLE_E_NOCACHE = unchecked((int)0x80040006),
        OLE_E_BLANK = unchecked((int)0x80040007),
        OLE_E_CLASSDIFF = unchecked((int)0x80040008),
        OLE_E_CANT_GETMONIKER = unchecked((int)0x80040009),
        OLE_E_CANT_BINDTOSOURCE = unchecked((int)0x8004000A),
        OLE_E_STATIC = unchecked((int)0x8004000B),
        OLE_E_PROMPTSAVECANCELLED = unchecked((int)0x8004000C),
        OLE_E_INVALIDRECT = unchecked((int)0x8004000D),
        OLE_E_WRONGCOMPOBJ = unchecked((int)0x8004000E),
        OLE_E_INVALIDHWND = unchecked((int)0x8004000F),
        OLE_E_NOT_INPLACEACTIVE = unchecked((int)0x80040010),
        OLE_E_CANTCONVERT = unchecked((int)0x80040011),
        OLE_E_NOSTORAGE = unchecked((int)0x80040012);

        // OLE DISP HRESULTS - may be returned by OLE DISP or related VS methods 

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="VSConstants.OleDispatchErrors"]/*' />
        public const int
        DISP_E_UNKNOWNINTERFACE = unchecked((int)0x80020001),
        DISP_E_MEMBERNOTFOUND = unchecked((int)0x80020003),
        DISP_E_PARAMNOTFOUND = unchecked((int)0x80020004),
        DISP_E_TYPEMISMATCH = unchecked((int)0x80020005),
        DISP_E_UNKNOWNNAME = unchecked((int)0x80020006),
        DISP_E_NONAMEDARGS = unchecked((int)0x80020007),
        DISP_E_BADVARTYPE = unchecked((int)0x80020008),
        DISP_E_EXCEPTION = unchecked((int)0x80020009),
        DISP_E_OVERFLOW = unchecked((int)0x8002000A),
        DISP_E_BADINDEX = unchecked((int)0x8002000B),
        DISP_E_UNKNOWNLCID = unchecked((int)0x8002000C),
        DISP_E_ARRAYISLOCKED = unchecked((int)0x8002000D),
        DISP_E_BADPARAMCOUNT = unchecked((int)0x8002000E),
        DISP_E_PARAMNOTOPTIONAL = unchecked((int)0x8002000F),
        DISP_E_BADCALLEE = unchecked((int)0x80020010),
        DISP_E_NOTACOLLECTION = unchecked((int)0x80020011),
        DISP_E_DIVBYZERO = unchecked((int)0x80020012),
        DISP_E_BUFFERTOOSMALL = unchecked((int)0x80020013);


        //-----------------------------------------------------------------------------
        //  VS_E_BUSY is returned by interfaces to asynchronous behavior when the
        //  object in question in already busy.  For example, starting a build while
        //  a buildable project configuration object is in the process of cleaning,
        //  building or checking for out of date-ness.
        //-----------------------------------------------------------------------------
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_BUSY"]/*' />
        /// <summary>
        /// VS specific error HRESULT returned by interfaces to asynchronous behavior when the
        /// object in question in already busy.
        /// </summary>
        public const int VS_E_BUSY = unchecked((int)0x80040200);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VS_E_SPECIFYING_OUTPUT_UNSUPPORTED"]/*' />
        /// <summary>
        /// Is returned by build interfaces that have parameters for specifying an array of IVsOutput's
        /// but the implementation can only apply the method to all outputs.
        /// </summary>
        public const int VS_E_SPECIFYING_OUTPUT_UNSUPPORTED = unchecked((int)0x80040201);

        // General HRESULTS

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.S_FALSE"]/*' />
        /// <summary>HRESULT for FALSE (not an error).</summary>
        public const int S_FALSE = 0x00000001;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.S_OK"]/*' />
        /// <summary>HRESULT for generic success.</summary>
        public const int S_OK = 0x00000000;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.UNDO_E_CLIENTABORT"]/*' />
        /// <summary>Error HRESULT for a client abort.</summary>
        public const int UNDO_E_CLIENTABORT = unchecked((int)0x80044001);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_OUTOFMEMORY"]/*' />
        /// <summary>Error HRESULT for out of memory.</summary>
        public const int E_OUTOFMEMORY = unchecked((int)0x8007000E);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_INVALIDARG"]/*' />
        /// <summary>Error HRESULT for an invalid argument.</summary>
        public const int E_INVALIDARG = unchecked((int)0x80070057);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_FAIL"]/*' />
        /// <summary>Error HRESULT for a generic failure.</summary>
        public const int E_FAIL = unchecked((int)0x80004005);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_NOINTERFACE"]/*' />
        /// <summary>Error HRESULT for the request of a not implemented interface.</summary>
        public const int E_NOINTERFACE = unchecked((int)0x80004002);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_NOTIMPL"]/*' />
        /// <summary>Error HRESULT for the call to a not implemented method.</summary>
        public const int E_NOTIMPL = unchecked((int)0x80004001);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_UNEXPECTED"]/*' />
        /// <summary>Error HRESULT for an unexpected condition.</summary>
        public const int E_UNEXPECTED = unchecked((int)0x8000FFFF);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_POINTER"]/*' />
        /// <summary>Error HRESULT for a null or invalid pointer.</summary>
        public const int E_POINTER = unchecked((int)0x80004003);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_HANDLE"]/*' />
        /// <summary>Error HRESULT for an invalid HANDLE.</summary>
        public const int E_HANDLE = unchecked((int)0x80070006);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_ABORT"]/*' />
        /// <summary>Error HRESULT for an abort.</summary>
        public const int E_ABORT = unchecked((int)0x80004004);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_ACCESSDENIED"]/*' />
        /// <summary>Error HRESULT for an access denied.</summary>
        public const int E_ACCESSDENIED = unchecked((int)0x80070005);
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.E_PENDING"]/*' />
        /// <summary>Error HRESULT for a pending condition.</summary>
        public const int E_PENDING = unchecked((int)0x8000000A);

        // Window Messages
        internal const int WM_USER = 0x0400;

        // VS specific messages
        // These definitions are for broadcasting a notification message via
        //   IVsBroadcastMessageEvents::OnBroadcastMessage to indicate that the cmdbar
        //   metrics have changed.
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSM_TOOLBARMETRICSCHANGE"]/*' />
        /// <summary>Toolbar metrics changed.</summary>
        public const int VSM_TOOLBARMETRICSCHANGE = WM_USER + 0x0C52;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSM_ENTERMODAL"]/*' />
        /// <summary></summary>
        public const int VSM_ENTERMODAL = WM_USER + 0x0C53;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.VSM_EXITMODAL"]/*' />
        /// <summary></summary>
        public const int VSM_EXITMODAL = WM_USER + 0x0C54;

        // messages sent from Component Selector dialog to page dialogs.
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPDN_SELCHANGED"]/*' />
        /// <summary>Inform of selection change on page.</summary>
        public const int CPDN_SELCHANGED = WM_USER + 1280;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPDN_SELDBLCLICK"]/*' />
        /// <summary>Inform of doubld-click on selected item on page.</summary>
        public const int CPDN_SELDBLCLICK = WM_USER + 1281;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_INITIALIZELIST"]/*' />
        /// <summary>Initialize list of available components.</summary>
        public const int CPPM_INITIALIZELIST = WM_USER + 1285;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_QUERYCANSELECT"]/*' />
        /// <summary>Determine whether Select button should be enabled.</summary>
        public const int CPPM_QUERYCANSELECT = WM_USER + 1286;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_GETSELECTION"]/*' />
        /// <summary>Retrieve information about selection.</summary>
        public const int CPPM_GETSELECTION = WM_USER + 1287;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_INITIALIZETAB"]/*' />
        /// <summary>Initialize tab with VARIANT in VSCOMPONENTSELECTORTABINIT.</summary>
        public const int CPPM_INITIALIZETAB = WM_USER + 1288;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_SETMULTISELECT"]/*' />
        /// <summary>Set multiple-selection mode for picker.</summary>
        public const int CPPM_SETMULTISELECT = WM_USER + 1289;
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Constants.CPPM_CLEARSELECTION"]/*' />
        /// <summary>Reset and clear selection in list of available components.</summary>
        public const int CPPM_CLEARSELECTION = WM_USER + 1290;

    }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Win32Methods"]/*' />
    [CLSCompliant(false)]
    public class Win32Methods
    {
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Win32Methods.SetParent"]/*' />
        /// <summary>
        /// Changes the parent window of the specified child window.
        /// </summary>
        /// <param name="hWnd">Handle to the child window.</param>
        /// <param name="hWndParent">Handle to the new parent window. If this parameter is NULL, the desktop window becomes the new parent window.</param>
        /// <returns>A handle to the previous parent window indicates success. NULL indicates failure.</returns>
        [DllImport("User32", ExactSpelling = true, CharSet = CharSet.Auto)]
        public static extern IntPtr SetParent(IntPtr hWnd, IntPtr hWndParent);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="Win32Methods.IsDialogMessageA"]/*' />
        [DllImport("user32.dll", EntryPoint = "IsDialogMessageA", SetLastError = true, CharSet = CharSet.Ansi, ExactSpelling = true, CallingConvention = CallingConvention.StdCall)]
        public static extern bool IsDialogMessageA(IntPtr hDlg, ref MSG msg);


    }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler"]/*' />
    [ComImport(), Guid("9BDA66AE-CA28-4e22-AA27-8A7218A0E3FA"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown), CLSCompliant(false)]
    public interface IEventHandler
    {

        // converts the underlying codefunction into an event handler for the given event
        // if the given event is NULL, then the function will handle no events
        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.AddHandler"]/*' />
        [PreserveSig]
        int AddHandler(string bstrEventName);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.RemoveHandler"]/*' />
        [PreserveSig]
        int RemoveHandler(string bstrEventName);

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.GetHandledEvents"]/*' />
        IVsEnumBSTR GetHandledEvents();

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="IEventHandler.HandlesEvent"]/*' />
        bool HandlesEvent(string bstrEventName);
    }

    /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler"]/*' />
    public sealed class ErrorHandler
    {

        private ErrorHandler() { }

        // Helper Methods

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.Succeeded"]/*' />
        /// <summary>
        /// Checks if a HRESULT is a success return code.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        /// <returns>true if hr represents a success, false otherwise.</returns>
        public static bool Succeeded(int hr)
        {
            return (hr >= 0);
        }

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.Failed"]/*' />
        /// <summary>
        /// Checks if a HRESULT is an error return code.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        /// <returns>true if hr represents an error, false otherwise.</returns>
        public static bool Failed(int hr)
        {
            return (hr < 0);
        }

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.ThrowOnFailure"]/*' />
        /// <summary>
        /// Checks if the parameter is a success or failure HRESULT and throws an exception in case
        /// of failure.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        public static int ThrowOnFailure(int hr)
        {
            return ThrowOnFailure(hr, null);
        }

        /// <include file='doc\VSConstants.uex' path='docs/doc[@for="ErrorHandler.ThrowOnFailure"]/*' />
        /// <summary>
        /// Checks if the parameter is a success or failure HRESULT and throws an exception if it is a
        /// failure that is not included in the array of well-known failures.
        /// </summary>
        /// <param name="hr">The HRESULT to test.</param>
        /// <param name="expectedHRFailure">Array of well-known and expected failures.</param>
        public static int ThrowOnFailure(int hr, params int[] expectedHRFailure)
        {
            if (Failed(hr))
            {
                if ((null == expectedHRFailure) || (Array.IndexOf(expectedHRFailure, hr) < 0))
                {
                    Marshal.ThrowExceptionForHR(hr);
                }
            }
            return hr;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Flavor\FlavoredProjectBase.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;
    using ErrorHandler = Microsoft.VisualStudio.ErrorHandler;

    /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject"]/*' />
    /// <devdoc>
    /// A project that is a subtype/flavor of an inner project.
    /// The default behavior of all methods is to delegate to the
    /// inner project. For any behavior you want to change, simply
    /// handle the request yourself.
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProjectBase : 
        IVsAggregatableProjectCorrected,
        System.IServiceProvider,
        IVsHierarchy,
        IVsUIHierarchy,
        IOleCommandTarget
    {
        // Keep interface reference for all interface we override

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerVsAggregatableProject"]/*' />
        protected IVsAggregatableProjectCorrected _innerVsAggregatableProject;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerVsHierarchy"]/*' />
        protected IVsHierarchy _innerVsHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerVsUIHierarchy"]/*' />
        protected IVsUIHierarchy _innerVsUIHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject._innerOleCommandTarget"]/*' />
        protected IOleCommandTarget _innerOleCommandTarget;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.serviceProvider"]/*' />
        protected System.IServiceProvider serviceProvider;

        private OleMenuCommandService _menuService;
        private DocumentsEventsSink _documentsEventsSink;
        private bool _hierarchyClosed = false;
        private int _inExecCommand = 0;

        uint cookie = 0;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FlavoredProject"]/*' />
        public FlavoredProjectBase()
        {
            _documentsEventsSink = new FlavoredProjectBase.DocumentsEventsSink(this);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetComInterface"]/*' />
        /// <devdoc>
        /// A project derived from this base class will be aggregated with a native COM component (the ProjectAggregator object) 
        /// that can also aggregate an inner project in case of flavoring.
        /// Because of this structure, all the request for interfaces exposed to COM must be handled by the external object that 
        /// has a special implementation of QueryInterface that handles both inner and outer projects. 
        /// If you dont use this helper method when requesting an interface you can get unexpected InvalidCast exceptions.
        /// Note that if you want to get the implementation of an interface implemented by your FlavoredProjectBase-derived
        /// object, then you must use the standard cast operator.
        /// </devdoc>
        public Interface_T GetComInterface<Interface_T>() where Interface_T : class
        {
            IntPtr thisUnknown = IntPtr.Zero;
            IntPtr interfacePtr = IntPtr.Zero;
            try
            {
                thisUnknown = Marshal.GetIUnknownForObject(this);
                Guid iid = typeof(Interface_T).GUID;
                if (ErrorHandler.Failed(Marshal.QueryInterface(thisUnknown, ref iid, out interfacePtr)) || (IntPtr.Zero == interfacePtr))
                {
                    return null;
                }
                return Marshal.GetObjectForIUnknown(interfacePtr) as Interface_T;
            }
            finally
            {
                if (IntPtr.Zero != thisUnknown)
                {
                    Marshal.Release(thisUnknown);
                }
                if (IntPtr.Zero != interfacePtr)
                {
                    Marshal.Release(interfacePtr);
                }
            }
        }

        #region IVsAggregatableProjectCorrected

        /// <devdoc>
        /// This is where all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        int IVsAggregatableProjectCorrected.SetInnerProject(IntPtr innerIUnknown)
        {
            // delegate to the protected method
            this.SetInnerProject(innerIUnknown);

            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetInnerProject"]/*' />
        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        protected virtual void SetInnerProject(IntPtr innerIUnknown)
        {
            object inner = null;

            inner = Marshal.GetObjectForIUnknown(innerIUnknown);

            // Keep a reference to each interface we want to call on the inner project
            // we must do it now as once we call SetInner the AddRef would be forwarded to ourselves
            _innerVsAggregatableProject = inner as IVsAggregatableProjectCorrected;
            Debug.Assert(inner != null, "Failed to retrieve IVsAggregatableProjectCorrected from inner Project");
            _innerVsHierarchy = (IVsHierarchy)inner;
            _innerVsUIHierarchy = (IVsUIHierarchy)inner;
            // "As" should return null without throwing in the event the base project does not implement the interface
            _innerOleCommandTarget = inner as IOleCommandTarget;

            // Setup our menu command service
            if (this.serviceProvider == null)
                throw new NotSupportedException("serviceProvider should have been set before SetInnerProject gets called.");
            _menuService = new OleMenuCommandService(this, _innerOleCommandTarget);

            // Pass the inner project pointer to the VisualStudio.ProjectAggregator2 object. This native object
            // has a special implementation of QueryInterface that delegates first to our managed FlavoredProjectBase
            // derived object and then to the inner project (either the base project or the next project flavor down).
            IntPtr thisIUnknown = IntPtr.Zero;
            IVsProjectAggregator2 vsProjectAggregator2 = null;
            try
            {
                thisIUnknown = Marshal.GetIUnknownForObject(this);
                vsProjectAggregator2 = (IVsProjectAggregator2)Marshal.GetObjectForIUnknown(thisIUnknown);
                if (vsProjectAggregator2 != null)
                    vsProjectAggregator2.SetInner(innerIUnknown);
            }
            finally
            {
                if (thisIUnknown != IntPtr.Zero)
                    Marshal.Release(thisIUnknown);
            }
        }

        /// <devdoc>
        /// Do the initialization here (such as loading flavor specific
        /// information from the project)
        /// </devdoc>
        int IVsAggregatableProjectCorrected.InitializeForOuter(string fileName, string location, string name,
            uint flags, ref Guid guidProject, out IntPtr project, out int canceled)
        {
            int hr = VSConstants.S_OK;
            project = IntPtr.Zero;
            canceled = 0;

            if (_innerVsAggregatableProject == null || guidProject != VSConstants.IID_IUnknown)
                throw new NotSupportedException();

            IntPtr thisIUnknown = IntPtr.Zero;
            try
            {
                thisIUnknown = Marshal.GetIUnknownForObject(this);
                if (thisIUnknown != IntPtr.Zero)
                    hr = Marshal.QueryInterface(thisIUnknown, ref guidProject, out project);
            }
            finally
            {
                if (thisIUnknown != IntPtr.Zero)
                    Marshal.Release(thisIUnknown);
            }

            bool cancel;
            this.InitializeForOuter(fileName, location, name, flags, ref guidProject, out cancel);
            if (cancel)
                canceled = 1;

            return hr;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.InitializeForOuter"]/*' />
        /// <devdoc>
        /// Allow the project to initialize itself.
        /// At this point it possible to call the inner project
        /// Also allow canceling the project creation
        /// </devdoc>
        /// <returns>Return true to cancel the project creation</returns>
        protected virtual void InitializeForOuter(string fileName, string location, string name, uint flags, ref Guid guidProject, out bool cancel)
        {
            cancel = false;
        }
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        int IVsAggregatableProjectCorrected.OnAggregationComplete()
        {
            this.OnAggregationComplete();
            if (_innerVsAggregatableProject != null)
                return _innerVsAggregatableProject.OnAggregationComplete();
            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.OnAggregationComplete"]/*' />
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        protected virtual void OnAggregationComplete()
        {
            // This will subscribe to the IVsTrackProjectDocumentsEvents.
            // This is not required to flavor a project but makes it easier for derived class
            // to subscribe to these events.
            IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
            ErrorHandler.ThrowOnFailure(trackDocuments.AdviseTrackProjectDocumentsEvents(_documentsEventsSink, out cookie));
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProjectCorrected.SetAggregateProjectTypeGuids(string projectTypeGuids)
        {
            if (_innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return _innerVsAggregatableProject.SetAggregateProjectTypeGuids(projectTypeGuids);
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProjectCorrected.GetAggregateProjectTypeGuids(out string projectTypeGuids)
        {
            if (_innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return _innerVsAggregatableProject.GetAggregateProjectTypeGuids(out projectTypeGuids);
        }

        #endregion

        #region IVsHierarchy
        //
        // Most methods call protected virtual methods which delegate to the inner project.
        // Derived classes should override those protected method if they want to change the
        // behavior.
        //

        int IVsHierarchy.AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink, out uint cookie)
        {
            cookie = this.AdviseHierarchyEvents(eventSink);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Close()
        {
            _hierarchyClosed = true;
            this.Close();

            if (cookie != 0)
            {
                // Unsubscribe to events 
                IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
                trackDocuments.UnadviseTrackProjectDocumentsEvents(cookie);
                cookie = 0;
            }

            this._menuService = null;
            if (_inExecCommand == 0)
                FreeInterfaces();

            return VSConstants.S_OK;
        }

        public virtual void FreeInterfaces()
        {
            this._menuService = null;

            if (_innerOleCommandTarget != null)
            {
                if (Marshal.IsComObject(_innerOleCommandTarget))
                    Marshal.ReleaseComObject(_innerOleCommandTarget);
                _innerOleCommandTarget = null;
            }

            if (_innerVsAggregatableProject != null)
            {
                if (Marshal.IsComObject(_innerVsAggregatableProject))
                    Marshal.ReleaseComObject(_innerVsAggregatableProject);
                _innerVsAggregatableProject = null;
            }

            if (_innerVsUIHierarchy != null)
            {
                if (Marshal.IsComObject(_innerVsUIHierarchy))
                    Marshal.ReleaseComObject(_innerVsUIHierarchy);
                _innerVsUIHierarchy = null;
            }

            if (_innerVsHierarchy != null)
            {
                if (Marshal.IsComObject(_innerVsHierarchy))
                    Marshal.ReleaseComObject(_innerVsHierarchy);
                _innerVsHierarchy = null;
            }
        } 



        int IVsHierarchy.GetCanonicalName(uint itemId, out string name)
        {
            return this.GetCanonicalName(itemId, out name);
        }

        int IVsHierarchy.GetGuidProperty(uint itemId, int propId, out System.Guid guid)
        {
            guid = this.GetGuidProperty(itemId, propId);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return this.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        int IVsHierarchy.GetProperty(uint itemId, int propId, out System.Object property)
        {
            // While other methods expect the protected method to throw, for GetProperty
            // we break this pattern as it is called much more often and it is legitimate to
            // return not implemented. Therefore it can help perf and debugging experience
            return this.GetProperty(itemId, propId, out property);
        }

        int IVsHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            serviceProvider = this.GetSite();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.ParseCanonicalName(string name, out uint itemId)
        {
            return this.ParseCanonicalName(name, out itemId);
        }

        int IVsHierarchy.QueryClose(out int canClose)
        {
            canClose = 0;
            if (this.QueryClose())
                canClose = 1;
            return VSConstants.S_OK;
        }

        int IVsHierarchy.SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            this.SetGuidProperty(itemId, propId, ref guid);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            this.serviceProvider = (System.IServiceProvider)new ServiceProvider(serviceProvider);
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.SetSite(serviceProvider));
            return VSConstants.S_OK;
        }

        int IVsHierarchy.UnadviseHierarchyEvents(uint cookie)
        {
            this.UnadviseHierarchyEvents(cookie);
            return VSConstants.S_OK;
        }

        int IVsHierarchy.SetProperty(uint itemId, int propId, System.Object property)
        {
            return this.SetProperty(itemId, propId, property);
        }

        int IVsHierarchy.Unused0()
        {
            this.Unused0();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused1()
        {
            this.Unused1();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused2()
        {
            this.Unused2();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused3()
        {
            this.Unused3();
            return VSConstants.S_OK;
        }

        int IVsHierarchy.Unused4()
        {
            this.Unused4();
            return VSConstants.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.AdviseHierarchyEvents"]/*' />
        protected virtual uint AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink)
        {
            uint cookie=0;
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.AdviseHierarchyEvents(eventSink, out cookie));
            return cookie;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Close"]/*' />
        protected virtual void Close()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Close());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetCanonicalName"]/*' />
        protected virtual int GetCanonicalName(uint itemId, out string name)
        {
            return _innerVsHierarchy.GetCanonicalName(itemId, out name);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetGuidProperty"]/*' />
        protected virtual Guid GetGuidProperty(uint itemId, int propId)
        {
            Guid property = Guid.Empty;
            if (_innerVsHierarchy != null)
                ErrorHandler.ThrowOnFailure(_innerVsHierarchy.GetGuidProperty(itemId, propId, out property));
            else
                return Guid.Empty;
            return property;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetNestedHierarchy"]/*' />
        protected virtual int GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            if (_innerVsHierarchy != null)
                return _innerVsHierarchy.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
            else
            {
                hierarchyNested = IntPtr.Zero;
                itemIdNested = VSConstants.VSITEMID_NIL;
                return VSConstants.E_NOINTERFACE;
            }
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetProperty"]/*' />
        protected virtual int GetProperty(uint itemId, int propId, out Object property)
        {
            if (_innerVsHierarchy != null)
                return _innerVsHierarchy.GetProperty(itemId, propId, out property);
            else
            {
                property = null;
                return VSConstants.E_UNEXPECTED;
            }
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetSite"]/*' />
        protected virtual Microsoft.VisualStudio.OLE.Interop.IServiceProvider GetSite()
        {
            Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider;
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.GetSite(out serviceProvider));
            return serviceProvider;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ParseCanonicalName"]/*' />
        protected virtual int ParseCanonicalName(string name, out uint itemId)
        {
            return _innerVsHierarchy.ParseCanonicalName(name, out itemId);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryClose"]/*' />
        protected virtual bool QueryClose()
        {
            int canClose;
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.QueryClose(out canClose));
            return (canClose != 0);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetGuidProperty"]/*' />
        protected virtual void SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.SetGuidProperty(itemId, propId, ref guid));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.UnadviseHierarchyEvents"]/*' />
        protected virtual void UnadviseHierarchyEvents(uint cookie)
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.UnadviseHierarchyEvents(cookie));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetProperty"]/*' />
        protected virtual int SetProperty(uint itemId, int propId, System.Object property)
        {
            return _innerVsHierarchy.SetProperty(itemId, propId, property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused0"]/*' />
        protected virtual void Unused0()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused0());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused1"]/*' />
        protected virtual void Unused1()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused1());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused2"]/*' />
        protected virtual void Unused2()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused2());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused3"]/*' />
        protected virtual void Unused3()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused3());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused4"]/*' />
        protected virtual void Unused4()
        {
            ErrorHandler.ThrowOnFailure(_innerVsHierarchy.Unused4());
        }
        #endregion

        #region IVsUIHierarchy Members
        //
        // All methods (except for QueryStatusCommand and ExecCommand) call the IVsHierarchy implementation.
        // QueryStatusCommand and ExecCommand call a protected virtual method that the base class can override.
        // Note that we QI for IVsUIHierarchy on this so that if we are flavored we call the outer IVsHierarchy.
        //

        int IVsUIHierarchy.QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return this.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryStatusCommand"]/*' />
        protected virtual int QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return _innerVsUIHierarchy.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        int IVsUIHierarchy.ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = VSConstants.S_OK;
            try
            {
                _inExecCommand++;
                hr = this.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            }
            finally
            {
                _inExecCommand--;
                Debug.Assert(_inExecCommand >= 0);
                if (_hierarchyClosed && _inExecCommand == 0)
                {
                    FreeInterfaces();
                }
            }
            return hr;
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ExecCommand"]/*' />
        protected virtual int ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return _innerVsUIHierarchy.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }

        int IVsUIHierarchy.AdviseHierarchyEvents(IVsHierarchyEvents pEventSink, out uint pdwCookie)
        {
            return ((IVsHierarchy)this).AdviseHierarchyEvents(pEventSink, out pdwCookie);
        }

        int IVsUIHierarchy.Close()
        {
            return ((IVsHierarchy)this).Close();
        }

        int IVsUIHierarchy.GetCanonicalName(uint itemid, out string pbstrName)
        {
            return ((IVsHierarchy)this).GetCanonicalName(itemid, out pbstrName);
        }

        int IVsUIHierarchy.GetGuidProperty(uint itemid, int propid, out Guid pguid)
        {
            return ((IVsHierarchy)this).GetGuidProperty(itemid, propid, out pguid);
        }

        int IVsUIHierarchy.GetNestedHierarchy(uint itemid, ref Guid iidHierarchyNested, out IntPtr ppHierarchyNested, out uint pitemidNested)
        {
            return ((IVsHierarchy)this).GetNestedHierarchy(itemid, ref iidHierarchyNested, out ppHierarchyNested, out pitemidNested);
        }

        int IVsUIHierarchy.GetProperty(uint itemid, int propid, out object pvar)
        {
            return ((IVsHierarchy)this).GetProperty(itemid, propid, out pvar);
        }

        int IVsUIHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider ppSP)
        {
            return ((IVsHierarchy)this).GetSite(out ppSP);
        }

        int IVsUIHierarchy.ParseCanonicalName(string pszName, out uint pitemid)
        {
            return ((IVsHierarchy)this).ParseCanonicalName(pszName, out pitemid);
        }

        int IVsUIHierarchy.QueryClose(out int pfCanClose)
        {
            return ((IVsHierarchy)this).QueryClose(out pfCanClose);
        }

        int IVsUIHierarchy.SetGuidProperty(uint itemid, int propid, ref Guid rguid)
        {
            return ((IVsHierarchy)this).SetGuidProperty(itemid, propid, ref rguid);
        }

        int IVsUIHierarchy.SetProperty(uint itemid, int propid, object var)
        {
            return ((IVsHierarchy)this).SetProperty(itemid, propid, var);
        }

        int IVsUIHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            return ((IVsHierarchy)this).SetSite(psp);
        }

        int IVsUIHierarchy.UnadviseHierarchyEvents(uint dwCookie)
        {
            return ((IVsHierarchy)this).UnadviseHierarchyEvents(dwCookie);
        }

        int IVsUIHierarchy.Unused0()
        {
            return ((IVsHierarchy)this).Unused0();
        }

        int IVsUIHierarchy.Unused1()
        {
            return ((IVsHierarchy)this).Unused1();
        }

        int IVsUIHierarchy.Unused2()
        {
            return ((IVsHierarchy)this).Unused2();
        }

        int IVsUIHierarchy.Unused3()
        {
            return ((IVsHierarchy)this).Unused3();
        }

        int IVsUIHierarchy.Unused4()
        {
            return ((IVsHierarchy)this).Unused4();
        }

        #endregion


        #region IOleCommandTarget Members

        int IOleCommandTarget.Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = ((IOleCommandTarget)_menuService).Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            return hr;
        }

        int IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            int hr = ((IOleCommandTarget)_menuService).QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            return hr;
        }

        #endregion

        #region IServiceProvider Members

        object System.IServiceProvider.GetService(Type serviceType)
        {
            if (serviceType == typeof(IOleCommandTarget))
                return ((IOleCommandTarget)_menuService);
            else if (serviceType == typeof(System.ComponentModel.Design.IMenuCommandService))
                return ((System.ComponentModel.Design.IMenuCommandService)_menuService);
            else 
                return this.serviceProvider.GetService(serviceType);

        }

        #endregion

        #region Events (subset of IVsTrackProjectDocumentsEvents)
        // This makes it easier for the derived class to subscribe to only the events it
        // is really interested in and get one event per file. This also filter events
        // and only send events that have to do with this project

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.EventHandler"]/*' />
        public delegate void EventHandler<ProjectDocumentsChangeEventArgs>(object sender, ProjectDocumentsChangeEventArgs e);

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileAdded"]/*' />
        /// <devdoc>
        /// Called after a file was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRemoved"]/*' />
        /// <devdoc>
        /// Called after a file was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRenamed"]/*' />
        /// <devdoc>
        /// Called after a file was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryAdded"]/*' />
        /// <devdoc>
        /// Called after a directory was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRemoved"]/*' />
        /// <devdoc>
        /// Called after a directory was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRenamed"]/*' />
        /// <devdoc>
        /// Called after a directory was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SccStatusChanged"]/*' />
        /// <devdoc>
        /// Called after the source code control status of a file in this project changed.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> SccStatusChanged;
        #endregion

        #region IVsTrackProjectDocumentsEvents2 Members
        internal class DocumentsEventsSink : IVsTrackProjectDocumentsEvents2
        {
            private FlavoredProjectBase _flavoredProjectBase; 

            internal DocumentsEventsSink(FlavoredProjectBase flavoredProjectBase)
            {
                _flavoredProjectBase = flavoredProjectBase;
            }

            /// We subscribes to IVsTrackProjectDocumentsEvents and trigger the
            /// corresponding event once per file per event.
            /// We filters the events to only reports those related to our project.
            /// This is NOT required for flavoring, but simplify the work the
            /// derived classes have to do when subscribing to these events

            int IVsTrackProjectDocumentsEvents2.OnAfterAddDirectoriesEx(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDDIRECTORYFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.DirectoryAdded, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterAddFilesEx(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDFILEFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.FileAdded, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRemoveDirectories(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEDIRECTORYFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.DirectoryRemoved, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRemoveFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEFILEFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.FileRemoved, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRenameDirectories(int cProjects, int cDirs, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEDIRECTORYFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, _flavoredProjectBase.DirectoryRenamed, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterRenameFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEFILEFLAGS[] rgFlags)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, _flavoredProjectBase.FileRenamed, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnAfterSccStatusChanged(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, uint[] rgdwSccStatus)
            {
                _flavoredProjectBase.GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, _flavoredProjectBase.SccStatusChanged, new ProjectDocumentsChangeEventArgs());
                return VSConstants.S_OK;
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryAddDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYADDDIRECTORYFLAGS[] rgFlags, VSQUERYADDDIRECTORYRESULTS[] pSummaryResult, VSQUERYADDDIRECTORYRESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryAddFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYADDFILEFLAGS[] rgFlags, VSQUERYADDFILERESULTS[] pSummaryResult, VSQUERYADDFILERESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRemoveDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYREMOVEDIRECTORYFLAGS[] rgFlags, VSQUERYREMOVEDIRECTORYRESULTS[] pSummaryResult, VSQUERYREMOVEDIRECTORYRESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRemoveFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYREMOVEFILEFLAGS[] rgFlags, VSQUERYREMOVEFILERESULTS[] pSummaryResult, VSQUERYREMOVEFILERESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRenameDirectories(IVsProject pProject, int cDirs, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEDIRECTORYFLAGS[] rgFlags, VSQUERYRENAMEDIRECTORYRESULTS[] pSummaryResult, VSQUERYRENAMEDIRECTORYRESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }

            int IVsTrackProjectDocumentsEvents2.OnQueryRenameFiles(IVsProject pProject, int cFiles, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEFILEFLAGS[] rgFlags, VSQUERYRENAMEFILERESULTS[] pSummaryResult, VSQUERYRENAMEFILERESULTS[] rgResults)
            {
                return VSConstants.S_OK; // We are not interested in this one
            }
        }

        #endregion

        #region Helpers for IVsTrackProjectDocumentsEvents2

        /// <devdoc>
        /// Used to subscribe/unsubscribe to those events
        /// </devdoc>
        private IVsTrackProjectDocuments2 GetTrackProjectDocuments()
        {
            IVsTrackProjectDocuments2 trackDocuments = ((System.IServiceProvider)this).GetService(typeof(SVsTrackProjectDocuments)) as IVsTrackProjectDocuments2;
            Debug.Assert(trackDocuments != null, "Could not get the IVsTrackProjectDocuments2 object");
            if (trackDocuments == null)
            {
                throw new InvalidOperationException();
            }
            return trackDocuments;
        }

        /// <devdoc>
        /// Look at the list of projects and files and for each file that is part of this
        /// project, set the MkDocument on the event argument and trigger the event.
        /// </devdoc>
        private void GenerateEvents(
            IVsProject[] projects,
            int[] firstFiles,
            string[] mkDocuments,
            EventHandler<ProjectDocumentsChangeEventArgs> eventToGenerate,
            ProjectDocumentsChangeEventArgs e)
        {
            if (eventToGenerate == null)
                return; // no event = nothing to do

            if (projects == null || firstFiles == null || mkDocuments == null)
                throw new ArgumentNullException();
            if (projects.Length != firstFiles.Length)
                throw new ArgumentException();

            // First find out which range of the array (if any) include the files that belong to this project
            int first = -1;
            int last = mkDocuments.Length - 1; // default to the last document
            for (int i = 0; i < projects.Length; ++i)
            {
                if (first > -1)
                {
                    // We get here if there is 1 or more project(s) after ours in the list
                    last = firstFiles[i] - 1;
                    break;
                }
                if (IsThisProject(projects[i]))
                    first = firstFiles[i];
            }
            if (last >= mkDocuments.Length)
                throw new ArgumentException();
            // See if we have any documents
            if (first < 0)
                return; // Nothing that belongs to this project

            // For each file, generate the event
            for (int i = first; i <= last; ++i)
            {
                try
                {
                    e.MkDocument = mkDocuments[i];
                    eventToGenerate(this, e);
                }
                catch(Exception error)
                {
                    Debug.Fail(error.Message);
                }
            }
        }

        private bool IsThisProject(IVsProject prj)
        {
            bool areSame = false;
            Guid IID_IUnknown = VSConstants.IID_IUnknown;
            IntPtr otherPtr = IntPtr.Zero;
            IntPtr otherIUnk = IntPtr.Zero;
            IntPtr thisPtr = IntPtr.Zero;
            IntPtr thisIUnk = IntPtr.Zero;
            try
            {
                otherPtr = Marshal.GetIUnknownForObject(prj);
                Marshal.QueryInterface(otherPtr, ref IID_IUnknown, out otherIUnk);

                thisPtr = Marshal.GetIUnknownForObject(this);
                Marshal.QueryInterface(thisPtr, ref IID_IUnknown, out thisIUnk);
                areSame = (otherIUnk == thisIUnk);
            }
            finally
            {
                if (IntPtr.Zero != otherPtr)
                {
                    Marshal.Release(otherPtr);
                }
                if (IntPtr.Zero != otherIUnk)
                {
                    Marshal.Release(otherIUnk);
                }
                if (IntPtr.Zero != thisPtr)
                {
                    Marshal.Release(thisPtr);
                }
                if (IntPtr.Zero != thisIUnk)
                {
                    Marshal.Release(thisIUnk);
                }
            }
            return areSame;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\MockBuildEngine.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;

using MSBuild = Microsoft.Build.Framework;

namespace Microsoft.VsSDK.UnitTestLibrary
{
	public class MockBuildEngine : MSBuild.IBuildEngine
	{
		#region IBuildEngine Members

		public bool BuildProjectFile(string projectFileName, string[] targetNames, System.Collections.IDictionary globalProperties, System.Collections.IDictionary targetOutputs)
		{
			throw new NotImplementedException();
		}

		public void LogCustomEvent(Microsoft.Build.Framework.CustomBuildEventArgs e)
		{
			throw new NotImplementedException();
		}

		public void LogErrorEvent(Microsoft.Build.Framework.BuildErrorEventArgs e)
		{
		}

		public void LogMessageEvent(Microsoft.Build.Framework.BuildMessageEventArgs e)
		{
		}

		public void LogWarningEvent(Microsoft.Build.Framework.BuildWarningEventArgs e)
		{
		}

		public int ColumnNumberOfTaskNode
		{
			get {return 1;}
		}

		public bool ContinueOnError
		{
			get {return false;}
		}

		public int LineNumberOfTaskNode
		{
			get {return 1;}
		}

		public string ProjectFileOfTaskNode
		{
			get { return String.Empty; }
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\Shell90\Flavor\Project.cs ===
/***************************************************************************
         Copyright (c) Microsoft Corporation, All rights reserved.             
    This code sample is provided "AS IS" without warranty of any kind, 
    it is not recommended for use in a production environment.
***************************************************************************/

namespace Microsoft.VisualStudio.Shell.Flavor
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using Microsoft.VisualStudio.Shell.Interop;
    using Microsoft.VisualStudio.OLE.Interop;
    using Microsoft.VisualStudio.Shell;

    /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject"]/*' />
    /// <devdoc>
    /// A project that is a subtype/flavor of an inner project.
    /// The default behavior of all methods is to delegate to the
    /// inner project. For any behavior you want to change, simply
    /// handle the request yourself.
    /// </devdoc>
    [CLSCompliant(false)]
    public abstract class FlavoredProject : 
        Microsoft.VisualStudio.ProjectAggregator.CProjectAggregatorClass, // Provide aggregation support
        IVsAggregatableProject,
        System.IServiceProvider,
        IVsHierarchy,
        IVsUIHierarchy,
        IOleCommandTarget,
        IVsTrackProjectDocumentsEvents2
    {
        // Keep interface reference for all interface we override

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsAggregatableProject"]/*' />
        protected IVsAggregatableProject innerVsAggregatableProject;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsHierarchy"]/*' />
        protected IVsHierarchy innerVsHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerVsUIHierarchy"]/*' />
        protected IVsUIHierarchy innerVsUIHierarchy;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.innerOleCommandTarget"]/*' />
        protected IOleCommandTarget innerOleCommandTarget;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.serviceProvider"]/*' />
        protected System.IServiceProvider serviceProvider;

        private OleMenuCommandService menuService;

        uint cookie = 0;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FlavoredProject"]/*' />
        public FlavoredProject()
        {
        }

        #region IVsAggregatableProject

        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        int IVsAggregatableProject.SetInnerProject(object inner)
        {
            // delegate to the protected method
            this.SetInnerProject(inner);

            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetInnerProject"]/*' />
        /// <devdoc>
        /// This is were all QI for interface on the inner object should happen
        /// Then set the inner project
        /// wait for InitializeForOuter to be called to do the real initialization
        /// </devdoc>
        protected virtual void SetInnerProject(object inner)
        {
            // Keep a reference to each interface we want to call on the inner project
            // we must do it now as once we call SetInner the AddRef would be forwarded to ourselves
            innerVsAggregatableProject = (IVsAggregatableProject)inner;
            innerVsHierarchy = (IVsHierarchy)inner;
            innerVsUIHierarchy = (IVsUIHierarchy)inner;
            // As should return null without throwing in the event the base project does not implement the interface
            innerOleCommandTarget = inner as IOleCommandTarget;

            // Setup our menu command service
            if (this.serviceProvider == null)
                throw new NotSupportedException("serviceProvider should have been set before SetInnerProject gets called.");
            menuService = new OleMenuCommandService(this, innerOleCommandTarget);

            // Aggregate the project
            this.SetInner(inner);
        }

        /// <devdoc>
        /// Do the initialization here (such as loading flavor specific
        /// information from the project)
        /// </devdoc>
        int IVsAggregatableProject.InitializeForOuter(string fileName, string location, string name,
            uint flags, ref Guid guidProject, out IntPtr project, out int canceled)
        {
            if (innerVsAggregatableProject == null || guidProject != NativeMethods.IID_IUnknown)
                throw new NotSupportedException();

            Marshal.QueryInterface(Marshal.GetIUnknownForObject(this), ref guidProject, out project);

            canceled = 0;
            bool cancel;
            this.InitializeForOuter(fileName, location, name, flags, ref guidProject, out cancel);
            if (cancel)
                canceled = 1;

            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.InitializeForOuter"]/*' />
        /// <devdoc>
        /// Allow the project to initialize itself.
        /// At this point it possible to call the inner project
        /// Also allow canceling the project creation
        /// </devdoc>
        /// <returns>Return true to cancel the project creation</returns>
        protected virtual void InitializeForOuter(string fileName, string location, string name, uint flags, ref Guid guidProject, out bool cancel)
        {
            cancel = false;
        }
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        int IVsAggregatableProject.OnAggregationComplete()
        {
            this.OnAggregationComplete();
            if (innerVsAggregatableProject != null)
                return innerVsAggregatableProject.OnAggregationComplete();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.OnAggregationComplete"]/*' />
        /// <devdoc>
        /// This is called when all object in aggregation have received InitializeForOuter calls.
        /// At this point the aggregation is complete and fully functional.
        /// </devdoc>
        protected virtual void OnAggregationComplete()
        {
            // This will subscribe to the IVsTrackProjectDocumentsEvents.
            // This is not required to flavor a project but makes it easier for derived class
            // to subscribe to these events.
            IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
            ErrorHandler.ThrowOnFailure(trackDocuments.AdviseTrackProjectDocumentsEvents(this, out cookie));
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProject.SetAggregateProjectTypeGuids(string projectTypeGuids)
        {
            if (innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return innerVsAggregatableProject.SetAggregateProjectTypeGuids(projectTypeGuids);
        }

        /// <devdoc>
        /// This must be delegetated to the inner most project
        /// </devdoc>
        int IVsAggregatableProject.GetAggregateProjectTypeGuids(out string projectTypeGuids)
        {
            if (innerVsAggregatableProject == null)
                throw new NotSupportedException();

            return innerVsAggregatableProject.GetAggregateProjectTypeGuids(out projectTypeGuids);
        }

        #endregion

        #region IVsHierarchy
        //
        // Most methods call protected virtual methods which delegate to the inner project.
        // Derived classes should override those protected method if they want to change the
        // behavior.
        //

        int IVsHierarchy.AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink, out uint cookie)
        {
            cookie = this.AdviseHierarchyEvents(eventSink);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Close()
        {
            if (cookie != 0)
            {
                // Unsubscribe to events
                IVsTrackProjectDocuments2 trackDocuments = GetTrackProjectDocuments();
                trackDocuments.UnadviseTrackProjectDocumentsEvents(cookie);
                cookie = 0;
            }
            this.Close();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.GetCanonicalName(uint itemId, out string name)
        {
            return this.GetCanonicalName(itemId, out name);
        }

        int IVsHierarchy.GetGuidProperty(uint itemId, int propId, out System.Guid guid)
        {
            guid = this.GetGuidProperty(itemId, propId);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return this.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        int IVsHierarchy.GetProperty(uint itemId, int propId, out System.Object property)
        {
            // While other methods expect the protected method to throw, for GetProperty
            // we break this pattern as it is called much more often and it is legitimate to
            // return not implemented. Therefore it can help perf and debugging experience
            return this.GetProperty(itemId, propId, out property);
        }

        int IVsHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            serviceProvider = this.GetSite();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.ParseCanonicalName(string name, out uint itemId)
        {
            return this.ParseCanonicalName(name, out itemId);
        }

        int IVsHierarchy.QueryClose(out int canClose)
        {
            canClose = 0;
            if (this.QueryClose())
                canClose = 1;
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            this.SetGuidProperty(itemId, propId, ref guid);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider)
        {
            this.serviceProvider = (System.IServiceProvider)new ServiceProvider(serviceProvider);
            NativeMethods.ThrowOnFailure(innerVsHierarchy.SetSite(serviceProvider));
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.UnadviseHierarchyEvents(uint cookie)
        {
            this.UnadviseHierarchyEvents(cookie);
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.SetProperty(uint itemId, int propId, System.Object property)
        {
            return this.SetProperty(itemId, propId, property);
        }

        int IVsHierarchy.Unused0()
        {
            this.Unused0();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused1()
        {
            this.Unused1();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused2()
        {
            this.Unused2();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused3()
        {
            this.Unused3();
            return NativeMethods.S_OK;
        }

        int IVsHierarchy.Unused4()
        {
            this.Unused4();
            return NativeMethods.S_OK;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.AdviseHierarchyEvents"]/*' />
        protected virtual uint AdviseHierarchyEvents(Microsoft.VisualStudio.Shell.Interop.IVsHierarchyEvents eventSink)
        {
            uint cookie=0;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.AdviseHierarchyEvents(eventSink, out cookie));
            return cookie;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Close"]/*' />
        protected virtual void Close()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Close());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetCanonicalName"]/*' />
        protected virtual int GetCanonicalName(uint itemId, out string name)
        {
            return innerVsHierarchy.GetCanonicalName(itemId, out name);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetGuidProperty"]/*' />
        protected virtual Guid GetGuidProperty(uint itemId, int propId)
        {
            Guid property;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.GetGuidProperty(itemId, propId, out property));
            return property;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetNestedHierarchy"]/*' />
        protected virtual int GetNestedHierarchy(uint itemId, ref System.Guid guidHierarchyNested, out System.IntPtr hierarchyNested, out uint itemIdNested)
        {
            return innerVsHierarchy.GetNestedHierarchy(itemId, ref guidHierarchyNested, out hierarchyNested, out itemIdNested);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetProperty"]/*' />
        protected virtual int GetProperty(uint itemId, int propId, out Object property)
        {
            return innerVsHierarchy.GetProperty(itemId, propId, out property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.GetSite"]/*' />
        protected virtual Microsoft.VisualStudio.OLE.Interop.IServiceProvider GetSite()
        {
            Microsoft.VisualStudio.OLE.Interop.IServiceProvider serviceProvider;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.GetSite(out serviceProvider));
            return serviceProvider;
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ParseCanonicalName"]/*' />
        protected virtual int ParseCanonicalName(string name, out uint itemId)
        {
            return innerVsHierarchy.ParseCanonicalName(name, out itemId);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryClose"]/*' />
        protected virtual bool QueryClose()
        {
            int canClose;
            NativeMethods.ThrowOnFailure(innerVsHierarchy.QueryClose(out canClose));
            return (canClose != 0);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetGuidProperty"]/*' />
        protected virtual void SetGuidProperty(uint itemId, int propId, ref System.Guid guid)
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.SetGuidProperty(itemId, propId, ref guid));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.UnadviseHierarchyEvents"]/*' />
        protected virtual void UnadviseHierarchyEvents(uint cookie)
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.UnadviseHierarchyEvents(cookie));
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SetProperty"]/*' />
        protected virtual int SetProperty(uint itemId, int propId, System.Object property)
        {
            return innerVsHierarchy.SetProperty(itemId, propId, property);
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused0"]/*' />
        protected virtual void Unused0()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused0());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused1"]/*' />
        protected virtual void Unused1()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused1());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused2"]/*' />
        protected virtual void Unused2()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused2());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused3"]/*' />
        protected virtual void Unused3()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused3());
        }

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.Unused4"]/*' />
        protected virtual void Unused4()
        {
            NativeMethods.ThrowOnFailure(innerVsHierarchy.Unused4());
        }
        #endregion

        #region IVsUIHierarchy Members
        //
        // All methods (except for QueryStatusCommand and ExecCommand) call the IVsHierarchy implementation.
        // QueryStatusCommand and ExecCommand call a protected virtual method that the base class can override.
        // Note that we QI for IVsUIHierarchy on this so that if we are flavored we call the outer IVsHierarchy.
        //

        int IVsUIHierarchy.QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return this.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.QueryStatusCommand"]/*' />
        protected virtual int QueryStatusCommand(uint itemid, ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            return innerVsUIHierarchy.QueryStatusCommand(itemid, ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
        }

        int IVsUIHierarchy.ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return this.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.ExecCommand"]/*' />
        protected virtual int ExecCommand(uint itemid, ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            return innerVsUIHierarchy.ExecCommand(itemid, ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
        }



        int IVsUIHierarchy.AdviseHierarchyEvents(IVsHierarchyEvents pEventSink, out uint pdwCookie)
        {
            return ((IVsHierarchy)this).AdviseHierarchyEvents(pEventSink, out pdwCookie);
        }

        int IVsUIHierarchy.Close()
        {
            return ((IVsHierarchy)this).Close();
        }

        int IVsUIHierarchy.GetCanonicalName(uint itemid, out string pbstrName)
        {
            return ((IVsHierarchy)this).GetCanonicalName(itemid, out pbstrName);
        }

        int IVsUIHierarchy.GetGuidProperty(uint itemid, int propid, out Guid pguid)
        {
            return ((IVsHierarchy)this).GetGuidProperty(itemid, propid, out pguid);
        }

        int IVsUIHierarchy.GetNestedHierarchy(uint itemid, ref Guid iidHierarchyNested, out IntPtr ppHierarchyNested, out uint pitemidNested)
        {
            return ((IVsHierarchy)this).GetNestedHierarchy(itemid, ref iidHierarchyNested, out ppHierarchyNested, out pitemidNested);
        }

        int IVsUIHierarchy.GetProperty(uint itemid, int propid, out object pvar)
        {
            return ((IVsHierarchy)this).GetProperty(itemid, propid, out pvar);
        }

        int IVsUIHierarchy.GetSite(out Microsoft.VisualStudio.OLE.Interop.IServiceProvider ppSP)
        {
            return ((IVsHierarchy)this).GetSite(out ppSP);
        }

        int IVsUIHierarchy.ParseCanonicalName(string pszName, out uint pitemid)
        {
            return ((IVsHierarchy)this).ParseCanonicalName(pszName, out pitemid);
        }

        int IVsUIHierarchy.QueryClose(out int pfCanClose)
        {
            return ((IVsHierarchy)this).QueryClose(out pfCanClose);
        }

        int IVsUIHierarchy.SetGuidProperty(uint itemid, int propid, ref Guid rguid)
        {
            return ((IVsHierarchy)this).SetGuidProperty(itemid, propid, ref rguid);
        }

        int IVsUIHierarchy.SetProperty(uint itemid, int propid, object var)
        {
            return ((IVsHierarchy)this).SetProperty(itemid, propid, var);
        }

        int IVsUIHierarchy.SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            return ((IVsHierarchy)this).SetSite(psp);
        }

        int IVsUIHierarchy.UnadviseHierarchyEvents(uint dwCookie)
        {
            return ((IVsHierarchy)this).UnadviseHierarchyEvents(dwCookie);
        }

        int IVsUIHierarchy.Unused0()
        {
            return ((IVsHierarchy)this).Unused0();
        }

        int IVsUIHierarchy.Unused1()
        {
            return ((IVsHierarchy)this).Unused1();
        }

        int IVsUIHierarchy.Unused2()
        {
            return ((IVsHierarchy)this).Unused2();
        }

        int IVsUIHierarchy.Unused3()
        {
            return ((IVsHierarchy)this).Unused3();
        }

        int IVsUIHierarchy.Unused4()
        {
            return ((IVsHierarchy)this).Unused4();
        }

        #endregion


        #region IOleCommandTarget Members

        int IOleCommandTarget.Exec(ref Guid pguidCmdGroup, uint nCmdID, uint nCmdexecopt, IntPtr pvaIn, IntPtr pvaOut)
        {
            int hr = ((IOleCommandTarget)menuService).Exec(ref pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
            return hr;
        }

        int IOleCommandTarget.QueryStatus(ref Guid pguidCmdGroup, uint cCmds, OLECMD[] prgCmds, IntPtr pCmdText)
        {
            int hr = ((IOleCommandTarget)menuService).QueryStatus(ref pguidCmdGroup, cCmds, prgCmds, pCmdText);
            return hr;
        }

        #endregion

        #region IServiceProvider Members

        object System.IServiceProvider.GetService(Type serviceType)
        {
            if (serviceType == typeof(IOleCommandTarget))
                return ((IOleCommandTarget)menuService);
            else if (serviceType == typeof(System.ComponentModel.Design.IMenuCommandService))
                return ((System.ComponentModel.Design.IMenuCommandService)menuService);
            else 
                return this.serviceProvider.GetService(serviceType);

        }

        #endregion

        #region Events (subset of IVsTrackProjectDocumentsEvents)
        // This makes it easier for the derived class to subscribe to only the events it
        // is really interested in and get one event per file. This also filter events
        // and only send events that have to do with this project

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.EventHandler"]/*' />
        public delegate void EventHandler<ProjectDocumentsChangeEventArgs>(object sender, ProjectDocumentsChangeEventArgs e);

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileAdded"]/*' />
        /// <devdoc>
        /// Called after a file was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRemoved"]/*' />
        /// <devdoc>
        /// Called after a file was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.FileRenamed"]/*' />
        /// <devdoc>
        /// Called after a file was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> FileRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryAdded"]/*' />
        /// <devdoc>
        /// Called after a directory was added to this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryAdded;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRemoved"]/*' />
        /// <devdoc>
        /// Called after a directory was remove from this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRemoved;
        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.DirectoryRenamed"]/*' />
        /// <devdoc>
        /// Called after a directory was renamed in this project.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> DirectoryRenamed;

        /// <include file='doc\FlavoredProject.uex' path='docs/doc[@for="FlavoredProject.SccStatusChanged"]/*' />
        /// <devdoc>
        /// Called after the source code control status of a file in this project changed.
        /// </devdoc>
        public event EventHandler<ProjectDocumentsChangeEventArgs> SccStatusChanged;
        #endregion

        #region IVsTrackProjectDocumentsEvents2 Members
        /// We subscribes to IVsTrackProjectDocumentsEvents and trigger the
        /// corresponding event once per file per event.
        /// We filters the events to only reports those related to our project.
        /// This is NOT required for flavoring, but simplify the work the
        /// derived classes have to do when subscribing to these events

        int IVsTrackProjectDocumentsEvents2.OnAfterAddDirectoriesEx(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, DirectoryAdded, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterAddFilesEx(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSADDFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, FileAdded, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRemoveDirectories(int cProjects, int cDirectories, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, DirectoryRemoved, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRemoveFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, VSREMOVEFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, FileRemoved, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRenameDirectories(int cProjects, int cDirs, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEDIRECTORYFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, DirectoryRenamed, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterRenameFiles(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgszMkOldNames, string[] rgszMkNewNames, VSRENAMEFILEFLAGS[] rgFlags)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgszMkNewNames, FileRenamed, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnAfterSccStatusChanged(int cProjects, int cFiles, IVsProject[] rgpProjects, int[] rgFirstIndices, string[] rgpszMkDocuments, uint[] rgdwSccStatus)
        {
            GenerateEvents(rgpProjects, rgFirstIndices, rgpszMkDocuments, SccStatusChanged, new ProjectDocumentsChangeEventArgs());
            return NativeMethods.S_OK;
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryAddDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYADDDIRECTORYFLAGS[] rgFlags, VSQUERYADDDIRECTORYRESULTS[] pSummaryResult, VSQUERYADDDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryAddFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYADDFILEFLAGS[] rgFlags, VSQUERYADDFILERESULTS[] pSummaryResult, VSQUERYADDFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRemoveDirectories(IVsProject pProject, int cDirectories, string[] rgpszMkDocuments, VSQUERYREMOVEDIRECTORYFLAGS[] rgFlags, VSQUERYREMOVEDIRECTORYRESULTS[] pSummaryResult, VSQUERYREMOVEDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRemoveFiles(IVsProject pProject, int cFiles, string[] rgpszMkDocuments, VSQUERYREMOVEFILEFLAGS[] rgFlags, VSQUERYREMOVEFILERESULTS[] pSummaryResult, VSQUERYREMOVEFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRenameDirectories(IVsProject pProject, int cDirs, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEDIRECTORYFLAGS[] rgFlags, VSQUERYRENAMEDIRECTORYRESULTS[] pSummaryResult, VSQUERYRENAMEDIRECTORYRESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        int IVsTrackProjectDocumentsEvents2.OnQueryRenameFiles(IVsProject pProject, int cFiles, string[] rgszMkOldNames, string[] rgszMkNewNames, VSQUERYRENAMEFILEFLAGS[] rgFlags, VSQUERYRENAMEFILERESULTS[] pSummaryResult, VSQUERYRENAMEFILERESULTS[] rgResults)
        {
            return NativeMethods.S_OK; // We are not interested in this one
        }

        #endregion

        #region Helpers for IVsTrackProjectDocumentsEvents2

        /// <devdoc>
        /// Used to subscribe/unsubscribe to those events
        /// </devdoc>
        private IVsTrackProjectDocuments2 GetTrackProjectDocuments()
        {
            IVsTrackProjectDocuments2 trackDocuments = ((System.IServiceProvider)this).GetService(typeof(SVsTrackProjectDocuments)) as IVsTrackProjectDocuments2;
            if (trackDocuments == null)
            {
                throw new ApplicationException(string.Format(Resources.Culture, Resources.Flavor_FailedToGetService, "SVsTrackProjectDocuments"));
            }
            return trackDocuments;
        }

        /// <devdoc>
        /// Look at the list of projects and files and for each file that is part of this
        /// project, set the MkDocument on the event argument and trigger the event.
        /// </devdoc>
        private void GenerateEvents(
            IVsProject[] projects,
            int[] firstFiles,
            string[] mkDocuments,
            EventHandler<ProjectDocumentsChangeEventArgs> eventToGenerate,
            ProjectDocumentsChangeEventArgs e)
        {
            if (eventToGenerate == null)
                return; // no event = nothing to do

            if (projects == null || firstFiles == null || mkDocuments == null)
                throw new ArgumentNullException();
            if (projects.Length != firstFiles.Length)
                throw new ArgumentException();

            // First find out which range of the array (if any) include the files that belong to this project
            int first = -1;
            int last = mkDocuments.Length - 1; // default to the last document
            for (int i = 0; i < projects.Length; ++i)
            {
                if (first > -1)
                {
                    // We get here if there is 1 or more project(s) after ours in the list
                    last = firstFiles[i] - 1;
                    break;
                }
                if (Object.ReferenceEquals(projects[i], this))
                    first = firstFiles[i];
            }
            if (last >= mkDocuments.Length)
                throw new ArgumentException();
            // See if we have any documents
            if (first < 0)
                return; // Nothing that belongs to this project

            // For each file, generate the event
            for (int i = first; i <= last; ++i)
            {
                try
                {
                    e.MkDocument = mkDocuments[i];
                    eventToGenerate(this, e);
                }
                catch(Exception error)
                {
                    Debug.Fail(error.Message);
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\LocalRegistryMock.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

using Microsoft.VisualStudio.Shell.Interop;

namespace Microsoft.VsSDK.UnitTestLibrary
{
    [CLSCompliant(false)]
    public class LocalRegistryMock : ILocalRegistry, ILocalRegistry2, ILocalRegistry3
    {
        private Dictionary<Guid, object> objectsList;
        private string registryRoot;

        public LocalRegistryMock()
        {
            objectsList = new Dictionary<Guid, object>();
        }
        public void AddClass(Type classType, object instance)
        {
            if (objectsList.ContainsKey(classType.GUID))
            {
                objectsList.Remove(classType.GUID);
            }
            objectsList.Add(classType.GUID, instance);
        }
        public string RegistryRoot
        {
            get { return registryRoot; }
            set { registryRoot = value; }
        }

        public int CreateInstance(Guid clsid, object punkOuter, ref Guid riid, uint dwFlags, out IntPtr ppvObj)
        {
            ppvObj = IntPtr.Zero;
            if (!objectsList.ContainsKey(clsid))
            {
                return Microsoft.VisualStudio.VSConstants.E_NOINTERFACE;
            }
            object obj = objectsList[clsid];
            ppvObj = System.Runtime.InteropServices.Marshal.GetIUnknownForObject(obj);
            return Microsoft.VisualStudio.VSConstants.S_OK;
        }

        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public int CreateManagedInstance(string codeBase, string assemblyName, string typeName, ref Guid riid, out IntPtr ppvObj)
        {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public virtual int GetClassObjectOfClsid(ref Guid clsid, uint dwFlags, IntPtr lpReserved, ref Guid riid, out IntPtr ppvClassObject)
        {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public int GetClassObjectOfClsid(ref Guid clsid, uint dwFlags, IntPtr lpReserved, ref Guid riid, IntPtr ppvClassObject)
        {
            return ((ILocalRegistry)this).GetClassObjectOfClsid(ref clsid, dwFlags, lpReserved, ref riid, out ppvClassObject);
        }

        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public int GetClassObjectOfManagedClass(string codeBase, string assemblyName, string typeName, ref Guid riid, out IntPtr ppvClassObject)
        {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        public int GetLocalRegistryRoot(out string pbstrRoot)
        {
            pbstrRoot = registryRoot;
            return Microsoft.VisualStudio.VSConstants.S_OK;
        }

        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public virtual int GetTypeLibOfClsid(Guid clsid, out Microsoft.VisualStudio.OLE.Interop.ITypeLib pptLib)
        {
            throw new NotImplementedException("The method or operation is not implemented.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\FileGenerator.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Xml;
using System.IO;
using System.Text;
using System.Reflection;

namespace Microsoft.VsSDK.UnitTestLibrary
{
	public sealed class FileGenerator
	{
		private string path;

		public FileGenerator(string relativePath)
		{
			// Generate temp directory name
			path = Path.Combine(Path.GetTempPath(), relativePath);

			// Delete it if it already exist to prevent being affected by previous runs
			try
			{
				if (Directory.Exists(path))
					Directory.Delete(path, true);
			}
			catch (IOException)
			{ }

			// Create the directory
			Directory.CreateDirectory(path);
		}

		/// <summary>
		/// Create the specified path under a temp directory
		/// The file will have some content
		/// </summary>
		/// <param name="fileName">FileName, can include relative path</param>
		public string CreateFile(string fileName)
		{
			return CreateFileWithSpecificContent(fileName, fileName);
		}

		public string CreateFileFromEmbeddedContent(string fileName, string content)
		{
			return CreateFileWithSpecificContent(fileName, content);
		}

		public string CreateXmlFileFromEmbeddedContent(string fileName, string content)
		{
			// Create an XML document with the specific content
			XmlDocument doc = new XmlDocument();
			doc.LoadXml(content);

			string outputPath = this.GetFullPath(fileName);
			doc.Save(outputPath);

			return outputPath;
		}

		/// <summary>
		/// Create the specified path under a temp directory
		/// Add the specified content to the file
		/// </summary>
		/// <param name="fileName">FileName, can include relative path</param>
		/// <param name="content">Content to add to the file</param>
		public string CreateFileWithSpecificContent(string fileName, string content)
		{
			string filePath = this.GetFullPath(fileName);
			string directory = Path.GetDirectoryName(filePath);
			if (!Directory.Exists(directory))
				Directory.CreateDirectory(directory);
			using (StreamWriter file = File.CreateText(filePath))
			{
				file.WriteLine(content);
			}

			return filePath;
		}

		/// <summary>
		/// Verify that the files have the same content
		/// </summary>
		/// <param name="path1">Full path of one of the file</param>
		/// <param name="path2">Full path of the other file</param>
		/// <param name="comparaisonType">What kind of comparaison to use</param>
		/// <returns></returns>
		public static bool FilesContentIsSame(string path1, string path2, StringComparison comparisonType)
		{
			string content1;
			string content2;
			using (StreamReader contentReader = File.OpenText(path1))
			{
				content1 = contentReader.ReadToEnd();
			}
			using (StreamReader contentReader = File.OpenText(path2))
			{
				content2 = contentReader.ReadToEnd();
			}

			return String.Equals(content1, content2, comparisonType);
		}

		private string GetFullPath(string fileName)
		{
			string filePath = Path.Combine(path, fileName);

			return filePath;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\ConnectionPointHelper.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Globalization;

using Microsoft.VisualStudio.OLE.Interop;

namespace Microsoft.VsSDK.UnitTestLibrary
{
    public static class ConnectionPointHelper
    {
        private const string connectionPointsCollection = "ConnectionPoints";
        private static GenericMockFactory connectionPointFactory;

        private static void FindConnectionPointCallback(object sender, CallbackArgs args)
        {
            BaseMock mock = (BaseMock)sender;
            Dictionary<Guid, IConnectionPoint> connectionPoints =
                (Dictionary<Guid, IConnectionPoint>)mock[connectionPointsCollection];
            Guid eventGuid = (Guid)args.GetParameter(0);
            IConnectionPoint connectionPoint;
            if (!connectionPoints.TryGetValue(eventGuid, out connectionPoint))
            {
                // This container does not contain a connection point for this event type,
                // so set the out parameter to null and return an error.
                args.SetParameter(1, null);
                args.ReturnValue = Microsoft.VisualStudio.VSConstants.E_NOINTERFACE;
                return;
            }
            // The connection point is handled.
            args.SetParameter(1, connectionPoint);
            args.ReturnValue = Microsoft.VisualStudio.VSConstants.S_OK;
        }

        /// <summary>
        /// Given a mock object, this function will add to it a callback function to handle
        /// IConnectionPointContainer.FindConnectionPoint for all the event interfaces contained
        /// in the array passed as parameter.
        /// </summary>
        public static void AddConnectionPointsToContainer(BaseMock mockContainer, Type[] eventInterfaces)
        {
            // Check that the mock object implements IConnectionPointContainer.
            if (null == (mockContainer as IConnectionPointContainer))
            {
                throw new InvalidCastException("Parameter mockContainer does not implement IConnectionPointContainer.");
            }
            // Check if there is any interface in the array.
            if ((null == eventInterfaces) || (eventInterfaces.Length == 0))
            {
                throw new ArgumentNullException("eventIterfaces");
            }
            // Create the Dictionary that will store the connection points.
            Dictionary<Guid, IConnectionPoint> connectionPoints = new Dictionary<Guid, IConnectionPoint>();

            // Get the factory for the connection points.
            if (null == connectionPointFactory)
            {
                connectionPointFactory = new GenericMockFactory("MockLibraryConnectionPoint", new Type[] { typeof(IConnectionPoint) });
            }

            // Create a connection point for every type in the array.
            foreach (Type eventInterface in eventInterfaces)
            {
                BaseMock connectionMock = connectionPointFactory.GetInstance();
                // Set a return value for the Advise method so that the cookie will be not zero.
                connectionMock.AddMethodReturnValues(
                    string.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(IConnectionPoint).FullName, "Advise"),
                    new object[] { null, (uint)1 });
                // Add this connection point to the dictionary.
                connectionPoints.Add(eventInterface.GUID, connectionMock as IConnectionPoint);
            }

            // Set the dictionary as member data for the container mock.
            mockContainer[connectionPointsCollection] = connectionPoints;

            // Set the callback for the FindConnectionPoint method.
            mockContainer.AddMethodCallback(
                string.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(IConnectionPointContainer).FullName, "FindConnectionPoint"),
                new EventHandler<CallbackArgs>(FindConnectionPointCallback));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\BaseMock.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

[module: SuppressMessage("Microsoft.Naming", "CA1705:LongAcronymsShouldBePascalCased",
   Scope = "namespace", Target = "Microsoft.VsSDK.UnitTestLibrary")]

[module: SuppressMessage("Microsoft.Naming", "CA1706:ShortAcronymsShouldBeUppercase",
   Scope = "namespace", Target = "Microsoft.VsSDK.UnitTestLibrary")]

namespace Microsoft.VsSDK.UnitTestLibrary
{
	/// <summary>
	/// Arguments passed to the callback functions used by the GenericMockFactory
	/// </summary>
    [SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
	public class CallbackArgs : EventArgs
	{
		private object[] parameters;
		private object returnValue;

		/// <summary>
		/// Builds a new CallbackArgs using an array of objects as values for the parameters.
		/// </summary>
		public CallbackArgs(object[] parameters)
		{
			this.parameters = parameters;
		}

		/// <summary>
		/// Get the value of a specific parameter.
		/// </summary>
		public object GetParameter(int index)
		{
			return parameters[index];
		}

		/// <summary>
		/// Set the value of a parameter.
		/// </summary>
		public void SetParameter(int index, object value)
		{
			parameters[index] = value;
		}

		/// <summary>
		/// The return value of the method.
		/// </summary>
		public object ReturnValue
		{
			get { return returnValue; }
			set { returnValue = value; }
		}
	}

	/// <summary>
	/// Base class for dynamicaly generated mock objects.
	/// </summary>
    [System.Runtime.InteropServices.ComVisible(true)]
	public abstract class BaseMock
	{
        [SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
        [SuppressMessage("Microsoft.Design", "CA1006:DoNotNestGenericTypesInMemberSignatures")]
		protected Dictionary<string, EventHandler<CallbackArgs>> callbacks;

        [SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields")]
		protected Dictionary<string, object[]> returnValues;
		private Dictionary<string, object> data;
        private Dictionary<string, int> callsCount;

		protected BaseMock()
		{
			callbacks = new Dictionary<string, EventHandler<CallbackArgs>>();
			returnValues = new Dictionary<string, object[]>();
			data = new Dictionary<string, object>();
            callsCount = new Dictionary<string, int>();
		}

		#region Public methods for Initialization
		/// <summary>
		/// Provide an array of values that will be used as return values in the 
		/// mock object method implementation. Index 0 being the return value index 1
		/// the value assigned to the first parameter (assuming it is ref/out),...
		/// To remove an entry, pass a null ArrayList.
		/// </summary>
		/// <param name="methodName">Name of the method the values are for. Case sensitive.</param>
		/// <param name="valuesToReturn">List of objects to return.
		/// Index 0 is the return value while higher indexes are used for ref/out parameters.</param>
        [SuppressMessage("Microsoft.Maintainability", "CA1500:VariableNamesShouldNotMatchFieldNames")]
		public void AddMethodReturnValues(string methodName, object[] returnValues)
		{
			if (this.returnValues.ContainsKey(methodName))
			{
				this.returnValues.Remove(methodName);
			}
			if (returnValues != null)
			{
				this.returnValues.Add(methodName, returnValues);
			}
		}

		/// <summary>
		/// Provide a call back method that the mock object will call when
		/// methodName is called on the mock object.
		/// As long as no value were specified for AddMethodReturnValues,
		/// the callBackMethod can set the value in the array list to set
		/// which value should be returned (return value and ref/out parameters).
		/// To remove an entry pass null as the callBackMethod.
		/// </summary>
		/// <param name="methodName">Name of the method for which the callback is provided</param>
		/// <param name="callBackMethod">Method to call when methodName is called on the mock object</param>
		public void AddMethodCallback(string methodName, EventHandler<CallbackArgs> callback)
		{
			if (callbacks.ContainsKey(methodName))
			{
				callbacks.Remove(methodName);
			}
			if (null != callback)
			{
				callbacks.Add(methodName, callback);
			}
		}

		#endregion

        /// <summary>
        /// Any data that is needed in the implementation of the callback
        /// can be saved here.
        /// </summary>
        /// <param name="name"></param>
        /// <returns></returns>
        public object this[string name]
        {
            get { return data[name]; }
            set { this.data[name] = value; }
        }

        #region Functions to handle the conters of funtion calls.
        /// <summary>
        /// Returns the number of times a function is called.
        /// </summary>
        /// <param name="name">Function name.</param>
        public int FunctionCalls(string name)
        {
            if (callsCount.ContainsKey(name))
            {
                return callsCount[name];
            }
            return 0;
        }

        /// <summary>
        /// Returns the sum of the number of times each function exposed by this
        /// object was called.
        /// </summary>
        public int TotalCallsAllFunctions()
        {
            int total = 0;
            foreach (int i in callsCount.Values)
            {
                total += i;
            }
            return total;
        }

        /// <summary>
        /// This function is called by the code generated by the GenericMockFactory
        /// when a function is called.
        /// </summary>
        /// <param name="name">Full name of the function.</param>
        protected void IncrementFunctionCalls(string name)
        {
            // A function name can not be empty.
            if (string.IsNullOrEmpty(name))
                return;

            if (callsCount.ContainsKey(name))
            {
                callsCount[name] += 1;
            }
            else
            {
                callsCount[name] = 1;
            }
        }

        /// <summary>
        /// Clears all the data about the number of times aech function is called.
        /// </summary>
        public void ResetAllFunctionCalls()
        {
            callsCount.Clear();
        }

        /// <summary>
        /// Clears the data about the number of times a specific function is called.
        /// </summary>
        /// <param name="name">Function name.</param>
        public void ResetFunctionCalls(string name)
        {
            if (!string.IsNullOrEmpty(name) && callsCount.ContainsKey(name))
            {
                callsCount.Remove(name);
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\OutputWindowService.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.Shell.Interop;

using VSConstants = Microsoft.VisualStudio.VSConstants;

namespace Microsoft.VsSDK.UnitTestLibrary
{
	[CLSCompliant(false)]
	public class OutputWindowService : IVsOutputWindow
	{
		private Dictionary<Guid, string> paneList = new Dictionary<Guid, string>();

		#region IVsOutputWindow Members

		public int CreatePane(ref Guid rguidPane, string pszPaneName, int fInitVisible, int fClearWithSolution)
		{
			// Keep track of the created pane
			paneList.Add(rguidPane, pszPaneName);
			return VSConstants.S_OK;
		}

		public int DeletePane(ref Guid rguidPane)
		{
			paneList.Remove(rguidPane);
			return VSConstants.S_OK;
		}

		public int GetPane(ref Guid rguidPane, out IVsOutputWindowPane ppPane)
		{
			// First make sure the pane was created (we may need to add standard ones in the constructor)
			if (!paneList.ContainsKey(rguidPane))
				throw new ArgumentException("Could not find the requested pane, make sure you call CreatePane first");

			// Create a pane with the correct name
			ppPane = new OutputWindowPane(paneList[rguidPane]);
			return VSConstants.S_OK;
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\OutputWindowPane.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.VisualStudio.Shell.Interop;
using System.Diagnostics.CodeAnalysis;

using VSConstants = Microsoft.VisualStudio.VSConstants;

namespace Microsoft.VsSDK.UnitTestLibrary
{
	[CLSCompliant(false)]
	[SuppressMessage("Microsoft.Naming", "CA1702:CompoundWordsShouldBeCasedCorrectly")]
	public class OutputWindowPane : IVsOutputWindowPane
	{
		private string name = String.Empty;
		public OutputWindowPane(string paneName)
		{
			name = paneName;
		}

		#region IVsOutputWindowPane Members

		public int Activate()
		{
			return VSConstants.S_OK;
		}

		public int Clear()
		{
			return VSConstants.S_OK;
		}

		public int FlushToTaskList()
		{
			return VSConstants.S_OK;
		}

		public int GetName(ref string pbstrPaneName)
		{
			pbstrPaneName = name;
			return VSConstants.S_OK;
		}

		public int Hide()
		{
			return VSConstants.S_OK;
		}

		public int OutputString(string pszOutputString)
		{
			// We should setup this class and the OutputWindowService class such
			// that the test can listen to calls to ouput strings (including what
			// pane it is sent to), but in my current scenario this is not needed.
			return VSConstants.S_OK;
		}

		public int OutputStringThreadSafe(string pszOutputString)
		{
			return VSConstants.S_OK;
		}

		public int OutputTaskItemString(string pszOutputString, VSTASKPRIORITY nPriority, VSTASKCATEGORY nCategory, string pszSubcategory, int nBitmap, string pszFilename, uint nLineNum, string pszTaskItemText)
		{
			return VSConstants.S_OK;
		}

		public int OutputTaskItemStringEx(string pszOutputString, VSTASKPRIORITY nPriority, VSTASKCATEGORY nCategory, string pszSubcategory, int nBitmap, string pszFilename, uint nLineNum, string pszTaskItemText, string pszLookupKwd)
		{
			return VSConstants.S_OK;
		}

		public int SetName(string pszPaneName)
		{
			name = pszPaneName;
			return VSConstants.S_OK;
		}

		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\OleServiceProvider.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Security;
using System.IO;
using System.Collections;
using System.Text;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using IServiceProvider = System.IServiceProvider;

namespace Microsoft.VsSDK.UnitTestLibrary
{
	public class OleServiceProvider : IServiceProvider, IOleServiceProvider, IDisposable
	{
		#region static fields
		private static GenericMockFactory profferServiceFactory;
		private static GenericMockFactory hostLocaleFactory;
		private static GenericMockFactory resourceManagerFactory;
		#endregion

		#region fields
		private class ServiceInstance
		{
			internal object service;
			internal bool shouldDispose;
			internal ServiceInstance(object service, bool shouldDispose)
			{
				this.service = service;
				this.shouldDispose = shouldDispose;
			}
		}

		private Dictionary<Guid, ServiceInstance> services = new Dictionary<Guid, ServiceInstance>();
		private bool isDisposed;
		/// <summary>
		/// Defines an object that will be a mutex for this object for synchronizing thread calls.
		/// </summary>
		private static volatile object Mutex = new object();
		#endregion

		#region ctors
		public OleServiceProvider()
		{
		}

		private static void ProfferServiceCallback(object sender, CallbackArgs args)
		{
			args.SetParameter(2, (uint)0);
			args.ReturnValue = 0;
		}

		/// <summary>
		/// Use to create an IOleServiceProvider with the basic services required by
		/// MS.VS.Shell.Package.SetSite() base implementation
		/// </summary>
		/// <returns></returns>
		public static OleServiceProvider CreateOleServiceProviderWithBasicServices()
		{
			// Create the service provider
			OleServiceProvider serviceProvider = new OleServiceProvider();

			// Add IProfferService
			// Create the type only once, then create as many instances as required.
			if (profferServiceFactory == null)
			{
				profferServiceFactory = new GenericMockFactory("MockProfferService", new Type[] { typeof(IProfferService) });
			}
			BaseMock mockObject = profferServiceFactory.GetInstance();
			mockObject.AddMethodCallback(string.Format(CultureInfo.InvariantCulture, "{0}.{1}", typeof(IProfferService).FullName, "ProfferService"),
                                         new EventHandler<CallbackArgs>(ProfferServiceCallback));
			serviceProvider.AddService(typeof(SProfferService), mockObject, false);

			// Add IUIHostLocale
			if (hostLocaleFactory == null)
			{
				hostLocaleFactory = new GenericMockFactory("MockUiHostLocale", new Type[] { typeof(IUIHostLocale), typeof(IUIHostLocale2) });
			}
			mockObject = hostLocaleFactory.GetInstance();
			// Set the return value to 0 (S_OK) and the out parameter to 1033 (enu).
			mockObject.AddMethodReturnValues(string.Format(CultureInfo.InvariantCulture,
                                                      "{0}.{1}",
                                                      typeof(IUIHostLocale).FullName,
                                                      "GetUILocale"), 
                                             new object[] { 0, (uint)1033 });
			serviceProvider.AddService(typeof(SUIHostLocale), mockObject, false);

			// Add IVsResourceManager
			if (resourceManagerFactory == null)
			{
				resourceManagerFactory = new GenericMockFactory("MockResourceManager", new Type[] { typeof(IVsResourceManager) });
			}
			mockObject = resourceManagerFactory.GetInstance();
			mockObject.AddMethodReturnValues(string.Format(CultureInfo.InvariantCulture,
                                                      "{0}.{1}",
                                                      typeof(IVsResourceManager).FullName,
                                                      "LoadResourceString"), 
                                             new object[] { 0, Guid.Empty, 0, null, "Mock Localized String" });
			serviceProvider.AddService(typeof(SVsResourceManager), mockObject, false);
			
			return serviceProvider;
		}

		#endregion

        #region IServiceProvider Members
        public object GetService(Type serviceType)
        {
            if (typeof(IOleServiceProvider) == serviceType)
                return this;
            if ((null == services) || (!services.ContainsKey(serviceType.GUID)))
                return null;
            return services[serviceType.GUID].service;
        }
        #endregion

        #region IOleServiceProvider Members

        public int QueryService(ref Guid guidService, ref Guid riid, out IntPtr ppvObject)
		{
			ppvObject = (IntPtr)0;
			int hr = VSConstants.S_OK;

			ServiceInstance serviceInstance = null;

			if (services != null && services.ContainsKey(guidService))
			{
				serviceInstance = services[guidService];				
			}

			if (serviceInstance == null)
			{
				return VSConstants.E_NOINTERFACE;
			}
			
			// Now check to see if the user asked for an IID other than
			// IUnknown.  If so, we must do another QI.
			//
			if (riid.Equals(VSConstants.IID_IUnknown))
			{
				ppvObject = Marshal.GetIUnknownForObject(serviceInstance.service);
			}
			else
			{
				IntPtr pUnk = IntPtr.Zero;
				try
				{
					pUnk = Marshal.GetIUnknownForObject(serviceInstance.service);
					hr = Marshal.QueryInterface(pUnk, ref riid, out ppvObject);
				}
				finally
				{
					if (pUnk != IntPtr.Zero)
					{
						Marshal.Release(pUnk);
					}
				}
			}

			return hr;
		}

		#endregion

		#region Dispose		

		/// <summary>
		/// The IDispose interface Dispose method for disposing the object determinastically.
		/// </summary>
		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		#endregion

		/// <summary>
		/// Adds the given service to the service container.
		/// </summary>
		/// <param name="serviceType">The type of the service to add.</param>
		/// <param name="serviceInstance">An instance of the service.</param>
		/// <param name="shouldDisposeServiceInstance">true if the Dipose of the service provider is allowed to dispose the sevice instance.</param>
		public void AddService(Type serviceType, object serviceInstance, bool shouldDisposeServiceInstance)
		{
			if (serviceType == null)
			{
				throw new ArgumentNullException("serviceType");
			}

			if (serviceInstance == null)
			{
				throw new ArgumentNullException("serviceInstance");
			}

			if (services == null)
			{
				services = new Dictionary<Guid, ServiceInstance>();
			}

			// Disallow the addition of duplicate services.
			if (services.ContainsKey(serviceType.GUID))
			{
				throw new InvalidOperationException();
			}

			// Add the service to the list
			services.Add(serviceType.GUID, new ServiceInstance(serviceInstance, shouldDisposeServiceInstance));
		}

		/// <devdoc>
		/// Removes the given service type from the service container.
		/// </devdoc>
		public void RemoveService(Type serviceType)
		{
			if (serviceType == null)
			{
				throw new ArgumentNullException("serviceType");
			}

			if (services.ContainsKey(serviceType.GUID))
			{
				services.Remove(serviceType.GUID);
			}			
		}

		#region helper methods
		/// <summary>
		/// The method that does the cleanup.
		/// </summary>
		/// <param name="disposing"></param>
		protected virtual void Dispose(bool disposing)
		{
			// Everybody can go here.
			if (!this.isDisposed)
			{
				// Synchronize calls to the Dispose simulteniously.
				lock (Mutex)
				{
					if (disposing)
					{
						// Remove all our services
						if (services != null)
						{
							while (services.Count > 0)
							{
								IEnumerator enumarator = services.Keys.GetEnumerator();
								enumarator.MoveNext();
								Guid guid = (Guid)enumarator.Current;
								this.RemoveService(guid);
							}
							services.Clear();
							services = null;
						}
					}

					this.isDisposed = true;
				}
			}
		}

		private void RemoveService(Guid guid)
		{
			if (this.services != null)
			{
				ServiceInstance serviceInstance = this.services[guid];
				if (serviceInstance != null)
				{
					services.Remove(guid);
					if (serviceInstance.shouldDispose && serviceInstance.service is IDisposable)
					{
						((IDisposable)(serviceInstance.service)).Dispose();
					}
				}
			}
		}
		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\GenericMockFactory.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Reflection.Emit;

namespace Microsoft.VsSDK.UnitTestLibrary
{
    /// <summary>
    /// This class creates Mock object classes implementing specific interfaces.
    /// </summary>
    public class GenericMockFactory
    {
        private static AssemblyBuilder dynamicAssembly;
        private static ModuleBuilder dynamicModule;
        private static Dictionary<String, Type> cachedTypes;

        private Type generatedType;
        private string className;
        private Type[] interfaces;

        // Static constructor used to initilize the static variables.
        [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static GenericMockFactory()
        {
            AppDomain domain = System.Threading.Thread.GetDomain();
            AssemblyName assemblyName = new AssemblyName("MockFactoryAssembly");
            dynamicAssembly = domain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
            dynamicModule = dynamicAssembly.DefineDynamicModule("MockFactoryModule", "MockFactoryAssembly.dll", true);
            cachedTypes = new Dictionary<String, Type>();
        }

        static public void Save()
        {
            dynamicAssembly.Save("MockFactoryAssembly.dll");
        }

        /// <summary>
        /// Creates an instance of the factory for a specific class.
        /// </summary>
        /// <param name="className">The name of the class that this factory will create.</param>
        /// <param name="interfaces">The interfaces implemented by the generated class.</param>
        public GenericMockFactory(string className, Type[] interfaces)
        {
            // Initialize the instance's variables.
            this.className = className;
            this.interfaces = interfaces;
        }

        /// <summary>
        /// This is similar to GetGeneratedType, but instead of returning the Type
        /// it returns an instance of that type
        /// </summary>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public BaseMock GetInstance()
        {
            return (BaseMock)Activator.CreateInstance(GetGeneratedType());
        }

        /// <summary>
        /// Create a new class type dynamicly.
        /// The type will be derived from BaseMock.
        /// </summary>
        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate")]
        public Type GetGeneratedType()
        {
            // Check if we have created this type before;
            if (null == generatedType)
                generatedType = CreateType(className, interfaces);

            return generatedType;
        }

        private static void AddTypeToList(Type t, List<Type> typeList)
        {
            if (typeList.Contains(t))
            {
                return;
            }
            typeList.Add(t);
            foreach (Type i in t.GetInterfaces())
            {
                AddTypeToList(i, typeList);
            }
        }

        /// <summary>
        /// Creates a new class with a given name derived from BaseMock and implementing 
        /// a specific set of interfaces.
        /// </summary>
        /// <param name="className">The name of the class to create.</param>
        /// <param name="interfaces">The interfaces implemented by the generated class.</param>
        /// <returns></returns>
        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public static Type CreateType(string className, Type[] interfaces)
        {
            if (cachedTypes.ContainsKey(GetHashForInterfaces(interfaces)))
            {
                return cachedTypes[GetHashForInterfaces(interfaces)];
            }

            // Get some information about the base type
            Type baseType = typeof(BaseMock);

            // Methods and fields about the callbacks
            FieldInfo callbackFieldInfo = baseType.GetField("callbacks", BindingFlags.Instance | BindingFlags.NonPublic);
            MethodInfo callbacksContainsKey = callbackFieldInfo.FieldType.GetMethod("ContainsKey");
            MethodInfo callbackGetItem = callbackFieldInfo.FieldType.GetMethod("get_Item");
            ConstructorInfo callbackArgsCtr = typeof(CallbackArgs).GetConstructor(new Type[] { typeof(object[]) });
            MethodInfo callbackInvoke = typeof(EventHandler<CallbackArgs>).GetMethod("Invoke");
            MethodInfo callbackArgsGetParam = typeof(CallbackArgs).GetMethod("GetParameter");
            MethodInfo callbackArgsGetRetVal = typeof(CallbackArgs).GetMethod("get_ReturnValue");

            // Utility functions exposed by the base class
            MethodInfo incrementCallCount = baseType.GetMethod("IncrementFunctionCalls", BindingFlags.Instance | BindingFlags.NonPublic);

            // Methods and fields about the return values.
            FieldInfo retValuesFieldInfo = baseType.GetField("returnValues", BindingFlags.Instance | BindingFlags.NonPublic);
            MethodInfo retValuesContainsKey = retValuesFieldInfo.FieldType.GetMethod("ContainsKey");
            MethodInfo retValuesGetItem = retValuesFieldInfo.FieldType.GetMethod("get_Item");
            MethodInfo arrayGetLength = typeof(object[]).GetMethod("get_Length");

            // Build the list of the interfaces to implement.
            // Note that if we have a COM interface I2 that derives from the COM interface I1
            // we have to implement also I1, even if I2 implements all the methods of the base
            // interface.
            List<Type> typeList = new List<Type>();
            foreach (Type t in interfaces)
            {
                AddTypeToList(t, typeList);
            }

            // Create the type builder for this type; the new type will be a class derived
            // from the BaseType class.
            TypeBuilder newType = dynamicModule.DefineType(className, TypeAttributes.Class | TypeAttributes.Public, baseType);

            // Set the ComVisible attribute for the type. This will enable unit testing of interop scenarios where the
            // mock objetcs are supposed to implement IDispatch.
            ConstructorInfo comVisibleAttributeCtr = typeof(System.Runtime.InteropServices.ComVisibleAttribute).GetConstructor(new Type[] { typeof(bool) });
            CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(comVisibleAttributeCtr, new object[] { true });
            newType.SetCustomAttribute(customAttribute);

            foreach (Type t in typeList)
            {
                // Add the informations about the implemented interface. We don't check if the type
                // is an interface because the check is performed by AddInterfaceImplementation.
                newType.AddInterfaceImplementation(t);

                // Now we have to create the interface's methods. 
                foreach (MethodInfo method in t.GetMethods())
                {
                    // Build the full name of this method; this name will also be used as index
                    // in the Disctionary of callbaks.
                    string fullMethodName = string.Format(System.Globalization.CultureInfo.InvariantCulture,
                                                          "{0}.{1}", t.FullName, method.Name);
                    Trace.WriteLine("Building method: " + fullMethodName);

                    // Get the information about parameters.
                    ParameterInfo[] parameters = method.GetParameters();
                    // Now build the array with the type of the parameters.
                    Type[] paramTypes = new Type[parameters.Length];
                    for (int i = 0; i < parameters.Length; ++i)
                    {
                        paramTypes[i] = parameters[i].ParameterType;
                    }

                    // Create a the method build with the informations about the parameter's type
                    // and the return value.
                    MethodBuilder methodBuilder = newType.DefineMethod(
                                                    fullMethodName,
                                                    MethodAttributes.Virtual | MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.NewSlot | MethodAttributes.HideBySig,
                                                    method.ReturnType,
                                                    paramTypes);
                    methodBuilder.SetImplementationFlags(MethodImplAttributes.IL | MethodImplAttributes.Managed);

                    // Add all the attributes to the parameters (e.g. 'out', 'in', ...).
                    foreach (ParameterInfo param in parameters)
                    {
                        methodBuilder.DefineParameter(param.Position + 1, param.Attributes, param.Name);
                    }


                    // Now we have to add the code for the method.
                    // The implementation of the method is simple: it will check if there is a
                    // callback defined for it; if there is no callback then it will return,
                    // otherwise it will call the event handler and return.
                    ILGenerator methodCode = methodBuilder.GetILGenerator();

                    // Define the local variables.
                    LocalBuilder paramValues = methodCode.DeclareLocal(typeof(object[]));
                    LocalBuilder callbackArgs = methodCode.DeclareLocal(typeof(CallbackArgs));
                    LocalBuilder retValuesArray = methodCode.DeclareLocal(typeof(object[]));

                    // Define the labels needed inside the method.
                    Label callbackNotDefined = methodCode.DefineLabel();
                    Label retValuesNotDefined = methodCode.DefineLabel();

                    // The first operation is to increment the counter for the calls to this function
                    methodCode.Emit(OpCodes.Ldarg_0);                   // this
                    methodCode.Emit(OpCodes.Ldstr, fullMethodName);     // Method name
                    methodCode.Emit(OpCodes.Call, incrementCallCount);  // Call the function
                    // IncrementFunctionCalls is a void function, so now the stack is clear.

                    // Check if there is a callback defined for this method
                    methodCode.Emit(OpCodes.Ldarg_0);				   // "this"
                    methodCode.Emit(OpCodes.Ldfld, callbackFieldInfo);  // get the dictionary of callbacks
                    methodCode.Emit(OpCodes.Ldstr, fullMethodName);	 // name of this method.
                    methodCode.Emit(OpCodes.Callvirt, callbacksContainsKey);

                    // Check the return code
                    methodCode.Emit(OpCodes.Ldc_I4_0);
                    methodCode.Emit(OpCodes.Beq, callbackNotDefined);

                    // Here the callback function is defined

                    // Create an array of objects with the values of the parameters.
                    methodCode.Emit(OpCodes.Ldc_I4_S, parameters.Length);
                    methodCode.Emit(OpCodes.Newarr, typeof(object));
                    methodCode.Emit(OpCodes.Stloc, paramValues);

                    // Set the values of the parameters.
                    foreach (ParameterInfo paramInfo in parameters)
                    {
                        methodCode.Emit(OpCodes.Ldloc, paramValues);
                        methodCode.Emit(OpCodes.Ldc_I4, paramInfo.Position);

                        methodCode.Emit(OpCodes.Ldarg, paramInfo.Position + 1);   // Parameter 0 is "this"
                        // If this parameter is a reference we have to get the referenced value.
                        if (paramInfo.ParameterType.IsByRef)
                        {
                            Type elemType = paramInfo.ParameterType.GetElementType();
                            if (elemType.IsValueType)
                            {
                                if (elemType.IsPrimitive)
                                {
                                    // Here we assume that element types are I4, but actually we should
                                    // consider I1,...,I8
                                    methodCode.Emit(OpCodes.Ldind_I4);
                                }
                                else
                                {
                                    methodCode.Emit(OpCodes.Ldobj, elemType);
                                }
                                methodCode.Emit(OpCodes.Box, elemType);
                            }
                            else
                            {
                                methodCode.Emit(OpCodes.Ldind_Ref);
                            }
                        }
                        if (paramInfo.ParameterType.IsValueType)
                        {
                            methodCode.Emit(OpCodes.Box, paramInfo.ParameterType);
                        }

                        methodCode.Emit(OpCodes.Stelem_Ref);
                    }

                    // Create the CallbackArgs variable using the array of parameter's values
                    methodCode.Emit(OpCodes.Ldloc, paramValues);
                    methodCode.Emit(OpCodes.Newobj, callbackArgsCtr);
                    methodCode.Emit(OpCodes.Stloc, callbackArgs);

                    // Get the callback function.
                    methodCode.Emit(OpCodes.Ldarg_0);
                    methodCode.Emit(OpCodes.Ldfld, callbackFieldInfo);
                    methodCode.Emit(OpCodes.Ldstr, fullMethodName);
                    methodCode.Emit(OpCodes.Callvirt, callbackGetItem);

                    // Keep the callback function on the stack as "this" pointer and
                    // add the other parameters.
                    methodCode.Emit(OpCodes.Ldarg_0);			   // Use this object as sender.
                    methodCode.Emit(OpCodes.Ldloc, callbackArgs);   // The arguments to the callback.
                    methodCode.Emit(OpCodes.Callvirt, callbackInvoke);

                    // After calling the callback we should set the values of the out parameters.
                    foreach (ParameterInfo param in parameters)
                    {
                        if (!param.ParameterType.IsByRef)
                        {
                            continue;
                        }
                        methodCode.Emit(OpCodes.Ldarg, param.Position + 1);
                        methodCode.Emit(OpCodes.Ldloc, callbackArgs);
                        methodCode.Emit(OpCodes.Ldc_I4, param.Position);
                        methodCode.Emit(OpCodes.Callvirt, callbackArgsGetParam);
                        if (param.ParameterType.GetElementType().IsValueType)
                        {
                            methodCode.Emit(OpCodes.Unbox_Any, param.ParameterType.GetElementType());
                            if (param.ParameterType.GetElementType().IsPrimitive)
                            {
                                // Right now we assume this is I4, but actually we should check
                                // for I1,...,I8
                                methodCode.Emit(OpCodes.Stind_I4);
                            }
                            else
                            {
                                methodCode.Emit(OpCodes.Stobj, param.ParameterType.GetElementType());
                            }
                        }
                        else
                        {
                            methodCode.Emit(OpCodes.Stind_Ref);
                        }
                    }

                    // The last step is to set the return value
                    if (method.ReturnType != typeof(void))
                    {
                        // Get the return code from the callback arguments
                        methodCode.Emit(OpCodes.Ldloc, callbackArgs);
                        methodCode.Emit(OpCodes.Callvirt, callbackArgsGetRetVal);
                        // If the return code of this method is object, no conversion is needed,
                        // otherwise we have to cast this value to the right type.
                        if (method.ReturnType != typeof(object))
                        {
                            // Here we have to switch on three case: a value type that needs unboxing,
                            // strings and any other type.
                            if (method.ReturnType.IsValueType)
                            {
                                // Unbox the type; notice that this will throw if the object is null
                                // or there is no conversion to the requested type.
                                methodCode.Emit(OpCodes.Unbox_Any, method.ReturnType);
                            }
                            else
                            {
                                // In all the other cases call the cast function.
                                methodCode.Emit(OpCodes.Castclass, method.ReturnType);
                            }
                        }
                    }
                    // Now the return value (if needed) is on the stack, so we can exit.
                    methodCode.Emit(OpCodes.Ret);

                    // ============================================================================
                    // Here we add the code for the case the callback is not defined.
                    methodCode.MarkLabel(callbackNotDefined);

                    // Check if there is an array of return values for this method.
                    // Check if there is a callback defined for this method
                    methodCode.Emit(OpCodes.Ldarg_0);				   // "this"
                    methodCode.Emit(OpCodes.Ldfld, retValuesFieldInfo); // get the dictionary of return values
                    methodCode.Emit(OpCodes.Ldstr, fullMethodName);	 // name of this method.
                    methodCode.Emit(OpCodes.Callvirt, retValuesContainsKey);

                    // Check the return code
                    methodCode.Emit(OpCodes.Ldc_I4_0);
                    methodCode.Emit(OpCodes.Beq, retValuesNotDefined);

                    // There is an entry for this method in the dictionary of return values.
                    // Get the array of values.
                    methodCode.Emit(OpCodes.Ldarg_0);
                    methodCode.Emit(OpCodes.Ldfld, retValuesFieldInfo);
                    methodCode.Emit(OpCodes.Ldstr, fullMethodName);
                    methodCode.Emit(OpCodes.Callvirt, retValuesGetItem);
                    methodCode.Emit(OpCodes.Stloc, retValuesArray);

                    // The array of return values contains in the first element the return value,
                    // then a value to assign to each parameter. The first step is to set the value
                    // of the ByRef parameters.
                    int offset = (method.ReturnType == typeof(void)) ? 0 : 1;
                    foreach (ParameterInfo paramInfo in parameters)
                    {
                        // If this parameter is not ByRef we can skip it.
                        if (!paramInfo.ParameterType.IsByRef)
                            continue;

                        // Put the parameter on the stack (add 1 because 0 is "this")
                        methodCode.Emit(OpCodes.Ldarg, paramInfo.Position + 1);

                        // Get the element in the array of values.
                        // Notice that we want an exception here if the element is not present.
                        methodCode.Emit(OpCodes.Ldloc, retValuesArray);
                        methodCode.Emit(OpCodes.Ldc_I4, paramInfo.Position + offset);
                        methodCode.Emit(OpCodes.Ldelem_Ref);

                        // Now the element is the first on the stack, so we can convert it to
                        // the type of the parameter.
                        Type elemType = paramInfo.ParameterType.GetElementType();
                        if (elemType.IsValueType)
                        {
                            methodCode.Emit(OpCodes.Unbox_Any, elemType);
                            if (elemType.IsPrimitive)
                            {
                                // As always we assume this is I4, but we should check for I1,...,I8
                                methodCode.Emit(OpCodes.Stind_I4);
                            }
                            else
                            {
                                methodCode.Emit(OpCodes.Stobj, elemType);
                            }
                        }
                        else
                        {
                            methodCode.Emit(OpCodes.Stind_Ref);
                        }
                    }

                    // Now that the parameters are done we have to set the return value.
                    if (method.ReturnType != typeof(void))
                    {
                        // Get the first element of the array
                        methodCode.Emit(OpCodes.Ldloc, retValuesArray);
                        methodCode.Emit(OpCodes.Ldc_I4_0);
                        methodCode.Emit(OpCodes.Ldelem_Ref);

                        // If the return type is object we don't need any conversion.
                        if (method.ReturnType != typeof(object))
                        {
                            if (method.ReturnType.IsValueType)
                            {
                                methodCode.Emit(OpCodes.Unbox_Any, method.ReturnType);
                            }
                            else
                            {
                                methodCode.Emit(OpCodes.Castclass, method.ReturnType);
                            }
                        }
                    }
                    methodCode.Emit(OpCodes.Ret);

                    // ============================================================================
                    // Here there is no return code defined and no callback, so we return a defaul
                    methodCode.MarkLabel(retValuesNotDefined);

                    // Simply return setting a return code if the method does not return void.
                    if (method.ReturnType != typeof(void))
                    {
                        // The first check should be if the return type is object because in this
                        // case it is assignable from any other type and this can cause unexpected
                        // results.
                        if (method.ReturnType == typeof(object))
                        {
                            methodCode.Emit(OpCodes.Ldnull);
                        }
                        else if (method.ReturnType.IsAssignableFrom(typeof(int)))
                        {
                            methodCode.Emit(OpCodes.Ldc_I4_0);
                        }
                        else if (method.ReturnType.IsValueType)
                        {
                            // Return a not initialized instance of the value type.
                            LocalBuilder localRetVal = methodCode.DeclareLocal(method.ReturnType);
                            methodCode.Emit(OpCodes.Ldloc, localRetVal);
                        }
                        else
                        {
                            methodCode.Emit(OpCodes.Ldnull);
                        }
                    }
                    methodCode.Emit(OpCodes.Ret);

                    // Now that we have the method implementation, let's declare it as the
                    // override of the interface's method.
                    newType.DefineMethodOverride(methodBuilder, method);
                }

            }
            cachedTypes.Add(GetHashForInterfaces(interfaces), newType);
            return newType.CreateType();
        }

        private static String GetHashForInterfaces(Type[] interfaces)
        {
            SortedList<String, Guid> sortedInterfaces = new SortedList<String, Guid>();
            foreach (Type type in interfaces)
            {
                sortedInterfaces.Add(type.GUID.ToString(), type.GUID);
            }

            String hash = "";
            foreach (String guid in sortedInterfaces.Keys)
            {
                hash = hash + guid;
            }
            return hash;
        }

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\TextWriterMock.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.IO;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Reflection;

namespace Microsoft.VsSDK.UnitTestLibrary
{

    public class TextWriterMock : TextWriter
    {
        public TextWriterMock(IFormatProvider formatProvider)
            : base(formatProvider)
        {
        }

        public override Encoding Encoding
        {
            get 
            { 
                return null; 
            }
        }

        public override void Write(string value)
        {
            return;
        }

        public override void WriteLine(string value)
        {
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\RegistrationKeyMock.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.VsSDK.UnitTestLibrary
{
    
    public class RegistrationKeyMock : RegistrationAttribute.Key
    {
        private Hashtable _table = new Hashtable();

        /// <summary>
        /// Constructor
        /// </summary>
        public RegistrationKeyMock()
        {

        }

        /// <summary>
        /// Collection of keys that are added.
        /// </summary>
        public Hashtable Keys
        {
            get
            {
                return _table;
            }
        }

        /// <summary>
        /// Close the key
        /// </summary>
        public override void Close()
        {
            return;
        }

        /// <summary>
        /// Create a sub key under the key with name
        /// </summary>
        /// <param name="name">name of the sub key</param>
        /// <returns>Key instance</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public override RegistrationAttribute.Key CreateSubkey(string name)
        {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        /// <summary>
        /// Set the reg key value
        /// </summary>
        /// <param name="valueName">name of the value</param>
        /// <param name="value">value</param>
        [SuppressMessage("Microsoft.Performance", "CA1807:AvoidUnnecessaryStringCreation")]
        [SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods")]
        public override void SetValue(string valueName, object value)
        {
            string val = value.ToString().ToUpperInvariant();
            string name = valueName.ToUpperInvariant();
            if (!_table.Contains(name))
                _table.Add(name, val);
            else
                _table[name] = val;
        }

        internal void RemoveValue(string valueName)
        {
            string name = valueName.ToUpperInvariant();
            if (_table.Contains(name))
                _table.Remove(name);
        }

        internal bool IsEmpty()
        {
            return _table.Count == 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Common\Source\CSharp\UnitTest\RegistrationContextMock.cs ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VsSDK.UnitTestLibrary;
using Microsoft.VisualStudio.Shell;
using System.Collections;
using System.Reflection;
using System.Diagnostics.CodeAnalysis;

namespace Microsoft.VsSDK.UnitTestLibrary
{
    
    public class BaseRegistrationContextMock : RegistrationAttribute.RegistrationContext
    {

        private Hashtable _keys = new Hashtable();
        
        /// <summary>
        /// Constructor
        /// </summary>
        public BaseRegistrationContextMock()
        {

        }

        /// <summary>
        /// THe hash table containing all the values that are being added.
        /// </summary>
        public Hashtable RegistryEntries
        {
            get
            {
                return _keys;
            }
        }

        /// <summary>
        /// Returns the code base to be used for the context
        /// </summary>
        public override string CodeBase
        {
            get { return Assembly.GetExecutingAssembly().EscapedCodeBase; }
        }

        /// <summary>
        /// Returns the component path
        /// </summary>
         public override string ComponentPath
        {
            get { return Path.GetDirectoryName(Assembly.GetCallingAssembly().EscapedCodeBase); }
        }

        /// <summary>
        /// Returns the component type
        /// </summary>
        public override Type ComponentType
        {
            get { return this.GetType(); }
        }

        /// <summary>
        /// Returns the root folder of the target host
        /// </summary>
        public override string RootFolder
        {
            [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
            get { throw new NotImplementedException("The method or operation is not implemented."); }
        }

        /// <summary>
        /// Creates the key
        /// </summary>
        /// <param name="name">name of the key</param>
        /// <returns></returns>
        [SuppressMessage("Microsoft.Performance", "CA1807:AvoidUnnecessaryStringCreation")]
        [SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods")]
        public override RegistrationAttribute.Key CreateKey(string name)
        {
            string keyName = name.ToUpperInvariant();
            if (!_keys.Contains(name))
            {
                RegistrationKeyMock key = new RegistrationKeyMock();
                _keys.Add(keyName, key);
            }
            return (RegistrationAttribute.Key)_keys[keyName];
        }

        /// <summary>
        /// Sets the escape path
        /// </summary>
        /// <param name="str">escape string</param>
        /// <returns>output after applying the escape string</returns>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public override string EscapePath(string str)
        {
            throw new NotImplementedException("The method or operation is not implemented.");
        }

        /// <summary>
        /// Inprocserver path
        /// </summary>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public override string InprocServerPath
        {
            get { throw new NotImplementedException("The method or operation is not implemented."); }
        }

        /// <summary>
        /// Logger if looging is needed.
        /// </summary>
        public override TextWriter Log
        {
            get 
            { 
                return new TextWriterMock(null); 
            }
        }

        /// <summary>
        /// Registration method to use
        /// </summary>
        [SuppressMessage("Microsoft.Globalization", "CA1303:DoNotPassLiteralsAsLocalizedParameters")]
        public override RegistrationMethod RegistrationMethod
        {
            get { throw new NotImplementedException("The method or operation is not implemented."); }
        }


        [SuppressMessage("Microsoft.Performance", "CA1807:AvoidUnnecessaryStringCreation")]
        [SuppressMessage("Microsoft.Design", "CA1062:ValidateArgumentsOfPublicMethods")]
        public override void RemoveKey(string name)
        {
            foreach (string keyName in _keys.Keys.Cast<string>().ToArray()) //Copy to an array since we'll be modifying the underlying Hashtable holding the keys.
            {
                if (keyName.StartsWith(name.ToUpperInvariant()))
                    _keys.Remove(keyName);
            }
            return;
        }

        public override void RemoveKeyIfEmpty(string name)
        {
            string upperKeyName = name.ToUpperInvariant();
            if (((RegistrationKeyMock)_keys[upperKeyName]).IsEmpty())
            {
                RemoveKey(upperKeyName);
            }
        }

        public override void RemoveValue(string keyname, string valuename)
        {
            string upperKeyName = keyname.ToUpperInvariant();
            ((RegistrationKeyMock)_keys[upperKeyName]).RemoveValue(valuename);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\Editor.Designer.cs ===
namespace %ProjectNamespace%.%ProjectClass%
{
    partial class MyEditor
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.richTextBoxCtrl = new %ProjectNamespace%.%ProjectClass%.EditorTextBox();
            this.SuspendLayout();
            // 
            // richTextBoxCtrl
            // 
            this.richTextBoxCtrl.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.richTextBoxCtrl.Location = new System.Drawing.Point(0, 0);
            this.richTextBoxCtrl.Name = "richTextBoxCtrl";
            this.richTextBoxCtrl.Size = new System.Drawing.Size(150, 150);
            this.richTextBoxCtrl.TabIndex = 0;
            this.richTextBoxCtrl.MouseEnter += new System.EventHandler(this.richTextBoxCtrl_MouseEnter);
            this.richTextBoxCtrl.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.richTextBoxCtrl_KeyPress);
            this.richTextBoxCtrl.KeyDown += new System.Windows.Forms.KeyEventHandler(this.richTextBoxCtrl_KeyDown);
            // 
            // MyEditor
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.richTextBoxCtrl);
            this.Name = "MyEditor";
            this.ResumeLayout(false);

        }

        #endregion

        private EditorTextBox richTextBoxCtrl;


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\EditorTextBox.cs ===
using System;
using System.Windows.Forms;
using System.Security.Permissions;

namespace %ProjectNamespace%.%ProjectClass%
{
    public partial class EditorTextBox : RichTextBox
    {
        private bool m_FilterMouseClickMessages;

        public bool FilterMouseClickMessages
        {
            get { return m_FilterMouseClickMessages; }
            set { m_FilterMouseClickMessages = value; }
        }

        public EditorTextBox()
        {
            InitializeComponent();
        }

        // Override WndProc so that we can ignore the mouse clicks when macro recording
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m)
        {
            switch (m.Msg)
            {
                case NativeMethods.WM_LBUTTONDOWN:
                case NativeMethods.WM_RBUTTONDOWN:
                case NativeMethods.WM_MBUTTONDOWN:
                case NativeMethods.WM_LBUTTONDBLCLK:
                    if (m_FilterMouseClickMessages)
                    {
                        Focus();
                        return;
                    }
                    break;
            }

            base.WndProc(ref m);
        }

        private void richTextBoxCtrl_MouseRecording(object sender, EventArgs e)
        {
            SetCursor(m_FilterMouseClickMessages);
        }

        private void richTextBoxCtrl_MouseLeave(object sender, EventArgs e)
        {
            if(m_FilterMouseClickMessages)
                SetCursor(!m_FilterMouseClickMessages);
        }

        private void SetCursor(bool cursorNo)
        {
            Cursor = cursorNo ? Cursors.No : Cursors.Default;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\EditorTextBox.Designer.cs ===
namespace %ProjectNamespace%.%ProjectClass%
{
    partial class EditorTextBox
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            // 
            // EditorTextBox
            // 
            this.MouseEnter += new System.EventHandler(this.richTextBoxCtrl_MouseRecording);
            this.MouseUp += new System.Windows.Forms.MouseEventHandler(this.richTextBoxCtrl_MouseRecording);
            this.MouseLeave += new System.EventHandler(this.richTextBoxCtrl_MouseLeave);
            this.MouseDown += new System.Windows.Forms.MouseEventHandler(this.richTextBoxCtrl_MouseRecording);
            this.ResumeLayout(false);

        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\AssemblyInfo.cs ===
using System;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("%PackageName%")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("%CompanyName%")]
[assembly: AssemblyProduct("%PackageName%")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]   
[assembly: ComVisible(false)]     
[assembly: CLSCompliant(false)]
[assembly: NeutralResourcesLanguage("en-US")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

%hasIntegrationTestProjectsStart%[assembly: InternalsVisibleTo("%ProjectName%_IntegrationTests, PublicKey=%IntegrationTestPublicKey%")]%hasIntegrationTestProjectsEnd%
%hasUnitTestProjectsStart%[assembly: InternalsVisibleTo("%ProjectName%_UnitTests, PublicKey=%UnitTestPublicKey%")]%hasUnitTestProjectsEnd%
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\EditorFactory.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Shell;

using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;

namespace %ProjectNamespace%.%ProjectClass%
{
    /// <summary>
    /// Factory for creating our editor object. Extends from the IVsEditoryFactory interface
    /// </summary>
    [Guid(GuidList.guid%ProjectClass%EditorFactoryString)]
    public sealed class EditorFactory : IVsEditorFactory, IDisposable
    {
        private %ProjectClass%Package editorPackage;
        private ServiceProvider vsServiceProvider;


        public EditorFactory(%ProjectClass%Package package)
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "Entering {0} constructor", this.ToString()));

            this.editorPackage = package;
        }

        /// <summary>
        /// Since we create a ServiceProvider which implements IDisposable we
        /// also need to implement IDisposable to make sure that the ServiceProvider's
        /// Dispose method gets called.
        /// </summary>
        public void Dispose()
        {
            if (vsServiceProvider != null)
            {
                vsServiceProvider.Dispose();
            }
        }

        #region IVsEditorFactory Members

        /// <summary>
        /// Used for initialization of the editor in the environment
        /// </summary>
        /// <param name="psp">pointer to the service provider. Can be used to obtain instances of other interfaces
        /// </param>
        /// <returns></returns>
        public int SetSite(Microsoft.VisualStudio.OLE.Interop.IServiceProvider psp)
        {
            vsServiceProvider = new ServiceProvider(psp);
            return VSConstants.S_OK;
        }

        public object GetService(Type serviceType)
        {
            return vsServiceProvider.GetService(serviceType);
        }

        // This method is called by the Environment (inside IVsUIShellOpenDocument::
        // OpenStandardEditor and OpenSpecificEditor) to map a LOGICAL view to a 
        // PHYSICAL view. A LOGICAL view identifies the purpose of the view that is
        // desired (e.g. a view appropriate for Debugging [LOGVIEWID_Debugging], or a 
        // view appropriate for text view manipulation as by navigating to a find
        // result [LOGVIEWID_TextView]). A PHYSICAL view identifies an actual type 
        // of view implementation that an IVsEditorFactory can create. 
        //
        // NOTE: Physical views are identified by a string of your choice with the 
        // one constraint that the default/primary physical view for an editor  
        // *MUST* use a NULL string as its physical view name (*pbstrPhysicalView = NULL).
        //
        // NOTE: It is essential that the implementation of MapLogicalView properly
        // validates that the LogicalView desired is actually supported by the editor.
        // If an unsupported LogicalView is requested then E_NOTIMPL must be returned.
        //
        // NOTE: The special Logical Views supported by an Editor Factory must also 
        // be registered in the local registry hive. LOGVIEWID_Primary is implicitly 
        // supported by all editor types and does not need to be registered.
        // For example, an editor that supports a ViewCode/ViewDesigner scenario
        // might register something like the following:
        //        HKLM\Software\Microsoft\VisualStudio\<version>\Editors\
        //            {...guidEditor...}\
        //                LogicalViews\
        //                    {...LOGVIEWID_TextView...} = s ''
        //                    {...LOGVIEWID_Code...} = s ''
        //                    {...LOGVIEWID_Debugging...} = s ''
        //                    {...LOGVIEWID_Designer...} = s 'Form'
        //
        public int MapLogicalView(ref Guid rguidLogicalView, out string pbstrPhysicalView)
        {
            pbstrPhysicalView = null;    // initialize out parameter

            // we support only a single physical view
            if (VSConstants.LOGVIEWID_Primary == rguidLogicalView)
                return VSConstants.S_OK;        // primary view uses NULL as pbstrPhysicalView
            else
                return VSConstants.E_NOTIMPL;   // you must return E_NOTIMPL for any unrecognized rguidLogicalView values
        }

        public int Close()
        {
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Used by the editor factory to create an editor instance. the environment first determines the 
        /// editor factory with the highest priority for opening the file and then calls 
        /// IVsEditorFactory.CreateEditorInstance. If the environment is unable to instantiate the document data 
        /// in that editor, it will find the editor with the next highest priority and attempt to so that same 
        /// thing. 
        /// NOTE: The priority of our editor is 32 as mentioned in the attributes on the package class.
        /// 
        /// Since our editor supports opening only a single view for an instance of the document data, if we 
        /// are requested to open document data that is already instantiated in another editor, or even our 
        /// editor, we return a value VS_E_INCOMPATIBLEDOCDATA.
        /// </summary>
        /// <param name="grfCreateDoc">Flags determining when to create the editor. Only open and silent flags 
        /// are valid
        /// </param>
        /// <param name="pszMkDocument">path to the file to be opened</param>
        /// <param name="pszPhysicalView">name of the physical view</param>
        /// <param name="pvHier">pointer to the IVsHierarchy interface</param>
        /// <param name="itemid">Item identifier of this editor instance</param>
        /// <param name="punkDocDataExisting">This parameter is used to determine if a document buffer 
        /// (DocData object) has already been created
        /// </param>
        /// <param name="ppunkDocView">Pointer to the IUnknown interface for the DocView object</param>
        /// <param name="ppunkDocData">Pointer to the IUnknown interface for the DocData object</param>
        /// <param name="pbstrEditorCaption">Caption mentioned by the editor for the doc window</param>
        /// <param name="pguidCmdUI">the Command UI Guid. Any UI element that is visible in the editor has 
        /// to use this GUID. This is specified in the .vsct file
        /// </param>
        /// <param name="pgrfCDW">Flags for CreateDocumentWindow</param>
        /// <returns></returns>
        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        public int CreateEditorInstance(
                        uint grfCreateDoc,
                        string pszMkDocument,
                        string pszPhysicalView,
                        IVsHierarchy pvHier,
                        uint itemid,
                        System.IntPtr punkDocDataExisting,
                        out System.IntPtr ppunkDocView,
                        out System.IntPtr ppunkDocData,
                        out string pbstrEditorCaption,
                        out Guid pguidCmdUI,
                        out int pgrfCDW)
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "Entering {0} CreateEditorInstace()", this.ToString()));

            // Initialize to null
            ppunkDocView = IntPtr.Zero;
            ppunkDocData = IntPtr.Zero;
            pguidCmdUI = GuidList.guid%ProjectClass%EditorFactory;
            pgrfCDW = 0;
            pbstrEditorCaption = null;

            // Validate inputs
            if ((grfCreateDoc & (VSConstants.CEF_OPENFILE | VSConstants.CEF_SILENT)) == 0)
            {
                return VSConstants.E_INVALIDARG;
            }
            if (punkDocDataExisting != IntPtr.Zero)
            {
                return VSConstants.VS_E_INCOMPATIBLEDOCDATA;
            }

            // Create the Document (editor)
            EditorPane NewEditor = new EditorPane(editorPackage);
            ppunkDocView = Marshal.GetIUnknownForObject(NewEditor);
            ppunkDocData = Marshal.GetIUnknownForObject(NewEditor);
            pbstrEditorCaption = "";
            return VSConstants.S_OK;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\Editor.cs ===
using System;
using System.Windows.Forms;
using System.Security.Permissions;
using System.Runtime.InteropServices;
using tom;

namespace %ProjectNamespace%.%ProjectClass%
{
    public partial class MyEditor : UserControl
    {
        private const int GetOleInterfaceCommandId = 1084;

        private string m_TextToRecord;
        private VSMacroRecorder m_Recorder;

        public MyEditor()
        {
            InitializeComponent();
            this.richTextBoxCtrl.WordWrap = false;
            this.richTextBoxCtrl.HideSelection = false;
            
            m_Recorder = new VSMacroRecorder(GuidList.guid%ProjectClass%EditorFactory);
        }

        public EditorTextBox RichTextBoxControl
        {
            get { return this.richTextBoxCtrl; }
        }

        #region Fields

        /// <summary>
        /// This value is used internally so that we know what to display on the status bar.
        /// NOTE: Setting this value will not actually change the insert/overwrite behavior
        /// of the editor, it is just used so that we can keep track of the state internally.
        /// </summary>
        private bool overstrike;
        public bool Overstrike
        {
            get
            {
                return this.overstrike;
            }
            set
            {
                this.overstrike = value;
            }
        }

        private ITextDocument textDocument;

        /// <summary>
        /// This property exposes the ITextDocument interface associated with
        /// our Rich Text editor.
        /// </summary>
        public ITextDocument TextDocument
        {
            [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
            get
            {
                if (null != textDocument)
                    return textDocument;

                // To get the IRichEditOle interface we need to call SendMessage, which
                // we imported from user32.dll
                object editOle = null;
                NativeMethods.SendMessage(richTextBoxCtrl.Handle,                // The rich text box handle
                                          GetOleInterfaceCommandId,   // The command ID for EM_GETOLEINTERFACE
                                          IntPtr.Zero,                // null
                                          out editOle                 // This will be set to the IRichEditOle interface
                                          );

                // Call GetIUnknownForObject with the IRichEditOle interface that we
                // just got so that we have an IntPtr to pass into QueryInterface
                IntPtr editOlePtr = IntPtr.Zero;
                editOlePtr = Marshal.GetIUnknownForObject(editOle);

                // Call QueryInterface to get the pointer to the ITextDocument
                IntPtr iTextDocument = IntPtr.Zero;
                Guid iTextDocumentGuid = typeof(ITextDocument).GUID;
                Marshal.QueryInterface(editOlePtr, ref iTextDocumentGuid, out iTextDocument);

                // We need to call Marshal.Release with the pointer that we got
                // from the GetIUnknownForObject call
                Marshal.Release(editOlePtr);

                // Call GetObjectForIUnknown passing in the pointer that was set
                // by QueryInterface and return it as an ITextDocument
                textDocument = Marshal.GetObjectForIUnknown(iTextDocument) as ITextDocument;
                return textDocument;
            }
        }

        /// <summary>
        /// This property will return the current ITextRange interface.
        /// </summary>
        public ITextRange TextRange
        {
            get
            {
                return this.TextDocument.Range(0, (int)tom.tomConstants.tomForward);
            }
        }

        /// <summary>
        /// This property will return the current ITextSelection interface.
        /// </summary>
        public ITextSelection TextSelection
        {
            get
            {
                return this.TextDocument.Selection;
            }
        }

        #endregion

        /// <summary>
        /// Returns the column number from the specified index
        /// </summary>
        /// <param name="index">index of the character</param>
        /// <returns>column number</returns>
        public int GetColumnFromIndex(int index)
        {
            //first get the index of the first char of the current line
            int currentLineIndex = richTextBoxCtrl.GetFirstCharIndexOfCurrentLine();
            return index - currentLineIndex;
        }

        /// <summary>
        /// Returns the index from the specified line and column number
        /// </summary>
        /// <param name="line">line number</param>
        /// <param name="column">column number</param>
        /// <returns>index</returns>
        public int GetIndexFromLineAndColumn(int line, int column)
        {
            if (line < 0)
                return -1;
            //first get the index of the first char of the specified line
            int firstCharLineIndex = richTextBoxCtrl.GetFirstCharIndexFromLine(line);
            if (firstCharLineIndex < 0)
                return -1;

            return firstCharLineIndex + column;
        }

        #region Macro Recording methods
        public void RecordDelete(bool backspace, bool word)
        {
            // If not backspace then it's a delete
            // If not word then it's a single character
            LastMacro macroType = backspace ?
                    (word ? LastMacro.BackspaceWord : LastMacro.BackspaceChar) :
                    (word ? LastMacro.DeleteWord : LastMacro.DeleteChar);

            // Get the number of times the macro type calculated above has been recorded already
            // (if any) and then add one to get the current count
            uint count = m_Recorder.GetTimesPreviouslyRecorded(macroType) + 1;

            string macroString = "";
            // if this parameter is negative, it indicates a backspace, rather then a delete
            macroString += "ActiveDocument.Object.Delete(" + (int)(word ? tom.tomConstants.tomWord : tom.tomConstants.tomCharacter) + ", " + (backspace ? -1 * count : count) + ")";

            m_Recorder.RecordBatchedLine(macroType, macroString);
        }

        public void RecordMove(LastMacro state, string direction, MoveScope scope, bool extend)
        {

            string macroString = "";
            macroString += "ActiveDocument.Object.Move";
            macroString += direction;
            // Get the number of times this macro type has been recorded already
            // (if any) and then add one to get the current count
            macroString += "(" + (int)scope + ", " + (m_Recorder.GetTimesPreviouslyRecorded(state) + 1) + ", " + (int)(extend ? tom.tomConstants.tomExtend : tom.tomConstants.tomMove) + ")";

            m_Recorder.RecordBatchedLine(state, macroString);
        }

        public void RecordCommand(string command)
        {
            if (m_Recorder.IsRecording())
            {
                string line = "ActiveDocument.Object.";

                line += command;

                m_Recorder.RecordLine(line);
            }
        }
        
        public void StopRecorder()
        {
            m_Recorder.Stop();
        }

        public void RecordPrintableChar(char currentValue)
        {
            string macroString = "";

            if (!m_Recorder.IsLastRecordedMacro(LastMacro.Text))
            {
                m_TextToRecord = "";
            }

            // Only deal with text characters.  Everything, space and above is a text chracter
            // except DEL (0x7f).  Include carriage return (enter key) and tab, which are
            // below space, since those are also text characters.
            if (char.IsLetterOrDigit(currentValue) ||
                    char.IsPunctuation(currentValue) ||
                    char.IsSeparator(currentValue) ||
                    char.IsSymbol(currentValue) ||
                    char.IsWhiteSpace(currentValue) ||
                    '\r' == currentValue || '\t' == currentValue)
            {
                if ('\r' == currentValue)
                {
                    // Emit "\r\n" as the standard line terminator
                    m_TextToRecord += "\" & vbCr & \"";
                }
                else if ('\t' == currentValue)
                {
                    // Emit "\t" as the standard tab
                    m_TextToRecord += "\" & vbTab & \"";
                }
                else
                {
                    m_TextToRecord += currentValue;
                }

                macroString += "ActiveDocument.Object.TypeText(\"";
                macroString += m_TextToRecord;
                macroString += "\")";

                if (m_Recorder.RecordBatchedLine(LastMacro.Text, macroString, 100)) // arbitrary max length
                {
                    // Clear out the buffer if the line hit max length, since
                    // it will not continue to be appended to
                    m_TextToRecord = "";
                }
            }       
        }
        
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public void RecordNonprintableChar(Keys currentKey)
        {
            string macroString = "";

            // Obtain the CTRL and SHIFT as they modify a number of the virtual keys. 
            bool shiftDown = System.Windows.Forms.Keys.Shift == (System.Windows.Forms.Control.ModifierKeys & System.Windows.Forms.Keys.Shift); //Keyboard::IsKeyDown(VK_SHIFT);
            bool controlDown = System.Windows.Forms.Keys.Control == (System.Windows.Forms.Control.ModifierKeys & System.Windows.Forms.Keys.Control); //Keyboard::IsKeyDown(VK_CONTROL);

            // msg.WParam indicates the virtual key.
            switch (currentKey)
            {
                case Keys.Back: // BackSpace key
                    // Note that SHIFT does not affect this command
                    RecordDelete(true, controlDown);
                    break;

                case Keys.Delete:
                    // Note that SHIFT completely disables this command
                    if (!shiftDown)
                    {
                        RecordDelete(false, controlDown);
                    }
                    break;

                case Keys.Left: // Left Arrow
                    // SHIFT indicates selection, CTRL indicates words instead of characters
                    {
                        LastMacro macroType = controlDown ?
                        (shiftDown ? LastMacro.LeftArrowWordSelection : LastMacro.LeftArrowWord) :
                        (shiftDown ? LastMacro.LeftArrowCharSelection : LastMacro.LeftArrowChar);

                        RecordMove(macroType, "Left", controlDown ? MoveScope.Word : MoveScope.Character, shiftDown);
                    }
                    break;

                case Keys.Right: // Right Arrow
                    // SHIFT indicates selection, CTRL indicates words instead of characters
                    {
                        LastMacro macroType = controlDown ?
                        (shiftDown ? LastMacro.RightArrowWordSelection : LastMacro.RightArrowWord) :
                        (shiftDown ? LastMacro.RightArrowCharSelection : LastMacro.RightArrowChar);

                        RecordMove(macroType, "Right", controlDown ? MoveScope.Word : MoveScope.Character, shiftDown);
                    }
                    break;

                case Keys.Up: // Up Arrow
                    // SHIFT indicates selection, CTRL indicates paragraphs instead of lines
                    {
                        LastMacro macroType = controlDown ?
                        (shiftDown ? LastMacro.UpArrowParaSelection : LastMacro.UpArrowPara) :
                        (shiftDown ? LastMacro.UpArrowLineSelection : LastMacro.UpArrowLine);

                        RecordMove(macroType, "Up", controlDown ? MoveScope.Paragraph : MoveScope.Line, shiftDown);
                    }
                    break;

                case Keys.Down: // Down Arrow
                    // SHIFT indicates selection, CTRL indicates paragraphs instead of lines
                    {
                        LastMacro macroType = controlDown ?
                        (shiftDown ? LastMacro.DownArrowParaSelection : LastMacro.DownArrowPara) :
                        (shiftDown ? LastMacro.DownArrowLineSelection : LastMacro.DownArrowLine);

                        RecordMove(macroType, "Down", controlDown ? MoveScope.Paragraph : MoveScope.Line, shiftDown);
                    }
                    break;

                case Keys.Prior: // Page Up
                case Keys.Next: // Page Down
                    macroString += "ActiveDocument.Object.Move";

                    if (System.Windows.Forms.Keys.Prior == currentKey)
                    {
                        macroString += "Up";
                    }
                    else
                    {
                        macroString += "Down";
                    }

                    macroString += "(" + (int)(controlDown ? tom.tomConstants.tomWindow : tom.tomConstants.tomScreen) + ", 1, " + (int)(shiftDown ? tom.tomConstants.tomExtend : tom.tomConstants.tomMove) + ")";

                    m_Recorder.RecordLine(macroString);
                    break;

                case Keys.End:
                case Keys.Home:
                    macroString += "ActiveDocument.Object.";

                    if (System.Windows.Forms.Keys.End == currentKey)
                    {
                        macroString += "EndKey";
                    }
                    else
                    {
                        macroString += "HomeKey";
                    }

                    macroString += "(" + (int)(controlDown ? tom.tomConstants.tomStory : tom.tomConstants.tomLine) + ", " + (int)(shiftDown ? tom.tomConstants.tomExtend : tom.tomConstants.tomMove) + ")";

                    m_Recorder.RecordLine(macroString);
                    break;

                case Keys.Insert:
                    // Note that the CTRL completely disables this command.  Also the SHIFT+INSERT
                    // actually generates a WM_PASTE message rather than a WM_KEYDOWN
                    if (!controlDown)
                    {
                        macroString = "ActiveDocument.Object.Flags = ActiveDocument.Object.Flags Xor ";
                        macroString += (int)tom.tomConstants.tomSelOvertype;
                        m_Recorder.RecordLine(macroString);
                    }
                    break;
            }
        }

        // This event returns the literal key that was pressed and does not account for
        // case of characters.  KeyPress is used to handled printable caracters.
        private void richTextBoxCtrl_KeyDown(object sender, KeyEventArgs e)
        {
            if (m_Recorder.IsRecording())
            {
                RecordNonprintableChar(e.KeyCode);
            }
        }

        // The argumements of this event will give us the char value of the key press taking into
        // account other characters press such as shift or caps lock for proper casing.
        private void richTextBoxCtrl_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (m_Recorder.IsRecording())
            {
                RecordPrintableChar(e.KeyChar);
            }
        }
        #endregion

        private void richTextBoxCtrl_MouseEnter(object sender, EventArgs e)
        {
            if(m_Recorder.IsRecording())
                richTextBoxCtrl.FilterMouseClickMessages = true;
            else
                richTextBoxCtrl.FilterMouseClickMessages = false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\EditorPane.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.IO;
using System.Drawing;
using System.Globalization;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Security.Permissions;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.TextManager.Interop;
using Microsoft.VisualStudio.Shell;
using EnvDTE;
using tom;

using ISysServiceProvider = System.IServiceProvider;
using IOleServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using VSStd97CmdID = Microsoft.VisualStudio.VSConstants.VSStd97CmdID;

namespace %ProjectNamespace%.%ProjectClass%
{
    /// <summary>
    /// This control host the editor (an extended RichTextBox) and is responsible for
    /// handling the commands targeted to the editor as well as saving and loading
    /// the document. This control also implement the search and replace functionalities.
    /// </summary>

    ///////////////////////////////////////////////////////////////////////////////
    // Having an entry in the new file dialog.
    //
    // For our file type should appear under "General" in the new files dialog, we need the following:-
    //     - A .vsdir file in the same directory as NewFileItems.vsdir (generally under Common7\IDE\NewFileItems).
    //       In our case the file name is Editor.vsdir but we only require a file with .vsdir extension.
    //     - An empty %Extension% file in the same directory as NewFileItems.vsdir. In
    //       our case we chose %DefaultName%.%Extension%. Note this file name appears in Editor.vsdir
    //       (see vsdir file format below)
    //     - Three text strings in our language specific resource. File Resources.resx :-
    //          - "Rich Text file" - this is shown next to our icon.
    //          - "A blank rich text file" - shown in the description window
    //             in the new file dialog.
    //          - "%DefaultName%" - This is the base file name. New files will initially
    //             be named as %DefaultName%1.%Extension%, %DefaultName%2.%Extension%... etc.
    ///////////////////////////////////////////////////////////////////////////////
    // Editor.vsdir contents:-
    //    %DefaultName%.%Extension%|{3085E1D6-A938-478e-BE49-3546C09A1AB1}|#106|80|#109|0|401|0|#107
    //
    // The fields in order are as follows:-
    //    - %DefaultName%.%Extension% - our empty %Extension% file
    //    - {db16ff5e-400a-4cb7-9fde-cb3eab9d22d2} - our Editor package guid
    //    - #106 - the ID of "Rich Text file" in the resource
    //    - 80 - the display ordering priority
    //    - #109 - the ID of "A blank rich text file" in the resource
    //    - 0 - resource dll string (we don't use this)
    //    - 401 - the ID of our icon
    //    - 0 - various flags (we don't use this - se vsshell.idl)
    //    - #107 - the ID of "%Extension%"
    ///////////////////////////////////////////////////////////////////////////////

    //This is required for Find In files scenario to work properly. This provides a connection point 
    //to the event interface
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling")]
    [ComSourceInterfaces(typeof(IVsTextViewEvents))]
    [ComVisible(true)]
    public sealed class EditorPane : Microsoft.VisualStudio.Shell.WindowPane,
                                IVsPersistDocData,  //to Enable persistence functionality for document data
                                IPersistFileFormat, //to enable the programmatic loading or saving of an object 
        //in a format specified by the user.
                                IVsFileChangeEvents,//to notify the client when file changes on disk
                                IVsDocDataFileChangeControl, //to Determine whether changes to files made outside 
        //of the editor should be ignored
                                IVsFileBackup,      //to support backup of files. Visual Studio File Recovery 
        //backs up all objects in the Running Document Table that 
        //support IVsFileBackup and have unsaved changes.
                                IVsStatusbarUser,   //support updating the status bar
                                IVsFindTarget,      //to implement find and replace capabilities within the editor
                                IVsTextImage,       //to support find and replace in a text image
                                IVsTextSpanSet,     //to support find and replace in a text image
                                IVsTextBuffer,      //needed for Find and Replace to work appropriately
                                IVsTextView,        //needed for Find and Replace to work appropriately
                                IVsCodeWindow,      //needed for Find and Replace to work appropriately
                                IVsTextLines,       //needed for Find and Replace to work appropriately
                                IExtensibleObject,  //so we can get the atuomation object
                                IEditor,  //the automation interface for Editor
                                IVsToolboxUser      //Sends notification about Toolbox items to the owner of these items
    {
        private const uint MyFormat = 0;
        private const string MyExtension = ".%Extension%";
        private static string[] fontSizeArray = { "8", "9", "10", "11", "12", "14", "16", "18",
                                                  "20", "22", "24", "26", "28", "36", "48", "72"};

        private class EditorProperties
        {
            private EditorPane editor;
            public EditorProperties(EditorPane Editor)
            {
                editor = Editor;
            }

            [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
            public string FileName
            {
                get { return editor.FileName; }
            }

            [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
            public bool DataChanged
            {
                get { return editor.DataChanged; }
            }
        }

        #region Fields
        private %ProjectClass%Package myPackage;

        private string fileName = string.Empty;
        private bool isDirty;
        // Flag true when we are loading the file. It is used to avoid to change the isDirty flag
        // when the changes are related to the load operation.
        private bool loading;
        // This flag is true when we are asking the QueryEditQuerySave service if we can edit the
        // file. It is used to avoid to have more than one request queued.
        private bool gettingCheckoutStatus;
        private MyEditor editorControl;

        private Microsoft.VisualStudio.Shell.SelectionContainer selContainer;
        private ITrackSelection trackSel;
        private IVsFileChangeEx vsFileChangeEx;

        private Timer FileChangeTrigger = new Timer();

        private Timer FNFStatusbarTrigger = new Timer();

        private bool fileChangedTimerSet;
        private int ignoreFileChangeLevel;
        private bool backupObsolete = true;
        private uint vsFileChangeCookie;
        private string[] fontListArray;

        private object findState;
        private bool lockImage;
        private ArrayList textSpanArray = new ArrayList();
        private IVsTextImage spTextImage;

        private IExtensibleObjectSite extensibleObjectSite;

        #endregion

        #region "Window.Pane Overrides"
        /// <summary>
        /// Constructor that calls the Microsoft.VisualStudio.Shell.WindowPane constructor then
        /// our initialization functions.
        /// </summary>
        /// <param name="package">Our Package instance.</param>
        public EditorPane(%ProjectClass%Package package)
            : base(null)
        {
            PrivateInit(package);
        }

        protected override void OnClose()
        {
            editorControl.StopRecorder();

            base.OnClose();
        }

        /// <summary>
        /// This is a required override from the Microsoft.VisualStudio.Shell.WindowPane class.
        /// It returns the extended rich text box that we host.
        /// </summary>
        public override IWin32Window Window
        {
            get
            {
                return this.editorControl;
            }
        }
        #endregion

        /// <summary>
        /// Initialization routine for the Editor. Loads the list of properties for the %Extension% document 
        /// which will show up in the properties window 
        /// </summary>
        /// <param name="package"></param>
        private void PrivateInit(%ProjectClass%Package package)
        {
            myPackage = package;
            loading = false;
            gettingCheckoutStatus = false;
            trackSel = null;

            Control.CheckForIllegalCrossThreadCalls = false;
            // Create an ArrayList to store the objects that can be selected
            ArrayList listObjects = new ArrayList();

            // Create the object that will show the document's properties
            // on the properties window.
            EditorProperties prop = new EditorProperties(this);
            listObjects.Add(prop);

            // Create the SelectionContainer object.
            selContainer = new Microsoft.VisualStudio.Shell.SelectionContainer(true, false);
            selContainer.SelectableObjects = listObjects;
            selContainer.SelectedObjects = listObjects;

            // Create and initialize the editor

            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(EditorPane));
            this.editorControl = new MyEditor();

            resources.ApplyResources(this.editorControl, "editorControl", CultureInfo.CurrentUICulture);
            // Event handlers for macro recording.
            this.editorControl.RichTextBoxControl.TextChanged += new System.EventHandler(this.OnTextChange);
            this.editorControl.RichTextBoxControl.MouseDown += new MouseEventHandler(this.OnMouseClick);
            this.editorControl.RichTextBoxControl.SelectionChanged += new EventHandler(this.OnSelectionChanged);
            this.editorControl.RichTextBoxControl.KeyDown += new KeyEventHandler(this.OnKeyDown);
            
            // Handle Focus event
            this.editorControl.RichTextBoxControl.GotFocus += new EventHandler(this.OnGotFocus);

            // Call the helper function that will do all of the command setup work
            setupCommands();
        }

        /// <summary>
        /// returns the name of the file currently loaded
        /// </summary>
        public string FileName
        {
            get { return fileName; }
        }

        /// <summary>
        /// returns whether the contents of file have changed since the last save
        /// </summary>
        public bool DataChanged
        {
            get { return isDirty; }
        }

        /// <summary>
        /// returns an instance of the ITrackSelection service object
        /// </summary>
        private ITrackSelection TrackSelection
        {
            get
            {
                if (trackSel == null)
                {
                    trackSel = (ITrackSelection)GetService(typeof(ITrackSelection));
                }
                return trackSel;
            }
        }

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1816:CallGCSuppressFinalizeCorrectly")]
        protected override void Dispose(bool disposing)
        {
            try
            {
                if (disposing)
                {
                    // Dispose the timers
                    if (null != FileChangeTrigger)
                    {
                        FileChangeTrigger.Dispose();
                        FileChangeTrigger = null;
                    }
                    if (null != FNFStatusbarTrigger)
                    {
                        FNFStatusbarTrigger.Dispose();
                        FNFStatusbarTrigger = null;
                    }

                    SetFileChangeNotification(null, false);

                    if (editorControl != null)
                    {
                        editorControl.RichTextBoxControl.Dispose();
                        editorControl.Dispose();
                        editorControl = null;
                    }
                    if (FileChangeTrigger != null)
                    {
                        FileChangeTrigger.Dispose();
                        FileChangeTrigger = null;
                    }
                    if (extensibleObjectSite != null)
                    {
                        extensibleObjectSite.NotifyDelete(this);
                        extensibleObjectSite = null;
                    }
                    GC.SuppressFinalize(this);
                }
            }
            finally
            {
                base.Dispose(disposing);
            }
        }

        /// <summary>
        /// Gets an instance of the RunningDocumentTable (RDT) service which manages the set of currently open 
        /// documents in the environment and then notifies the client that an open document has changed
        /// </summary>
        private void NotifyDocChanged()
        {
            // Make sure that we have a file name
            if (fileName.Length == 0)
                return;

            // Get a reference to the Running Document Table
            IVsRunningDocumentTable runningDocTable = (IVsRunningDocumentTable)GetService(typeof(SVsRunningDocumentTable));

            // Lock the document
            uint docCookie;
            IVsHierarchy hierarchy;
            uint itemID;
            IntPtr docData;
            int hr = runningDocTable.FindAndLockDocument(
                (uint)_VSRDTFLAGS.RDT_ReadLock,
                fileName,
                out hierarchy,
                out itemID,
                out docData,
                out docCookie
            );
            ErrorHandler.ThrowOnFailure(hr);

            // Send the notification
            hr = runningDocTable.NotifyDocumentChanged(docCookie, (uint)__VSRDTATTRIB.RDTA_DocDataReloaded);

            // Unlock the document.
            // Note that we have to unlock the document even if the previous call failed.
            ErrorHandler.ThrowOnFailure(runningDocTable.UnlockDocument((uint)_VSRDTFLAGS.RDT_ReadLock, docCookie));

            // Check ff the call to NotifyDocChanged failed.
            ErrorHandler.ThrowOnFailure(hr);
        }

        /// <summary>
        /// This is an added command handler that will make it so the ITrackSelection.OnSelectChange
        /// function gets called whenever the cursor position is changed and also so the position 
        /// displayed on the status bar will update whenever the cursor position changes.
        /// </summary>
        /// <param name="sender"> Not used.</param>
        /// <param name="e"> Not used.</param>
        void OnSelectionChanged(object sender, EventArgs e)
        {
            // Call the function that will update the position displayed on the status bar.
            this.SetStatusBarPosition();

            // Now call the OnSelectChange function using our stored TrackSelection and
            // selContainer variables.
            ITrackSelection track = TrackSelection;
            if (null != track)
            {
                ErrorHandler.ThrowOnFailure(track.OnSelectChange((ISelectionContainer)selContainer));
            }
        }

        #region Command Handling Functions

        /// <summary>
        /// This helper function, which is called from the EditorPane's PrivateInit
        /// function, does all the work involving adding commands.
        /// </summary>
        private void setupCommands()
        {
            // Now get the IMenuCommandService; this object is the one
            // responsible for handling the collection of commands implemented by the package.

            IMenuCommandService mcs = GetService(typeof(IMenuCommandService)) as IMenuCommandService;
            if (null != mcs)
            {
                // Now create one object derived from MenuCommnad for each command defined in
                // the CTC file and add it to the command service.

                // For each command we have to define its id that is a unique Guid/integer pair, then
                // create the OleMenuCommand object for this command. The EventHandler object is the
                // function that will be called when the user will select the command. Then we add the 
                // OleMenuCommand to the menu service.  The addCommand helper function does all this for us.

                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.SelectAll,
                                new EventHandler(onSelectAll), null);
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Copy,
                                new EventHandler(onCopy), new EventHandler(onQueryCopy));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Cut,
                                new EventHandler(onCut), new EventHandler(onQueryCutOrDelete));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Paste,
                                new EventHandler(onPaste), new EventHandler(onQueryPaste));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Delete,
                                new EventHandler(onDelete), new EventHandler(onQueryCutOrDelete));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Undo,
                                new EventHandler(onUndo), new EventHandler(onQueryUndo));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Redo,
                                new EventHandler(onRedo), new EventHandler(onQueryRedo));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Bold,
                                new EventHandler(onBold), new EventHandler(onQueryBold));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Italic,
                                new EventHandler(onItalic), new EventHandler(onQueryItalic));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.Underline,
                                new EventHandler(onUnderline), new EventHandler(onQueryUnderline));
                addCommand(mcs, GuidList.guid%ProjectClass%CmdSet, (int)PkgCmdIDList.icmdStrike,
                                new EventHandler(onStrikethrough), new EventHandler(onQueryStrikethrough));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.JustifyCenter,
                                new EventHandler(onJustifyCenter), new EventHandler(onQueryJustifyCenter));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.JustifyLeft,
                                new EventHandler(onJustifyLeft), new EventHandler(onQueryJustifyLeft));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.JustifyRight,
                                new EventHandler(onJustifyRight), new EventHandler(onQueryJustifyRight));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.FontNameGetList,
                                new EventHandler(onFontNameGetList), null);
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.FontName,
                                new EventHandler(onFontName), null);
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.FontSizeGetList,
                                new EventHandler(onFontSizeGetList), null);
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.FontSize,
                                new EventHandler(onFontSize), null);
                addCommand(mcs, VSConstants.VSStd2K, (int)VSConstants.VSStd2KCmdID.BULLETEDLIST,
                                new EventHandler(onBulletedList), new EventHandler(onQueryBulletedList));
                // Support clipboard rings
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.PasteNextTBXCBItem,
                                new EventHandler(onPasteNextTBXCBItem), new EventHandler(onQueryPasteNextTBXCBItem));

                // These two commands enable Visual Studio's default undo/redo toolbar buttons.  When these
                // buttons are clicked it triggers a multi-level undo/redo (even when we are undoing/redoing
                // only one action.  Note that we are not implementing the multi-level undo/redo functionality,
                // we are just adding a handler for this command so these toolbar buttons are enabled (Note that
                // we are just reusing the undo/redo command handlers).  To implement multi-level functionality
                // we would need to properly handle these two commands as well as MultiLevelUndoList and
                // MultiLevelRedoList.
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.MultiLevelUndo,
                                new EventHandler(onUndo), new EventHandler(onQueryUndo));
                addCommand(mcs, VSConstants.GUID_VSStandardCommandSet97, (int)VSConstants.VSStd97CmdID.MultiLevelRedo,
                                new EventHandler(onRedo), new EventHandler(onQueryRedo));
            }
        }

        /// <summary>
        /// Helper function used to add commands using IMenuCommandService
        /// </summary>
        /// <param name="mcs"> The IMenuCommandService interface.</param>
        /// <param name="menuGroup"> This guid represents the menu group of the command.</param>
        /// <param name="cmdID"> The command ID of the command.</param>
        /// <param name="commandEvent"> An EventHandler which will be called whenever the command is invoked.</param>
        /// <param name="queryEvent"> An EventHandler which will be called whenever we want to query the status of
        /// the command.  If null is passed in here then no EventHandler will be added.</param>
        private static void addCommand(IMenuCommandService mcs, Guid menuGroup, int cmdID,
                                       EventHandler commandEvent, EventHandler queryEvent)
        {
            // Create the OleMenuCommand from the menu group, command ID, and command event
            CommandID menuCommandID = new CommandID(menuGroup, cmdID);
            OleMenuCommand command = new OleMenuCommand(commandEvent, menuCommandID);

            // Add an event handler to BeforeQueryStatus if one was passed in
            if (null != queryEvent)
            {
                command.BeforeQueryStatus += queryEvent;
            }

            // Add the command using our IMenuCommandService instance
            mcs.AddCommand(command);
        }

        /// <summary>
        /// Handler for out SelectAll command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onSelectAll(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.SelectAll();
        }

        /// <summary>
        /// Handler for when we want to query the status of the copy command.  If there
        /// is any text selected then it will set the Enabled property to true.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryCopy(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Enabled = editorControl.RichTextBoxControl.SelectionLength > 0 ? true : false;
        }

        /// <summary>
        /// Handler for our Copy command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onCopy(object sender, EventArgs e)
        {
            Copy();
            editorControl.RecordCommand("Copy");
        }

        /// <summary>
        /// Handler for when we want to query the status of the cut or delete
        /// commands.  If there is any selected text then it will set the 
        /// enabled property to true.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryCutOrDelete(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Enabled = editorControl.RichTextBoxControl.SelectionLength > 0 ? true : false;
        }

        /// <summary>
        /// Handler for our Cut command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onCut(object sender, EventArgs e)
        {
            Cut();
            editorControl.RecordCommand("Cut");
        }

        /// <summary>
        /// Handler for our Delete command.
        /// </summary>
        private void onDelete(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.SelectedText = "";
            editorControl.RecordCommand("Delete");
        }

        /// <summary>
        /// Handler for when we want to query the status of the paste command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryPaste(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Enabled = editorControl.RichTextBoxControl.CanPaste(DataFormats.GetFormat(DataFormats.Text));
        }

        /// <summary>
        /// Handler for our Paste command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onPaste(object sender, EventArgs e)
        {
            Paste();
            editorControl.RecordCommand("Paste");
        }

        /// <summary>
        /// Handler for when we want to query the status of the clipboard ring.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryPasteNextTBXCBItem(object sender, EventArgs e)
        {
            // Get the Toolbox Service from the package
            IVsToolboxClipboardCycler clipboardCycler = GetService(typeof(SVsToolbox)) as IVsToolboxClipboardCycler;

            int itemsAvailable;
            ErrorHandler.ThrowOnFailure(clipboardCycler.AreDataObjectsAvailable((IVsToolboxUser)this, out itemsAvailable));

            OleMenuCommand command = (OleMenuCommand)sender;
            command.Enabled = ((itemsAvailable > 0) ? true : false);
        }

        /// <summary>
        /// Handler for our Paste command.
        /// </summary>
        /// <param name="sender">  Not used.</param>
        /// <param name="e">  Not used.</param>
        private void onPasteNextTBXCBItem(object sender, EventArgs e)
        {
            // Get the Toolbox Service from the package
            IVsToolboxClipboardCycler clipboardCycler = GetService(typeof(SVsToolbox)) as IVsToolboxClipboardCycler;

            Microsoft.VisualStudio.OLE.Interop.IDataObject pDO;

            ErrorHandler.ThrowOnFailure(clipboardCycler.GetAndSelectNextDataObject((IVsToolboxUser)this, out pDO));

            ITextSelection textSelection = editorControl.TextDocument.Selection;

            // Get the current position of the start of the current selection. 
            // After the paste the positiono of the start of current selection
            // will be moved to the end of inserted text, so it needs to
            // move back to original position so that inserted text can be highlighted to 
            // allow cycling through our clipboard items.
            int originalStart;
            originalStart = textSelection.Start;

            // This will do the actual pasting of the object
            ItemPicked(pDO);

            // Now move the start position backwards to the original position.
            int currentStart;
            currentStart = textSelection.Start;
            textSelection.MoveStart((int)tom.tomConstants.tomCharacter, originalStart - currentStart);

            // Select the pasted text
            textSelection.Select();
        }

        /// <summary>
        /// Handler for when we want to query the status of the Undo command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryUndo(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Enabled = editorControl.RichTextBoxControl.CanUndo;
        }

        /// <summary>
        /// Handler for our Undo command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onUndo(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.Undo();
        }

        /// <summary>
        /// Handler for when we want to query the status of the Redo command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryRedo(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Enabled = editorControl.RichTextBoxControl.CanRedo;
        }

        /// <summary>
        /// Handler for our Redo command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onRedo(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.Redo();
        }

        /// <summary>
        /// Handler for when we want to query the status of the Bold command.  It will
        /// always be enabled, but we want to check if the current text is bold or not
        /// so we can set the Checked property which will change how the button looks
        /// in the toolbar and the context menu.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryBold(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = editorControl.RichTextBoxControl.SelectionFont.Bold;
        }

        /// <summary>
        /// Handler for our Bold command.  Toggles the bold state of the selected text.
        /// Or if there is no selected text then it toggles the bold state for 
        /// newly entered text.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onBold(object sender, EventArgs e)
        {
            setFontStyle(FontStyle.Bold, editorControl.RichTextBoxControl.SelectionFont.Bold);
        }

        /// <summary>
        /// Handler for when we want to query the status of the Italic command.  It will
        /// always be enabled, but we want to check if the current text is Italic or not
        /// so we can set the Checked property which will change how the button looks
        /// in the toolbar and the context menu.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryItalic(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = editorControl.RichTextBoxControl.SelectionFont.Italic;
        }

        /// <summary>
        /// Handler for our Italic command.  Toggles the italic state of the selected text.
        /// Or if there is no selected text then it toggles the italic state for 
        /// newly entered text.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onItalic(object sender, EventArgs e)
        {
            setFontStyle(FontStyle.Italic, editorControl.RichTextBoxControl.SelectionFont.Italic);
        }

        /// <summary>
        /// Handler for when we want to query the status of the Underline command.  It will
        /// always be enabled, but we want to check if the current text is underlined or not
        /// so we can set the Checked property which will change how the button looks
        /// in the toolbar and the context menu.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryUnderline(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = editorControl.RichTextBoxControl.SelectionFont.Underline;
        }

        /// <summary>
        /// Handler for our Underline command.  Toggles the underline state of the selected
        /// text.  Or if there is no selected text then it toggles the underline state for 
        /// newly entered text.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onUnderline(object sender, EventArgs e)
        {
            setFontStyle(FontStyle.Underline, editorControl.RichTextBoxControl.SelectionFont.Underline);
        }

        /// <summary>
        /// Handler for when we want to query the status of the Strikethrough command.  It will
        /// always be enabled, but we want to check if the current text has Strikethrough or not
        /// so we can set the Checked property which will change how the button looks
        /// in the toolbar and the context menu.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryStrikethrough(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = editorControl.RichTextBoxControl.SelectionFont.Strikeout;
        }

        /// <summary>
        /// Handler for our Strikethrough command.  Toggles the strikethrough state of 
        /// the selected text.  Or if there is no selected text then it toggles the 
        /// strikethrough state for newly entered text.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onStrikethrough(object sender, EventArgs e)
        {
            setFontStyle(FontStyle.Strikeout, editorControl.RichTextBoxControl.SelectionFont.Strikeout);
        }

        /// <summary>
        /// This helper function is called when we need to toggle the states bold,
        /// underline, italic or strikeout.
        /// </summary>
        /// <param name="fontStyleToSet"> Which FontStyle to toggle (bold, italic, underline or strikeout).</param>
        /// <param name="currentStateOn"> The current state of the font style.  If this is true then we
        /// will turn the font style off and if it is false we will turn it on.</param>
        private void setFontStyle(FontStyle fontStyleToSet, bool currentStateOn)
        {
            // Figure out what the new FontStyle should be based on the current one
            FontStyle fs = currentStateOn ? editorControl.RichTextBoxControl.SelectionFont.Style & (~fontStyleToSet) :
                                            editorControl.RichTextBoxControl.SelectionFont.Style | fontStyleToSet;

            // Create the new Font based on the current one and fs then set it
            Font f = new Font(editorControl.RichTextBoxControl.SelectionFont, fs);
            editorControl.RichTextBoxControl.SelectionFont = f;

            if (f != null)
                f.Dispose();
        }

        /// <summary>
        /// Handler for when we want to query the status of the justify center command.  It will
        /// always be enabled, but we want to check if the current text is center-justified or not
        /// so we can set the Checked property which will change how the button looks in the toolbar.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryJustifyCenter(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = (editorControl.RichTextBoxControl.SelectionAlignment == HorizontalAlignment.Center);
        }

        /// <summary>
        /// Handler for our Justify Center command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onJustifyCenter(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.SelectionAlignment = HorizontalAlignment.Center;
        }

        /// <summary>
        /// Handler for when we want to query the status of the justify left command.  It will
        /// always be enabled, but we want to check if the current text is left-justified or not
        /// so we can set the Checked property which will change how the button looks in the toolbar.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryJustifyLeft(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = (editorControl.RichTextBoxControl.SelectionAlignment == HorizontalAlignment.Left);
        }

        /// <summary>
        /// Handler for our Justify Left command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onJustifyLeft(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.SelectionAlignment = HorizontalAlignment.Left;
        }

        /// <summary>
        /// Handler for when we want to query the status of the justify right command.  It will
        /// always be enabled, but we want to check if the current text is right-justified or not
        /// so we can set the Checked property which will change how the button looks in the toolbar.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryJustifyRight(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = (editorControl.RichTextBoxControl.SelectionAlignment == HorizontalAlignment.Right);
        }

        /// <summary>
        /// Handler for our Justify Right command.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onJustifyRight(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.SelectionAlignment = HorizontalAlignment.Right;
        }

        /// <summary>
        /// Helper function that fills the fontList array (of strings) with
        /// all the available fonts.
        /// </summary>
        private void fillFontList()
        {
            FontFamily[] fontFamilies;

            System.Drawing.Text.InstalledFontCollection installedFontCollection = new System.Drawing.Text.InstalledFontCollection();

            // Get the array of FontFamily objects.
            fontFamilies = installedFontCollection.Families;

            // Create the font list array and fill it with the list of available fonts.
            fontListArray = new string[fontFamilies.Length];
            for (int i = 0; i < fontFamilies.Length; ++i)
            {
                fontListArray[i] = fontFamilies[i].Name;
            }
        }

        /// <summary>
        /// This function is called when the drop down that lists the possible
        /// fonts is clicked.  It is responsible for populating the list of fonts
        /// with strings.  The fillFontList function is responsible for getting the
        /// list of possible fonts and will be called from here the first time
        /// this function is called.  Note that we use the EventArgs parameter to
        /// pass back the list after casting it to an OleMenuCmdEventArgs object.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  We will cast this to an OleMenuCommandEventArgs
        /// object and then use it to pass back the array of strings.</param>
        private void onFontNameGetList(object sender, EventArgs e)
        {
            // If this is the first time we are calling this function then
            // we need to set up the fontListArray
            if (this.fontListArray == null)
            {
                fillFontList();
            }

            // Cast the EventArgs to an OleMenuCmdEventArgs object
            OleMenuCmdEventArgs args = (OleMenuCmdEventArgs)e;

            // Set the out value of the OleMenuCmdEventArgs to our font list array
            Marshal.GetNativeVariantForObject(fontListArray, args.OutValue);
        }

        /// <summary>
        /// This function will be called for two seperate reasons.  It will be called constantly
        /// to figure out what string needs to be displayed in the font name combo box.  In this
        /// case we need to cast the EventArgs to OleMenuCmdEventArgs and set the OutValue to
        /// the name of the currently used font.  It will also be called when the user selects a new
        /// font.  In this case we need to cast EventArgs to OleMenuCmdEventArgs so that we can get the
        /// name of the new font from InValue and set it for our hosted text editor.
        /// </summary>
        /// <param name="sender"> This can be cast to an OleMenuCommand.</param>
        /// <param name="e"> We will cast this to an OleMenuCommandEventArgs and use it in
        /// two ways.  If we are setting a new font we will get its name by casting the
        /// InValue to a string.  Otherwise we will just set the OutValue to the name
        /// of the current font.</param>
        private void onFontName(object sender, EventArgs e)
        {
            OleMenuCmdEventArgs args = (OleMenuCmdEventArgs)e;

            // If args.InValue is null then we just need to set the OutValue
            // to the current font.  If it is not null then that means that we
            // need to cast it to a string and set it as the font.
            if (null == args.InValue)
            {
                string currentFont = editorControl.RichTextBoxControl.SelectionFont.FontFamily.Name;
                Marshal.GetNativeVariantForObject(currentFont, args.OutValue);
            }
            else
            {
                string fontName = (string)args.InValue;
                Font f = new Font(fontName, editorControl.RichTextBoxControl.SelectionFont.Size, editorControl.RichTextBoxControl.SelectionFont.Style);
                editorControl.RichTextBoxControl.SelectionFont = f;

                if (f != null)
                    f.Dispose();
            }
        }

        /// <summary>
        /// This function is called when the drop down that lists the possible
        /// font sizes is clicked.  It is responsible for populating the list
        /// with strings.  The static string array fontSizeArray is filled with the most
        /// commonly used font sizes, although the user can enter any number they want. 
        /// Note that we use the EventArgs parameter to pass back the list after
        /// casting it to an OleMenuCmdEventArgs object.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  We will cast this to an OleMenuCommandEventArgs
        /// object and then use it to pass back the array of strings.</param>
        private void onFontSizeGetList(object sender, EventArgs e)
        {
            // Cast the EventArgs to an OleMenuCmdEventArgs object
            OleMenuCmdEventArgs args = (OleMenuCmdEventArgs)e;

            // Set the out value of the OleMenuCmdEventArgs to our font size array
            Marshal.GetNativeVariantForObject(fontSizeArray, args.OutValue);
        }

        /// <summary>
        /// This function will be called for two seperate reasons.  It will be called constantly
        /// to figure out what string needs to be displayed in the font size combo box.  In this
        /// case we need to cast the EventArgs to OleMenuCmdEventArgs and set the OutValue to
        /// the current font size.  It will also be called when the user changes the font size.
        /// In this case we need to cast EventArgs to OleMenuCmdEventArgs so that we can get the
        /// new font size and set it for our hosted text editor.
        /// </summary>
        /// <param name="sender"> This can be cast to an OleMenuCommand.</param>
        /// <param name="e"> We will cast this to an OleMenuCommandEventArgs and use it in
        /// two ways.  If we are setting a new font sizse we will get its name by casting the
        /// InValue to a string.  Otherwise we will just set the OutValue to the current 
        /// font size.</param>
        private void onFontSize(object sender, EventArgs e)
        {
            OleMenuCmdEventArgs args = (OleMenuCmdEventArgs)e;

            // If args.InValue is null then we just need to set the OutValue
            // to the current font size.  If it is not null then that means that we
            // need to cast it to a string and set it as the new font size.
            if (null == args.InValue)
            {
                string currentSize = Convert.ToString(Convert.ToInt32(editorControl.RichTextBoxControl.SelectionFont.Size), CultureInfo.InvariantCulture);
                Marshal.GetNativeVariantForObject(currentSize, args.OutValue);
            }
            else
            {
                string fontSize = (string)args.InValue;
                Font f = new Font(editorControl.RichTextBoxControl.SelectionFont.FontFamily, Convert.ToSingle(fontSize, CultureInfo.InvariantCulture), editorControl.RichTextBoxControl.SelectionFont.Style);
                editorControl.RichTextBoxControl.SelectionFont = f;

                if (f != null)
                    f.Dispose();
            }
        }

        /// <summary>
        /// Handler for when we want to query the status of the justify right command.  It will
        /// always be enabled, but we want to check if this is active in the current text so
        /// we can change the look of the command in the toolbar and context menu.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onQueryBulletedList(object sender, EventArgs e)
        {
            OleMenuCommand command = (OleMenuCommand)sender;
            command.Checked = editorControl.RichTextBoxControl.SelectionBullet;
        }

        /// <summary>
        /// Handler for our Bulleted List command.  This simply toggles the state
        /// of the SelectionBullet property.
        /// </summary>
        /// <param name="sender">  This can be cast to an OleMenuCommand.</param>
        /// <param name="e">  Not used.</param>
        private void onBulletedList(object sender, EventArgs e)
        {
            editorControl.RichTextBoxControl.SelectionBullet = !editorControl.RichTextBoxControl.SelectionBullet;
        }

        /// <summary>
        /// This is an extra command handler that we will use to intercept right
        /// mouse click events so that we can call our function to display the
        /// context menu.
        /// </summary>
        private void OnMouseClick(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Right)
            {
                Point mouseDownLocation = new Point(e.X, e.Y);

                // Convert the point to screen coordinates and pass it into
                // our DisplayContextMenuAt function
                Point screenCoordinates = this.editorControl.RichTextBoxControl.PointToScreen(mouseDownLocation);
                DisplayContextMenuAt(screenCoordinates);
            }
        }

        /// <summary>
        /// Function that we use to display our context menu.  This function
        /// makes use of the IMenuCommandService's ShowContextMenu function.
        /// </summary>
        /// <param name="point"> The point that we want to display the context menu at.
        /// Note that this must be in screen coordinates.</param>
        private void DisplayContextMenuAt(Point point)
        {
            // Pass in the GUID:ID pair for the context menu.
            CommandID contextMenuID = new CommandID(GuidList.guid%ProjectClass%CmdSet, PkgCmdIDList.IDMX_RTF);

            // Get the OleMenuCommandService from the package
            IMenuCommandService menuService = GetService(typeof(IMenuCommandService)) as IMenuCommandService;

            if (null != menuService)
            {
                // Note: point must be in screen coordinates
                menuService.ShowContextMenu(contextMenuID, point.X, point.Y);
            }
        }

        #endregion

        #region IEditor Implementation

        // Note that all functions implemented here call functions from the rich
        // edit control's text object model.

        /// <summary>
        /// This property gets/sets the default tab width.
        /// </summary>
        public float DefaultTabStop
        {
            get { return editorControl.TextDocument.DefaultTabStop; }
            set { editorControl.TextDocument.DefaultTabStop = value; }
        }

        /// <summary>
        /// This property gets our editor's current ITextRange interface.  ITextRange is part
        /// of the rich edit control's text object model.
        /// </summary>
        public ITextRange Range
        {
            get { return editorControl.TextRange; }
        }

        /// <summary>
        /// This property gets our editor's current ITextSelection interface.  ITextSelection
        /// is part of the rich edit control's text object model.
        /// </summary>
        public ITextSelection Selection
        {
            get { return editorControl.TextSelection; }
        }

        /// <summary>
        /// This property gets/sets the selection properties that contain certain information
        /// about our editor's current selection.
        /// </summary>
        public int SelectionProperties
        {
            get { return editorControl.TextSelection.Flags; }
            set { editorControl.TextSelection.Flags = value; }
        }

        /// <summary>
        /// This function finds a string and returns the length of the matched string.
        /// Note that this function does not move the cursor to the string that it finds.
        /// </summary>
        /// <param name="textToFind"> The string that we want to look for.</param>
        /// <returns> The length of the matched string.</returns>
        public int FindText(string textToFind)
        {
            return editorControl.TextRange.FindText(textToFind, (int)tom.tomConstants.tomForward, 0);
        }

        /// <summary>
        /// This function has the same effect as typing the passed in string into the editor.
        /// Our implementation will just call TypeText since for now we want them both to do
        /// the same thing.
        /// </summary>
        /// <param name="textToSet"> The string to set/</param>
        /// <returns> HResult that indicates success/failure.</returns>
        public int SetText(string textToSet)
        {
            // Just delegate to TypeText
            return TypeText(textToSet);
        }

        /// <summary>
        /// This function has the same effect as typing the passed in string into the editor.
        /// </summary>
        /// <param name="textToType"> The string to type.</param>
        /// <returns> HResult that indicates success/failure.</returns>
        public int TypeText(string textToType)
        {
            editorControl.TextSelection.TypeText(textToType);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// This function performs the cut operation in the editor.
        /// </summary>
        /// <returns> HResult that indicates success/failure.</returns>
        public int Cut()
        {
            object o = null;
            editorControl.TextSelection.Cut(out o);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// This function performs the copy operation in the editor.
        /// </summary>
        /// <returns> HResult that indicates success/failure.</returns>
        public int Copy()
        {
            object o = null;
            editorControl.TextSelection.Copy(out o);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// This function performs the paste operation in the editor.
        /// </summary>
        /// <returns> HResult that indicates success/failure.</returns>
        public int Paste()
        {
            object o = null;
            editorControl.TextSelection.Paste(ref o, 0);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// This function performs a delete in the editor.
        /// </summary>
        /// <param name="unit"> The type of units that we are going to delete.  The two valid options
        /// for this are TOMWord and TOMCharacter, which are defined in the TOMConstants enumeration.</param>
        /// <param name="count"> The number of units that we are going to delete.  Passing in a negative number
        /// will be similar to pressing backspace and passing in a positive number will be similar to
        /// pressing delete.</param>
        /// <returns> HResult that indicates success/failure.</returns>
        public int Delete(long unit, long count)
        {
            editorControl.TextSelection.Delete((int)unit, (int)count);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// This function will move up by the specified number of lines/paragraphs in the editor.
        /// </summary>
        /// <param name="unit"> The type of unit to move up by.  The two valid options for this are
        /// TOMLine and TOMParagraph, which are defined in the TOMConstants enumeration.</param>
        /// <param name="count"> The number of units to move.</param>
        /// <param name="extend"> This should be set to TOMExtend if we want to select as we move
        /// or TOMMove if we don't.  These values are defined in the TOMConstants enumeration.</param>
        /// <returns> The number of units that the cursor moved up.</returns>
        public int MoveUp(int unit, int count, int extend)
        {
            return editorControl.TextSelection.MoveUp(unit, count, extend);
        }

        /// <summary>
        /// This function will move down by the specified number of lines/paragraphs in the editor.
        /// </summary>
        /// <param name="unit"> The type of unit to move down by.  The two valid options for this are
        /// TOMLine and TOMParagraph, which are defined in the TOMConstants enumeration.</param>
        /// <param name="count"> The number of units to move.</param>
        /// <param name="extend"> This should be set to TOMExtend if we want to select as we move
        /// or TOMMove if we don't.  These values are defined in the TOMConstants enumeration.</param>
        /// <returns> The number of units that the cursor moved down.</returns>
        public int MoveDown(int unit, int count, int extend)
        {
            return editorControl.TextSelection.MoveDown(unit, count, extend);
        }

        /// <summary>
        /// This function will move to the left by the specified number of characters/words in the editor.
        /// </summary>
        /// <param name="unit"> The type of unit to move left by.  The two valid options for this are
        /// TOMWord and TOMCharacter, which are defined in the TOMConstants enumeration.</param>
        /// <param name="count"> The number of units to move.</param>
        /// <param name="extend"> This should be set to TOMExtend if we want to select as we move
        /// or TOMMove if we don't.  These values are defined in the TOMConstants enumeration.</param>
        /// <returns> The number of units that the cursor moved to the left.</returns>
        public int MoveLeft(int unit, int count, int extend)
        {
            return editorControl.TextSelection.MoveLeft(unit, count, extend);
        }

        /// <summary>
        /// This function will move to the right by the specified number of characters/words in the editor.
        /// </summary>
        /// <param name="unit"> The type of unit to move right by.  The two valid options for this are
        /// TOMWord and TOMCharacter, which are defined in the TOMConstants enumeration.</param>
        /// <param name="count"> The number of units to move.</param>
        /// <param name="extend"> This should be set to TOMExtend if we want to select as we move
        /// or TOMMove if we don't.  These values are defined in the TOMConstants enumeration.</param>
        /// <returns> The number of units that the cursor moved to the right.</returns>
        public int MoveRight(int unit, int count, int extend)
        {
            return editorControl.TextSelection.MoveRight(unit, count, extend);
        }

        /// <summary>
        /// This function will either move the cursor to either the end of the current line or the end of the document.
        /// </summary>
        /// <param name="unit"> If this value is equal to TOMLine it will move the cursor to the end of the line.  If
        /// it is set to TOMStory then it will move to the end of the document.  These values are defined in the
        /// TOMConstants enumeration.</param>
        /// <param name="extend"> This should be set to TOMExtend if we want to select as we move
        /// or TOMMove if we don't.  These values are defined in the TOMConstants enumeration.</param>
        /// <returns> The number of characters that the operation moved the cursor by.  This value
        /// should always be positive since we are moving "forward" in the text buffer.</returns>
        public int EndKey(int unit, int extend)
        {
            return editorControl.TextSelection.EndKey(unit, extend);
        }

        /// <summary>
        /// This function will either move the cursor to either the beggining of the current line or
        /// the beggining of the document.
        /// </summary>
        /// <param name="unit"> If this value is equal to TOMLine it will move the cursor to the beggining of the line.
        /// If it is set to TOMStory then it will move to the beggining of the document.  These values are defined in the
        /// TOMConstants enumeration.</param>
        /// <param name="extend"> This should be set to TOMExtend if we want to select as we move
        /// or TOMMove if we don't.  These values are defined in the TOMConstants enumeration.</param>
        /// <returns> The number of characters that the operation moved the cursor by.  This value
        /// should always be negative since we are moving "backward" in the text buffer.</returns>
        public int HomeKey(int unit, int extend)
        {
            return editorControl.TextSelection.HomeKey(unit, extend);
        }

        #endregion

        #region IExtensibleObject Implementation

        /// <summary>
        /// This function is used for Macro playback.  Whenever a macro gets played this funtion will be
        /// called and then the IEditor functions will be called on the object that ppDisp is set to.
        /// Since EditorPane implements IEditor we will just set it to "this".
        /// </summary>
        /// <param name="Name"> Passing in either null, empty string or "Document" will work.  Anything
        /// else will result in ppDisp being set to null.</param>
        /// <param name="pParent"> An object of type IExtensibleObjectSite.  We will keep a reference to this
        /// so that in the Dispose method we can call the NotifyDelete function.</param>
        /// <param name="ppDisp"> The object that this is set to will act as the automation object for macro
        /// playback.  In our case since IEditor is the automation interface and EditorPane
        /// implements it we will just be setting this parameter to "this".</param>
        void IExtensibleObject.GetAutomationObject(string Name, IExtensibleObjectSite pParent, out Object ppDisp)
        {
            // null or empty string just means the default object, but if a specific string
            // is specified, then make sure it's the correct one, but don't enforce case
            if (!string.IsNullOrEmpty(Name) && !Name.Equals("Document", StringComparison.CurrentCultureIgnoreCase))
            {
                ppDisp = null;
                return;
            }

            // Set the out value to this
            ppDisp = (IEditor)this;

            // Store the IExtensibleObjectSite object, it will be used in the Dispose method
            extensibleObjectSite = pParent;
        }

        #endregion

        int Microsoft.VisualStudio.OLE.Interop.IPersist.GetClassID(out Guid pClassID)
        {
            ErrorHandler.ThrowOnFailure(((Microsoft.VisualStudio.OLE.Interop.IPersist)this).GetClassID(out pClassID));
            return VSConstants.S_OK;
        }

        #region IPersistFileFormat Members

        /// <summary>
        /// Notifies the object that it has concluded the Save transaction
        /// </summary>
        /// <param name="pszFilename">Pointer to the file name</param>
        /// <returns>S_OK if the funtion succeeds</returns>
        int IPersistFileFormat.SaveCompleted(string pszFilename)
        {
            // TODO:  Add Editor.SaveCompleted implementation
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Returns the path to the object's current working file 
        /// </summary>
        /// <param name="ppszFilename">Pointer to the file name</param>
        /// <param name="pnFormatIndex">Value that indicates the current format of the file as a zero based index
        /// into the list of formats. Since we support only a single format, we need to return zero. 
        /// Subsequently, we will return a single element in the format list through a call to GetFormatList.</param>
        /// <returns></returns>
        int IPersistFileFormat.GetCurFile(out string ppszFilename, out uint pnFormatIndex)
        {
            // We only support 1 format so return its index
            pnFormatIndex = MyFormat;
            ppszFilename = fileName;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Initialization for the object 
        /// </summary>
        /// <param name="nFormatIndex">Zero based index into the list of formats that indicates the current format 
        /// of the file</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IPersistFileFormat.InitNew(uint nFormatIndex)
        {
            if (nFormatIndex != MyFormat)
            {
                return VSConstants.E_INVALIDARG;
            }
            // until someone change the file, we can consider it not dirty as
            // the user would be annoyed if we prompt him to save an empty file
            isDirty = false;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Returns the class identifier of the editor type
        /// </summary>
        /// <param name="pClassID">pointer to the class identifier</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IPersistFileFormat.GetClassID(out Guid pClassID)
        {
            ErrorHandler.ThrowOnFailure(((Microsoft.VisualStudio.OLE.Interop.IPersist)this).GetClassID(out pClassID));
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Provides the caller with the information necessary to open the standard common "Save As" dialog box. 
        /// This returns an enumeration of supported formats, from which the caller selects the appropriate format. 
        /// Each string for the format is terminated with a newline (\n) character. 
        /// The last string in the buffer must be terminated with the newline character as well. 
        /// The first string in each pair is a display string that describes the filter, such as "Text Only 
        /// (*.txt)". The second string specifies the filter pattern, such as "*.txt". To specify multiple filter 
        /// patterns for a single display string, use a semicolon to separate the patterns: "*.htm;*.html;*.asp". 
        /// A pattern string can be a combination of valid file name characters and the asterisk (*) wildcard character. 
        /// Do not include spaces in the pattern string. The following string is an example of a file pattern string: 
        /// "HTML File (*.htm; *.html; *.asp)\n*.htm;*.html;*.asp\nText File (*.txt)\n*.txt\n."
        /// </summary>
        /// <param name="ppszFormatList">Pointer to a string that contains pairs of format filter strings</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IPersistFileFormat.GetFormatList(out string ppszFormatList)
        {
            char Endline = (char)'\n';
            string FormatList = string.Format(CultureInfo.InvariantCulture, "My Editor (*{0}){1}*{0}{1}{1}", MyExtension, Endline);
            ppszFormatList = FormatList;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Loads the file content into the textbox
        /// </summary>
        /// <param name="pszFilename">Pointer to the full path name of the file to load</param>
        /// <param name="grfMode">file format mode</param>
        /// <param name="fReadOnly">determines if teh file should be opened as read only</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IPersistFileFormat.Load(string pszFilename, uint grfMode, int fReadOnly)
        {
            if (pszFilename == null)
            {
                return VSConstants.E_INVALIDARG;
            }

            loading = true;
            int hr = VSConstants.S_OK;
            try
            {
                // Show the wait cursor while loading the file
                IVsUIShell VsUiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
                if (VsUiShell != null)
                {
                    // Note: we don't want to throw or exit if this call fails, so
                    // don't check the return code.
                    hr = VsUiShell.SetWaitCursor();
                }

                // Load the file
                StreamReader str = new StreamReader(pszFilename);
                string rtfSignature = "{\\rtf";
                string lineRead = null;
                try
                {
                    lineRead = str.ReadLine();
                }
                finally
                {
                    str.Close();
                }
                if (lineRead.Contains(rtfSignature))
                {
                    //try loading with Rich Text initially
                    editorControl.RichTextBoxControl.LoadFile(pszFilename, RichTextBoxStreamType.RichText);
                }
                else
                {
                    editorControl.RichTextBoxControl.LoadFile(pszFilename, RichTextBoxStreamType.PlainText);
                }

                isDirty = false;

                //Determine if the file is read only on the file system
                FileAttributes fileAttrs = File.GetAttributes(pszFilename);

                int isReadOnly = (int)fileAttrs & (int)FileAttributes.ReadOnly;

                //Set readonly if either the file is readonly for the user or on the file system
                if (0 == isReadOnly && 0 == fReadOnly)
                    SetReadOnly(false);
                else
                    SetReadOnly(true);


                // Notify to the property window that some of the selected objects are changed
                ITrackSelection track = TrackSelection;
                if (null != track)
                {
                    hr = track.OnSelectChange((ISelectionContainer)selContainer);
                    if (ErrorHandler.Failed(hr))
                        return hr;
                }

                // Hook up to file change notifications
                if (String.IsNullOrEmpty(fileName) || 0 != String.Compare(fileName, pszFilename, true, CultureInfo.CurrentCulture))
                {
                    fileName = pszFilename;
                    SetFileChangeNotification(pszFilename, true);

                    // Notify the load or reload
                    NotifyDocChanged();
                }
            }
            finally
            {
                loading = false;
            }
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Determines whether an object has changed since being saved to its current file
        /// </summary>
        /// <param name="pfIsDirty">true if the document has changed</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IPersistFileFormat.IsDirty(out int pfIsDirty)
        {
            if (isDirty)
            {
                pfIsDirty = 1;
            }
            else
            {
                pfIsDirty = 0;
            }
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Save the contents of the textbox into the specified file. If doing the save on the same file, we need to
        /// suspend notifications for file changes during the save operation.
        /// </summary>
        /// <param name="pszFilename">Pointer to the file name. If the pszFilename parameter is a null reference 
        /// we need to save using the current file
        /// </param>
        /// <param name="remember">Boolean value that indicates whether the pszFileName parameter is to be used 
        /// as the current working file.
        /// If remember != 0, pszFileName needs to be made the current file and the dirty flag needs to be cleared after the save.
        ///                   Also, file notifications need to be enabled for the new file and disabled for the old file 
        /// If remember == 0, this save operation is a Save a Copy As operation. In this case, 
        ///                   the current file is unchanged and dirty flag is not cleared
        /// </param>
        /// <param name="nFormatIndex">Zero based index into the list of formats that indicates the format in which 
        /// the file will be saved</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IPersistFileFormat.Save(string pszFilename, int fRemember, uint nFormatIndex)
        {
            int hr = VSConstants.S_OK;
            bool doingSaveOnSameFile = false;
            // If file is null or same --> SAVE
            if (pszFilename == null || pszFilename == fileName)
            {
                fRemember = 1;
                doingSaveOnSameFile = true;
            }

            //Suspend file change notifications for only Save since we don't have notifications setup
            //for SaveAs and SaveCopyAs (as they are different files)
            if (doingSaveOnSameFile)
                this.SuspendFileChangeNotification(pszFilename, 1);

            try
            {
                editorControl.RichTextBoxControl.SaveFile(pszFilename, RichTextBoxStreamType.RichText);
            }
            catch (ArgumentException)
            {
                hr = VSConstants.E_FAIL;
            }
            catch (IOException)
            {
                hr = VSConstants.E_FAIL;
            }
            finally
            {
                //restore the file change notifications
                if (doingSaveOnSameFile)
                    this.SuspendFileChangeNotification(pszFilename, 0);
            }

            if (VSConstants.E_FAIL == hr)
                return hr;

            //Save and Save as
            if (fRemember != 0)
            {
                //Save as
                if (null != pszFilename && !fileName.Equals(pszFilename))
                {
                    SetFileChangeNotification(fileName, false); //remove notification from old file
                    SetFileChangeNotification(pszFilename, true); //add notification for new file
                    fileName = pszFilename;     //cache the new file name
                }
                isDirty = false;
                SetReadOnly(false);             //set read only to false since you were successfully able
                //to save to the new file                                                    
            }

            ITrackSelection track = TrackSelection;
            if (null != track)
            {
                hr = track.OnSelectChange((ISelectionContainer)selContainer);
            }

            // Since all changes are now saved properly to disk, there's no need for a backup.
            backupObsolete = false;
            return hr;
        }

        #endregion


        #region IVsPersistDocData Members

        /// <summary>
        /// Used to determine if the document data has changed since the last time it was saved
        /// </summary>
        /// <param name="pfDirty">Will be set to 1 if the data has changed</param>
        /// <returns>S_OK if the function succeeds</returns>
        int IVsPersistDocData.IsDocDataDirty(out int pfDirty)
        {
            return ((IPersistFileFormat)this).IsDirty(out pfDirty);
        }

        /// <summary>
        /// Saves the document data. Before actually saving the file, we first need to indicate to the environment
        /// that a file is about to be saved. This is done through the "SVsQueryEditQuerySave" service. We call the
        /// "QuerySaveFile" function on the service instance and then proceed depending on the result returned as follows:
        /// If result is QSR_SaveOK - We go ahead and save the file and the file is not read only at this point.
        /// If result is QSR_ForceSaveAs - We invoke the "Save As" functionality which will bring up the Save file name 
        ///                                dialog 
        /// If result is QSR_NoSave_Cancel - We cancel the save operation and indicate that the document could not be saved
        ///                                by setting the "pfSaveCanceled" flag
        /// If result is QSR_NoSave_Continue - Nothing to do here as the file need not be saved
        /// </summary>
        /// <param name="dwSave">Flags which specify the file save options:
        /// VSSAVE_Save        - Saves the current file to itself.
        /// VSSAVE_SaveAs      - Prompts the User for a filename and saves the file to the file specified.
        /// VSSAVE_SaveCopyAs  - Prompts the user for a filename and saves a copy of the file with a name specified.
        /// VSSAVE_SilentSave  - Saves the file without prompting for a name or confirmation.  
        /// </param>
        /// <param name="pbstrMkDocumentNew">Pointer to the path to the new document</param>
        /// <param name="pfSaveCanceled">value 1 if the document could not be saved</param>
        /// <returns></returns>
        int IVsPersistDocData.SaveDocData(Microsoft.VisualStudio.Shell.Interop.VSSAVEFLAGS dwSave, out string pbstrMkDocumentNew, out int pfSaveCanceled)
        {
            pbstrMkDocumentNew = null;
            pfSaveCanceled = 0;
            int hr = VSConstants.S_OK;

            switch (dwSave)
            {
                case VSSAVEFLAGS.VSSAVE_Save:
                case VSSAVEFLAGS.VSSAVE_SilentSave:
                    {
                        IVsQueryEditQuerySave2 queryEditQuerySave = (IVsQueryEditQuerySave2)GetService(typeof(SVsQueryEditQuerySave));

                        // Call QueryEditQuerySave
                        uint result = 0;
                        hr = queryEditQuerySave.QuerySaveFile(
                                fileName,        // filename
                                0,    // flags
                                null,            // file attributes
                                out result);    // result
                        if (ErrorHandler.Failed(hr))
                            return hr;

                        // Process according to result from QuerySave
                        switch ((tagVSQuerySaveResult)result)
                        {
                            case tagVSQuerySaveResult.QSR_NoSave_Cancel:
                                // Note that this is also case tagVSQuerySaveResult.QSR_NoSave_UserCanceled because these
                                // two tags have the same value.
                                pfSaveCanceled = ~0;
                                break;

                            case tagVSQuerySaveResult.QSR_SaveOK:
                                {
                                    // Call the shell to do the save for us
                                    IVsUIShell uiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
                                    hr = uiShell.SaveDocDataToFile(dwSave, (IPersistFileFormat)this, fileName, out pbstrMkDocumentNew, out pfSaveCanceled);
                                    if (ErrorHandler.Failed(hr))
                                        return hr;
                                }
                                break;

                            case tagVSQuerySaveResult.QSR_ForceSaveAs:
                                {
                                    // Call the shell to do the SaveAS for us
                                    IVsUIShell uiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
                                    hr = uiShell.SaveDocDataToFile(VSSAVEFLAGS.VSSAVE_SaveAs, (IPersistFileFormat)this, fileName, out pbstrMkDocumentNew, out pfSaveCanceled);
                                    if (ErrorHandler.Failed(hr))
                                        return hr;
                                }
                                break;

                            case tagVSQuerySaveResult.QSR_NoSave_Continue:
                                // In this case there is nothing to do.
                                break;

                            default:
                                throw new NotSupportedException("Unsupported result from QEQS");
                        }
                        break;
                    }
                case VSSAVEFLAGS.VSSAVE_SaveAs:
                case VSSAVEFLAGS.VSSAVE_SaveCopyAs:
                    {
                        // Make sure the file name as the right extension
                        if (String.Compare(MyExtension, System.IO.Path.GetExtension(fileName), true, CultureInfo.CurrentCulture) != 0)
                        {
                            fileName += MyExtension;
                        }
                        // Call the shell to do the save for us
                        IVsUIShell uiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
                        hr = uiShell.SaveDocDataToFile(dwSave, (IPersistFileFormat)this, fileName, out pbstrMkDocumentNew, out pfSaveCanceled);
                        if (ErrorHandler.Failed(hr))
                            return hr;
                        break;
                    }
                default:
                    throw new ArgumentException("Unsupported Save flag");
            };

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Loads the document data from the file specified
        /// </summary>
        /// <param name="pszMkDocument">Path to the document file which needs to be loaded</param>
        /// <returns>S_Ok if the method succeeds</returns>
        int IVsPersistDocData.LoadDocData(string pszMkDocument)
        {
            return ((IPersistFileFormat)this).Load(pszMkDocument, 0, 0);
        }

        /// <summary>
        /// Used to set the initial name for unsaved, newly created document data
        /// </summary>
        /// <param name="pszDocDataPath">String containing the path to the document. We need to ignore this parameter
        /// </param>
        /// <returns>S_OK if the mthod succeeds</returns>
        int IVsPersistDocData.SetUntitledDocPath(string pszDocDataPath)
        {
            return ((IPersistFileFormat)this).InitNew(MyFormat);
        }

        /// <summary>
        /// Returns the Guid of the editor factory that created the IVsPersistDocData object
        /// </summary>
        /// <param name="pClassID">Pointer to the class identifier of the editor type</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IVsPersistDocData.GetGuidEditorType(out Guid pClassID)
        {
            return ((IPersistFileFormat)this).GetClassID(out pClassID);
        }

        /// <summary>
        /// Close the IVsPersistDocData object
        /// </summary>
        /// <returns>S_OK if the function succeeds</returns>
        int IVsPersistDocData.Close()
        {
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Determines if it is possible to reload the document data
        /// </summary>
        /// <param name="pfReloadable">set to 1 if the document can be reloaded</param>
        /// <returns>S_OK if the method succeeds</returns>
        int IVsPersistDocData.IsDocDataReloadable(out int pfReloadable)
        {
            // Allow file to be reloaded
            pfReloadable = 1;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Renames the document data
        /// </summary>
        /// <param name="grfAttribs"></param>
        /// <param name="pHierNew"></param>
        /// <param name="itemidNew"></param>
        /// <param name="pszMkDocumentNew"></param>
        /// <returns></returns>
        int IVsPersistDocData.RenameDocData(uint grfAttribs, IVsHierarchy pHierNew, uint itemidNew, string pszMkDocumentNew)
        {
            // TODO:  Add EditorPane.RenameDocData implementation
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Reloads the document data
        /// </summary>
        /// <param name="grfFlags">Flag indicating whether to ignore the next file change when reloading the document data.
        /// This flag should not be set for us since we implement the "IVsDocDataFileChangeControl" interface in order to 
        /// indicate ignoring of file changes
        /// </param>
        /// <returns>S_OK if the mthod succeeds</returns>
        int IVsPersistDocData.ReloadDocData(uint grfFlags)
        {
            return ((IPersistFileFormat)this).Load(fileName, grfFlags, 0);
        }

        /// <summary>
        /// Called by the Running Document Table when it registers the document data. 
        /// </summary>
        /// <param name="docCookie">Handle for the document to be registered</param>
        /// <param name="pHierNew">Pointer to the IVsHierarchy interface</param>
        /// <param name="itemidNew">Item identifier of the document to be registered from VSITEM</param>
        /// <returns></returns>
        int IVsPersistDocData.OnRegisterDocData(uint docCookie, IVsHierarchy pHierNew, uint itemidNew)
        {
            //Nothing to do here
            return VSConstants.S_OK;
        }

        #endregion

        #region IVsFileChangeEvents Members

        /// <summary>
        /// Notify the editor of the changes made to one or more files
        /// </summary>
        /// <param name="cChanges">Number of files that have changed</param>
        /// <param name="rgpszFile">array of the files names that have changed</param>
        /// <param name="rggrfChange">Array of the flags indicating the type of changes</param>
        /// <returns></returns>
        int IVsFileChangeEvents.FilesChanged(uint cChanges, string[] rgpszFile, uint[] rggrfChange)
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "\t**** Inside FilesChanged ****"));

            //check the different parameters
            if (0 == cChanges || null == rgpszFile || null == rggrfChange)
                return VSConstants.E_INVALIDARG;

            //ignore file changes if we are in that mode
            if (ignoreFileChangeLevel != 0)
                return VSConstants.S_OK;

            for (uint i = 0; i < cChanges; i++)
            {
                if (!String.IsNullOrEmpty(rgpszFile[i]) && String.Compare(rgpszFile[i], fileName, true, CultureInfo.CurrentCulture) == 0)
                {
                    // if the readonly state (file attributes) have changed we can immediately update
                    // the editor to match the new state (either readonly or not readonly) immediately
                    // without prompting the user.
                    if (0 != (rggrfChange[i] & (int)_VSFILECHANGEFLAGS.VSFILECHG_Attr))
                    {
                        FileAttributes fileAttrs = File.GetAttributes(fileName);
                        int isReadOnly = (int)fileAttrs & (int)FileAttributes.ReadOnly;
                        SetReadOnly(isReadOnly != 0);
                    }
                    // if it looks like the file contents have changed (either the size or the modified
                    // time has changed) then we need to prompt the user to see if we should reload the
                    // file. it is important to not syncronisly reload the file inside of this FilesChanged
                    // notification. first it is possible that there will be more than one FilesChanged 
                    // notification being sent (sometimes you get separate notifications for file attribute
                    // changing and file size/time changing). also it is the preferred UI style to not
                    // prompt the user until the user re-activates the environment application window.
                    // this is why we use a timer to delay prompting the user.
                    if (0 != (rggrfChange[i] & (int)(_VSFILECHANGEFLAGS.VSFILECHG_Time | _VSFILECHANGEFLAGS.VSFILECHG_Size)))
                    {
                        if (!fileChangedTimerSet)
                        {
                            FileChangeTrigger = new Timer();
                            fileChangedTimerSet = true;
                            FileChangeTrigger.Interval = 1000;
                            FileChangeTrigger.Tick += new EventHandler(this.OnFileChangeEvent);
                            FileChangeTrigger.Enabled = true;
                        }
                    }
                }
            }

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Notify the editor of the changes made to a directory
        /// </summary>
        /// <param name="pszDirectory">Name of the directory that has changed</param>
        /// <returns></returns>
        int IVsFileChangeEvents.DirectoryChanged(string pszDirectory)
        {
            //Nothing to do here
            return VSConstants.S_OK;
        }
        #endregion

        #region IVsDocDataFileChangeControl Members

        /// <summary>
        /// Used to determine whether changes to DocData in files should be ignored or not
        /// </summary>
        /// <param name="fIgnore">a non zero value indicates that the file changes should be ignored
        /// </param>
        /// <returns></returns>
        int IVsDocDataFileChangeControl.IgnoreFileChanges(int fIgnore)
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "\t **** Inside IgnoreFileChanges ****"));

            if (fIgnore != 0)
            {
                ignoreFileChangeLevel++;
            }
            else
            {
                if (ignoreFileChangeLevel > 0)
                    ignoreFileChangeLevel--;

                // We need to check here if our file has changed from "Read Only"
                // to "Read/Write" or vice versa while the ignore level was non-zero.
                // This may happen when a file is checked in or out under source
                // code control. We need to check here so we can update our caption.
                FileAttributes fileAttrs = File.GetAttributes(fileName);
                int isReadOnly = (int)fileAttrs & (int)FileAttributes.ReadOnly;
                SetReadOnly(isReadOnly != 0);
            }
            return VSConstants.S_OK;
        }
        #endregion

        #region File Change Notification Helpers

        /// <summary>
        /// In this function we inform the shell when we wish to receive 
        /// events when our file is changed or we inform the shell when 
        /// we wish not to receive events anymore.
        /// </summary>
        /// <param name="pszFileName">File name string</param>
        /// <param name="fStart">TRUE indicates advise, FALSE indicates unadvise.</param>
        /// <returns>Result of teh operation</returns>
        private int SetFileChangeNotification(string pszFileName, bool fStart)
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "\t **** Inside SetFileChangeNotification ****"));

            int result = VSConstants.E_FAIL;

            //Get the File Change service
            if (null == vsFileChangeEx)
                vsFileChangeEx = (IVsFileChangeEx)GetService(typeof(SVsFileChangeEx));
            if (null == vsFileChangeEx)
                return VSConstants.E_UNEXPECTED;

            // Setup Notification if fStart is TRUE, Remove if fStart is FALSE.
            if (fStart)
            {
                if (vsFileChangeCookie == VSConstants.VSCOOKIE_NIL)
                {
                    //Receive notifications if either the attributes of the file change or 
                    //if the size of the file changes or if the last modified time of the file changes
                    result = vsFileChangeEx.AdviseFileChange(pszFileName,
                        (uint)(_VSFILECHANGEFLAGS.VSFILECHG_Attr | _VSFILECHANGEFLAGS.VSFILECHG_Size | _VSFILECHANGEFLAGS.VSFILECHG_Time),
                        (IVsFileChangeEvents)this,
                        out vsFileChangeCookie);
                    if (vsFileChangeCookie == VSConstants.VSCOOKIE_NIL)
                        return VSConstants.E_FAIL;
                }
            }
            else
            {
                if (vsFileChangeCookie != VSConstants.VSCOOKIE_NIL)
                {
                    result = vsFileChangeEx.UnadviseFileChange(vsFileChangeCookie);
                    vsFileChangeCookie = VSConstants.VSCOOKIE_NIL;
                }
            }
            return result;
        }

        /// <summary>
        /// In this function we suspend receiving file change events for
        /// a file or we reinstate a previously suspended file depending
        /// on the value of the given fSuspend flag.
        /// </summary>
        /// <param name="pszFileName">File name string</param>
        /// <param name="fSuspend">TRUE indicates that the events needs to be suspended</param>
        /// <returns></returns>

        private int SuspendFileChangeNotification(string pszFileName, int fSuspend)
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "\t **** Inside SuspendFileChangeNotification ****"));

            if (null == vsFileChangeEx)
                vsFileChangeEx = (IVsFileChangeEx)GetService(typeof(SVsFileChangeEx));
            if (null == vsFileChangeEx)
                return VSConstants.E_UNEXPECTED;

            if (0 == fSuspend)
            {
                // we are transitioning from suspended to non-suspended state - so force a
                // sync first to avoid asynchronous notifications of our own change
                if (vsFileChangeEx.SyncFile(pszFileName) == VSConstants.E_FAIL)
                    return VSConstants.E_FAIL;
            }

            //If we use the VSCOOKIE parameter to specify the file, then pszMkDocument parameter 
            //must be set to a null reference and vice versa 
            return vsFileChangeEx.IgnoreFile(vsFileChangeCookie, null, fSuspend);
        }
        #endregion

        #region IVsFileBackup Members

        /// <summary>
        /// This method is used to Persist the data to a single file. On a successful backup this 
        /// should clear up the backup dirty bit
        /// </summary>
        /// <param name="pszBackupFileName">Name of the file to persist</param>
        /// <returns>S_OK if the data can be successfully persisted.
        /// This should return STG_S_DATALOSS or STG_E_INVALIDCODEPAGE if there is no way to 
        /// persist to a file without data loss
        /// </returns>
        int IVsFileBackup.BackupFile(string pszBackupFileName)
        {
            try
            {
                editorControl.RichTextBoxControl.SaveFile(pszBackupFileName);
                backupObsolete = false;
            }
            catch (ArgumentException)
            {
                return VSConstants.E_FAIL;
            }
            catch (IOException)
            {
                return VSConstants.E_FAIL;
            }
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Used to set the backup dirty bit. This bit should be set when the object is modified 
        /// and cleared on calls to BackupFile and any Save method
        /// </summary>
        /// <param name="pbObsolete">the dirty bit to be set</param>
        /// <returns>returns 1 if the backup dirty bit is set, 0 otherwise</returns>
        int IVsFileBackup.IsBackupFileObsolete(out int pbObsolete)
        {
            if (backupObsolete)
                pbObsolete = 1;
            else
                pbObsolete = 0;
            return VSConstants.S_OK;
        }

        #endregion

        #region IVsToolboxUser Interface
        public int IsSupported(Microsoft.VisualStudio.OLE.Interop.IDataObject pDO)
        {
            // Create a OleDataObject from the input interface.
            OleDataObject oleData = new OleDataObject(pDO);
            // && editorControl.RichTextBoxControl.CanPaste(DataFormats.GetFormat(DataFormats.UnicodeText))
            // Check if the data object is of type UnicodeText.
            if (oleData.GetDataPresent(DataFormats.UnicodeText))
            {
                return VSConstants.S_OK;
            }

            // In all the other cases return S_FALSE
            return VSConstants.S_FALSE;
        }

        public int ItemPicked(Microsoft.VisualStudio.OLE.Interop.IDataObject pDO)
        {
            // Create a OleDataObject from the input interface.
            OleDataObject oleData = new OleDataObject(pDO);

            // Check if the picked item is the one we can paste.
            if (oleData.GetDataPresent(DataFormats.UnicodeText))
            {
                object o = null;
                editorControl.TextSelection.Paste(ref o, 0);
            }

            return VSConstants.S_OK;
        }
        #endregion

        /// <summary>
        /// Used to ReadOnly property for the Rich TextBox and correspondingly update the editor caption
        /// </summary>
        /// <param name="_isFileReadOnly">Indicates whether the file loaded is Read Only or not</param>
        private void SetReadOnly(bool _isFileReadOnly)
        {
            this.editorControl.RichTextBoxControl.ReadOnly = _isFileReadOnly;

            //update editor caption with "[Read Only]" or "" as necessary
            IVsWindowFrame frame = (IVsWindowFrame)GetService(typeof(SVsWindowFrame));
            string editorCaption = "";
            if (_isFileReadOnly)
                editorCaption = this.GetResourceString("@100");
            ErrorHandler.ThrowOnFailure(frame.SetProperty((int)__VSFPROPID.VSFPROPID_EditorCaption, editorCaption));
            backupObsolete = true;
        }

        /// <summary>
        /// This event is triggered when one of the files loaded into the environment has changed outside of the
        /// editor
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnFileChangeEvent(object sender, System.EventArgs e)
        {
            //Disable the timer
            FileChangeTrigger.Enabled = false;

            string message = this.GetResourceString("@101");    //get the message string from the resource
            IVsUIShell VsUiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
            int result = 0;
            Guid tempGuid = Guid.Empty;
            if (VsUiShell != null)
            {
                //Show up a message box indicating that the file has changed outside of VS environment
                ErrorHandler.ThrowOnFailure(VsUiShell.ShowMessageBox(0, ref tempGuid, fileName, message, null, 0,
                    OLEMSGBUTTON.OLEMSGBUTTON_YESNOCANCEL, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST,
                    OLEMSGICON.OLEMSGICON_QUERY, 0, out result));
            }
            //if the user selects "Yes", reload the current file
            if (result == (int)DialogResult.Yes)
            {
                ErrorHandler.ThrowOnFailure(((IVsPersistDocData)this).ReloadDocData(0));
            }

            fileChangedTimerSet = false;
        }

        /// <summary>
        /// This method loads a localized string based on the specified resource.
        /// </summary>
        /// <param name="resourceName">Resource to load</param>
        /// <returns>String loaded for the specified resource</returns>
        internal string GetResourceString(string resourceName)
        {
            string resourceValue;
            IVsResourceManager resourceManager = (IVsResourceManager)GetService(typeof(SVsResourceManager));
            if (resourceManager == null)
            {
                throw new InvalidOperationException("Could not get SVsResourceManager service. Make sure the package is Sited before calling this method");
            }
            Guid packageGuid = myPackage.GetType().GUID;
            int hr = resourceManager.LoadResourceString(ref packageGuid, -1, resourceName, out resourceValue);
            Microsoft.VisualStudio.ErrorHandler.ThrowOnFailure(hr);
            return resourceValue;
        }

        /// <summary>
        /// This function asks to the QueryEditQuerySave service if it is possible to
        /// edit the file.
        /// </summary>
        private bool CanEditFile()
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "\t**** CanEditFile called ****"));

            // Check the status of the recursion guard
            if (gettingCheckoutStatus)
                return false;

            try
            {
                // Set the recursion guard
                gettingCheckoutStatus = true;

                // Get the QueryEditQuerySave service
                IVsQueryEditQuerySave2 queryEditQuerySave = (IVsQueryEditQuerySave2)GetService(typeof(SVsQueryEditQuerySave));

                // Now call the QueryEdit method to find the edit status of this file
                string[] documents = { this.fileName };
                uint result;
                uint outFlags;

                // Note that this function can popup a dialog to ask the user to checkout the file.
                // When this dialog is visible, it is possible to receive other request to change
                // the file and this is the reason for the recursion guard.
                int hr = queryEditQuerySave.QueryEditFiles(
                    0,              // Flags
                    1,              // Number of elements in the array
                    documents,      // Files to edit
                    null,           // Input flags
                    null,           // Input array of VSQEQS_FILE_ATTRIBUTE_DATA
                    out result,     // result of the checkout
                    out outFlags    // Additional flags
                );
                if (ErrorHandler.Succeeded(hr) && (result == (uint)tagVSQueryEditResult.QER_EditOK))
                {
                    // In this case (and only in this case) we can return true from this function.
                    return true;
                }
            }

            finally
            {
                gettingCheckoutStatus = false;
            }
            return false;
        }

        /// <summary>
        /// This event is triggered when there contents of the file are changed inside the editor
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1806:DoNotIgnoreMethodResults", MessageId = "Microsoft.VisualStudio.Shell.Interop.ITrackSelection.OnSelectChange(Microsoft.VisualStudio.Shell.Interop.ISelectionContainer)")]
        private void OnTextChange(object sender, System.EventArgs e)
        {
            // During the load operation the text of the control will change, but
            // this change must not be stored in the status of the document.
            if (!loading)
            {
                // The only interesting case is when we are changing the document
                // for the first time
                if (!isDirty)
                {
                    // Check if the QueryEditQuerySave service allow us to change the file
                    if (!CanEditFile())
                    {
                        // We can not change the file (e.g. a checkout operation failed),
                        // so undo the change and exit.
                        editorControl.RichTextBoxControl.Undo();
                        return;
                    }

                    // It is possible to change the file, so update the status.
                    isDirty = true;
                    ITrackSelection track = TrackSelection;
                    if (null != track)
                    {
                        // Note: here we don't need to check the return code.
                        track.OnSelectChange((ISelectionContainer)selContainer);
                    }
                    backupObsolete = true;
                }
            }
        }

        /// <summary>
        /// This event is triggered when the control's GotFocus event is fired.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OnGotFocus(object sender, System.EventArgs e)
        {
            if (null == FNFStatusbarTrigger)
                FNFStatusbarTrigger = new Timer();

            FileChangeTrigger.Interval = 1000;
            FNFStatusbarTrigger.Tick += new EventHandler(this.OnSetStatusBar);
            FNFStatusbarTrigger.Start();
        }

        private void OnSetStatusBar(object sender, System.EventArgs e)
        {
            FNFStatusbarTrigger.Stop();
            ErrorHandler.ThrowOnFailure(((IVsStatusbarUser)this).SetInfo());
        }

        #region IVsStatusbarUser Members

        /// <summary>
        /// This is the IVsStatusBarUser function that will update our status bar.
        /// Note that the IDE calls this function only when our document window is
        /// initially activated.
        /// </summary>
        /// <returns> Hresult that represents success or failure.</returns>
        int IVsStatusbarUser.SetInfo()
        {
            // Call the helper function that updates the status bar insert mode
            int hrSetInsertMode = SetStatusBarInsertMode();

            // Call the helper function that updates the status bar selection mode
            int hrSetSelectionMode = SetStatusBarSelectionMode();

            // Call the helper function that updates the status bar position
            int hrSetPosition = SetStatusBarPosition();

            return (hrSetInsertMode == VSConstants.S_OK &&
                    hrSetSelectionMode == VSConstants.S_OK &&
                    hrSetPosition == VSConstants.S_OK) ? VSConstants.S_OK : VSConstants.E_FAIL;
        }

        /// <summary>
        /// Helper function that updates the insert mode displayed on the status bar.
        /// This is the text that is displayed in the right side of the status bar that
        /// will either say INS or OVR.
        /// </summary>
        /// <returns> Hresult that represents success or failure.</returns>
        int SetStatusBarInsertMode()
        {
            // Get the IVsStatusBar interface
            IVsStatusbar statusBar = GetService(typeof(SVsStatusbar)) as IVsStatusbar;
            if (statusBar == null)
                return VSConstants.E_FAIL;

            // Set the insert mode based on our editorControl.richTextBoxCtrl.Overstrike value.  If 1 is passed
            // in then it will display OVR and if 0 is passed in it will display INS.
            object insertMode = (object)(this.editorControl.Overstrike ? 1 : 0);
            return statusBar.SetInsMode(ref insertMode);
        }

        /// <summary>
        /// This is an extra command handler that we will use to check when the insert
        /// key is pressed.  Note that even if we detect that the insert key is pressed
        /// we are not setting the handled property to true, so other event handlers will
        /// also see it.
        /// </summary>
        /// <param name="sender"> Not used.</param>
        /// <param name="e"> KeyEventArgs instance that we will use to get the key that was pressed.</param>
        private void OnKeyDown(object sender, KeyEventArgs e)
        {
            // If the key pressed is the insert key...
            if (e.KeyValue == 45)
            {
                // Toggle our stored insert value
                this.editorControl.Overstrike = !this.editorControl.Overstrike;

                // Call the function to update the status bar insert mode
                SetStatusBarInsertMode();
            }
        }

        /// <summary>
        /// Helper function that updates the selection mode displayed on the status
        /// bar.  Right now we only support stream selection.
        /// </summary>
        /// <returns> Hresult that represents success or failure.</returns>
        int SetStatusBarSelectionMode()
        {
            // Get the IVsStatusBar interface.
            IVsStatusbar statusBar = GetService(typeof(SVsStatusbar)) as IVsStatusbar;
            if (statusBar == null)
                return VSConstants.E_FAIL;

            // Set the selection mode.  Since we only support stream selection we will
            // always pass in zero here.  Passing in one would make "COL" show up
            // just to the left of the insert mode on the status bar.
            object selectionMode = 0;
            return statusBar.SetSelMode(ref selectionMode);
        }

        /// <summary>
        /// Helper function that updates the cursor position displayed on the status bar.
        /// </summary>
        /// <returns> Hresult that represents success or failure.</returns>
        int SetStatusBarPosition()
        {
            // Get the IVsStatusBar interface.
            IVsStatusbar statusBar = GetService(typeof(SVsStatusbar)) as IVsStatusbar;
            if (statusBar == null)
                return VSConstants.E_FAIL;

            // If there is no selection then textBox1.SelectionStart will tell us
            // the position of the cursor.  If there is a selection then this value will tell
            // us the position of the "left" side of the selection (the side of the selection that
            // has the smaller index value).
            int startIndex = editorControl.RichTextBoxControl.SelectionStart;

            // If the cursor is at the end of the selection then we need to add the selection
            // length to the index value.
            if ((editorControl.TextSelection.Flags & (int)tom.tomConstants.tomSelStartActive) == 0)
                startIndex += editorControl.RichTextBoxControl.SelectionLength;

            // Call the function that gets the (zero-based) line index based on the buffer index.
            int lineNumber = editorControl.RichTextBoxControl.GetLineFromCharIndex(startIndex);

            // To get the (zero-based) character number subtract the index of the first character
            // on this line from the buffer index.
            int charNumber = startIndex - editorControl.RichTextBoxControl.GetFirstCharIndexFromLine(lineNumber);

            // Call the SetLineChar function, making sure to add one to our line and
            // character values since the values we get from the RichTextBox calls
            // are zero based.
            object line = (object)(lineNumber + 1);
            object chr = (object)(charNumber + 1);

            // Call the IVsStatusBar's SetLineChar function and return it's hresult
            return statusBar.SetLineChar(ref line, ref chr);
        }

        #endregion

        #region IVsFindTarget Members

        /// <summary>
        /// Return the object that was requested
        /// </summary>
        /// <param name="propid">Id of the requested object</param>
        /// <param name="pvar">Object returned</param>
        /// <returns>HResult</returns>
        int IVsFindTarget.GetProperty(uint propid, out object pvar)
        {
            pvar = null;

            switch (propid)
            {
                case (uint)__VSFTPROPID.VSFTPROPID_DocName:
                    {
                        // Return a copy of the file name
                        pvar = fileName;
                        break;
                    }
                case (uint)__VSFTPROPID.VSFTPROPID_InitialPattern:
                case (uint)__VSFTPROPID.VSFTPROPID_InitialPatternAggressive:
                    {
                        // Return the selected text
                        GetInitialSearchString(out pvar);
                        //pvar = editorControl.RichTextBoxControl.SelectedText;
                        break;
                    }
                case (uint)__VSFTPROPID.VSFTPROPID_WindowFrame:
                    {
                        // Return the Window frame
                        pvar = (IVsWindowFrame)GetService(typeof(SVsWindowFrame));
                        break;
                    }
                case (uint)__VSFTPROPID.VSFTPROPID_IsDiskFile:
                    {
                        // We currently assume the file is on disk
                        pvar = true;
                        break;
                    }
                default:
                    {
                        return VSConstants.E_NOTIMPL;
                    }
            }

            return VSConstants.S_OK;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="grfOptions"></param>
        /// <param name="ppSpans"></param>
        /// <param name="ppTextImage"></param>
        int IVsFindTarget.GetSearchImage(uint grfOptions, IVsTextSpanSet[] ppSpans, out IVsTextImage ppTextImage)
        {
            //set the IVsTextSpanSet object
            if (null != ppSpans && ppSpans.Length > 0)
            {
                ppSpans[0] = (IVsTextSpanSet)this;
            }

            //set the IVsTextImage object
            ppTextImage = (IVsTextImage)this;

            //attach this text image to the span
            if (null != ppSpans && ppSpans.Length > 0)
            {
                ErrorHandler.ThrowOnFailure(ppSpans[0].AttachTextImage(ppTextImage));
            }

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Retrieve a previously stored object
        /// </summary>
        /// <returns>The object that is being asked</returns>
        int IVsFindTarget.GetFindState(out object ppunk)
        {
            ppunk = findState;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Search for the string in the text of our editor.
        /// Options specify how we do the search. No need to implement this since we implment IVsTextImage
        /// </summary>
        /// <param name="pszSearch">Search string</param>
        /// <param name="grfOptions">Search options</param>
        /// <param name="fResetStartPoint">Is this a new search?</param>
        /// <param name="pHelper">We are not using it</param>
        /// <param name="pResult">True if we found the search string</param>
        int IVsFindTarget.Find(string pszSearch, uint grfOptions, int fResetStartPoint, IVsFindHelper pHelper, out uint pResult)
        {
            pResult = 0;

            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// Bring the focus to a specific position in the document
        /// </summary>
        /// <param name="pts">Location where to move the cursor to</param>
        int IVsFindTarget.NavigateTo(TextSpan[] pts)
        {
            int hr = VSConstants.S_OK;

            // Activate the window
            IVsWindowFrame frame = (IVsWindowFrame)GetService(typeof(SVsWindowFrame));
            if (frame != null)
                hr = frame.Show();
            else
                return VSConstants.E_NOTIMPL;

            // Now navigate to the specified location (if any)
            if (ErrorHandler.Succeeded(hr) && (null != pts) && (pts.Length > 0))
            {
                // first set start location
                int NewPosition = editorControl.RichTextBoxControl.GetFirstCharIndexFromLine(pts[0].iStartLine);
                NewPosition += pts[0].iStartIndex;
                if (NewPosition > editorControl.RichTextBoxControl.Text.Length)
                    NewPosition = editorControl.RichTextBoxControl.Text.Length;
                editorControl.RichTextBoxControl.SelectionStart = NewPosition;

                // now set the length of the selection
                NewPosition = editorControl.RichTextBoxControl.GetFirstCharIndexFromLine(pts[0].iEndLine);
                NewPosition += pts[0].iEndIndex;
                if (NewPosition > editorControl.RichTextBoxControl.Text.Length)
                    NewPosition = editorControl.RichTextBoxControl.Text.Length;
                int length = NewPosition - editorControl.RichTextBoxControl.SelectionStart;
                if (length >= 0)
                    editorControl.RichTextBoxControl.SelectionLength = length;
                else
                    editorControl.RichTextBoxControl.SelectionLength = 0;
            }
            return hr;
        }

        /// <summary>
        /// Get current cursor location
        /// </summary>
        /// <param name="pts">Current location</param>
        /// <returns>Hresult</returns>
        int IVsFindTarget.GetCurrentSpan(TextSpan[] pts)
        {
            if (null == pts || 0 == pts.Length)
                return VSConstants.E_INVALIDARG;

            pts[0].iStartIndex = editorControl.GetColumnFromIndex(editorControl.RichTextBoxControl.SelectionStart);
            pts[0].iEndIndex = editorControl.GetColumnFromIndex(editorControl.RichTextBoxControl.SelectionStart + editorControl.RichTextBoxControl.SelectionLength);
            pts[0].iStartLine = editorControl.RichTextBoxControl.GetLineFromCharIndex(editorControl.RichTextBoxControl.SelectionStart);
            pts[0].iEndLine = editorControl.RichTextBoxControl.GetLineFromCharIndex(editorControl.RichTextBoxControl.SelectionStart + editorControl.RichTextBoxControl.SelectionLength);

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Highlight a given text span. No need to implement
        /// </summary>
        /// <param name="pts"></param>
        /// <returns></returns>
        int IVsFindTarget.MarkSpan(TextSpan[] pts)
        {
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// Replace a string in the text. No need to implement since we implement IVsTextImage
        /// </summary>
        /// <param name="pszSearch">string containing the search text</param>
        /// <param name="pszReplace">string xontaining the replacement text</param>
        /// <param name="grfOptions">Search options available</param>
        /// <param name="fResetStartPoint">flag to reset the search start point</param>
        /// <param name="pHelper">IVsFindHelper interface object</param>
        /// <param name="pfReplaced">returns whether replacement was successful or not</param>
        /// <returns></returns>
        int IVsFindTarget.Replace(string pszSearch, string pszReplace, uint grfOptions, int fResetStartPoint, IVsFindHelper pHelper, out int pfReplaced)
        {
            pfReplaced = 0;

            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// Store an object that will later be returned
        /// </summary>
        /// <returns>The object that is being stored</returns>
        int IVsFindTarget.SetFindState(object pUnk)
        {
            findState = pUnk;
            return VSConstants.S_OK;
        }


        /// <summary>
        /// This implementation does not use notification
        /// </summary>
        /// <param name="notification"></param>
        int IVsFindTarget.NotifyFindTarget(uint notification)
        {
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Specify which search option we support.
        /// </summary>
        /// <param name="pfImage">Do we support IVsTextImage?</param>
        /// <param name="pgrfOptions">Supported options</param>
        int IVsFindTarget.GetCapabilities(bool[] pfImage, uint[] pgrfOptions)
        {
            // We do support IVsTextImage
            if (pfImage != null && pfImage.Length > 0)
                pfImage[0] = true;

            if (pgrfOptions != null && pgrfOptions.Length > 0)
            {
                pgrfOptions[0] = (uint)__VSFINDOPTIONS.FR_Backwards;        //Search backwards from the insertion point
                pgrfOptions[0] |= (uint)__VSFINDOPTIONS.FR_MatchCase;       //Match the case while searching
                pgrfOptions[0] |= (uint)__VSFINDOPTIONS.FR_WholeWord;       //Match whole word while searching
                pgrfOptions[0] |= (uint)__VSFINDOPTIONS.FR_Selection;       //Search in selected text only
                pgrfOptions[0] |= (uint)__VSFINDOPTIONS.FR_ActionMask;      //Find/Replace capabilities

                // Only support selection if something is selected
                if (editorControl.RichTextBoxControl.SelectionLength == 0)
                    pgrfOptions[0] &= ~((uint)__VSFINDOPTIONS.FR_Selection);

                //if the file is read only, don't support replace
                if (editorControl.RichTextBoxControl.ReadOnly)
                    pgrfOptions[0] &= ~((uint)__VSFINDOPTIONS.FR_Replace | (uint)__VSFINDOPTIONS.FR_ReplaceAll);
            }
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Return the Screen coordinates of the matched string. No need to implement
        /// </summary>
        /// <param name="prc"></param>
        /// <returns></returns>
        int IVsFindTarget.GetMatchRect(RECT[] prc)
        {
            return VSConstants.E_NOTIMPL;
        }

        #endregion

        /// <summary>
        /// Function to return the string to be used in the "Find What" field of the find window. Will return
        /// null if no text is selected or if there are multiple lines of text selected.
        /// </summary>
        /// <param name="pvar">the string to be returned</param>
        private void GetInitialSearchString(out object pvar)
        {
            //If no text is selected, return null
            if (0 == editorControl.RichTextBoxControl.SelectionLength)
            {
                pvar = null;
                return;
            }

            //Now check if multiple lines have been selected
            int endIndex = editorControl.RichTextBoxControl.SelectionStart + editorControl.RichTextBoxControl.SelectionLength;
            int endline = editorControl.RichTextBoxControl.GetLineFromCharIndex(endIndex);
            int startline = editorControl.RichTextBoxControl.GetLineFromCharIndex(editorControl.RichTextBoxControl.SelectionStart);
            if (startline != endline)
            {
                pvar = null;
                return;
            }

            pvar = editorControl.RichTextBoxControl.SelectedText;
        }

        #region IVsTextImage members

        /// <summary>
        /// To return the number of characters in the text image. No need to implement
        /// </summary>
        /// <param name="pcch">contain the number of characters</param>
        /// <returns></returns>
        int IVsTextImage.GetCharSize(out int pcch)
        {
            pcch = 0;
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// To return the number of lines in the text image
        /// </summary>
        /// <param name="pcLines">pointer to the number of lines in the text image</param>
        /// <returns>S_OK</returns>
        int IVsTextImage.GetLineSize(out int pcLines)
        {
            //get the number of the lines in the control
            int len = editorControl.RichTextBoxControl.Lines.Length;
            pcLines = len;

            return VSConstants.S_OK;
        }

        /// <summary>
        /// To return the buffer address of the given text address. No need to implement
        /// </summary>
        /// <param name="ta">contains the TextAddress</param>
        /// <param name="piOffset">will contain the ofset from the start of the buffer</param>
        /// <returns></returns>
        int IVsTextImage.GetOffsetOfTextAddress(TextAddress ta, out int piOffset)
        {
            piOffset = 0;
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// To return the text address of the given buffer address. No need to implement
        /// </summary>
        /// <param name="iOffset">offset from the start of the buffer</param>
        /// <param name="pta">will contain the TextAddress</param>
        /// <returns></returns>
        int IVsTextImage.GetTextAddressOfOffset(int iOffset, TextAddress[] pta)
        {
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// Notification for a text span replacement
        /// </summary>
        /// <param name="dwFlags">Flags used for the replace</param>
        /// <param name="pts">Contains the TextSpan to be replaced</param>
        /// <param name="cch">count of characters in pchText</param>
        /// <param name="pchText">the replacement text</param>
        /// <param name="ptsChanged">TextSpan of the replaced text</param>
        /// <returns></returns>
        int IVsTextImage.Replace(uint dwFlags,
                                 TextSpan[] pts,
                                 int cch,
                                 string pchText,
                                 TextSpan[] ptsChanged
            )
        {
            //pts contains the span of the item which is to be replaced
            if (null == pts || 0 == pts.Length)
                return VSConstants.E_INVALIDARG;

            if (null == pchText)
                return VSConstants.E_INVALIDARG;

            // first set start location
            int NewPosition = editorControl.RichTextBoxControl.GetFirstCharIndexFromLine(pts[0].iStartLine);
            NewPosition += pts[0].iStartIndex;
            if (NewPosition > editorControl.RichTextBoxControl.Text.Length)
                NewPosition = editorControl.RichTextBoxControl.Text.Length;
            editorControl.RichTextBoxControl.SelectionStart = NewPosition;

            // now set the length of the selection
            NewPosition = editorControl.RichTextBoxControl.GetFirstCharIndexFromLine(pts[0].iEndLine);
            NewPosition += pts[0].iEndIndex;
            if (NewPosition > editorControl.RichTextBoxControl.Text.Length)
                NewPosition = editorControl.RichTextBoxControl.Text.Length;
            int length = NewPosition - editorControl.RichTextBoxControl.SelectionStart;
            if (length >= 0)
                editorControl.RichTextBoxControl.SelectionLength = length;
            else
                editorControl.RichTextBoxControl.SelectionLength = 0;

            //replace the text
            editorControl.RichTextBoxControl.SelectedText = pchText;

            if ((dwFlags & (uint)__VSFINDOPTIONS.FR_Backwards) == 0)
            {
                // In case of forward search we have to place the insertion point at the
                // end of the new text, so it will be skipped during the next call to Find.
                editorControl.RichTextBoxControl.SelectionStart += editorControl.RichTextBoxControl.SelectionLength;
            }
            else
            {
                // If the search is backward, then set the end postion at the
                // beginning of the new text.
                editorControl.RichTextBoxControl.SelectionLength = 0;
            }

            //set the ptsChanged to the TextSpan of the replaced text
            if (null != ptsChanged && ptsChanged.Length > 0)
            {
                ptsChanged[0].iStartIndex = editorControl.GetColumnFromIndex(editorControl.RichTextBoxControl.SelectionStart);
                ptsChanged[0].iEndIndex = editorControl.GetColumnFromIndex(editorControl.RichTextBoxControl.SelectionStart + editorControl.RichTextBoxControl.SelectionLength);
                ptsChanged[0].iStartLine = editorControl.RichTextBoxControl.GetLineFromCharIndex(editorControl.RichTextBoxControl.SelectionStart);
                ptsChanged[0].iEndLine = editorControl.RichTextBoxControl.GetLineFromCharIndex(editorControl.RichTextBoxControl.SelectionStart + editorControl.RichTextBoxControl.SelectionLength);
            }

            return VSConstants.S_OK;
        }

        /// <summary>
        /// To return the number of characters in a TextSpan
        /// </summary>
        /// <param name="pts">The TextSpan structure</param>
        /// <param name="pcch">will contain the number of characters</param>
        /// <returns></returns>
        int IVsTextImage.GetSpanLength(TextSpan[] pts, out int pcch)
        {
            pcch = 0;
            if (null == pts || 0 == pts.Length)
                return VSConstants.E_INVALIDARG;

            int startIndex = editorControl.GetIndexFromLineAndColumn(pts[0].iStartLine, pts[0].iStartIndex);
            if (startIndex < 0)
                return VSConstants.E_INVALIDARG;

            int endIndex = editorControl.GetIndexFromLineAndColumn(pts[0].iEndLine, pts[0].iEndIndex);
            if (endIndex < 0)
                return VSConstants.E_INVALIDARG;

            pcch = Math.Abs(endIndex - startIndex);

            return VSConstants.S_OK;
        }

        /// <summary>
        /// to return the text of a TextSpan as a BSTR
        /// </summary>
        /// <param name="pts">the TextSpan structure</param>
        /// <param name="pbstrText">the BSTR text</param>
        /// <returns></returns>
        int IVsTextImage.GetTextBSTR(TextSpan[] pts, out string pbstrText)
        {
            pbstrText = null;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// To return the text of a TextSpan. No need to implement
        /// </summary>
        /// <param name="pts">TextSpan structure</param>
        /// <param name="cch">number of characters to return</param>
        /// <param name="psz">will contain the text</param>
        /// <returns></returns>
        int IVsTextImage.GetText(TextSpan[] pts, int cch, ushort[] psz)
        {
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// To return the length of a particular line
        /// </summary>
        /// <param name="iLine">zero based line number</param>
        /// <param name="piLength">will contain the length</param>
        /// <returns></returns>
        int IVsTextImage.GetLineLength(int iLine, out int piLength)
        {
            int numberOfLines = 0;
            piLength = 0;
            ErrorHandler.ThrowOnFailure(((IVsTextImage)this).GetLineSize(out numberOfLines));

            if (iLine < 0 || iLine > numberOfLines - 1)
            {
                return VSConstants.E_INVALIDARG;
            }
            piLength = editorControl.RichTextBoxControl.Lines[iLine].Length;

            return VSConstants.S_OK;
        }

        /// <summary>
        /// To provide line oriented access to the text buffer
        /// </summary>
        /// <param name="grfGet">flags containing information on the line to get</param>
        /// <param name="iLine">zero based line number</param>
        /// <param name="iStartIndex">starting character index of the line</param>
        /// <param name="iEndIndex">ending character index of the line</param>
        /// <param name="pLineData">Will contain the filled LINEDATA structure</param>
        /// <returns></returns>
        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        int IVsTextImage.GetLine(uint grfGet,
                                        int iLine,
                                        int iStartIndex,
                                        int iEndIndex,
                                        LINEDATAEX[] pLineData
            )
        {
            if (null == pLineData || 0 == pLineData.Length)
                return VSConstants.E_INVALIDARG;

            //first intialize the Line Data object
            pLineData[0].iLength = 0;
            pLineData[0].pszText = IntPtr.Zero;
            pLineData[0].iEolType = EOLTYPE.eolCR;
            pLineData[0].pAttributes = IntPtr.Zero;
            pLineData[0].dwFlags = (ushort)LINEDATAEXFLAGS.ldfDefault;
            pLineData[0].dwReserved = 0;
            pLineData[0].pAtomicTextChain = IntPtr.Zero;

            int lineCount = editorControl.RichTextBoxControl.Lines.Length;
            if ((iLine < 0) || (iLine >= lineCount) || (iStartIndex < 0) || (iEndIndex < 0) ||
                (iStartIndex > iEndIndex))
            {
                return VSConstants.E_INVALIDARG;
            }

            string lineText = editorControl.RichTextBoxControl.Lines[iLine];
            // If the line is empty then do not attempt to calculate the span in the normal way; just return.
            if (string.IsNullOrEmpty(lineText) && iStartIndex == 0 && iEndIndex == 0)
                return VSConstants.S_OK;
            int lineLength = lineText.Length;

            //Error if startIndex is greater than the line length
            if (iStartIndex >= lineLength || iEndIndex >= lineLength)
                return VSConstants.E_INVALIDARG;

            int spanLength = iEndIndex - iStartIndex + 1;

            //Error in arguments if the span length is greater than the line length
            if (spanLength > lineLength)
                return VSConstants.E_INVALIDARG;

            //If we are looking for a subset of the line i.e. a line span
            if (0 != (grfGet & (uint)GLDE_FLAGS.gldeSubset))
            {
                pLineData[0].iLength = spanLength;
                string spanText = lineText.Substring(iStartIndex, spanLength);
                pLineData[0].pszText = new IntPtr();
                pLineData[0].pszText = Marshal.StringToCoTaskMemAuto(spanText);
            }
            //else we need to return the complete line
            else
            {
                pLineData[0].iLength = lineLength;
                pLineData[0].pszText = new IntPtr();
                pLineData[0].pszText = Marshal.StringToCoTaskMemAuto(lineText);
            }

            return VSConstants.S_OK;

        }

        /// <summary>
        /// Release the LINEDATAEX structure
        /// </summary>
        /// <param name="pLineData">pointer to the LINEDATAEX structure</param>
        /// <returns></returns>
        [SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        int IVsTextImage.ReleaseLine(LINEDATAEX[] pLineData)
        {
            if (null == pLineData || 0 == pLineData.Length)
                return VSConstants.E_INVALIDARG;

            //clear the Line Data object
            pLineData[0].iLength = 0;
            Marshal.FreeCoTaskMem(pLineData[0].pszText);
            pLineData[0].iEolType = EOLTYPE.eolNONE;
            pLineData[0].pAttributes = IntPtr.Zero;
            pLineData[0].dwFlags = (ushort)LINEDATAEXFLAGS.ldfDefault;
            pLineData[0].dwReserved = 0;
            pLineData[0].pAtomicTextChain = IntPtr.Zero;

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Registers the environment to revieve notifications of text image changes.
        /// </summary>
        /// <param name="pSink">Object requesting notification on text image changes</param>
        /// <param name="pCookie">Handle for the event sink</param>
        /// <returns></returns>
        int IVsTextImage.AdviseTextImageEvents(IVsTextImageEvents pSink, out uint pCookie)
        {
            //We don't use this
            pCookie = 0;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Cancels notification for text image changes
        /// </summary>
        /// <param name="Cookie">Handle to the event sink</param>
        /// <returns></returns>
        int IVsTextImage.UnadviseTextImageEvents(uint Cookie)
        {
            //We don't use this
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Notification from the environment that it is locking an image
        /// </summary>
        /// <param name="grfLock">the locking flag</param>
        /// <returns></returns>
        int IVsTextImage.LockImage(uint grfLock)
        {
            //We only allow one reader/writer
            if (!lockImage)
            {
                lockImage = true;
                return VSConstants.S_OK;
            }
            else
                return VSConstants.E_FAIL;
        }

        /// <summary>
        /// Notification from the environment that the text image is not in use
        /// </summary>
        /// <param name="grfLock">the locking flag</param>
        /// <returns></returns>
        int IVsTextImage.UnlockImage(uint grfLock)
        {
            lockImage = false;
            return VSConstants.S_OK;
        }

        #endregion

        #region IVsTextSpanSet Members

        /// <summary>
        /// The environment uses this to get a text image
        /// </summary>
        /// <param name="pText">Pointer to the text image</param>
        /// <returns></returns>
        int IVsTextSpanSet.AttachTextImage(object pText)
        {
            if (null == pText)
                return VSConstants.E_INVALIDARG;

            if (null != spTextImage)
            {
                if (spTextImage.Equals(pText))
                    return VSConstants.S_OK;
            }

            spTextImage = (IVsTextImage)this;

            //get the number of lines in the Text Image
            int lineCount = 0;
            ErrorHandler.ThrowOnFailure(spTextImage.GetLineSize(out lineCount));

            //create a text span for the entire text image
            TextSpan textSpan = new TextSpan();
            textSpan.iStartLine = 0;
            textSpan.iStartIndex = 0;
            textSpan.iEndLine = 0;

            //get the length of the last line
            int lastLineLength = 0;
            if (lineCount > 0)
            {
                textSpan.iEndLine = lineCount - 1;
                ErrorHandler.ThrowOnFailure(spTextImage.GetLineLength(lineCount - 1, out lastLineLength));
            }

            //set the end index corresponding to the last line length
            textSpan.iEndIndex = lastLineLength;

            //add it to the text span array
            textSpanArray.Add(textSpan);

            return VSConstants.S_OK;
        }

        /// <summary>
        /// To Release a text image
        /// </summary>
        /// <returns></returns>
        int IVsTextSpanSet.Detach()
        {
            spTextImage = null;
            textSpanArray.RemoveRange(0, textSpanArray.Count);

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Not needed to be implmented
        /// </summary>
        /// <returns></returns>
        int IVsTextSpanSet.SuspendTracking()
        {
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// Not needed to be implemented
        /// </summary>
        /// <returns></returns>
        int IVsTextSpanSet.ResumeTracking()
        {
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// To add the TExtSpan to an array at the specified location
        /// </summary>
        /// <param name="cEl">the index to insert</param>
        /// <param name="pSpan">the TextSpan object</param>
        /// <returns></returns>
        int IVsTextSpanSet.Add(int cEl, TextSpan[] pSpan)
        {
            if (null == pSpan || 0 == pSpan.Length)
                return VSConstants.E_INVALIDARG;

            if (cEl < 0)
                return VSConstants.E_INVALIDARG;

            textSpanArray.Insert(cEl, pSpan[0]);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Returns the number of text spans in the array
        /// </summary>
        /// <param name="pcel">will contain the count</param>
        /// <returns></returns>
        int IVsTextSpanSet.GetCount(out int pcel)
        {
            pcel = textSpanArray.Count;
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Return the text span at the requested index
        /// </summary>
        /// <param name="iEl">the index</param>
        /// <param name="pSpan">will contain the TextSpan returned</param>
        /// <returns></returns>
        int IVsTextSpanSet.GetAt(int iEl, TextSpan[] pSpan)
        {
            if (iEl >= textSpanArray.Count || iEl < 0)
                return VSConstants.E_INVALIDARG;

            if (null == pSpan || 0 == pSpan.Length)
                return VSConstants.E_INVALIDARG;

            pSpan[0] = (TextSpan)textSpanArray[iEl];

            return VSConstants.S_OK;
        }

        /// <summary>
        /// Clear up the text span array
        /// </summary>
        /// <returns></returns>
        int IVsTextSpanSet.RemoveAll()
        {
            textSpanArray.RemoveRange(0, textSpanArray.Count);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// No need to implement this
        /// </summary>
        /// <param name="sortOptions"></param>
        /// <returns></returns>
        int IVsTextSpanSet.Sort(uint SortOptions)
        {
            return VSConstants.E_NOTIMPL;
        }

        /// <summary>
        /// No need to implement this
        /// </summary>
        /// <param name="pEnum"></param>
        /// <returns></returns>
        int IVsTextSpanSet.AddFromEnum(IVsEnumTextSpans pEnum)
        {
            return VSConstants.E_NOTIMPL;
        }
        #endregion

        #region IVsTextBuffer Members

        /*The IVsTextBuffer interface is used to provide just general information about the Text Buffer used
        by the Editor. For our sample this is just provided so that the find in files scenario will work 
        properly.  It isn't necesary to implement most of the methods for this
        scenario to work correctly.*/

        public int GetLanguageServiceID(out Guid pguidLangService)
        {
            pguidLangService = Guid.Empty;
            return VSConstants.E_NOTIMPL;
        }

        public int GetLastLineIndex(out int piLine, out int piIndex)
        {
            //Initialize the parameters first
            piLine = 0;
            piIndex = 0;

            int totalLines = editorControl.RichTextBoxControl.Lines.Length;
            if (totalLines > 0)
                piLine = totalLines - 1;
            int lineLen = editorControl.RichTextBoxControl.Lines[piLine].Length;
            piIndex = lineLen >= 1 ? lineLen - 1 : lineLen;

            return VSConstants.S_OK;
        }

        public int GetLengthOfLine(int iLine, out int piLength)
        {
            piLength = 0;
            int totalLines = editorControl.RichTextBoxControl.Lines.Length;

            if (iLine < 0 || iLine >= totalLines)
                return VSConstants.E_INVALIDARG;

            piLength = editorControl.RichTextBoxControl.Lines[iLine].Length;

            return VSConstants.S_OK;
        }

        public int GetLineCount(out int piLineCount)
        {
            piLineCount = editorControl.RichTextBoxControl.Lines.Length;
            return VSConstants.E_NOTIMPL;
        }

        public int GetLineIndexOfPosition(int iPosition, out int piLine, out int piColumn)
        {
            //Initialize the parameters first
            piLine = 0;
            piColumn = 0;

            return VSConstants.E_NOTIMPL;
        }

        public int GetPositionOfLine(int iLine, out int piPosition)
        {
            piPosition = 0;

            return VSConstants.E_NOTIMPL;
        }

        public int GetPositionOfLineIndex(int iLine, int iIndex, out int piPosition)
        {
            piPosition = 0;

            return VSConstants.E_NOTIMPL;
        }

        public int GetSize(out int piLength)
        {
            piLength = 0;
            return VSConstants.E_NOTIMPL;
        }

        public int GetStateFlags(out uint pdwReadOnlyFlags)
        {
            pdwReadOnlyFlags = 0;
            return VSConstants.E_NOTIMPL;
        }

        public int GetUndoManager(out IOleUndoManager ppUndoManager)
        {
            ppUndoManager = null;
            return VSConstants.E_NOTIMPL;
        }

        public int InitializeContent(string pszText, int iLength)
        {
            return VSConstants.E_NOTIMPL;
        }

        public int LockBuffer()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int LockBufferEx(uint dwFlags)
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reload(int fUndoable)
        {
            return VSConstants.E_NOTIMPL;
        }

        public int SetLanguageServiceID(ref Guid guidLangService)
        {
            return VSConstants.E_NOTIMPL;
        }

        public int SetStateFlags(uint dwReadOnlyFlags)
        {
            return VSConstants.E_NOTIMPL;
        }

        public int UnlockBuffer()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int UnlockBufferEx(uint dwFlags)
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved1()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved2()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved3()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved4()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved5()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved6()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved7()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved8()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved9()
        {
            return VSConstants.E_NOTIMPL;
        }

        public int Reserved10()
        {
            return VSConstants.E_NOTIMPL;
        }
        #endregion

        #region IVsTextView Members

        /*This interface contains methods to manage the Text View i.e. the editor window which is shown to
        the user. For our sample this is just provided so that the find in files scenario will work 
        properly.  It isn't necesary to implement most of the methods for this
        scenario to work correctly.*/

        int IVsTextView.AddCommandFilter(IOleCommandTarget pNewCmdTarg, out IOleCommandTarget ppNextCmdTarg)
        {
            ppNextCmdTarg = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.CenterColumns(int iLine, int iLeftCol, int iColCount)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.CenterLines(int iTopLine, int iCount)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.ClearSelection(int fMoveToAnchor)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.CloseView()
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.EnsureSpanVisible(TextSpan span)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetBuffer(out IVsTextLines ppBuffer)
        {
            ppBuffer = (IVsTextLines)this;
            return VSConstants.S_OK;
        }

        int IVsTextView.GetCaretPos(out int piLine, out int piColumn)
        {
            piLine = 0;
            piColumn = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetLineAndColumn(int iPos, out int piLine, out int piIndex)
        {
            piLine = 0;
            piIndex = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetLineHeight(out int piLineHeight)
        {
            piLineHeight = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetNearestPosition(int iLine, int iCol, out int piPos, out int piVirtualSpaces)
        {
            piPos = 0;
            piVirtualSpaces = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetPointOfLineColumn(int iLine, int iCol, Microsoft.VisualStudio.OLE.Interop.POINT[] ppt)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetScrollInfo(int iBar, out int piMinUnit, out int piMaxUnit,
                        out int piVisibleUnits, out int piFirstVisibleUnit)
        {
            piMinUnit = 0;
            piMaxUnit = 0;
            piVisibleUnits = 0;
            piFirstVisibleUnit = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetSelectedText(out string pbstrText)
        {
            pbstrText = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetSelection(out int piAnchorLine,
                    out int piAnchorCol,
                    out int piEndLine,
                    out int piEndCol)
        {
            piAnchorLine = 0;
            piAnchorCol = 0;
            piEndLine = 0;
            piEndCol = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetSelectionDataObject(out Microsoft.VisualStudio.OLE.Interop.IDataObject ppIDataObject)
        {
            ppIDataObject = null;
            return VSConstants.E_NOTIMPL;
        }

        TextSelMode IVsTextView.GetSelectionMode()
        {
            return TextSelMode.SM_STREAM;
        }

        int IVsTextView.GetSelectionSpan(TextSpan[] pSpan)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.GetTextStream(int iTopLine,
                    int iTopCol,
                    int iBottomLine,
                    int iBottomCol,
                    out string pbstrText
            )
        {
            pbstrText = null;
            return VSConstants.E_NOTIMPL;
        }

        IntPtr IVsTextView.GetWindowHandle()
        {
            return IntPtr.Zero;
        }

        int IVsTextView.GetWordExtent(int iLine,
                    int iCol,
                    uint dwFlags,
                    TextSpan[] pSpan
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.HighlightMatchingBrace(uint dwFlags, uint cSpans, TextSpan[] rgBaseSpans)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.Initialize(IVsTextLines pBuffer,
                IntPtr hwndParent,
                uint InitFlags,
                INITVIEW[] pInitView
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.PositionCaretForEditing(int iLine, int cIndentLevels)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.RemoveCommandFilter(IOleCommandTarget pCmdTarg)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.ReplaceTextOnLine(int iLine,
                int iStartCol,
                int iCharsToReplace,
                string pszNewText,
                int iNewLen
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.RestrictViewRange(int iMinLine, int iMaxLine, IVsViewRangeClient pClient)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.SendExplicitFocus()
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.SetBuffer(IVsTextLines pBuffer)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.SetCaretPos(int iLine, int iColumn)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.SetScrollPosition(int iBar, int iFirstVisibleUnit)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.SetSelection(int iAnchorLine, int iAnchorCol, int iEndLine, int iEndCol)
        {
            // first set start location
            int startPosition = editorControl.GetIndexFromLineAndColumn(iAnchorLine, iAnchorCol);
            if (startPosition < 0)
                return VSConstants.E_INVALIDARG;
            editorControl.RichTextBoxControl.SelectionStart = startPosition;

            // now set the length of the selection
            int endPosition = editorControl.GetIndexFromLineAndColumn(iEndLine, iEndCol);
            if (endPosition < 0)
                return VSConstants.E_INVALIDARG;
            int length = endPosition - editorControl.RichTextBoxControl.SelectionStart;
            if (length >= 0)
                editorControl.RichTextBoxControl.SelectionLength = length;
            else
                editorControl.RichTextBoxControl.SelectionLength = 0;
            return VSConstants.S_OK;
        }

        int IVsTextView.SetSelectionMode(TextSelMode iSelMode)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.SetTopLine(int iBaseLine)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.UpdateCompletionStatus(IVsCompletionSet pCompSet, uint dwFlags)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.UpdateTipWindow(IVsTipWindow pTipWindow, uint dwFlags)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextView.UpdateViewFrameCaption()
        {
            return VSConstants.E_NOTIMPL;
        }

        #endregion

        #region IVsTextViewEvents Members

        /*This interface is used as a notifier for the events that are occurring on the Text View.
        For our sample this is just provided so that the find in files scenario will work 
        properly.  It isn't necesary to implement any of the methods. */

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "pView")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iOldLine")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iNewLine")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "p")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "i")]
        public void OnChangeCaretLine(IVsTextView pView, int iNewLine, int iOldLine)
        {
            //Not Implemented
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "pView")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iVisibleUnits")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iMinUnit")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iMaxUnits")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iFirstVisibleUnit")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "iBar")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "p")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "i")]
        public void OnChangeScrollInfo(IVsTextView pView,
                    int iBar,
                    int iMinUnit,
                    int iMaxUnits,
                    int iVisibleUnits,
                    int iFirstVisibleUnit
            )
        {
            //Not Implemented
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "p")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "pView")]
        public void OnKillFocus(IVsTextView pView)
        {
            //Not Implemented
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "pView")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "pBuffer")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "p")]
        public void OnSetBuffer(IVsTextView pView, IVsTextLines pBuffer)
        {
            //Not Implemented
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "p")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "pView")]
        public void OnSetFocus(IVsTextView pView)
        {
            //Not Implemented
        }
        #endregion

        #region IVsCodeWindow Members

        /* This interface is used for hosting of the views for a text buffer. Multiple views can be enclosed
        with the code window. 
        Since our editor support the LOGVIEWID_TextView logical view, we need to implment this interface 
        for find in files scenario to work properly.  
        It isn't necesary to implement most of the methods for this scenario to work correctly. */

        int IVsCodeWindow.GetPrimaryView(out IVsTextView ppView)
        {
            ppView = (IVsTextView)this;
            return VSConstants.S_OK;
        }

        int IVsCodeWindow.GetSecondaryView(out IVsTextView ppView)
        {
            ppView = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsCodeWindow.GetLastActiveView(out IVsTextView ppView)
        {
            ppView = (IVsTextView)this;
            return VSConstants.S_OK;
        }

        int IVsCodeWindow.Close()
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsCodeWindow.GetBuffer(out IVsTextLines ppBuffer)
        {
            ppBuffer = (IVsTextLines)this;
            return VSConstants.S_OK;
        }

        int IVsCodeWindow.GetEditorCaption(READONLYSTATUS dwReadOnly, out string pbstrEditorCaption)
        {
            pbstrEditorCaption = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsCodeWindow.GetViewClassID(out Guid pclsidView)
        {
            pclsidView = Guid.Empty;
            return VSConstants.E_NOTIMPL;
        }

        int IVsCodeWindow.SetBaseEditorCaption(string[] pszBaseEditorCaption)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsCodeWindow.SetBuffer(IVsTextLines pBuffer)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsCodeWindow.SetViewClassID(ref Guid clsidView)
        {
            return VSConstants.E_NOTIMPL;
        }

        #endregion

        #region IVsTextLines Members

        /* This interface is used for a line-oriented access to the contents of the text buffer. 
         For our sample all methods return E_NOTIMPL. This is needed for Find/Replace to work approproiately.
         The Caller just does a QueryInterface for this particular interface, but does not use any 
         of the methods available on the interface*/

        int IVsTextLines.AdviseTextLinesEvents(IVsTextLinesEvents pSink, out uint pdwCookie)
        {
            pdwCookie = 0;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.UnadviseTextLinesEvents(uint dwCookie)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.CanReplaceLines(int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    int iNewLen
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.CopyLineText(int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    IntPtr pszBuf,
                    ref int pcchBuf
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.CreateEditPoint(int iLine, int iIndex, out Object ppEditPoint)
        {
            ppEditPoint = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.CreateLineMarker(int iMarkerType,
                    int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    IVsTextMarkerClient pClient,
                    IVsTextLineMarker[] ppMarker
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.CreateTextPoint(int iLine, int iIndex, out Object ppTextPoint)
        {
            ppTextPoint = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.EnumMarkers(int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    int iMarkerType,
                    uint dwFlags,
                    out IVsEnumLineMarkers ppEnum
            )
        {
            ppEnum = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.FindMarkerByLineIndex(int iMarkerType,
                    int iStartingLine,
                    int iStartingIndex,
                    uint dwFlags,
                    out IVsTextLineMarker ppMarker
            )
        {
            ppMarker = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.GetMarkerData(int iTopLine, int iBottomLine, MARKERDATA[] pMarkerData)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.ReleaseMarkerData(MARKERDATA[] pMarkerData)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.GetLineData(int iLine, LINEDATA[] pLineData, MARKERDATA[] pMarkerData)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.ReleaseLineData(LINEDATA[] pLineData)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.GetLineDataEx(uint dwFlags,
                    int iLine,
                    int iStartIndex,
                    int iEndIndex,
                    LINEDATAEX[] pLineData,
                    MARKERDATA[] pMarkerData
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.ReleaseLineDataEx(LINEDATAEX[] pLineData)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.IVsTextLinesReserved1(int iLine, LINEDATA[] pLineData, int fAttributes)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.GetLineText(int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    out string pbstrBuf
            )
        {
            pbstrBuf = null;
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.GetPairExtents(TextSpan[] pSpanIn, TextSpan[] pSpanOut)
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.ReplaceLines(int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    IntPtr pszText,
                    int iNewLen,
                    TextSpan[] pChangedSpan
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.ReplaceLinesEx(uint dwFlags,
                    int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    IntPtr pszText,
                    int iNewLen,
                    TextSpan[] pChangedSpan
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        int IVsTextLines.ReloadLines(int iStartLine,
                    int iStartIndex,
                    int iEndLine,
                    int iEndIndex,
                    IntPtr pszText,
                    int iNewLen,
                    TextSpan[] pChangedSpan
            )
        {
            return VSConstants.E_NOTIMPL;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\Guids.cs ===
// Guids.cs
// MUST match guids.h
using System;

namespace %ProjectNamespace%.%ProjectClass%
{
    static class GuidList
    {
        public const string guid%ProjectClass%PkgString = "%PackageGuid%";
        public const string guid%ProjectClass%CmdSetString = "%CmdSetGuid%";
%ToolWindowItemStart%        public const string guidToolWindowPersistanceString = "%ToolGuid%";
%ToolWindowItemEnd%%EditorStart%        public const string guid%ProjectClass%EditorFactoryString = "%FactoryGuid%";
%EditorEnd%
        public static readonly Guid guid%ProjectClass%CmdSet = new Guid(guid%ProjectClass%CmdSetString);
%EditorStart%        public static readonly Guid guid%ProjectClass%EditorFactory = new Guid(guid%ProjectClass%EditorFactoryString);
%EditorEnd%    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage
// attributes that are applied to this project. Project-level
// suppressions either have no target or are given a specific target
// and scoped to a namespace, type, member, etc.
//
// To add a suppression to this file, right-click the message in the
// Error List, point to "Suppress Message(s)", and click "In Project
// Suppression File". You do not need to add suppressions to this
// file manually.

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1017:MarkAssembliesWithComVisible")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\IEditor.cs ===
using System;
using System.Runtime.InteropServices;
using EnvDTE;
using tom;

namespace %ProjectNamespace%.%ProjectClass%
{

    /// <summary>
    /// IEditor is the automation interface for EditorDocument.
    /// The implementation of the methods is just a wrapper over the rich
    /// edit control's object model.
    /// </summary>
    [InterfaceType(ComInterfaceType.InterfaceIsIDispatch)]
    public interface IEditor
    {
        float DefaultTabStop { get; set; }
        ITextRange Range { get; }
        ITextSelection Selection { get; }
        int SelectionProperties { get; set; }
        int FindText(string textToFind);
        int SetText(string textToSet);
        int TypeText(string textToType);
        int Cut();
        int Copy();
        int Paste();
        int Delete(long unit, long count);
        int MoveUp(int unit, int count, int extend);
        int MoveDown(int unit, int count, int extend);
        int MoveLeft(int unit, int count, int extend);
        int MoveRight(int unit, int count, int extend);
        int EndKey(int unit, int extend);
        int HomeKey(int unit, int extend);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\VsMacroRecorder.cs ===
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;

namespace %ProjectNamespace%.%ProjectClass%
{
    // Last command type sent to the macro recorder. Note that there are more commands
    // recorded than is implied by this list. Commands in this list (other than
    // LastMacroNone) are coalesced when multiples of the same command are received
    // consecutively.

    // This enum should be extended or replaced with your own command identifiers to enable
    // Coalescing of commands.
    public enum LastMacro
    {
        None,
        Text,
        DownArrowLine,
        DownArrowLineSelection,
        DownArrowPara,
        DownArrowParaSelection,
        UpArrowLine,
        UpArrowLineSelection,
        UpArrowPara,
        UpArrowParaSelection,
        LeftArrowChar,
        LeftArrowCharSelection,
        LeftArrowWord,
        LeftArrowWordSelection,
        RightArrowChar,
        RightArrowCharSelection,
        RightArrowWord,
        RightArrowWordSelection,
        DeleteChar,
        DeleteWord,
        BackspaceChar,
        BackspaceWord
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1027:MarkEnumsWithFlags")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1008:EnumsShouldHaveZeroValue")]
    public enum MoveScope
	{
        Character = tom.tomConstants.tomCharacter,
        Word = tom.tomConstants.tomWord,
        Line = tom.tomConstants.tomLine,
        Paragraph = tom.tomConstants.tomParagraph
	}

	/// <summary>
    /// The VSMacroRecorder class implementation and the IVsMacroRecorder Interface definition
    /// were included here in this seperate class because they were not included in the 
    /// interop assemblies shipped with Visual Studio 2005.
    /// 
    /// When implementing a macro recorder this class should be copied into your own name space
    /// and not shared between different 3rd party packages.
	/// </summary>
    public class VSMacroRecorder
    {
        private IVsMacroRecorder m_VsMacroRecorder;
	    private LastMacro m_LastMacroRecorded;
        private uint m_TimesPreviouslyRecorded;
        Guid m_GuidEmitter;

        public VSMacroRecorder(Guid emitter)
	    {
		    this.m_LastMacroRecorded = LastMacro.None;

            this.m_GuidEmitter = emitter;
	    }

	    // Compiler generated destructor is fine

        public void Reset()    
        { 
            m_LastMacroRecorded = LastMacro.None;
            m_TimesPreviouslyRecorded = 0;
        }

	    public void Stop()
	    {
		    Reset();
            m_VsMacroRecorder = null;
        }

	    public bool IsLastRecordedMacro(LastMacro macro)
	    {
		    return (macro == m_LastMacroRecorded && ObjectIsLastMacroEmitter()) ? true : false;
	    }

	    public bool IsRecording()
	    {
		    // If the property can not be retreived it is assumeed no macro is being recorded.
		    VSRECORDSTATE recordState = VSRECORDSTATE.VSRECORDSTATE_OFF;

            // Retrieve the macro recording state.
            IVsShell vsShell = (IVsShell)Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(SVsShell));
            if (vsShell != null)
            {
                object var;
                if (ErrorHandler.Succeeded(vsShell.GetProperty((int)__VSSPROPID.VSSPROPID_RecordState, out var)) && null != var)
                {
                    recordState = (VSRECORDSTATE)var;
                }
            }

            // If there is a change in the record state to OFF or ON we must either obtain
            // or release the macro recorder. 
            if (recordState == VSRECORDSTATE.VSRECORDSTATE_ON && m_VsMacroRecorder == null)
            {
                // If this QueryService fails we no macro recording
                m_VsMacroRecorder = (IVsMacroRecorder)Microsoft.VisualStudio.Shell.Package.GetGlobalService(typeof(IVsMacroRecorder));
            }
            else if (recordState == VSRECORDSTATE.VSRECORDSTATE_OFF && m_VsMacroRecorder != null)
            {
                // If the macro recording state has been switched off then we can release
                // the service. Note that if the state has become paused we take no action.
                Stop();
            }

            return (m_VsMacroRecorder != null);
	    }

	    public void RecordLine(string line)
	    {
		    m_VsMacroRecorder.RecordLine(line, ref m_GuidEmitter);
		    Reset();
	    }

        public bool RecordBatchedLine(LastMacro macroRecorded, string line)
        {
            if (null == line)
                line = "";
            
            return RecordBatchedLine(macroRecorded, line, 0);
        }

	    public bool RecordBatchedLine(LastMacro macroRecorded, string line, int maxLineLength)
	    {
            if (null == line)
                line = "";

            if (maxLineLength > 0 && line.Length >= maxLineLength)
		    {
			    // Reset the state after recording the line, so it will not be appended to further
			    RecordLine(line);
			    // Notify the caller that the this line will not be appended to further
			    return true;
		    }

		    if(IsLastRecordedMacro(macroRecorded))
		    {
			    m_VsMacroRecorder.ReplaceLine(line, ref m_GuidEmitter);
			    // m_LastMacroRecorded can stay the same
			    ++m_TimesPreviouslyRecorded;
		    }
		    else
		    {
			    m_VsMacroRecorder.RecordLine(line, ref m_GuidEmitter);
			    m_LastMacroRecorded = macroRecorded;
			    m_TimesPreviouslyRecorded = 1;
		    }

		    return false;
	    }

	    public uint GetTimesPreviouslyRecorded(LastMacro macro)
	    {
		    return IsLastRecordedMacro(macro) ? m_TimesPreviouslyRecorded : 0;
	    }

        // This function determines if the last line sent to the macro recorder was
        // sent from this emitter. Note it is not valid to call this function if
        // macro recording is switched off.
        private bool ObjectIsLastMacroEmitter()
        {
            Guid guid;
            m_VsMacroRecorder.GetLastEmitterId(out guid);
		    return guid.Equals(m_GuidEmitter);
        }
    }

#region "IVsMacro Interfaces"
    [StructLayout(LayoutKind.Sequential, Pack = 4), ComConversionLoss]
    internal struct _VSPROPSHEETPAGE
    {
        public uint dwSize;
        public uint dwFlags;
        [ComAliasName("vbapkg.ULONG_PTR")]
        public uint hInstance;
        public ushort wTemplateId;
        public uint dwTemplateSize;
        [ComConversionLoss]
        public IntPtr pTemplate;
        [ComAliasName("vbapkg.ULONG_PTR")]
        public uint pfnDlgProc;
        [ComAliasName("vbapkg.LONG_PTR")]
        public int lParam;
        [ComAliasName("vbapkg.ULONG_PTR")]
        public uint pfnCallback;
        [ComConversionLoss]
        public IntPtr pcRefParent;
        public uint dwReserved;
        [ComConversionLoss, ComAliasName("vbapkg.wireHWND")]
        public IntPtr hwndDlg;
    }

    internal enum _VSRECORDMODE
    {
        // Fields
        VSRECORDMODE_ABSOLUTE = 1,
        VSRECORDMODE_RELATIVE = 2
    }

    [ComImport, ComConversionLoss, InterfaceType(1), Guid("55ED27C1-4CE7-11D2-890F-0060083196C6")]
    internal interface IVsMacros
    {
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void GetMacroCommands([Out] IntPtr ppsaMacroCanonicalNames);
    }
    
    [ComImport, InterfaceType(1), Guid("04BBF6A5-4697-11D2-890E-0060083196C6")]
    internal interface IVsMacroRecorder
    {
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void RecordStart([In, MarshalAs(UnmanagedType.LPWStr)] string pszReserved);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void RecordEnd();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void RecordLine([In, MarshalAs(UnmanagedType.LPWStr)] string pszLine, [In] ref Guid rguidEmitter);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void GetLastEmitterId([Out] out Guid pguidEmitter);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void ReplaceLine([In, MarshalAs(UnmanagedType.LPWStr)] string pszLine, [In] ref Guid rguidEmitter);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void RecordCancel();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void RecordPause();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void RecordResume();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void SetCodeEmittedFlag([In] int fFlag);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void GetCodeEmittedFlag([Out] out int pfFlag);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void GetKeyWord([In] uint uiKeyWordId, [Out, MarshalAs(UnmanagedType.BStr)] out string pbstrKeyWord);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void IsValidIdentifier([In, MarshalAs(UnmanagedType.LPWStr)] string pszIdentifier);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void GetRecordMode([Out] out _VSRECORDMODE peRecordMode);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void SetRecordMode([In] _VSRECORDMODE eRecordMode);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void GetStringLiteralExpression([In, MarshalAs(UnmanagedType.LPWStr)] string pszStringValue, [Out, MarshalAs(UnmanagedType.BStr)] out string pbstrLiteralExpression);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void ExecuteLine([In, MarshalAs(UnmanagedType.LPWStr)] string pszLine);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]
        void AddTypeLibRef([In] ref Guid guidTypeLib, [In] uint uVerMaj, [In] uint uVerMin);
    }
#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\VsPkg.cs ===
using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.ComponentModel.Design;
using Microsoft.Win32;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.OLE.Interop;
using Microsoft.VisualStudio.Shell;

namespace %ProjectNamespace%.%ProjectClass%
{
    /// <summary>
    /// This is the class that implements the package exposed by this assembly.
    ///
    /// The minimum requirement for a class to be considered a valid package for Visual Studio
    /// is to implement the IVsPackage interface and register itself with the shell.
    /// This package uses the helper classes defined inside the Managed Package Framework (MPF)
    /// to do it: it derives from the Package class that provides the implementation of the 
    /// IVsPackage interface and uses the registration attributes defined in the framework to 
    /// register itself and its components with the shell.
    /// </summary>
    // This attribute tells the PkgDef creation utility (CreatePkgDef.exe) that this class is
    // a package.
    [PackageRegistration(UseManagedResourcesOnly = true)]
    // This attribute is used to register the informations needed to show the this package
    // in the Help/About dialog of Visual Studio.
    [InstalledProductRegistration("#110", "#112", "1.0", IconResourceID = 400)]
%MenuItemToolWindowEditorStart%    // This attribute is needed to let the shell know that this package exposes some menus.
    [ProvideMenuResource("Menus.ctmenu", 1)]
%MenuItemToolWindowEditorEnd%%ToolWindowItemStart%    // This attribute registers a tool window exposed by this package.
    [ProvideToolWindow(typeof(MyToolWindow))]
%ToolWindowItemEnd%%EditorStart%    [ProvideEditorExtension(typeof(EditorFactory), ".%Extension%", 50, 
              ProjectGuid = "{A2FE74E1-B743-11d0-AE1A-00A0C90FFFC3}", 
              TemplateDir = "Templates", 
              NameResourceID = 105,
              DefaultName = "%PackageName%")]
    [ProvideKeyBindingTable(GuidList.guid%ProjectClass%EditorFactoryString, 102)]
    [ProvideEditorLogicalView(typeof(EditorFactory), "{7651a703-06e5-11d1-8ebd-00a0c90f26ea}")]
%EditorEnd%    [Guid(GuidList.guid%ProjectClass%PkgString)]
    public sealed class %ProjectClass%Package : Package
    {
        /// <summary>
        /// Default constructor of the package.
        /// Inside this method you can place any initialization code that does not require 
        /// any Visual Studio service because at this point the package object is created but 
        /// not sited yet inside Visual Studio environment. The place to do all the other 
        /// initialization is the Initialize method.
        /// </summary>
        public %ProjectClass%Package()
        {
            Trace.WriteLine(string.Format(CultureInfo.CurrentCulture, "Entering constructor for: {0}", this.ToString()));
        }

%ToolWindowItemStart%        /// <summary>
        /// This function is called when the user clicks the menu item that shows the 
        /// tool window. See the Initialize method to see how the menu item is associated to 
        /// this function using the OleMenuCommandService service and the MenuCommand class.
        /// </summary>
        private void ShowToolWindow(object sender, EventArgs e)
        {
            // Get the instance number 0 of this tool window. This window is single instance so this instance
            // is actually the only one.
            // The last flag is set to true so that if the tool window does not exists it will be created.
            ToolWindowPane window = this.FindToolWindow(typeof(MyToolWindow), 0, true);
            if ((null == window) || (null == window.Frame))
            {
                throw new NotSupportedException(Resources.CanNotCreateWindow);
            }
            IVsWindowFrame windowFrame = (IVsWindowFrame)window.Frame;
            Microsoft.VisualStudio.ErrorHandler.ThrowOnFailure(windowFrame.Show());
        }
%ToolWindowItemEnd%

        /////////////////////////////////////////////////////////////////////////////
        // Overriden Package Implementation
        #region Package Members

        /// <summary>
        /// Initialization of the package; this method is called right after the package is sited, so this is the place
        /// where you can put all the initilaization code that rely on services provided by VisualStudio.
        /// </summary>
        protected override void Initialize()
        {
            Trace.WriteLine (string.Format(CultureInfo.CurrentCulture, "Entering Initialize() of: {0}", this.ToString()));
            base.Initialize();
%EditorStart%
            //Create Editor Factory. Note that the base Package class will call Dispose on it.
            base.RegisterEditorFactory(new EditorFactory(this));
%EditorEnd%
%MenuItemToolWindowStart%            // Add our command handlers for menu (commands must exist in the .vsct file)
            OleMenuCommandService mcs = GetService(typeof(IMenuCommandService)) as OleMenuCommandService;
            if ( null != mcs )
            {
%MenuItemStart%                // Create the command for the menu item.
                CommandID menuCommandID = new CommandID(GuidList.guid%ProjectClass%CmdSet, (int)PkgCmdIDList.%CommandID%);
                MenuCommand menuItem = new MenuCommand(MenuItemCallback, menuCommandID );
                mcs.AddCommand( menuItem );
%MenuItemEnd%%ToolWindowItemStart%                // Create the command for the tool window
                CommandID toolwndCommandID = new CommandID(GuidList.guid%ProjectClass%CmdSet, (int)PkgCmdIDList.%ToolCommandID%);
                MenuCommand menuToolWin = new MenuCommand(ShowToolWindow, toolwndCommandID);
                mcs.AddCommand( menuToolWin );
%ToolWindowItemEnd%            }
%MenuItemToolWindowEnd%        }
        #endregion
%MenuItemStart%
        /// <summary>
        /// This function is the callback used to execute a command when the a menu item is clicked.
        /// See the Initialize method to see how the menu item is associated to this function using
        /// the OleMenuCommandService service and the MenuCommand class.
        /// </summary>
        private void MenuItemCallback(object sender, EventArgs e)
        {
            // Show a Message Box to prove we were here
            IVsUIShell uiShell = (IVsUIShell)GetService(typeof(SVsUIShell));
            Guid clsid = Guid.Empty;
            int result;
            Microsoft.VisualStudio.ErrorHandler.ThrowOnFailure(uiShell.ShowMessageBox(
                       0,
                       ref clsid,
                       "%PackageName%",
                       string.Format(CultureInfo.CurrentCulture, "Inside {0}.MenuItemCallback()", this.ToString()),
                       string.Empty,
                       0,
                       OLEMSGBUTTON.OLEMSGBUTTON_OK,
                       OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST,
                       OLEMSGICON.OLEMSGICON_INFO,
                       0,        // false
                       out result));
        }
%MenuItemEnd%
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\MyToolWindow.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Windows;
using System.Runtime.InteropServices;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Shell;

namespace %ProjectNamespace%.%ProjectClass%
{
    /// <summary>
    /// This class implements the tool window exposed by this package and hosts a user control.
    ///
    /// In Visual Studio tool windows are composed of a frame (implemented by the shell) and a pane, 
    /// usually implemented by the package implementer.
    ///
    /// This class derives from the ToolWindowPane class provided from the MPF in order to use its 
    /// implementation of the IVsUIElementPane interface.
    /// </summary>
    [Guid("%ToolGuid%")]
    public class MyToolWindow : ToolWindowPane
    {
        /// <summary>
        /// Standard constructor for the tool window.
        /// </summary>
        public MyToolWindow() :
            base(null)
        {
            // Set the window title reading it from the resources.
            this.Caption = Resources.ToolWindowTitle;
            // Set the image that will appear on the tab of the window frame
            // when docked with an other window
            // The resource ID correspond to the one defined in the resx file
            // while the Index is the offset in the bitmap strip. Each image in
            // the strip being 16x16.
            this.BitmapResourceID = 301;
            this.BitmapIndex = 1;

            // This is the user control hosted by the tool window; Note that, even if this class implements IDisposable,
            // we are not calling Dispose on this object. This is because ToolWindowPane calls Dispose on 
            // the object returned by the Content property.
            base.Content = new MyControl();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\NativeMethods.cs ===
using System;
using System.Runtime.InteropServices;

namespace %ProjectNamespace%.%ProjectClass%
{
    /// <summary>
    /// This class will contain all methods that we need to import.
    /// </summary>
    internal class NativeMethods 
    {
        public const int WM_LBUTTONDOWN = 0x0201;
        public const int WM_LBUTTONDBLCLK = 0x0203;
        public const int WM_RBUTTONDOWN = 0x0204;
        public const int WM_MBUTTONDOWN = 0x0207;

        //Including a private constructor to prevent a compiler-generated default constructor
        private NativeMethods()
        {
        }

        // Import the SendMessage function from user32.dll
        [DllImport("user32.dll")]
        public static extern IntPtr SendMessage(IntPtr hwnd,
                                                int Msg,
                                                IntPtr wParam,
                                                [MarshalAs(UnmanagedType.IUnknown)] out object lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\MyControl.xaml.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace %ProjectNamespace%.%ProjectClass%
{
    /// <summary>
    /// Interaction logic for MyControl.xaml
    /// </summary>
    public partial class MyControl : UserControl
    {
        public MyControl()
        {
            InitializeComponent();
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1300:SpecifyMessageBoxOptions")]
        private void button1_Click(object sender, RoutedEventArgs e)
        {
            MessageBox.Show(string.Format(System.Globalization.CultureInfo.CurrentUICulture, "We are inside {0}.button1_Click()", this.ToString()),
                            "%ToolWindowName%");

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\Resources.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace %ProjectNamespace%.%ProjectClass% {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("%ProjectNamespace%.%ProjectClass%.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
%MenuItemToolWindowStart%%ToolWindowItemStart%        /// <summary>
        ///   Looks up a localized string similar to Can not create tool window..
        /// </summary>
        internal static string CanNotCreateWindow {
            get {
                return ResourceManager.GetString("CanNotCreateWindow", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to My Tool Window.
        /// </summary>
        internal static string ToolWindowTitle {
            get {
                return ResourceManager.GetString("ToolWindowTitle", resourceCulture);
            }
        }
%ToolWindowItemEnd%%MenuItemToolWindowEnd%    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\CS\PkgCmdID.cs ===
// PkgCmdID.cs
// MUST match PkgCmdID.h
using System;

namespace %ProjectNamespace%.%ProjectClass%
{
    static class PkgCmdIDList
    {
%MenuItemStart%        public const uint %CommandID% =        0x100;%MenuItemEnd%
%ToolWindowItemStart%        public const uint %ToolCommandID% =    0x101;%ToolWindowItemEnd%
%EditorStart%
        // Menus
        public const int IDM_TLB_RTF = 0x0001;			// toolbar
        public const int IDMX_RTF = 0x0002;			// context menu
        public const int IDM_RTFMNU_ALIGN = 0x0004;
        public const int IDM_RTFMNU_SIZE = 0x0005;

        // Menu Groups
        public const int IDG_RTF_FMT_FONT1 = 0x1000;
        public const int IDG_RTF_FMT_FONT2 = 0x1001;
        public const int IDG_RTF_FMT_INDENT = 0x1002;
        public const int IDG_RTF_FMT_BULLET = 0x1003;

        public const int IDG_RTF_TLB_FONT1 = 0x1004;
        public const int IDG_RTF_TLB_FONT2 = 0x1005;
        public const int IDG_RTF_TLB_INDENT = 0x1006;
        public const int IDG_RTF_TLB_BULLET = 0x1007;
        public const int IDG_RTF_TLB_FONT_COMBOS = 0x1008;

        public const int IDG_RTF_CTX_EDIT = 0x1009;
        public const int IDG_RTF_CTX_PROPS = 0x100a;

        public const int IDG_RTF_EDITOR_CMDS = 0x100b;

        // Command IDs

        public const int icmdStrike = 0x0004;
%EditorEnd%
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\UI\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by %ProjectName%UI.rc
//
%CppOnlyStart%
#define IDS_OFFICIALNAME                    100
#define IDS_PRODUCTDETAILS                  102
#define IDS_COMPANYNAME                     103
#define IDS_VERSION                         104
%EditorStart%
#define IDS_EDITOR_NAME                     106
#define IDS_DEFAULT_NAME                    107
#define IDS_EDITORCAPTION                   108
#define IDS_FILE_DESCRIPTION                109
#define IDS_READONLY                        110
#define IDS_FORMATSTR                       111
#define IDS_OUTSIDEEDITORFILECHANGE         112
#define IDS_NEWFILE_TEMPLATES_ENTRY         113
%EditorEnd%
%ToolWindowItemStart%
#define IDS_WINDOW_TITLE                    120
#define IDS_E_CANTCREATETOOL                121
#define IDS_E_GETVIEWOBJECT_CALLED_AGAIN    122
#define IDS_BUTTONCLICK_MESSAGE             123
%ToolWindowItemEnd%%CppOnlyEnd%
#define IDB_MENU_IMAGES                     300
#define IDB_FRAME_IMAGES                    301
#define IDI_PACKAGE_ICON                    400
%EditorStart%#define IDI_FILE_ICON                       401%EditorEnd%

%ToolWindowItemStart%#define IDD_%ProjectClass%_DLG                        800
#define IDC_CLICKME_BTN                     801%ToolWindowItemEnd%
%CppOnlyStart%
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        402
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           402
#endif
#endif
%CppOnlyEnd%
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\LP\service.cpp ===
#include "service.h"
%IncludeList%

/*---------------------------------------------------------
  Globals
---------------------------------------------------------*/
const wchar_t*  g_languageName              = %LanguageName%;
const wchar_t*  g_languageFileExtensions[]  = { %LanguageExtensions% NULL };
const CLSID     g_languageCLSID             = {%PackageGuid2%};

const LanguageProperty g_languageProperties[] =
{
  { L"RequestStockColors", %SyntaxColor% },

  { L"ShowCompletion",     %ShowCompletion%     },
  { L"SortMemberList",     %SortMemberList%     },

  { L"CodeSense",          %SyntaxCheck%  },
  { L"CodeSenseDelay",     %SyntaxCheckDelay% },
  { L"MaxErrorMessages",   %MaxErrMsg%     },
  { L"QuickInfo",          %QuickInfo%     },
  { L"MatchBraces",        %MatchBraces%     },
  { L"ShowMatchingBrace",  %ShowMatchingBrace%     },
  { L"MatchBracesAtCaret", %MatchBracesAtCaret%     },

  { NULL, 0 }
};

/*---------------------------------------------------------
  Create Service
---------------------------------------------------------*/
HRESULT CreateBabelService( out IBabelService** babelService )
{
  TRACE(L"CreateBabelService");
  OUTARG(babelService);

  *babelService = new Service();
  if (*babelService == NULL) return E_OUTOFMEMORY;

  return S_OK;
}

%CommentFormatImpl%

/*---------------------------------------------------------
  Tokens
---------------------------------------------------------*/
override const TokenInfo* Service::getTokenInfo() const
{
  static TokenInfo tokenInfoTable[] =
  {
	%TokensInfo%
    //always end with the 'TokenEnd' token.
    { TokenEnd,     ClassText,      "<unknown>" }
  };

  return tokenInfoTable;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\UI\CommandIds.h ===
// CommandIds.h
// Command IDs used in defining command bars
//

// do not use #pragma once - used by ctc compiler
#ifndef __COMMANDIDS_H_
#define __COMMANDIDS_H_

///////////////////////////////////////////////////////////////////////////////
// Menu IDs
%EditorStart%
#define IDM_TLB_RTF                0x0001                // toolbar
#define IDMX_RTF                0x0002                // context menu
#define IDM_RTFMNU_ALIGN            0x0004
#define IDM_RTFMNU_SIZE                0x0005
%EditorEnd%


///////////////////////////////////////////////////////////////////////////////
// Menu Group IDs
%EditorStart%
#define IDG_RTF_FMT_FONT1            0x1000
#define IDG_RTF_FMT_FONT2            0x1001
#define IDG_RTF_FMT_INDENT            0x1002
#define IDG_RTF_FMT_BULLET            0x1003

#define IDG_RTF_TLB_FONT1            0x1004
#define IDG_RTF_TLB_FONT2            0x1005
#define IDG_RTF_TLB_INDENT            0x1006
#define IDG_RTF_TLB_BULLET            0x1007
#define IDG_RTF_TLB_FONT_COMBOS            0x1008

#define IDG_RTF_CTX_EDIT            0x1009
#define IDG_RTF_CTX_PROPS            0x100a

#define IDG_RTF_EDITOR_CMDS            0x100b
%EditorEnd%
#define MyMenuGroup                 0x1020

///////////////////////////////////////////////////////////////////////////////
// Command IDs

%MenuItemStart%#define %CommandID% 0x100%MenuItemEnd%
%ToolWindowItemStart%#define %ToolCommandID% 0x101%ToolWindowItemEnd%
%EditorStart%#define commandIDStrike 0x102%EditorEnd%

///////////////////////////////////////////////////////////////////////////////
// Bitmap IDs
#define bmpPic1 1
#define bmpPic2 2
#define bmpPicSearch 3
#define bmpPicX 4
#define bmpPicArrows 5


#endif // __COMMANDIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\LP\service.h ===
#ifndef service_h
#define service_h

#include <common.h>
#include <languagedef.h>
#include <stdservice.h>


class Service : public CommentService
{
protected:
  %CommentFormatDecl%
  override const TokenInfo*     getTokenInfo()     const;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\CommonIncludes.h ===
// CommonIncludes.h

#pragma once

#include "Resource.h"
#include "..\%ProjectName%UI\Resource.h"
#include "Guids.h"
#include "..\%ProjectName%UI\CommandIds.h"

#include "%ProjectName%.h"

#include "Package.h"

%EditorStart%
#include "EditorDocument.h"
#include "EditorAutomation.inl"
#include "EditorCore.inl"
#include "EditorEvents.inl"
#include "EditorFindAndReplace.inl"
#include "EditorPersistance.inl"
#include "EditorWindowing.inl"
%EditorEnd%
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorAutomation.inl ===
// EditorAutomation.inl

#pragma once

/*
ISingleViewEditor is the automation interface for EditorDocument.  The implementation
of the methods is just a thin wrapper over the site cache and the rich edit control's object
model.
*/

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::get_DTE(_Deref_out_ _DTE** ppDTE)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(ppDTE, E_INVALIDARG);

	// Return the VS DTE service
	return GetVsSiteCache().QueryService(SID_SDTE, ppDTE);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::get_Parent(_Deref_out_ _DTE** ppParent)
{
	// Delegate, as the VS DTE is the parent of this automation object
	return get_DTE(ppParent);
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::get_DefaultTabStop(_Out_ float* pfStop)
{
	VSL_RETURN_E_INVALIDARG_IF_NULL(pfStop);

	return GetControl().GetITextDocument()->GetDefaultTabStop(pfStop);
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::put_DefaultTabStop(float fStop)
{
	return GetControl().GetITextDocument()->SetDefaultTabStop(fStop);
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::get_Range(_Deref_out_ /*ITextRange*/ IDispatch** ppRange)
{
	VSL_RETURN_E_INVALIDARG_IF_NULL(ppRange);

	VSL_STDMETHODTRY{

	CComPtr<ITextRange> spRange;
	CHKHR(GetControl().GetITextDocument()->Range(0, tomForward, &spRange));
	CHKHR(spRange->QueryInterface(IID_IDispatch, (void**)ppRange));

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::get_Selection(_Deref_out_ /*ITextSelection*/ IDispatch** ppSelection)
{
	VSL_RETURN_E_INVALIDARG_IF_NULL(ppSelection);

	VSL_STDMETHODTRY{

	CComPtr<ITextSelection> spSelection;
	CHKHR(GetControl().GetITextDocument()->GetSelection(&spSelection));
	CHKHR(spSelection->QueryInterface(IID_IDispatch, (void**)ppSelection));

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::get_Flags(_Out_ long* piFlags)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(piFlags, E_INVALIDARG);

	*piFlags = GetTextSelectionFlags();
		
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::put_Flags(long iFlags)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->SetFlags(iFlags));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::FindText(_In_ BSTR bstrToFind)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(bstrToFind, E_INVALIDARG);

	CComPtr<ITextRange>	spITextRange;
	GetTextRange(spITextRange);

	long cFound = 0;
	return spITextRange->FindText(bstrToFind, tomForward, 0, &cFound);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::SetText(_In_ BSTR bstrToSet)
{
	// Just delegate to TypeText
	return TypeText(bstrToSet);
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::TypeText(_In_ BSTR bstrToType)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(bstrToType, E_INVALIDARG);

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->TypeText(bstrToType));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::Cut()
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->Cut(NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::Copy()
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->Copy(NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::Paste()
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->Paste(NULL, 0));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::Delete(long iUnit, long iCount)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->Delete(iUnit, iCount, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}


template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::MoveUp(long iUnit, long iCount, long iExtend)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->MoveUp(iUnit, iCount, iExtend, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::MoveDown(long iUnit, long iCount, long iExtend)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->MoveDown(iUnit, iCount, iExtend, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::MoveLeft(long iUnit, long iCount, long iExtend)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->MoveLeft(iUnit, iCount, iExtend, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::MoveRight(long iUnit, long iCount, long iExtend)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->MoveRight(iUnit, iCount, iExtend, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::EndKey(long iUnit, long iExtend)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->EndKey(iUnit, iExtend, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::HomeKey(long iUnit, long iExtend)
{
	VSL_STDMETHODTRY{

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	VSL_SET_STDMETHOD_HRESULT(spITextSelection->HomeKey(iUnit, iExtend, NULL));
	GetControl().SetFocus();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
void EditorDocument<Traits_T>::RecordCommand(const wchar_t* szCommand)
{
	if(m_Recorder.IsRecording(GetVsSiteCache()))
	{
		CStringW strLine = L"ActiveDocument.Object.";

		strLine += szCommand;

		m_Recorder.RecordLine(strLine);
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::RecordKeyStroke(UINT msg, _In_ WPARAM wParam, _In_ LPARAM /*lParam*/)
{
	CStringW strMacro;

	switch(msg)
	{
	case WM_CHAR:
		// Only deal with text characters.  Everything, space and above is a text chracter
		// except DEL (0x7f).  Include carriage return (enter key) and tab, which are
		// below space, since those are also text characters.
		if(	(wParam >= L' ' && wParam != 0x7f) // 0x7f is DEL, don't process that
			|| L'\r' == wParam
			|| L'\t' == wParam)
		{
			if(!m_Recorder.IsLastRecordedMacro(eLastMacroText))
			{
				// clear the buffer, the last line won't be replaced, if it wasn't also
				// for text
				m_strTextToRecord.Empty();
			}

			if(L'\r' == wParam)
			{
				// Emit "vbCr" as the standard line terminator
				m_strTextToRecord.Append(L"\" & vbCr & \"");
			}
			else if(L'\t' == wParam)
			{
				// Emit "vbTab" as the standard tab
				m_strTextToRecord.Append(L"\" & vbTab & \"");
			}
			else
			{
				m_strTextToRecord += static_cast<wchar_t>(wParam);
			}

			strMacro.Append(L"ActiveDocument.Object.TypeText(\"");
			strMacro.Append(m_strTextToRecord);
			strMacro.Append(L"\")");

			if(m_Recorder.RecordBatchedLine(eLastMacroText, strMacro, 100)) // arbitrary max length
			{
				// Clear out the buffer if the line hit max length, since
				// it will not continue to be appended to
				m_strTextToRecord.Empty();
			}
		}
		break;

	case WM_KEYDOWN:
		{
		// Obtain the CTRL and SHIFT as they modify a number of the virtual keys. 
		bool bShift = Keyboard::IsKeyDown(VK_SHIFT);
		bool bCtrl = Keyboard::IsKeyDown(VK_CONTROL);

		// wParam indicates the virtual key.
		switch(wParam)
		{
		case VK_BACK: // BackSpace key
			// Note that SHIFT does not affect this command
			RecordDelete(true, bCtrl && IsSelectionEmpty());
			break;

		case VK_DELETE:
			// Note that SHIFT completely disables this command
			if(!bShift)
			{
				RecordDelete(false, bCtrl && IsSelectionEmpty());
			}
			break;

		case VK_LEFT: // Left Arrow
			// SHIFT indicates selection, CTRL indicates words instead of characters
			{
			LastMacro macroType = bCtrl ?
			(bShift ? eLastMacroLeftArrowWordSel : eLastMacroLeftArrowWord) : 
			(bShift ? eLastMacroLeftArrowCharSel : eLastMacroLeftArrowChar);

			RecordMove(macroType, L"Left", bCtrl ? Word : Character, bShift);
			}
			break;

		case VK_RIGHT: // Right Arrow
			// SHIFT indicates selection, CTRL indicates words instead of characters
			{
			LastMacro macroType = bCtrl ?
			(bShift ? eLastMacroRightArrowWordSel : eLastMacroRightArrowWord) : 
			(bShift ? eLastMacroRightArrowCharSel : eLastMacroRightArrowChar);

			RecordMove(macroType, L"Right", bCtrl ? Word : Character, bShift);
			}
			break;

		case VK_UP: // Up Arrow
			// SHIFT indicates selection, CTRL indicates paragraphs instead of lines
			{
			LastMacro macroType = bCtrl ?
			(bShift ? eLastMacroUpArrowParaSel : eLastMacroUpArrowPara) : 
			(bShift ? eLastMacroUpArrowLineSel : eLastMacroUpArrowLine);

			RecordMove(macroType, L"Up", bCtrl ? Paragraph : Line, bShift);
			}
			break;

		case VK_DOWN: // Down Arrow
			// SHIFT indicates selection, CTRL indicates paragraphs instead of lines
			{
			LastMacro macroType = bCtrl ?
			(bShift ? eLastMacroDownArrowParaSel : eLastMacroDownArrowPara) : 
			(bShift ? eLastMacroDownArrowLineSel : eLastMacroDownArrowLine);

			RecordMove(macroType, L"Down", bCtrl ? Paragraph : Line, bShift);
			}
			break;

		case VK_PRIOR: // Page Up
		case VK_NEXT: // Page Down
			strMacro.Append(L"ActiveDocument.Object.Move");

			if(wParam == VK_PRIOR)
			{
				strMacro.Append(L"Up");
			}
			else
			{
				strMacro.Append(L"Down");
			}

			strMacro.AppendFormat(L"(%i, 1, %i)", bCtrl ? tomWindow : tomScreen, bShift ? tomExtend : tomMove);

			m_Recorder.RecordLine(strMacro);
			break;

		case VK_END:
		case VK_HOME:
			strMacro.Append(L"ActiveDocument.Object.");

			if(wParam == VK_END)
			{
				strMacro.Append(L"EndKey");
			}
			else
			{
				strMacro.Append(L"HomeKey");
			}

			strMacro.AppendFormat(
				L"(%i, %i)", 
				bCtrl ? tomStory : tomLine, 
				bShift ? tomExtend : tomMove);

			m_Recorder.RecordLine(strMacro);
			break;

		case VK_INSERT:
			// Note that the CTRL completely disables this command.  Also the SHIFT+INSERT
			// actually generates a WM_PASTE message rather than a WM_KEYDOWN
			if(!bCtrl)
			{
				strMacro = L"ActiveDocument.Object.Flags = ActiveDocument.Object.Flags Xor ";
				strMacro.AppendFormat(L"%i", tomSelOvertype);
				m_Recorder.RecordLine(strMacro);
			}
			break;

		default:
			// Note that VK_RETURN and VK_TAB are handled in the WM_CHAR message
			// case rather than in the WM_KEYDOWN case.
			break;
		}
		break;
		}
	default:
		break;
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::RecordDelete(bool bBackspace /*= false*/, bool bWord /*= false*/)
{
	if(!m_Recorder.IsRecording(GetVsSiteCache()))
	{
		return;
	}

	// If not bBackspace then it's a delete
	// If not bWord then it's a single character
	LastMacro macroType = bBackspace ?
			(bWord ? eLastMacroBackSpaceWord : eLastMacroBackSpaceChar) : 
			(bWord ? eLastMacroDeleteWord : eLastMacroDeleteChar);

	// Get the number of times the macro type calculated above has been recorded already
	// (if any) and then add one to get the current count
	unsigned int iCount = m_Recorder.GetTimesPreviouslyRecorded(macroType) + 1;

	CStringW strMacro;
	strMacro.AppendFormat(
		L"ActiveDocument.Object.Delete(%i, %i)", 
		bWord ? tomWord : tomCharacter, 
		// if this parameter is negative, it indicates a backspace, rather then a delete
		bBackspace ? -1*iCount : iCount);

	m_Recorder.RecordBatchedLine(macroType, strMacro);
}

template <class Traits_T>
void EditorDocument<Traits_T>::RecordMove(
	LastMacro eState,
	LPCWSTR szDirection,
	MoveScope eScope,
	bool bExtend)
{
	CStringW strMacro;
	strMacro.Append(L"ActiveDocument.Object.Move");
	strMacro.Append(szDirection);
	strMacro.AppendFormat(
		L"(%i, %i, %i)", 
		eScope, 
		// Get the number of times this macro type has been recorded already
		// (if any) and then add one to get the current count
		m_Recorder.GetTimesPreviouslyRecorded(eState)+1, 
		bExtend ? tomExtend : tomMove);

	m_Recorder.RecordBatchedLine(eState, strMacro);
}

// Window Proc for the rich edit control.  Necessary to implement macro recording.
template <class Traits_T>
LRESULT CALLBACK EditorDocument<Traits_T>::RichEditWindowProc(
	_In_ HWND hWnd, 
	UINT msg, 
	_In_ WPARAM wParam, 
	_In_ LPARAM lParam)
{
	VSL_STDMETHODTRY{

	// Get the document pointer, which was set by calling SetWindowLong in CreatePaneWindow
	Control::Window window(hWnd);
	EditorDocument* pDocument = reinterpret_cast<EditorDocument*>(window.GetWindowLongPtr(GWLP_USERDATA));

	if(NULL != pDocument)
	{
		pDocument->EnsureNotClosed(); // paranoid, this shouldn't happen since this proc is removed in ClosePane

		if(!pDocument->m_Recorder.IsRecording(pDocument->GetVsSiteCache()))
		{
			return pDocument->GetControl().CallWindowProc(pDocument->m_pWindowProc, msg, wParam, lParam);
		}

		switch(msg)
		{
		case WM_SETCURSOR:
			// Set the curose to the "No" symbol, to indicate mouse actions will not be recorded, 
			// and supress the message
			{
			static Traits_T::Cursor noCursor(IDC_NO);
			noCursor.Activate();
			}
			return 0;

		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_MBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
			// The cursor has been set to the "No" symbol, just set the focus, and supress the message
			pDocument->GetControl().SetFocus();
			return 0;

		default:
			// Need to process the message normally, as well so that user action actually occurs in the 
			// control after recording the user action
			pDocument->RecordKeyStroke(msg, wParam, lParam);
			return pDocument->GetControl().CallWindowProc(pDocument->m_pWindowProc, msg, wParam, lParam);
		}
	}

	}VSL_STDMETHODCATCH()

	VSL_ASSERT(SUCCEEDED(VSL_GET_STDMETHOD_HRESULT()));

	return 0;
}

template <class Traits_T>
IDispatch* EditorDocument<Traits_T>::GetNamedAutomationObject(_In_z_ BSTR bstrName)
{
	const wchar_t szDocumentName[] = L"Document";
	if(bstrName != NULL && bstrName[0] != L'\0')
	{
		// NULL or empty string just means the default object, but if a specific string
		// is specified, then make sure it's the correct one, but don't enforce case
		CHK(0 == ::_wcsicmp(bstrName, szDocumentName), E_INVALIDARG);
	}
	IDispatch* pIDispatch = static_cast<ISingleViewEditor*>(this);
	// Required to AddRef this once before returning it
	pIDispatch->AddRef();
	return pIDispatch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorCore.inl ===
// EditorCore.inl

/*****************************************************************************
** IVsWindowPane Implementation
*****************************************************************************/

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::CreatePaneWindow(
	_In_ HWND hWndParent,
	_In_ int x,
	_In_ int y,
	_In_ int cx,
	_In_ int cy,
	_Out_ HWND *phWnd)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(phWnd, E_INVALIDARG);

	RECT rect = { x, y, x+cx, y+cy };

	RichEditContainer::Create(hWndParent, rect);

	// Subclass the rich edit control window
	m_pWindowProc = reinterpret_cast<WNDPROC>(GetControl().SetWindowLongPtr(GWLP_WNDPROC, (LONG_PTR)EditorDocument<Traits_T>::RichEditWindowProc));
	GetControl().SetWindowLongPtr(GWLP_USERDATA, (LONG_PTR)this);

	// Finally show the window
	GetControl().ShowWindow(SW_SHOWNORMAL);

	// Setup the selection container for the one selected item
	GetItemsContainer()[0] = GetControl().GetITextDocument();

	// Now fire the selection change event
	FireSelectionChange();

	// Register with the text manager, so find in files works correctlyy
	RegisterToTextManager();

	*phWnd = GetHWND();

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetDefaultSize(_Out_ SIZE *psize)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(psize, E_INVALIDARG);

	psize->cx = 50;
	psize->cy = 50;

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::ClosePane()
{
	if(m_bClosed)
	{
		// recursion guard
		return E_UNEXPECTED;
	}

	VSL_STDMETHODTRY{

	// Put back the original window procedure
	GetControl().SetWindowLongPtr(GWLP_WNDPROC, (LONG_PTR)m_pWindowProc);

	// Destroy the parent window, which will in turn destory the rich edit window
	Destroy();

	// Notify the persistance base class that the document is closing
	OnDocumentClose();

	GetItemsContainer()[0] = NULL;

	// Stop any macro recording
	m_Recorder.Stop();

	// Unregister with the text manager
	UnregisterFromTextManager();

	m_bClosed = true;

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorFactory.h ===
// EditorFactory.h

#pragma once

#include "EditorDocument.h"

/***************************************************************************
%ProjectName%.pkgdef contains:

%EditorStart%
[$RootKey$\Editors\{%FactoryGuid%}]
@="%EditorName%"
"Package"="{%PackageGuid%}"
"DisplayName"="%EditorName%"
"ExcludeDefTextEditor"=dword:00000001
"AcceptBinaryFiles"=dword:00000000

[$RootKey$\Editors\{%FactoryGuid%}\LogicalViews]
"{7651A703-06E5-11D1-8EBD-00A0C90F26EA}"=""

[$RootKey$\Editors\{%FactoryGuid%}\Extensions]
"%Extension%"=dword:00000032

which informs the shell that %ProjectClass%Package is the package to createto have this editor 
registered with Visual Studio.  When %ProjectClass%Package is sited by Visual Studio, 
%ProjectClass%Package::PostSited creates an instance of EditorFactory and then queries
for SID_SVsRegisterEditors and then calls IVsRegisterEditors->RegisterEditor to register
the new instance of EditorFactory with Visual Studio.

Visual Studio then uses the EditorFactory instance to create EditorDocument
instances, which is the actual edtior instance.
***************************************************************************/

class EditorFactory :
	// Use ATL to take care of common COM infrastructure
	public CComObjectRootEx<CComSingleThreadModel>,
	// IVsEditorFactory is required to be an editor factory
	public IVsEditorFactoryImpl<EditorFactory>
{

// Provides a portion of the implementation of IUnknown, in particular the list of interfaces
// the EditorFactory object will support via QueryInterface
BEGIN_COM_MAP(EditorFactory)
    COM_INTERFACE_ENTRY(IVsEditorFactory)
END_COM_MAP()

// COM objects typically should not be cloned, and this prevents cloning by declaring the 
// copy constructor and assignment operator private (NOTE:  this macro includes the decleration of
// a private section, so everything following this macro and preceding a public or protected 
// section will be private).
VSL_DECLARE_NOT_COPYABLE(EditorFactory)

protected:
	EditorFactory()
	{
	}

	virtual ~EditorFactory()
	{
	}

public:

#pragma warning(push)
#pragma warning(disable : 4480) // // warning C4480: nonstandard extension used: specifying underlying type for enum
	enum PhysicalViewId : unsigned int
	{
		Unsupported,
		Primary
	};
#pragma warning(pop)

	PhysicalViewId GetPhysicalViewId(REFGUID rguidLogicalView)
	{
		if(LOGVIEWID_Primary == rguidLogicalView || LOGVIEWID_TextView == rguidLogicalView)
		{
			return Primary;
		}

		return Unsupported;
	}

	BSTR GetPhysicalViewBSTR(PhysicalViewId viewId)
	{
		if(Primary == viewId)
		{
			// Note that the value of LOGVIEWID_TextView in the registry is empty string.
			// The values under LogicalViews for an editor should match up to the values 
			// returned by this method, so that GetPhysicalViewId below can properly
			// map the strings back to a PhysicalViewId.
			return ::SysAllocString(L"");
		}

		return NULL;
	}

	PhysicalViewId GetPhysicalViewId(LPCOLESTR szPhysicalView)
	{
		if(szPhysicalView != NULL && szPhysicalView[0] == L'\0')
		{
			return Primary;
		}

		return Unsupported;
	}

	bool CanShareBuffer(PhysicalViewId /*physicalViewId*/)
	{
		return false;
	}

	void CreateSingleViewObject(
		PhysicalViewId physicalViewId, 
		CComPtr<IUnknown>& rspViewObject, 
		CComBSTR& rbstrEditorCaption, 
		const GUID*& rpguidCommandUI, 
		VSEDITORCREATEDOCWIN& /*rCreateDocumentWindowUI*/)
	{
		if(physicalViewId == Primary)
		{
			CComObject<EditorDocument<> > *pDocument;
			VSL_CHECKHRESULT(CComObject<EditorDocument<> >::CreateInstance(&pDocument));
			HRESULT hr = pDocument->QueryInterface(&rspViewObject);
			if(FAILED(hr))
			{
				// If QueryInterface failed, then there is something wrong with the object.
				// Delete it and throw an exception for the error.
				delete pDocument;
				VSL_CREATE_ERROR_HRESULT(hr);
			}

			// NOTE - if the file is read only [Read Only] will be appended to the caption
			rbstrEditorCaption.LoadStringW(IDS_EDITORCAPTION);

			rpguidCommandUI = &CLSID_%ProjectClass%EditorDocument;

			// pCreateDocumentWindowUI will be initialized to 0, and see we provide
			// no GUI for the user to cancel from so leave it 0

			return;
		}
		ERRHR(E_FAIL); // This should never happen
	}

private:

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorEvents.inl ===
// EditorEvents.inl

/*
NOTE - pOleCmd is not ensured against NULL in the OnQuery* methods, as 
VSL::CommandHandlerBase::QueryStatus, which is the called of the OnQuery* method implemented 
here, already does so.  Additionally, VSL::IOleCommandTargetImpl::QueryStatus checks
pOleCmd as well before calling the query status handler.

The OnQuery* are all private, so the only way to access them is via calling QueryStatus.
*/

#include <VSLFont.h>

template <class Traits_T>
LRESULT EditorDocument<Traits_T>::OnContentChange(WORD /*iCommand*/, WORD /*iId*/, _In_ HWND hWindow, BOOL& /*bHandled*/)
{
	CHK(hWindow == GetControl().GetHWND(), E_FAIL);

	// If not dirty then it is necessary to process this message inorder to determine if
	// the file should be marked as dirty or the change undone
	if(!IsFileDirty())
	{
		// Check with the source control provider to see if the file can be changed.
		if(!ShouldDiscardChange())
		{
			SetFileDirty(true);
			// REVIEW - 3/14/2006 - is this here to ensure the "*" get's appended to the document name properly?
			UpdateVSCommandUI();    
		}
		else
		{
			// The source control provider indicate that this file can't be edited, so undo the changes.
			GetControl().Undo();
		}
	}
	return 0; // return value is ignored
}

template <class Traits_T>
LRESULT EditorDocument<Traits_T>::OnSelectionChange(int /*wParam*/, _In_ LPNMHDR /*pHeader*/, BOOL& /*bHandled*/)
{
	StatusBarUpdatePos();
	UpdateVSCommandUI();
	return 0; // return value is ignored
}

template <class Traits_T>
LRESULT EditorDocument<Traits_T>::OnUserInteractionEvent(int /*wParam*/, _In_ LPNMHDR pHeader, BOOL& /*bHandled*/)
{
	CHKPTR(pHeader, E_FAIL);
	MSGFILTER* pMsgFilter = reinterpret_cast<MSGFILTER*>(pHeader);

	// Non-zero indicates the RTF control should not handle the message
	// Use this as the default and let the default cases set it to 0
	// for events not handled here
	LRESULT iRet = 1;

	switch(pMsgFilter->msg)
	{
	case WM_RBUTTONUP:
		{
			// Convert to screen coordinates
			POINT pt;
			POINTSTOPOINT(pt, MAKEPOINTS(pMsgFilter->lParam));
			GetControl().ClientToScreen(&pt);
			CHK(pt.x <= SHRT_MAX && pt.x > 0, E_FAIL);
			CHK(pt.y <= SHRT_MAX && pt.y > 0, E_FAIL);

			POINTS ptsTemp = {static_cast<short>(pt.x) , static_cast<short>(pt.y)};

			// Now show the context menu
			CComPtr<IOleComponentUIManager> spIOleComponentUIManager;
			CHKHR(GetVsSiteCache().QueryService(SID_SOleComponentUIManager, &spIOleComponentUIManager));
			CHKHR(spIOleComponentUIManager->ShowContextMenu(OLEROLE_TOPLEVELCOMPONENT,
			   CLSID_%ProjectClass%CmdSet,
			   IDMX_RTF,
			   ptsTemp,
			   (IOleCommandTarget *) this));
		}
		break;               

	case WM_CHAR:
		{

		// CTRL+A/"Select All" is handled seperately from the others, since this command does
		// does not modify the content
		if(1 == pMsgFilter->wParam)
		{
			iRet = 0;
			break;
		}

		// If the document is dirty, it isn't necessary to determine if the file
		// can be edited currently, as it has to editable inorder to be dirty
		bool bDiscardInput = false;
		if(!IsFileDirty())
		{
			// Determine if editing is currently possible
			bDiscardInput = ShouldDiscardChange();
		}

		// Discard the input if the user has decided not to check the file out
		// or if the file has been reloaded
		if(bDiscardInput || IsFileReloaded())
		{
			SetFileReloaded(false);
			break;
		}

		iRet = 0;

		break;
		}

	default:
		// Return value of 0 indicates that the control should process the event.
		// Since this message isn't handled here, let the control handle it.
		iRet = 0;
		break;
	}

	
	return iRet;
}

template <class Traits_T>
LRESULT EditorDocument<Traits_T>::OnTimer(UINT /*uMsg*/, _In_ WPARAM wParam, _In_ LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
    if(WFILECHANGEDTIMERID == wParam)
    {
        // This timer is set in DocumentPersistanceBase::FilesChanged which is a notification
        // from the SVsFileChangeEx service that the file has changed outside of the 
		// environment. Prompt the user as to whether they want to reload the file or not.
        // See comments in DocumentPersistanceBase::FilesChanged for more details.

		Control::Window activeWindow(Control::Window::GetActiveWindow());
		if(!activeWindow.IsWindow())
		{
			// GetActiveWindow doesn't set the last error, so all we do here is indicate
			// that the message was processed (nothing else with process this message,
			// correctly either).
			return 0; // 0 indicates the message was processed
		}
        
        // If this process is the active window, shut off the timer and prompt to reload file.
		if(::GetCurrentProcessId() == GetWindowProcessID())
        {
            KillTimer(WFILECHANGEDTIMERID);

			OleComponentUIManagerUtilities<VsUtilityLocalSiteControl> util;
			util.SetSite(GetVsSiteCache());
			if(IDYES == util.ShowMessage(const_cast<wchar_t*>(static_cast<const wchar_t*>(GetFileName())), IDS_OUTSIDEEDITORFILECHANGE, OLEMSGBUTTON_YESNO, OLEMSGDEFBUTTON_FIRST, OLEMSGICON_QUERY))
            {
                ReloadDocData(0);
            }

            NotifyFileChangedTimerHandled();
        }
    }
	else if(WDELAYSTATUSBARUPDATETIMERID == wParam)
	{
		KillTimer(WDELAYSTATUSBARUPDATETIMERID);
		SetInfo();
	}
	return 0; // 0 indicates the message was processed
}

template <class Traits_T>
LRESULT EditorDocument<Traits_T>::OnSetFocus(UINT /*uMsg*/, _In_ WPARAM /*wParam*/, _In_ LPARAM /*lParam*/, BOOL& bHandled)
{
	// Just hook this message, don't handle it.
	bHandled = FALSE;

	// Update the status bar
	SetInfo();

	// The results pane is very aggresive in updating the status bar
	// and will update it even after it has lost focus, so set a short
	// timer to update the staus bar again, in case this occurs
	VSL_CHECKBOOL_GLE(0 != SetTimer(WDELAYSTATUSBARUPDATETIMERID, 100, NULL));

	return 0;  // Ignored, since this is not the final handler of the message
}

// Only the Copy, Cut, Paste and Delete commands are explicitly recorded by the document.  The 
// command will be recorded via the macro default recording mechanism that attempts to record 
// any command not handled by this document

#define RETURN_IF_CANT_EDIT() \
	if(ShouldDiscardChange()) \
	{ \
		return; \
	}


template <class Traits_T>
void EditorDocument<Traits_T>::OnCopy(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	// Delegate to the Copy method on the automation interface
	CHKHR(Copy());
	// Record the command if necessary
	RecordCommand(L"Copy");
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryCopy(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// If there is no selection, there it is not possible to copy anything
	pOleCmd[0].cmdf = (IsSelectionEmpty() ? OLECMDSTATE_DISABLED : OLECMDSTATE_UP);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnCut(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();

	// Delegate to the Cut method on the automation interface
	CHKHR(Cut());
	// Record the command if necessary
	RecordCommand(L"Cut");
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryCut(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// Can't cut (via the menu) unless there is a selection
	pOleCmd[0].cmdf = (IsSelectionEmpty()) ? OLECMDSTATE_DISABLED : OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnDelete(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();

	// Delegate to the Delete method on the automation interface
	CHKHR(Delete(tomCharacter, 1));
	// Record the command if necessary
	RecordDelete();
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnPaste(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();

	// Delegate to the Paste method on the automation interface
	CHKHR(Paste());
	// Record the command if necessary
	RecordCommand(L"Paste");
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryPaste(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);
	// Determine if pasting currently
	long bCanPaste = tomFalse;
    CHKHR(spITextSelection->CanPaste(NULL, 0, &bCanPaste));
	if(bCanPaste == tomTrue)
	{
		pOleCmd[0].cmdf = OLECMDSTATE_UP;
	}
	else
	{
	    pOleCmd[0].cmdf = OLECMDSTATE_DISABLED;
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnBold(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetFontFormatState(CFE_BOLD);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryBold(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = GetFontFormatState(CFE_BOLD);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnItalic(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetFontFormatState(CFE_ITALIC);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryItalic(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = GetFontFormatState(CFE_ITALIC);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnUnderline(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetFontFormatState(CFE_UNDERLINE);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryUnderline(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = GetFontFormatState(CFE_UNDERLINE);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnJustifyLeft(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetParagraphAlignment(tomAlignLeft);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryJustifyLeft(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = QueryParagraphAlignmentState(tomAlignLeft);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnJustifyRight(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetParagraphAlignment(tomAlignRight);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryJustifyRight(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = QueryParagraphAlignmentState(tomAlignRight);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnJustifyCenter(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetParagraphAlignment(tomAlignCenter);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryJustifyCenter(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = QueryParagraphAlignmentState(tomAlignCenter);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnFontNameGetList(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* pOut)
{
	// This command fills the drop-down list for the font name combo box.
	if(OLECMDEXECOPT_DODEFAULT == flags)
	{
		static VsFontCommandHandling::FontNameContainerElementDeallocator<FontNameList> fontNameListDeallocator;
		if(fontNameListDeallocator.GetContainer().size() == 0)
		{
			VsFontCommandHandling::PopulateFontNameContainerElementDeallocator(fontNameListDeallocator);
		}
		VsFontCommandHandling::FontContainerToVariant(fontNameListDeallocator.GetContainer(), pOut);
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryFontNameGetList(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// Since this is a drop down, rather then a button, it is always up
	pOleCmd[0].cmdf = OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnFontName(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* pIn, _Out_ VARIANT* pOut)
{
    if(OLECMDEXECOPT_DODEFAULT == flags)
    {
        // If there is an in value the use it to set the font.
        if(NULL != pIn)
        {
            // Only allow modifications if the is not read-only or it has been made editable anyway
            if(!ShouldDiscardChange())
			{
                SetFontName(pIn);
			}
        }
        else
        {
            CHKPTR(pOut, E_INVALIDARG);
            // Retrieve the current font name.
            GetFontName(pOut); 
        }
    }
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryFontName(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// Since this is a drop down, rather then a button, it is always up
	pOleCmd[0].cmdf = OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnFontSizeGetList(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* pOut)
{
	if(OLECMDEXECOPT_DODEFAULT == flags)
	{
		// Available font sizes are just hard coded, which means they
		// are the same for every font
		static StaticArray<wchar_t*, 16> szFontSizeStrings =
		{
			{ 
					L"8",
					L"9", 
					L"10", 
					L"11", 
					L"12", 
					L"14", 
					L"16", 
					L"18",
					L"20",
					L"22",
					L"24",
					L"26",
					L"28",
					L"36",
					L"48",
					L"72"
			}
		};

		// This will fill in pOut with the value of szFontSizeStrings
		VsFontCommandHandling::FontContainerToVariant(szFontSizeStrings, pOut);
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryFontSizeGetList(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// Since this is a drop down, rather then a button, it is always up
	pOleCmd[0].cmdf = OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnFontSize(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* pIn, _Out_ VARIANT* pOut)
{
    if(OLECMDEXECOPT_DODEFAULT == flags)
    {
        // If there is an in value the use it to set the font szie.
        if(NULL != pIn)
        {
            // Only allow modifications if the is not read-only or it has been made editable anyway
            if(!ShouldDiscardChange())
			{
                SetFontSize(pIn);
			}
        }
        else
        {
            CHKPTR(pOut, E_INVALIDARG);
            // Retrieve the current font size.
            GetFontSize(pOut); 
        }
    }
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryFontSize(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// Since this is a drop down, rather then a button, it is always up
	pOleCmd[0].cmdf = OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnPasteNextTBXCBItem(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	PasteClipboardObject();
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryPasteNextTBXCBItem(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// Note that if the file is not editable then cmdidPasteNextTBXCBItem command is considered disabled
	if(!IsFileEditable())
	{
		pOleCmd[0].cmdf = OLECMDSTATE_DISABLED;
	}
	else
	{
		pOleCmd[0].cmdf = OLECMDF_SUPPORTED;
		if(CanCycleClipboard())
		{
			pOleCmd[0].cmdf |= OLECMDF_ENABLED;
		}
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnBulletedList(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	ToggleBulleted();
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryBulletedList(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = GetBulletState();
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnInsert(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	long grfFlags = GetTextSelectionFlags();
	grfFlags = (grfFlags & tomSelOvertype) ? (grfFlags & ~tomSelOvertype) : (grfFlags | tomSelOvertype);
	CHKHR(put_Flags(grfFlags));
	StatusBarUpdateInsMode();
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryInsert(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	// tomSelOvertype indicates the toggle state of insert
	pOleCmd[0].cmdf = (GetTextSelectionFlags() & tomSelOvertype) ? OLECMDSTATE_DOWN : OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnStrikeOut(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/)
{
	RETURN_IF_CANT_EDIT();
	SetFontFormatState(CFE_STRIKEOUT);
}

template <class Traits_T>
void EditorDocument<Traits_T>::OnQueryStrikeOut(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/)
{
	pOleCmd[0].cmdf = GetFontFormatState(CFE_STRIKEOUT);
}

template <class Traits_T>
bool EditorDocument<Traits_T>::ShouldDiscardChange()
{
	// If the buffer is already Read/Write or edit enabled no need to check further
	// as the change need not be discarded
	if(IsFileEditableWhenReadOnly())
	{
		return false;
	}

    CComPtr<IVsQueryEditQuerySave2> spIVsQueryEditQuerySave2;
	CHKHR(GetVsSiteCache().QueryService(SID_SVsQueryEditQuerySave, &spIVsQueryEditQuerySave2));

	// Array of the file names to check, which in this case is just one.
	LPCOLESTR bstrFiles[] = {GetFileName()};
	VSQueryEditResult iEditResult = QER_EditNotOK;
	VSQueryEditResultFlags iEditResultFlags = 0;
	CHKHR(spIVsQueryEditQuerySave2->QueryEditFiles(
		QEF_AllowInMemoryEdits,
		1,
		bstrFiles,
		NULL,
		NULL,
		&iEditResult,
		&iEditResultFlags));

	if(QER_EditOK == iEditResult)
	{
		GetControl().SetReadOnly(false);

		// We cannot distinguish here between the case when a file has been checked out and the
		// case where the user has decided to allow in-memory edits for a read-only file so we
		// set "read edits enabled" bit.
		if(iEditResultFlags & QER_InMemoryEdit)
		{
			// QER_InMemoryEdit indicates an in memory edit for a read-only file
			SetFileEditableWhenReadOnly(true);
		}

		return false;
	}

	// In this case, the file is still read only, so the change needs to be discarded.
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorDocument.h ===
// EditorDocument.h

#pragma once

/***************************************************************************

EditorDocument provides the implementation of a single view editor (as opposed to a 
multi-view editor that can display the same file in multiple modes like the HTML editor).

%ProjectName%.pkgdef contains:

[$RootKey$\KeyBindingTables\{%DocumentGuid%}]
@="#1"
"AllowNavKeyBinding"=dword:00000000
"Package"="{%PackageGuid%}"

which is required for some, but not all, of the key bindings, which are located at the bottom of 
%ProjectClass%UI.vsct, to work correctly so that the appropriate command handler below will be
called.

***************************************************************************/

// This is provided as a template parameter to facilitate unit testing
// One traits class is provided rather then multiple template arguments
// so that when an new type is added, it isn't necessary to update all
// instances of the template decleration
class EditorDocumentDefaultTraits
{
public:
	// The rich edit control needs to be contained in another window, as the list view will send 
	// it's notifications to it's parent window; however, if the VS frame window is subclassed, VS
	// may stomp on the window proc we have set, so we have to provide our own parent window
	// for the control.
	typedef Win32ControlContainer<RichEditWin32Control<> > RichEditContainer;
	typedef VSL::Cursor Cursor;
	typedef VSL::Keyboard Keyboard;
	typedef VSL::File File;
};

template <class Traits_T = EditorDocumentDefaultTraits>
class EditorDocument : 
	// Use ATL to take care of common COM infrastructure
	public CComObjectRootEx<CComSingleThreadModel>,
	// IVsWindowPane is required to be a document
	public IVsWindowPaneImpl<EditorDocument<Traits_T> >,
	// IOleCommandTarget is required to be a document that handles commands (as any editor will need to do)
	public IOleCommandTargetImpl<EditorDocument<Traits_T> >,
	// DocumentPersistanceBase provides the persistance related interfaces: IVsPersistDocData, 
	// IVsDocDataFileChangeContro, IVsFileChangeEvents, IPersistFileFormat, and IVsFileBackup.
	public DocumentPersistanceBase<EditorDocument<Traits_T>, typename Traits_T::File>,
	// ISelectionContainer is required for the properties windows to be updated.
	// The document only has one item to display properties for, so ISelectionContainerSingleItemImpl
	// is used rather then ISelectionContainerImpl
	public ISelectionContainerSingleItemImpl<EditorDocument<Traits_T>, ITextDocument>,
	// IVsToolboxUser is required for items be dragged from the toolbox on to the document
	public IVsToolboxUser,
	// IVsStatusbarUser is required to update the line and character position on the status bar,
	// as well as the insertion (INS at the right most end of the status bar) state.
	public IVsStatusbarUser,
	// Custom automation interface used with macro recording and playback
	public IDispatchImpl<ISingleViewEditor, &__uuidof(ISingleViewEditor), &LIBID_%ProjectClass%Lib>,
	// IExtensibleObject or IVsExtensibleObject is required to be an automation object
	// IExtensibleObject is newer and prefered.
	public IExtensibleObjectImpl<EditorDocument<Traits_T> >,
	// IVsFindTarget, IVsTextImage, and IVsTextSpanSet are required for find and replace to work correctly
	public IVsFindTargetImpl<EditorDocument<Traits_T>, TRUE>,
	public IVsTextImageImpl<>,
	public IVsTextSpanSetImpl,
	// IVsTextView, IVsTextViewEvents, IVsCodeWindow, IVsTextLines along with the a connection point 
	// for IVsTextViewEvents, are required so that double-clicking on results of a find in files in the 
	// output window will correctly naviagate to the location in the document.  That is the only
	// scenario these interfaces are required for.
	public SingleViewFindInFilesOutputWindowIntegrationImpl<EditorDocument<Traits_T> >,
	public ATL::IConnectionPointContainerImpl<EditorDocument<Traits_T> >,
	// This is required in addition to IConnectionPointContainer for the connection map to compile properly
	// This interface is not included in the interface map though, so it can not be QI'ed for.
	public ATL::IConnectionPointImpl<EditorDocument<Traits_T>, &IID_IVsTextViewEvents>,
	// The container for the rich edit control is the actual window associated with IVsWindowPane
	// rather then the rich edit control, as the the parent window of IVsWindowPane is owned by
	// the Visual Studio IDE and can not be used as the parent window of the rich edit control,
	// it it can not be reliably sub-classed (VS doesn't guarantee it will not overwrite the
	// window procedure).
	public Traits_T::RichEditContainer
{

// COM objects typically should not be cloned, and this prevents cloning by declaring the 
// copy constructor and assignment operator private (NOTE:  this macro includes the decleration of
// a private section, so everything following this macro and preceding a public or protected 
// section will be private).
VSL_DECLARE_NOT_COPYABLE(EditorDocument)

public:

	typedef typename Traits_T::File File;

// Provides a portion of the implementation of IUnknown, in particular the list of interfaces
// the EditorDocument object will support via QueryInterface
BEGIN_COM_MAP(EditorDocument)
	COM_INTERFACE_ENTRY(IVsWindowPane)    
	COM_INTERFACE_ENTRY(ISelectionContainer)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(IPersistFileFormat)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IVsPersistDocData)
	COM_INTERFACE_ENTRY(IVsFileChangeEvents)
	COM_INTERFACE_ENTRY(IVsDocDataFileChangeControl)
	COM_INTERFACE_ENTRY(IVsFileBackup)
	COM_INTERFACE_ENTRY(IVsToolboxUser)
	COM_INTERFACE_ENTRY(IVsStatusbarUser)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISingleViewEditor)
	COM_INTERFACE_ENTRY(IExtensibleObject)
	COM_INTERFACE_ENTRY(IVsFindTarget)
	COM_INTERFACE_ENTRY(IVsTextImage)
	COM_INTERFACE_ENTRY(IVsTextSpanSet)
	COM_INTERFACE_ENTRY(IVsTextBuffer)
	COM_INTERFACE_ENTRY(IVsTextView)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	// IConnectionPoint is purposefully omitted
	COM_INTERFACE_ENTRY(IVsTextViewEvents)
	COM_INTERFACE_ENTRY(IVsCodeWindow)
	COM_INTERFACE_ENTRY(IVsTextLines)
END_COM_MAP()

// Defines the command handlers. IOleCommandTargetImpl will use these handlers to implement
// IOleCommandTarget.
VSL_BEGIN_COMMAND_MAP()
	// Every command is identified by the shell using a GUID/DWORD pair, so every the definition of
	// commands must contain this information.

	// The following command map entries define a GUID/DWORD pair to identify the command and a 
	// callback for the command execution and status queries.
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidCopy, &OnQueryCopy, &OnCopy)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidCut, &OnQueryCut, &OnCut)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidDelete, NULL, &OnDelete)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidPaste, &OnQueryPaste, &OnPaste)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidBold, &OnQueryBold, &OnBold)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidItalic, &OnQueryItalic, &OnItalic)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidUnderline, &OnQueryUnderline, &OnUnderline)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidJustifyLeft, &OnQueryJustifyLeft, &OnJustifyLeft)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidJustifyRight, &OnQueryJustifyRight, &OnJustifyRight)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidJustifyCenter, &OnQueryJustifyCenter, &OnJustifyCenter)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidFontNameGetList, &OnQueryFontNameGetList, &OnFontNameGetList)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidFontName, &OnQueryFontName, &OnFontName)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidFontSizeGetList, &OnQueryFontSizeGetList, &OnFontSizeGetList)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidFontSize, &OnQueryFontSize, &OnFontSize)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet97, cmdidPasteNextTBXCBItem, &OnQueryPasteNextTBXCBItem, &OnPasteNextTBXCBItem)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet2K, ECMD_BULLETEDLIST, &OnQueryBulletedList, &OnBulletedList)
	VSL_COMMAND_MAP_ENTRY(CMDSETID_StandardCommandSet2K, ECMD_INSERT, &OnQueryInsert, &OnInsert)
	VSL_COMMAND_MAP_ENTRY(CLSID_%ProjectClass%CmdSet, commandIDStrike, &OnQueryStrikeOut, &OnStrikeOut)

// Terminate the definition of the command map
VSL_END_VSCOMMAND_MAP()

VSL_BEGIN_MSG_MAP(EditorDocument)
	// Whenever the content changes, need to check and see if the file can be edited,
	// if not then the changes will be rejected.
	COMMAND_HANDLER(RichEditContainer::iContainedControlID, EN_CHANGE, OnContentChange)
	// Whenever the selection changes, need to update the Visual Studio UI (i.e. status bar, menus, 
	// and toolbars).
	NOTIFY_HANDLER(RichEditContainer::iContainedControlID, EN_SELCHANGE, OnSelectionChange)
	// On this event the context menu will be shown if needed, and some keyboard commands will be
	// dealt with.
	NOTIFY_HANDLER(RichEditContainer::iContainedControlID, EN_MSGFILTER, OnUserInteractionEvent)
	MESSAGE_HANDLER(WM_TIMER, OnTimer)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	// Let the rich edit container process all other messages
	CHAIN_MSG_MAP(RichEditContainer)
VSL_END_MSG_MAP()

// This is necessary to implement the connection point for IVsTextViewEvents
// See comment above SingleViewFindInFilesOutputWindowIntegrationImpl
BEGIN_CONNECTION_POINT_MAP(EditorDocument)
	CONNECTION_POINT_ENTRY(IID_IVsTextViewEvents)
END_CONNECTION_POINT_MAP()

// IVsWindowPane methods overriden or not provided by IVsWindowPaneImpl

	STDMETHOD(CreatePaneWindow)(
		/*[in] */ _In_ HWND hwndParent,
		/*[in] */ _In_ int x,
		/*[in] */ _In_ int y,
		/*[in] */ _In_ int cx,
		/*[in] */ _In_ int cy,
		/*[out]*/ _Out_ HWND *hwnd);
	STDMETHOD(GetDefaultSize)(
		/*[out]*/ _Out_ SIZE *psize);
	STDMETHOD(ClosePane)();

// IVsToolboxUser method

	STDMETHOD(IsSupported)(/*[in] */ _In_ IDataObject* pDO);
	STDMETHOD(ItemPicked)(/*[in] */ _In_ IDataObject* pDO);

// ISingleViewEditor - this is the object model exposed by the editor in order to
// facilitate macro recording.

	STDMETHOD(get_DTE)(/* [out] */ _Deref_out_ _DTE** ppDTE);
	STDMETHOD(get_Parent)(/* [out] */ _Deref_out_ _DTE** ppDTE);
	STDMETHOD(get_DefaultTabStop)(/* [out] */ _Out_ float* pdVal);
	STDMETHOD(put_DefaultTabStop)(/* [in] */ float dVal);
	STDMETHOD(get_Range)(/* [out] */ _Deref_out_ /*ITextRange*/IDispatch** ppRange);
	STDMETHOD(get_Selection)(/* [out] */ _Deref_out_ /*ITextSelection*/IDispatch** ppSelection);
	STDMETHOD(get_Flags)(/* [out] */ _Out_ long* plFlags);
	STDMETHOD(put_Flags)(/* [in] */ long lFlags);
	STDMETHOD(FindText)(/* [in] */ _In_ BSTR pStr);
	STDMETHOD(SetText)(/* [in] */ _In_ BSTR pStr);
	STDMETHOD(TypeText)(/* [in] */ _In_ BSTR pStr);
	STDMETHOD(Cut)();
	STDMETHOD(Copy)();
	STDMETHOD(Paste)();
	STDMETHOD(Delete)(
		/* [in] */ long lUnit,
		/* [in] */ long cUnit);
	STDMETHOD(MoveUp)(
		/* [in] */ long lUnit,
		/* [in] */ long cUnit,
		/* [in] */ long lExtend);
	STDMETHOD(MoveDown)(
		/* [in] */ long lUnit,
		/* [in] */ long cUnit,
		/* [in] */ long lExtend);
	STDMETHOD(MoveLeft)(
		/* [in] */ long lUnit,
		/* [in] */ long cUnit,
		/* [in] */ long lExtend);
	STDMETHOD(MoveRight)(
		/* [in] */ long lUnit,
		/* [in] */ long cUnit,
		/* [in] */ long lExtend);
	STDMETHOD(EndKey)(
		/* [in] */ long lUnit,
		/* [in] */ long lExtend);
	STDMETHOD(HomeKey)(
		/* [in] */ long lUnit,
		/* [in] */ long lExtend);
					
// IVsStatusbarUser methods

	STDMETHOD(SetInfo)();

// IVsFindTarget methods

	STDMETHOD(GetProperty)( 
		/* [in] */ VSFTPROPID propid,
		/* [out]*/ _Out_ VARIANT* pvar);
	STDMETHOD(NavigateTo)(
		/* [in] */ const TextSpan* pts);
	STDMETHOD(GetCurrentSpan)(
		/* [out]*/ _Out_ TextSpan* pts);

// IVsTextImage methods

	 STDMETHOD(GetLineSize)( 
		/* [retval][out] */ _Out_ LONG* pcLines); 
	 STDMETHOD(Replace)( 
		/* [in] */ DWORD dwFlags,
		/* [in] */ const TextSpan* pts,
		/* [in] */ LONG cch,
		/* [size_is][in] */ LPCOLESTR pchText,
		/* [retval][out] */ _Out_ TextSpan* ptsChanged); 
	 STDMETHOD(GetSpanLength)( 
		/* [in] */ const TextSpan* pts,
		/* [retval][out] */ _Out_ LONG* pcch); 
	 STDMETHOD(GetLineLength)( 
		/* [in] */ LONG iLine,
		/* [retval][out] */ _Out_ LONG* piLength); 
	 STDMETHOD(GetLine)( 
		/* [in] */ DWORD grfGet,
		/* [in] */ LONG iLine,
		/* [in] */ LONG iStartIndex,
		/* [in] */ LONG iEndIndex,
		/* [retval][out] */ _Out_ LINEDATAEX* pLineData); 

// IVsTextLines methods not provided by SingleViewFindInFilesOutputWindowIntegrationImpl

	STDMETHOD(GetLengthOfLine)(
        /* [in] */ long iLine,
        /* [out] */ _Out_ long *piLength);
	STDMETHOD(GetLastLineIndex)(
        /* [out] */ _Out_ long *piLine,
        /* [out] */ _Out_ long *piIndex);

// IVsTextView methods not provided by SingleViewFindInFilesOutputWindowIntegrationImpl

	STDMETHOD(SetSelection)(
        /* [in] */ long iAnchorLine,
        /* [in] */ ViewCol iAnchorCol,
        /* [in] */ long iEndLine,
        /* [in] */ ViewCol iEndCol);

// VSL base class statically bound call back methods

	// Called by IExtensibleObjectImpl::GetAutomationObject
	IDispatch* GetNamedAutomationObject(_In_z_ BSTR bstrName);

	// Called by VSL::DocumentPersistanceBase::InitNew and VSL::DocumentPersistanceBase::Save
	bool IsValidFormat(DWORD dwFormatIndex);

	// Called by VSL::DocumentPersistanceBase::FilesChanged
	void OnFileChangedSetTimer();

	// Called by VSL::DocumentPersistanceBase::GetClassID, which is also called by 
	// VSL::DocumentPersistanceBase::GetGuidEditorType)
	const GUID& GetEditorTypeGuid() const;

	// Called by VSL::DocumentPersistanceBase::GetFormatList
	void GetFormatListString(ATL::CStringW& rstrFormatList);

	// Called indirectly by VSL::DocumentPersistanceBase::Load and VSL::DocumentPersistanceBase::Save
	void PostSetDirty();

	// Called indirectly by VSL::DocumentPersistanceBase::FilesChanged, 
	// VSL::DocumentPersistanceBase::IgnoreFileChanges, VSL::DocumentPersistanceBase::Load, and 
	// VSL::DocumentPersistanceBase::Save
	void PostSetReadOnly();

	// FUTURE - 3/17/2006 - could move the 2 following methods on to the Rich Edit control in VSL

	// Called by the IPersistFileFormat::Load implementation on DocumentPersistanceBase
	HRESULT ReadData(File& rFile, BOOL bInsert, DWORD& rdwFormatIndex) throw();

	// Called indirectly by IPersistFileFormat::Save and IVsFileBackup::BackupFile implementations 
	// on DocumentPersistanceBase
	void WriteData(File& rFile, DWORD /*dwFormatIndex*/);

	// Called by VSL::IVsFindTargetImpl::GetCapabilities and 
	// VSL::IVsFindTargetImpl::GetSearchImage
	DWORD GetCapabilityOptions();

protected:

	typedef typename Traits_T::RichEditContainer RichEditContainer;
	typedef typename Traits_T::RichEditContainer::Control Control;
	typedef typename Traits_T::Keyboard Keyboard;

	typedef typename IVsWindowPaneImpl<EditorDocument<Traits_T> >::VsSiteCache VsSiteCache;

	typedef EditorDocument<Traits_T> This;

	EditorDocument():
		m_pWindowProc(NULL),
		m_bClosed(false)
	{
	}

	~EditorDocument()
	{
		VSL_ASSERT(m_bClosed);
		if(!m_bClosed)
		{
			// Paranoid clean-up.  Ignore return value, nothing to do if this fails,
			// and execution should not have arrived here anyway.
			ClosePane();
		}
	}

	// Called by the Rich Edit control during the processing of EM_STREAMOUT and EM_STREAMIN
	template <bool bRead_T>
	static DWORD CALLBACK EditStreamCallback(
		_In_ DWORD_PTR dwpFile, 
		_Inout_bytecap_(iBufferByteSize) LPBYTE pBuffer, 
		LONG iBufferByteSize, 
		_Out_ LONG* piBytesWritten);

	// Window Proc for the rich edit control.  Necessary to implement macro recording.
	static LRESULT CALLBACK RichEditWindowProc(
		_In_ HWND hWnd, 
		UINT msg, 
		_In_ WPARAM wParam, 
		_In_ LPARAM lParam);

#pragma warning(push)
#pragma warning(disable : 4480) // // warning C4480: nonstandard extension used: specifying underlying type for enum
	enum TimerID : WPARAM
	{
		// ID of timer message sent from OnFileChangedSetTimer
		WFILECHANGEDTIMERID = 1,
		// ID of timer message sent from OnSetFocus
		WDELAYSTATUSBARUPDATETIMERID = 2,
	};
#pragma warning(pop)

private:

// Windows message handlers

	LRESULT OnContentChange(WORD /*iCommand*/, WORD /*iId*/, _In_ HWND hWindow, BOOL& /*bHandled*/);
	LRESULT OnSelectionChange(int /*wParam*/, _In_ LPNMHDR /*pHeader*/, BOOL& /*bHandled*/);
	LRESULT OnUserInteractionEvent(int /*wParam*/, _In_ LPNMHDR pHeader, BOOL& /*bHandled*/);
	LRESULT OnTimer(UINT /*uMsg*/, _In_ WPARAM wParam, _In_ LPARAM /*lParam*/, BOOL& /*bHandled*/);
	LRESULT OnSetFocus(UINT /*uMsg*/, _In_ WPARAM wParam, _In_ LPARAM /*lParam*/, BOOL& bHandled);

// Visual Studio command handlers

	void OnCopy(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryCopy(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnCut(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryCut(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnDelete(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnPaste(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryPaste(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnBold(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryBold(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnItalic(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryItalic(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnUnderline(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryUnderline(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnJustifyLeft(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryJustifyLeft(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnJustifyRight(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryJustifyRight(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnJustifyCenter(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryJustifyCenter(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnFontNameGetList(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* pOut);
	void OnQueryFontNameGetList(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnFontName(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* pIn, _Out_ VARIANT* pOut);
	void OnQueryFontName(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnFontSizeGetList(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* pOut);
	void OnQueryFontSizeGetList(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnFontSize(_In_ CommandHandler* /*pSender*/, DWORD flags, _In_ VARIANT* pIn, _Out_ VARIANT* pOut);
	void OnQueryFontSize(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnPasteNextTBXCBItem(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryPasteNextTBXCBItem(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnBulletedList(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryBulletedList(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnInsert(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryInsert(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);
	void OnStrikeOut(_In_ CommandHandler* /*pSender*/, DWORD /*flags*/, _In_ VARIANT* /*pIn*/, _Out_ VARIANT* /*pOut*/);
	void OnQueryStrikeOut(const CommandHandler& /*rSender*/, _Inout_ OLECMD* pOleCmd, _Inout_ OLECMDTEXT* /*pOleText*/);

// Rich Edit object model helper methods

	void GetTextSelection(CComPtr<ITextSelection>& rspITextSelection)
	{
		EnsureNotClosed();
		CHKHR(GetControl().GetITextDocument()->GetSelection(&rspITextSelection));
		CHKPTR(rspITextSelection.p, E_FAIL);
	}

	void GetTextRange(CComPtr<ITextRange>& rspITextRange)
	{
		EnsureNotClosed();
		CHKHR(GetControl().GetITextDocument()->Range(0, tomForward, &rspITextRange));
		CHKPTR(rspITextRange.p, E_FAIL);
	}

	void GetTextFont(CComPtr<ITextFont>& rspITextFont)
	{
		CComPtr<ITextSelection>	spITextSelection;
		GetTextSelection(spITextSelection);
		CHKHR(spITextSelection->GetFont(&rspITextFont));
	}

	void GetTextPara(CComPtr<ITextPara>& rspITextPara)
	{
		CComPtr<ITextSelection>	spITextSelection;
		GetTextSelection(spITextSelection);
		CHKHR(spITextSelection->GetPara(&rspITextPara));
	}

	// Helper function to obtain the ITextSelection flags
	long GetTextSelectionFlags();

// Macro recording helper methods

	// Last command type sent to the macro recorder. Note that there are more commands
	// recorded than is implied by this list.
	enum LastMacro
	{
		eLastMacroNone = 0,
		eLastMacroText,
		eLastMacroDownArrowLine,
		eLastMacroDownArrowLineSel,
		eLastMacroDownArrowPara,
		eLastMacroDownArrowParaSel,
		eLastMacroUpArrowLine,
		eLastMacroUpArrowLineSel,
		eLastMacroUpArrowPara,
		eLastMacroUpArrowParaSel,
		eLastMacroLeftArrowChar,
		eLastMacroLeftArrowCharSel,
		eLastMacroLeftArrowWord,
		eLastMacroLeftArrowWordSel,
		eLastMacroRightArrowChar,
		eLastMacroRightArrowCharSel,
		eLastMacroRightArrowWord,
		eLastMacroRightArrowWordSel,
		eLastMacroDeleteChar,
		eLastMacroDeleteWord,
		eLastMacroBackSpaceChar,
		eLastMacroBackSpaceWord
	};

	void RecordCommand(const wchar_t* szCommand);

	// Member functions used to interface with the shell macro recording service.
	// Note that although macro recording may fail we do not return any errors.
	void RecordKeyStroke(UINT msg, _In_ WPARAM wParam, _In_ LPARAM lParam);

	// This function outputs a line to the macro recorder in response to a
	// delete or backspace key.
	void RecordDelete(bool bBackspace = false, bool bWord = false);

	// This function outputs a line to the macro recorder in response to an
	// Up, Down, Left or Right Arrow.

	enum MoveScope
	{
		Character = tomCharacter,
		Word = tomWord,
		Line = tomLine,
		Paragraph = tomParagraph
	};

	void RecordMove(LastMacro eState, LPCWSTR szDirection, MoveScope eScope, bool bExtend);

// Find and Replace helper methods

	// IVsFindTarget helper to get selection string if it is only single line
	void GetInitialPattern(_Deref_out_z_ BSTR *pbstrSelection);

// Format command handler helper methods

	// Function to obtain and set Character and paragraph properties.
	DWORD GetFontFormatState(DWORD dwEffect);
	void SetFontFormatState(DWORD dwEffect);
	DWORD QueryParagraphAlignmentState(long lState);
	DWORD GetBulletState();
	void SetParagraphAlignment(long iAlignment);
	void ToggleBulleted();

// Font command handler helper methods

	typedef std::list<BSTR> FontNameList;

	// OleCommandTarget Helper functions for selecting font names and sizes.
	void GetFontName(_Out_ VARIANT *pvarOut);
	void GetFontSize(_Out_ VARIANT *pvarOut);
	void SetFontName(_In_ VARIANT *pvarNew);
	void SetFontSize(_In_ VARIANT *pvarNew);

// Helper function for query status for command cmdidPasteNextTBXCBItem

	bool CanCycleClipboard();
	void PasteClipboardObject();

// IVsToolboxUser helper

	void IVsToolboxUserHelper(_In_ IDataObject* pDataObject, ATL::CComVariant& vt);

// Status bar helper functions

	void StatusBarUpdatePos(_In_ IVsStatusbar* pIVsStatusBar = NULL);
	void StatusBarUpdateInsMode(_In_ IVsStatusbar* pIVsStatusBar = NULL);

// Miscelanous helper methods

	// Selection helpers
	bool IsSelectionEmpty();

	// Helper function to checkout file if necessary.
	bool ShouldDiscardChange();

	// Calls IVsUIShell method to tell the environment to update the state of 
	// the command bars (menus and toolbars).
	void UpdateVSCommandUI();

	void EnsureNotClosed()
	{
		CHK(!m_bClosed, E_UNEXPECTED);
	}

// Data members

	// Simplifies macro recording
	VsMacroRecorder<&CLSID_%ProjectClass%EditorDocument, LastMacro, eLastMacroNone> m_Recorder;

	// Window procedure pointer for the window containing the rich edit control
	WNDPROC m_pWindowProc;

	// Buffer for text input during macro recording
	CStringW m_strTextToRecord;

	// IVsWindowPane Data
	bool m_bClosed;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorFindAndReplace.inl ===
// EditorFindAndReplace.inl

#pragma once

/***************************************************************************
IVsFindTarget implementation
***************************************************************************/

// Called by VSL::IVsFindTargetImpl::GetCapabilities and 
// VSL::IVsFindTargetImpl::GetSearchImage
template <class Traits_T>
DWORD EditorDocument<Traits_T>::GetCapabilityOptions()
{
	DWORD dwOptions =
		FR_MatchCase |    // Match case
		FR_WholeWord |    // Match whole word
		FR_Hidden |       // Hidden text
		FR_Backwards |    // Backwards from insertion point
		FR_Selection |    // Search selection only
		FR_SubFolders |   // Support subfolders
		FR_KeepOpen |     // Keep Open
		FR_Plain |        // Plain (as opposed to reg expression)
		FR_TargetMask |   // All targets (FR_Document, FR_OpenDocuments, FR_Files, FR_Project, FR_Solution)
		FR_ActionMask |   // All actions (FR_MarkAll, FR_Find, FR_FindAll, FR_Replace, FR_ReplaceAll)
		FR_FromStart |    // Search from beginning
		FR_OneMatchPerLine | // One match per line
		FR_Report;        // Report

	// If the file is "Read Only" then disable the replace options
	if(IsFileReadOnly())
	{
		dwOptions &= ~(FR_ReplaceAll | FR_Replace);
	}

	// If the selection is empty then disable the "Search Selection Only" option
	if(IsSelectionEmpty())
	{
		dwOptions &= ~FR_Selection;
	}

	return dwOptions;
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetProperty(VSFTPROPID propid, _Out_ VARIANT *pvar)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pvar, E_INVALIDARG);

	::VariantClear(pvar);

	switch(propid)
	{
	case VSFTPROPID_DocName: 
		CHK(!GetFileName().IsEmpty(), E_UNEXPECTED);
		// Return a copy of the file name as the document name
		pvar->vt = VT_BSTR;
		pvar->bstrVal = ::SysAllocString(GetFileName());
		CHKPTR(pvar->bstrVal, E_OUTOFMEMORY);
		break;

	case VSFTPROPID_IsDiskFile: 
		pvar->vt = VT_BOOL;
		pvar->boolVal = GetFile().IsOnDisk() ? TRUE : FALSE;
		break;

	case VSFTPROPID_InitialPatternAggressive:
		// Intentional fall through
	case VSFTPROPID_InitialPattern: 
		pvar->vt = VT_BSTR;
		GetInitialPattern(&pvar->bstrVal);
		break;

	case VSFTPROPID_WindowFrame: 
		pvar->vt = VT_UNKNOWN;
		// Query the same site provided to the SetSite method of this instance
		CHKHR(GetVsSiteCache().QueryService(SID_SVsWindowFrame, &pvar->punkVal));
		CHKPTR(pvar->punkVal, E_NOINTERFACE); // paranoid
		break;
	default:
		VSL_SET_STDMETHOD_HRESULT(E_NOTIMPL);
	}

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

// Callers call into this to tell us to highlight a span in the document
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::NavigateTo(const TextSpan* pts)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pts, E_INVALIDARG);

	// Make sure the window is visible
	CComPtr<IVsWindowFrame> spFrame;
	CHKHR(GetVsSiteCache().QueryService(SID_SVsWindowFrame, &spFrame));
	CHKHR(spFrame->Show());

	// Now, tell the editor control to select the span given
	long lStartIndex = GetControl().GetIndexFromLineAndCharacter(pts->iStartLine, pts->iStartIndex);
	if(lStartIndex < 0)
	{
		return E_INVALIDARG;  // Caller gave us a faulty text span
	}

	long lEndIndex = GetControl().GetIndexFromLineAndCharacter(pts->iEndLine, pts->iEndIndex);
	if(lEndIndex < 0)	
	{
		return E_INVALIDARG;  // Caller gave us a faulty text span
	}

	GetControl().SetSelection(lStartIndex, lEndIndex);
	
	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetCurrentSpan(_Out_ TextSpan* pts)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pts, E_INVALIDARG);

	CComPtr<ITextSelection> spTextSelection;
	GetTextSelection(spTextSelection);

	long iSpanStart = 0;
	CHKHR(spTextSelection->GetStart(&iSpanStart));

	long iSpanEnd = 0;
	CHKHR(spTextSelection->GetEnd(&iSpanEnd));

	pts->iStartLine = GetControl().GetLineFromIndex(iSpanStart);
	pts->iStartIndex = GetControl().GetCharacterPositionFromIndex(iSpanStart);
	pts->iEndLine = GetControl().GetLineFromIndex(iSpanEnd);
	pts->iEndIndex = GetControl().GetCharacterPositionFromIndex(iSpanEnd);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

/***************************************************************************
IVsTextImage implementation
***************************************************************************/

// Returns the number of lines in the editor
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetLineSize( 
	/* [retval][out] */ _Out_ LONG* pcLines)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pcLines, E_INVALIDARG);

	long iLines = GetControl().GetLineCount();

	*pcLines = iLines;

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::Replace( 
	/* [in] */ DWORD dwFlags,
	/* [in] */ const TextSpan* pts,
	/* [in] */ LONG /*cch*/,
	/* [size_is][in] */ LPCOLESTR pchText,
	/* [retval][out] */ _Out_ TextSpan* ptsChanged)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pts, E_INVALIDARG);

	// pts contains the span of the text to replace.  Set the selection to be pts.
	long iStartIndex = GetControl().GetIndexFromLineAndCharacter(pts->iStartLine, pts->iStartIndex);
	if(iStartIndex < 0)
	{
		return E_INVALIDARG; // pts is bad
	}

	long iEndIndex = GetControl().GetIndexFromLineAndCharacter(pts->iEndLine, pts->iEndIndex);
	if(iEndIndex < 0)
	{
		return E_INVALIDARG; // pts is bad
	}

	// Set the selection
	GetControl().SetSelection(iStartIndex, iEndIndex);

	CComPtr<ITextSelection> spTextSelection;
	GetTextSelection(spTextSelection);

	// Store the starting position of this selection
	long iSelectionStart = 0;
	CHKHR(spTextSelection->GetStart(&iSelectionStart));

	// Call the function to replace the currently selected text
	// with the given replacement string
	CComBSTR bstrReplace = pchText;    // Replacement text

	// Do the actual replace
	CHKHR(spTextSelection->SetText(bstrReplace));

	long iEndPosition = 0;
	CHKHR(spTextSelection->GetEnd(&iEndPosition));

	if ((dwFlags & FR_Backwards) == 0)
	{
		// In case of forward search place the insertion point at the end of the new text, 
		// so it will be skipped during the next call to Find.
		CHKHR(spTextSelection->SetStart(iEndPosition));
	}
	else
	{
		// If the search is backward, then set the end postion at the
		// beginning of the new text.
		CHKHR(spTextSelection->SetEnd(iSelectionStart));
	}

	// Set ptsSpan to contain the replaced text's span info if caller requests for it
	if(ptsChanged)
	{
		ptsChanged->iStartLine = GetControl().GetLineFromIndex(iSelectionStart);
		ptsChanged->iStartIndex = GetControl().GetCharacterPositionFromIndex(iSelectionStart);
		ptsChanged->iEndLine = GetControl().GetLineFromIndex(iEndPosition);
		ptsChanged->iEndIndex = GetControl().GetCharacterPositionFromIndex(iEndPosition);
	}

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

// Note, line endings are included in the length of a span
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetSpanLength( 
	/* [in] */ const TextSpan* pts,
	/* [retval][out] */ _Out_ LONG* pcch)
{
	
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pts, E_INVALIDARG);
	VSL_CHECKPOINTER(pcch, E_INVALIDARG);

	// Need to convert the starting and end points of the span into their index equivalent
	long iStartIndex = GetControl().GetIndexFromLineAndCharacter(pts->iStartLine, pts->iStartIndex);
	if(iStartIndex < 0)
	{
		return E_INVALIDARG;  // pts is bad
	}

	long iEndIndex = GetControl().GetIndexFromLineAndCharacter(pts->iEndLine, pts->iEndIndex);
	if(iEndIndex < 0)
	{
		return E_INVALIDARG;  // pts is bad
	}

	*pcch = ::abs(iEndIndex - iStartIndex);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}
		
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetLineLength( 
	/* [in] */ LONG iLine,
	/* [retval][out] */ _Out_ LONG* piLength)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(piLength, E_INVALIDARG);

	if(iLine < 0)
	{
		return E_INVALIDARG;
	}

	// Convert the line number into an index equivalent
	*piLength = GetControl().GetLineLength(iLine);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetLine( 
	/* [in] */ DWORD grfGet,
	/* [in] */ LONG iLine,
	/* [in] */ LONG iStartIndex,
	/* [in] */ LONG iEndIndex,
	/* [retval][out] */ _Out_ LINEDATAEX* pLineData)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(pLineData, E_INVALIDARG);

	// Initialize pLineData
	pLineData->iLength = 0;
	pLineData->pszText = NULL;
	pLineData->iEolType = eolCR;
	pLineData->pAttributes = 0;
	pLineData->dwFlags = static_cast<USHORT>(ldfDefault);
	pLineData->dwReserved = 0;
	pLineData->pAtomicTextChain = NULL;

	// First, make sure all of the inputs make sense
	long iLineCount = GetControl().GetLineCount();

	if( iLine < 0 ||
		iLine >= iLineCount ||
		iStartIndex < 0 ||
		iEndIndex < 0 ||
		iStartIndex > iEndIndex)  // An empty span is valid
	{
		return E_INVALIDARG;
	}

	// Length of the line is the span between the start and end index
	long iLineLength = GetControl().GetLineLength(iLine);
	// Check if the line is empty and the caller asks for an empty span.
	if (0 == iLineLength && 0 == iStartIndex && 0 == iEndIndex)
	{
		pLineData->pszText = NULL;
		return S_OK;
	}

	// Get the length of the span.
	long iLineSpanLength = iEndIndex - iStartIndex +1;

	// If the span length determined by the start and end index is greater than the length of the line, this is an error
	if(iLineSpanLength > iLineLength)
	{
		return E_INVALIDARG;
	}

	// Now, grab the text
	Pointer<StdArrayPointerTraits<WCHAR> > szText;
	GetControl().GetLineText(iLine, szText);

	if(grfGet & gldeSubset)
	{
		pLineData->iLength = iLineSpanLength;
		Pointer<StdArrayPointerTraits<WCHAR> > szSubText = new WCHAR[iLineSpanLength+1]; // Plus 1 for NULL
		// Now, copy the substring
		CHK(0 == ::wcsncpy_s(szSubText, iLineSpanLength+1, szText+iStartIndex, iLineSpanLength), E_FAIL);
		pLineData->pszText = szSubText.Detach();
	}
	// Else, whole line
	else
	{
		pLineData->iLength = iLineLength;
		pLineData->pszText = szText.Detach();
	}

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

/***************************************************************************
IVsTextBuffer implementation

This is just provided so that the find in files scenario will work 
properly.  It isn't necesary to implement most of the methods for this
scenario to work correctly.
***************************************************************************/

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetLengthOfLine(long iLine, _Out_ long* piLength)
{
	// defer to IVsTextImage::GetLineLength
	return GetLineLength(iLine, piLength);
}

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::GetLastLineIndex(_Out_ long* piLine, _Out_ long* piIndex)
{
	VSL_STDMETHODTRY{

	VSL_CHECKPOINTER(piLine, E_INVALIDARG);
	VSL_CHECKPOINTER(piIndex, E_INVALIDARG);

	*piLine = 0;
	*piIndex = 0;

	GetLineSize(piLine); // Get the number of lines in the editor
	if(*piLine >= 1)
	{
		// We need to subtract 1 to get the index
		(*piLine) -= 1;
	}

	// Now, get the line length of the last line
	long cLineLength = GetControl().GetLineLength(*piLine);
	*piIndex = (cLineLength >= 1 ? cLineLength - 1 : cLineLength);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

/***************************************************************************
IVsTextView implementation

This is just provided so that the find in files scenario will work 
properly.  It isn't necesary to implement most of the methods for this
scenario to work correctly.
***************************************************************************/

template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::SetSelection(
	long iAnchorLine, 
	ViewCol iAnchorCol, 
	long iEndLine, 
	ViewCol iEndCol)
{
	// Convert the given inputs to be the start and end index
	long lStartIndex = GetControl().GetIndexFromLineAndCharacter(iAnchorLine, iAnchorCol);
	if( lStartIndex < 0 )
	{
		return E_INVALIDARG;
	}

	long lEndIndex = GetControl().GetIndexFromLineAndCharacter(iEndLine, iEndCol);
	if( lEndIndex < 0 )	
	{
		return E_INVALIDARG;
	}

	GetControl().SetSelection(lStartIndex, lEndIndex);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////
//    Helper Functions
/////////////////////////////////////////////////////////////////////////////////

template <class Traits_T>
void EditorDocument<Traits_T>::GetInitialPattern(_Deref_out_z_ BSTR* pbstrPattern)
{
	*pbstrPattern = NULL;

	// First check if the selection is empty.
	if(IsSelectionEmpty())
	{
		return;
	}

	// Now check if the selection is multiline by:
	//    - Getting and then duplicating the current text range.
	//    - Advancing the start of the duplicate by one line
	//    - Checking if the duplicate range is still within
	//      the original range.
	// If the check is true then the selection is multiline.
	CComPtr<ITextSelection> spITextSelection;
	GetTextSelection(spITextSelection);

	// Duplicate the text selection
	CComPtr<ITextRange> spDuplicate;
	CHKHR(spITextSelection->GetDuplicate(&spDuplicate));
	// Advance the start of the duplicate by one line
	CHKHR(spDuplicate->MoveStart(tomLine, 1, NULL));

	// Get the ends of each range. 
	long iEndOrig;
	CHKHR(spITextSelection->GetEnd(&iEndOrig));
	long iEndDup;
	CHKHR(spDuplicate->GetEnd(&iEndDup));

	// If the ends are still the same are still the same then the selection is multiline.
	if(iEndOrig == iEndDup)
	{
		return;
	}

	// The selection is all within a single line so retrieve the selection text.
	CHKHR(spITextSelection->GetText(pbstrPattern));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorPersistance.inl ===
// EditorPersistence.inl

// Called by the IPersistFileFormat::Load implementation on DocumentPersistanceBase
template <class Traits_T>
HRESULT EditorDocument<Traits_T>::ReadData(
	File& rFile, 
	BOOL bInsert,
	DWORD& rdwFormatIndex) throw()
{
	VSL_STDMETHODTRY{

	// Only the default format is supported by this editor
	rdwFormatIndex = DEF_FORMAT_INDEX;

	{

	Control::SuspendDrawAndNotifications suspend(GetControl());

	// Figure out format of file being read by examining the start of
	// the file for the RTF signature.
	const char szRTFSignature[] = "{\\rtf";
	char szHeader[_countof(szRTFSignature)];
	const DWORD dwBytesToRead = _countof(szRTFSignature) - 1; // -1 as the last spot is for the NULL terminator
	DWORD dwBytesRead;
	rFile.Read(szHeader, dwBytesToRead, dwBytesRead);

	// NULL terminate so this is a proper string
	szHeader[_countof(szHeader)-1] = '\0';

	// If the signature isn't RTF, then assume text
	DWORD dwFormat = SF_TEXT;
	if(dwBytesToRead == dwBytesRead && 0 == ::_strnicmp(szRTFSignature, szHeader, dwBytesToRead))
	{
		dwFormat = SF_RTF;
	}

	// Move back to the beginning of the file
	rFile.Seek(0L, FILE_BEGIN);

	// Now tell the control to load the file
	EDITSTREAM editStream =
	{
		reinterpret_cast<DWORD_PTR>(&rFile),
		S_OK,
		&EditStreamCallback<true>
	};

	// This message will result in EditStreamInCallback being called
	GetControl().SendMessage(
		EM_STREAMIN,
		(bInsert ? dwFormat | SFF_SELECTION : dwFormat),
		&editStream);

	VSL_SET_STDMETHOD_HRESULT(*(reinterpret_cast<HRESULT*>(&editStream.dwError)));

	} // Suspend needs to be destroyed here

	if(SUCCEEDED(VSL_GET_STDMETHOD_HRESULT()))
	{
		// Redraw so that the new contect is reflected on screen
		GetControl().InvalidateRect(NULL, TRUE);
		GetControl().UpdateWindow();
		// Update the status bar, since the content is being loaded for the first time
		SetInfo();
	}

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}            

// Called indirectly by IPersistFileFormat::Save and IVsFileBackup::BackupFile implementations 
// on DocumentPersistanceBase
template <class Traits_T>
void EditorDocument<Traits_T>::WriteData(File& rFile, DWORD /*dwFormatIndex*/)
{
	// Don't need to check the parameters, the caller ensures they are valid

	EDITSTREAM editStream =
	{
		reinterpret_cast<DWORD_PTR>(&rFile),
		S_OK,
		&EditStreamCallback<false>
	};

	// This message will result in EditStreamCallback being called
	GetControl().SendMessage(EM_STREAMOUT, SF_RTF, &editStream);

	CHKHR(*(reinterpret_cast<HRESULT*>(&editStream.dwError)));
}

// Called by the Rich Edit control during the processing of EM_STREAMOUT and EM_STREAMIN
template <class Traits_T> // class template
template <bool bRead_T> // method template
DWORD CALLBACK EditorDocument<Traits_T>::EditStreamCallback(
	_In_ DWORD_PTR dwpFile, 
	_Inout_bytecap_(iBufferByteSize) LPBYTE pBuffer, 
	LONG iBufferByteSize, 
	_Out_ LONG* piBytesWritenOrRead)
{
	DWORD dwBytesWritten = 0;

	DWORD dwBufferByteSize = iBufferByteSize;

	VSL_STDMETHODTRY{

	if(	NULL != pBuffer && 
		0 != dwBufferByteSize && 
		LONG_MAX >= dwBufferByteSize && 
		NULL != piBytesWritenOrRead)
	{
		File* pFile = reinterpret_cast<File*>(dwpFile);

		if(NULL != pFile)
		{
			if(bRead_T)
			{
				pFile->Read(pBuffer, dwBufferByteSize, dwBytesWritten);
			}
			else
			{
				pFile->Write(pBuffer, dwBufferByteSize, &dwBytesWritten);
			}
			VSL_ASSERT(dwBytesWritten <= iBufferByteSize);
		}

		if(dwBytesWritten <= dwBufferByteSize)
		{
			*piBytesWritenOrRead = dwBytesWritten;
		}
	}

	}VSL_STDMETHODCATCH()

	HRESULT hr = (dwBytesWritten >= 0 && (bRead_T ? true : dwBytesWritten == dwBufferByteSize)) ? 
		VSL_GET_STDMETHOD_HRESULT() : 
		(FAILED(VSL_GET_STDMETHOD_HRESULT()) ? VSL_GET_STDMETHOD_HRESULT() : E_FAIL);

	// If the return value is non-Zero (i.e. not S_OK), the return value will
	// be put into the dwError member of the EDITSTREAM instance passed with
	// the EM_STREAMOUT message in WriteData
	return *(reinterpret_cast<DWORD*>(&hr));
}

// Called by VSL::DocumentPersistanceBase::InitNew and VSL::DocumentPersistanceBase::Save
template <class Traits_T>
bool EditorDocument<Traits_T>::IsValidFormat(DWORD dwFormatIndex)
{
	// Only one format, the default, is supported
	return DEF_FORMAT_INDEX == dwFormatIndex;
}

// Called by VSL::DocumentPersistanceBase::FilesChanged
template <class Traits_T>
void EditorDocument<Traits_T>::OnFileChangedSetTimer()
{
	// 500 miliseconds is an arbitrary time to delay
	// See EditorDocument::OnTimer and 
	// VSL::DocumentPersistanceBase::FilesChanged for details
	VSL_CHECKBOOL_GLE(0 != SetTimer(WFILECHANGEDTIMERID, 500, NULL));
}

// Called by VSL::DocumentPersistanceBase::GetClassID, which is also called by 
// VSL::DocumentPersistanceBase::GetGuidEditorType)
template <class Traits_T>
const GUID& EditorDocument<Traits_T>::GetEditorTypeGuid() const
{
	// The GUID for the factory is the one to return from IPersist::GetClassID and 
	// IVsPersistDocData::GetGuidEditorType
	return CLSID_%ProjectClass%EditorFactory;
}

// Called by VSL::DocumentPersistanceBase::GetFormatList
template <class Traits_T>
void EditorDocument<Traits_T>::GetFormatListString(ATL::CStringW& rstrFormatList)
{
	// Load the file format list string from the resource DLL
	VSL_CHECKBOOL_GLE(rstrFormatList.LoadString(IDS_FORMATSTR));
}

// Called indirectly by VSL::DocumentPersistanceBase::Load and VSL::DocumentPersistanceBase::Save
template <class Traits_T>
void EditorDocument<Traits_T>::PostSetDirty()
{
	// Notify the Rich Edit control of the current dirty state
	GetControl().SetModified(IsFileDirty());
}

// Called indirectly by VSL::DocumentPersistanceBase::FilesChanged, 
// VSL::DocumentPersistanceBase::IgnoreFileChanges, VSL::DocumentPersistanceBase::Load, and 
// VSL::DocumentPersistanceBase::Save
template <class Traits_T>
void EditorDocument<Traits_T>::PostSetReadOnly()
{
	// Notify the Rich Edit control of the current read-only state.
	GetControl().SetReadOnly(IsFileReadOnly());

	// Update editor caption with " [Read Only]" or "" as necessary

	CComPtr<IVsWindowFrame> spIVsWindowFrame;
	CHKHR(GetVsSiteCache().QueryService(SID_SVsWindowFrame, &spIVsWindowFrame));

	CStringW strEditorCaption;

	if(IsFileReadOnly())
	{
		VSL_CHECKBOOL_GLE(strEditorCaption.LoadString(IDS_READONLY));
	}

	CComVariant varEditorCaption = strEditorCaption;

	CHKHR(spIVsWindowFrame->SetProperty(VSFPROPID_EditorCaption, varEditorCaption));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\Package.h ===
// Package.h

#pragma once

#include <atlstr.h>
#include <VSLCommandTarget.h>


#include "resource.h"       // main symbols
#include "Guids.h"
#include "..\%ProjectName%UI\Resource.h"

#include "..\%ProjectName%UI\CommandIds.h"

%ToolWindowItemStart%
#include "MyToolWindow.h"
#include <commctrl.h>
%ToolWindowItemEnd%%EditorStart%
#include "EditorFactory.h"
%EditorEnd%

using namespace VSL;

%EditorStart%/***************************************************************************
C%ProjectClass%Package handles the necessary registeration for this package.

See EditorFactory.h for the details of the Editor key section in 
%ProjectClass%.pkgdef.

See the Package C++ reference sample for the details of the Package key section in
%ProjectClass%.pkgdef.

See the MenuAndCommands C++ reference sample for the details of the Menu key section in 
%ProjectClass%.pkgdef.

See EditorDocument.h for the details of the KeyBindingTables key section in
%ProjectName%.pkgdef.

The following Projects key section exists in %ProjectClass%.pkgdef in order to
register the new file template.

//The first GUID below is the GUID for the Miscellaneous Files project type, and can be changed
//  to the GUID of any other project you wish.
[$RootKey$\Projects\{A2FE74E1-B743-11d0-AE1A-00A0C90FFFC3}\AddItemTemplates\TemplateDirs\{%PackageGuid%}\/1]
@="#100"
"TemplatesDir"="$PackageFolder$\Templates"
"SortPriority"=dword:00004E20

The contents of %ProjectClass%.vsdir, which is located a the location registered above are:

myext.myext|{ab02f9cb-42e8-467c-a242-d9bb2e1918a0}|#106|80|#109|{ab02f9cb-42e8-467c-a242-d9bb2e1918a0}|401|0|#107
The meaning of the fields are as follows:
	- Default.rtf - the default .RTF file
	- {ab02f9cb-42e8-467c-a242-d9bb2e1918a0} - same as CLSID_%ProjectClass%Package
	- #106 - the literal value of IDS_EDITOR_NAME in %ProjectClass%UI.rc,
		which is displayed under the icon in the new file dialog.
	- 80 - the display ordering priority
	- #109 - the literal value of IDS_FILE_DESCRIPTION in %ProjectClass%UI.rc, which is displayed
		in the description window in the new file dialog.
	- {ab02f9cb-42e8-467c-a242-d9bb2e1918a0} - resource dll package guid
	- 401 - the literal value of IDI_FILE_ICON in %ProjectClass%.rc (not %ProjectClass%UI.rc), 
		which is the icon to display in the new file dialog.
	- 0 - template flags, which are unused here(we don't use this - see vsshell.idl)
	- #107 - the literal value of IDS_DEFAULT_NAME in %ProjectClass%UI.rc, which is the base
		name of the new files (i.e. myext1.myext, myext2.myext, etc.).

***************************************************************************/
%EditorEnd%
class ATL_NO_VTABLE C%ProjectClass%Package : 
	// CComObjectRootEx and CComCoClass are used to implement a non-thread safe COM object, and 
	// a partial implementation for IUknown (the COM map below provides the rest).
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<C%ProjectClass%Package, &CLSID_%ProjectClass%>,
	// Provides the implementation for IVsPackage to make this COM object into a VS Package.
	public IVsPackageImpl<C%ProjectClass%Package, &CLSID_%ProjectClass%>,
	public IOleCommandTargetImpl<C%ProjectClass%Package>,
	// Provides consumers of this object with the ability to determine which interfaces support
	// extended error information.
	public ATL::ISupportErrorInfoImpl<&__uuidof(IVsPackage)>
{
public:

// Provides a portion of the implementation of IUnknown, in particular the list of interfaces
// the C%ProjectClass%Package object will support via QueryInterface
BEGIN_COM_MAP(C%ProjectClass%Package)
	COM_INTERFACE_ENTRY(IVsPackage)
	COM_INTERFACE_ENTRY(IOleCommandTarget)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// COM objects typically should not be cloned, and this prevents cloning by declaring the 
// copy constructor and assignment operator private (NOTE:  this macro includes the decleration of
// a private section, so everything following this macro and preceding a public or protected 
// section will be private).
VSL_DECLARE_NOT_COPYABLE(C%ProjectClass%Package)

public:
	C%ProjectClass%Package()%EditorOrToolWindowStart%:
		%EditorStart%m_dwEditorCookie(0)%EditorEnd%%EditorAndToolWindowStart%,%EditorAndToolWindowEnd%
		%ToolWindowItemStart%m_MyToolWindow(GetVsSiteCache())%ToolWindowItemEnd%%EditorOrToolWindowEnd%
	{
	}
	
	~C%ProjectClass%Package()
	{
	}

%EditorStart%
	// This method will be called after IVsPackage::SetSite is called with a valid site
	void PostSited(IVsPackageEnums::SetSiteResult /*result*/)
	{
		if(m_dwEditorCookie == 0) 
		{
			// Create the editor factory
			CComObject<EditorFactory> *pFactory = new CComObject<EditorFactory>;
			if(NULL == pFactory)
			{
				ERRHR(E_OUTOFMEMORY);
			}
			CComPtr<IVsEditorFactory> spIVsEditorFactory = static_cast<IVsEditorFactory*>(pFactory);

			// Register the editor factory
			CComPtr<IVsRegisterEditors> spIVsRegisterEditors;
			CHKHR(GetVsSiteCache().QueryService(SID_SVsRegisterEditors, &spIVsRegisterEditors));
			CHKHR(spIVsRegisterEditors->RegisterEditor(CLSID_%ProjectClass%EditorFactory, spIVsEditorFactory, &m_dwEditorCookie));
		}
	}

	void PreClosing()
	{
		if(m_dwEditorCookie != 0)
		{
			// Unregister the editor factory
			CComPtr<IVsRegisterEditors> spIVsRegisterEditors;
			CHKHR(GetVsSiteCache().QueryService(SID_SVsRegisterEditors, &spIVsRegisterEditors));
			CHKHR(spIVsRegisterEditors->UnregisterEditor(m_dwEditorCookie));
		}
	}
%EditorEnd%
	// This function provides the error information if it is not possible to load
	// the UI dll. It is for this reason that the resource IDS_E_BADINSTALL must
	// be defined inside this dll's resources.
	static const LoadUILibrary::ExtendedErrorInfo& GetLoadUILibraryErrorInfo()
	{
		static LoadUILibrary::ExtendedErrorInfo errorInfo(IDS_E_BADINSTALL);
		return errorInfo;
	}

	// DLL is registered with VS via a pkgdef file. Don't do anything if asked to
	// self-register.
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		return S_OK;
	}

// NOTE - the arguments passed to these macros can not have names longer then 30 characters
// Definition of the commands handled by this package
VSL_BEGIN_COMMAND_MAP()
%MenuItemStart%
    VSL_COMMAND_MAP_ENTRY(CLSID_%ProjectClass%CmdSet, %CommandID%, NULL, CommandHandler::ExecHandler(&OnMyCommand))%MenuItemEnd%
%ToolWindowItemStart%    VSL_COMMAND_MAP_ENTRY(CLSID_%ProjectClass%CmdSet, %ToolCommandID%, NULL, CommandHandler::ExecHandler(&OnMyTool))%ToolWindowItemEnd%
VSL_END_VSCOMMAND_MAP()

%ToolWindowItemStart%
// The tool map implements IVsPackage::CreateTool that is called by VS to create a tool window 
// when appropriate.
VSL_BEGIN_TOOL_MAP()
    VSL_TOOL_ENTRY(CLSID_guidPersistanceSlot, m_MyToolWindow.CreateAndShow())
VSL_END_TOOL_MAP()

// Command handler called when the user selects the command to show the toolwindow.
void OnMyTool(CommandHandler* /*pSender*/, DWORD /*flags*/, VARIANT* /*pIn*/, VARIANT* /*pOut*/)
{
    m_MyToolWindow.CreateAndShow();
}
%ToolWindowItemEnd%%MenuItemStart%
// Command handler called when the user selects the "My Command" command.
void OnMyCommand(CommandHandler* /*pSender*/, DWORD /*flags*/, VARIANT* /*pIn*/, VARIANT* /*pOut*/)
{
	// Get the string for the title of the message box from the resource dll.
	CComBSTR bstrTitle;
	VSL_CHECKBOOL_GLE(bstrTitle.LoadStringW(_AtlBaseModule.GetResourceInstance(), IDS_PROJNAME));
	// Get a pointer to the UI Shell service to show the message box.
	CComPtr<IVsUIShell> spUiShell = this->GetVsSiteCache().GetCachedService<IVsUIShell, SID_SVsUIShell>();
	LONG lResult;
	HRESULT hr = spUiShell->ShowMessageBox(
	                             0,
	                             CLSID_NULL,
	                             bstrTitle,
	                             W2OLE(L"Inside C%ProjectClass%Package::Exec"),
	                             NULL,
	                             0,
	                             OLEMSGBUTTON_OK,
	                             OLEMSGDEFBUTTON_FIRST,
	                             OLEMSGICON_INFO,
	                             0,
	                             &lResult);
	VSL_CHECKHRESULT(hr);
}
%MenuItemEnd%

private:
%ToolWindowItemStart%    %ProjectClass%ToolWindow m_MyToolWindow;%ToolWindowItemEnd%

%EditorStart%	// Cookie returned when registering editor
	VSCOOKIE m_dwEditorCookie;%EditorEnd%
};

// This exposes C%ProjectClass%Package for instantiation via DllGetClassObject; however, an instance
// can not be created by CoCreateInstance, as C%ProjectClass%Package is specfically registered with
// VS, not the the system in general.
OBJECT_ENTRY_AUTO(CLSID_%ProjectClass%, C%ProjectClass%Package)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\MyToolWindow.h ===
//
// MyToolWindow.h
//
// This file contains the implementation of a tool window that hosts a .NET user control
//

#pragma once

#include <AtlWin.h>
#include <VSLWindows.h>

#include "..\%ProjectName%UI\Resource.h"

class %ProjectClass%WindowPane :
    public CComObjectRootEx<CComSingleThreadModel>,
	public VsWindowPaneFromResource<%ProjectClass%WindowPane, IDD_%ProjectClass%_DLG>,
	public VsWindowFrameEventSink<%ProjectClass%WindowPane>,
	public VSL::ISupportErrorInfoImpl<
		InterfaceSupportsErrorInfoList<IVsWindowPane,
		InterfaceSupportsErrorInfoList<IVsWindowFrameNotify,
		InterfaceSupportsErrorInfoList<IVsWindowFrameNotify3> > > >
{
	VSL_DECLARE_NOT_COPYABLE(%ProjectClass%WindowPane)

protected:

	// Protected constructor called by CComObject<%ProjectClass%WindowPane>::CreateInstance.
	%ProjectClass%WindowPane() :
		 VsWindowPaneFromResource()
	{}

	~%ProjectClass%WindowPane() {}
	
public:

BEGIN_COM_MAP(%ProjectClass%WindowPane)
	COM_INTERFACE_ENTRY(IVsWindowPane)
	COM_INTERFACE_ENTRY(IVsWindowFrameNotify)
	COM_INTERFACE_ENTRY(IVsWindowFrameNotify3)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_MSG_MAP(%ProjectClass%WindowPane)
	COMMAND_HANDLER(IDC_CLICKME_BTN, BN_CLICKED, OnButtonClick)
END_MSG_MAP()

	// Function called by VsVsWindowPaneFromResource at the end of SetSite; at this point the
	// window pane is constructed and sited and can be used, so this is where we can initialize
	// the event sink by siting it.
	void PostSited(IVsPackageEnums::SetSiteResult /*result*/)
	{
		VsWindowFrameEventSink<%ProjectClass%WindowPane>::SetSite(GetVsSiteCache());
	}

	// Callback function called by ToolWindowBase when the size of the window changes.
	void OnFrameSize(int x, int y, int w, int h)
	{
		// Center button.
		CWindow button(this->GetDlgItem(IDC_CLICKME_BTN));
		RECT buttonRectangle;
		button.GetWindowRect(&buttonRectangle);

		OffsetRect(&buttonRectangle, -buttonRectangle.left, -buttonRectangle.top);

		int iLeft = (w - buttonRectangle.right) / 2; 
		if (iLeft <= 0)
		{
			iLeft = 5;
		}

		int iTop = (h - buttonRectangle.bottom) / 2; 
		if (iTop <= 0)
		{
			iTop = 5;
		}

		button.SetWindowPos(NULL, iLeft, iTop, 0, 0, SWP_NOSIZE);
	}

	LRESULT OnButtonClick(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& bHandled)
	{
		// Load the message from the resources.
		CComBSTR strMessage;
		VSL_CHECKBOOL_GLE(strMessage.LoadStringW(_AtlBaseModule.GetResourceInstance(), IDS_BUTTONCLICK_MESSAGE));

		// Get the title of the message box (it is the same as the tool window's title).
		CComBSTR strTitle;
		VSL_CHECKBOOL_GLE(strTitle.LoadStringW(_AtlBaseModule.GetResourceInstance(), IDS_WINDOW_TITLE));

		// Get the UI Shell service.
		CComPtr<IVsUIShell> spIVsUIShell = GetVsSiteCache().GetCachedService<IVsUIShell, SID_SVsUIShell>();
		LONG lResult;
		VSL_CHECKHRESULT(spIVsUIShell->ShowMessageBox(0, GUID_NULL, strTitle, strMessage, NULL, 0, OLEMSGBUTTON_OK, OLEMSGDEFBUTTON_FIRST, OLEMSGICON_INFO, FALSE, &lResult));

		bHandled = TRUE;
		return 0;
	}
};


class %ProjectClass%ToolWindow :
	public VSL::ToolWindowBase<%ProjectClass%ToolWindow>
{
public:
	// Constructor of the tool window object.
	// The goal of this constructor is to initialize the base class with the site cache
	// of the owner package.
	%ProjectClass%ToolWindow(const PackageVsSiteCache& rPackageVsSiteCache):
		ToolWindowBase(rPackageVsSiteCache)
	{
	}

	// Caption of the tool window.
	const wchar_t* const GetCaption() const
	{
		static CStringW strCaption;
		// Avoid to load the string from the resources more that once.
		if (0 == strCaption.GetLength())
		{
			VSL_CHECKBOOL_GLE(
				strCaption.LoadStringW(_AtlBaseModule.GetResourceInstance(), IDS_WINDOW_TITLE));
		}
		return strCaption;
	}

	// Creation flags for this tool window.
	VSCREATETOOLWIN GetCreationFlags() const
	{
		return CTW_fInitNew|CTW_fForceCreate;
	}

	// Return the GUID of the persintence slot for this tool window.
	const GUID& GetToolWindowGuid() const
	{
		return CLSID_guidPersistanceSlot;
	}

	IUnknown* GetViewObject()
	{
		// Should only be called once per-instance
		VSL_CHECKBOOLEAN_EX(m_spView == NULL, E_UNEXPECTED, IDS_E_GETVIEWOBJECT_CALLED_AGAIN);

		// Create the object that implements the window pane for this tool window.
		CComObject<%ProjectClass%WindowPane>* pViewObject;
		VSL_CHECKHRESULT(CComObject<%ProjectClass%WindowPane>::CreateInstance(&pViewObject));

		// Get the pointer to IUnknown for the window pane.
		HRESULT hr = pViewObject->QueryInterface(IID_IUnknown, (void**)&m_spView);
		if (FAILED(hr))
		{
			// If QueryInterface failed, then there is something wrong with the object.
			// Delete it and throw an exception for the error.
			delete pViewObject;
			VSL_CHECKHRESULT(hr);
		}

		return m_spView;
	}

	// This method is called by the base class after the tool window is created.
	// We use it to set the icon for this window.
	void PostCreate()
	{
		CComVariant srpvt;
		srpvt.vt = VT_I4;
		srpvt.intVal = IDB_FRAME_IMAGES;
		// We don't want to make the window creation fail only becuase we can not set
		// the icon, so we will not throw if SetProperty fails.
		if (SUCCEEDED(GetIVsWindowFrame()->SetProperty(VSFPROPID_BitmapResource, srpvt)))
		{
			srpvt.intVal = 1;
			GetIVsWindowFrame()->SetProperty(VSFPROPID_BitmapIndex, srpvt);
		}
	}

private:
	CComPtr<IUnknown> m_spView;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\Guids.cpp ===
// Guids.c
//

#include "initguid.h"
#include "Guids.h"
#include <VSShellInterfaces.h>

#define _MIDL_USE_GUIDDEF_ // Necessary to build without compilation errors
#include "%ProjectName%.c"
%EditorStart%
// There is no library that defines the GUIDs for the interfaces defined inside
// TOM.h, so we have to define here the GUIDs that are used inside our code.
// You can find these GUIDs looking at the definition of the interfaces in TOM.h.
DEFINE_GUID(IID_ITextDocument,
    0x8CC497C0, 0xA1DF, 0x11ce, 0x80, 0x98, 0x00, 0xAA, 0x00, 0x47, 0xBE, 0x5D);
%EditorEnd%
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\EditorWindowing.inl ===
// EditorWindowing.inl

template <class Traits_T>
void EditorDocument<Traits_T>::SetFontName(_In_ VARIANT *pvarNew)
{
	VSL_ASSERT(NULL != pvarNew); // Caller should ensure this isn't NULL, so no retail check

	// The user may manually select any font rather than selecting a font from the drop-down list.
	// So make sure the string length is sufficiently short for the CHARFORMATW structure
	VSL_CHECKBOOL(::SysStringLen(pvarNew->bstrVal) < LF_FACESIZE, E_INVALIDARG);

	CComPtr<ITextFont> spITextFont;
	GetTextFont(spITextFont);

	// NOTE - since this doesn't take a character set, some fonts may not render correctly,
	// but this scenario has no bearing on integrating into Visual Studio correctly.
	CHKHR(spITextFont->SetName(pvarNew->bstrVal));
}

template <class Traits_T>
void EditorDocument<Traits_T>::SetFontSize(_In_ VARIANT *pvarNew)
{
	VSL_ASSERT(NULL != pvarNew); // Caller should ensure this isn't NULL, so no retail check

	long iFontSize = ::wcstol(V_BSTR(pvarNew), NULL, 10);
	CHK((iFontSize != 0 && iFontSize != LONG_MAX && iFontSize != LONG_MIN), E_INVALIDARG);

	CComPtr<ITextFont> spITextFont;
	GetTextFont(spITextFont);

	CHKHR(spITextFont->SetSize(static_cast<float>(iFontSize)));
}


template <class Traits_T>
void EditorDocument<Traits_T>::GetFontName(_Out_ VARIANT *pvarOut)
{
	VSL_ASSERT(NULL != pvarOut); // Caller should ensure this isn't NULL, so no retail check

	// Clear the out value here in case of failure
    ::VariantClear(pvarOut);

	CComPtr<ITextFont> spITextFont;
	GetTextFont(spITextFont);

	CHKHR(spITextFont->GetName(&pvarOut->bstrVal));

	// Set the variant type on success
	V_VT(pvarOut) = VT_BSTR;
}

template <class Traits_T>
void EditorDocument<Traits_T>::GetFontSize(_Out_ VARIANT *pvarOut)
{
	VSL_ASSERT(NULL != pvarOut); // Caller should ensure this isn't NULL, so no retail check

	// Clear the out value here in case of failure
    ::VariantClear(pvarOut);

	CComPtr<ITextFont> spITextFont;
	GetTextFont(spITextFont);

	float fFontSize;
	CHKHR(spITextFont->GetSize(&fFontSize));

	// Convert font size to int, which will truncate, so add 0.5 to get rounding rather then 
	// truncation
	int iFontSize = static_cast<long>(fFontSize + 0.5);

	// Less than 0 indicates more then one font size selected, so return empty string.
	wchar_t szFontSize[12] = L""; // 11 characters is the max needed for signed int, +1 for terminator
	if(iFontSize >= 0)
	{
		// No return value indicates an error
		::_itow_s(iFontSize, szFontSize, _countof(szFontSize), 10);
	}

	pvarOut->bstrVal = ::SysAllocString(szFontSize);
	CHKPTR(pvarOut->bstrVal, E_OUTOFMEMORY);

	// Set the variant type on success
	V_VT(pvarOut) = VT_BSTR;
}

/***************************************************************************
	IVsStatusBarUser Implementation
***************************************************************************/

// Displays the current insertion point line\column and insert\overstrike etc. in the status bar.
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::SetInfo()
{
	VSL_STDMETHODTRY{

	CComPtr<IVsStatusbar> spIVsStatusBar;
	CHKHR(GetVsSiteCache().QueryService(SID_SVsStatusbar, &spIVsStatusBar));

	// Set the selection (or insertion point) position
	StatusBarUpdatePos(spIVsStatusBar);

	// Only STREAM selection mode is supported, so just set that
	CComVariant vtSelMode(static_cast<__int32>(UIE_TEXTSELMODE_STREAM), VT_I4);
	spIVsStatusBar->SetSelMode(&vtSelMode);

	// Set insert or overstrike
	StatusBarUpdateInsMode(spIVsStatusBar);

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

template <class Traits_T>
void EditorDocument<Traits_T>::StatusBarUpdatePos(_In_ IVsStatusbar* pIVsStatusBar)
{
	CComPtr<IVsStatusbar> spIVsStatusBar = pIVsStatusBar;

	if(!spIVsStatusBar)
	{
		CHKHR(GetVsSiteCache().QueryService(SID_SVsStatusbar, &spIVsStatusBar));
	}

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);

	long iMin = 0;
	CHKHR(spITextSelection->GetStart(&iMin));
	long iMax = 0;
	CHKHR(spITextSelection->GetEnd(&iMax));

	// The presence of tomSelStartActive indicates that the cursor is at the
	// beginning of current selection, rather then the end.
	long iCursorIndex = (GetTextSelectionFlags() & tomSelStartActive) ? iMin : iMax;

	// add one to the line and column to get an origin of of 1,1 rather then 0,0
	CComVariant varLine(static_cast<__int32>(GetControl().GetLineFromIndex(iCursorIndex)+1), VT_I4);
	CComVariant varCharacterPosition(static_cast<__int32>(GetControl().GetCharacterPositionFromIndex(iCursorIndex)+1), VT_I4);

	// Now update the status bar's line and character position; however,
	// do not update the column, as that requires properly accounting for tab settings
	CHKHR(spIVsStatusBar->SetLineChar(&varLine, &varCharacterPosition));
}

template <class Traits_T>
void EditorDocument<Traits_T>::StatusBarUpdateInsMode(_In_ IVsStatusbar* pIVsStatusBar)
{
	CComPtr<IVsStatusbar> spIVsStatusBar = pIVsStatusBar;

	if(!spIVsStatusBar)
	{
		CHKHR(GetVsSiteCache().QueryService(SID_SVsStatusbar, &spIVsStatusBar));
	}

	CComVariant varInsertionMode(static_cast<__int32>(GetTextSelectionFlags() & tomSelOvertype ? UIE_TEXTINSMODE_OVERSTRIKE : UIE_TEXTINSMODE_INSERT), VT_I4);
	spIVsStatusBar->SetInsMode(&varInsertionMode);
}    

template <class Traits_T>
long EditorDocument<Traits_T>::GetTextSelectionFlags()
{
	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);

	long iFlags = 0;
	VSL_CHECKHRESULT(spITextSelection->GetFlags(&iFlags));
	
	return iFlags;
}



//////////////////////////////////////////////////////////////////
//IVsToolBoxUser methods
//////////////////////////////////////////////////////////////////

// Called determine if a toolbox item can be added to the document.
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::IsSupported(_In_ IDataObject* pDataObject)
{
	VSL_STDMETHODTRY{

	// Determine if pDataObject can be pasted by querying the control
	ATL::CComVariant vt;
	IVsToolboxUserHelper(pDataObject, vt);

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);

	long bCanPaste;
	VSL_CHECKHRESULT(spITextSelection->CanPaste(&vt, 0, &bCanPaste));

	// returning S_FALSE indicates an inability to paste pDataObject
	if(tomTrue != bCanPaste)
	{
		return S_FALSE;
	}

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

// Called when the user adds a supported toolbox item to the document.
template <class Traits_T>
STDMETHODIMP EditorDocument<Traits_T>::ItemPicked(_In_ IDataObject* pDataObject)
{
	VSL_STDMETHODTRY{

	ATL::CComVariant vt;
	IVsToolboxUserHelper(pDataObject, vt);

	CComPtr<ITextSelection>	spITextSelection;
	GetTextSelection(spITextSelection);

	// Add the item by pasting it in
	VSL_CHECKHRESULT(spITextSelection->Paste(&vt, 0));

	}VSL_STDMETHODCATCH()

	return VSL_GET_STDMETHOD_HRESULT();
}

//////////////////////////////////////////////////////////////////
// Helper methods
//////////////////////////////////////////////////////////////////

template <class Traits_T>
void EditorDocument<Traits_T>::IVsToolboxUserHelper(_In_ IDataObject* pDataObject, ATL::CComVariant& vt)
{
	VSL_CHECKPOINTER(pDataObject, E_INVALIDARG);

	VSL_CHECKHRESULT(pDataObject->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&vt.punkVal)));
	VSL_CHECKPOINTER(vt.punkVal, E_FAIL);
	vt.vt = VT_UNKNOWN;
}

template <class Traits_T>
bool EditorDocument<Traits_T>::CanCycleClipboard()
{
	BOOL bCanCycle = FALSE;

	CComPtr<IVsToolboxClipboardCycler> spIVsToolboxClipboardCycler;
	CHKHR(GetVsSiteCache().QueryService(SID_SVsToolbox, &spIVsToolboxClipboardCycler));

	// This will call back into IVsToolboxUser::IsSupported
	spIVsToolboxClipboardCycler->AreDataObjectsAvailable(static_cast<IVsToolboxUser*>(this), &bCanCycle);

	return bCanCycle ? true : false;
}

template <class Traits_T>
void EditorDocument<Traits_T>::PasteClipboardObject()
{
	CComPtr<IVsToolboxClipboardCycler> spIVsToolboxClipboardCycler;
	CHKHR(GetVsSiteCache().QueryService(SID_SVsToolbox, &spIVsToolboxClipboardCycler));

	// Ask the toolbox for what to paste
	CComPtr<IDataObject> spIDataObject;
	CHKHR(spIVsToolboxClipboardCycler->GetAndSelectNextDataObject(static_cast<IVsToolboxUser*>(this), &spIDataObject));

	CComPtr<ITextSelection> spITextSelection;
	GetTextSelection(spITextSelection);

	// Get the current position of the start of the current selection. 
	// After the paste the positiono of the start of current selection
	// will be moved to the end of inserted text, so it needs to
	// move back to original position so that inserted text can be highlighted to 
	// allow cycling through our clipboard items.
	long iOriginalStart;
	CHKHR(spITextSelection->GetStart(&iOriginalStart));

	// This will do the actual pasting of the object
	ItemPicked(spIDataObject);

	// Now move the start position backwards to the original position.
	long iCurrentStart;
	CHKHR(spITextSelection->GetStart(&iCurrentStart));
	CHKHR(spITextSelection->MoveStart(tomCharacter, iOriginalStart - iCurrentStart, NULL));

	// Select the pasted text
	CHKHR(spITextSelection->Select());
}

template <class Traits_T>
bool EditorDocument<Traits_T>::IsSelectionEmpty()
{
	CComPtr<ITextSelection> spITextSelection;
	GetTextSelection(spITextSelection);
	long iStart = 0;
	CHKHR(spITextSelection->GetStart(&iStart));
	long iEnd = 0;
	CHKHR(spITextSelection->GetEnd(&iEnd));

	return (iStart == iEnd);
}

template <class Traits_T>
DWORD EditorDocument<Traits_T>::GetFontFormatState(DWORD dwEffect)
{
	CComPtr<ITextFont> spITextFont;
	GetTextFont(spITextFont);

	long iState = tomFalse;

	switch(dwEffect)
	{
	case CFE_BOLD:
		CHKHR(spITextFont->GetBold(&iState));
		break;

	case CFE_ITALIC:
		CHKHR(spITextFont->GetItalic(&iState));
		break;

	case CFE_UNDERLINE:
		CHKHR(spITextFont->GetUnderline(&iState));
		if(iState == tomTrue || iState == tomSingle || iState == tomWords || iState == tomDouble || iState == tomDotted)
		{
			// Any of these indicate underlined
			iState = tomTrue;
		}
		else
		{
			// Anything else, such as tomNone or tomUndefined, is considered not underlined
			iState = tomFalse;
		}
		break;

	case CFE_STRIKEOUT:
		CHKHR(spITextFont->GetStrikeThrough(&iState));
		break;
	}

	return iState == tomTrue ? OLECMDSTATE_DOWN : OLECMDSTATE_UP;
}

template <class Traits_T>
VOID EditorDocument<Traits_T>::SetFontFormatState(DWORD dwEffect)
{
	CComPtr<ITextFont> spITextFont;
	GetTextFont(spITextFont);

	switch(dwEffect)
	{
	case CFE_BOLD:
		CHKHR(spITextFont->SetBold(tomToggle));
		break;

	case CFE_ITALIC:
		CHKHR(spITextFont->SetItalic(tomToggle));
		break;

	case CFE_UNDERLINE:
		{
		long iUnderlineState = tomNone;
		CHKHR(spITextFont->GetUnderline(&iUnderlineState));
		if(tomNone == iUnderlineState || tomUndefined == iUnderlineState)
		{
			// Only single underlining is supported
			CHKHR(spITextFont->SetUnderline(tomSingle));
		}
		else
		{
			// Anything other then tomNone or tomUndefined, is considered underlined
			// even if it isn't single underlined.
			CHKHR(spITextFont->SetUnderline(tomNone));
		}
		}
		break;

	case CFE_STRIKEOUT:
		CHKHR(spITextFont->SetStrikeThrough(tomToggle));
		break;
	}
}

template <class Traits_T>
DWORD EditorDocument<Traits_T>::QueryParagraphAlignmentState(long iToQuery)
{
	CComPtr<ITextPara> spITextPara;
	GetTextPara(spITextPara);

	long iAlignment = tomNone;
	CHKHR(spITextPara->GetAlignment(&iAlignment));

	// If the alignment being queryed for is the same as the current one, then it's active (down)
	return iAlignment == iToQuery ? OLECMDSTATE_DOWN : OLECMDSTATE_UP;
}

template <class Traits_T>
DWORD EditorDocument<Traits_T>::GetBulletState()
{
	CComPtr<ITextPara> spITextPara;
	GetTextPara(spITextPara);

	// There are multiple list types but only support bulleted is supported.
	long iListType = tomListNone;
	CHKHR(spITextPara->GetListType(&iListType));

	return iListType == tomListBullet ? OLECMDSTATE_DOWN : OLECMDSTATE_UP;
}

template <class Traits_T>
void EditorDocument<Traits_T>::SetParagraphAlignment(long iAlignment)
{
	CComPtr<ITextPara> spITextPara;
	GetTextPara(spITextPara);

	CHKHR(spITextPara->SetAlignment(iAlignment));
}

template <class Traits_T>
void EditorDocument<Traits_T>::ToggleBulleted()
{
	CComPtr<ITextPara> spITextPara;
	GetTextPara(spITextPara);

	// There are multiple list types but only support bulleted is supported.
	long lCurrent = tomListNone;
	CHKHR(spITextPara->GetListType(&lCurrent));
	if(tomListBullet == lCurrent)
	{
		// If set, toggle bulleted
		CHKHR(spITextPara->SetListType(tomListNone));
	}
	else
	{
		// If not bulleted, toggle to bullted (even if another list type)
		CHKHR(spITextPara->SetListType(tomListBullet));
	}
}

template <class Traits_T>
void EditorDocument<Traits_T>::UpdateVSCommandUI()
{
	CComPtr<IVsUIShell> spIVsUIShell = GetVsSiteCache().GetCachedService<IVsUIShell, SID_SVsUIShell>();
	if(!!spIVsUIShell)
	{
		// Tell VS to update the menus and toolbars
		CHKHR(spIVsUIShell->UpdateCommandUI(FALSE));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\Module.cpp ===
/***************************************************************************

Copyright (c) Microsoft Corporation. All rights reserved.
This code is licensed under the Visual Studio SDK license terms.
THIS CODE IS PROVIDED *AS IS* WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING ANY
IMPLIED WARRANTIES OF FITNESS FOR A PARTICULAR
PURPOSE, MERCHANTABILITY, OR NON-INFRINGEMENT.

***************************************************************************/

#include "stdafx.h"

#include "CommonIncludes.h"

class PackageModule :
	public CAtlDllModuleT<PackageModule> 
{
};

PackageModule _AtlModule;

// This macro is used as default registry root when a NULL parameter is passed to VSDllRegisterServer
// or VSDllUnregisterServer. For sample code we set as default the experimental instance, but for production
// code you should change it to the standard VisualStudio instance that is LREGKEY_VISUALSTUDIOROOT.
#define DEFAULT_REGISTRY_ROOT LREGKEY_VISUALSTUDIOROOT

// Since this project defines an oleautomation interface, the typelib needs to be registered.
#define VSL_REGISTER_TYPE_LIB TRUE

// Must come after declaration of _AtlModule and DEFAULT_REGISTRY_ROOT
#include <VSLPackageDllEntryPoints.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\guids.h ===
// guids.h: definitions of GUIDs/IIDs/CLSIDs used in this VsPackage

/*
Do not use #pragma once, as this file needs to be included twice.  Once to declare the externs
for the GUIDs, and again right after including initguid.h to actually define the GUIDs.
*/

%ToolWindowItemStart%
// guidPersistanceSlot ID for the Tool Window
// { %ToolGuid% }
#define guid%ProjectClass%PersistenceSlot { %ToolGuid2% }
#ifdef DEFINE_GUID
DEFINE_GUID(CLSID_guidPersistanceSlot, 
%ToolGuid1% );
#endif
%ToolWindowItemEnd%

// package guid
// { %PackageGuid% }
#define guid%ProjectClass%Pkg { %PackageGuid2% }
#ifdef DEFINE_GUID
DEFINE_GUID(CLSID_%ProjectClass%,
%PackageGuid1% );
#endif

// Command set guid for our commands (used with IOleCommandTarget)
// { %CmdSetGuid% }
#define guid%ProjectClass%CmdSet { %CmdSetGuid2% }
#ifdef DEFINE_GUID
DEFINE_GUID(CLSID_%ProjectClass%CmdSet, 
%CmdSetGuid1% );
#endif

//Guid for the image list referenced in the VSCT file
// { %ImagesGuid% }
#define guidImages { %ImagesGuid2% }
#ifdef DEFINE_GUID
DEFINE_GUID(CLSID_Images, 
%ImagesGuid1% );
#endif

%EditorStart%
// Guid for the Editor Factory
// { %FactoryGuid% }
#define guid%ProjectClass%EditorFactory { %FactoryGuid2% } 
#ifdef DEFINE_GUID
DEFINE_GUID(CLSID_%ProjectClass%EditorFactory, 
%FactoryGuid1% ); 
#endif

// Guid for the Editor Document (the document is the actual editor)
// { %DocumentGuid% }
#define guid%ProjectClass%EditorDocument { %DocumentGuid2% }
#ifdef DEFINE_GUID
DEFINE_GUID(CLSID_%ProjectClass%EditorDocument, 
%DocumentGuid1% );
#endif
%EditorEnd%
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\stdafx.cpp ===
// StdAfx.cpp

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WindowsAzureSDK\v1.1\inc\Diagnostics.h ===
#ifndef __DIAGNOSTICS__
#define __DIAGNOSTICS__
#pragma once
#include <windef.h>

enum DiagnosticLogLevel
{
   LlUndefined = 0,
   LlCritical,
   LlError,
   LlWarning,
   LlInformation,
   LlVerbose,
};

STDAPI
DiagnosticsInitialize(__in LPCWSTR DiagnosticStorePath);

STDAPI
DiagnosticsWriteToLog(
    __in DiagnosticLogLevel level,
    __in LPCWSTR format, 
    ...);

// Collect dumps to the default directory
STDAPI
DiagnosticsCrashDumpsEnableCollection(
    __in BOOL collectFullDumps);

// Collect dumps to an explict directory.
STDAPI
DiagnosticsCrashDumpsEnableCollectionToDirectory(
    __in LPCWSTR crashDumpDirectory,
    __in BOOL collectFullDumps);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by %ProjectName%.rc
//
#define IDS_PROJNAME                    100
#define IDS_E_BADINSTALL                101
%EditorStart%
#define IDI_ICON1                       204
%EditorEnd%

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\VisualStudio\VS10RTM\VisualStudioIntegration\Tools\Wizards\Templates\VC\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#pragma once

// Windows Platform headers and control defines
#define STRICT
#define _WIN32_WINNT 0x0500 // Visual Studio requires Windows 2000 or better
#define NOMINMAX // Windows Platform min and max macros cause problems for the Standard C++ Library
#define WIN32_LEAN_AND_MEAN	// Exclude rarely-used stuff from the Windows Platform headers

// ATL headers and control defines
#define _ATL_APARTMENT_THREADED
#define _ATL_REGISTER_PER_USER

#include <atlbase.h>
#include <atlcom.h>
#include <atlwin.h>
#include <atlstr.h>
#include <atlfile.h>
#include <atlsafe.h>

// Windows Platform headers
#include <windowsx.h> // REVIEW - what is this for?
%EditorStart%#include <richedit.h>
#include <TOM.h>%EditorEnd%

// Visual Studio Platform headers
#include <dte.h> // for extensibility
#include <objext.h> // for ILocalRegistry
#include <vshelp.h> // for Help
#include <uilocale.h> // for IUIHostLocale2
#include <IVsQueryEditQuerySave2.h> // for IVsQueryEditQuerySave2
#include <vbapkg.h> // for IVsMacroRecorder
#include <fpstfmt.h> // for IPersistFileFormat
#include <VSRegKeyNames.h>
#include <stdidcmd.h>
#include <stdiduie.h> // For status bar consts.
#include <textfind.h>
#include <textmgr.h>

// VSL headers
#define VSLASSERT _ASSERTE
#define VSLASSERTEX(exp, szMsg) _ASSERT_BASE(exp, szMsg)
#define VSLTRACE ATLTRACE

#include <VSLPackage.h>
#include <VSLCommandTarget.h>
#include <VSLWindows.h>
%EditorStart%#include <VSLControls.h>%EditorEnd%
#include <VSLFile.h>
#include <VSLContainers.h>
#include <VSLComparison.h>
#include <VSLAutomation.h>
#include <VSLFindAndReplace.h>
#include <VSLShortNameDefines.h>

using namespace VSL;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WindowsAzureSDK\v1.1\inc\ServiceRuntime.h ===
#ifndef __SERVICE_RUNTIME__
#define __SERVICE_RUNTIME__
#pragma once
#include <windef.h>
#define ROLE_ENVIRONMENT_E_INSUFFICIENT_BUFFER HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

STDAPI
RoleEnvironmentInitialize(void);

STDAPI
RoleEnvironmentGetConfigurationSettingValueW(
    __in LPCWSTR name,
    __out_ecount(cchDest) LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
RoleEnvironmentGetConfigurationSettingValueA(
    __in LPCSTR name,
    __out_ecount(cchDest) LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

typedef struct _LOCALRESOURCE* LPLOCALRESOURCE;

STDAPI
RoleEnvironmentGetLocalResourceW(
    __in LPCWSTR name,
    __deref_out LPLOCALRESOURCE* ppout);

STDAPI
RoleEnvironmentGetLocalResourceA(
    __in LPCSTR name,
    __deref_out LPLOCALRESOURCE* ppout);

STDAPI
LocalResourceGetMaximumSizeInMegabytes(
    __in  LPLOCALRESOURCE plrc,
    __out PULONG pdw);

STDAPI
LocalResourceGetNameW(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
LocalResourceGetNameA(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
LocalResourceGetRootPathW(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
LocalResourceGetRootPathA(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

#ifdef UNICODE
#define RoleEnvironmentGetConfigurationSettingValue  RoleEnvironmentGetConfigurationSettingValueW
#define RoleEnvironmentGetLocalResource  RoleEnvironmentGetLocalResourceW
#define LocalResourceGetName LocalResourceGetNameW
#define LocalResourceGetRootPath  LocalResourceGetRootPathW
#else
#define RoleEnvironmentGetConfigurationSettingValue  RoleEnvironmentGetConfigurationSettingValueA
#define RoleEnvironmentGetLocalResource  RoleEnvironmentGetLocalResourceA
#define LocalResourceGetName LocalResourceGetNameA
#define LocalResourceGetRootPath  LocalResourceGetRootPathA
#endif /* !UNICODE */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WindowsAzureSDK\v1.4\inc\Diagnostics.h ===
#ifndef __DIAGNOSTICS__
#define __DIAGNOSTICS__
#pragma once
#include <windef.h>

enum DiagnosticLogLevel
{
   LlUndefined = 0,
   LlCritical,
   LlError,
   LlWarning,
   LlInformation,
   LlVerbose,
};

STDAPI
DiagnosticsInitialize(__in LPCWSTR DiagnosticStorePath);

STDAPI
DiagnosticsWriteToLog(
    __in DiagnosticLogLevel level,
    __in LPCWSTR format, 
    ...);

// Collect dumps to the default directory
STDAPI
DiagnosticsCrashDumpsEnableCollection(
    __in BOOL collectFullDumps);

// Collect dumps to an explict directory.
STDAPI
DiagnosticsCrashDumpsEnableCollectionToDirectory(
    __in LPCWSTR crashDumpDirectory,
    __in BOOL collectFullDumps);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WindowsAzureSDK\v1.4\inc\ServiceRuntime.h ===
#ifndef __SERVICE_RUNTIME__
#define __SERVICE_RUNTIME__
#pragma once
#include <windef.h>
#define ROLE_ENVIRONMENT_E_INSUFFICIENT_BUFFER HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)

STDAPI
RoleEnvironmentInitialize(void);

STDAPI
RoleEnvironmentGetConfigurationSettingValueW(
    __in LPCWSTR name,
    __out_ecount(cchDest) LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
RoleEnvironmentGetConfigurationSettingValueA(
    __in LPCSTR name,
    __out_ecount(cchDest) LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

typedef struct _LOCALRESOURCE* LPLOCALRESOURCE;

STDAPI
RoleEnvironmentGetLocalResourceW(
    __in LPCWSTR name,
    __deref_out LPLOCALRESOURCE* ppout);

STDAPI
RoleEnvironmentGetLocalResourceA(
    __in LPCSTR name,
    __deref_out LPLOCALRESOURCE* ppout);

STDAPI
LocalResourceGetMaximumSizeInMegabytes(
    __in  LPLOCALRESOURCE plrc,
    __out PULONG pdw);

STDAPI
LocalResourceGetNameW(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
LocalResourceGetNameA(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
LocalResourceGetRootPathW(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

STDAPI
LocalResourceGetRootPathA(
    __in LPLOCALRESOURCE plrc,
    __out_ecount(cchDest) LPSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t *pcchRequiredDestSize);

#ifdef UNICODE
#define RoleEnvironmentGetConfigurationSettingValue  RoleEnvironmentGetConfigurationSettingValueW
#define RoleEnvironmentGetLocalResource  RoleEnvironmentGetLocalResourceW
#define LocalResourceGetName LocalResourceGetNameW
#define LocalResourceGetRootPath  LocalResourceGetRootPathW
#else
#define RoleEnvironmentGetConfigurationSettingValue  RoleEnvironmentGetConfigurationSettingValueA
#define RoleEnvironmentGetLocalResource  RoleEnvironmentGetLocalResourceA
#define LocalResourceGetName LocalResourceGetNameA
#define LocalResourceGetRootPath  LocalResourceGetRootPathA
#endif /* !UNICODE */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\latest.inc ===
#
#    * CoreXT takes frequent WiX drops during which these can be udpated to auto-upgrade
#    * consumers to a specific major version
#    * Simply import this latest.inc, and set your WIXVERSION=$(WIXLATESTV?)
#
WIXLATESTV2  = 2.0.5508.0
WIXLATESTV3  = 3.0.5419.0
WIXLATESTV35 = 3.5.1322.0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\aclutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="aclutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Access Control List helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <aclapi.h>
#include <sddl.h>

#define ReleaseSid(x) if (x) { AclFreeSid(x); }
#define ReleaseNullSid(x) if (x) { AclFreeSid(x); x = NULL; }

#ifdef __cplusplus
extern "C" {
#endif

// structs
struct ACL_ACCESS
{
	BOOL fDenyAccess;
	DWORD dwAccessMask;

	// TODO: consider using a union
	LPCWSTR pwzAccountName;   // NOTE: the last three items in this structure are ignored if this is not NULL

	SID_IDENTIFIER_AUTHORITY sia;  // used if pwzAccountName is NULL
	BYTE nSubAuthorityCount;
	DWORD nSubAuthority[8];
};

struct ACL_ACE
{
	DWORD dwFlags;
	DWORD dwMask;
	PSID psid;
};


// functions
HRESULT DAPI AclCheckAccess(
	__in HANDLE hToken, 
	ACL_ACCESS* paa
	);
HRESULT DAPI AclCheckAdministratorAccess(
	__in HANDLE hToken
	);
HRESULT DAPI AclCheckLocalSystemAccess(
	__in HANDLE hToken
	);

HRESULT DAPI AclGetWellKnownSid(
	__in WELL_KNOWN_SID_TYPE wkst,
	__out PSID* ppsid
	);
HRESULT DAPI AclGetAccountSid(
	__in_opt LPCWSTR wzSystem,
	__in LPCWSTR wzAccount,
	__out PSID* ppsid
	);
HRESULT DAPI AclGetAccountSidString(
	__in LPCWSTR wzSystem,
	__in LPCWSTR wzAccount,
	__out LPWSTR* ppwzSid
	);

HRESULT DAPI AclCreateDacl(
	__in_ecount(cDeny) ACL_ACE rgaaDeny[],
	__in DWORD cDeny,
	__in_ecount(cAllow) ACL_ACE rgaaAllow[],
	__in DWORD cAllow,
	__out ACL** ppAcl
	);
HRESULT DAPI AclAddToDacl(
	__in ACL* pAcl,
	__in ACL_ACE rgaaDeny[],
	__in DWORD cDeny,
	__in ACL_ACE rgaaAllow[],
	__in DWORD cAllow,
	__out ACL** ppAclNew
	);
HRESULT DAPI AclMergeDacls(
	__in ACL* pAcl1,
	__in ACL* pAcl2,
	__out ACL** ppAclNew
	);
HRESULT DAPI AclCreateDaclOld(
	__in_ecount(cAclAccesses) ACL_ACCESS* paa,
	__in DWORD cAclAccesses,
	__out ACL** ppAcl
	);
HRESULT DAPI AclCreateSecurityDescriptor(
	__in_ecount(cAclAccesses) ACL_ACCESS* paa,
	__in DWORD cAclAccesses,
	__out SECURITY_DESCRIPTOR** ppsd
	);
HRESULT DAPI AclCreateSecurityDescriptorFromDacl(
	__in ACL* pACL,
	__out SECURITY_DESCRIPTOR** ppsd
	);
HRESULT __cdecl AclCreateSecurityDescriptorFromString(
	__out SECURITY_DESCRIPTOR** ppsd,
	__in LPCWSTR wzSddlFormat,
	...
	);
HRESULT DAPI AclDuplicateSecurityDescriptor(
	__in SECURITY_DESCRIPTOR* psd,
	__out SECURITY_DESCRIPTOR** ppsd
	);
HRESULT DAPI AclGetSecurityDescriptor(
	__in LPCWSTR wzObject,
	__in SE_OBJECT_TYPE sot,
	__out SECURITY_DESCRIPTOR** ppsd
	);

HRESULT DAPI AclFreeSid(
	__in PSID psid
	);
HRESULT DAPI AclFreeDacl(
	__in ACL* pACL
	);
HRESULT DAPI AclFreeSecurityDescriptor(
	__in SECURITY_DESCRIPTOR* psd
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\dirutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="dirutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Directory helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

BOOL DAPI DirExists(
    __in LPCWSTR wzPath, 
    __out_opt DWORD *pdwAttributes
    );

HRESULT DAPI DirCreateTempPath(
    __in LPCWSTR wzPrefix,
    __in LPWSTR wzPath,
    __in DWORD cchPath
    );

HRESULT DAPI DirEnsureExists(
    __in LPCWSTR wzPath, 
    __in_opt LPSECURITY_ATTRIBUTES psa
    );

HRESULT DAPI DirEnsureDelete(
    __in LPCWSTR wzPath,
    __in BOOL fDeleteFiles,
    __in BOOL fRecurse
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\cabcutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="cabcutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for cabinet creation helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <fci.h>
#include <fcntl.h>

#define CAB_MAX_SIZE 0x7FFFFFFF   // (see KB: Q174866)

#ifdef __cplusplus
extern "C" {
#endif

// time vs. space trade-off
enum COMPRESSION_TYPE 
{ 
	COMPRESSION_TYPE_NONE, // fastest
	COMPRESSION_TYPE_LOW, 
	COMPRESSION_TYPE_MEDIUM,
	COMPRESSION_TYPE_HIGH, // smallest
	COMPRESSION_TYPE_MSZIP
};

// functions
HRESULT DAPI CabCBegin(
	__in LPCWSTR wzCab,
	__in LPCWSTR wzCabDir,
	__in DWORD dwMaxSize,
	__in DWORD dwMaxThresh,
	__in COMPRESSION_TYPE ct,
	__out HANDLE *phContext
	);
HRESULT DAPI CabCNextCab(
	__in HANDLE hContext
	);
HRESULT DAPI CabCAddFile(
	__in LPCWSTR wzFile,
	__in LPCWSTR wzToken,
	__in HANDLE hContext
	);
HRESULT DAPI CabCFinish(
	__in HANDLE hContext
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\cabutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="cabutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for cabinet decompression helper functions
// </summary>
//-------------------------------------------------------------------------------------------------

#include <fdi.h>
#include <sys\stat.h>

#ifdef __cplusplus
extern "C" {
#endif

// structs


// callback function prototypes
typedef HRESULT (*CAB_CALLBACK_OPEN_FILE)(LPCWSTR wzFile, INT_PTR* ppFile);
typedef HRESULT (*CAB_CALLBACK_READ_FILE)(INT_PTR pFile, LPVOID pvData, DWORD cbData, DWORD* pcbRead);
typedef HRESULT (*CAB_CALLBACK_WRITE_FILE)(INT_PTR pFile, LPVOID pvData, DWORD cbData, DWORD* pcbRead);
typedef LONG (*CAB_CALLBACK_SEEK_FILE)(INT_PTR pFile, DWORD dwMove, DWORD dwMoveMethod);
typedef HRESULT (*CAB_CALLBACK_CLOSE_FILE)(INT_PTR pFile);

typedef HRESULT (*CAB_CALLBACK_BEGIN_FILE)(LPCWSTR wzFileId, FILETIME* pftFileTime, DWORD cbFileSize, LPVOID pvContext, INT_PTR* ppFile);
typedef HRESULT (*CAB_CALLBACK_END_FILE)(LPCWSTR wzFileId, LPVOID pvContext, INT_PTR pFile);
typedef HRESULT (*CAB_CALLBACK_PROGRESS)(BOOL fBeginFile, LPCWSTR wzFileId, LPVOID pvContext);

// function type with calling convention of __stdcall that .NET 1.1 understands only
// .NET 2.0 will not need this
typedef INT_PTR (FAR __stdcall *STDCALL_PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);


// functions
HRESULT DAPI CabInitialize(
    __in BOOL fDelayLoad
    );
void DAPI CabUninitialize(
    );

HRESULT DAPI CabExtract(
    __in LPCWSTR wzCabinet,
    __in LPCWSTR wzExtractFile,
    __in LPCWSTR wzExtractDir,
    __in CAB_CALLBACK_PROGRESS pfnProgress,
    __in LPVOID pvContext
    );

HRESULT DAPI CabEnumerate(
    __in LPCWSTR wzCabinet,
    __in LPCWSTR wzEnumerateFile,
    __in STDCALL_PFNFDINOTIFY pfnNotify
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\dutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="dutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for utility layer that provides standard support for asserts, exit macros
// </summary>
//-------------------------------------------------------------------------------------------------

#define DAPI __stdcall
#define DAPIV __cdecl // used only for functions taking variable length arguments

#define DAPI_(type) EXTERN_C type DAPI
#define DAPIV_(type) EXTERN_C type DAPIV


// enums
enum REPORT_LEVEL { 
	REPORT_NONE,      // turns off report (only valid for XXXSetLevel())
	REPORT_STANDARD,  // written if reporting is on
	REPORT_VERBOSE,   // written only if verbose reporting is on
	REPORT_DEBUG,     // reporting useful when debugging code
	REPORT_ERROR,     // always gets reported, but can never be specified
	};

// asserts and traces
#ifdef DEBUG

typedef BOOL (DAPI *DUTIL_ASSERTDISPLAYFUNCTION)(LPCSTR sz);

extern "C" void DAPI Dutil_SetAssertModule(__in HMODULE hAssertModule);
extern "C" void DAPI Dutil_SetAssertDisplayFunction(__in DUTIL_ASSERTDISPLAYFUNCTION pfn);
extern "C" void DAPI Dutil_Assert(const CHAR* szFile, int iLine);
extern "C" void DAPI Dutil_AssertSz(const CHAR* szFile, int iLine, const CHAR *szMsg);

extern "C" void DAPI Dutil_TraceSetLevel(__in REPORT_LEVEL ll, __in BOOL fTraceFilenames);
extern "C" REPORT_LEVEL DAPI Dutil_TraceGetLevel();
extern "C" void __cdecl Dutil_Trace(__in LPCSTR szFile, __in int iLine, __in REPORT_LEVEL rl, __in LPCSTR szMessage, ...);
extern "C" void __cdecl Dutil_TraceError(__in LPCSTR szFile, __in int iLine, __in REPORT_LEVEL rl, __in HRESULT hr, __in LPCSTR szMessage, ...);

#endif

#if defined DEBUG

#define AssertSetModule(m) (void)Dutil_SetAssertModule(m)
#define AssertSetDisplayFunction(pfn) (void)Dutil_SetAssertDisplayFunction(pfn)
#define Assert(f)          ((f)    ? (void)0 : (void)Dutil_Assert(__FILE__, __LINE__))
#define AssertSz(f, sz)    ((f)    ? (void)0 : (void)Dutil_AssertSz(__FILE__, __LINE__, sz))

#define TraceSetLevel(l, f) (void)Dutil_TraceSetLevel(l, f)
#define TraceGetLevel() (REPORT_LEVEL)Dutil_TraceGetLevel()
#define Trace(l, f) (void)Dutil_Trace(__FILE__, __LINE__, l, f, NULL)
#define Trace1(l, f, s) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s)
#define Trace2(l, f, s, t) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s, t)
#define Trace3(l, f, s, t, u) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s, t, u)

#define TraceError(x, f) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, NULL)
#define TraceError1(x, f, s) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s)
#define TraceError2(x, f, s, t) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s, t)
#define TraceError3(x, f, s, t, u) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s, t, u)

#define TraceErrorDebug(x, f) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, NULL)
#define TraceErrorDebug1(x, f, s) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s)
#define TraceErrorDebug2(x, f, s, t) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s, t)
#define TraceErrorDebug3(x, f, s, t, u) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s, t, u)

#else // !DEBUG

#define AssertSetModule(m)
#define AssertSetDisplayFunction(pfn)
#define Assert(f)
#define AssertSz(f, sz)

#define TraceSetLevel(l, f)
#define Trace(l, f)
#define Trace1(l, f, s)
#define Trace2(l, f, s, t)
#define Trace3(l, f, s, t, u)

#define TraceError(x, f)
#define TraceError1(x, f, s)
#define TraceError2(x, f, s, t)
#define TraceError3(x, f, s, t, u)

#define TraceErrorDebug(x, f)
#define TraceErrorDebug1(x, f, s)
#define TraceErrorDebug2(x, f, s, t)
#define TraceErrorDebug3(x, f, s, t, u)

#endif // DEBUG


// ExitTrace can be overriden
#ifndef ExitTrace
#define ExitTrace TraceError
#endif
#ifndef ExitTrace1
#define ExitTrace1 TraceError1
#endif
#ifndef ExitTrace2
#define ExitTrace2 TraceError2
#endif
#ifndef ExitTrace3
#define ExitTrace3 TraceError3
#endif

// Exit macros
#define ExitFunction()        { goto LExit; }
#define ExitFunction1(x)          { x; goto LExit; }

#define ExitOnLastError(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace(x, s); goto LExit; } }
#define ExitOnLastError1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace1(x, f, s); goto LExit; } }
#define ExitOnLastError2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace2(x, f, s, t); goto LExit; } }

#define ExitOnLastErrorDebugTrace(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { TraceErrorDebug(x, s); goto LExit; } }
#define ExitOnLastErrorDebugTrace1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { TraceErrorDebug1(x, f, s); goto LExit; } }
#define ExitOnLastErrorDebugTrace2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { TraceErrorDebug2(x, f, s, t); goto LExit; } }

#define ExitWithLastError(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, s); goto LExit; }
#define ExitWithLastError1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace1(x, f, s); goto LExit; }
#define ExitWithLastError2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace2(x, f, s, t); goto LExit; }

#define ExitOnFailure(x, s)   if (FAILED(x)) { ExitTrace(x, s);  goto LExit; }
#define ExitOnFailure1(x, f, s)   if (FAILED(x)) { ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnFailure2(x, f, s, t)   if (FAILED(x)) { ExitTrace2(x, f, s, t);  goto LExit; }
#define ExitOnFailure3(x, f, s, t, u) if (FAILED(x)) { ExitTrace3(x, f, s, t, u);  goto LExit; }

#define ExitOnFailureDebugTrace(x, s)   if (FAILED(x)) { TraceErrorDebug(x, s);  goto LExit; }
#define ExitOnFailureDebugTrace1(x, f, s)   if (FAILED(x)) { TraceErrorDebug1(x, f, s);  goto LExit; }
#define ExitOnFailureDebugTrace2(x, f, s, t)   if (FAILED(x)) { TraceErrorDebug2(x, f, s, t);  goto LExit; }
#define ExitOnFailureDebugTrace3(x, f, s, t, u) if (FAILED(x)) { TraceErrorDebug3(x, f, s, t, u);  goto LExit; }

#define ExitOnNull(p, x, e, s)   if (NULL == p) { x = e; ExitTrace(x, s);  goto LExit; }
#define ExitOnNull1(p, x, e, f, s)   if (NULL == p) { x = e; ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnNull2(p, x, e, f, s, t)   if (NULL == p) { x = e; ExitTrace2(x, f, s, t);  goto LExit; }

#define ExitOnNullWithLastError(p, x, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, s); goto LExit; }
#define ExitOnNullWithLastError1(p, x, f, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace1(x, f, s); goto LExit; }

#define ExitOnNullDebugTrace(p, x, e, s)   if (NULL == p) { x = e; TraceErrorDebug(x, s);  goto LExit; }
#define ExitOnNullDebugTrace1(p, x, e, f, s)   if (NULL == p) { x = e; TraceErrorDebug1(x, f, s);  goto LExit; }

#define ExitOnNtError(x, s)   if (NT_ERROR(x))  { ExitTrace(x, s);  goto LExit; }
#define ExitOnNtError1(x, f, s)   if (NT_ERROR(x))  { ExitTrace1(x, f, s);  goto LExit; }


// release macros
#define ReleaseObject(x) if (x) { x->Release(); }
#define ReleaseVariant(x) { ::VariantClear(&x); }
#define ReleaseNullObject(x) if (x) { (x)->Release(); x = NULL; }
#define ReleaseCertificate(x) if (x) { ::CertFreeCertificateContext(x); x=NULL; }


// useful defines and macros
#define Unused(x) ((void)x)

#ifndef MAXSIZE_T
#define MAXSIZE_T   ((SIZE_T)~((SIZE_T)0))
#endif


#if 1
#define countof(ary) (sizeof(ary) / sizeof(ary[0]))
#else
#ifndef __cplusplus
#define countof(ary) (sizeof(ary) / sizeof(ary[0]))
#else
template<typename T> static char countofVerify(void const *, T) throw() { return 0; }
template<typename T> static void countofVerify(T *const, T *const *) throw() {};
#define countof(arr) (sizeof(countofVerify(arr,&(arr))) * sizeof(arr)/sizeof(*(arr)))
#endif
#endif


#ifndef MAXSIZE_T
#define MAXSIZE_T ((SIZE_T)~((SIZE_T)0))
#endif

#define E_NOMOREITEMS HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
#define AddRefAndRelease(x) { x->AddRef(); x->Release(); }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\inetutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="inetutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
//
//    The use and distribution terms for this software are covered by the
//    Common Public License 1.0 (http://opensource.org/licenses/cpl.php)
//    which can be found in the file CPL.TXT at the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by
//    the terms of this license.
//
//    You must not remove this notice, or any other, from this software.
// </copyright>
// 
// <summary>
//    Internet utilites.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif


// functions
HRESULT DAPI InternetGetSizeByHandle(
	__in HINTERNET hiFile,
	__out LONGLONG* pllSize
	);
HRESULT DAPI InternetGetCreateTimeByHandle(
	__in HINTERNET hiFile,
	__out LPFILETIME pft
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\memutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="memutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for memory helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseMem(p) if (p) { MemFree(p); }
#define ReleaseNullMem(p) if (p) { MemFree(p); p = NULL; }


HRESULT DAPI MemInitialize();
void DAPI MemUninitialize();

LPVOID DAPI MemAlloc(
    __in SIZE_T cbSize,
    __in BOOL fZero
    );
LPVOID DAPI MemReAlloc(
    __in LPVOID pv,
    __in SIZE_T cbSize,
    __in BOOL fZero
    );

HRESULT DAPI MemFree(
    __in LPVOID pv
    );
SIZE_T DAPI MemSize(
    __in LPVOID pv
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\fileutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="fileutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for file helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <wchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseFile(h) if (INVALID_HANDLE_VALUE != h) { ::CloseHandle(h); h = INVALID_HANDLE_VALUE; }

LPWSTR DAPI FileFromPath(
    __in LPCWSTR wzPath
    );
HRESULT DAPI FileResolvePath(
    __in LPCWSTR wzRelativePath,
    __out LPWSTR *ppwzFullPath
    );
HRESULT DAPI FileStripExtension(
    __in LPCWSTR wzFileName,
    __out LPWSTR *ppwzFileNameNoExtension
    );
HRESULT DAPI FileVersionFromString(
    __in LPCWSTR wzVersion, 
    __out DWORD *pdwVerMajor, 
    __out DWORD* pdwVerMinor
    );
HRESULT DAPI FileSizeByHandle(
    __in HANDLE hFile, 
    __out LONGLONG* pllSize
    );
BOOL DAPI FileExistsEx(
    __in LPCWSTR wzPath, 
    __out_opt DWORD *pdwAttributes
    );
HRESULT DAPI FileRead(
    __out LPBYTE* ppbDest,
    __out DWORD* pcbDest,
    __in LPCWSTR wzSrcPath
    );
HRESULT DAPI FileReadUntil(
    __out LPBYTE* ppbDest,
    __out DWORD* pcbDest,
    __in LPCWSTR wzSrcPath,
    __in DWORD cbMaxRead
    );
HRESULT DAPI FileEnsureMove(
    __in LPCWSTR wzSource, 
    __in LPCWSTR wzTarget, 
    __in BOOL fOverwrite,
    __in BOOL fAllowCopy
    );
HRESULT FileCreateTemp(
    IN LPCWSTR wzPrefix,
    IN LPCWSTR wzExtension,
    OUT LPWSTR* ppwzLog,
    OUT HANDLE* phLog
    );
HRESULT FileCreateTempW(
    IN LPCWSTR wzPrefix,
    IN LPCWSTR wzExtension,
    OUT LPWSTR* ppwzTempFile,
    OUT HANDLE* phTempFile
    );
    
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\sqlutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="sqlutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    SQL helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <cguid.h>
#include <oledberr.h>
#include <sqloledb.h>


#ifdef __cplusplus
extern "C" {
#endif

// structs
struct SQL_FILESPEC
{
	WCHAR wzName[MAX_PATH];
	WCHAR wzFilename[MAX_PATH];
	WCHAR wzSize[MAX_PATH];
	WCHAR wzMaxSize[MAX_PATH];
	WCHAR wzGrow[MAX_PATH];
};


// functions
HRESULT DAPI SqlConnectDatabase(
	__in LPCWSTR wzServer, 
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase, 
	__in BOOL fIntegratedAuth, 
	__in LPCWSTR wzUser, 
	__in LPCWSTR wzPassword, 
	__out IDBCreateSession** ppidbSession
	);
HRESULT DAPI SqlStartTransaction(
	__in IDBCreateSession* pidbSession,
	__out IDBCreateCommand** ppidbCommand,
	__out ITransaction** ppit
	);
HRESULT DAPI SqlEndTransaction(
	__in ITransaction* pit,
	__in BOOL fCommit
	);
HRESULT DAPI SqlDatabaseExists(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDatabaseExists(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlDatabaseEnsureExists(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__in SQL_FILESPEC* psfDatabase,
	__in SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDatabaseEnsureExists(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__in SQL_FILESPEC* psfDatabase,
	__in SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlCreateDatabase(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__in SQL_FILESPEC* psfDatabase,
	__in SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionCreateDatabase(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__in SQL_FILESPEC* psfDatabase,
	__in SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlDropDatabase(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDropDatabase(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionExecuteQuery(
	__in IDBCreateSession* pidbSession, 
	__in LPCWSTR wzSql, 
	__out_opt IRowset** ppirs,
	__out_opt DBROWCOUNT* pcRows,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlCommandExecuteQuery(
	__in IDBCreateCommand* pidbCommand, 
	__in LPCWSTR wzSql, 
	__out IRowset** ppirs,
	__out DBROWCOUNT* pcRows
	);
HRESULT DAPI SqlGetErrorInfo(
	__in IUnknown* pObjectWithError,
	__in REFIID IID_InterfaceWithError,
	__in DWORD dwLocaleId,
	__out_opt BSTR* pbstrErrorSource,
	__out_opt BSTR* pbstrErrorDescription
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\rssutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="rssutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    RSS helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseRssChannel(p) if (p) { RssFreeChannel(p); }
#define ReleaseNullRssChannel(p) if (p) { RssFreeChannel(p); p = NULL; }


struct RSS_UNKNOWN_ATTRIBUTE
{
    LPWSTR wzNamespace;
    LPWSTR wzAttribute;
    LPWSTR wzValue;

    RSS_UNKNOWN_ATTRIBUTE* pNext;
};

struct RSS_UNKNOWN_ELEMENT
{
    LPWSTR wzNamespace;
    LPWSTR wzElement;
    LPWSTR wzValue;

    RSS_UNKNOWN_ATTRIBUTE* pAttributes;
    RSS_UNKNOWN_ELEMENT* pNext;
};

struct RSS_ITEM
{
    LPWSTR wzTitle;
    LPWSTR wzLink;
    LPWSTR wzDescription;

    LPWSTR wzGuid;
    FILETIME ftPublished;

    LPWSTR wzEnclosureUrl;
    DWORD dwEnclosureSize;
    LPWSTR wzEnclosureType;

    RSS_UNKNOWN_ELEMENT* pUnknownElements;
};

struct RSS_CHANNEL
{
    LPWSTR wzTitle;
    LPWSTR wzLink;
    LPWSTR wzDescription;
    DWORD dwTimeToLive;

    RSS_UNKNOWN_ELEMENT* pUnknownElements;

    DWORD cItems;
    RSS_ITEM rgItems[1];
};

HRESULT DAPI RssInitialize(
    );

void DAPI RssUninitialize(
    );

HRESULT DAPI RssParseFromString(
    __in LPCWSTR wzRssString,
    __out RSS_CHANNEL **ppChannel
    );

HRESULT DAPI RssParseFromFile(
    __in LPCWSTR wzRssFile,
    __out RSS_CHANNEL **ppChannel
    );

// Adding this until we have the updated specstrings.h
#ifndef __in_xcount
#define __in_xcount(size) 
#endif

void DAPI RssFreeChannel(
    __in_xcount(pChannel->cItems) RSS_CHANNEL *pChannel
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\strutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="strutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for string helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseStr(pwz) if (pwz) { StrFree(pwz); }
#define ReleaseNullStr(pwz) if (pwz) { StrFree(pwz); pwz = NULL; }
#define ReleaseBSTR(bstr) if (bstr) { ::SysFreeString(bstr); }
#define ReleaseNullBSTR(bstr) if (bstr) { ::SysFreeString(bstr); bstr = NULL; }

HRESULT DAPI StrAlloc(
    __inout LPWSTR* ppwz,
    __in DWORD_PTR cch
    );
HRESULT DAPI StrAnsiAlloc(
    __inout LPSTR* ppz,
    __in DWORD_PTR cch
    );
HRESULT DAPI StrAllocString(
    __inout LPWSTR* ppwz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource
    );
HRESULT DAPI StrAnsiAllocString(
    __inout LPSTR* ppsz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource,
    __in UINT uiCodepage
    );
HRESULT DAPI StrAllocStringAnsi(
    __inout LPWSTR* ppwz,
    __in LPCSTR szSource,
    __in DWORD_PTR cchSource,
    __in UINT uiCodepage
    );
HRESULT DAPI StrAllocPrefix(
    __inout LPWSTR* ppwz,
    __in LPCWSTR wzPrefix,
    __in DWORD_PTR cchPrefix
    );
HRESULT DAPI StrAllocConcat(
    __inout LPWSTR* ppwz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource
    );
HRESULT __cdecl StrAllocFormatted(
    __inout LPWSTR* ppwz,
    __in LPCWSTR wzFormat,
    ...
    );
HRESULT __cdecl StrAnsiAllocFormatted(
    __inout LPSTR* ppsz,
    __in LPCSTR szFormat,
    ...
    );
HRESULT DAPI StrAllocFormattedArgs(
    __inout LPWSTR* ppwz,
    __in LPCWSTR wzFormat,
    __in va_list args
    );
HRESULT DAPI StrAnsiAllocFormattedArgs(
    __inout LPSTR* ppsz,
    __in LPCSTR szFormat,
    __in va_list args
    );

HRESULT DAPI StrMaxLength(
    __in LPVOID p,
    __out DWORD_PTR* pcch
    );
HRESULT DAPI StrSize(
    __in LPVOID p,
    __out DWORD_PTR* pcb
    );

HRESULT DAPI StrFree(
    __in LPVOID p
    );

HRESULT DAPI StrCurrentTime(
    __inout LPWSTR* ppwz,
    __in BOOL fGMT
    );
HRESULT DAPI StrCurrentDateTime(
    __inout LPWSTR* ppwz,
    __in BOOL fGMT
    );

HRESULT DAPI StrHexEncode(
    __in_ecount(cbSource) const BYTE* pbSource,
    __in DWORD_PTR cbSource,
    __out_ecount(cchDest) LPWSTR wzDest,
    __in DWORD_PTR cchDest
    );
HRESULT DAPI StrHexDecode(
    __in LPCWSTR wzSource,
    __out_bcount(cbDest) BYTE* pbDest,
    __in DWORD_PTR cbDest
    );

HRESULT DAPI StrAllocBase85Encode(
    __in_bcount(cbSource) const BYTE* pbSource,
    __in DWORD_PTR cbSource,
    __inout LPWSTR* pwzDest
    );
HRESULT DAPI StrAllocBase85Decode(
    __in LPCWSTR wzSource,
    __out BYTE** hbDest,
    __out DWORD_PTR* pcbDest
    );

HRESULT DAPI MultiSzLen(
    __in LPCWSTR pwzMultiSz,
    __out DWORD_PTR* pcch
    );
HRESULT DAPI MultiSzPrepend(
    __inout LPWSTR* ppwzMultiSz,
    __inout_opt DWORD_PTR *pcchMultiSz,
    __in LPCWSTR pwzInsert
    );
HRESULT DAPI MultiSzFindSubstring(
    __in LPCWSTR pwzMultiSz,
    __in LPCWSTR pwzSubstring,
    __out_opt DWORD_PTR* pdwIndex,
    __out_opt LPCWSTR* ppwzFoundIn
    );
HRESULT DAPI MultiSzFindString(
    __in LPCWSTR pwzMultiSz,
    __in LPCWSTR pwzString,
    __out DWORD_PTR* pdwIndex,
    __out LPCWSTR* ppwzFound
    );
HRESULT DAPI MultiSzRemoveString(
    __inout LPWSTR* ppwzMultiSz,
    __in DWORD_PTR dwIndex
    );
HRESULT DAPI MultiSzInsertString(
    __inout LPWSTR* ppwzMultiSz,
    __inout_opt DWORD_PTR *pcchMultiSz,
    __in DWORD_PTR dwIndex,
    __in LPCWSTR pwzInsert
    );
HRESULT DAPI MultiSzReplaceString(
    __inout LPWSTR* ppwzMultiSz,
    __in DWORD_PTR dwIndex,
    __in LPCWSTR pwzString
    );

LPCWSTR wcsistr(
    IN LPCWSTR wzString,
    IN LPCWSTR wzCharSet
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\metautil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="metautil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    IIS Metabase helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <iadmw.h>
#include <iiscnfg.h>
#include <iwamreg.h>
#include <mddefw.h>

#ifdef __cplusplus
extern "C" {
#endif

// structs

// prototypes
HRESULT DAPI MetaFindWebBase(
	__in IMSAdminBaseW* piMetabase, 
	__in LPCWSTR wzIP, 
	__in int iPort, 
	__in LPCWSTR wzHeader,
	__in BOOL fSecure,
	__out_ecount(cchWebBase) LPWSTR wzWebBase, 
	__in DWORD cchWebBase
	);
HRESULT DAPI MetaFindFreeWebBase(
	__in IMSAdminBaseW* piMetabase, 
	__out_ecount(cchWebBase) LPWSTR wzWebBase, 
	__in DWORD cchWebBase
	);

HRESULT DAPI MetaOpenKey(
	__in IMSAdminBaseW* piMetabase, 
	__in METADATA_HANDLE mhKey, 
	__in LPCWSTR wzKey,
	__in DWORD dwAccess,
	__in DWORD cRetries,
	__out METADATA_HANDLE* pmh
	);
HRESULT DAPI MetaGetValue(
	__in IMSAdminBaseW* piMetabase, 
	__in METADATA_HANDLE mhKey, 
	__in LPCWSTR wzKey, 
	__inout METADATA_RECORD* pmr
	);
void DAPI MetaFreeValue(
	__in METADATA_RECORD* pmr
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\perfutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="perfutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Performance helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

// structs


// functions
void DAPI PerfInitialize(
	);
void DAPI PerfClickTime(
	__in LARGE_INTEGER* pliElapsed
	);
double DAPI PerfConvertToSeconds(
	__in LARGE_INTEGER* pli
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\xmlutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="xmlutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    XML helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

// constant XML CLSIDs and IIDs
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument   = {0x2933BF90, 0x7B36, 0x11d2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument20  = {0xF6D90F11, 0x9C73, 0x11D3, {0xB3, 0x2E, 0x00, 0xC0, 0x4F, 0x99, 0x0B, 0xB4}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument26 = {0xf5078f1b, 0xc551, 0x11d3, {0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument30 = {0xf5078f32, 0xc551, 0x11d3, {0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument50 = {0x88d969e5, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_XMLSchemaCache = {0x88d969c2, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};

extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMDocument =  {0x2933BF81, 0x7B36, 0x11D2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMDocument2 = {0x2933BF95, 0x7B36, 0x11D2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMSchemaCollection = {0x373984C8, 0xB845, 0x449B, {0x91, 0xE7, 0x45, 0xAC, 0x83, 0x03, 0x6A, 0xDE}};

enum XML_LOAD_ATTRIBUTE
{
    XML_LOAD_PRESERVE_WHITESPACE = 1,
};


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI XmlInitialize();
void DAPI XmlUninitialize();

HRESULT DAPI XmlCreateElement(
    __in IXMLDOMDocument *pixdDocument,
    __in LPCWSTR wzElementName,
    __out IXMLDOMElement **ppixnElement
    );
HRESULT DAPI XmlCreateDocument(
    __in_opt LPCWSTR pwzElementName, 
    __out IXMLDOMDocument** ppixdDocument,
    __out_opt IXMLDOMElement** ppixeRootElement = NULL
    );
HRESULT DAPI XmlLoadDocument(
    __in LPCWSTR wzDocument,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentEx(
    __in LPCWSTR wzDocument,
    __in DWORD dwAttributes,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromFile(
    __in LPCWSTR wzPath,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromFileEx(
    __in LPCWSTR wzPath,
    __in DWORD dwAttributes,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlSelectSingleNode(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR wzXPath,
    __out IXMLDOMNode **ppixnChild
    );
HRESULT DAPI XmlSetAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __in LPCWSTR pwzAttributeValue
    );
HRESULT DAPI XmlCreateTextNode(
    __in IXMLDOMDocument *pixdDocument,
    __in LPCWSTR wzText,
    __out IXMLDOMText **ppixnTextNode
    );
HRESULT DAPI XmlGetText(
    __in IXMLDOMNode* pixnNode,
    __out BSTR* pbstrText
    );
HRESULT DAPI XmlGetAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out BSTR* pbstrAttributeValue
    );
HRESULT DAPI XmlGetAttributeNumber(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out DWORD* pdwValue
    );
HRESULT DAPI XmlGetNamedItem(
    __in IXMLDOMNamedNodeMap *pixnmAttributes, 
    __in_opt LPCWSTR wzName, 
    __out IXMLDOMNode **ppixnNamedItem
    );
HRESULT DAPI XmlSetText(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzText
    );
HRESULT DAPI XmlSetTextNumber(
    __in IXMLDOMNode *pixnNode,
    __in DWORD dwValue
    );
HRESULT DAPI XmlCreateChild(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR pwzElementType,
    __out IXMLDOMNode** ppixnChild
    );
HRESULT DAPI XmlRemoveAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute
    );
HRESULT DAPI XmlSelectNodes(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR wzXPath,
    __out IXMLDOMNodeList **ppixnChild
    );
HRESULT DAPI XmlNextElement(
    __in IXMLDOMNodeList* pixnl,
    __out IXMLDOMNode** pixnElement,
    __out BSTR* pbstrElement
    );
HRESULT DAPI XmlRemoveChildren(
    __in IXMLDOMNode* pixnSource,
    __in LPCWSTR pwzXPath
    );
HRESULT DAPI XmlSaveDocument(
    __in IXMLDOMDocument* pixdDocument, 
    __inout LPCWSTR wzPath
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\timeutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="timeutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//  Time helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI TimeFromString(
	__in LPCWSTR wzTime,
	__out FILETIME* pFileTime
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\2.0.5508.0\sdk\inc\wcautil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcautil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define WIXAPI __stdcall
#define ExitTrace WcaLogError
#define ExitTrace1 WcaLogError
#define ExitTrace2 WcaLogError
#define ExitTrace3 WcaLogError

#include "dutil.h"

#define MessageExitOnLastError(x, e, s)      { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace(x, "%s", s); WcaErrorMessage(e, x, MB_OK, 0);  goto LExit; } }
#define MessageExitOnLastError1(x, e, f, s)  { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace1(x, f, s); WcaErrorMessage(e, x, MB_OK, 1, s);  goto LExit; } }

#define MessageExitOnFailure(x, e, s)           if (FAILED(x)) { ExitTrace(x, "%s", s); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 0);  goto LExit; }
#define MessageExitOnFailure1(x, e, f, s)       if (FAILED(x)) { ExitTrace1(x, f, s); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 1, s);  goto LExit; }
#define MessageExitOnFailure2(x, e, f, s, t)    if (FAILED(x)) { ExitTrace2(x, f, s, t); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 2, s, t);  goto LExit; }
#define MessageExitOnFailure3(x, e, f, s, t, u) if (FAILED(x)) { ExitTrace2(x, f, s, t, u); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 3, s, t, u);  goto LExit; }

#define MessageExitOnNullWithLastError(p, x, e, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, "%s", s); WcaErrorMessage(e, x, MB_OK, 0);  goto LExit; }
#define MessageExitOnNullWithLastError1(p, x, e, f, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, f, s); WcaErrorMessage(e, x, MB_OK, 1, s);  goto LExit; }
#define MessageExitOnNullWithLastError2(p, x, e, f, s, t) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, f, s, t); WcaErrorMessage(e, x, MB_OK, 2, s, t);  goto LExit; }

#define MAX_DARWIN_KEY 73
#define MAX_DARWIN_COLUMN 255

// Generic action enum.
enum WCA_ACTION
{
    WCA_ACTION_NONE,
    WCA_ACTION_INSTALL,
    WCA_ACTION_UNINSTALL,
};

enum WCA_CASCRIPT
{
    WCA_CASCRIPT_SCHEDULED,
    WCA_CASCRIPT_ROLLBACK,
};

enum WCA_CASCRIPT_CLOSE
{
    WCA_CASCRIPT_CLOSE_PRESERVE,
    WCA_CASCRIPT_CLOSE_DELETE,
};

typedef struct WCA_CASCRIPT_STRUCT
{
    LPWSTR pwzScriptPath;
    HANDLE hScriptFile;
} *WCA_CASCRIPT_HANDLE;

void WIXAPI WcaGlobalInitialize(
    __in HINSTANCE hInst
    );
void WIXAPI WcaGlobalFinalize();

HRESULT WIXAPI WcaInitialize(
    __in MSIHANDLE hInstall,
    __in const char* szCustomActionLogName
    );
UINT WIXAPI WcaFinalize(
    __in UINT iReturnValue
    );
BOOL WIXAPI WcaIsInitialized();

MSIHANDLE WIXAPI WcaGetInstallHandle();
MSIHANDLE WIXAPI WcaGetDatabaseHandle();

const char* WIXAPI WcaGetLogName();

void WIXAPI WcaSetReturnValue(
    __in UINT iReturnValue
    );
BOOL WIXAPI WcaCancelDetected();

const int LOG_BUFFER = 2048;
enum LOGLEVEL
{ 
    LOGMSG_TRACEONLY,  // Never written to the log file (except in DEBUG builds)
    LOGMSG_VERBOSE,    // Written to log when LOGVERBOSE
    LOGMSG_STANDARD    // Written to log whenever informational logging is enabled
};

void __cdecl WcaLog(
    __in LOGLEVEL llv,
    __in const char* fmt, ...
    );
BOOL WIXAPI WcaDisplayAssert(
    __in LPCSTR sz
    );
void __cdecl WcaLogError(
    __in HRESULT hr,
    __in LPCSTR szMessage,
    ...
    );


UINT WIXAPI WcaProcessMessage(
    __in INSTALLMESSAGE eMessageType,
    __in MSIHANDLE hRecord
    );
UINT __cdecl WcaErrorMessage(
    __in int iError, 
    __in HRESULT hrError, 
    __in UINT uiType, 
    __in DWORD cArgs, 
    ...
    );
HRESULT WIXAPI WcaProgressMessage(
    __in UINT uiCost,
    __in BOOL fExtendProgressBar
    );

BOOL WIXAPI WcaIsInstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );
BOOL WIXAPI WcaIsReInstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );
BOOL WIXAPI WcaIsUninstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );

HRESULT WIXAPI WcaSetComponentState(
    __in LPCWSTR wzComponent,
    __in INSTALLSTATE isState
    );

HRESULT WIXAPI WcaTableExists(
    __in LPCWSTR wzTable
    );

HRESULT WIXAPI WcaOpenView(
    __in LPCWSTR wzSql,
    __out MSIHANDLE* phView
    );
HRESULT WIXAPI WcaExecuteView(
    __in MSIHANDLE hView,
    __in MSIHANDLE hRec
    );
HRESULT WIXAPI WcaOpenExecuteView(
    __in LPCWSTR wzSql,
    __out MSIHANDLE* phView
    );
HRESULT WIXAPI WcaFetchRecord(
    __in MSIHANDLE hView,
    __out MSIHANDLE* phRec
    );
HRESULT WIXAPI WcaFetchSingleRecord(
    __in MSIHANDLE hView,
    __out MSIHANDLE* phRec
    );

HRESULT WIXAPI WcaGetProperty(
    __in LPCWSTR wzProperty,
    __inout LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetFormattedProperty(
    __in LPCWSTR wzProperty,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetFormattedString(
    __in LPCWSTR wzString,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetIntProperty(
    __in LPCWSTR wzProperty,
    __inout int* piData
    );
HRESULT WIXAPI WcaGetTargetPath(
    __in LPCWSTR wzFolder,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaSetProperty(
    __in LPCWSTR wzPropertyName,
    __in LPCWSTR wzPropertyValue
    );
HRESULT WIXAPI WcaSetIntProperty(
    __in LPCWSTR wzPropertyName,
    __in int nPropertyValue
    );
BOOL WIXAPI WcaIsPropertySet(
    __in LPCSTR szProperty
    );

HRESULT WIXAPI WcaGetRecordInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout int* piData
    );
HRESULT WIXAPI WcaGetRecordString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetRecordFormattedString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout LPWSTR* ppwzData
    );

HRESULT WIXAPI WcaAllocStream(__inout BYTE** ppbData, __in DWORD cbData);
HRESULT WIXAPI WcaFreeStream(__in BYTE* pbData);

HRESULT WIXAPI WcaGetRecordStream(
    __in MSIHANDLE hRecBinary,
    __in UINT uiField, 
    __inout BYTE** ppbData,
    __inout DWORD* pcbData
    );
HRESULT WIXAPI WcaSetRecordString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __in LPCWSTR wzData
    );
HRESULT WIXAPI WcaSetRecordInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __in int iValue
    );

HRESULT WIXAPI WcaDoDeferredAction(
    __in LPCWSTR wzAction,
    __in LPCWSTR wzCustomActionData,
    __in UINT uiCost
    );
DWORD WIXAPI WcaCountOfCustomActionDataRecords(
    __in LPCWSTR wzData
    );
HRESULT WIXAPI WcaReadStringFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __inout LPWSTR* ppwzString
    );
HRESULT WIXAPI WcaReadIntegerFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __inout int* piResult
    );
HRESULT WIXAPI WcaReadStreamFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __out BYTE** ppbData,
    __out DWORD_PTR* pcbData
    );
HRESULT WIXAPI WcaWriteStringToCaData(
    __in LPCWSTR wzString,
    __inout LPWSTR* ppwzCustomActionData
    );
HRESULT WIXAPI WcaWriteIntegerToCaData(
    __in int i, 
    __inout LPWSTR* ppwzCustomActionData
    );
HRESULT WIXAPI WcaWriteStreamToCaData(
    __in_bcount(cbData) const BYTE* pbData,
    __in DWORD cbData,
    __inout LPWSTR* ppwzCustomActionData
    );

HRESULT __cdecl WcaAddTempRecord(
    __inout MSIHANDLE* phTableView,
    __inout MSIHANDLE* phColumns,
    __in LPCWSTR wzTable,
    __in UINT uiUniquifyColumn,
    __in UINT cColumns,
    ...
    );

HRESULT WIXAPI WcaDumpTable(
    __in LPCWSTR wzTable
    );


HRESULT WIXAPI WcaCaScriptCreateKey(
    __out LPWSTR* ppwzScriptKey
    );

HRESULT WIXAPI WcaCaScriptCreate(
    __in WCA_ACTION action,
    __in WCA_CASCRIPT script,
    __in BOOL fImpersonated,
    __in LPCWSTR wzScriptKey,
    __in BOOL fAppend,
    __out WCA_CASCRIPT_HANDLE* phScript
    );

HRESULT WIXAPI WcaCaScriptOpen(
    __in WCA_ACTION action,
    __in WCA_CASCRIPT script,
    __in BOOL fImpersonated,
    __in LPCWSTR wzScriptKey,
    __out WCA_CASCRIPT_HANDLE* phScript
    );

void WIXAPI WcaCaScriptClose(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in WCA_CASCRIPT_CLOSE closeOperation
    );

HRESULT WIXAPI WcaCaScriptReadAsCustomActionData(
    __in WCA_CASCRIPT_HANDLE hScript,
    __out LPWSTR* ppwzCustomActionData
    );

HRESULT WIXAPI WcaCaScriptWriteString(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in LPCWSTR wzValue
    );

HRESULT WIXAPI WcaCaScriptWriteNumber(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in DWORD dwValue
    );

void WIXAPI WcaCaScriptFlush(
    __in WCA_CASCRIPT_HANDLE hScript
    );

void WIXAPI WcaCaScriptCleanup(
    __in LPCWSTR wzProductCode,
    __in BOOL fImpersonated
    );


HRESULT QuietExec(
    __in LPWSTR wzCommand,
    __in DWORD dwTimeout
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\dirutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="dirutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Directory helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

BOOL DAPI DirExists(
    __in LPCWSTR wzPath, 
    __out_opt DWORD *pdwAttributes
    );

HRESULT DAPI DirCreateTempPath(
    __in LPCWSTR wzPrefix,
    __in LPWSTR wzPath,
    __in DWORD cchPath
    );

HRESULT DAPI DirEnsureExists(
    __in LPCWSTR wzPath, 
    __in_opt LPSECURITY_ATTRIBUTES psa
    );

HRESULT DAPI DirEnsureDelete(
    __in LPCWSTR wzPath,
    __in BOOL fDeleteFiles,
    __in BOOL fRecurse
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\cabcutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="cabcutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for cabinet creation helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <fci.h>
#include <fcntl.h>

#define CAB_MAX_SIZE 0x7FFFFFFF   // (see KB: Q174866)

#ifdef __cplusplus
extern "C" {
#endif

// time vs. space trade-off
enum COMPRESSION_TYPE 
{ 
	COMPRESSION_TYPE_NONE, // fastest
	COMPRESSION_TYPE_LOW, 
	COMPRESSION_TYPE_MEDIUM,
	COMPRESSION_TYPE_HIGH, // smallest
	COMPRESSION_TYPE_MSZIP
};

// functions
HRESULT DAPI CabCBegin(
	__in LPCWSTR wzCab,
	__in LPCWSTR wzCabDir,
	__in DWORD dwMaxSize,
	__in DWORD dwMaxThresh,
	__in COMPRESSION_TYPE ct,
	__out HANDLE *phContext
	);
HRESULT DAPI CabCNextCab(
	__in HANDLE hContext
	);
HRESULT DAPI CabCAddFile(
	__in LPCWSTR wzFile,
	__in_opt LPCWSTR wzToken,
	__in HANDLE hContext
	);
HRESULT DAPI CabCFinish(
	__in HANDLE hContext
	);
void DAPI CabCCancel(
    __in HANDLE hContext
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\cabutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="cabutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for cabinet decompression helper functions
// </summary>
//-------------------------------------------------------------------------------------------------

#include <fdi.h>
#include <sys\stat.h>

#ifdef __cplusplus
extern "C" {
#endif

// structs


// callback function prototypes
typedef HRESULT (*CAB_CALLBACK_OPEN_FILE)(LPCWSTR wzFile, INT_PTR* ppFile);
typedef HRESULT (*CAB_CALLBACK_READ_FILE)(INT_PTR pFile, LPVOID pvData, DWORD cbData, DWORD* pcbRead);
typedef HRESULT (*CAB_CALLBACK_WRITE_FILE)(INT_PTR pFile, LPVOID pvData, DWORD cbData, DWORD* pcbRead);
typedef LONG (*CAB_CALLBACK_SEEK_FILE)(INT_PTR pFile, DWORD dwMove, DWORD dwMoveMethod);
typedef HRESULT (*CAB_CALLBACK_CLOSE_FILE)(INT_PTR pFile);

typedef HRESULT (*CAB_CALLBACK_BEGIN_FILE)(LPCWSTR wzFileId, FILETIME* pftFileTime, DWORD cbFileSize, LPVOID pvContext, INT_PTR* ppFile);
typedef HRESULT (*CAB_CALLBACK_END_FILE)(LPCWSTR wzFileId, LPVOID pvContext, INT_PTR pFile);
typedef HRESULT (*CAB_CALLBACK_PROGRESS)(BOOL fBeginFile, LPCWSTR wzFileId, LPVOID pvContext);

// function type with calling convention of __stdcall that .NET 1.1 understands only
// .NET 2.0 will not need this
typedef INT_PTR (FAR __stdcall *STDCALL_PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);


// functions
HRESULT DAPI CabInitialize(
    __in BOOL fDelayLoad
    );
void DAPI CabUninitialize(
    );

HRESULT DAPI CabExtract(
    __in LPCWSTR wzCabinet,
    __in LPCWSTR wzExtractFile,
    __in LPCWSTR wzExtractDir,
    __in_opt CAB_CALLBACK_PROGRESS pfnProgress,
    __in_opt LPVOID pvContext
    );

HRESULT DAPI CabEnumerate(
    __in LPCWSTR wzCabinet,
    __in LPCWSTR wzEnumerateFile,
    __in STDCALL_PFNFDINOTIFY pfnNotify
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\aclutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="aclutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Access Control List helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <aclapi.h>
#include <sddl.h>

#define ReleaseSid(x) if (x) { AclFreeSid(x); }
#define ReleaseNullSid(x) if (x) { AclFreeSid(x); x = NULL; }

#ifdef __cplusplus
extern "C" {
#endif

// structs
struct ACL_ACCESS
{
	BOOL fDenyAccess;
	DWORD dwAccessMask;

	// TODO: consider using a union
	LPCWSTR pwzAccountName;   // NOTE: the last three items in this structure are ignored if this is not NULL

	SID_IDENTIFIER_AUTHORITY sia;  // used if pwzAccountName is NULL
	BYTE nSubAuthorityCount;
	DWORD nSubAuthority[8];
};

struct ACL_ACE
{
	DWORD dwFlags;
	DWORD dwMask;
	PSID psid;
};


// functions
HRESULT DAPI AclCheckAccess(
	__in HANDLE hToken, 
	ACL_ACCESS* paa
	);
HRESULT DAPI AclCheckAdministratorAccess(
	__in HANDLE hToken
	);
HRESULT DAPI AclCheckLocalSystemAccess(
	__in HANDLE hToken
	);

HRESULT DAPI AclGetWellKnownSid(
	__in WELL_KNOWN_SID_TYPE wkst,
	__out PSID* ppsid
	);
HRESULT DAPI AclGetAccountSid(
	__in_opt LPCWSTR wzSystem,
	__in LPCWSTR wzAccount,
	__out PSID* ppsid
	);
HRESULT DAPI AclGetAccountSidString(
	__in LPCWSTR wzSystem,
	__in LPCWSTR wzAccount,
	__out LPWSTR* ppwzSid
	);

HRESULT DAPI AclCreateDacl(
	__in_ecount(cDeny) ACL_ACE rgaaDeny[],
	__in DWORD cDeny,
	__in_ecount(cAllow) ACL_ACE rgaaAllow[],
	__in DWORD cAllow,
	__out ACL** ppAcl
	);
HRESULT DAPI AclAddToDacl(
	__in ACL* pAcl,
	__in_ecount_opt(cDeny) const ACL_ACE rgaaDeny[],
	__in DWORD cDeny,
	__in_ecount_opt(cAllow) const ACL_ACE rgaaAllow[],
	__in DWORD cAllow,
	__out ACL** ppAclNew
	);
HRESULT DAPI AclMergeDacls(
	__in const ACL* pAcl1,
	__in const ACL* pAcl2,
	__out ACL** ppAclNew
	);
HRESULT DAPI AclCreateDaclOld(
	__in_ecount(cAclAccesses) ACL_ACCESS* paa,
	__in DWORD cAclAccesses,
	__out ACL** ppAcl
	);
HRESULT DAPI AclCreateSecurityDescriptor(
	__in_ecount(cAclAccesses) ACL_ACCESS* paa,
	__in DWORD cAclAccesses,
	__out SECURITY_DESCRIPTOR** ppsd
	);
HRESULT DAPI AclCreateSecurityDescriptorFromDacl(
	__in ACL* pACL,
	__out SECURITY_DESCRIPTOR** ppsd
	);
HRESULT __cdecl AclCreateSecurityDescriptorFromString(
	__out SECURITY_DESCRIPTOR** ppsd,
	__in LPCWSTR wzSddlFormat,
	...
	);
HRESULT DAPI AclDuplicateSecurityDescriptor(
	__in SECURITY_DESCRIPTOR* psd,
	__out SECURITY_DESCRIPTOR** ppsd
	);
HRESULT DAPI AclGetSecurityDescriptor(
	__in LPCWSTR wzObject,
	__in SE_OBJECT_TYPE sot,
	__out SECURITY_DESCRIPTOR** ppsd
	);

HRESULT DAPI AclFreeSid(
	__in PSID psid
	);
HRESULT DAPI AclFreeDacl(
	__in ACL* pACL
	);
HRESULT DAPI AclFreeSecurityDescriptor(
	__in SECURITY_DESCRIPTOR* psd
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\memutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="memutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for memory helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseMem(p) if (p) { MemFree(p); }
#define ReleaseNullMem(p) if (p) { MemFree(p); p = NULL; }


HRESULT DAPI MemInitialize();
void DAPI MemUninitialize();

LPVOID DAPI MemAlloc(
    __in SIZE_T cbSize,
    __in BOOL fZero
    );
LPVOID DAPI MemReAlloc(
    __in LPVOID pv,
    __in SIZE_T cbSize,
    __in BOOL fZero
    );

HRESULT DAPI MemFree(
    __in LPVOID pv
    );
SIZE_T DAPI MemSize(
    __in LPVOID pv
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\metautil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="metautil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    IIS Metabase helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <iadmw.h>
#include <iiscnfg.h>
#include <iwamreg.h>
#include <mddefw.h>

#ifdef __cplusplus
extern "C" {
#endif

// structs

// prototypes
HRESULT DAPI MetaFindWebBase(
	__in IMSAdminBaseW* piMetabase, 
	__in LPCWSTR wzIP, 
	__in int iPort, 
	__in LPCWSTR wzHeader,
	__in BOOL fSecure,
	__out_ecount(cchWebBase) LPWSTR wzWebBase, 
	__in DWORD cchWebBase
	);
HRESULT DAPI MetaFindFreeWebBase(
	__in IMSAdminBaseW* piMetabase, 
	__out_ecount(cchWebBase) LPWSTR wzWebBase, 
	__in DWORD cchWebBase
	);

HRESULT DAPI MetaOpenKey(
	__in IMSAdminBaseW* piMetabase, 
	__in METADATA_HANDLE mhKey, 
	__in LPCWSTR wzKey,
	__in DWORD dwAccess,
	__in DWORD cRetries,
	__out METADATA_HANDLE* pmh
	);
HRESULT DAPI MetaGetValue(
	__in IMSAdminBaseW* piMetabase, 
	__in METADATA_HANDLE mhKey, 
	__in LPCWSTR wzKey, 
	__inout METADATA_RECORD* pmr
	);
void DAPI MetaFreeValue(
	__in METADATA_RECORD* pmr
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\conutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="conutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Console helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ConsoleExitOnFailure(x, c, f) if (FAILED(x)) { ConsoleWriteError(x, c, f); ExitTrace(x, f); goto LExit; }
#define ConsoleExitOnFailure1(x, c, f, s) if (FAILED(x)) { ConsoleWriteError(x, c, f, s, NULL); ExitTrace1(x, f, s); goto LExit; }
#define ConsoleExitOnFailure2(x, c, f, s, t) if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t); ExitTrace2(x, f, s, t); goto LExit; }
#define ConsoleExitOnFailure3(x, c, f, s, t, u) if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t, u); ExitTrace3(x, f, s, t, u); goto LExit; }

#define ConsoleExitOnLastError(x, c, f) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f); ExitTrace(x, f); goto LExit; } }
#define ConsoleExitOnLastError1(x, c, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f, s, NULL); ExitTrace1(x, f, s); goto LExit; } }
#define ConsoleExitOnLastError2(x, c, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t); ExitTrace2(x, f, s, t); goto LExit; } }
#define ConsoleExitOnLastError3(x, c, f, s, t, u) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t, u); ExitTrace3(x, f, s, t, u); goto LExit; } }

#define ConsoleExitOnNull(p, x, e, c, f) if (NULL == p) { x = e; ConsoleWriteError(x, c, f); ExitTrace(x, f); goto LExit; }
#define ConsoleExitOnNull1(p, x, e, c, f, s) if (NULL == p) { x = e; ConsoleWriteError(x, c, f, s, NULL); ExitTrace1(x, f, s); goto LExit; }
#define ConsoleExitOnNull2(p, x, e, c, f, s, t) if (NULL == p) { x = e; ConsoleWriteError(x, c, f, s, t); ExitTrace2(x, f, s, t); goto LExit; }
#define ConsoleExitOnNull3(p, x, e, c, f, s, t, u) if (NULL == p) { x = e; ConsoleWriteError(x, c, f, s, t, u); ExitTrace2(x, f, s, t, u); goto LExit; }


// the following macros need to go away
#define ConsoleTrace(l, f) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f); Trace(l, f); }
#define ConsoleTrace1(l, f, s) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f, s); Trace1(l, f, s); }
#define ConsoleTrace2(l, f, s, t) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f, s, t); Trace2(l, f, s, t); }
#define ConsoleTrace3(l, f, s, t, u) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f, s, t, u); Trace3(l, f, s, t, u); }

#define ConsoleWarning(f) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f); Trace(REPORT_STANDARD, f); }
#define ConsoleWarning1(f, s) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f, s); Trace1(REPORT_STANDARD, f, s); }
#define ConsoleWarning2(f, s, t) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f, s, t); Trace2(REPORT_STANDARD, f, s, t); }
#define ConsoleWarning3(f, s, t, u) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f, s, t, u); Trace3(REPORT_STANDARD, f, s, t, u); }

#define ConsoleError(x, f) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f); TraceError(x, f); }
#define ConsoleError1(x, f, s) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f, s); TraceError1(x, f, s); }
#define ConsoleError2(x, f, s, t) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f, s, t); TraceError2(x, f, s, t); }
#define ConsoleError3(x, f, s, t, u) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f, s, t, u); TraceError3(x, f, s, t, u); }


// enums
enum CONSOLE_COLOR { CONSOLE_COLOR_NORMAL, CONSOLE_COLOR_RED, CONSOLE_COLOR_YELLOW, CONSOLE_COLOR_GREEN };

// structs

// functions
HRESULT DAPI ConsoleInitialize();
void DAPI ConsoleUninitialize();

void DAPI ConsoleGreen();
void DAPI ConsoleRed();
void DAPI ConsoleYellow();
void DAPI ConsoleNormal();

HRESULT DAPI ConsoleWrite(
    CONSOLE_COLOR cc,
    __in_z __format_string LPCSTR szFormat,
    ...
    );
HRESULT DAPI ConsoleWriteLine(
    CONSOLE_COLOR cc,
    __in_z __format_string LPCSTR szFormat,
    ...
    );
HRESULT DAPI ConsoleWriteError(
    HRESULT hrError,
    CONSOLE_COLOR cc,
    __in_z __format_string LPCSTR szFormat,
    ...
    );

HRESULT DAPI ConsoleReadW(
    __deref_out_z LPWSTR* ppwzBuffer
    );

HRESULT DAPI ConsoleReadStringA(
    __deref_out_ecount_part(cchCharBuffer,*pcchNumCharReturn) LPSTR* szCharBuffer,
    CONST DWORD cchCharBuffer,
    __out DWORD* pcchNumCharReturn
    );
HRESULT DAPI ConsoleReadStringW(
    __deref_out_ecount_part(cchCharBuffer,*pcchNumCharReturn) LPWSTR* szCharBuffer,
    CONST DWORD cchCharBuffer,
    __out DWORD* pcchNumCharReturn
    );

HRESULT DAPI ConsoleReadNonBlockingW(
    __deref_out_ecount_opt(*pcchSize) LPWSTR* ppwzBuffer,
    __out DWORD* pcchSize,
    BOOL fReadLine
    );

HRESULT ConsoleSetReadHidden(void);
HRESULT ConsoleSetReadNormal(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\fileutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="fileutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for file helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <wchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseFile(h) if (INVALID_HANDLE_VALUE != h) { ::CloseHandle(h); h = INVALID_HANDLE_VALUE; }

LPWSTR DAPI FileFromPath(
    __in LPCWSTR wzPath
    );
HRESULT DAPI FileResolvePath(
    __in LPCWSTR wzRelativePath,
    __out LPWSTR *ppwzFullPath
    );
HRESULT DAPI FileStripExtension(
    __in LPCWSTR wzFileName,
    __out LPWSTR *ppwzFileNameNoExtension
    );
HRESULT DAPI FileVersionFromString(
    __in LPCWSTR wzVersion, 
    __out DWORD *pdwVerMajor, 
    __out DWORD* pdwVerMinor
    );
HRESULT DAPI FileSizeByHandle(
    __in HANDLE hFile, 
    __out LONGLONG* pllSize
    );
BOOL DAPI FileExistsEx(
    __in LPCWSTR wzPath, 
    __out_opt DWORD *pdwAttributes
    );
HRESULT DAPI FileRead(
    __deref_out_bcount_full(*pcbDest) LPBYTE* ppbDest,
    __out DWORD* pcbDest,
    __in LPCWSTR wzSrcPath
    );
HRESULT DAPI FileReadUntil(
    __deref_out_bcount_full(*pcbDest) LPBYTE* ppbDest,
    __out_range(<=, cbMaxRead) DWORD* pcbDest,
    __in LPCWSTR wzSrcPath,
    __in DWORD cbMaxRead
    );
HRESULT DAPI FileReadPartial(
    __deref_out_bcount_full(*pcbDest) LPBYTE* ppbDest,
    __out_range(<=, cbMaxRead) DWORD* pcbDest,
    __in LPCWSTR wzSrcPath,
    __in BOOL fSeek,
    __in DWORD cbStartPosition,
    __in DWORD cbMaxRead,
    __in BOOL fPartialOK
    );
HRESULT DAPI FileWrite(
    __in_bcount(cbData) LPCBYTE pbData,
    __in DWORD cbData,
    __in LPCWSTR pwzFileName,
    __in DWORD dwFlagsAndAttributes,
    __out_opt HANDLE* pHandle
    );
HRESULT DAPI FileEnsureCopy(
    __in LPCWSTR wzSource,
    __in LPCWSTR wzTarget,
    __in BOOL fOverwrite
    );
HRESULT DAPI FileEnsureMove(
    __in LPCWSTR wzSource, 
    __in LPCWSTR wzTarget, 
    __in BOOL fOverwrite,
    __in BOOL fAllowCopy
    );
HRESULT DAPI FileCreateTemp(
    __in LPCWSTR wzPrefix,
    __in LPCWSTR wzExtension,
    __deref_opt_out_z LPWSTR* ppwzTempFile,
    __out_opt HANDLE* phTempFile
    );
HRESULT DAPI FileCreateTempW(
    __in LPCWSTR wzPrefix,
    __in LPCWSTR wzExtension,
    __deref_opt_out_z LPWSTR* ppwzTempFile,
    __out_opt HANDLE* phTempFile
    );
HRESULT DAPI FileVersion(
    __in LPCWSTR wzFilename, 
    __out DWORD *pdwVerMajor, 
    __out DWORD* pdwVerMinor
    );
HRESULT DAPI FileIsSame(
    __in LPCWSTR wzFile1,
    __in LPCWSTR wzFile2,
    __out LPBOOL lpfSameFile
    );
HRESULT DAPI FileEnsureDelete(
    __in LPCWSTR wzFile
    );
HRESULT DAPI FileGetTime(
    __in LPCWSTR wzFile,  
    __out_opt  LPFILETIME lpCreationTime,
    __out_opt  LPFILETIME lpLastAccessTime,
    __out_opt  LPFILETIME lpLastWriteTime
    );
HRESULT DAPI FileSetTime(
    __in LPCWSTR wzFile,  
    __in_opt  const FILETIME *lpCreationTime,
    __in_opt  const FILETIME *lpLastAccessTime,
    __in_opt  const FILETIME *lpLastWriteTime
    );
HRESULT DAPI FileResetTime(
    __in LPCWSTR wzFile
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\inetutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="inetutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Internet utilites.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif


// functions
HRESULT DAPI InternetGetSizeByHandle(
	__in HINTERNET hiFile,
	__out LONGLONG* pllSize
	);
HRESULT DAPI InternetGetCreateTimeByHandle(
	__in HINTERNET hiFile,
	__out LPFILETIME pft
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\logutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="logutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for string helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define LogExitOnFailure(x, i, f) if (FAILED(x)) { LogErrorId(x, i, NULL, NULL, NULL); ExitTrace(x, f); goto LExit; }
#define LogExitOnFailure1(x, i, f, s) if (FAILED(x)) { LogErrorId(x, i, s, NULL, NULL); ExitTrace1(x, f, s); goto LExit; }
#define LogExitOnFailure2(x, i, f, s, t) if (FAILED(x)) { LogErrorId(x, i, s, t, NULL); ExitTrace2(x, f, s, t); goto LExit; }
#define LogExitOnFailure3(x, i, f, s, t, u) if (FAILED(x)) { LogErrorId(x, i, s, t, u); ExitTrace3(x, f, s, t, u); goto LExit; }

// enums

// structs

// functions
HRESULT DAPI LogInitialize(
    IN HMODULE hModule,
    IN LPCWSTR wzLog,
    IN LPCWSTR wzExt,
    IN BOOL fAppend,
    IN BOOL fHeader
    );

void DAPI LogUninitialize(
    IN BOOL fFooter
    );

BOOL DAPI LogIsOpen();

REPORT_LEVEL DAPI LogSetLevel(
    IN REPORT_LEVEL rl,
    IN BOOL fLogChange
    );

REPORT_LEVEL DAPI LogGetLevel();

HRESULT DAPI LogGetPath(
    __out_ecount(cchLogPath) LPWSTR pwzLogPath, 
    __in DWORD cchLogPath
    );

HANDLE DAPI LogGetHandle();

HRESULT DAPIV LogString(
    IN REPORT_LEVEL rl,
    IN LPCSTR szFormat,
    ...
    );

HRESULT DAPI LogStringArgs(
    IN REPORT_LEVEL rl,
    IN LPCSTR szFormat,
    IN va_list args
    );

HRESULT DAPIV LogStringLine(
    IN REPORT_LEVEL rl,
    IN LPCSTR szFormat,
    ...
    );

HRESULT DAPI LogStringLineArgs(
    IN REPORT_LEVEL rl,
    IN LPCSTR szFormat,
    IN va_list args
    );

HRESULT DAPI LogIdModuleArgs(
    IN REPORT_LEVEL rl,
    IN DWORD dwLogId,
    IN HMODULE hModule,
    va_list args
    );

/* 
 * Wraps LogIdModuleArgs, so inline to save the function call
 */

inline HRESULT LogId(
    IN REPORT_LEVEL rl,
    IN DWORD dwLogId,
    ...
    )
{
    HRESULT hr = S_OK;
    va_list args;
    
    va_start(args, dwLogId);
    hr = LogIdModuleArgs(rl, dwLogId, NULL, args);
    va_end(args);
    
    return hr;
}


/* 
 * Wraps LogIdModuleArgs, so inline to save the function call
 */
 
inline HRESULT LogIdArgs(
    IN REPORT_LEVEL rl,
    IN DWORD dwLogId,
    va_list args
    )
{
    return LogIdModuleArgs(rl, dwLogId, NULL, args);
}

HRESULT DAPIV LogErrorString(
    IN HRESULT hrError,
    IN LPCSTR szFormat,
    ...
    );

HRESULT DAPI LogErrorStringArgs(
    IN HRESULT hrError,
    IN LPCSTR szFormat,
    IN va_list args
    );

HRESULT DAPI LogErrorIdModule(
    IN HRESULT hrError,
    IN DWORD dwLogId,
    IN HMODULE hModule,
    IN LPCWSTR wzString1,
    IN LPCWSTR wzString2,
    IN LPCWSTR wzString3
    );

inline HRESULT LogErrorId(
    IN HRESULT hrError,
    IN DWORD dwLogId,
    IN LPCWSTR wzString1,
    IN LPCWSTR wzString2,
    IN LPCWSTR wzString3
    )
{
    return LogErrorIdModule(hrError, dwLogId, NULL, wzString1, wzString2, wzString3);
}

HRESULT DAPI LogHeader();

HRESULT DAPI LogFooter();

// begin the switch of LogXXX to LogStringXXX
#define Log LogString
#define LogLine LogStringLine

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\dutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="dutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for utility layer that provides standard support for asserts, exit macros
// </summary>
//-------------------------------------------------------------------------------------------------

#define DAPI __stdcall
#define DAPIV __cdecl // used only for functions taking variable length arguments

#define DAPI_(type) EXTERN_C type DAPI
#define DAPIV_(type) EXTERN_C type DAPIV


// enums
enum REPORT_LEVEL
{
    REPORT_NONE,      // turns off report (only valid for XXXSetLevel())
    REPORT_STANDARD,  // written if reporting is on
    REPORT_VERBOSE,   // written only if verbose reporting is on
    REPORT_DEBUG,     // reporting useful when debugging code
    REPORT_ERROR,     // always gets reported, but can never be specified
};

// asserts and traces
#ifdef DEBUG

typedef BOOL (DAPI *DUTIL_ASSERTDISPLAYFUNCTION)(LPCSTR sz);

extern "C" void DAPI Dutil_SetAssertModule(__in HMODULE hAssertModule);
extern "C" void DAPI Dutil_SetAssertDisplayFunction(__in DUTIL_ASSERTDISPLAYFUNCTION pfn);
extern "C" void DAPI Dutil_Assert(const CHAR* szFile, int iLine);
extern "C" void DAPI Dutil_AssertSz(const CHAR* szFile, int iLine, const CHAR *szMsg);

extern "C" void DAPI Dutil_TraceSetLevel(__in REPORT_LEVEL ll, __in BOOL fTraceFilenames);
extern "C" REPORT_LEVEL DAPI Dutil_TraceGetLevel();
extern "C" void __cdecl Dutil_Trace(__in LPCSTR szFile, __in int iLine, __in REPORT_LEVEL rl, __in LPCSTR szMessage, ...);
extern "C" void __cdecl Dutil_TraceError(__in LPCSTR szFile, __in int iLine, __in REPORT_LEVEL rl, __in HRESULT hr, __in LPCSTR szMessage, ...);

#endif

extern "C" void DAPI Dutil_RootFailure(__in LPCSTR szFile, __in int iLine, __in HRESULT hrError);

#ifdef DEBUG

#define AssertSetModule(m) (void)Dutil_SetAssertModule(m)
#define AssertSetDisplayFunction(pfn) (void)Dutil_SetAssertDisplayFunction(pfn)
#define Assert(f)          ((f)    ? (void)0 : (void)Dutil_Assert(__FILE__, __LINE__))
#define AssertSz(f, sz)    ((f)    ? (void)0 : (void)Dutil_AssertSz(__FILE__, __LINE__, sz))

#define TraceSetLevel(l, f) (void)Dutil_TraceSetLevel(l, f)
#define TraceGetLevel() (REPORT_LEVEL)Dutil_TraceGetLevel()
#define Trace(l, f) (void)Dutil_Trace(__FILE__, __LINE__, l, f, NULL)
#define Trace1(l, f, s) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s)
#define Trace2(l, f, s, t) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s, t)
#define Trace3(l, f, s, t, u) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s, t, u)

#define TraceError(x, f) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, NULL)
#define TraceError1(x, f, s) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s)
#define TraceError2(x, f, s, t) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s, t)
#define TraceError3(x, f, s, t, u) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s, t, u)

#define TraceErrorDebug(x, f) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, NULL)
#define TraceErrorDebug1(x, f, s) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s)
#define TraceErrorDebug2(x, f, s, t) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s, t)
#define TraceErrorDebug3(x, f, s, t, u) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s, t, u)

#else // !DEBUG

#define AssertSetModule(m)
#define AssertSetDisplayFunction(pfn)
#define Assert(f)
#define AssertSz(f, sz)

#define TraceSetLevel(l, f)
#define Trace(l, f)
#define Trace1(l, f, s)
#define Trace2(l, f, s, t)
#define Trace3(l, f, s, t, u)

#define TraceError(x, f)
#define TraceError1(x, f, s)
#define TraceError2(x, f, s, t)
#define TraceError3(x, f, s, t, u)

#define TraceErrorDebug(x, f)
#define TraceErrorDebug1(x, f, s)
#define TraceErrorDebug2(x, f, s, t)
#define TraceErrorDebug3(x, f, s, t, u)

#endif // DEBUG


// ExitTrace can be overriden
#ifndef ExitTrace
#define ExitTrace TraceError
#endif
#ifndef ExitTrace1
#define ExitTrace1 TraceError1
#endif
#ifndef ExitTrace2
#define ExitTrace2 TraceError2
#endif
#ifndef ExitTrace3
#define ExitTrace3 TraceError3
#endif

// Exit macros
#define ExitFunction()        { goto LExit; }
#define ExitFunction1(x)          { x; goto LExit; }

#define ExitOnLastError(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; } }
#define ExitOnLastError1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; } }
#define ExitOnLastError2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t); goto LExit; } }

#define ExitOnLastErrorDebugTrace(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug(x, s); goto LExit; } }
#define ExitOnLastErrorDebugTrace1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug1(x, f, s); goto LExit; } }
#define ExitOnLastErrorDebugTrace2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug2(x, f, s, t); goto LExit; } }

#define ExitWithLastError(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitWithLastError1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }
#define ExitWithLastError2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t); goto LExit; }
#define ExitWithLastError3(x, f, s, t, u) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace3(x, f, s, t, u); goto LExit; }

#define ExitOnFailure(x, s)   if (FAILED(x)) { ExitTrace(x, s);  goto LExit; }
#define ExitOnFailure1(x, f, s)   if (FAILED(x)) { ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnFailure2(x, f, s, t)   if (FAILED(x)) { ExitTrace2(x, f, s, t);  goto LExit; }
#define ExitOnFailure3(x, f, s, t, u) if (FAILED(x)) { ExitTrace3(x, f, s, t, u);  goto LExit; }

#define ExitOnRootFailure(x, s)   if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s);  goto LExit; }
#define ExitOnRootFailure1(x, f, s)   if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnRootFailure2(x, f, s, t)   if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t);  goto LExit; }
#define ExitOnRootFailure3(x, f, s, t, u) if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace3(x, f, s, t, u);  goto LExit; }

#define ExitOnFailureDebugTrace(x, s)   if (FAILED(x)) { TraceErrorDebug(x, s);  goto LExit; }
#define ExitOnFailureDebugTrace1(x, f, s)   if (FAILED(x)) { TraceErrorDebug1(x, f, s);  goto LExit; }
#define ExitOnFailureDebugTrace2(x, f, s, t)   if (FAILED(x)) { TraceErrorDebug2(x, f, s, t);  goto LExit; }
#define ExitOnFailureDebugTrace3(x, f, s, t, u) if (FAILED(x)) { TraceErrorDebug3(x, f, s, t, u);  goto LExit; }

#define ExitOnNull(p, x, e, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s);  goto LExit; }
#define ExitOnNull1(p, x, e, f, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnNull2(p, x, e, f, s, t)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t);  goto LExit; }

#define ExitOnNullWithLastError(p, x, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitOnNullWithLastError1(p, x, f, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }

#define ExitOnNullDebugTrace(p, x, e, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug(x, s);  goto LExit; }
#define ExitOnNullDebugTrace1(p, x, e, f, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug1(x, f, s);  goto LExit; }

#define ExitOnInvalidHandleWithLastError(p, x, s) if (INVALID_HANDLE_VALUE == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitOnInvalidHandleWithLastError1(p, x, f, s) if (INVALID_HANDLE_VALUE == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }

// release macros
#define ReleaseObject(x) if (x) { x->Release(); }
#define ReleaseObjectArray(prg, cel) if (prg) { for (DWORD Dutil_ReleaseObjectArrayIndex = 0; Dutil_ReleaseObjectArrayIndex < cel; ++Dutil_ReleaseObjectArrayIndex) { ReleaseObject(prg[Dutil_ReleaseObjectArrayIndex]); } ReleaseMem(prg); }
#define ReleaseVariant(x) { ::VariantClear(&x); }
#define ReleaseNullObject(x) if (x) { (x)->Release(); x = NULL; }
#define ReleaseCertificate(x) if (x) { ::CertFreeCertificateContext(x); x=NULL; }


// useful defines and macros
#define Unused(x) ((void)x)

#ifndef countof
#if 1
#define countof(ary) (sizeof(ary) / sizeof(ary[0]))
#else
#ifndef __cplusplus
#define countof(ary) (sizeof(ary) / sizeof(ary[0]))
#else
template<typename T> static char countofVerify(void const *, T) throw() { return 0; }
template<typename T> static void countofVerify(T *const, T *const *) throw() {};
#define countof(arr) (sizeof(countofVerify(arr,&(arr))) * sizeof(arr)/sizeof(*(arr)))
#endif
#endif
#endif

#define roundup(x, n) roundup_typed(x, n, DWORD)
#define roundup_typed(x, n, t) (((t)(x) + ((t)(n) - 1)) & ~((t)(n) - 1))

#ifndef MAXSIZE_T
#define MAXSIZE_T ((SIZE_T)~((SIZE_T)0))
#endif

#define E_NOMOREITEMS HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
#define AddRefAndRelease(x) { x->AddRef(); x->Release(); }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\rssutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="rssutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    RSS helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseRssChannel(p) if (p) { RssFreeChannel(p); }
#define ReleaseNullRssChannel(p) if (p) { RssFreeChannel(p); p = NULL; }


struct RSS_UNKNOWN_ATTRIBUTE
{
    LPWSTR wzNamespace;
    LPWSTR wzAttribute;
    LPWSTR wzValue;

    RSS_UNKNOWN_ATTRIBUTE* pNext;
};

struct RSS_UNKNOWN_ELEMENT
{
    LPWSTR wzNamespace;
    LPWSTR wzElement;
    LPWSTR wzValue;

    RSS_UNKNOWN_ATTRIBUTE* pAttributes;
    RSS_UNKNOWN_ELEMENT* pNext;
};

struct RSS_ITEM
{
    LPWSTR wzTitle;
    LPWSTR wzLink;
    LPWSTR wzDescription;

    LPWSTR wzGuid;
    FILETIME ftPublished;

    LPWSTR wzEnclosureUrl;
    DWORD dwEnclosureSize;
    LPWSTR wzEnclosureType;

    RSS_UNKNOWN_ELEMENT* pUnknownElements;
};

struct RSS_CHANNEL
{
    LPWSTR wzTitle;
    LPWSTR wzLink;
    LPWSTR wzDescription;
    DWORD dwTimeToLive;

    RSS_UNKNOWN_ELEMENT* pUnknownElements;

    DWORD cItems;
    RSS_ITEM rgItems[1];
};

HRESULT DAPI RssInitialize(
    );

void DAPI RssUninitialize(
    );

HRESULT DAPI RssParseFromString(
    __in LPCWSTR wzRssString,
    __out RSS_CHANNEL **ppChannel
    );

HRESULT DAPI RssParseFromFile(
    __in LPCWSTR wzRssFile,
    __out RSS_CHANNEL **ppChannel
    );

// Adding this until we have the updated specstrings.h
#ifndef __in_xcount
#define __in_xcount(size) 
#endif

void DAPI RssFreeChannel(
    __in_xcount(pChannel->cItems) RSS_CHANNEL *pChannel
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\timeutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="timeutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//  Time helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI TimeFromString(
	__in LPCWSTR wzTime,
	__out FILETIME* pFileTime
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\procutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="procutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for proces helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ProcExecute(
    __in LPWSTR wzCommand,
    __out HANDLE *phProcess,
    __out_opt HANDLE *phChildStdIn,
    __out_opt HANDLE *phChildStdOutErr
    );
HRESULT DAPI ProcWaitForCompletion(
    __in HANDLE hProcess,
    __in DWORD dwTimeout,
    __out DWORD *pReturnCode
    );
HRESULT DAPI ProcWaitForIds(
    __in_ecount(cProcessIds) const DWORD* pdwProcessIds,
    __in DWORD cProcessIds,
    __in DWORD dwMilliseconds
    );
HRESULT DAPI ProcCloseIds(
    __in_ecount(cProcessIds) const DWORD* pdwProcessIds,
    __in DWORD cProcessIds
    );

// following code in proc2utl.cpp due to dependency on PSAPI.DLL.
HRESULT DAPI ProcFindAllIdsFromExeName(
    __in LPCWSTR wzExeName,
    __out DWORD** ppdwProcessIds,
    __out DWORD* pcProcessIds
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\perfutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="perfutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Performance helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

// structs


// functions
void DAPI PerfInitialize(
	);
void DAPI PerfClickTime(
	__out_opt LARGE_INTEGER* pliElapsed
	);
double DAPI PerfConvertToSeconds(
	__in const LARGE_INTEGER* pli
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\pathutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="pathutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for path helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

enum PATH_EXPAND
{
    PATH_EXPAND_ENVIRONMENT = 0x0001,
    PATH_EXPAND_FULLPATH    = 0x0002,
};

LPWSTR DAPI PathFile(
    __in LPCWSTR wzPath
    );
HRESULT DAPI PathGetDirectory(
    __in LPCWSTR wzPath,
    __out LPWSTR *ppwzDirectory
    );
HRESULT DAPI PathExpand(
    __out LPWSTR *ppwzFullPath,
    __in LPCWSTR wzRelativePath,
    __in DWORD dwResolveFlags
    );
HRESULT DAPI PathPrefix(
    __inout LPWSTR *ppwzFullPath
    );
HRESULT DAPI PathBackslashTerminate(
    __inout LPWSTR* ppwzPath
    );
HRESULT DAPI PathFixedBackslashTerminate(
    __inout_ecount_z(cchPath) LPWSTR wzPath,
    __in DWORD_PTR cchPath
    );
HRESULT DAPI PathForCurrentProcess(
    __inout LPWSTR *ppwzFullPath,
    __in_opt HMODULE hModule
    );
HRESULT DAPI PathCreateTempFile(
    __in_opt LPCWSTR wzDirectory,
    __in_opt __format_string LPCWSTR wzFileNameTemplate,
    __in DWORD dwUniqueCount,
    __in DWORD dwFileAttributes,
    __out_opt LPWSTR* ppwzTempFile,
    __out_opt HANDLE* phTempFile
    );
HRESULT DAPI PathCreateTempDirectory(
    __in_opt LPCWSTR wzDirectory,
    __in __format_string LPCWSTR wzDirectoryNameTemplate,
    __in DWORD dwUniqueCount,
    __out LPWSTR* ppwzTempDirectory
    );
HRESULT DAPI PathGetKnownFolder(
    __in int csidl,
    __out LPWSTR* psczKnownFolder
    );
BOOL DAPI PathIsAbsolute(
    __in LPCWSTR sczPath
    );
HRESULT DAPI PathConcat(
    __in_opt LPCWSTR sczPath1,
    __in_opt LPCWSTR sczPath2,
    __out LPWSTR* psczCombined
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\resrutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="resrutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Resource read helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ResGetStringLangId(
    __in_opt LPCWSTR wzPath,
    __in UINT uID,
    __out WORD *pwLangId
    );

HRESULT DAPI ResReadString(
    __in HINSTANCE hinst,
    __in UINT uID,
    __deref_out_z LPWSTR* ppwzString
    );

HRESULT DAPI ResReadStringAnsi(
    __in HINSTANCE hinst,
    __in UINT uID,
    __deref_out_z LPSTR* ppszString
    );

HRESULT DAPI ResReadData(
    __in_opt HINSTANCE hinst,
    __in LPCSTR szDataName,
    __deref_out_bcount(*pcb) PVOID *ppv,
    __out DWORD *pcb
    );

HRESULT DAPI ResExportDataToFile(
    __in LPCSTR szDataName,
    __in LPCWSTR wzTargetFile,
    __in DWORD dwCreationDisposition
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\reswutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="reswutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Resource writer helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ResWriteString(
    __in LPCWSTR wzResourceFile,
    __in DWORD dwDataId,
    __in LPCWSTR wzData,
    __in WORD wLangId
    );

HRESULT DAPI ResWriteData(
    __in LPCWSTR wzResourceFile,
    __in LPCSTR szDataName,
    __in PVOID pData,
    __in DWORD cbData
    );

HRESULT DAPI ResImportDataFromFile(
    __in LPCWSTR wzTargetFile,
    __in LPCWSTR wzSourceFile,
    __in LPCSTR szDataName
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\strutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="strutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for string helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseStr(pwz) if (pwz) { StrFree(pwz); }
#define ReleaseNullStr(pwz) if (pwz) { StrFree(pwz); pwz = NULL; }
#define ReleaseBSTR(bstr) if (bstr) { ::SysFreeString(bstr); }
#define ReleaseNullBSTR(bstr) if (bstr) { ::SysFreeString(bstr); bstr = NULL; }

HRESULT DAPI StrAlloc(
    __deref_out_ecount_part(cch, 0) LPWSTR* ppwz,
    __in DWORD_PTR cch
    );
HRESULT DAPI StrAnsiAlloc(
    __deref_out_ecount_part(cch, 0) LPSTR* ppz,
    __in DWORD_PTR cch
    );
HRESULT DAPI StrAllocString(
    __deref_out_ecount_z(cchSource+1) LPWSTR* ppwz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource
    );
HRESULT DAPI StrAnsiAllocString(
    __deref_out_ecount_z(cchSource+1) LPSTR* ppsz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource,
    __in UINT uiCodepage
    );
HRESULT DAPI StrAllocStringAnsi(
    __deref_out_ecount_z(cchSource+1) LPWSTR* ppwz,
    __in LPCSTR szSource,
    __in DWORD_PTR cchSource,
    __in UINT uiCodepage
    );
HRESULT DAPI StrAllocPrefix(
    __deref_out_z LPWSTR* ppwz,
    __in LPCWSTR wzPrefix,
    __in DWORD_PTR cchPrefix
    );
HRESULT DAPI StrAllocConcat(
    __deref_out_z LPWSTR* ppwz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource
    );
HRESULT __cdecl StrAllocFormatted(
    __deref_out_z LPWSTR* ppwz,
    __in __format_string LPCWSTR wzFormat,
    ...
    );
HRESULT __cdecl StrAnsiAllocFormatted(
    __deref_out_z LPSTR* ppsz,
    __in __format_string LPCSTR szFormat,
    ...
    );
HRESULT DAPI StrAllocFormattedArgs(
    __deref_out_z LPWSTR* ppwz,
    __in __format_string LPCWSTR wzFormat,
    __in va_list args
    );
HRESULT DAPI StrAnsiAllocFormattedArgs(
    __deref_out_z LPSTR* ppsz,
    __in __format_string LPCSTR szFormat,
    __in va_list args
    );

HRESULT DAPI StrMaxLength(
    __in LPVOID p,
    __out DWORD_PTR* pcch
    );
HRESULT DAPI StrSize(
    __in LPVOID p,
    __out DWORD_PTR* pcb
    );

HRESULT DAPI StrFree(
    __in LPVOID p
    );

HRESULT DAPI StrCurrentTime(
    __deref_out_z LPWSTR* ppwz,
    __in BOOL fGMT
    );
HRESULT DAPI StrCurrentDateTime(
    __deref_out_z LPWSTR* ppwz,
    __in BOOL fGMT
    );

HRESULT DAPI StrHexEncode(
    __in_ecount(cbSource) const BYTE* pbSource,
    __in DWORD_PTR cbSource,
    __out_ecount(cchDest) LPWSTR wzDest,
    __in DWORD_PTR cchDest
    );
HRESULT DAPI StrHexDecode(
    __in LPCWSTR wzSource,
    __out_bcount(cbDest) BYTE* pbDest,
    __in DWORD_PTR cbDest
    );

HRESULT DAPI StrAllocBase85Encode(
    __in_bcount(cbSource) const BYTE* pbSource,
    __in DWORD_PTR cbSource,
    __deref_out_z LPWSTR* pwzDest
    );
HRESULT DAPI StrAllocBase85Decode(
    __in LPCWSTR wzSource,
    __deref_out_bcount(*pcbDest) BYTE** hbDest,
    __out DWORD_PTR* pcbDest
    );

HRESULT DAPI MultiSzLen(
    __in LPCWSTR pwzMultiSz,
    __out DWORD_PTR* pcch
    );
HRESULT DAPI MultiSzPrepend(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __inout_opt DWORD_PTR *pcchMultiSz,
    __in LPCWSTR pwzInsert
    );
HRESULT DAPI MultiSzFindSubstring(
    __in LPCWSTR pwzMultiSz,
    __in LPCWSTR pwzSubstring,
    __out_opt DWORD_PTR* pdwIndex,
    __deref_opt_out_z LPCWSTR* ppwzFoundIn
    );
HRESULT DAPI MultiSzFindString(
    __in LPCWSTR pwzMultiSz,
    __in LPCWSTR pwzString,
    __out_opt DWORD_PTR* pdwIndex,
    __deref_opt_out_z LPCWSTR* ppwzFound
    );
HRESULT DAPI MultiSzRemoveString(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __in DWORD_PTR dwIndex
    );
HRESULT DAPI MultiSzInsertString(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __inout_opt DWORD_PTR *pcchMultiSz,
    __in DWORD_PTR dwIndex,
    __in LPCWSTR pwzInsert
    );
HRESULT DAPI MultiSzReplaceString(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __in DWORD_PTR dwIndex,
    __in LPCWSTR pwzString
    );

LPCWSTR wcsistr(
    __in LPCWSTR wzString,
    __in LPCWSTR wzCharSet
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\sqlutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="sqlutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    SQL helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <cguid.h>
#include <oledberr.h>
#include <sqloledb.h>


#ifdef __cplusplus
extern "C" {
#endif

// Adding this until the SQL annotations are published to specstrings.h
#ifndef __sql_command
#define __sql_command
#endif

// structs
struct SQL_FILESPEC
{
	WCHAR wzName[MAX_PATH];
	WCHAR wzFilename[MAX_PATH];
	WCHAR wzSize[MAX_PATH];
	WCHAR wzMaxSize[MAX_PATH];
	WCHAR wzGrow[MAX_PATH];
};


// functions
HRESULT DAPI SqlConnectDatabase(
	__in LPCWSTR wzServer, 
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase, 
	__in BOOL fIntegratedAuth, 
	__in LPCWSTR wzUser, 
	__in LPCWSTR wzPassword, 
	__out IDBCreateSession** ppidbSession
	);
HRESULT DAPI SqlStartTransaction(
	__in IDBCreateSession* pidbSession,
	__out IDBCreateCommand** ppidbCommand,
	__out ITransaction** ppit
	);
HRESULT DAPI SqlEndTransaction(
	__in ITransaction* pit,
	__in BOOL fCommit
	);
HRESULT DAPI SqlDatabaseExists(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDatabaseExists(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlDatabaseEnsureExists(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__in_opt SQL_FILESPEC* psfDatabase,
	__in_opt SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDatabaseEnsureExists(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__in_opt SQL_FILESPEC* psfDatabase,
	__in_opt SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlCreateDatabase(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__in_opt SQL_FILESPEC* psfDatabase,
	__in_opt SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionCreateDatabase(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__in_opt const SQL_FILESPEC* psfDatabase,
	__in_opt const SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlDropDatabase(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDropDatabase(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionExecuteQuery(
	__in IDBCreateSession* pidbSession, 
	__in __sql_command LPCWSTR wzSql, 
	__out_opt IRowset** ppirs,
	__out_opt DBROWCOUNT* pcRows,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlCommandExecuteQuery(
	__in IDBCreateCommand* pidbCommand, 
	__in __sql_command LPCWSTR wzSql, 
	__out IRowset** ppirs,
	__out DBROWCOUNT* pcRows
	);
HRESULT DAPI SqlGetErrorInfo(
	__in IUnknown* pObjectWithError,
	__in REFIID IID_InterfaceWithError,
	__in DWORD dwLocaleId,
	__out_opt BSTR* pbstrErrorSource,
	__out_opt BSTR* pbstrErrorDescription
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\wcawow64.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcawow64.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library for Wow64 API-related functionality.
// </summary>
//-------------------------------------------------------------------------------------------------

#include "wcautil.h"

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WIXAPI WcaInitializeWow64();
BOOL WIXAPI WcaIsWow64Initialized();
HRESULT WIXAPI WcaDisableWow64FSRedirection();
HRESULT WIXAPI WcaRevertWow64FSRedirection();
HRESULT WIXAPI WcaFinalizeWow64();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\uriutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="uriutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    URI helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

enum URI_PROTOCOL
{
    URI_PROTOCOL_UNKNOWN,
    URI_PROTOCOL_FILE,
    URI_PROTOCOL_FTP,
    URI_PROTOCOL_HTTP,
    URI_PROTOCOL_LOCAL,
    URI_PROTOCOL_UNC
};


LPWSTR DAPI UriFile(
    __in LPCWSTR wzUri
    );

HRESULT DAPI UriProtocol(
    __in LPCWSTR wzUri,
    __out URI_PROTOCOL* pProtocol
    );

HRESULT DAPI UriRoot(
    __in LPCWSTR wzUri,
    __out LPWSTR* ppwzRoot,
    __out_opt URI_PROTOCOL* pProtocol
    );

HRESULT DAPI UriResolve(
    __in LPCWSTR wzUri,
    __in_opt LPCWSTR wzBaseUri,
    __out LPWSTR* ppwzResolvedUri,
    __out_opt URI_PROTOCOL* pResolvedProtocol
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\wcautil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcautil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define WIXAPI __stdcall
#define ExitTrace WcaLogError
#define ExitTrace1 WcaLogError
#define ExitTrace2 WcaLogError
#define ExitTrace3 WcaLogError

#include "dutil.h"

#define MessageExitOnLastError(x, e, s)      { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace(x, "%s", s); WcaErrorMessage(e, x, MB_OK, 0);  goto LExit; } }
#define MessageExitOnLastError1(x, e, f, s)  { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace1(x, f, s); WcaErrorMessage(e, x, MB_OK, 1, s);  goto LExit; } }

#define MessageExitOnFailure(x, e, s)           if (FAILED(x)) { ExitTrace(x, "%s", s); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 0);  goto LExit; }
#define MessageExitOnFailure1(x, e, f, s)       if (FAILED(x)) { ExitTrace1(x, f, s); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 1, s);  goto LExit; }
#define MessageExitOnFailure2(x, e, f, s, t)    if (FAILED(x)) { ExitTrace2(x, f, s, t); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 2, s, t);  goto LExit; }
#define MessageExitOnFailure3(x, e, f, s, t, u) if (FAILED(x)) { ExitTrace2(x, f, s, t, u); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 3, s, t, u);  goto LExit; }

#define MessageExitOnNullWithLastError(p, x, e, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, "%s", s); WcaErrorMessage(e, x, MB_OK, 0);  goto LExit; }
#define MessageExitOnNullWithLastError1(p, x, e, f, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, f, s); WcaErrorMessage(e, x, MB_OK, 1, s);  goto LExit; }
#define MessageExitOnNullWithLastError2(p, x, e, f, s, t) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, f, s, t); WcaErrorMessage(e, x, MB_OK, 2, s, t);  goto LExit; }

// Generic action enum.
enum WCA_ACTION
{
    WCA_ACTION_NONE,
    WCA_ACTION_INSTALL,
    WCA_ACTION_UNINSTALL,
};

enum WCA_CASCRIPT
{
    WCA_CASCRIPT_SCHEDULED,
    WCA_CASCRIPT_ROLLBACK,
};

enum WCA_CASCRIPT_CLOSE
{
    WCA_CASCRIPT_CLOSE_PRESERVE,
    WCA_CASCRIPT_CLOSE_DELETE,
};

enum WCA_TODO
{
    WCA_TODO_UNKNOWN,
    WCA_TODO_INSTALL,
    WCA_TODO_UNINSTALL,
    WCA_TODO_REINSTALL,
};

typedef struct WCA_CASCRIPT_STRUCT
{
    LPWSTR pwzScriptPath;
    HANDLE hScriptFile;
} *WCA_CASCRIPT_HANDLE;

void WIXAPI WcaGlobalInitialize(
    __in HINSTANCE hInst
    );
void WIXAPI WcaGlobalFinalize();

HRESULT WIXAPI WcaInitialize(
    __in MSIHANDLE hInstall,
    __in_z PCSTR szCustomActionLogName
    );
UINT WIXAPI WcaFinalize(
    __in UINT iReturnValue
    );
BOOL WIXAPI WcaIsInitialized();

MSIHANDLE WIXAPI WcaGetInstallHandle();
MSIHANDLE WIXAPI WcaGetDatabaseHandle();

const char* WIXAPI WcaGetLogName();

void WIXAPI WcaSetReturnValue(
    __in UINT iReturnValue
    );
BOOL WIXAPI WcaCancelDetected();

const int LOG_BUFFER = 2048;
enum LOGLEVEL
{ 
    LOGMSG_TRACEONLY,  // Never written to the log file (except in DEBUG builds)
    LOGMSG_VERBOSE,    // Written to log when LOGVERBOSE
    LOGMSG_STANDARD    // Written to log whenever informational logging is enabled
};

void __cdecl WcaLog(
    __in LOGLEVEL llv,
    __in_z __format_string PCSTR fmt, ...
    );
BOOL WIXAPI WcaDisplayAssert(
    __in LPCSTR sz
    );
void __cdecl WcaLogError(
    __in HRESULT hr,
    __in LPCSTR szMessage,
    ...
    );

UINT WIXAPI WcaProcessMessage(
    __in INSTALLMESSAGE eMessageType,
    __in MSIHANDLE hRecord
    );
UINT __cdecl WcaErrorMessage(
    __in int iError, 
    __in HRESULT hrError, 
    __in UINT uiType, 
    __in DWORD cArgs, 
    ...
    );
HRESULT WIXAPI WcaProgressMessage(
    __in UINT uiCost,
    __in BOOL fExtendProgressBar
    );

BOOL WIXAPI WcaIsInstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );
BOOL WIXAPI WcaIsReInstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );
BOOL WIXAPI WcaIsUninstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );

HRESULT WIXAPI WcaSetComponentState(
    __in_z LPCWSTR wzComponent,
    __in INSTALLSTATE isState
    );

HRESULT WIXAPI WcaTableExists(
    __in_z LPCWSTR wzTable
    );

HRESULT WIXAPI WcaOpenView(
    __in_z LPCWSTR wzSql,
    __out MSIHANDLE* phView
    );
HRESULT WIXAPI WcaExecuteView(
    __in MSIHANDLE hView,
    __in MSIHANDLE hRec
    );
HRESULT WIXAPI WcaOpenExecuteView(
    __in_z LPCWSTR wzSql,
    __out MSIHANDLE* phView
    );
HRESULT WIXAPI WcaFetchRecord(
    __in MSIHANDLE hView,
    __out MSIHANDLE* phRec
    );
HRESULT WIXAPI WcaFetchSingleRecord(
    __in MSIHANDLE hView,
    __out MSIHANDLE* phRec
    );

HRESULT WIXAPI WcaGetProperty(
    __in_z LPCWSTR wzProperty,
    __inout LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetFormattedProperty(
    __in_z LPCWSTR wzProperty,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetFormattedString(
    __in_z LPCWSTR wzString,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetIntProperty(
    __in_z LPCWSTR wzProperty,
    __inout int* piData
    );
HRESULT WIXAPI WcaGetTargetPath(
    __in_z LPCWSTR wzFolder,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaSetProperty(
    __in_z LPCWSTR wzPropertyName,
    __in_z LPCWSTR wzPropertyValue
    );
HRESULT WIXAPI WcaSetIntProperty(
    __in_z LPCWSTR wzPropertyName,
    __in int nPropertyValue
    );
BOOL WIXAPI WcaIsPropertySet(
    __in LPCSTR szProperty
    );

HRESULT WIXAPI WcaGetRecordInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout int* piData
    );
HRESULT WIXAPI WcaGetRecordString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetRecordFormattedInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __out int* piData
    );
HRESULT WIXAPI WcaGetRecordFormattedString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout LPWSTR* ppwzData
    );

HRESULT WIXAPI WcaAllocStream(
    __inout BYTE** ppbData,
    __in DWORD cbData
    );
HRESULT WIXAPI WcaFreeStream(
    __in BYTE* pbData
    );

HRESULT WIXAPI WcaGetRecordStream(
    __in MSIHANDLE hRecBinary,
    __in UINT uiField, 
    __inout BYTE** ppbData,
    __inout DWORD* pcbData
    );
HRESULT WIXAPI WcaSetRecordString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __in_z LPCWSTR wzData
    );
HRESULT WIXAPI WcaSetRecordInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __in int iValue
    );

HRESULT WIXAPI WcaDoDeferredAction(
    __in_z LPCWSTR wzAction,
    __in_z LPCWSTR wzCustomActionData,
    __in UINT uiCost
    );
DWORD WIXAPI WcaCountOfCustomActionDataRecords(
    __in_z LPCWSTR wzData
    );
HRESULT WIXAPI WcaReadStringFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __inout LPWSTR* ppwzString
    );
HRESULT WIXAPI WcaReadIntegerFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __inout int* piResult
    );
HRESULT WIXAPI WcaReadStreamFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __out BYTE** ppbData,
    __out DWORD_PTR* pcbData
    );
HRESULT WIXAPI WcaWriteStringToCaData(
    __in_z LPCWSTR wzString,
    __inout LPWSTR* ppwzCustomActionData
    );
HRESULT WIXAPI WcaWriteIntegerToCaData(
    __in int i, 
    __inout LPWSTR* ppwzCustomActionData
    );
HRESULT WIXAPI WcaWriteStreamToCaData(
    __in_bcount(cbData) const BYTE* pbData,
    __in DWORD cbData,
    __inout LPWSTR* ppwzCustomActionData
    );

HRESULT __cdecl WcaAddTempRecord(
    __inout MSIHANDLE* phTableView,
    __inout MSIHANDLE* phColumns,
    __in_z LPCWSTR wzTable,
    __out_opt MSIDBERROR* pdbError,
    __in UINT uiUniquifyColumn,
    __in UINT cColumns,
    ...
    );

HRESULT WIXAPI WcaDumpTable(
    __in_z LPCWSTR wzTable
    );

HRESULT WIXAPI WcaDeferredActionRequiresReboot();
BOOL WIXAPI WcaDidDeferredActionRequireReboot();

HRESULT WIXAPI WcaCaScriptCreateKey(
    __out LPWSTR* ppwzScriptKey
    );

HRESULT WIXAPI WcaCaScriptCreate(
    __in WCA_ACTION action,
    __in WCA_CASCRIPT script,
    __in BOOL fImpersonated,
    __in_z LPCWSTR wzScriptKey,
    __in BOOL fAppend,
    __out WCA_CASCRIPT_HANDLE* phScript
    );

HRESULT WIXAPI WcaCaScriptOpen(
    __in WCA_ACTION action,
    __in WCA_CASCRIPT script,
    __in BOOL fImpersonated,
    __in_z LPCWSTR wzScriptKey,
    __out WCA_CASCRIPT_HANDLE* phScript
    );

void WIXAPI WcaCaScriptClose(
    __in_opt WCA_CASCRIPT_HANDLE hScript,
    __in WCA_CASCRIPT_CLOSE closeOperation
    );

HRESULT WIXAPI WcaCaScriptReadAsCustomActionData(
    __in WCA_CASCRIPT_HANDLE hScript,
    __out LPWSTR* ppwzCustomActionData
    );

HRESULT WIXAPI WcaCaScriptWriteString(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in_z LPCWSTR wzValue
    );

HRESULT WIXAPI WcaCaScriptWriteNumber(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in DWORD dwValue
    );

void WIXAPI WcaCaScriptFlush(
    __in WCA_CASCRIPT_HANDLE hScript
    );

void WIXAPI WcaCaScriptCleanup(
    __in_z LPCWSTR wzProductCode,
    __in BOOL fImpersonated
    );

HRESULT QuietExec(
    __in_z LPWSTR wzCommand,
    __in DWORD dwTimeout
    );

WCA_TODO WcaGetComponentToDo(
    __in_z LPCWSTR wzComponentId
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\wcawrapquery.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcawrapquery.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library wrappers meant to wrap an MSI view as
//    opened by an immediate custom action and transmit it to a deferred custom action
// </summary>
//-------------------------------------------------------------------------------------------------

#include "wcautil.h"

// Enumerations
enum eWrapQueryAction
{
    wqaTableBegin = 1,
    wqaTableFinish,
    wqaRowBegin,
    wqaRowFinish
};

enum eColumnDataType
{
    cdtString = 1,
    cdtInt,
    cdtStream,
    cdtUnknown
};

enum eFormatMaskColumn
{
    efmcColumn1 = 1,
    efmcColumn2 = 1 << 1,
    efmcColumn3 = 1 << 2,
    efmcColumn4 = 1 << 3,
    efmcColumn5 = 1 << 4,
    efmcColumn6 = 1 << 5,
    efmcColumn7 = 1 << 6,
    efmcColumn8 = 1 << 7,
    efmcColumn9 = 1 << 8,
    efmcColumn10 = 1 << 9,
    efmcColumn11 = 1 << 10,
    efmcColumn12 = 1 << 11,
    efmcColumn13 = 1 << 12,
    efmcColumn14 = 1 << 13,
    efmcColumn15 = 1 << 14,
    efmcColumn16 = 1 << 15,
    efmcColumn17 = 1 << 16,
    efmcColumn18 = 1 << 17,
    efmcColumn19 = 1 << 18,
    efmcColumn20 = 1 << 19,
    efmcColumn21 = 1 << 20,
    efmcColumn22 = 1 << 21,
    efmcColumn23 = 1 << 22,
    efmcColumn24 = 1 << 23,
    efmcColumn25 = 1 << 24,
    efmcColumn26 = 1 << 25,
    efmcColumn27 = 1 << 26,
    efmcColumn28 = 1 << 27,
    efmcColumn29 = 1 << 28,
    efmcColumn30 = 1 << 29,
    efmcColumn31 = 1 << 30,
    efmcColumn32 = 1 << 31,
};

// Keeps track of the query instance for the reading CA (deferred CA)
typedef struct WCA_WRAPQUERY_STRUCT
{
    // These are used to size our dynamic arrays below
    DWORD dwColumns, dwRows, dwNextIndex;

    // Dynamic arrays of column schema information
    eColumnDataType *pcdtColumnType;
    LPWSTR *ppwzColumnNames;

    // Dynamic array of raw record data
    MSIHANDLE *phRecords;
} *WCA_WRAPQUERY_HANDLE;

// Wrap a query
// Setting the pfFormatMask enables control over which fields will be formatted, and which will be left unchanged
// Setting dwComponentColumn to something other than 0xFFFFFFFF tells WcaWrapQuery to add two additional columns to the right side of the table
//      - ISInstalled and ISAction - which map to the ComponentState of the component (the component is found in the column specified)
//      Note that if a component is NULL, the component state columns will also be left null, and it will be up to the deferred CA to fail or ignore the case appropriately
// Setting dwDirectoryColumn to something other than 0xFFFFFFFF tells WcaWrapQuery to add two more additional columns to the right side of the table
//      - SourcePath and TargetPath - which map to the Directory's Source and Target Path (the directory is found in the column specified)
//      Note that if a directory is NULL, the directory source/target path columns will also be left null, and it will be up to the deferred CA to fail or ignore the case appropriately
HRESULT WIXAPI WcaWrapQuery(
    __in_z LPCWSTR pwzQuery,
    __inout LPWSTR * ppwzCustomActionData,
    __in_opt DWORD dwFormatMask,
    __in_opt DWORD dwComponentColumn,
    __in_opt DWORD dwDirectoryColumn
    );
// This wraps an empty table query into the custom action data - this is a way to indicate to the deferred custom action that a necessary table doesn't exist, or its query returned no results
HRESULT WIXAPI WcaWrapEmptyQuery(
    __inout LPWSTR * ppwzCustomActionData
    );

// Open a new unwrap query operation, with data from the ppwzCustomActionData string
HRESULT WIXAPI WcaBeginUnwrapQuery(
    __out WCA_WRAPQUERY_HANDLE * phWrapQuery,
    __inout LPWSTR * ppwzCustomActionData
    );

// Get the number of records in a query being unwrapped
DWORD WIXAPI WcaGetQueryRecords(
    __in const WCA_WRAPQUERY_HANDLE hWrapQuery
    );

// This function resets a query back to its first row, so that the next fetch returns the first record
void WIXAPI WcaFetchWrappedReset(
    __in WCA_WRAPQUERY_HANDLE hWrapQuery
    );
// Fetch the next record in this query
// NOTE: the MSIHANDLE returned by this function should not be released, as it is the same handle used by the query object to maintain the item.
//       so, don't use this function with PMSIHANDLE objects!
HRESULT WIXAPI WcaFetchWrappedRecord(
    __in WCA_WRAPQUERY_HANDLE hWrapQuery,
    __out MSIHANDLE* phRec
    );

// Fetch the next record in the query where the string value in column dwComparisonColumn equals the value pwzExpectedValue
// NOTE: the MSIHANDLE returned by this function should not be released, as it is the same handle used by the query object to maintain the item.
//       so, don't use this function with PMSIHANDLE objects!
HRESULT WIXAPI WcaFetchWrappedRecordWhereString(
    __in WCA_WRAPQUERY_HANDLE hWrapQuery,
    __in DWORD dwComparisonColumn,
    __in_z LPCWSTR pwzExpectedValue,
    __out MSIHANDLE* phRec
    );

// Release a query ID (frees memory, and frees the ID for a new query)
void WIXAPI WcaFinishUnwrapQuery(
    __in_opt WCA_WRAPQUERY_HANDLE hWrapQuery
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.0.5419.0\sdk\inc\xmlutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="xmlutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    XML helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

// constant XML CLSIDs and IIDs
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument   = {0x2933BF90, 0x7B36, 0x11d2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument20  = {0xF6D90F11, 0x9C73, 0x11D3, {0xB3, 0x2E, 0x00, 0xC0, 0x4F, 0x99, 0x0B, 0xB4}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument26 = {0xf5078f1b, 0xc551, 0x11d3, {0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument30 = {0xf5078f32, 0xc551, 0x11d3, {0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument40 = {0x88d969c0, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument50 = {0x88d969e5, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument60 = {0x88d96a05, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_XMLSchemaCache = {0x88d969c2, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};

extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMDocument =  {0x2933BF81, 0x7B36, 0x11D2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMDocument2 = {0x2933BF95, 0x7B36, 0x11D2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMSchemaCollection = {0x373984C8, 0xB845, 0x449B, {0x91, 0xE7, 0x45, 0xAC, 0x83, 0x03, 0x6A, 0xDE}};

enum XML_LOAD_ATTRIBUTE
{
    XML_LOAD_PRESERVE_WHITESPACE = 1,
};


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI XmlInitialize();
void DAPI XmlUninitialize();

HRESULT DAPI XmlCreateElement(
    __in IXMLDOMDocument *pixdDocument,
    __in LPCWSTR wzElementName,
    __out IXMLDOMElement **ppixnElement
    );
HRESULT DAPI XmlCreateDocument(
    __in_opt LPCWSTR pwzElementName, 
    __out IXMLDOMDocument** ppixdDocument,
    __out_opt IXMLDOMElement** ppixeRootElement = NULL
    );
HRESULT DAPI XmlLoadDocument(
    __in LPCWSTR wzDocument,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentEx(
    __in LPCWSTR wzDocument,
    __in DWORD dwAttributes,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromFile(
    __in LPCWSTR wzPath,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromBuffer(
    __in_bcount(cbSource) const BYTE* pbSource,
    __in DWORD cbSource,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromFileEx(
    __in LPCWSTR wzPath,
    __in DWORD dwAttributes,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlSelectSingleNode(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR wzXPath,
    __out IXMLDOMNode **ppixnChild
    );
HRESULT DAPI XmlSetAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __in LPCWSTR pwzAttributeValue
    );
HRESULT DAPI XmlCreateTextNode(
    __in IXMLDOMDocument *pixdDocument,
    __in LPCWSTR wzText,
    __out IXMLDOMText **ppixnTextNode
    );
HRESULT DAPI XmlGetText(
    __in IXMLDOMNode* pixnNode,
    __out BSTR* pbstrText
    );
HRESULT DAPI XmlGetAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out BSTR* pbstrAttributeValue
    );
HRESULT DAPI XmlGetAttributeNumber(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out DWORD* pdwValue
    );
HRESULT DAPI XmlGetNamedItem(
    __in IXMLDOMNamedNodeMap *pixnmAttributes, 
    __in_opt LPCWSTR wzName, 
    __out IXMLDOMNode **ppixnNamedItem
    );
HRESULT DAPI XmlSetText(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzText
    );
HRESULT DAPI XmlSetTextNumber(
    __in IXMLDOMNode *pixnNode,
    __in DWORD dwValue
    );
HRESULT DAPI XmlCreateChild(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR pwzElementType,
    __out IXMLDOMNode** ppixnChild
    );
HRESULT DAPI XmlRemoveAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute
    );
HRESULT DAPI XmlSelectNodes(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR wzXPath,
    __out IXMLDOMNodeList **ppixnChild
    );
HRESULT DAPI XmlNextElement(
    __in IXMLDOMNodeList* pixnl,
    __out IXMLDOMNode** pixnElement,
    __out BSTR* pbstrElement
    );
HRESULT DAPI XmlRemoveChildren(
    __in IXMLDOMNode* pixnSource,
    __in LPCWSTR pwzXPath
    );
HRESULT DAPI XmlSaveDocument(
    __in IXMLDOMDocument* pixdDocument, 
    __inout LPCWSTR wzPath
    );
HRESULT DAPI XmlSaveDocumentToBuffer(
    __in IXMLDOMDocument* pixdDocument,
    __deref_out_bcount(*pcbDest) BYTE** ppbDest,
    __out DWORD* pcbDest
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\atomutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="atomutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    ATOM helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseAtomFeed(p) if (p) { AtomFreeFeed(p); }
#define ReleaseNullAtomFeed(p) if (p) { AtomFreeFeed(p); p = NULL; }


struct ATOM_UNKNOWN_ATTRIBUTE
{
    LPWSTR wzNamespace;
    LPWSTR wzAttribute;
    LPWSTR wzValue;

    ATOM_UNKNOWN_ATTRIBUTE* pNext;
};

struct ATOM_UNKNOWN_ELEMENT
{
    LPWSTR wzNamespace;
    LPWSTR wzElement;
    LPWSTR wzValue;

    ATOM_UNKNOWN_ATTRIBUTE* pAttributes;
    ATOM_UNKNOWN_ELEMENT* pNext;
};

struct ATOM_LINK
{
    LPWSTR wzRel;
    LPWSTR wzTitle;
    LPWSTR wzType;
    LPWSTR wzUrl;
    LPWSTR wzValue;
    DWORD64 dw64Length;

    ATOM_UNKNOWN_ATTRIBUTE* pUnknownAttributes;
    ATOM_UNKNOWN_ELEMENT* pUnknownElements;
};

struct ATOM_CONTENT
{
    LPWSTR wzType;
    LPWSTR wzUrl;
    LPWSTR wzValue;

    ATOM_UNKNOWN_ELEMENT* pUnknownElements;
};

struct ATOM_AUTHOR
{
    LPWSTR wzName;
    LPWSTR wzEmail;
    LPWSTR wzUrl;
};

struct ATOM_CATEGORY
{
    LPWSTR wzLabel;
    LPWSTR wzScheme;
    LPWSTR wzTerm;

    ATOM_UNKNOWN_ELEMENT* pUnknownElements;
};

struct ATOM_ENTRY
{
    LPWSTR wzId;
    LPWSTR wzSummary;
    LPWSTR wzTitle;
    FILETIME ftPublished;
    FILETIME ftUpdated;

    ATOM_CONTENT* pContent;

    DWORD cAuthors;
    ATOM_AUTHOR* rgAuthors;

    DWORD cCategories;
    ATOM_CATEGORY* rgCategories;

    DWORD cLinks;
    ATOM_LINK* rgLinks;

    IXMLDOMNode* pixn;
    ATOM_UNKNOWN_ELEMENT* pUnknownElements;
};

struct ATOM_FEED
{
    LPWSTR wzGenerator;
    LPWSTR wzIcon;
    LPWSTR wzId;
    LPWSTR wzLogo;
    LPWSTR wzSubtitle;
    LPWSTR wzTitle;
    FILETIME ftUpdated;

    DWORD cAuthors;
    ATOM_AUTHOR* rgAuthors;

    DWORD cCategories;
    ATOM_CATEGORY* rgCategories;

    DWORD cEntries;
    ATOM_ENTRY* rgEntries;

    DWORD cLinks;
    ATOM_LINK* rgLinks;

    IXMLDOMNode* pixn;
    ATOM_UNKNOWN_ELEMENT* pUnknownElements;
};

HRESULT DAPI AtomInitialize(
    );

void DAPI AtomUninitialize(
    );

HRESULT DAPI AtomParseFromString(
    __in LPCWSTR wzAtomString,
    __out ATOM_FEED **ppFeed
    );

HRESULT DAPI AtomParseFromFile(
    __in LPCWSTR wzAtomFile,
    __out ATOM_FEED **ppFeed
    );

HRESULT DAPI AtomParseFromDocument(
    __in IXMLDOMDocument* pixdDocument,
    __out ATOM_FEED **ppFeed
    );

void DAPI AtomFreeFeed(
    ATOM_FEED *pFEED
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\conutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="conutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Console helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ConsoleExitOnFailure(x, c, f) if (FAILED(x)) { ConsoleWriteError(x, c, f); ExitTrace(x, f); goto LExit; }
#define ConsoleExitOnFailure1(x, c, f, s) if (FAILED(x)) { ConsoleWriteError(x, c, f, s, NULL); ExitTrace1(x, f, s); goto LExit; }
#define ConsoleExitOnFailure2(x, c, f, s, t) if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t); ExitTrace2(x, f, s, t); goto LExit; }
#define ConsoleExitOnFailure3(x, c, f, s, t, u) if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t, u); ExitTrace3(x, f, s, t, u); goto LExit; }

#define ConsoleExitOnLastError(x, c, f) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f); ExitTrace(x, f); goto LExit; } }
#define ConsoleExitOnLastError1(x, c, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f, s, NULL); ExitTrace1(x, f, s); goto LExit; } }
#define ConsoleExitOnLastError2(x, c, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t); ExitTrace2(x, f, s, t); goto LExit; } }
#define ConsoleExitOnLastError3(x, c, f, s, t, u) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ConsoleWriteError(x, c, f, s, t, u); ExitTrace3(x, f, s, t, u); goto LExit; } }

#define ConsoleExitOnNull(p, x, e, c, f) if (NULL == p) { x = e; ConsoleWriteError(x, c, f); ExitTrace(x, f); goto LExit; }
#define ConsoleExitOnNull1(p, x, e, c, f, s) if (NULL == p) { x = e; ConsoleWriteError(x, c, f, s, NULL); ExitTrace1(x, f, s); goto LExit; }
#define ConsoleExitOnNull2(p, x, e, c, f, s, t) if (NULL == p) { x = e; ConsoleWriteError(x, c, f, s, t); ExitTrace2(x, f, s, t); goto LExit; }
#define ConsoleExitOnNull3(p, x, e, c, f, s, t, u) if (NULL == p) { x = e; ConsoleWriteError(x, c, f, s, t, u); ExitTrace2(x, f, s, t, u); goto LExit; }


// the following macros need to go away
#define ConsoleTrace(l, f) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f); Trace(l, f); }
#define ConsoleTrace1(l, f, s) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f, s); Trace1(l, f, s); }
#define ConsoleTrace2(l, f, s, t) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f, s, t); Trace2(l, f, s, t); }
#define ConsoleTrace3(l, f, s, t, u) { ConsoleWriteLine(CONSOLE_COLOR_NORMAL, f, s, t, u); Trace3(l, f, s, t, u); }

#define ConsoleWarning(f) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f); Trace(REPORT_STANDARD, f); }
#define ConsoleWarning1(f, s) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f, s); Trace1(REPORT_STANDARD, f, s); }
#define ConsoleWarning2(f, s, t) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f, s, t); Trace2(REPORT_STANDARD, f, s, t); }
#define ConsoleWarning3(f, s, t, u) { ConsoleWriteLine(CONSOLE_COLOR_YELLOW, f, s, t, u); Trace3(REPORT_STANDARD, f, s, t, u); }

#define ConsoleError(x, f) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f); TraceError(x, f); }
#define ConsoleError1(x, f, s) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f, s); TraceError1(x, f, s); }
#define ConsoleError2(x, f, s, t) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f, s, t); TraceError2(x, f, s, t); }
#define ConsoleError3(x, f, s, t, u) { ConsoleWriteError(x, CONSOLE_COLOR_RED, f, s, t, u); TraceError3(x, f, s, t, u); }


// enums
enum CONSOLE_COLOR { CONSOLE_COLOR_NORMAL, CONSOLE_COLOR_RED, CONSOLE_COLOR_YELLOW, CONSOLE_COLOR_GREEN };

// structs

// functions
HRESULT DAPI ConsoleInitialize();
void DAPI ConsoleUninitialize();

void DAPI ConsoleGreen();
void DAPI ConsoleRed();
void DAPI ConsoleYellow();
void DAPI ConsoleNormal();

HRESULT DAPI ConsoleWrite(
    CONSOLE_COLOR cc,
    __in_z __format_string LPCSTR szFormat,
    ...
    );
HRESULT DAPI ConsoleWriteLine(
    CONSOLE_COLOR cc,
    __in_z __format_string LPCSTR szFormat,
    ...
    );
HRESULT DAPI ConsoleWriteError(
    HRESULT hrError,
    CONSOLE_COLOR cc,
    __in_z __format_string LPCSTR szFormat,
    ...
    );

HRESULT DAPI ConsoleReadW(
    __deref_out_z LPWSTR* ppwzBuffer
    );

HRESULT DAPI ConsoleReadStringA(
    __deref_out_ecount_part(cchCharBuffer,*pcchNumCharReturn) LPSTR* szCharBuffer,
    CONST DWORD cchCharBuffer,
    __out DWORD* pcchNumCharReturn
    );
HRESULT DAPI ConsoleReadStringW(
    __deref_out_ecount_part(cchCharBuffer,*pcchNumCharReturn) LPWSTR* szCharBuffer,
    CONST DWORD cchCharBuffer,
    __out DWORD* pcchNumCharReturn
    );

HRESULT DAPI ConsoleReadNonBlockingW(
    __deref_out_ecount_opt(*pcchSize) LPWSTR* ppwzBuffer,
    __out DWORD* pcchSize,
    BOOL fReadLine
    );

HRESULT ConsoleSetReadHidden(void);
HRESULT ConsoleSetReadNormal(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\buffutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="buffutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//    Binary serialization helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif


// macro definitions

#define ReleaseBuffer ReleaseMem
#define ReleaseNullBuffer ReleaseNullMem
#define BuffFree MemFree


// function declarations

HRESULT BuffReadNumber(
    __in_bcount(cbBuffer) BYTE* pbBuffer,
    __in SIZE_T cbBuffer,
    __inout SIZE_T* piBuffer,
    __out DWORD* pdw
    );
HRESULT BuffReadNumber64(
    __in_bcount(cbBuffer) BYTE* pbBuffer,
    __in SIZE_T cbBuffer,
    __inout SIZE_T* piBuffer,
    __out DWORD64* pdw64
    );
HRESULT BuffReadString(
    __in_bcount(cbBuffer) BYTE* pbBuffer,
    __in SIZE_T cbBuffer,
    __inout SIZE_T* piBuffer,
    __deref_inout_z LPWSTR* pscz
    );
HRESULT BuffReadStream(
    __in_bcount(cbBuffer) BYTE* pbBuffer,
    __in SIZE_T cbBuffer,
    __inout SIZE_T* piBuffer,
    __deref_out_bcount(*pcbStream) BYTE** ppbStream,
    __out SIZE_T* pcbStream
    );

HRESULT BuffWriteNumber(
    __deref_inout BYTE** ppbBuffer,
    __inout SIZE_T* piBuffer,
    __in DWORD dw
    );
HRESULT BuffWriteNumber64(
    __deref_inout BYTE** ppbBuffer,
    __inout SIZE_T* piBuffer,
    __in DWORD64 dw64
    );
HRESULT BuffWriteString(
    __deref_inout BYTE** ppbBuffer,
    __inout SIZE_T* piBuffer,
    __in_z LPCWSTR scz
    );
HRESULT BuffWriteStream(
    __deref_inout BYTE** ppbBuffer,
    __inout SIZE_T* piBuffer,
    __in_bcount(cbStream) const BYTE* pbStream,
    __in SIZE_T cbStream
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\apuputil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="apuputil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for Application Update helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseApupChain(p) if (p) { ApupFreeChain(p); p = NULL; }
#define ReleaseNullApupChain(p) if (p) { ApupFreeChain(p); p = NULL; }


const LPCWSTR APPLICATION_SYNDICATION_NAMESPACE = L"http://appsyndication.org/2006/appsyn";

enum APUP_HASH_ALGORITHM
{
    APUP_HASH_ALGORITHM_UNKNOWN,
    APUP_HASH_ALGORITHM_MD5,
    APUP_HASH_ALGORITHM_SHA1,
    APUP_HASH_ALGORITHM_SHA256,
};


struct APPLICATION_UPDATE_ENCLOSURE
{
    LPWSTR wzUrl;
    LPWSTR wzLocalName;
    DWORD64 dw64Size;

    BYTE* rgbDigest;
    DWORD cbDigest;
    APUP_HASH_ALGORITHM digestAlgorithm;

    BOOL fInstaller;
};


struct APPLICATION_UPDATE_ENTRY
{
    LPWSTR wzApplicationId;
    LPWSTR wzApplicationType;

    DWORD64 dw64Version;
    LPWSTR wzUpgradeId;
    DWORD64 dw64UpgradeVersion;
    BOOL fUpgradeExclusive;

    DWORD64 dw64TotalSize;

    DWORD cEnclosures;
    APPLICATION_UPDATE_ENCLOSURE* rgEnclosures;
};


struct APPLICATION_UPDATE_CHAIN
{
    LPWSTR wzDefaultApplicationId;
    LPWSTR wzDefaultApplicationType;

    DWORD cEntries;
    APPLICATION_UPDATE_ENTRY* rgEntries;
};


HRESULT DAPI ApupAllocChainFromAtom(
    __in ATOM_FEED* pFeed,
    __out APPLICATION_UPDATE_CHAIN** ppChain
    );

HRESULT DAPI ApupFilterChain(
    __in APPLICATION_UPDATE_CHAIN* pChain,
    __in DWORD64 dw64Version,
    __out APPLICATION_UPDATE_CHAIN** ppFilteredChain
    );

void DAPI ApupFreeChain(
    __in APPLICATION_UPDATE_CHAIN* pChain
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\dirutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="dirutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Directory helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

BOOL DAPI DirExists(
    __in LPCWSTR wzPath, 
    __out_opt DWORD *pdwAttributes
    );

HRESULT DAPI DirCreateTempPath(
    __in LPCWSTR wzPrefix,
    __in LPWSTR wzPath,
    __in DWORD cchPath
    );

HRESULT DAPI DirEnsureExists(
    __in LPCWSTR wzPath, 
    __in_opt LPSECURITY_ATTRIBUTES psa
    );

HRESULT DAPI DirEnsureDelete(
    __in LPCWSTR wzPath,
    __in BOOL fDeleteFiles,
    __in BOOL fRecurse
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\aclutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="aclutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Access Control List helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <aclapi.h>
#include <sddl.h>

#define ReleaseSid(x) if (x) { AclFreeSid(x); }
#define ReleaseNullSid(x) if (x) { AclFreeSid(x); x = NULL; }

#ifdef __cplusplus
extern "C" {
#endif

// structs
struct ACL_ACCESS
{
    BOOL fDenyAccess;
    DWORD dwAccessMask;

    // TODO: consider using a union
    LPCWSTR pwzAccountName;   // NOTE: the last three items in this structure are ignored if this is not NULL

    SID_IDENTIFIER_AUTHORITY sia;  // used if pwzAccountName is NULL
    BYTE nSubAuthorityCount;
    DWORD nSubAuthority[8];
};

struct ACL_ACE
{
    DWORD dwFlags;
    DWORD dwMask;
    PSID psid;
};


// functions
HRESULT DAPI AclCheckAccess(
    __in HANDLE hToken, 
    ACL_ACCESS* paa
    );
HRESULT DAPI AclCheckAdministratorAccess(
    __in HANDLE hToken
    );
HRESULT DAPI AclCheckLocalSystemAccess(
    __in HANDLE hToken
    );

HRESULT DAPI AclGetWellKnownSid(
    __in WELL_KNOWN_SID_TYPE wkst,
    __out PSID* ppsid
    );
HRESULT DAPI AclGetAccountSid(
    __in_opt LPCWSTR wzSystem,
    __in LPCWSTR wzAccount,
    __out PSID* ppsid
    );
HRESULT DAPI AclGetAccountSidString(
    __in LPCWSTR wzSystem,
    __in LPCWSTR wzAccount,
    __out LPWSTR* ppwzSid
    );

HRESULT DAPI AclCreateDacl(
    __in_ecount(cDeny) ACL_ACE rgaaDeny[],
    __in DWORD cDeny,
    __in_ecount(cAllow) ACL_ACE rgaaAllow[],
    __in DWORD cAllow,
    __out ACL** ppAcl
    );
HRESULT DAPI AclAddToDacl(
    __in ACL* pAcl,
    __in_ecount_opt(cDeny) const ACL_ACE rgaaDeny[],
    __in DWORD cDeny,
    __in_ecount_opt(cAllow) const ACL_ACE rgaaAllow[],
    __in DWORD cAllow,
    __out ACL** ppAclNew
    );
HRESULT DAPI AclMergeDacls(
    __in const ACL* pAcl1,
    __in const ACL* pAcl2,
    __out ACL** ppAclNew
    );
HRESULT DAPI AclCreateDaclOld(
    __in_ecount(cAclAccesses) ACL_ACCESS* paa,
    __in DWORD cAclAccesses,
    __out ACL** ppAcl
    );
HRESULT DAPI AclCreateSecurityDescriptor(
    __in_ecount(cAclAccesses) ACL_ACCESS* paa,
    __in DWORD cAclAccesses,
    __out SECURITY_DESCRIPTOR** ppsd
    );
HRESULT DAPI AclCreateSecurityDescriptorFromDacl(
    __in ACL* pACL,
    __out SECURITY_DESCRIPTOR** ppsd
    );
HRESULT __cdecl AclCreateSecurityDescriptorFromString(
    __out SECURITY_DESCRIPTOR** ppsd,
    __in LPCWSTR wzSddlFormat,
    ...
    );
HRESULT DAPI AclDuplicateSecurityDescriptor(
    __in SECURITY_DESCRIPTOR* psd,
    __out SECURITY_DESCRIPTOR** ppsd
    );
HRESULT DAPI AclGetSecurityDescriptor(
    __in LPCWSTR wzObject,
    __in SE_OBJECT_TYPE sot,
    __out SECURITY_DESCRIPTOR** ppsd
    );

HRESULT DAPI AclFreeSid(
    __in PSID psid
    );
HRESULT DAPI AclFreeDacl(
    __in ACL* pACL
    );
HRESULT DAPI AclFreeSecurityDescriptor(
    __in SECURITY_DESCRIPTOR* psd
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\cabcutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="cabcutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for cabinet creation helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <fci.h>
#include <fcntl.h>
#include <msi.h>

#define CAB_MAX_SIZE 0x7FFFFFFF   // (see KB: Q174866)

#ifdef __cplusplus
extern "C" {
#endif

// time vs. space trade-off
enum COMPRESSION_TYPE 
{ 
    COMPRESSION_TYPE_NONE, // fastest
    COMPRESSION_TYPE_LOW, 
    COMPRESSION_TYPE_MEDIUM,
    COMPRESSION_TYPE_HIGH, // smallest
    COMPRESSION_TYPE_MSZIP
};

// functions
HRESULT DAPI CabCBegin(
    __in_z LPCWSTR wzCab,
    __in_z LPCWSTR wzCabDir,
    __in DWORD dwMaxFiles,
    __in DWORD dwMaxSize,
    __in DWORD dwMaxThresh,
    __in COMPRESSION_TYPE ct,
    __out HANDLE *phContext
    );
HRESULT DAPI CabCNextCab(
    __in HANDLE hContext
    );
HRESULT DAPI CabCAddFile(
    __in_z LPCWSTR wzFile,
    __in_z_opt LPCWSTR wzToken,
    __in_opt PMSIFILEHASHINFO pmfHash,
    __in HANDLE hContext
    );
HRESULT DAPI CabCFinish(
    __in HANDLE hContext
    );
void DAPI CabCCancel(
    __in HANDLE hContext
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\certutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="certutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Certificate helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI CertReadProperty(
    __in PCCERT_CONTEXT pCertContext,
    __in DWORD dwProperty,
    __deref_out_bound LPVOID pvValue
    );

HRESULT DAPI GetCryptProvFromCert(
      __in_opt HWND hwnd,
      __in PCCERT_CONTEXT pCert,
      __out HCRYPTPROV *phCryptProv,
      __out DWORD *pdwKeySpec,
      __in BOOL *pfDidCryptAcquire,
      __deref_opt_out LPWSTR *ppwszTmpContainer,
      __deref_opt_out LPWSTR *ppwszProviderName,
      __out DWORD *pdwProviderType
      );

HRESULT DAPI FreeCryptProvFromCert(
    __in BOOL fAcquired,
    __in HCRYPTPROV hProv,
    __in_opt LPWSTR pwszCapiProvider,
    __in DWORD dwProviderType,
    __in_opt LPWSTR pwszTmpContainer
    );

HRESULT DAPI GetProvSecurityDesc(
      __in HCRYPTPROV hProv, 
      __deref_out SECURITY_DESCRIPTOR** pSecurity
      );

HRESULT DAPI SetProvSecurityDesc(
    __in HCRYPTPROV hProv,
    __in SECURITY_DESCRIPTOR* pSecurity
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\cabutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="cabutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for cabinet decompression helper functions
// </summary>
//-------------------------------------------------------------------------------------------------

#include <fdi.h>
#include <sys\stat.h>

#ifdef __cplusplus
extern "C" {
#endif

// structs


// callback function prototypes
typedef HRESULT (*CAB_CALLBACK_OPEN_FILE)(LPCWSTR wzFile, INT_PTR* ppFile);
typedef HRESULT (*CAB_CALLBACK_READ_FILE)(INT_PTR pFile, LPVOID pvData, DWORD cbData, DWORD* pcbRead);
typedef HRESULT (*CAB_CALLBACK_WRITE_FILE)(INT_PTR pFile, LPVOID pvData, DWORD cbData, DWORD* pcbRead);
typedef LONG (*CAB_CALLBACK_SEEK_FILE)(INT_PTR pFile, DWORD dwMove, DWORD dwMoveMethod);
typedef HRESULT (*CAB_CALLBACK_CLOSE_FILE)(INT_PTR pFile);

typedef HRESULT (*CAB_CALLBACK_BEGIN_FILE)(LPCWSTR wzFileId, FILETIME* pftFileTime, DWORD cbFileSize, LPVOID pvContext, INT_PTR* ppFile);
typedef HRESULT (*CAB_CALLBACK_END_FILE)(LPCWSTR wzFileId, LPVOID pvContext, INT_PTR pFile);
typedef HRESULT (*CAB_CALLBACK_PROGRESS)(BOOL fBeginFile, LPCWSTR wzFileId, LPVOID pvContext);

// function type with calling convention of __stdcall that .NET 1.1 understands only
// .NET 2.0 will not need this
typedef INT_PTR (FAR __stdcall *STDCALL_PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint, PFDINOTIFICATION pfdin);


// functions
HRESULT DAPI CabInitialize(
    __in BOOL fDelayLoad
    );
void DAPI CabUninitialize(
    );

HRESULT DAPI CabExtract(
    __in LPCWSTR wzCabinet,
    __in LPCWSTR wzExtractFile,
    __in LPCWSTR wzExtractDir,
    __in_opt CAB_CALLBACK_PROGRESS pfnProgress,
    __in_opt LPVOID pvContext,
    __in DWORD64 dw64EmbeddedOffset
    );

HRESULT DAPI CabEnumerate(
    __in LPCWSTR wzCabinet,
    __in LPCWSTR wzEnumerateFile,
    __in STDCALL_PFNFDINOTIFY pfnNotify,
    __in DWORD64 dw64EmbeddedOffset
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\IBurnCore.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="IBurnCore.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//      IBurnCore, implemented by engine(core) and used by Burn UX
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once

#define IDERROR -1
#define IDNOACTION 0

enum BURN_ACTION
{
    BURN_ACTION_UNKNOWN,
    BURN_ACTION_HELP,
    BURN_ACTION_UNINSTALL,
    BURN_ACTION_INSTALL,
    BURN_ACTION_MODIFY,
    BURN_ACTION_REPAIR,
};

enum ACTION_STATE
{
    ACTION_STATE_NONE,
    ACTION_STATE_UNINSTALL,
    ACTION_STATE_INSTALL,
    ACTION_STATE_ADMIN_INSTALL,
    ACTION_STATE_MAINTENANCE,
    ACTION_STATE_RECACHE,
    ACTION_STATE_MINOR_UPGRADE,
    ACTION_STATE_MAJOR_UPGRADE,
    ACTION_STATE_PATCH,
};

enum PACKAGE_STATE
{
    PACKAGE_STATE_UNKNOWN,
    PACKAGE_STATE_ABSENT,
    PACKAGE_STATE_CACHED,
    PACKAGE_STATE_PRESENT,
};

enum REQUEST_STATE
{
    REQUEST_STATE_NONE,
    REQUEST_STATE_ABSENT,
    REQUEST_STATE_CACHE,
    REQUEST_STATE_PRESENT,
    REQUEST_STATE_REPAIR,
};

enum BURN_LOG_LEVEL
{
    BURN_LOG_LEVEL_NONE,      // turns off report (only valid for XXXSetLevel())
    BURN_LOG_LEVEL_STANDARD,  // written if reporting is on
    BURN_LOG_LEVEL_VERBOSE,   // written only if verbose reporting is on
    BURN_LOG_LEVEL_DEBUG,     // reporting useful when debugging code
    BURN_LOG_LEVEL_ERROR,     // always gets reported, but can never be specified
};


struct __declspec(novtable) IBurnCore
{
public:
    virtual ~IBurnCore() {}
    //virtual HRESULT GetPackageCount(
    //    __out DWORD* pcPackages
    //    ) = 0;

    //HRESULT GetCommandLineParameters(
    //    __out LPWSTR* psczCommandLine
    //    ) PURE;

    virtual HRESULT __stdcall GetVariableNumeric(
        __in_z LPCWSTR wzVariable,
        __out LONGLONG* pllValue
        ) = 0;

    virtual HRESULT __stdcall GetVariableString(
        __in_z LPCWSTR wzVariable,
        __out_ecount_opt(*pcchValue) LPWSTR wzValue,
        __inout DWORD* pcchValue
        ) = 0;

    virtual HRESULT __stdcall GetVariableVersion(
        __in_z LPCWSTR wzVariable,
        __out DWORD64* pqwValue
        ) = 0;

    virtual HRESULT __stdcall SetVariableNumeric(
        __in_z LPCWSTR wzVariable,
        __in LONGLONG llValue
        ) = 0;

    virtual HRESULT __stdcall SetVariableString(
        __in_z LPCWSTR wzVariable,
        __in_z LPCWSTR wzValue
        ) = 0;

    virtual HRESULT __stdcall SetVariableVersion(
        __in_z LPCWSTR wzVariable,
        __in DWORD64 qwValue
        ) = 0;

    virtual HRESULT __stdcall FormatString(
        __in_z LPCWSTR wzIn,
        __out_ecount_opt(*pcchOut) LPWSTR wzOut,
        __inout DWORD* pcchOut
        ) = 0;

    virtual HRESULT __stdcall EscapeString(
        __in_z LPCWSTR wzIn,
        __out_ecount_opt(*pcchOut) LPWSTR wzOut,
        __inout DWORD* pcchOut
        ) = 0;

    virtual HRESULT __stdcall EvaluateCondition(
        __in_z LPCWSTR wzCondition,
        __out BOOL* pf
        ) = 0;

    virtual HRESULT __stdcall Log(
        __in BURN_LOG_LEVEL level,
        __in_z LPCWSTR wzMessage
        ) = 0;

    virtual HRESULT __stdcall Elevate(
        __in_opt HWND hwndParent
        ) = 0;

    virtual HRESULT __stdcall Detect() = 0;

    virtual HRESULT __stdcall Plan(
        __in BURN_ACTION action
        ) = 0;

    virtual HRESULT __stdcall Apply(
        __in_opt HWND hwndParent
        ) = 0;

    virtual HRESULT __stdcall Suspend() = 0;

    virtual HRESULT __stdcall Reboot() = 0;

    virtual HRESULT __stdcall SetSource(
        __in    LPCWSTR wzSourcePath
        ) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\gdiputil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="gdiputil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    GDI+ helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once

#define ExitOnGdipFailure(g, x, s) { x = GdipHresultFromStatus(g); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; } }
#define ExitOnGdipFailure1(g, x, f, s) { x = GdipHresultFromStatus(g); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; } }
#define ExitOnGdipFailure2(g, x, f, s, t) { x = GdipHresultFromStatus(g); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t); goto LExit; } }

#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI GdipBitmapFromResource(
    __in_opt HINSTANCE hinst,
    __in_z LPCSTR szId,
    __out Gdiplus::Bitmap **ppBitmap
    );

HRESULT DAPI GdipBitmapFromFile(
    __in_z LPCWSTR wzFileName,
    __out Gdiplus::Bitmap **ppBitmap
    );

HRESULT DAPI GdipHresultFromStatus(
    __in Gdiplus::Status gs
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\fileutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="fileutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for file helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseFile(h) if (INVALID_HANDLE_VALUE != h) { ::CloseHandle(h); h = INVALID_HANDLE_VALUE; }
#define ReleaseFileHandle(h) if (INVALID_HANDLE_VALUE != h) { ::CloseHandle(h); h = INVALID_HANDLE_VALUE; }
#define ReleaseFileFindHandle(h) if (INVALID_HANDLE_VALUE != h) { ::FindClose(h); h = INVALID_HANDLE_VALUE; }

enum FILE_ARCHITECTURE
{
    FILE_ARCHITECTURE_UNKNOWN,
    FILE_ARCHITECTURE_X86,
    FILE_ARCHITECTURE_X64,
    FILE_ARCHITECTURE_IA64,
};


LPWSTR DAPI FileFromPath(
    __in LPCWSTR wzPath
    );
HRESULT DAPI FileResolvePath(
    __in LPCWSTR wzRelativePath,
    __out LPWSTR *ppwzFullPath
    );
HRESULT DAPI FileStripExtension(
    __in LPCWSTR wzFileName,
    __out LPWSTR *ppwzFileNameNoExtension
    );
HRESULT DAPI FileChangeExtension(
    __in LPCWSTR wzFileName,
    __in LPCWSTR wzNewExtension,
    __out LPWSTR *ppwzFileNameNewExtension
    );
HRESULT DAPI FileAddSuffixToBaseName(
    __in_z LPCWSTR wzFileName,
    __in_z LPCWSTR wzSuffix,
    __out_z LPWSTR* psczNewFileName
    );
HRESULT DAPI FileVersionFromString(
    __in LPCWSTR wzVersion, 
    __out DWORD *pdwVerMajor, 
    __out DWORD* pdwVerMinor
    );
HRESULT DAPI FileVersionFromStringEx(
    __in LPCWSTR wzVersion,
    __in DWORD cchVersion,
    __out DWORD64* pqwVersion
    );
HRESULT DAPI FileSetPointer(
    __in HANDLE hFile,
    __in DWORD64 dw64Move,
    __out_opt DWORD64* pdw64NewPosition,
    __in DWORD dwMoveMethod
    );
HRESULT DAPI FileSize(
    __in LPCWSTR pwzFileName,
    __out LONGLONG* pllSize
    );
HRESULT DAPI FileSizeByHandle(
    __in HANDLE hFile, 
    __out LONGLONG* pllSize
    );
BOOL DAPI FileExistsEx(
    __in LPCWSTR wzPath, 
    __out_opt DWORD *pdwAttributes
    );
HRESULT DAPI FileRead(
    __deref_out_bcount_full(*pcbDest) LPBYTE* ppbDest,
    __out DWORD* pcbDest,
    __in LPCWSTR wzSrcPath
    );
HRESULT DAPI FileReadUntil(
    __deref_out_bcount_full(*pcbDest) LPBYTE* ppbDest,
    __out_range(<=, cbMaxRead) DWORD* pcbDest,
    __in LPCWSTR wzSrcPath,
    __in DWORD cbMaxRead
    );
HRESULT DAPI FileReadPartial(
    __deref_out_bcount_full(*pcbDest) LPBYTE* ppbDest,
    __out_range(<=, cbMaxRead) DWORD* pcbDest,
    __in LPCWSTR wzSrcPath,
    __in BOOL fSeek,
    __in DWORD cbStartPosition,
    __in DWORD cbMaxRead,
    __in BOOL fPartialOK
    );
HRESULT DAPI FileWrite(
    __in_z LPCWSTR pwzFileName,
    __in DWORD dwFlagsAndAttributes,
    __in_bcount(cbData) LPCBYTE pbData,
    __in DWORD cbData,
    __out_opt HANDLE* pHandle
    );
HRESULT DAPI FileWriteHandle(
    __in HANDLE hFile,
    __in_bcount(cbData) LPCBYTE pbData,
    __in DWORD cbData
    );
HRESULT DAPI FileEnsureCopy(
    __in LPCWSTR wzSource,
    __in LPCWSTR wzTarget,
    __in BOOL fOverwrite
    );
HRESULT DAPI FileEnsureMove(
    __in LPCWSTR wzSource, 
    __in LPCWSTR wzTarget, 
    __in BOOL fOverwrite,
    __in BOOL fAllowCopy
    );
HRESULT DAPI FileCreateTemp(
    __in LPCWSTR wzPrefix,
    __in LPCWSTR wzExtension,
    __deref_opt_out_z LPWSTR* ppwzTempFile,
    __out_opt HANDLE* phTempFile
    );
HRESULT DAPI FileCreateTempW(
    __in LPCWSTR wzPrefix,
    __in LPCWSTR wzExtension,
    __deref_opt_out_z LPWSTR* ppwzTempFile,
    __out_opt HANDLE* phTempFile
    );
HRESULT DAPI FileVersion(
    __in LPCWSTR wzFilename, 
    __out DWORD *pdwVerMajor, 
    __out DWORD* pdwVerMinor
    );
HRESULT DAPI FileIsSame(
    __in LPCWSTR wzFile1,
    __in LPCWSTR wzFile2,
    __out LPBOOL lpfSameFile
    );
HRESULT DAPI FileEnsureDelete(
    __in LPCWSTR wzFile
    );
HRESULT DAPI FileGetTime(
    __in LPCWSTR wzFile,  
    __out_opt  LPFILETIME lpCreationTime,
    __out_opt  LPFILETIME lpLastAccessTime,
    __out_opt  LPFILETIME lpLastWriteTime
    );
HRESULT DAPI FileSetTime(
    __in LPCWSTR wzFile,
    __in_opt  const FILETIME *lpCreationTime,
    __in_opt  const FILETIME *lpLastAccessTime,
    __in_opt  const FILETIME *lpLastWriteTime
    );
HRESULT DAPI FileResetTime(
    __in LPCWSTR wzFile
    );
HRESULT FileExecutableArchitecture(
    __in LPCWSTR wzFile,
    __out FILE_ARCHITECTURE *pArchitecture
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\dictutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="dictutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for string dict helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

typedef void* STRINGDICT_HANDLE;

HRESULT DAPI DictCreate(
    __out void **ppvHandle,
    __in DWORD dwNumExpectedItems,
    __in size_t cByteOffset
    );
HRESULT DAPI DictAdd(
    __in void *pvHandle,
    __in LPCWSTR szString,
    __in void *pvValue
    );
HRESULT DAPI DictGet(
    __in void *pvHandle,
    __in LPCWSTR szString,
    __out void **ppvValue
    );
void DAPI DictDestroy(
    __in void *pvHandle
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\dutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="dutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for utility layer that provides standard support for asserts, exit macros
// </summary>
//-------------------------------------------------------------------------------------------------

#define DAPI __stdcall
#define DAPIV __cdecl // used only for functions taking variable length arguments

#define DAPI_(type) EXTERN_C type DAPI
#define DAPIV_(type) EXTERN_C type DAPIV


// enums
enum REPORT_LEVEL
{
    REPORT_NONE,      // turns off report (only valid for XXXSetLevel())
    REPORT_STANDARD,  // written if reporting is on
    REPORT_VERBOSE,   // written only if verbose reporting is on
    REPORT_DEBUG,     // reporting useful when debugging code
    REPORT_ERROR,     // always gets reported, but can never be specified
};

// asserts and traces
#ifdef DEBUG

typedef BOOL (DAPI *DUTIL_ASSERTDISPLAYFUNCTION)(LPCSTR sz);

extern "C" void DAPI Dutil_SetAssertModule(__in HMODULE hAssertModule);
extern "C" void DAPI Dutil_SetAssertDisplayFunction(__in DUTIL_ASSERTDISPLAYFUNCTION pfn);
extern "C" void DAPI Dutil_Assert(const CHAR* szFile, int iLine);
extern "C" void DAPI Dutil_AssertSz(const CHAR* szFile, int iLine, const CHAR *szMsg);

extern "C" void DAPI Dutil_TraceSetLevel(__in REPORT_LEVEL ll, __in BOOL fTraceFilenames);
extern "C" REPORT_LEVEL DAPI Dutil_TraceGetLevel();
extern "C" void __cdecl Dutil_Trace(__in LPCSTR szFile, __in int iLine, __in REPORT_LEVEL rl, __in LPCSTR szMessage, ...);
extern "C" void __cdecl Dutil_TraceError(__in LPCSTR szFile, __in int iLine, __in REPORT_LEVEL rl, __in HRESULT hr, __in LPCSTR szMessage, ...);

#endif

extern "C" void DAPI Dutil_RootFailure(__in LPCSTR szFile, __in int iLine, __in HRESULT hrError);

#ifdef DEBUG

#define AssertSetModule(m) (void)Dutil_SetAssertModule(m)
#define AssertSetDisplayFunction(pfn) (void)Dutil_SetAssertDisplayFunction(pfn)
#define Assert(f)          ((f)    ? (void)0 : (void)Dutil_Assert(__FILE__, __LINE__))
#define AssertSz(f, sz)    ((f)    ? (void)0 : (void)Dutil_AssertSz(__FILE__, __LINE__, sz))

#define TraceSetLevel(l, f) (void)Dutil_TraceSetLevel(l, f)
#define TraceGetLevel() (REPORT_LEVEL)Dutil_TraceGetLevel()
#define Trace(l, f) (void)Dutil_Trace(__FILE__, __LINE__, l, f, NULL)
#define Trace1(l, f, s) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s)
#define Trace2(l, f, s, t) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s, t)
#define Trace3(l, f, s, t, u) (void)Dutil_Trace(__FILE__, __LINE__, l, f, s, t, u)

#define TraceError(x, f) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, NULL)
#define TraceError1(x, f, s) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s)
#define TraceError2(x, f, s, t) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s, t)
#define TraceError3(x, f, s, t, u) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_ERROR, x, f, s, t, u)

#define TraceErrorDebug(x, f) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, NULL)
#define TraceErrorDebug1(x, f, s) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s)
#define TraceErrorDebug2(x, f, s, t) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s, t)
#define TraceErrorDebug3(x, f, s, t, u) (void)Dutil_TraceError(__FILE__, __LINE__, REPORT_DEBUG, x, f, s, t, u)

#else // !DEBUG

#define AssertSetModule(m)
#define AssertSetDisplayFunction(pfn)
#define Assert(f)
#define AssertSz(f, sz)

#define TraceSetLevel(l, f)
#define Trace(l, f)
#define Trace1(l, f, s)
#define Trace2(l, f, s, t)
#define Trace3(l, f, s, t, u)

#define TraceError(x, f)
#define TraceError1(x, f, s)
#define TraceError2(x, f, s, t)
#define TraceError3(x, f, s, t, u)

#define TraceErrorDebug(x, f)
#define TraceErrorDebug1(x, f, s)
#define TraceErrorDebug2(x, f, s, t)
#define TraceErrorDebug3(x, f, s, t, u)

#endif // DEBUG


// ExitTrace can be overriden
#ifndef ExitTrace
#define ExitTrace TraceError
#endif
#ifndef ExitTrace1
#define ExitTrace1 TraceError1
#endif
#ifndef ExitTrace2
#define ExitTrace2 TraceError2
#endif
#ifndef ExitTrace3
#define ExitTrace3 TraceError3
#endif

// Exit macros
#define ExitFunction()        { goto LExit; }
#define ExitFunction1(x)          { x; goto LExit; }

#define ExitOnLastError(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; } }
#define ExitOnLastError1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; } }
#define ExitOnLastError2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t); goto LExit; } }

#define ExitOnLastErrorDebugTrace(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug(x, s); goto LExit; } }
#define ExitOnLastErrorDebugTrace1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug1(x, f, s); goto LExit; } }
#define ExitOnLastErrorDebugTrace2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug2(x, f, s, t); goto LExit; } }

#define ExitWithLastError(x, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitWithLastError1(x, f, s) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }
#define ExitWithLastError2(x, f, s, t) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t); goto LExit; }
#define ExitWithLastError3(x, f, s, t, u) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace3(x, f, s, t, u); goto LExit; }

#define ExitOnFailure(x, s)   if (FAILED(x)) { ExitTrace(x, s);  goto LExit; }
#define ExitOnFailure1(x, f, s)   if (FAILED(x)) { ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnFailure2(x, f, s, t)   if (FAILED(x)) { ExitTrace2(x, f, s, t);  goto LExit; }
#define ExitOnFailure3(x, f, s, t, u) if (FAILED(x)) { ExitTrace3(x, f, s, t, u);  goto LExit; }

#define ExitOnRootFailure(x, s)   if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s);  goto LExit; }
#define ExitOnRootFailure1(x, f, s)   if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnRootFailure2(x, f, s, t)   if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t);  goto LExit; }
#define ExitOnRootFailure3(x, f, s, t, u) if (FAILED(x)) { Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace3(x, f, s, t, u);  goto LExit; }

#define ExitOnFailureDebugTrace(x, s)   if (FAILED(x)) { TraceErrorDebug(x, s);  goto LExit; }
#define ExitOnFailureDebugTrace1(x, f, s)   if (FAILED(x)) { TraceErrorDebug1(x, f, s);  goto LExit; }
#define ExitOnFailureDebugTrace2(x, f, s, t)   if (FAILED(x)) { TraceErrorDebug2(x, f, s, t);  goto LExit; }
#define ExitOnFailureDebugTrace3(x, f, s, t, u) if (FAILED(x)) { TraceErrorDebug3(x, f, s, t, u);  goto LExit; }

#define ExitOnNull(p, x, e, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s);  goto LExit; }
#define ExitOnNull1(p, x, e, f, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s);  goto LExit; }
#define ExitOnNull2(p, x, e, f, s, t)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace2(x, f, s, t);  goto LExit; }

#define ExitOnNullWithLastError(p, x, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitOnNullWithLastError1(p, x, f, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }

#define ExitOnNullDebugTrace(p, x, e, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug(x, s);  goto LExit; }
#define ExitOnNullDebugTrace1(p, x, e, f, s)   if (NULL == p) { x = e; Dutil_RootFailure(__FILE__, __LINE__, x); TraceErrorDebug1(x, f, s);  goto LExit; }

#define ExitOnInvalidHandleWithLastError(p, x, s) if (INVALID_HANDLE_VALUE == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitOnInvalidHandleWithLastError1(p, x, f, s) if (INVALID_HANDLE_VALUE == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }

#define ExitOnWin32Error(e, x, s) if (ERROR_SUCCESS != e) { x = HRESULT_FROM_WIN32(e); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace(x, s); goto LExit; }
#define ExitOnWin32Error1(e, x, f, s) if (ERROR_SUCCESS != e) { x = HRESULT_FROM_WIN32(e); if (!FAILED(x)) { x = E_FAIL; } Dutil_RootFailure(__FILE__, __LINE__, x); ExitTrace1(x, f, s); goto LExit; }

// release macros
#define ReleaseObject(x) if (x) { x->Release(); }
#define ReleaseObjectArray(prg, cel) if (prg) { for (DWORD Dutil_ReleaseObjectArrayIndex = 0; Dutil_ReleaseObjectArrayIndex < cel; ++Dutil_ReleaseObjectArrayIndex) { ReleaseObject(prg[Dutil_ReleaseObjectArrayIndex]); } ReleaseMem(prg); }
#define ReleaseVariant(x) { ::VariantClear(&x); }
#define ReleaseNullObject(x) if (x) { (x)->Release(); x = NULL; }
#define ReleaseCertificate(x) if (x) { ::CertFreeCertificateContext(x); x=NULL; }


// useful defines and macros
#define Unused(x) ((void)x)

#ifndef countof
#if 1
#define countof(ary) (sizeof(ary) / sizeof(ary[0]))
#else
#ifndef __cplusplus
#define countof(ary) (sizeof(ary) / sizeof(ary[0]))
#else
template<typename T> static char countofVerify(void const *, T) throw() { return 0; }
template<typename T> static void countofVerify(T *const, T *const *) throw() {};
#define countof(arr) (sizeof(countofVerify(arr,&(arr))) * sizeof(arr)/sizeof(*(arr)))
#endif
#endif
#endif

#define roundup(x, n) roundup_typed(x, n, DWORD)
#define roundup_typed(x, n, t) (((t)(x) + ((t)(n) - 1)) & ~((t)(n) - 1))

#define HRESULT_FROM_RPC(x) ((HRESULT) ((x) | FACILITY_RPC))

#ifndef MAXSIZE_T
#define MAXSIZE_T ((SIZE_T)~((SIZE_T)0))
#endif

typedef const BYTE* LPCBYTE;

#define E_FILENOTFOUND HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
#define E_INVALIDSTATE HRESULT_FROM_WIN32(ERROR_INVALID_STATE)
#define E_MOREDATA HRESULT_FROM_WIN32(ERROR_MORE_DATA)
#define E_NOMOREITEMS HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
#define E_NOTFOUND HRESULT_FROM_WIN32(ERROR_NOT_FOUND)

#define AddRefAndRelease(x) { x->AddRef(); x->Release(); }

#define MAKEQWORDVERSION(mj, mi, b, r) (((DWORD64)MAKELONG(r, b)) | (((DWORD64)MAKELONG(mi, mj)) << 32))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\metautil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="metautil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    IIS Metabase helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <iadmw.h>
#include <iiscnfg.h>
#include <iwamreg.h>
#include <mddefw.h>

#ifdef __cplusplus
extern "C" {
#endif

// structs

// prototypes
HRESULT DAPI MetaFindWebBase(
	__in IMSAdminBaseW* piMetabase, 
	__in LPCWSTR wzIP, 
	__in int iPort, 
	__in LPCWSTR wzHeader,
	__in BOOL fSecure,
	__out_ecount(cchWebBase) LPWSTR wzWebBase, 
	__in DWORD cchWebBase
	);
HRESULT DAPI MetaFindFreeWebBase(
	__in IMSAdminBaseW* piMetabase, 
	__out_ecount(cchWebBase) LPWSTR wzWebBase, 
	__in DWORD cchWebBase
	);

HRESULT DAPI MetaOpenKey(
	__in IMSAdminBaseW* piMetabase, 
	__in METADATA_HANDLE mhKey, 
	__in LPCWSTR wzKey,
	__in DWORD dwAccess,
	__in DWORD cRetries,
	__out METADATA_HANDLE* pmh
	);
HRESULT DAPI MetaGetValue(
	__in IMSAdminBaseW* piMetabase, 
	__in METADATA_HANDLE mhKey, 
	__in LPCWSTR wzKey, 
	__inout METADATA_RECORD* pmr
	);
void DAPI MetaFreeValue(
	__in METADATA_RECORD* pmr
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\inetutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="inetutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Internet utilites.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseInternet(h) if (h) { ::InternetCloseHandle(h); h = NULL; }
#define ReleaseNullInternet(h) if (h) { ::InternetCloseHandle(h); h = NULL; }


// functions
HRESULT DAPI InternetGetSizeByHandle(
    __in HINTERNET hiFile,
    __out LONGLONG* pllSize
    );

HRESULT DAPI InternetGetCreateTimeByHandle(
    __in HINTERNET hiFile,
    __out LPFILETIME pft
    );

HRESULT DAPI InternetQueryInfoString(
    __in HINTERNET h,
    __in DWORD dwInfo,
    __deref_out_z LPWSTR* psczValue
    );

HRESULT DAPI InternetQueryInfoNumber(
    __in HINTERNET h,
    __in DWORD dwInfo,
    __out LONG* plInfo
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\IBurnUserExperience.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="IBurnUserExperience.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//      IBurnUserExperience, implemented by Burn UX and used by Burn engine/core.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


enum BURN_DISPLAY
{
    BURN_DISPLAY_UNKNOWN,
    BURN_DISPLAY_NONE,
    BURN_DISPLAY_PASSIVE,
    BURN_DISPLAY_FULL,
};


enum BURN_RESTART
{
    BURN_RESTART_UNKNOWN,
    BURN_RESTART_NEVER,
    BURN_RESTART_PROMPT,
    BURN_RESTART_AUTOMATIC,
    BURN_RESTART_ALWAYS,
};


enum BURN_RESUME_TYPE
{
    BURN_RESUME_TYPE_NONE,
    BURN_RESUME_TYPE_INVALID,        // resume information is present but invalid
    BURN_RESUME_TYPE_UNEXPECTED,     // relaunched after an unexpected interruption
    BURN_RESUME_TYPE_REBOOT_PENDING, // reboot has not taken place yet
    BURN_RESUME_TYPE_REBOOT,         // relaunched after reboot
    BURN_RESUME_TYPE_SUSPEND,        // relaunched after suspend
    BURN_RESUME_TYPE_ARP,            // launched from ARP
};


struct BURN_COMMAND
{
    BURN_ACTION action;
    BURN_DISPLAY display;
    BURN_RESTART restart;

    BOOL fResumed;
};


struct __declspec(novtable) IBurnUserExperience
{
public:
    virtual ~IBurnUserExperience() {}

    virtual HRESULT __stdcall Initialize(
        __in IBurnCore* pCore,
        __in int nCmdShow,
        __in BURN_RESUME_TYPE resumeType
        ) = 0;

    virtual HRESULT __stdcall Run() = 0;

    virtual void __stdcall Uninitialize() = 0;

    virtual int __stdcall OnDetectBegin(
        __in DWORD cPackages
        ) = 0;

    virtual int __stdcall OnDetectPackageBegin(
        __in_z LPCWSTR wzPackageId
        ) = 0;

    virtual void __stdcall OnDetectPackageComplete(
        __in LPCWSTR wzPackageId,
        __in HRESULT hrStatus,
        __in PACKAGE_STATE state
        ) = 0;

    virtual void __stdcall OnDetectComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual int __stdcall OnPlanBegin(
        __in DWORD cPackages
        ) = 0;

    virtual int __stdcall OnPlanPackageBegin(
        __in_z LPCWSTR wzPackageId,
        __inout_z REQUEST_STATE* pRequestedState
        ) = 0;

    virtual void __stdcall OnPlanPackageComplete(
        __in LPCWSTR wzPackageId,
        __in HRESULT hrStatus,
        __in PACKAGE_STATE state,
        __in REQUEST_STATE requested,
        __in ACTION_STATE execute,
        __in ACTION_STATE rollback
        ) = 0;

    virtual void __stdcall OnPlanComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual int __stdcall OnApplyBegin() = 0;

    virtual int __stdcall OnRegisterBegin() = 0;

    virtual void __stdcall OnRegisterComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual void __stdcall OnUnregisterBegin() = 0;

    virtual void __stdcall OnUnregisterComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual void __stdcall OnCacheComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual int __stdcall OnExecuteBegin(
        __in DWORD cExecutingPackages
        ) = 0;

    virtual int __stdcall  OnExecutePackageBegin(
        __in LPCWSTR wzPackageId,
        __in BOOL fExecute
        ) = 0;

    virtual int __stdcall OnError(
        __in LPCWSTR wzPackageId,
        __in DWORD dwCode,
        __in_z LPCWSTR wzError,
        __in DWORD dwUIHint
        ) = 0;

    virtual int __stdcall OnProgress(
        __in DWORD dwProgressPercentage,
        __in DWORD dwOverallPercentage
        ) = 0;

    virtual int __stdcall OnExecuteMsiMessage(
        __in_z LPCWSTR wzPackageId,
        __in INSTALLMESSAGE mt,
        __in UINT uiFlags,
        __in_z LPCWSTR wzMessage
        ) = 0;

    virtual int __stdcall OnExecuteMsiFilesInUse(
        __in_z LPCWSTR wzPackageId,
        __in DWORD cFiles,
        __in LPCWSTR* rgwzFiles
        ) = 0;

    virtual void __stdcall OnExecutePackageComplete(
        __in LPCWSTR wzPackageId,
        __in HRESULT hrExitCode
        ) = 0;

    virtual void __stdcall OnExecuteComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual BOOL __stdcall OnRestartRequired() = 0;

    virtual void __stdcall OnApplyComplete(
        __in HRESULT hrStatus
        ) = 0;

    virtual int __stdcall ResolveSource (
        __in    LPCWSTR wzPackageId ,
        __in    LPCWSTR wzPackageOrContainerPath
        ) = 0;

    virtual BOOL __stdcall CanPackagesBeDownloaded(void) = 0;

}; //struct IBurnUserExperience


extern "C" typedef HRESULT (WINAPI *PFN_CREATE_USER_EXPERIENCE)(
    __in BURN_COMMAND* pCommand,
    __out IBurnUserExperience** ppUX
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\locutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="locutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for localization helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

struct LOC_STRING
{
    LPWSTR wzID;
    LPWSTR wzText;
    BOOL bOverridable;
};

struct LOC_STRINGSET
{
    DWORD cLocStrings;
    LOC_STRING* rgLocStrings;
};

HRESULT DAPI LocLoadFromFile(
    __in LPCWSTR wzWxlFile,
    __out LOC_STRINGSET** ppLocStringSet
    );

HRESULT DAPI LocLocalizeString(
    __in const LOC_STRINGSET* pLocStringSet,
    __inout LPWSTR* ppInput
    );

void DAPI LocFree(
    __in_opt LOC_STRINGSET* pLocStringSet
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\osutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="osutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Operating system helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

enum OS_VERSION
{
    OS_VERSION_UNKNOWN,
    OS_VERSION_WINNT,
    OS_VERSION_WIN2000,
    OS_VERSION_WINXP,
    OS_VERSION_WIN2003,
    OS_VERSION_VISTA,
    OS_VERSION_WIN2008,
    OS_VERSION_WIN7,
    OS_VERSION_WIN2008_R2,
    OS_VERSION_FUTURE
};

void DAPI OsGetVersion(
    __out OS_VERSION* pVersion,
    __out DWORD* pdwServicePack
    );
HRESULT OsIsRunningPrivileged(
    __out BOOL* pfPrivileged
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\perfutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="perfutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Performance helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

// structs


// functions
void DAPI PerfInitialize(
	);
void DAPI PerfClickTime(
	__out_opt LARGE_INTEGER* pliElapsed
	);
double DAPI PerfConvertToSeconds(
	__in const LARGE_INTEGER* pli
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\memutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="memutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for memory helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseMem(p) if (p) { MemFree(p); }
#define ReleaseNullMem(p) if (p) { MemFree(p); p = NULL; }

#define MEM_ENSURE_ARRAY_SIZE(type, pointer, count, max, grow, hresult, errMsg) \
    if (max <= count) { \
        LPVOID pv = NULL; DWORD cNewMax = count + grow; \
        if (0 == max) pv = MemAlloc(sizeof(type) * cNewMax, TRUE); else pv = MemReAlloc(pointer, sizeof(type) * cNewMax, TRUE); \
        ExitOnNull(pv, hresult, E_OUTOFMEMORY, errMsg); \
        max = cNewMax; pointer = static_cast<type*>(pv); \
    }

HRESULT DAPI MemInitialize();
void DAPI MemUninitialize();

LPVOID DAPI MemAlloc(
    __in SIZE_T cbSize,
    __in BOOL fZero
    );
LPVOID DAPI MemReAlloc(
    __in LPVOID pv,
    __in SIZE_T cbSize,
    __in BOOL fZero
    );

HRESULT DAPI MemFree(
    __in LPVOID pv
    );
SIZE_T DAPI MemSize(
    __in LPCVOID pv
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\procutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="procutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for proces helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ProcExecute(
    __in LPWSTR wzCommand,
    __out HANDLE *phProcess,
    __out_opt HANDLE *phChildStdIn,
    __out_opt HANDLE *phChildStdOutErr
    );
HRESULT DAPI ProcWaitForCompletion(
    __in HANDLE hProcess,
    __in DWORD dwTimeout,
    __out DWORD *pReturnCode
    );
HRESULT DAPI ProcWaitForIds(
    __in_ecount(cProcessIds) const DWORD* pdwProcessIds,
    __in DWORD cProcessIds,
    __in DWORD dwMilliseconds
    );
HRESULT DAPI ProcCloseIds(
    __in_ecount(cProcessIds) const DWORD* pdwProcessIds,
    __in DWORD cProcessIds
    );

// following code in proc2utl.cpp due to dependency on PSAPI.DLL.
HRESULT DAPI ProcFindAllIdsFromExeName(
    __in LPCWSTR wzExeName,
    __out DWORD** ppdwProcessIds,
    __out DWORD* pcProcessIds
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\resrutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="resrutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Resource read helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ResGetStringLangId(
    __in_opt LPCWSTR wzPath,
    __in UINT uID,
    __out WORD *pwLangId
    );

HRESULT DAPI ResReadString(
    __in HINSTANCE hinst,
    __in UINT uID,
    __deref_out_z LPWSTR* ppwzString
    );

HRESULT DAPI ResReadStringAnsi(
    __in HINSTANCE hinst,
    __in UINT uID,
    __deref_out_z LPSTR* ppszString
    );

HRESULT DAPI ResReadData(
    __in_opt HINSTANCE hinst,
    __in LPCSTR szDataName,
    __deref_out_bcount(*pcb) PVOID *ppv,
    __out DWORD *pcb
    );

HRESULT DAPI ResExportDataToFile(
    __in LPCSTR szDataName,
    __in LPCWSTR wzTargetFile,
    __in DWORD dwCreationDisposition
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\pathutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="pathutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for path helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

enum PATH_EXPAND
{
    PATH_EXPAND_ENVIRONMENT = 0x0001,
    PATH_EXPAND_FULLPATH    = 0x0002,
};

LPWSTR DAPI PathFile(
    __in LPCWSTR wzPath
    );
HRESULT DAPI PathGetDirectory(
    __in LPCWSTR wzPath,
    __out LPWSTR *psczDirectory
    );
HRESULT DAPI PathExpand(
    __out LPWSTR *psczFullPath,
    __in LPCWSTR wzRelativePath,
    __in DWORD dwResolveFlags
    );
HRESULT DAPI PathPrefix(
    __inout LPWSTR *psczFullPath
    );
HRESULT DAPI PathBackslashTerminate(
    __inout LPWSTR* psczPath
    );
HRESULT DAPI PathFixedBackslashTerminate(
    __inout_ecount_z(cchPath) LPWSTR wzPath,
    __in DWORD_PTR cchPath
    );
HRESULT DAPI PathForCurrentProcess(
    __inout LPWSTR *psczFullPath,
    __in_opt HMODULE hModule
    );
HRESULT DAPI PathRelativeToModule(
    __inout LPWSTR *psczFullPath,
    __in_opt LPCWSTR wzFileName,
    __in_opt HMODULE hModule
    );
HRESULT DAPI PathCreateTempFile(
    __in_opt LPCWSTR wzDirectory,
    __in_opt __format_string LPCWSTR wzFileNameTemplate,
    __in DWORD dwUniqueCount,
    __in DWORD dwFileAttributes,
    __out_opt LPWSTR* psczTempFile,
    __out_opt HANDLE* phTempFile
    );
HRESULT DAPI PathCreateTempDirectory(
    __in_opt LPCWSTR wzDirectory,
    __in __format_string LPCWSTR wzDirectoryNameTemplate,
    __in DWORD dwUniqueCount,
    __out LPWSTR* psczTempDirectory
    );
HRESULT DAPI PathGetKnownFolder(
    __in int csidl,
    __out LPWSTR* psczKnownFolder
    );
BOOL DAPI PathIsAbsolute(
    __in LPCWSTR wzPath
    );
HRESULT DAPI PathConcat(
    __in_opt LPCWSTR wzPath1,
    __in_opt LPCWSTR wzPath2,
    __out LPWSTR* psczCombined
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\reswutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="reswutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Resource writer helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ResWriteString(
    __in LPCWSTR wzResourceFile,
    __in DWORD dwDataId,
    __in LPCWSTR wzData,
    __in WORD wLangId
    );

HRESULT DAPI ResWriteData(
    __in LPCWSTR wzResourceFile,
    __in LPCSTR szDataName,
    __in PVOID pData,
    __in DWORD cbData
    );

HRESULT DAPI ResImportDataFromFile(
    __in LPCWSTR wzTargetFile,
    __in LPCWSTR wzSourceFile,
    __in LPCSTR szDataName
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\rssutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="rssutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    RSS helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseRssChannel(p) if (p) { RssFreeChannel(p); }
#define ReleaseNullRssChannel(p) if (p) { RssFreeChannel(p); p = NULL; }


struct RSS_UNKNOWN_ATTRIBUTE
{
    LPWSTR wzNamespace;
    LPWSTR wzAttribute;
    LPWSTR wzValue;

    RSS_UNKNOWN_ATTRIBUTE* pNext;
};

struct RSS_UNKNOWN_ELEMENT
{
    LPWSTR wzNamespace;
    LPWSTR wzElement;
    LPWSTR wzValue;

    RSS_UNKNOWN_ATTRIBUTE* pAttributes;
    RSS_UNKNOWN_ELEMENT* pNext;
};

struct RSS_ITEM
{
    LPWSTR wzTitle;
    LPWSTR wzLink;
    LPWSTR wzDescription;

    LPWSTR wzGuid;
    FILETIME ftPublished;

    LPWSTR wzEnclosureUrl;
    DWORD dwEnclosureSize;
    LPWSTR wzEnclosureType;

    RSS_UNKNOWN_ELEMENT* pUnknownElements;
};

struct RSS_CHANNEL
{
    LPWSTR wzTitle;
    LPWSTR wzLink;
    LPWSTR wzDescription;
    DWORD dwTimeToLive;

    RSS_UNKNOWN_ELEMENT* pUnknownElements;

    DWORD cItems;
    RSS_ITEM rgItems[1];
};

HRESULT DAPI RssInitialize(
    );

void DAPI RssUninitialize(
    );

HRESULT DAPI RssParseFromString(
    __in LPCWSTR wzRssString,
    __out RSS_CHANNEL **ppChannel
    );

HRESULT DAPI RssParseFromFile(
    __in LPCWSTR wzRssFile,
    __out RSS_CHANNEL **ppChannel
    );

// Adding this until we have the updated specstrings.h
#ifndef __in_xcount
#define __in_xcount(size) 
#endif

void DAPI RssFreeChannel(
    __in_xcount(pChannel->cItems) RSS_CHANNEL *pChannel
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\timeutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="timeutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//  Time helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI TimeFromString(
	__in LPCWSTR wzTime,
	__out FILETIME* pFileTime
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\logutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="logutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for string helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define LogExitOnFailure(x, i, f) if (FAILED(x)) { LogErrorId(x, i, NULL, NULL, NULL); ExitTrace(x, f); goto LExit; }
#define LogExitOnFailure1(x, i, f, s) if (FAILED(x)) { LogErrorId(x, i, s, NULL, NULL); ExitTrace1(x, f, s); goto LExit; }
#define LogExitOnFailure2(x, i, f, s, t) if (FAILED(x)) { LogErrorId(x, i, s, t, NULL); ExitTrace2(x, f, s, t); goto LExit; }
#define LogExitOnFailure3(x, i, f, s, t, u) if (FAILED(x)) { LogErrorId(x, i, s, t, u); ExitTrace3(x, f, s, t, u); goto LExit; }

// enums

// structs

// functions
BOOL DAPI IsLogInitialized();

HRESULT DAPI LogInitialize(
    __in HMODULE hModule,
    __in_z LPCWSTR wzLog,
    __in_z_opt LPCWSTR wzExt,
    __in BOOL fAppend,
    __in BOOL fHeader
    );

void DAPI LogUninitialize(
    __in BOOL fFooter
    );

BOOL DAPI LogIsOpen();

REPORT_LEVEL DAPI LogSetLevel(
    __in REPORT_LEVEL rl,
    __in BOOL fLogChange
    );

REPORT_LEVEL DAPI LogGetLevel();

HRESULT DAPI LogGetPath(
    __out_ecount_z(cchLogPath) LPWSTR pwzLogPath, 
    __in DWORD cchLogPath
    );

HANDLE DAPI LogGetHandle();

HRESULT DAPIV LogString(
    __in REPORT_LEVEL rl,
    __format_string LPCWSTR wzFormat,
    ...
    );

HRESULT DAPI LogStringArgs(
    __in REPORT_LEVEL rl,
    __format_string LPCWSTR wzFormat,
    __in va_list args
    );

HRESULT DAPIV LogStringLine(
    __in REPORT_LEVEL rl,
    __format_string LPCWSTR wzFormat,
    ...
    );

HRESULT DAPI LogStringLineArgs(
    __in REPORT_LEVEL rl,
    __format_string LPCWSTR wzFormat,
    __in va_list args
    );

HRESULT DAPI LogIdModuleArgs(
    __in REPORT_LEVEL rl,
    __in DWORD dwLogId,
    __in_opt HMODULE hModule,
    __in va_list args
    );

/* 
 * Wraps LogIdModuleArgs, so inline to save the function call
 */

inline HRESULT LogId(
    __in REPORT_LEVEL rl,
    __in DWORD dwLogId,
    ...
    )
{
    HRESULT hr = S_OK;
    va_list args;

    va_start(args, dwLogId);
    hr = LogIdModuleArgs(rl, dwLogId, NULL, args);
    va_end(args);

    return hr;
}


/* 
 * Wraps LogIdModuleArgs, so inline to save the function call
 */
 
inline HRESULT LogIdArgs(
    __in REPORT_LEVEL rl,
    __in DWORD dwLogId,
    __in va_list args
    )
{
    return LogIdModuleArgs(rl, dwLogId, NULL, args);
}

HRESULT DAPIV LogErrorString(
    __in HRESULT hrError,
    __format_string LPCWSTR wzFormat,
    ...
    );

HRESULT DAPI LogErrorStringArgs(
    __in HRESULT hrError,
    __format_string LPCWSTR wzFormat,
    __in va_list args
    );

HRESULT DAPI LogErrorIdModule(
    __in HRESULT hrError,
    __in DWORD dwLogId,
    __in_opt HMODULE hModule,
    __in_z_opt LPCWSTR wzString1,
    __in_z_opt LPCWSTR wzString2,
    __in_z_opt LPCWSTR wzString3
    );

inline HRESULT LogErrorId(
    __in HRESULT hrError,
    __in DWORD dwLogId,
    __in LPCWSTR wzString1,
    __in LPCWSTR wzString2,
    __in LPCWSTR wzString3
    )
{
    return LogErrorIdModule(hrError, dwLogId, NULL, wzString1, wzString2, wzString3);
}

HRESULT DAPI LogHeader();

HRESULT DAPI LogFooter();

// begin the switch of LogXXX to LogStringXXX
#define Log LogString
#define LogLine LogStringLine

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\rexutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="rexutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Resource Cabinet Extract Utilities
// </summary>
//-------------------------------------------------------------------------------------------------

#include <sys\stat.h>
#include <fdi.h>

#ifdef __cplusplus
extern "C" {
#endif

// defines
#define FILETABLESIZE 40

// structs
struct MEM_FILE 
{
    LPCBYTE vpStart;
    UINT  uiCurrent;
    UINT  uiLength;
};

typedef enum { NORMAL_FILE, MEMORY_FILE } FAKE_FILE_TYPE;

typedef HRESULT (*REX_CALLBACK_PROGRESS)(BOOL fBeginFile, LPCWSTR wzFileId, LPVOID pvContext);
typedef VOID (*REX_CALLBACK_WRITE)(UINT cb);


struct FAKE_FILE // used __in internal file table
{
    BOOL fUsed;
    FAKE_FILE_TYPE fftType;
    MEM_FILE mfFile; // State for memory file
    HANDLE hFile; // Handle for disk  file
};

// functions
HRESULT RexInitialize();
void RexUninitialize();

HRESULT RexExtract(
    __in LPCSTR szResource,
    __in LPCWSTR wzExtractId,
    __in LPCWSTR wzExtractDir,
    __in LPCWSTR wzExtractName,
    __in REX_CALLBACK_PROGRESS pfnProgress,
    __in REX_CALLBACK_WRITE pfnWrite,
    __in LPVOID pvContext
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\uriutil.h ===
//-------------------------------------------------------------------------------------------------
// <copyright file="uriutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    URI helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#pragma once


#ifdef __cplusplus
extern "C" {
#endif

enum URI_PROTOCOL
{
    URI_PROTOCOL_UNKNOWN,
    URI_PROTOCOL_FILE,
    URI_PROTOCOL_FTP,
    URI_PROTOCOL_HTTP,
    URI_PROTOCOL_LOCAL,
    URI_PROTOCOL_UNC
};


HRESULT DAPI UriCanonicalize(
    __inout_z LPWSTR* psczUri
    );

HRESULT DAPI UriCrack(
    __in_z LPCWSTR wzUri,
    __out_opt INTERNET_SCHEME* pScheme,
    __inout_z_opt LPWSTR* psczHostName,
    __out_opt INTERNET_PORT* pPort,
    __inout_z_opt LPWSTR* psczUser,
    __inout_z_opt LPWSTR* psczPassword,
    __inout_z_opt LPWSTR* psczPath,
    __inout_z_opt LPWSTR* psczQueryString
    );

HRESULT DAPI UriCreate(
    __inout_z LPWSTR* psczUri,
    __in INTERNET_SCHEME scheme,
    __in_z_opt LPWSTR wzHostName,
    __in INTERNET_PORT port,
    __in_z_opt LPWSTR wzUser,
    __in_z_opt LPWSTR wzPassword,
    __in_z_opt LPWSTR wzPath,
    __in_z_opt LPWSTR wzQueryString
    );

HRESULT DAPI UriCanonicalize(
    __inout_z LPWSTR* psczUri
    );

HRESULT DAPI UriFile(
    __deref_out_z LPWSTR* psczFile,
    __in LPCWSTR wzUri
    );

HRESULT DAPI UriProtocol(
    __in LPCWSTR wzUri,
    __out URI_PROTOCOL* pProtocol
    );

HRESULT DAPI UriRoot(
    __in LPCWSTR wzUri,
    __out LPWSTR* ppwzRoot,
    __out_opt URI_PROTOCOL* pProtocol
    );

HRESULT DAPI UriResolve(
    __in LPCWSTR wzUri,
    __in_opt LPCWSTR wzBaseUri,
    __out LPWSTR* ppwzResolvedUri,
    __out_opt const URI_PROTOCOL* pResolvedProtocol
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\thmutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="thmutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//  Theme helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

enum THEME_CONTROL_DATA
{
    THEME_CONTROL_DATA_HOVER = 1,
};

enum THEME_CONTROL_TYPE
{
    THEME_CONTROL_TYPE_UNKNOWN,
    THEME_CONTROL_TYPE_BUTTON,
    THEME_CONTROL_TYPE_CHECKBOX,
    THEME_CONTROL_TYPE_EDITBOX,
    THEME_CONTROL_TYPE_HYPERLINK,
    THEME_CONTROL_TYPE_IMAGE,
    THEME_CONTROL_TYPE_PROGRESSBAR,
    THEME_CONTROL_TYPE_RICHEDIT,
    THEME_CONTROL_TYPE_STATIC,
    THEME_CONTROL_TYPE_TEXT,
};

struct THEME_CONTROL
{
    THEME_CONTROL_TYPE type;

    LPWSTR wzText;
    int nX;
    int nY;
    int nHeight;
    int nWidth;
    int nSourceX;
    int nSourceY;

    DWORD dwStyle;
    DWORD dwFontId;
    DWORD dwFontHoverId;
    DWORD dwFontSelectedId;
    HWND hWnd;
};


struct THEME_FONT
{
    HFONT hFont;
    COLORREF crForeground;
    HBRUSH hForeground;
    COLORREF crBackground;
    HBRUSH hBackground;
};


struct THEME
{
    DWORD dwStyle;
    DWORD dwFontId;
    HANDLE hIcon;
    LPWSTR wzCaption;
    int nHeight;
    int nWidth;
    int nSourceX;
    int nSourceY;

    HBITMAP hImage;

    DWORD cFonts;
    THEME_FONT* rgFonts;

    DWORD cControls;
    THEME_CONTROL* rgControls;

    // state variables that should be ignored
    HWND hwndHover; // currently 
};


HRESULT DAPI ThemeInitialize(
    __in HMODULE hModule
    );

void DAPI ThemeUninitialize();

HRESULT DAPI ThemeLoadFromFile(
    __in LPCWSTR wzThemeFile,
    __out THEME** ppTheme
    );

HRESULT DAPI ThemeLoadFromResource(
    __in_opt HMODULE hModule,
    __in LPCSTR szResource,
    __out THEME** ppTheme
    );

void DAPI ThemeFree(
    __in THEME* pTheme
    );

HRESULT DAPI ThemeLoadControls(
    __in THEME* pTheme,
    __in HWND hwndParent
    );

HRESULT DAPI ThemeDrawBackground(
    __in THEME* pTheme,
    __in PAINTSTRUCT* pps
    );

HRESULT DAPI ThemeDrawControl(
    __in THEME* pTheme,
    __in DRAWITEMSTRUCT* pdis
    );

void DAPI ThemeHoverControl(
    __in THEME* pTheme,
    __in HWND hwndParent,
    __in HWND hwndControl
    );

BOOL DAPI ThemeIsControlChecked(
    __in THEME* pTheme,
    __in DWORD dwControl
    );

BOOL DAPI ThemeSetControlColor(
    __in THEME* pTheme,
    __in HDC hdc,
    __in HWND hWnd,
    __out HBRUSH* phBackgroundBrush
    );

HRESULT DAPI ThemeSetProgressControl(
    __in THEME* pTheme,
    __in DWORD dwControl,
    __in DWORD dwProgressPercentage
    );

HRESULT DAPI ThemeSetProgressControlColor(
    __in THEME* pTheme,
    __in DWORD dwControl,
    __in DWORD dwColorIndex
    );

HRESULT DAPI ThemeSetTextControl(
    __in THEME* pTheme,
    __in DWORD dwControl,
    __in_z LPCWSTR wzText
    );

HRESULT DAPI ThemeGetTextControl(
    __in const THEME* pTheme,
    __in DWORD dwControl,
    __out LPWSTR* psczText
    );

HRESULT DAPI ThemeLoadRichEditFromFile(
    __in THEME* pTheme,
    __in DWORD dwControl,
    __in_z LPCWSTR wzFileName, 
    __in HMODULE hModule
    );

HRESULT DAPI ThemeLoadLocFromFile(
    __in THEME* pTheme,
    __in_z LPCWSTR wzFileName,
    __in HMODULE hModule
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\shelutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="shelutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for proces helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifndef REFKNOWNFOLDERID
#define REFKNOWNFOLDERID REFGUID
#endif

#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI ShelExec(
    __in LPCWSTR wzTargetPath,
    __in_opt LPCWSTR wzParameters,
    __in_opt LPCWSTR wzVerb,
    __in_opt LPCWSTR wzWorkingDirectory,
    __in int nShowCmd,
    __out_opt HINSTANCE* phInstance
    );

HRESULT DAPI ShelGetFolder(
    __out_z LPWSTR* psczFolderPath,
    __in int csidlFolder
    );

HRESULT DAPI ShelGetKnownFolder(
    __out_z LPWSTR* psczFolderPath,
    __in REFKNOWNFOLDERID rfidFolder
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\sqlutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="sqlutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    SQL helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#include <cguid.h>
#include <oledberr.h>
#include <sqloledb.h>


#ifdef __cplusplus
extern "C" {
#endif

// Adding this until the SQL annotations are published to specstrings.h
#ifndef __sql_command
#define __sql_command
#endif

// structs
struct SQL_FILESPEC
{
	WCHAR wzName[MAX_PATH];
	WCHAR wzFilename[MAX_PATH];
	WCHAR wzSize[MAX_PATH];
	WCHAR wzMaxSize[MAX_PATH];
	WCHAR wzGrow[MAX_PATH];
};


// functions
HRESULT DAPI SqlConnectDatabase(
	__in LPCWSTR wzServer, 
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase, 
	__in BOOL fIntegratedAuth, 
	__in LPCWSTR wzUser, 
	__in LPCWSTR wzPassword, 
	__out IDBCreateSession** ppidbSession
	);
HRESULT DAPI SqlStartTransaction(
	__in IDBCreateSession* pidbSession,
	__out IDBCreateCommand** ppidbCommand,
	__out ITransaction** ppit
	);
HRESULT DAPI SqlEndTransaction(
	__in ITransaction* pit,
	__in BOOL fCommit
	);
HRESULT DAPI SqlDatabaseExists(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDatabaseExists(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlDatabaseEnsureExists(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__in_opt const SQL_FILESPEC* psfDatabase,
	__in_opt const SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDatabaseEnsureExists(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__in_opt const SQL_FILESPEC* psfDatabase,
	__in_opt const SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlCreateDatabase(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__in_opt const SQL_FILESPEC* psfDatabase,
	__in_opt const SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionCreateDatabase(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__in_opt const SQL_FILESPEC* psfDatabase,
	__in_opt const SQL_FILESPEC* psfLog,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlDropDatabase(
	__in LPCWSTR wzServer,
	__in LPCWSTR wzInstance,
	__in LPCWSTR wzDatabase,
	__in BOOL fIntegratedAuth,
	__in LPCWSTR wzUser,
	__in LPCWSTR wzPassword,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionDropDatabase(
	__in IDBCreateSession* pidbSession,
	__in LPCWSTR wzDatabase,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlSessionExecuteQuery(
	__in IDBCreateSession* pidbSession, 
	__in __sql_command LPCWSTR wzSql, 
	__out_opt IRowset** ppirs,
	__out_opt DBROWCOUNT* pcRows,
	__out_opt BSTR* pbstrErrorDescription
	);
HRESULT DAPI SqlCommandExecuteQuery(
	__in IDBCreateCommand* pidbCommand, 
	__in __sql_command LPCWSTR wzSql, 
	__out IRowset** ppirs,
	__out DBROWCOUNT* pcRows
	);
HRESULT DAPI SqlGetErrorInfo(
	__in IUnknown* pObjectWithError,
	__in REFIID IID_InterfaceWithError,
	__in DWORD dwLocaleId,
	__out_opt BSTR* pbstrErrorSource,
	__out_opt BSTR* pbstrErrorDescription
	);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\wcawrapquery.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcawrapquery.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library wrappers meant to wrap an MSI view as
//    opened by an immediate custom action and transmit it to a deferred custom action
// </summary>
//-------------------------------------------------------------------------------------------------

#include "wcautil.h"

// Enumerations
enum eWrapQueryAction
{
    wqaTableBegin = 1,
    wqaTableFinish,
    wqaRowBegin,
    wqaRowFinish
};

enum eColumnDataType
{
    cdtString = 1,
    cdtInt,
    cdtStream,
    cdtUnknown
};

enum eFormatMaskColumn
{
    efmcColumn1 = 1,
    efmcColumn2 = 1 << 1,
    efmcColumn3 = 1 << 2,
    efmcColumn4 = 1 << 3,
    efmcColumn5 = 1 << 4,
    efmcColumn6 = 1 << 5,
    efmcColumn7 = 1 << 6,
    efmcColumn8 = 1 << 7,
    efmcColumn9 = 1 << 8,
    efmcColumn10 = 1 << 9,
    efmcColumn11 = 1 << 10,
    efmcColumn12 = 1 << 11,
    efmcColumn13 = 1 << 12,
    efmcColumn14 = 1 << 13,
    efmcColumn15 = 1 << 14,
    efmcColumn16 = 1 << 15,
    efmcColumn17 = 1 << 16,
    efmcColumn18 = 1 << 17,
    efmcColumn19 = 1 << 18,
    efmcColumn20 = 1 << 19,
    efmcColumn21 = 1 << 20,
    efmcColumn22 = 1 << 21,
    efmcColumn23 = 1 << 22,
    efmcColumn24 = 1 << 23,
    efmcColumn25 = 1 << 24,
    efmcColumn26 = 1 << 25,
    efmcColumn27 = 1 << 26,
    efmcColumn28 = 1 << 27,
    efmcColumn29 = 1 << 28,
    efmcColumn30 = 1 << 29,
    efmcColumn31 = 1 << 30,
    efmcColumn32 = 1 << 31,
};

// Keeps track of the query instance for the reading CA (deferred CA)
typedef struct WCA_WRAPQUERY_STRUCT
{
    // These are used to size our dynamic arrays below
    DWORD dwColumns, dwRows, dwNextIndex;

    // Dynamic arrays of column schema information
    eColumnDataType *pcdtColumnType;
    LPWSTR *ppwzColumnNames;

    // Dynamic array of raw record data
    MSIHANDLE *phRecords;
} *WCA_WRAPQUERY_HANDLE;

// Wrap a query
// Setting the pfFormatMask enables control over which fields will be formatted, and which will be left unchanged
// Setting dwComponentColumn to something other than 0xFFFFFFFF tells WcaWrapQuery to add two additional columns to the right side of the table
//      - ISInstalled and ISAction - which map to the ComponentState of the component (the component is found in the column specified)
//      Note that if a component is NULL, the component state columns will also be left null, and it will be up to the deferred CA to fail or ignore the case appropriately
// Setting dwDirectoryColumn to something other than 0xFFFFFFFF tells WcaWrapQuery to add two more additional columns to the right side of the table
//      - SourcePath and TargetPath - which map to the Directory's Source and Target Path (the directory is found in the column specified)
//      Note that if a directory is NULL, the directory source/target path columns will also be left null, and it will be up to the deferred CA to fail or ignore the case appropriately
HRESULT WIXAPI WcaWrapQuery(
    __in_z LPCWSTR pwzQuery,
    __inout LPWSTR * ppwzCustomActionData,
    __in_opt DWORD dwFormatMask,
    __in_opt DWORD dwComponentColumn,
    __in_opt DWORD dwDirectoryColumn
    );
// This wraps an empty table query into the custom action data - this is a way to indicate to the deferred custom action that a necessary table doesn't exist, or its query returned no results
HRESULT WIXAPI WcaWrapEmptyQuery(
    __inout LPWSTR * ppwzCustomActionData
    );

// Open a new unwrap query operation, with data from the ppwzCustomActionData string
HRESULT WIXAPI WcaBeginUnwrapQuery(
    __out WCA_WRAPQUERY_HANDLE * phWrapQuery,
    __inout LPWSTR * ppwzCustomActionData
    );

// Get the number of records in a query being unwrapped
DWORD WIXAPI WcaGetQueryRecords(
    __in const WCA_WRAPQUERY_HANDLE hWrapQuery
    );

// This function resets a query back to its first row, so that the next fetch returns the first record
void WIXAPI WcaFetchWrappedReset(
    __in WCA_WRAPQUERY_HANDLE hWrapQuery
    );
// Fetch the next record in this query
// NOTE: the MSIHANDLE returned by this function should not be released, as it is the same handle used by the query object to maintain the item.
//       so, don't use this function with PMSIHANDLE objects!
HRESULT WIXAPI WcaFetchWrappedRecord(
    __in WCA_WRAPQUERY_HANDLE hWrapQuery,
    __out MSIHANDLE* phRec
    );

// Fetch the next record in the query where the string value in column dwComparisonColumn equals the value pwzExpectedValue
// NOTE: the MSIHANDLE returned by this function should not be released, as it is the same handle used by the query object to maintain the item.
//       so, don't use this function with PMSIHANDLE objects!
HRESULT WIXAPI WcaFetchWrappedRecordWhereString(
    __in WCA_WRAPQUERY_HANDLE hWrapQuery,
    __in DWORD dwComparisonColumn,
    __in_z LPCWSTR pwzExpectedValue,
    __out MSIHANDLE* phRec
    );

// Release a query ID (frees memory, and frees the ID for a new query)
void WIXAPI WcaFinishUnwrapQuery(
    __in_opt WCA_WRAPQUERY_HANDLE hWrapQuery
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\wcawow64.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcawow64.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library for Wow64 API-related functionality.
// </summary>
//-------------------------------------------------------------------------------------------------

#include "wcautil.h"

#ifdef __cplusplus
extern "C" {
#endif

HRESULT WIXAPI WcaInitializeWow64();
BOOL WIXAPI WcaIsWow64Initialized();
HRESULT WIXAPI WcaDisableWow64FSRedirection();
HRESULT WIXAPI WcaRevertWow64FSRedirection();
HRESULT WIXAPI WcaFinalizeWow64();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\userutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="userutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    User helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI UserBuildDomainUserName(
    __out_ecount_z(cchDest) LPWSTR wzDest,
    __in int cchDest,
    __in_z LPCWSTR pwzName,
    __in_z LPCWSTR pwzDomain
    );

HRESULT DAPI UserCheckIsMember(
    __in_z LPCWSTR pwzName,
    __in_z LPCWSTR pwzDomain,
    __in_z LPCWSTR pwzGroupName,
    __in_z LPCWSTR pwzGroupDomain,
    __out LPBOOL lpfMember
    );

HRESULT DAPI UserCreateADsPath(
    __in_z LPCWSTR wzObjectDomain, 
    __in_z LPCWSTR wzObjectName,
    __out BSTR *pbstrAdsPath
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\strutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="strutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for string helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define ReleaseStr(pwz) if (pwz) { StrFree(pwz); }
#define ReleaseNullStr(pwz) if (pwz) { StrFree(pwz); pwz = NULL; }
#define ReleaseBSTR(bstr) if (bstr) { ::SysFreeString(bstr); }
#define ReleaseNullBSTR(bstr) if (bstr) { ::SysFreeString(bstr); bstr = NULL; }

#define DeclareConstBSTR(bstr_const, wz) const WCHAR bstr_const[] = { 0x00, 0x00, sizeof(wz)-sizeof(WCHAR), 0x00, wz }
#define UseConstBSTR(bstr_const) const_cast<BSTR>(bstr_const + 4)

HRESULT DAPI StrAlloc(
    __deref_out_ecount_part(cch, 0) LPWSTR* ppwz,
    __in DWORD_PTR cch
    );
HRESULT DAPI StrAnsiAlloc(
    __deref_out_ecount_part(cch, 0) LPSTR* ppz,
    __in DWORD_PTR cch
    );
HRESULT DAPI StrAllocString(
    __deref_out_ecount_z(cchSource+1) LPWSTR* ppwz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource
    );
HRESULT DAPI StrAnsiAllocString(
    __deref_out_ecount_z(cchSource+1) LPSTR* ppsz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource,
    __in UINT uiCodepage
    );
HRESULT DAPI StrAllocStringAnsi(
    __deref_out_ecount_z(cchSource+1) LPWSTR* ppwz,
    __in LPCSTR szSource,
    __in DWORD_PTR cchSource,
    __in UINT uiCodepage
    );
HRESULT DAPI StrAllocPrefix(
    __deref_out_z LPWSTR* ppwz,
    __in LPCWSTR wzPrefix,
    __in DWORD_PTR cchPrefix
    );
HRESULT DAPI StrAllocConcat(
    __deref_out_z LPWSTR* ppwz,
    __in LPCWSTR wzSource,
    __in DWORD_PTR cchSource
    );
HRESULT DAPI StrAnsiAllocConcat(
    __deref_out_z LPSTR* ppz,
    __in LPCSTR pzSource,
    __in DWORD_PTR cchSource
    );
HRESULT __cdecl StrAllocFormatted(
    __deref_out_z LPWSTR* ppwz,
    __in __format_string LPCWSTR wzFormat,
    ...
    );
HRESULT __cdecl StrAnsiAllocFormatted(
    __deref_out_z LPSTR* ppsz,
    __in __format_string LPCSTR szFormat,
    ...
    );
HRESULT DAPI StrAllocFormattedArgs(
    __deref_out_z LPWSTR* ppwz,
    __in __format_string LPCWSTR wzFormat,
    __in va_list args
    );
HRESULT DAPI StrAnsiAllocFormattedArgs(
    __deref_out_z LPSTR* ppsz,
    __in __format_string LPCSTR szFormat,
    __in va_list args
    );
HRESULT DAPI StrAllocFromError(
    __inout LPWSTR *ppwzMessage,
    __in HRESULT hrError,
    __in_opt HMODULE hModule,
    ...
    );

HRESULT DAPI StrMaxLength(
    __in LPCVOID p,
    __out DWORD_PTR* pcch
    );
HRESULT DAPI StrSize(
    __in LPCVOID p,
    __out DWORD_PTR* pcb
    );

HRESULT DAPI StrFree(
    __in LPVOID p
    );

HRESULT DAPI StrCurrentTime(
    __deref_out_z LPWSTR* ppwz,
    __in BOOL fGMT
    );
HRESULT DAPI StrCurrentDateTime(
    __deref_out_z LPWSTR* ppwz,
    __in BOOL fGMT
    );

HRESULT DAPI StrReplaceStringAll(
    __inout LPWSTR* ppwzOriginal,
    __in LPCWSTR wzOldSubString,
    __in LPCWSTR wzNewSubString
    );
HRESULT DAPI StrReplaceString(
    __inout LPWSTR* ppwzOriginal,
    __inout DWORD* pdwStartIndex,
    __in LPCWSTR wzOldSubString,
    __in LPCWSTR wzNewSubString
    );

HRESULT DAPI StrHexEncode(
    __in_ecount(cbSource) const BYTE* pbSource,
    __in DWORD_PTR cbSource,
    __out_ecount(cchDest) LPWSTR wzDest,
    __in DWORD_PTR cchDest
    );
HRESULT DAPI StrHexDecode(
    __in LPCWSTR wzSource,
    __out_bcount(cbDest) BYTE* pbDest,
    __in DWORD_PTR cbDest
    );

HRESULT DAPI StrAllocBase85Encode(
    __in_bcount(cbSource) const BYTE* pbSource,
    __in DWORD_PTR cbSource,
    __deref_out_z LPWSTR* pwzDest
    );
HRESULT DAPI StrAllocBase85Decode(
    __in LPCWSTR wzSource,
    __deref_out_bcount(*pcbDest) BYTE** hbDest,
    __out DWORD_PTR* pcbDest
    );

HRESULT DAPI MultiSzLen(
    __in LPCWSTR pwzMultiSz,
    __out DWORD_PTR* pcch
    );
HRESULT DAPI MultiSzPrepend(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __inout_opt DWORD_PTR *pcchMultiSz,
    __in LPCWSTR pwzInsert
    );
HRESULT DAPI MultiSzFindSubstring(
    __in LPCWSTR pwzMultiSz,
    __in LPCWSTR pwzSubstring,
    __out_opt DWORD_PTR* pdwIndex,
    __deref_opt_out_z LPCWSTR* ppwzFoundIn
    );
HRESULT DAPI MultiSzFindString(
    __in LPCWSTR pwzMultiSz,
    __in LPCWSTR pwzString,
    __out_opt DWORD_PTR* pdwIndex,
    __deref_opt_out_z LPCWSTR* ppwzFound
    );
HRESULT DAPI MultiSzRemoveString(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __in DWORD_PTR dwIndex
    );
HRESULT DAPI MultiSzInsertString(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __inout_opt DWORD_PTR *pcchMultiSz,
    __in DWORD_PTR dwIndex,
    __in LPCWSTR pwzInsert
    );
HRESULT DAPI MultiSzReplaceString(
    __deref_inout_z LPWSTR* ppwzMultiSz,
    __in DWORD_PTR dwIndex,
    __in LPCWSTR pwzString
    );

LPCWSTR wcsistr(
    __in LPCWSTR wzString,
    __in LPCWSTR wzCharSet
    );

HRESULT DAPI StrStringToInt16(
    __in_z LPCWSTR wzIn,
    __in DWORD cchIn,
    __out SHORT* psOut
    );
HRESULT DAPI StrStringToUInt16(
    __in_z LPCWSTR wzIn,
    __in DWORD cchIn,
    __out USHORT* pusOut
    );
HRESULT DAPI StrStringToInt32(
    __in_z LPCWSTR wzIn,
    __in DWORD cchIn,
    __out INT* piOut
    );
HRESULT DAPI StrStringToUInt32(
    __in_z LPCWSTR wzIn,
    __in DWORD cchIn,
    __out UINT* puiOut
    );
HRESULT DAPI StrStringToInt64(
    __in_z LPCWSTR wzIn,
    __in DWORD cchIn,
    __out LONGLONG* pllOut
    );
HRESULT DAPI StrStringToUInt64(
    __in_z LPCWSTR wzIn,
    __in DWORD cchIn,
    __out ULONGLONG* pullOut
    );
void DAPI StrStringToUpper(
    __inout_z LPWSTR wzIn
    );
void DAPI StrStringToLower(
    __inout_z LPWSTR wzIn
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WSDLExtract\code\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\wcautil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wcautil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Windows Installer XML CustomAction utility library.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define WIXAPI __stdcall
#define ExitTrace WcaLogError
#define ExitTrace1 WcaLogError
#define ExitTrace2 WcaLogError
#define ExitTrace3 WcaLogError

#include "dutil.h"

#define MessageExitOnLastError(x, e, s)      { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace(x, "%s", s); WcaErrorMessage(e, x, MB_OK, 0);  goto LExit; } }
#define MessageExitOnLastError1(x, e, f, s)  { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (FAILED(x)) { ExitTrace1(x, f, s); WcaErrorMessage(e, x, MB_OK, 1, s);  goto LExit; } }

#define MessageExitOnFailure(x, e, s)           if (FAILED(x)) { ExitTrace(x, "%s", s); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 0);  goto LExit; }
#define MessageExitOnFailure1(x, e, f, s)       if (FAILED(x)) { ExitTrace1(x, f, s); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 1, s);  goto LExit; }
#define MessageExitOnFailure2(x, e, f, s, t)    if (FAILED(x)) { ExitTrace2(x, f, s, t); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 2, s, t);  goto LExit; }
#define MessageExitOnFailure3(x, e, f, s, t, u) if (FAILED(x)) { ExitTrace2(x, f, s, t, u); WcaErrorMessage(e, x, INSTALLMESSAGE_ERROR | MB_OK, 3, s, t, u);  goto LExit; }

#define MessageExitOnNullWithLastError(p, x, e, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, "%s", s); WcaErrorMessage(e, x, MB_OK, 0);  goto LExit; }
#define MessageExitOnNullWithLastError1(p, x, e, f, s) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, f, s); WcaErrorMessage(e, x, MB_OK, 1, s);  goto LExit; }
#define MessageExitOnNullWithLastError2(p, x, e, f, s, t) if (NULL == p) { x = ::GetLastError(); x = HRESULT_FROM_WIN32(x); if (!FAILED(x)) { x = E_FAIL; } ExitTrace(x, f, s, t); WcaErrorMessage(e, x, MB_OK, 2, s, t);  goto LExit; }

// Generic action enum.
enum WCA_ACTION
{
    WCA_ACTION_NONE,
    WCA_ACTION_INSTALL,
    WCA_ACTION_UNINSTALL,
};

enum WCA_CASCRIPT
{
    WCA_CASCRIPT_SCHEDULED,
    WCA_CASCRIPT_ROLLBACK,
};

enum WCA_CASCRIPT_CLOSE
{
    WCA_CASCRIPT_CLOSE_PRESERVE,
    WCA_CASCRIPT_CLOSE_DELETE,
};

enum WCA_TODO
{
    WCA_TODO_UNKNOWN,
    WCA_TODO_INSTALL,
    WCA_TODO_UNINSTALL,
    WCA_TODO_REINSTALL,
};

typedef struct WCA_CASCRIPT_STRUCT
{
    LPWSTR pwzScriptPath;
    HANDLE hScriptFile;
} *WCA_CASCRIPT_HANDLE;

void WIXAPI WcaGlobalInitialize(
    __in HINSTANCE hInst
    );
void WIXAPI WcaGlobalFinalize();

HRESULT WIXAPI WcaInitialize(
    __in MSIHANDLE hInstall,
    __in_z PCSTR szCustomActionLogName
    );
UINT WIXAPI WcaFinalize(
    __in UINT iReturnValue
    );
BOOL WIXAPI WcaIsInitialized();

MSIHANDLE WIXAPI WcaGetInstallHandle();
MSIHANDLE WIXAPI WcaGetDatabaseHandle();

const char* WIXAPI WcaGetLogName();

void WIXAPI WcaSetReturnValue(
    __in UINT iReturnValue
    );
BOOL WIXAPI WcaCancelDetected();

const int LOG_BUFFER = 2048;
enum LOGLEVEL
{ 
    LOGMSG_TRACEONLY,  // Never written to the log file (except in DEBUG builds)
    LOGMSG_VERBOSE,    // Written to log when LOGVERBOSE
    LOGMSG_STANDARD    // Written to log whenever informational logging is enabled
};

void __cdecl WcaLog(
    __in LOGLEVEL llv,
    __in_z __format_string PCSTR fmt, ...
    );
BOOL WIXAPI WcaDisplayAssert(
    __in LPCSTR sz
    );
void __cdecl WcaLogError(
    __in HRESULT hr,
    __in LPCSTR szMessage,
    ...
    );

UINT WIXAPI WcaProcessMessage(
    __in INSTALLMESSAGE eMessageType,
    __in MSIHANDLE hRecord
    );
UINT __cdecl WcaErrorMessage(
    __in int iError, 
    __in HRESULT hrError, 
    __in UINT uiType, 
    __in DWORD cArgs, 
    ...
    );
HRESULT WIXAPI WcaProgressMessage(
    __in UINT uiCost,
    __in BOOL fExtendProgressBar
    );

BOOL WIXAPI WcaIsInstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );
BOOL WIXAPI WcaIsReInstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );
BOOL WIXAPI WcaIsUninstalling(
    __in INSTALLSTATE isInstalled,
    __in INSTALLSTATE isAction
    );

HRESULT WIXAPI WcaSetComponentState(
    __in_z LPCWSTR wzComponent,
    __in INSTALLSTATE isState
    );

HRESULT WIXAPI WcaTableExists(
    __in_z LPCWSTR wzTable
    );

HRESULT WIXAPI WcaOpenView(
    __in_z LPCWSTR wzSql,
    __out MSIHANDLE* phView
    );
HRESULT WIXAPI WcaExecuteView(
    __in MSIHANDLE hView,
    __in MSIHANDLE hRec
    );
HRESULT WIXAPI WcaOpenExecuteView(
    __in_z LPCWSTR wzSql,
    __out MSIHANDLE* phView
    );
HRESULT WIXAPI WcaFetchRecord(
    __in MSIHANDLE hView,
    __out MSIHANDLE* phRec
    );
HRESULT WIXAPI WcaFetchSingleRecord(
    __in MSIHANDLE hView,
    __out MSIHANDLE* phRec
    );

HRESULT WIXAPI WcaGetProperty(
    __in_z LPCWSTR wzProperty,
    __inout LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetFormattedProperty(
    __in_z LPCWSTR wzProperty,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetFormattedString(
    __in_z LPCWSTR wzString,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetIntProperty(
    __in_z LPCWSTR wzProperty,
    __inout int* piData
    );
HRESULT WIXAPI WcaGetTargetPath(
    __in_z LPCWSTR wzFolder,
    __out LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaSetProperty(
    __in_z LPCWSTR wzPropertyName,
    __in_z LPCWSTR wzPropertyValue
    );
HRESULT WIXAPI WcaSetIntProperty(
    __in_z LPCWSTR wzPropertyName,
    __in int nPropertyValue
    );
BOOL WIXAPI WcaIsPropertySet(
    __in LPCSTR szProperty
    );

HRESULT WIXAPI WcaGetRecordInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout int* piData
    );
HRESULT WIXAPI WcaGetRecordString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout LPWSTR* ppwzData
    );
HRESULT WIXAPI WcaGetRecordFormattedInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __out int* piData
    );
HRESULT WIXAPI WcaGetRecordFormattedString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __inout LPWSTR* ppwzData
    );

HRESULT WIXAPI WcaAllocStream(
    __inout BYTE** ppbData,
    __in DWORD cbData
    );
HRESULT WIXAPI WcaFreeStream(
    __in BYTE* pbData
    );

HRESULT WIXAPI WcaGetRecordStream(
    __in MSIHANDLE hRecBinary,
    __in UINT uiField, 
    __inout BYTE** ppbData,
    __inout DWORD* pcbData
    );
HRESULT WIXAPI WcaSetRecordString(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __in_z LPCWSTR wzData
    );
HRESULT WIXAPI WcaSetRecordInteger(
    __in MSIHANDLE hRec,
    __in UINT uiField,
    __in int iValue
    );

HRESULT WIXAPI WcaDoDeferredAction(
    __in_z LPCWSTR wzAction,
    __in_z LPCWSTR wzCustomActionData,
    __in UINT uiCost
    );
DWORD WIXAPI WcaCountOfCustomActionDataRecords(
    __in_z LPCWSTR wzData
    );
HRESULT WIXAPI WcaReadStringFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __inout LPWSTR* ppwzString
    );
HRESULT WIXAPI WcaReadIntegerFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __inout int* piResult
    );
HRESULT WIXAPI WcaReadStreamFromCaData(
    __inout LPWSTR* ppwzCustomActionData,
    __out BYTE** ppbData,
    __out DWORD_PTR* pcbData
    );
HRESULT WIXAPI WcaWriteStringToCaData(
    __in_z LPCWSTR wzString,
    __inout LPWSTR* ppwzCustomActionData
    );
HRESULT WIXAPI WcaWriteIntegerToCaData(
    __in int i, 
    __inout LPWSTR* ppwzCustomActionData
    );
HRESULT WIXAPI WcaWriteStreamToCaData(
    __in_bcount(cbData) const BYTE* pbData,
    __in DWORD cbData,
    __inout LPWSTR* ppwzCustomActionData
    );

HRESULT __cdecl WcaAddTempRecord(
    __inout MSIHANDLE* phTableView,
    __inout MSIHANDLE* phColumns,
    __in_z LPCWSTR wzTable,
    __out_opt MSIDBERROR* pdbError,
    __in UINT uiUniquifyColumn,
    __in UINT cColumns,
    ...
    );

HRESULT WIXAPI WcaDumpTable(
    __in_z LPCWSTR wzTable
    );

HRESULT WIXAPI WcaDeferredActionRequiresReboot();
BOOL WIXAPI WcaDidDeferredActionRequireReboot();

HRESULT WIXAPI WcaCaScriptCreateKey(
    __out LPWSTR* ppwzScriptKey
    );

HRESULT WIXAPI WcaCaScriptCreate(
    __in WCA_ACTION action,
    __in WCA_CASCRIPT script,
    __in BOOL fImpersonated,
    __in_z LPCWSTR wzScriptKey,
    __in BOOL fAppend,
    __out WCA_CASCRIPT_HANDLE* phScript
    );

HRESULT WIXAPI WcaCaScriptOpen(
    __in WCA_ACTION action,
    __in WCA_CASCRIPT script,
    __in BOOL fImpersonated,
    __in_z LPCWSTR wzScriptKey,
    __out WCA_CASCRIPT_HANDLE* phScript
    );

void WIXAPI WcaCaScriptClose(
    __in_opt WCA_CASCRIPT_HANDLE hScript,
    __in WCA_CASCRIPT_CLOSE closeOperation
    );

HRESULT WIXAPI WcaCaScriptReadAsCustomActionData(
    __in WCA_CASCRIPT_HANDLE hScript,
    __out LPWSTR* ppwzCustomActionData
    );

HRESULT WIXAPI WcaCaScriptWriteString(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in_z LPCWSTR wzValue
    );

HRESULT WIXAPI WcaCaScriptWriteNumber(
    __in WCA_CASCRIPT_HANDLE hScript,
    __in DWORD dwValue
    );

void WIXAPI WcaCaScriptFlush(
    __in WCA_CASCRIPT_HANDLE hScript
    );

void WIXAPI WcaCaScriptCleanup(
    __in_z LPCWSTR wzProductCode,
    __in BOOL fImpersonated
    );

HRESULT WIXAPI QuietExec(
    __in_z LPWSTR wzCommand,
    __in DWORD dwTimeout
    );

WCA_TODO WIXAPI WcaGetComponentToDo(
    __in_z LPCWSTR wzComponentId
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\wiutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="wiutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    Header for Windows Installer helper functions.
// </summary>
//-------------------------------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif

#define MAX_DARWIN_KEY 73
#define MAX_DARWIN_COLUMN 255

#define ReleaseMsi(h) if (h) { ::MsiCloseHandle(h); }
#define ReleaseNullMsi(h) if (h) { ::MsiCloseHandle(h); h = NULL; }

HRESULT DAPI WiuGetComponentPath(
    __in LPCWSTR wzProductCode,
    __in LPCWSTR wzComponentId,
    __out LPWSTR* ppwzPath
    );

HRESULT DAPI WiuGetProductInfo(
    __in LPCWSTR wzProductCode,
    __in LPCWSTR wzProperty,
    __out LPWSTR* ppwzValue
    );

HRESULT DAPI WiuGetProductProperty(
    __in MSIHANDLE hProduct,
    __in LPCWSTR wzProperty,
    __out LPWSTR* ppwzValue
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\wix\3.5.1322.0\sdk\inc\xmlutil.h ===
#pragma once
//-------------------------------------------------------------------------------------------------
// <copyright file="xmlutil.h" company="Microsoft">
//    Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// 
// <summary>
//    XML helper funtions.
// </summary>
//-------------------------------------------------------------------------------------------------

// constant XML CLSIDs and IIDs
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument   = {0x2933BF90, 0x7B36, 0x11d2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument20  = {0xF6D90F11, 0x9C73, 0x11D3, {0xB3, 0x2E, 0x00, 0xC0, 0x4F, 0x99, 0x0B, 0xB4}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument26 = {0xf5078f1b, 0xc551, 0x11d3, {0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument30 = {0xf5078f32, 0xc551, 0x11d3, {0x89, 0xb9, 0x00, 0x00, 0xf8, 0x1f, 0xe2, 0x21}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument40 = {0x88d969c0, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument50 = {0x88d969e5, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_DOMDocument60 = {0x88d96a05, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};
extern __declspec(selectany) const CLSID XmlUtil_CLSID_XMLSchemaCache = {0x88d969c2, 0xf192, 0x11d4, {0xa6, 0x5f, 0x00, 0x40, 0x96, 0x32, 0x51, 0xe5}};

extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMDocument =  {0x2933BF81, 0x7B36, 0x11D2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMDocument2 = {0x2933BF95, 0x7B36, 0x11D2, {0xB2, 0x0E, 0x00, 0xC0, 0x4F, 0x98, 0x3E, 0x60}};
extern __declspec(selectany) const IID XmlUtil_IID_IXMLDOMSchemaCollection = {0x373984C8, 0xB845, 0x449B, {0x91, 0xE7, 0x45, 0xAC, 0x83, 0x03, 0x6A, 0xDE}};

enum XML_LOAD_ATTRIBUTE
{
    XML_LOAD_PRESERVE_WHITESPACE = 1,
};


#ifdef __cplusplus
extern "C" {
#endif

HRESULT DAPI XmlInitialize();
void DAPI XmlUninitialize();

HRESULT DAPI XmlCreateElement(
    __in IXMLDOMDocument *pixdDocument,
    __in LPCWSTR wzElementName,
    __out IXMLDOMElement **ppixnElement
    );
HRESULT DAPI XmlCreateDocument(
    __in_opt LPCWSTR pwzElementName, 
    __out IXMLDOMDocument** ppixdDocument,
    __out_opt IXMLDOMElement** ppixeRootElement = NULL
    );
HRESULT DAPI XmlLoadDocument(
    __in LPCWSTR wzDocument,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentEx(
    __in LPCWSTR wzDocument,
    __in DWORD dwAttributes,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromFile(
    __in LPCWSTR wzPath,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromBuffer(
    __in_bcount(cbSource) const BYTE* pbSource,
    __in DWORD cbSource,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlLoadDocumentFromFileEx(
    __in LPCWSTR wzPath,
    __in DWORD dwAttributes,
    __out IXMLDOMDocument** ppixdDocument
    );
HRESULT DAPI XmlSelectSingleNode(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR wzXPath,
    __out IXMLDOMNode **ppixnChild
    );
HRESULT DAPI XmlSetAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __in LPCWSTR pwzAttributeValue
    );
HRESULT DAPI XmlCreateTextNode(
    __in IXMLDOMDocument *pixdDocument,
    __in LPCWSTR wzText,
    __out IXMLDOMText **ppixnTextNode
    );
HRESULT DAPI XmlGetText(
    __in IXMLDOMNode* pixnNode,
    __out BSTR* pbstrText
    );
HRESULT DAPI XmlGetAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out BSTR* pbstrAttributeValue
    );
HRESULT DAPI XmlGetAttributeEx(
    __in IXMLDOMNode* pixnNode,
    __in_z LPCWSTR wzAttribute,
    __deref_out_z LPWSTR* psczAttributeValue
    );
HRESULT DAPI XmlGetYesNoAttribute(
    __in IXMLDOMNode* pixnNode,
    __in_z LPCWSTR wzAttribute,
    __out BOOL* pfYes
    );
HRESULT DAPI XmlGetAttributeNumber(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out DWORD* pdwValue
    );
HRESULT DAPI XmlGetAttributeNumberBase(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __in int nBase,
    __out DWORD* pdwValue
    );
HRESULT DAPI XmlGetAttributeLargeNumber(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute,
    __out DWORD64* pdw64Value
    );
HRESULT DAPI XmlGetNamedItem(
    __in IXMLDOMNamedNodeMap *pixnmAttributes, 
    __in_opt LPCWSTR wzName, 
    __out IXMLDOMNode **ppixnNamedItem
    );
HRESULT DAPI XmlSetText(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzText
    );
HRESULT DAPI XmlSetTextNumber(
    __in IXMLDOMNode *pixnNode,
    __in DWORD dwValue
    );
HRESULT DAPI XmlCreateChild(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR pwzElementType,
    __out IXMLDOMNode** ppixnChild
    );
HRESULT DAPI XmlRemoveAttribute(
    __in IXMLDOMNode* pixnNode,
    __in LPCWSTR pwzAttribute
    );
HRESULT DAPI XmlSelectNodes(
    __in IXMLDOMNode* pixnParent,
    __in LPCWSTR wzXPath,
    __out IXMLDOMNodeList **ppixnChild
    );
HRESULT DAPI XmlNextAttribute(
    __in IXMLDOMNamedNodeMap* pixnnm,
    __out IXMLDOMNode** pixnAttribute,
    __out_opt BSTR* pbstrAttribute
    );
HRESULT DAPI XmlNextElement(
    __in IXMLDOMNodeList* pixnl,
    __out IXMLDOMNode** pixnElement,
    __out_opt BSTR* pbstrElement
    );
HRESULT DAPI XmlRemoveChildren(
    __in IXMLDOMNode* pixnSource,
    __in LPCWSTR pwzXPath
    );
HRESULT DAPI XmlSaveDocument(
    __in IXMLDOMDocument* pixdDocument, 
    __inout LPCWSTR wzPath
    );
HRESULT DAPI XmlSaveDocumentToBuffer(
    __in IXMLDOMDocument* pixdDocument,
    __deref_out_bcount(*pcbDest) BYTE** ppbDest,
    __out DWORD* pcbDest
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WSDLExtract\code\WSDLExtract.cs ===
using System;
using System.Xml;
using System.Web.Services.Description;
using System.Reflection;
using System.IO;

namespace Microsoft.MSN.Tools
{

	/// <summary>
	/// Global data
	/// </summary>
	class Global
	{
		static public string assembly=null;
		static public TextWriter wsdl=null;
        static public string serviceurl = "http://localhost/wsdlreflection.asmx";
	}
	
	/// <summary>
	/// Summary description for WSDLExtract.
	/// </summary>
	class WSDLExtract
	{
		/// <summary>
		/// Displays the program usage
		/// </summary>
		static private void Usage()
		{
			Console.WriteLine("wsdlextract.exe -a assembly [-o wsdloutputfile] [-?|-h]");
			Console.WriteLine("    -a [required](specifies the assembly to extract the WSDL information from)");
			Console.WriteLine("    -o [optional](specifies the name of the wsdl outputfile; by default it uses stdout)");
			Console.WriteLine("    -u [optional](specifies the base URL of the webservice)");
			Console.WriteLine("    -? [optional](displays this information)");
			Console.WriteLine("    -h [optional](displays this information)");
			Console.WriteLine("    example: wsdlextract.exe -a assembly.dll -o assembly.wsdl");
		}

		/// <summary>
		/// Parse command line arguements
		/// </summary>
		/// <param name="args"></param>
		/// <returns></returns>
		static private int ParseArgs(string[] args)
		{
			//Check for min arg length
			if (2>args.GetLength(0))
			{
				Usage();
				return -1;
			}

			//Loop through arguement
			for (int i=0; i<args.GetLength(0);i++)
			{
				switch (args[i].ToLower())
				{
					//Usage
					case "-?":
					case "-h":
					case "?":
					case "h":
					case "\\?":
					case "\\h":
						Usage();
						return -1;

					//WSDL output file
					case "-o":

						//Check if there is another parameter before reading
						if (i+1>args.GetLength(0))
						{
							Console.WriteLine("Missing output file argument");
							Usage();
							return -1;
						}
						try
						{
							Global.wsdl = File.CreateText(args[++i]);
						}
						catch
						{
							Console.WriteLine("Exception opening output file ");
							Usage();
							return -1;
						}
						break;

					//Assembly
					case "-a":

						//Check if there is another parameter before reading
						if (i+1>args.GetLength(0))
						{
							Console.WriteLine("Missing assembly file arguement");
							Usage();
							return -1;
						}

						//Get full path
						FileInfo fi = new FileInfo(args[++i]);

						//Check if it exists
						if (false==File.Exists(fi.FullName))
						{
							Console.WriteLine("File does not exist {0}",args[i]);
							Usage();
							return -1;
						}
						Global.assembly=fi.FullName;
						break;

					// Web service base URL
					case "-u":
						
						//Check if there is another parameter before reading
						if (i + 1 > args.GetLength(0))
						{
							Console.WriteLine("Missing webservice URL argument");
							Usage();
							return -1;
						}

						Global.serviceurl = args[++i];
						break;

					//Invalid parameter
					default:
						Console.WriteLine("Invalid parameter");
						Usage();
						return -1;
				}
			}

			//Check for required parameters
			if (null==Global.assembly) 
			{
				Console.WriteLine("Missing required parameter -a");
				Usage();
				return -1;
			}

			//If no output file use stdio
			if (null==Global.wsdl)
			{
				Global.wsdl=Console.Out;
			}
			return 0;
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static int Main(string[] args)
		{
			//Parse the arguements and open output stream
			int retVal=0;
			retVal=ParseArgs(args);
			if (0!=retVal) return retVal;

			//Open the input assembly
			Assembly a = Assembly.LoadFrom(Global.assembly);
			ServiceDescriptionReflector reflector = new ServiceDescriptionReflector();

			//Gets the types defined for this assembly
			Type[] types = a.GetTypes();
			if (types.Length==0) return -1;

			//Find the System.Web.Services.WebService type and reflect it
			foreach (Type theType in types)
			{
				if (theType.BaseType==typeof(System.Web.Services.WebService))
				{
					reflector.Reflect(theType, Global.serviceurl);
				}
			}

			//Write the WSDL file
			XmlTextWriter xtr = new XmlTextWriter(Global.wsdl);
			xtr.Formatting = Formatting.Indented;
			if (reflector.ServiceDescriptions.Count==0)
			{
				Console.WriteLine("Assembly does not contain service descriptions");
				Usage();
				return -1;
			}

			reflector.ServiceDescriptions[0].Write(xtr);

			//Close the WSDL file
			xtr.Close();

			return 0;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\WSDLExtract\code\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("WSDLExtract")]
[assembly: AssemblyDescription("Used to extract a WSDL file from an assembly")]
[assembly: AssemblyCompany("Microsoft Corp.")]
[assembly: AssemblyProduct("WSDLExtract")]
[assembly: AssemblyCopyright("2006")]

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.0000.0")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
#if ENABLE_CODESIGN

#if ENABLE_PRS_DELAYSIGN
[assembly: AssemblyKeyFile(@"")]
[assembly: AssemblyKeyName("")]
[assembly: AssemblyDelaySign(true)]
#else
[assembly: AssemblyKeyFile(@"")]
[assembly: AssemblyKeyName("")]
[assembly: AssemblyDelaySign(false)]
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\BaseFile.cs ===
using System;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{

	///-----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: BaseFile
	///
	/// Copyright (C) 2004, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Base class for the three file types that Mage works with.  Each file comes
	/// off the Tab control from the Mage UI
	/// </summary>
	/// <history>
	/// 	[a-dwils]	3/1/04	Inserted comment block for code review
	/// </history>
	///-----------------------------------------------------------------------------

	public class BaseFile : Maui.Core.WinControls.TabControlTab
	{

#region "Control IDs"

		public class ControlIDs
		{
			public const string ListBox = "Pages";
		}

#endregion

#region "Member Variables"
		protected ListBox m_cachedListBox;
		public App m_storedApp;
#endregion

#region "Constructors"

		/// <summary>
		/// Constructor that takes in a Tab control and calls the base class constructor
		/// </summary>
		/// <param name="Tab"></param>
		/// <history>
		/// 	[a-dwils]	3/1/04	Inserted comment block for code review
		/// </history>
		public BaseFile(TabControlTab Tab) : base(Tab.Owner, Tab.Text)
		{
		}

#endregion

#region "Properties"

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the ListBox control
		///  </summary>
		///  <value>The list box that each file type shares</value>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public ListBox List	//IBaseFileControls
		{
			get
			{
				if ((m_cachedListBox == null))
				{
					m_cachedListBox = new ListBox(this.Owner, ControlIDs.ListBox);
				}
				return m_cachedListBox;
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Core\Resources\WhidbeyResourceBridge.cs ===
using System;
using System.IO;
using System.Diagnostics;
using Maui.Core.Remoting;

namespace Maui.Core.Resources
{
	/// <summary>
	/// Provides a way for MAUI to extract resources from Whidbey assemblies
	/// while running on Everett runtime.
	/// </summary>
	/// <history>
	///		[dmitriv]	6/25/2003	Created
	/// </history>
	class WhidbeyResourceBridge
	{

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			RemotingHost.Instance.InitializeServer();
			string semFileName = Process.GetCurrentProcess().MainModule.ModuleName + ".running";
			File.Create(semFileName).Close();
			while (File.Exists(semFileName))
			{
				System.Threading.Thread.Sleep(200);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\BrowseForFolderDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IBrowseForFolderDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IBrowseForFolderDialogControls
    {
        TreeView TreeView  {get;}
        Button MakeNewFolderButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: BrowseForFolderDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Browse dialog window that comes up when choosing a folder in Mage
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 1/21/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class BrowseForFolderDialog : Dialog, IBrowseForFolderDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Browse For Folder";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int TreeView = 0x64;
            public const int MakeNewFolderButton = 0x3746;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        protected TreeView m_cachedTreeView;
        protected Button m_cachedMakeNewFolderButton;
        protected Button m_cachedOKButton;
        protected Button m_cachedCancelButton;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for this window, simply calls init function
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public BrowseForFolderDialog(MageApp app) : 
                base(app, Init(app))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app)
        {
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the Browse window.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IBrowseForFolderDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TreeView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TreeView IBrowseForFolderDialogControls.TreeView
        {
            get
            {
                if ((m_cachedTreeView == null))
                {
                    m_cachedTreeView = new TreeView(this, ControlIDs.TreeView);
                }
                return m_cachedTreeView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MakeNewFolderButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IBrowseForFolderDialogControls.MakeNewFolderButton
        {
            get
            {
                if ((m_cachedMakeNewFolderButton == null))
                {
                    m_cachedMakeNewFolderButton = new Button(this, ControlIDs.MakeNewFolderButton);
                }
                return m_cachedMakeNewFolderButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IBrowseForFolderDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IBrowseForFolderDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MakeNewFolder
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickMakeNewFolder()
        {
            Controls.MakeNewFolderButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Browse dialog is up already
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\MageApp.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using Maui.TestLog;
	using System;
    using System.ComponentModel;
	using System.Collections.Specialized;


#region "IMageAppControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMageAppControls
    {
        TabControl FileTabControl  {get;}
        Toolbar MageToolbar  {get;}
		//statusBar MageStatus   {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: MageApp
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Class to describe the main Mage app, includes toolbar and main tab control
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 1/14/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MageApp : App, IMageAppControls
    {


#region "Strings"
        /// -----------------------------------------------------------
        /// <summary>
        ///  Discover the path to the app on this system
        ///  </summary>
        ///  <remarks>
        ///  <returns>the path to the Apps exe file.</returns>
        /// -----------------------------------------------------------
        private static string GetExePath()
        {
			LogManager.LogHack("MageApp.GetExePath", "Have to change to GetSdkRoot method to get exepath");
			//return WFCTestLib.Util.Utilities.GetSdkRoot() + @"\mage.exe";
			return @"C:\Program Files\Microsoft.NET\SDK\v2.0\Bin\mageui.exe";
        }
        
        public class Strings
        {
			public const string MageCaption = "BrowseForFolder";
			public const string File = "File";
			public const string Exit = "Exit";
			public const string AppMan = "Application Manifest";
			public const string DepMan = "Deployment Manifest";
			public const string TrustL = "Trust License";
			public const string MenuNew = "New";
			public const string SaveAs = "Save As";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string FileTabControl = "tabs";
            //public const string MageStatus = "status";
            public const string MageToolbar = "toolbar";
        }

#endregion

#region "Member Variables"
        protected TabControl m_cachedFileTabControl;
        protected Toolbar m_cachedMageToolbar;
        protected internal static Window ActiveWindow;
#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Mage App, calls base class constructor with exe path.
        ///  </summary>
        //  <param name="app">MageApp object owning the app. window.</param>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MageApp() : 
                base(MageApp.GetExePath())
        {
        }
#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this app. window
        ///  </summary>
        ///  <value>An interface that groups all of the app. window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMageAppControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileTabControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IMageAppControls.FileTabControl
        {
            get
            {
                if ((m_cachedFileTabControl == null))
                {
                    m_cachedFileTabControl = new TabControl(this.MainWindow, ControlIDs.FileTabControl);
                }
                return m_cachedFileTabControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MageToolbar control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar IMageAppControls.MageToolbar
        {
            get
            {
                if ((m_cachedMageToolbar == null))
                {
                    m_cachedMageToolbar = new Toolbar(this.MainWindow);//, ControlIDs.MageToolbar);
                }
                return m_cachedMageToolbar;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the MageStatus control, not in build yet
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		/*Toolbar IMageAppControls.MageStatus
		{
			get
			{
				if ((m_cachedMageStatus == null))
				{
					m_cachedMageStatus = new StatusBar(this.MainWindow, ControlIDs.MageStatus);
				}
				return m_cachedMageStatus;
			}
		}*/

#endregion

#region Methods

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  this function will call File->Exit in the menu, it will select no if a save dialog comes up
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void QuitWithoutSave()
		{
			// click File->Exit Manifest
			StringCollection Exit = new StringCollection();
			Exit.Add(this.GetIntlStr(Strings.File));
			Exit.Add(this.GetIntlStr(Strings.Exit));
            this.Menu.ExecuteMenuItem(Exit);

			Window saveWindow = null;
			do
			{
				try
				{
					saveWindow = new Window("Mage", StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
				}
				catch (Exception ex)
				{
					break;
				}
				saveWindow.SendKeys("N");
			} while (saveWindow != null);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new application manifest through the menu
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewAppMenu()
		{
			StringCollection NewApp = new StringCollection();
			NewApp.Add(this.GetIntlStr(Strings.File));
			NewApp.Add(this.GetIntlStr(Strings.MenuNew));
			NewApp.Add(this.GetIntlStr(Strings.AppMan));
			this.Menu.ExecuteMenuItem(NewApp);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new application manifest through the toolbar
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewAppToolbar()
		{
			this.Controls.MageToolbar.ToolbarItems[0].Click();
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new deployment manifest through the menu
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewDeploymentMenu()
		{
			// click File->New->Deployment Manifest
			StringCollection NewDep = new StringCollection();
			NewDep.Add(this.GetIntlStr(Strings.File));
			NewDep.Add(this.GetIntlStr(Strings.MenuNew));
			NewDep.Add(this.GetIntlStr(Strings.DepMan));
			this.Menu.ExecuteMenuItem(NewDep);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new deployment manifest through the toolbar
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewDeploymentToolbar()
		{
			this.Controls.MageToolbar.ToolbarItems[1].Click();
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new trust license through the menu
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewLicenseMenu()
		{
			StringCollection NewLic = new StringCollection();
			NewLic.Add(this.GetIntlStr(Strings.File));
			NewLic.Add(this.GetIntlStr(Strings.MenuNew));
			NewLic.Add(this.GetIntlStr(Strings.TrustL));
			this.Menu.ExecuteMenuItem(NewLic);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new trust license through the toolbar
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewLicenseToolbar()
		{
			this.Controls.MageToolbar.ToolbarItems[2].Click();
		}

#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\OpenDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IOpenDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IOpenDialogControls
    {
        StaticControl LookInStaticControl  {get;}
        EditComboBox LookInEditComboBox  {get;}
        Toolbar Toolbar0  {get;}
        Toolbar LookInToolbar  {get;}
        ListView FolderView  {get;}
        StaticControl FileNameStaticControl  {get;}
        EditComboBox FileNameEditComboBox  {get;}
        TextBox FileNameTextBox  {get;}
        StaticControl FilesOfTypeStaticControl  {get;}
        EditComboBox FilesOfTypeEditComboBox  {get;}
        Button OpenButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: OpenDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This dialog is for the Open file dialog that Mage uses.
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/23/2004 Created
    /// 	[a-dwils] 3/1/2004  Modified for code review
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class OpenDialog : Dialog, IOpenDialogControls
    {

#region "Control IDs"
        public class ControlIDs
        {
            public const int LookInStaticControl = 0x443;
            public const int LookInEditComboBox = 0x471;
            public const int Toolbar0 = 0x440;
            public const int LookInToolbar = 0x4A0;
            public const int FolderView = 0x1;
            public const int FileNameStaticControl = 0x442;
            public const int FileNameEditComboBox = 0x47C;
            public const int FileNameTextBox = 0x47C;
            public const int FilesOfTypeStaticControl = 0x441;
            public const int FilesOfTypeEditComboBox = 0x470;
            public const int OpenButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedLookInStaticControl;
        protected EditComboBox m_cachedLookInEditComboBox;
        protected Toolbar m_cachedToolbar0;
        protected Toolbar m_cachedLookInToolbar;
        protected ListView m_cachedFolderView;
        protected StaticControl m_cachedFileNameStaticControl;
        protected EditComboBox m_cachedFileNameEditComboBox;
        protected TextBox m_cachedFileNameTextBox;
        protected StaticControl m_cachedFilesOfTypeStaticControl;
        protected EditComboBox m_cachedFilesOfTypeEditComboBox;
        protected Button m_cachedOpenButton;
        protected Button m_cachedCancelButton;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This constructor takes in the Title of the Open dialog window
        ///  </summary>
        //  <param name="app">IDEApp object owning the dialog.</param>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public OpenDialog(MageApp app, string Title) : 
                base(app, Init(app, Title))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">IDEApp owning the dialog.</param>)
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app, string Title)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
				tempWindow = new Window(Title, StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the " + Title + " dialog.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IOpenDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LookIn
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string LookIn
        {
            get
            {
                return Controls.LookInEditComboBox.Text;
            }
            set
            {
                Controls.LookInEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FileName
        {
            get
            {
                return Controls.FileNameEditComboBox.Text;
            }
            set
            {
                Controls.FileNameEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName3
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FileName3
        {
            get
            {
                return Controls.FileNameTextBox.Text;
            }
            set
            {
                Controls.FileNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FilesOfType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FilesOfType
        {
            get
            {
                return Controls.FilesOfTypeEditComboBox.Text;
            }
            set
            {
                Controls.FilesOfTypeEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IOpenDialogControls.LookInStaticControl
        {
            get
            {
                if ((m_cachedLookInStaticControl == null))
                {
                    m_cachedLookInStaticControl = new StaticControl(this, ControlIDs.LookInStaticControl);
                }
                return m_cachedLookInStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOpenDialogControls.LookInEditComboBox
        {
            get
            {
                if ((m_cachedLookInEditComboBox == null))
                {
                    m_cachedLookInEditComboBox = new EditComboBox(this, ControlIDs.LookInEditComboBox);
                }
                return m_cachedLookInEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Toolbar0 control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar IOpenDialogControls.Toolbar0
        {
            get
            {
                if ((m_cachedToolbar0 == null))
                {
                    m_cachedToolbar0 = new Toolbar(this, ControlIDs.Toolbar0.ToString());
                }
                return m_cachedToolbar0;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInToolbar control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar IOpenDialogControls.LookInToolbar
        {
            get
            {
                if ((m_cachedLookInToolbar == null))
                {
                    m_cachedLookInToolbar = new Toolbar(this, ControlIDs.LookInToolbar.ToString());
                }
                return m_cachedLookInToolbar;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FolderView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IOpenDialogControls.FolderView
        {
            get
            {
                if ((m_cachedFolderView == null))
                {
                    m_cachedFolderView = new ListView(this, ControlIDs.FolderView);
                }
                return m_cachedFolderView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IOpenDialogControls.FileNameStaticControl
        {
            get
            {
                if ((m_cachedFileNameStaticControl == null))
                {
                    m_cachedFileNameStaticControl = new StaticControl(this, ControlIDs.FileNameStaticControl);
                }
                return m_cachedFileNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOpenDialogControls.FileNameEditComboBox
        {
            get
            {
                if ((m_cachedFileNameEditComboBox == null))
                {
                    m_cachedFileNameEditComboBox = new EditComboBox(this, ControlIDs.FileNameEditComboBox);
                }
                return m_cachedFileNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IOpenDialogControls.FileNameTextBox
        {
            get
            {
                // The ID for this control (1148) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedFileNameTextBox == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 9); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    wndTemp = wndTemp.Extended.FirstChild;
                    wndTemp = wndTemp.Extended.FirstChild;
                    m_cachedFileNameTextBox = new TextBox(wndTemp);
                }
                return m_cachedFileNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IOpenDialogControls.FilesOfTypeStaticControl
        {
            get
            {
                if ((m_cachedFilesOfTypeStaticControl == null))
                {
                    m_cachedFilesOfTypeStaticControl = new StaticControl(this, ControlIDs.FilesOfTypeStaticControl);
                }
                return m_cachedFilesOfTypeStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOpenDialogControls.FilesOfTypeEditComboBox
        {
            get
            {
                if ((m_cachedFilesOfTypeEditComboBox == null))
                {
                    m_cachedFilesOfTypeEditComboBox = new EditComboBox(this, ControlIDs.FilesOfTypeEditComboBox);
                }
                return m_cachedFilesOfTypeEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OpenButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOpenDialogControls.OpenButton
        {
            get
            {
                // The ID for this control (1) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedOpenButton == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 13); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    m_cachedOpenButton = new Button(wndTemp);
                }
                return m_cachedOpenButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOpenDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Open
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOpen()
        {
            Controls.OpenButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Open dialog is up already
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(string Title, MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\SaveAsDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ISaveAsDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISaveAsDialogControls
    {
        StaticControl SaveInStaticControl  {get;}
        EditComboBox LookInEditComboBox  {get;}
        Toolbar Toolbar1  {get;}
        Toolbar LookInToolbar  {get;}
        ListView FolderView  {get;}
        StaticControl FileNameStaticControl  {get;}
        EditComboBox FileNameEditComboBox  {get;}
        TextBox FileNameTextBox  {get;}
        StaticControl SaveAsTypeStaticControl  {get;}
        EditComboBox FilesOfTypeEditComboBox  {get;}
        Button SaveButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: SaveAsDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the SaveAs dialog that Mage uses
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/23/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SaveAsDialog : Dialog, ISaveAsDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Save As";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int SaveInStaticControl = 0x443;
            public const int LookInEditComboBox = 0x471;
            public const int Toolbar1 = 0x440;
            public const int LookInToolbar = 0x4A0;
            public const int FolderView = 0x1;
            public const int FileNameStaticControl = 0x442;
            public const int FileNameEditComboBox = 0x47C;
            public const int FileNameTextBox = 0x47C;
            public const int SaveAsTypeStaticControl = 0x441;
            public const int FilesOfTypeEditComboBox = 0x470;
            public const int SaveButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedSaveInStaticControl;
        protected EditComboBox m_cachedLookInEditComboBox;
        protected Toolbar m_cachedToolbar1;
        protected Toolbar m_cachedLookInToolbar;
        protected ListView m_cachedFolderView;
        protected StaticControl m_cachedFileNameStaticControl;
        protected EditComboBox m_cachedFileNameEditComboBox;
        protected TextBox m_cachedFileNameTextBox;
        protected StaticControl m_cachedSaveAsTypeStaticControl;
        protected EditComboBox m_cachedFilesOfTypeEditComboBox;
        protected Button m_cachedSaveButton;
        protected Button m_cachedCancelButton;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Save As dialog in Mage tool
        ///  </summary>
        //  <param name="app">IDEApp object owning the dialog.</param>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SaveAsDialog(MageApp app) : 
                base(app, Init(app))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">IDEApp owning the dialog.</param>)
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the Save As dialog.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISaveAsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LookIn
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string LookIn
        {
            get
            {
                return Controls.LookInEditComboBox.Text;
            }
            set
            {
                Controls.LookInEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FileName
        {
            get
            {
                return Controls.FileNameTextBox.Text;
            }
            set
            {
                Controls.FileNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FilesOfType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FilesOfType
        {
            get
            {
                return Controls.FilesOfTypeEditComboBox.Text;
            }
            set
            {
                Controls.FilesOfTypeEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveInStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISaveAsDialogControls.SaveInStaticControl
        {
            get
            {
                if ((m_cachedSaveInStaticControl == null))
                {
                    m_cachedSaveInStaticControl = new StaticControl(this, ControlIDs.SaveInStaticControl);
                }
                return m_cachedSaveInStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISaveAsDialogControls.LookInEditComboBox
        {
            get
            {
                if ((m_cachedLookInEditComboBox == null))
                {
                    m_cachedLookInEditComboBox = new EditComboBox(this, ControlIDs.LookInEditComboBox);
                }
                return m_cachedLookInEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Toolbar1 control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar ISaveAsDialogControls.Toolbar1
        {
            get
            {
                if ((m_cachedToolbar1 == null))
                {
                    m_cachedToolbar1 = new Toolbar(this, ControlIDs.Toolbar1.ToString());
                }
                return m_cachedToolbar1;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInToolbar control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar ISaveAsDialogControls.LookInToolbar
        {
            get
            {
                if ((m_cachedLookInToolbar == null))
                {
                    m_cachedLookInToolbar = new Toolbar(this, ControlIDs.LookInToolbar.ToString());
                }
                return m_cachedLookInToolbar;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FolderView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView ISaveAsDialogControls.FolderView
        {
            get
            {
                if ((m_cachedFolderView == null))
                {
                    m_cachedFolderView = new ListView(this, ControlIDs.FolderView);
                }
                return m_cachedFolderView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISaveAsDialogControls.FileNameStaticControl
        {
            get
            {
                if ((m_cachedFileNameStaticControl == null))
                {
                    m_cachedFileNameStaticControl = new StaticControl(this, ControlIDs.FileNameStaticControl);
                }
                return m_cachedFileNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISaveAsDialogControls.FileNameEditComboBox
        {
            get
            {
                if ((m_cachedFileNameEditComboBox == null))
                {
                    m_cachedFileNameEditComboBox = new EditComboBox(this, ControlIDs.FileNameEditComboBox);
                }
                return m_cachedFileNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISaveAsDialogControls.FileNameTextBox
        {
            get
            {
                // The ID for this control (1148) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedFileNameTextBox == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 9); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    wndTemp = wndTemp.Extended.FirstChild;
                    wndTemp = wndTemp.Extended.FirstChild;
                    m_cachedFileNameTextBox = new TextBox(wndTemp);
                }
                return m_cachedFileNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveAsTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISaveAsDialogControls.SaveAsTypeStaticControl
        {
            get
            {
                if ((m_cachedSaveAsTypeStaticControl == null))
                {
                    m_cachedSaveAsTypeStaticControl = new StaticControl(this, ControlIDs.SaveAsTypeStaticControl);
                }
                return m_cachedSaveAsTypeStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISaveAsDialogControls.FilesOfTypeEditComboBox
        {
            get
            {
                if ((m_cachedFilesOfTypeEditComboBox == null))
                {
                    m_cachedFilesOfTypeEditComboBox = new EditComboBox(this, ControlIDs.FilesOfTypeEditComboBox);
                }
                return m_cachedFilesOfTypeEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISaveAsDialogControls.SaveButton
        {
            get
            {
                // The ID for this control (1) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedSaveButton == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 13); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    m_cachedSaveButton = new Button(wndTemp);
                }
                return m_cachedSaveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISaveAsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Save
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickSave()
        {
            Controls.SaveButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Save As dialog is up already
		///  </summary>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\PreferencesDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;
	using System.Collections.Specialized;


#region "IPreferencesDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IPreferencesDialogControls
    {
        Button CancelButton  {get;}
        Button OKButton  {get;}
        Button EllipsisButton  {get;}
        CheckBox UseDefaultSigningKeyCheckBox  {get;}
        TextBox KeyFileTextBox  {get;}
        CheckBox SignManifestOnSaveCheckBox  {get;}
        StaticControl KeyFileStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: PreferencesDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Preferences dialog in the File->Preferences menu of Mage
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class PreferencesDialog : Dialog, IPreferencesDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Preferences";
			public const string File = "File";
			public const string Pref = "Preferences...";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string CancelButton = "btnCancel";
            public const string OKButton = "btnOK";
            public const string EllipsisButton = "btnBrowse";
            public const string UseDefaultSigningKeyCheckBox = "chkUseDefaultKey";
            public const string KeyFileTextBox = "txtKeyFile";
            public const string SignManifestOnSaveCheckBox = "chkSignOnSave";
            public const string KeyFileStaticControl = "label1";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedCancelButton;
        protected Button m_cachedOKButton;
        protected Button m_cachedEllipsisButton;
        protected CheckBox m_cachedUseDefaultSigningKeyCheckBox;
        protected TextBox m_cachedKeyFileTextBox;
        protected CheckBox m_cachedSignManifestOnSaveCheckBox;
        protected StaticControl m_cachedKeyFileStaticControl;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Preferences dialog, calls Init
        ///  </summary>
        //  <param name="app">MageApp object owning the dialog.</param>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public PreferencesDialog(MageApp app) : 
                base(app, Init(app))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MageApp owning the dialog.</param>)
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
				StringCollection Preferences = new StringCollection();
				Preferences.Add(app.GetIntlStr(Strings.File));
				Preferences.Add(app.GetIntlStr(Strings.Pref));
				app.Menu.ExecuteMenuItem(Preferences);
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
				if (tempWindow == null)
					throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the Preferences dialog.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IPreferencesDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox UseDefaultSigningKey
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool UseDefaultSigningKey
        {
            get
            {
                return Controls.UseDefaultSigningKeyCheckBox.Checked;
            }
            set
            {
                Controls.UseDefaultSigningKeyCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox SignManifestOnSave
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool SignManifestOnSave
        {
            get
            {
                return Controls.SignManifestOnSaveCheckBox.Checked;
            }
            set
            {
                Controls.SignManifestOnSaveCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control KeyFile
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public  string KeyFile
        {
            get
            {
                return Controls.KeyFileTextBox.Text;
            }
            set
            {
                Controls.KeyFileTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPreferencesDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPreferencesDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EllipsisButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPreferencesDialogControls.EllipsisButton
        {
            get
            {
                if ((m_cachedEllipsisButton == null))
                {
                    m_cachedEllipsisButton = new Button(this, ControlIDs.EllipsisButton);
                }
                return m_cachedEllipsisButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the UseDefaultSigningKeyCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IPreferencesDialogControls.UseDefaultSigningKeyCheckBox
        {
            get
            {
                if ((m_cachedUseDefaultSigningKeyCheckBox == null))
                {
                    m_cachedUseDefaultSigningKeyCheckBox = new CheckBox(this, ControlIDs.UseDefaultSigningKeyCheckBox);
                }
                return m_cachedUseDefaultSigningKeyCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyFileTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IPreferencesDialogControls.KeyFileTextBox
        {
            get
            {
                if ((m_cachedKeyFileTextBox == null))
                {
                    m_cachedKeyFileTextBox = new TextBox(this, ControlIDs.KeyFileTextBox);
                }
                return m_cachedKeyFileTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignManifestOnSaveCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IPreferencesDialogControls.SignManifestOnSaveCheckBox
        {
            get
            {
                if ((m_cachedSignManifestOnSaveCheckBox == null))
                {
                    m_cachedSignManifestOnSaveCheckBox = new CheckBox(this, ControlIDs.SignManifestOnSaveCheckBox);
                }
                return m_cachedSignManifestOnSaveCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyFileStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IPreferencesDialogControls.KeyFileStaticControl
        {
            get
            {
                if ((m_cachedKeyFileStaticControl == null))
                {
                    m_cachedKeyFileStaticControl = new StaticControl(this, ControlIDs.KeyFileStaticControl);
                }
                return m_cachedKeyFileStaticControl;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis0()
        {
            Controls.EllipsisButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Preferences dialog is up already
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\AppType.cs ===
using System;
using Maui.Mage.AppWindows;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{
#region "IAppTypeControls interface definition"
     
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IAppTypeControls
	{
		AppNameWindow Name {get;}
		AppFilesWindow File {get;}
		AppPermWindow Permission {get;}
	}

#endregion

	/// -----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: AppType
	///  Copyright (C) 2004, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  Class to describe the controls shown when an Application Manifest is opened
	///  </summary>
	///  <history>
	/// 	[a-dwils] 1/14/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class AppType : BaseFile, IAppTypeControls
	{

#region "Strings"
		public class Strings
		{
			public const string NameTitle = "Name";
			public const string FileTitle = "Files";
			public const string PermTitle = "Permissions Required";
		}
#endregion

#region "Member Variables"
		protected AppNameWindow m_cachedAppNameWindow;
		protected AppFilesWindow m_cachedAppFileWindow;
		protected AppPermWindow m_cachedAppPermWindow;
		public String m_ManName;
#endregion

#region "Constructors"
		/// <summary>
		/// Constructor that takes in the tab control that corresponds to the File
		/// </summary>
		/// <param name="Tab"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		public AppType(TabControlTab Tab, MageApp app) : base(Tab)
		{
			// Check to make sure window is correct type by checking
			//	elements in ListBox
			if ( (base.List[0].Text.CompareTo(app.GetIntlStr(Strings.NameTitle)) != 0) ||
				(base.List[1].Text.CompareTo(app.GetIntlStr(Strings.FileTitle)) != 0) ||
				(base.List[2].Text.CompareTo(app.GetIntlStr(Strings.PermTitle)) != 0))
			{
				throw (new Exception("TabControlTab opened was not of AppType."));
			}
			m_storedApp = app;
			m_ManName = Tab.Text + "*";
		}
#endregion

#region "Properties"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>An interface that groups all of the window's control properties together</value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IAppTypeControls Controls
		{
			get
			{
				return this;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Name window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		AppNameWindow IAppTypeControls.Name
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.NameTitle)].Click();
				if ((m_cachedAppNameWindow == null))
				{
					m_cachedAppNameWindow = new AppNameWindow(this, m_ManName);
				}
				return m_cachedAppNameWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the File window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		AppFilesWindow IAppTypeControls.File
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.FileTitle)].Click();
				if ((m_cachedAppFileWindow == null))
				{
					m_cachedAppFileWindow = new AppFilesWindow(this, m_ManName);
				}
				return m_cachedAppFileWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Permission window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		AppPermWindow IAppTypeControls.Permission
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.PermTitle)].Click();
				if ((m_cachedAppPermWindow == null))
				{
					m_cachedAppPermWindow = new AppPermWindow(this, m_ManName);
				}
				return m_cachedAppPermWindow;
			}
		}
#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\DepType.cs ===
using System;
using Maui.Mage.DepWindows;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{
	#region "IDepTypeControls interface definition"
     
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDepTypeControls
	{
		DepAppRefWindow AppRef {get;}
		DepDescWindow Desc {get;}
		DepNameWindow Name {get;}
		DepTLWindow TL {get;}
		DepUpdateWindow Update {get;}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: DepType
	///  Copyright (C) 2004, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  Class to describe the controls shown when a Deployment Manifest is opened
	///  </summary>
	///  <history>
	/// 	[a-dwils] 1/14/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class DepType : BaseFile, IDepTypeControls
	{

#region "Strings"
		public class Strings
		{
			public const string NameTitle = "Name";
			public const string DescTitle = "Description";
			public const string UpdateTitle = "Update Options";
			public const string AppTitle = "Application Reference";
			public const string TLTitle = "Trust Licenses";
		}
#endregion

#region "Member Variables"
		protected DepAppRefWindow m_cachedDepAppRefWindow;
		protected DepDescWindow m_cachedDepDescWindow;
		protected DepNameWindow m_cachedDepNameWindow;
		protected DepTLWindow m_cachedDepTLWindow;
		protected DepUpdateWindow m_cachedDepUpdateWindow;
		public String m_ManName;
#endregion

#region "Constructors"
		/// <summary>
		/// Constructor for DepType that takes in the Tab corresponding to the file
		/// </summary>
		/// <param name="Tab"></param>
		/// <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		///  
		public DepType(TabControlTab Tab, MageApp app) : base(Tab)
		{
			// Check to make sure window is correct type by checking
			//	elements in ListBox
			if ( (base.List[0].Text.CompareTo(app.GetIntlStr(Strings.NameTitle)) != 0) ||
				(base.List[1].Text.CompareTo(app.GetIntlStr(Strings.DescTitle)) != 0) ||
				(base.List[2].Text.CompareTo(app.GetIntlStr(Strings.UpdateTitle)) != 0) ||
				(base.List[3].Text.CompareTo(app.GetIntlStr(Strings.AppTitle)) != 0) ||
				(base.List[4].Text.CompareTo(app.GetIntlStr(Strings.TLTitle))!= 0))
			{
				throw (new Exception("TabControlTab opened was not of DepType."));
			}
			m_storedApp = app;
			m_ManName = Tab.Text + "*";
		}
#endregion

		#region "Properties"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>An interface that groups all of the window's control properties together</value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IDepTypeControls Controls
		{
			get
			{
				return this;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Application Reference window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepAppRefWindow IDepTypeControls.AppRef
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.AppTitle)].Click();
				if ((m_cachedDepAppRefWindow == null))
				{
					m_cachedDepAppRefWindow = new DepAppRefWindow(this, m_ManName);
				}
				return m_cachedDepAppRefWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Description window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepDescWindow IDepTypeControls.Desc
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.DescTitle)].Click();
				if ((m_cachedDepDescWindow == null))
				{
					m_cachedDepDescWindow = new DepDescWindow(this, m_ManName);
				}
				return m_cachedDepDescWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Name window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepNameWindow IDepTypeControls.Name
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.NameTitle)].Click();
				if ((m_cachedDepNameWindow == null))
				{
					m_cachedDepNameWindow = new DepNameWindow(this, m_ManName);
				}
				return m_cachedDepNameWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Trust Licenses window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepTLWindow IDepTypeControls.TL
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.TLTitle)].Click();
				if ((m_cachedDepTLWindow == null))
				{
					m_cachedDepTLWindow = new DepTLWindow(this, m_ManName);
				}
				return m_cachedDepTLWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Update Options window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepUpdateWindow IDepTypeControls.Update
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.UpdateTitle)].Click();
				if ((m_cachedDepUpdateWindow == null))
				{
					m_cachedDepUpdateWindow = new DepUpdateWindow(this, m_ManName);
				}
				return m_cachedDepUpdateWindow;
			}
		}

		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\AppWindows\AppFilesWindow.cs ===
namespace Maui.Mage.AppWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IAppFilesWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAppFilesWindowControls
    {
        StaticControl LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl  {get;}
        Button PopulateButton  {get;}
        Button EllipsisButton  {get;}
        TextBox NameTextBox  {get;}
        PropertyGridView VersionPropertyGridView  {get;}
        StaticControl ApplicationFilesStaticControl  {get;}
        StaticControl ApplicationDirectoryStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: AppFilesWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Class to describe the controls on the Files window for Application Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AppFilesWindow : Window, IAppFilesWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Files";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl = "label3";
            public const string PopulateButton = "btnPopulate";
            public const string EllipsisButton = "btnBrowse";
            public const string NameTextBox = "txtDirectory";
            public const string VersionPropertyGridView = "grid";
            public const string ApplicationFilesStaticControl = "label2";
            public const string ApplicationDirectoryStaticControl = "label1";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl;
        protected Button m_cachedPopulateButton;
        protected Button m_cachedEllipsisButton;
        protected TextBox m_cachedNameTextBox;
        protected PropertyGridView m_cachedVersionPropertyGridView;
        protected StaticControl m_cachedApplicationFilesStaticControl;
        protected StaticControl m_cachedApplicationDirectoryStaticControl;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for File window
		///  </summary>
		///  <param name="app">Window object owning the window.</param>
		///  <param name="Title"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AppFilesWindow(AppType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(AppType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAppFilesWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppFilesWindowControls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl
        {
            get
            {
                if ((m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl == null))
                {
                    m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl = new StaticControl(this, ControlIDs.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl);
                }
                return m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PopulateButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAppFilesWindowControls.PopulateButton
        {
            get
            {
                if ((m_cachedPopulateButton == null))
                {
                    m_cachedPopulateButton = new Button(this, ControlIDs.PopulateButton);
                }
                return m_cachedPopulateButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EllipsisButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAppFilesWindowControls.EllipsisButton
        {
            get
            {
                if ((m_cachedEllipsisButton == null))
                {
                    m_cachedEllipsisButton = new Button(this, ControlIDs.EllipsisButton);
                }
                return m_cachedEllipsisButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppFilesWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionPropertyGridView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        PropertyGridView IAppFilesWindowControls.VersionPropertyGridView
        {
            get
            {
                if ((m_cachedVersionPropertyGridView == null))
                {
                    m_cachedVersionPropertyGridView = new PropertyGridView((this));//, ControlIDs.VersionPropertyGridView);
                }
                return m_cachedVersionPropertyGridView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationFilesStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppFilesWindowControls.ApplicationFilesStaticControl
        {
            get
            {
                if ((m_cachedApplicationFilesStaticControl == null))
                {
                    m_cachedApplicationFilesStaticControl = new StaticControl(this, ControlIDs.ApplicationFilesStaticControl);
                }
                return m_cachedApplicationFilesStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationDirectoryStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppFilesWindowControls.ApplicationDirectoryStaticControl
        {
            get
            {
                if ((m_cachedApplicationDirectoryStaticControl == null))
                {
                    m_cachedApplicationDirectoryStaticControl = new StaticControl(this, ControlIDs.ApplicationDirectoryStaticControl);
                }
                return m_cachedApplicationDirectoryStaticControl;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Populate
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickPopulate()
        {
            Controls.PopulateButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis0()
        {
            Controls.EllipsisButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\AppWindows\AppNameWindow.cs ===
namespace Maui.Mage.AppWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IAppNameWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAppNameWindowControls
    {
        StaticControl NameStaticControl  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox NameTextBox  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox ProcessorEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl PublicKeyTokenStaticControl  {get;}
        TextBox PublicKeyTokenTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: AppNameWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Name window for Application Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AppNameWindow : Window, IAppNameWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Name";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string NameStaticControl = "lblName";
            public const string VersionStaticControl = "lblVersion";
            public const string NameTextBox = "txtName";
            public const string VersionTextBox = "txtVersion";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string ProcessorEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string CultureEditComboBox = "cbxCulture";
            public const string PublicKeyTokenStaticControl = "lblPublicKeyToken";
            public const string PublicKeyTokenTextBox = "txtPublicKeyToken";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedNameStaticControl;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedNameTextBox;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedProcessorEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedPublicKeyTokenStaticControl;
        protected TextBox m_cachedPublicKeyTokenTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Name window for Application Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		//  <param name="Title"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AppNameWindow(AppType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(AppType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAppNameWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Processor
        {
            get
            {
                return Controls.ProcessorEditComboBox.Text;
            }
            set
            {
                Controls.ProcessorEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken
        {
            get
            {
                return Controls.PublicKeyTokenTextBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppNameWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppNameWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAppNameWindowControls.ProcessorEditComboBox
        {
            get
            {
                if ((m_cachedProcessorEditComboBox == null))
                {
                    m_cachedProcessorEditComboBox = new EditComboBox(this, ControlIDs.ProcessorEditComboBox);
                }
                return m_cachedProcessorEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAppNameWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.PublicKeyTokenStaticControl
        {
            get
            {
                if ((m_cachedPublicKeyTokenStaticControl == null))
                {
                    m_cachedPublicKeyTokenStaticControl = new StaticControl(this, ControlIDs.PublicKeyTokenStaticControl);
                }
                return m_cachedPublicKeyTokenStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppNameWindowControls.PublicKeyTokenTextBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenTextBox == null))
                {
                    m_cachedPublicKeyTokenTextBox = new TextBox(this, ControlIDs.PublicKeyTokenTextBox);
                }
                return m_cachedPublicKeyTokenTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\SigningOptionsDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ISigningOptionsDialogControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISigningOptionsDialogControls
    {
        PropertyGridView KeyFilePropertyGridView  {get;}
        RadioButton SignWithStoredCertificateRadioButton  {get;}
        TextBox PasswordTextBox  {get;}
        StaticControl PasswordStaticControl  {get;}
        Button BrowseCerts  {get;}
        TextBox CertTextBox  {get;}
        StaticControl FileStaticControl  {get;}
        RadioButton SignWithCertificateFileRadioButton  {get;}
        Button NewButton  {get;}
        Button BrowseKeys  {get;}
        TextBox KeyTextBox  {get;}
        StaticControl FileStaticControl2  {get;}
        RadioButton SignWithKeypairFileRadioButton  {get;}
        Button DontSignButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion


#region "Enums for RadioButton groups"
    
    
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioSigningOptions
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    /// 	[a-dwils] 3/08/2004 Changed name from RadioGroup0 to RadioSigningOptions
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioSigningOptions
    {
        SignWithStoredCertificate = 0,
        SignWithCertificateFile = 1,
        SignWithKeypairFile = 2,
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: SigningOptionsDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Signing Options dialog in Mage
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SigningOptionsDialog : Dialog, ISigningOptionsDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Signing Options - ";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string KeyFilePropertyGridView = "grid";
            public const string SignWithStoredCertificateRadioButton = "rbStoredCert";
            public const string PasswordTextBox = "txtCertPassword";
            public const string PasswordStaticControl = "lblPassword";
            public const string BrowseCerts = "btnCertBrowse";
            public const string CertTextBox = "txtCertFile";
            public const string FileStaticControl = "lblCertFile";
            public const string SignWithCertificateFileRadioButton = "rbCertFile";
            public const string NewButton = "btnNewKeyFile";
            public const string BrowseKeys = "btnBrowseKeyFile";
            public const string KeyTextBox = "txtKeyFile";
            public const string FileStaticControl2 = "lblKeyFile";
            public const string SignWithKeypairFileRadioButton = "rbKeyFile";
            public const string DontSignButton = "btnDontSign";
            public const string OKButton = "btnOK";
            public const string CancelButton = "btnCancel";
        }

#endregion

#region "Member Variables"
        protected PropertyGridView m_cachedKeyFilePropertyGridView;
        protected RadioButton m_cachedSignWithStoredCertificateRadioButton;
        protected TextBox m_cachedPasswordTextBox;
        protected StaticControl m_cachedPasswordStaticControl;
        protected Button m_cachedBrowseCerts;
        protected TextBox m_cachedCertTextBox;
        protected StaticControl m_cachedFileStaticControl;
        protected RadioButton m_cachedSignWithCertificateFileRadioButton;
        protected Button m_cachedNewButton;
        protected Button m_cachedBrowseKeys;
        protected TextBox m_cachedKeyTextBox;
        protected StaticControl m_cachedFileStaticControl2;
        protected RadioButton m_cachedSignWithKeypairFileRadioButton;
        protected Button m_cachedDontSignButton;
        protected Button m_cachedOKButton;
        protected Button m_cachedCancelButton;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Signing Options dialog in Mage, calls base constructor with
        ///  instance from Init function
        ///  </summary>
        ///  <param name="app">MageApp object owning the dialog.</param>
        ///  <param name="Title"></param>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SigningOptionsDialog(MageApp app, string Title) : 
                base(app, Init(app, Title))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MageApp owning the dialog.</param>
        ///  <param name="Title"></param>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
		private static Window Init(MageApp app, string Title)
		{
			// First check if the dialog is already up.
			Window tempWindow = null;
			try
			{
				// Using WildCard match right now until bug 248525 is fixed
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.WildCard, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
				//tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle) + Title, StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				throw new Window.Exceptions.WindowNotFoundException("Init function could not find the Signing Options dialog.", ex);
			}
			return tempWindow;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISigningOptionsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioSigningOptions
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioSigningOptions RadioSigningOptions
        {
            get
            {
                if ((Controls.SignWithStoredCertificateRadioButton.ButtonState == ButtonState.Checked))
                    return RadioSigningOptions.SignWithStoredCertificate;

                if ((Controls.SignWithCertificateFileRadioButton.ButtonState == ButtonState.Checked))
                    return RadioSigningOptions.SignWithCertificateFile;

                if ((Controls.SignWithKeypairFileRadioButton.ButtonState == ButtonState.Checked))
                    return RadioSigningOptions.SignWithKeypairFile;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioSigningOptions.SignWithStoredCertificate))
                    Controls.SignWithStoredCertificateRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioSigningOptions.SignWithCertificateFile))
                    Controls.SignWithCertificateFileRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioSigningOptions.SignWithKeypairFile))
                    Controls.SignWithKeypairFileRadioButton.ButtonState = ButtonState.Checked;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Password
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Password
        {
            get
            {
                return Controls.PasswordTextBox.Text;
            }
            set
            {
                Controls.PasswordTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control File
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string File
        {
            get
            {
                return Controls.CertTextBox.Text;
            }
            set
            {
                Controls.CertTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control File2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string File2
        {
            get
            {
                return Controls.KeyTextBox.Text;
            }
            set
            {
                Controls.KeyTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyFilePropertyGridView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        PropertyGridView ISigningOptionsDialogControls.KeyFilePropertyGridView
        {
            get
            {
                if ((m_cachedKeyFilePropertyGridView == null))
                {
                    m_cachedKeyFilePropertyGridView = new PropertyGridView(this);//, ControlIDs.KeyFilePropertyGridView);
                }
                return m_cachedKeyFilePropertyGridView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignWithStoredCertificateRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISigningOptionsDialogControls.SignWithStoredCertificateRadioButton
        {
            get
            {
                if ((m_cachedSignWithStoredCertificateRadioButton == null))
                {
                    m_cachedSignWithStoredCertificateRadioButton = new RadioButton(this, ControlIDs.SignWithStoredCertificateRadioButton);
                }
                return m_cachedSignWithStoredCertificateRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PasswordTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISigningOptionsDialogControls.PasswordTextBox
        {
            get
            {
                if ((m_cachedPasswordTextBox == null))
                {
                    m_cachedPasswordTextBox = new TextBox(this, ControlIDs.PasswordTextBox);
                }
                return m_cachedPasswordTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PasswordStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISigningOptionsDialogControls.PasswordStaticControl
        {
            get
            {
                if ((m_cachedPasswordStaticControl == null))
                {
                    m_cachedPasswordStaticControl = new StaticControl(this, ControlIDs.PasswordStaticControl);
                }
                return m_cachedPasswordStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BrowseCerts control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.BrowseCerts
        {
            get
            {
                if ((m_cachedBrowseCerts == null))
                {
                    m_cachedBrowseCerts = new Button(this, ControlIDs.BrowseCerts);
                }
                return m_cachedBrowseCerts;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CertTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISigningOptionsDialogControls.CertTextBox
        {
            get
            {
                if ((m_cachedCertTextBox == null))
                {
                    m_cachedCertTextBox = new TextBox(this, ControlIDs.CertTextBox);
                }
                return m_cachedCertTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISigningOptionsDialogControls.FileStaticControl
        {
            get
            {
                if ((m_cachedFileStaticControl == null))
                {
                    m_cachedFileStaticControl = new StaticControl(this, ControlIDs.FileStaticControl);
                }
                return m_cachedFileStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignWithCertificateFileRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISigningOptionsDialogControls.SignWithCertificateFileRadioButton
        {
            get
            {
                if ((m_cachedSignWithCertificateFileRadioButton == null))
                {
                    m_cachedSignWithCertificateFileRadioButton = new RadioButton(this, ControlIDs.SignWithCertificateFileRadioButton);
                }
                return m_cachedSignWithCertificateFileRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NewButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.NewButton
        {
            get
            {
                if ((m_cachedNewButton == null))
                {
                    m_cachedNewButton = new Button(this, ControlIDs.NewButton);
                }
                return m_cachedNewButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BrowseKeys control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.BrowseKeys
        {
            get
            {
                if ((m_cachedBrowseKeys == null))
                {
                    m_cachedBrowseKeys = new Button(this, ControlIDs.BrowseKeys);
                }
                return m_cachedBrowseKeys;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISigningOptionsDialogControls.KeyTextBox
        {
            get
            {
                if ((m_cachedKeyTextBox == null))
                {
                    m_cachedKeyTextBox = new TextBox(this, ControlIDs.KeyTextBox);
                }
                return m_cachedKeyTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileStaticControl2 control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISigningOptionsDialogControls.FileStaticControl2
        {
            get
            {
                if ((m_cachedFileStaticControl2 == null))
                {
                    m_cachedFileStaticControl2 = new StaticControl(this, ControlIDs.FileStaticControl2);
                }
                return m_cachedFileStaticControl2;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignWithKeypairFileRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISigningOptionsDialogControls.SignWithKeypairFileRadioButton
        {
            get
            {
                if ((m_cachedSignWithKeypairFileRadioButton == null))
                {
                    m_cachedSignWithKeypairFileRadioButton = new RadioButton(this, ControlIDs.SignWithKeypairFileRadioButton);
                }
                return m_cachedSignWithKeypairFileRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DontSignButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.DontSignButton
        {
            get
            {
                if ((m_cachedDontSignButton == null))
                {
                    m_cachedDontSignButton = new Button(this, ControlIDs.DontSignButton);
                }
                return m_cachedDontSignButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis1
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis1()
        {
            Controls.BrowseCerts.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button New
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickNew()
        {
            Controls.NewButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis2()
        {
            Controls.BrowseKeys.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button DontSign
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickDontSign()
        {
            Controls.DontSignButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Signing Options dialog is up already
		///  </summary>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				// Using WildCard match right now until bug 248525 is fixed
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.WildCard, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
				//tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle) + Title, StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\LicType.cs ===
using System;
using Maui.Mage.LicWindows;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{

#region "ILicTypeControls interface definition"
     
		[EditorBrowsable(EditorBrowsableState.Never)]
		public interface ILicTypeControls
		{
			LicAppTrustWindow AppTrust  {get;}
			LicConditionsWindow Conditions {get;}
			LicPubTrustWindow PubTrust {get;}
			LicTitleWindow LicTitle {get;}
		}
#endregion

	/// -----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: LicType
	///  Copyright (C) 2004, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  Class to describe the controls shown when an Trust License is opened
	///  </summary>
	///  <history>
	/// 	[a-dwils] 1/14/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class LicType : BaseFile, ILicTypeControls
	{

#region "Strings"
		public class Strings
		{
			public const string LicTitle = "License Title";
			public const string AppTitle = "Application Being Trusted";
			public const string PubTitle = "Publisher Being Trusted";
			public const string CondTitle = "Conditions";
		}
#endregion

#region "Member Variables"
			LicAppTrustWindow m_cachedLicAppTrustWindow;
			LicConditionsWindow m_cachedLicConditionsWindow;
			LicPubTrustWindow m_cachedLicPubTrustWindow;
			LicTitleWindow m_cachedLicTitleWindow;
			public String m_ManName;
#endregion

#region "Constructors"
		/// <summary>
		/// Constructor for DepType that takes in the Tab corresponding to the file
		/// </summary>
		/// <param name="Tab"></param>
		/// <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		public LicType(TabControlTab Tab, MageApp app) : base(Tab)
		{
			// Check to make sure window is correct type by checking
			//	elements in ListBox
			if ( (base.List[0].Text.CompareTo(app.GetIntlStr(Strings.LicTitle)) != 0) ||
				(base.List[1].Text.CompareTo(app.GetIntlStr(Strings.AppTitle)) != 0) ||
				(base.List[2].Text.CompareTo(app.GetIntlStr(Strings.PubTitle)) != 0) ||
				(base.List[3].Text.CompareTo(app.GetIntlStr(Strings.CondTitle)) != 0) )
			{
				throw (new Exception("TabControlTab opened was not of LicType."));
			}
			m_storedApp = app;
			m_ManName = Tab.Text + "*";
		}
#endregion

#region "Properties"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>An interface that groups all of the window's control properties together</value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual ILicTypeControls Controls
		{
			get
			{
				return this;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Application Being Trusted window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicAppTrustWindow ILicTypeControls.AppTrust
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.AppTitle)].Click();
				if ((m_cachedLicAppTrustWindow == null))
				{
					m_cachedLicAppTrustWindow = new LicAppTrustWindow(this, m_ManName);
				}
				return m_cachedLicAppTrustWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Conditions window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicConditionsWindow ILicTypeControls.Conditions
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.CondTitle)].Click();
				if ((m_cachedLicConditionsWindow == null))
				{
					m_cachedLicConditionsWindow = new LicConditionsWindow(this, m_ManName);
				}
				return m_cachedLicConditionsWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Publisher Being Trusted window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicPubTrustWindow ILicTypeControls.PubTrust
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.PubTitle)].Click();
				if ((m_cachedLicPubTrustWindow == null))
				{
					m_cachedLicPubTrustWindow = new LicPubTrustWindow(this, m_ManName);
				}
				return m_cachedLicPubTrustWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the License Title window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicTitleWindow ILicTypeControls.LicTitle
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.LicTitle)].Click();
				if ((m_cachedLicTitleWindow == null))
				{
					m_cachedLicTitleWindow = new LicTitleWindow(this, m_ManName);
				}
				return m_cachedLicTitleWindow;
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\DepWindows\DepTLWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepTLWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepTLWindowControls
    {
        Button ExportButton  {get;}
        Button RemoveButton  {get;}
        Button AddButton  {get;}
        ListBox NameListBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepTLWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Trust License window for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepTLWindow : Window, IDepTLWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Trust Licenses";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string ExportButton = "btnExport";
            public const string RemoveButton = "btnRemove";
            public const string AddButton = "btnAdd";
            public const string NameListBox = "lbxLicenses";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedExportButton;
        protected Button m_cachedRemoveButton;
        protected Button m_cachedAddButton;
        protected ListBox m_cachedNameListBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Trust License window for Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepTLWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepTLWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExportButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepTLWindowControls.ExportButton
        {
            get
            {
                if ((m_cachedExportButton == null))
                {
                    m_cachedExportButton = new Button(this, ControlIDs.ExportButton);
                }
                return m_cachedExportButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RemoveButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepTLWindowControls.RemoveButton
        {
            get
            {
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepTLWindowControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameListBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox IDepTLWindowControls.NameListBox
        {
            get
            {
                if ((m_cachedNameListBox == null))
                {
                    m_cachedNameListBox = new ListBox(this, ControlIDs.NameListBox);
                }
                return m_cachedNameListBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Export
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickExport()
        {
            Controls.ExportButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Remove
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickRemove()
        {
            Controls.RemoveButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickAdd()
        {
            Controls.AddButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\LicWindows\LicAppTrustWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicAppTrustWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicAppTrustWindowControls
    {
        Button SelectApplicationButton  {get;}
        CheckBox LicenseValidForAllVersionsOfTheApplicationCheckBox  {get;}
        CheckBox LicenseAppliesOnlyToASpecificApplicationCheckBox  {get;}
        StaticControl ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl  {get;}
        StaticControl NameStaticControl  {get;}
        TextBox ExampleHttpServershareTextBox  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox ProcessorTextBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox PublicKeyTokenEditComboBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicAppTrustWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Application Being Trusted page for
    ///  Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicAppTrustWindow : Window, ILicAppTrustWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Application Being Trusted";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string SelectApplicationButton = "btnSelect";
            public const string LicenseValidForAllVersionsOfTheApplicationCheckBox = "chkValidForAllVersions";
            public const string LicenseAppliesOnlyToASpecificApplicationCheckBox = "chkSpecificApplication";
            public const string ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl = "lblInstructions";
            public const string NameStaticControl = "lblName";
            public const string ExampleHttpServershareTextBox = "txtName";
            public const string VersionStaticControl = "lblVersion";
            public const string ProcessorTextBox = "txtVersion";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string CultureEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string PublicKeyTokenEditComboBox = "cbxCulture";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedSelectApplicationButton;
        protected CheckBox m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox;
        protected CheckBox m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox;
        protected StaticControl m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl;
        protected StaticControl m_cachedNameStaticControl;
        protected TextBox m_cachedExampleHttpServershareTextBox;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedProcessorTextBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedPublicKeyTokenEditComboBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Application Being Trusted page for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicAppTrustWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicAppTrustWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox LicenseValidForAllVersionsOfTheApplication
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool LicenseValidForAllVersionsOfTheApplication
        {
            get
            {
                return Controls.LicenseValidForAllVersionsOfTheApplicationCheckBox.Checked;
            }
            set
            {
                Controls.LicenseValidForAllVersionsOfTheApplicationCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox LicenseAppliesOnlyToASpecificApplication
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool LicenseAppliesOnlyToASpecificApplication
        {
            get
            {
                return Controls.LicenseAppliesOnlyToASpecificApplicationCheckBox.Checked;
            }
            set
            {
                Controls.LicenseAppliesOnlyToASpecificApplicationCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ExampleHttpServershare
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ExampleHttpServershareText
        {
            get
            {
                return Controls.ExampleHttpServershareTextBox.Text;
            }
            set
            {
                Controls.ExampleHttpServershareTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ProcessorText
        {
            get
            {
                return Controls.ProcessorTextBox.Text;
            }
            set
            {
                Controls.ProcessorTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string CultureText
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string PublicKeyTokenText
        {
            get
            {
                return Controls.PublicKeyTokenEditComboBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SelectApplicationButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILicAppTrustWindowControls.SelectApplicationButton
        {
            get
            {
                if ((m_cachedSelectApplicationButton == null))
                {
                    m_cachedSelectApplicationButton = new Button(this, ControlIDs.SelectApplicationButton);
                }
                return m_cachedSelectApplicationButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LicenseValidForAllVersionsOfTheApplicationCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILicAppTrustWindowControls.LicenseValidForAllVersionsOfTheApplicationCheckBox
        {
            get
            {
                if ((m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox == null))
                {
                    m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox = new CheckBox(this, ControlIDs.LicenseValidForAllVersionsOfTheApplicationCheckBox);
                }
                return m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LicenseAppliesOnlyToASpecificApplicationCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILicAppTrustWindowControls.LicenseAppliesOnlyToASpecificApplicationCheckBox
        {
            get
            {
                if ((m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox == null))
                {
                    m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox = new CheckBox(this, ControlIDs.LicenseAppliesOnlyToASpecificApplicationCheckBox);
                }
                return m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl
        {
            get
            {
                if ((m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl == null))
                {
                    m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl = new StaticControl(this, ControlIDs.ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl);
                }
                return m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicAppTrustWindowControls.ExampleHttpServershareTextBox
        {
            get
            {
                if ((m_cachedExampleHttpServershareTextBox == null))
                {
                    m_cachedExampleHttpServershareTextBox = new TextBox(this, ControlIDs.ExampleHttpServershareTextBox);
                }
                return m_cachedExampleHttpServershareTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicAppTrustWindowControls.ProcessorTextBox
        {
            get
            {
                if ((m_cachedProcessorTextBox == null))
                {
                    m_cachedProcessorTextBox = new TextBox(this, ControlIDs.ProcessorTextBox);
                }
                return m_cachedProcessorTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ILicAppTrustWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ILicAppTrustWindowControls.PublicKeyTokenEditComboBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenEditComboBox == null))
                {
                    m_cachedPublicKeyTokenEditComboBox = new EditComboBox(this, ControlIDs.PublicKeyTokenEditComboBox);
                }
                return m_cachedPublicKeyTokenEditComboBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button SelectApplication
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickSelectApplication()
        {
            Controls.SelectApplicationButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\DepWindows\DepDescWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepDescWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepDescWindowControls
    {
        StaticControl PublisherStaticControl  {get;}
        TextBox PermissionSetTypeTextBox  {get;}
        StaticControl ProductStaticControl  {get;}
        TextBox NameTextBox  {get;}
        StaticControl SupportURLStaticControl  {get;}
        TextBox VersionTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepDescWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Description window for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepDescWindow : Window, IDepDescWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Description";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string PublisherStaticControl = "lblPublisher";
            public const string PermissionSetTypeTextBox = "txtPublisher";
            public const string ProductStaticControl = "lblProduct";
            public const string NameTextBox = "txtProduct";
            public const string SupportURLStaticControl = "lblSupportUrl";
            public const string VersionTextBox = "txtSupportUrl";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedPublisherStaticControl;
        protected TextBox m_cachedPermissionSetTypeTextBox;
        protected StaticControl m_cachedProductStaticControl;
        protected TextBox m_cachedNameTextBox;
        protected StaticControl m_cachedSupportURLStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Description window for Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepDescWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepDescWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PermissionSetType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PermissionSetType
        {
            get
            {
                return Controls.PermissionSetTypeTextBox.Text;
            }
            set
            {
                Controls.PermissionSetTypeTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublisherStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepDescWindowControls.PublisherStaticControl
        {
            get
            {
                if ((m_cachedPublisherStaticControl == null))
                {
                    m_cachedPublisherStaticControl = new StaticControl(this, ControlIDs.PublisherStaticControl);
                }
                return m_cachedPublisherStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PermissionSetTypeTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepDescWindowControls.PermissionSetTypeTextBox
        {
            get
            {
                if ((m_cachedPermissionSetTypeTextBox == null))
                {
                    m_cachedPermissionSetTypeTextBox = new TextBox(this, ControlIDs.PermissionSetTypeTextBox);
                }
                return m_cachedPermissionSetTypeTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProductStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepDescWindowControls.ProductStaticControl
        {
            get
            {
                if ((m_cachedProductStaticControl == null))
                {
                    m_cachedProductStaticControl = new StaticControl(this, ControlIDs.ProductStaticControl);
                }
                return m_cachedProductStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepDescWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SupportURLStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepDescWindowControls.SupportURLStaticControl
        {
            get
            {
                if ((m_cachedSupportURLStaticControl == null))
                {
                    m_cachedSupportURLStaticControl = new StaticControl(this, ControlIDs.SupportURLStaticControl);
                }
                return m_cachedSupportURLStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepDescWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\DepWindows\DepUpdateWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepUpdateWindowControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepUpdateWindowControls
    {
        CheckBox ThisApplicationShouldCheckForUpdatesCheckBox  {get;}
        CheckBox RequiredUpdateCheckBox  {get;}
        RadioButton InTheBackgroundAfterTheAppStartsRadioButton  {get;}
        RadioButton BeforeTheApplicationStartsRadioButton  {get;}
        RadioButton EveryTimeTheApplicationStartsRadioButton  {get;}
        RadioButton CheckEveryRadioButton  {get;}
        NumericUpDown ProcessorNumericUpDown  {get;}
        EditComboBox ExampleHttpServershareEditComboBox  {get;}
    }

#endregion


#region "Enums for RadioButton groups"
    
    
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioGroup0
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioGroup0
    {
        InTheBackgroundAfterTheAppStarts = 0,
        BeforeTheApplicationStarts = 1,
    }

    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioGroup1
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioGroup1
    {
        EveryTimeTheApplicationStarts = 0,
        CheckEvery = 1,
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepUpdateWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls for the Update Options page for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepUpdateWindow : Window, IDepUpdateWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Update Options";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string ThisApplicationShouldCheckForUpdatesCheckBox = "chkCheckForUpdates";
            public const string RequiredUpdateCheckBox = "chkRequiredUpdate";
            public const string InTheBackgroundAfterTheAppStartsRadioButton = "rbBackground";
            public const string BeforeTheApplicationStartsRadioButton = "rbBeforeStart";
            public const string EveryTimeTheApplicationStartsRadioButton = "rbEveryStart";
            public const string CheckEveryRadioButton = "rbInterval";
            public const string ProcessorNumericUpDown = "udNumber";
            public const string ExampleHttpServershareEditComboBox = "cbxUnits";
        }

#endregion

#region "Member Variables"
        protected CheckBox m_cachedThisApplicationShouldCheckForUpdatesCheckBox;
        protected CheckBox m_cachedRequiredUpdateCheckBox;
        protected RadioButton m_cachedInTheBackgroundAfterTheAppStartsRadioButton;
        protected RadioButton m_cachedBeforeTheApplicationStartsRadioButton;
        protected RadioButton m_cachedEveryTimeTheApplicationStartsRadioButton;
        protected RadioButton m_cachedCheckEveryRadioButton;
        protected NumericUpDown m_cachedProcessorNumericUpDown;
        protected EditComboBox m_cachedExampleHttpServershareEditComboBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		//// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Update Options page for Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepUpdateWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepUpdateWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioGroup0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioGroup0 RadioGroup0
        {
            get
            {
                if ((Controls.InTheBackgroundAfterTheAppStartsRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.InTheBackgroundAfterTheAppStarts;

                if ((Controls.BeforeTheApplicationStartsRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.BeforeTheApplicationStarts;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioGroup0.InTheBackgroundAfterTheAppStarts))
                    Controls.InTheBackgroundAfterTheAppStartsRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup0.BeforeTheApplicationStarts))
                    Controls.BeforeTheApplicationStartsRadioButton.ButtonState = ButtonState.Checked;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioGroup1
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioGroup1 RadioGroup1
        {
            get
            {
                if ((Controls.EveryTimeTheApplicationStartsRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup1.EveryTimeTheApplicationStarts;

                if ((Controls.CheckEveryRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup1.CheckEvery;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioGroup1.EveryTimeTheApplicationStarts))
                    Controls.EveryTimeTheApplicationStartsRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup1.CheckEvery))
                    Controls.CheckEveryRadioButton.ButtonState = ButtonState.Checked;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox ThisApplicationShouldCheckForUpdates
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool ThisApplicationShouldCheckForUpdates
        {
            get
            {
                return Controls.ThisApplicationShouldCheckForUpdatesCheckBox.Checked;
            }
            set
            {
                Controls.ThisApplicationShouldCheckForUpdatesCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox RequiredUpdate
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool RequiredUpdate
        {
            get
            {
                return Controls.RequiredUpdateCheckBox.Checked;
            }
            set
            {
                Controls.RequiredUpdateCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ExampleHttpServershare
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string ExampleHttpServershare
        {
            get
            {
                return Controls.ExampleHttpServershareEditComboBox.Text;
            }
            set
            {
                Controls.ExampleHttpServershareEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ThisApplicationShouldCheckForUpdatesCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IDepUpdateWindowControls.ThisApplicationShouldCheckForUpdatesCheckBox
        {
            get
            {
                if ((m_cachedThisApplicationShouldCheckForUpdatesCheckBox == null))
                {
                    m_cachedThisApplicationShouldCheckForUpdatesCheckBox = new CheckBox(this, ControlIDs.ThisApplicationShouldCheckForUpdatesCheckBox);
                }
                return m_cachedThisApplicationShouldCheckForUpdatesCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RequiredUpdateCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IDepUpdateWindowControls.RequiredUpdateCheckBox
        {
            get
            {
                if ((m_cachedRequiredUpdateCheckBox == null))
                {
                    m_cachedRequiredUpdateCheckBox = new CheckBox(this, ControlIDs.RequiredUpdateCheckBox);
                }
                return m_cachedRequiredUpdateCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the InTheBackgroundAfterTheAppStartsRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.InTheBackgroundAfterTheAppStartsRadioButton
        {
            get
            {
                if ((m_cachedInTheBackgroundAfterTheAppStartsRadioButton == null))
                {
                    m_cachedInTheBackgroundAfterTheAppStartsRadioButton = new RadioButton(this, ControlIDs.InTheBackgroundAfterTheAppStartsRadioButton);
                }
                return m_cachedInTheBackgroundAfterTheAppStartsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BeforeTheApplicationStartsRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.BeforeTheApplicationStartsRadioButton
        {
            get
            {
                if ((m_cachedBeforeTheApplicationStartsRadioButton == null))
                {
                    m_cachedBeforeTheApplicationStartsRadioButton = new RadioButton(this, ControlIDs.BeforeTheApplicationStartsRadioButton);
                }
                return m_cachedBeforeTheApplicationStartsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EveryTimeTheApplicationStartsRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.EveryTimeTheApplicationStartsRadioButton
        {
            get
            {
                if ((m_cachedEveryTimeTheApplicationStartsRadioButton == null))
                {
                    m_cachedEveryTimeTheApplicationStartsRadioButton = new RadioButton(this, ControlIDs.EveryTimeTheApplicationStartsRadioButton);
                }
                return m_cachedEveryTimeTheApplicationStartsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CheckEveryRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.CheckEveryRadioButton
        {
            get
            {
                if ((m_cachedCheckEveryRadioButton == null))
                {
                    m_cachedCheckEveryRadioButton = new RadioButton(this, ControlIDs.CheckEveryRadioButton);
                }
                return m_cachedCheckEveryRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorNumericUpDown control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        NumericUpDown IDepUpdateWindowControls.ProcessorNumericUpDown
        {
            get
            {
                if ((m_cachedProcessorNumericUpDown == null))
                {
                    m_cachedProcessorNumericUpDown = new NumericUpDown(this, ControlIDs.ProcessorNumericUpDown);
                }
                return m_cachedProcessorNumericUpDown;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepUpdateWindowControls.ExampleHttpServershareEditComboBox
        {
            get
            {
                if ((m_cachedExampleHttpServershareEditComboBox == null))
                {
                    m_cachedExampleHttpServershareEditComboBox = new EditComboBox(this, ControlIDs.ExampleHttpServershareEditComboBox);
                }
                return m_cachedExampleHttpServershareEditComboBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\DepWindows\DepAppRefWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepAppRefWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepAppRefWindowControls
    {
        StaticControl ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl  {get;}
        Button SelectManifestButton  {get;}
        StaticControl LocationStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl NameStaticControl  {get;}
        TextBox ExampleHttpServershareTextBox  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox ProcessorTextBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox PublicKeyTokenEditComboBox  {get;}
        StaticControl PublicKeyTokenStaticControl  {get;}
        TextBox CultureTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepAppRefWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls shown on the Application Reference page for
    ///  Deployment Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepAppRefWindow : Window, IDepAppRefWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Application Reference";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl = "lblInstructions";
            public const string SelectManifestButton = "btnBrowse";
            public const string LocationStaticControl = "lblLocation";
            public const string VersionTextBox = "txtLocation";
            public const string NameStaticControl = "lblName";
            public const string ExampleHttpServershareTextBox = "txtName";
            public const string VersionStaticControl = "lblVersion";
            public const string ProcessorTextBox = "txtVersion";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string CultureEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string PublicKeyTokenEditComboBox = "cbxCulture";
            public const string PublicKeyTokenStaticControl = "lblPublicKeyToken";
            public const string CultureTextBox = "txtPublicKeyToken";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl;
        protected Button m_cachedSelectManifestButton;
        protected StaticControl m_cachedLocationStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedNameStaticControl;
        protected TextBox m_cachedExampleHttpServershareTextBox;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedProcessorTextBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedPublicKeyTokenEditComboBox;
        protected StaticControl m_cachedPublicKeyTokenStaticControl;
        protected TextBox m_cachedCultureTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Application Referecne window of Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepAppRefWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepAppRefWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ExampleHttpServershare
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string ExampleHttpServershare
        {
            get
            {
                return Controls.ExampleHttpServershareTextBox.Text;
            }
            set
            {
                Controls.ExampleHttpServershareTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Processor
        {
            get
            {
                return Controls.ProcessorTextBox.Text;
            }
            set
            {
                Controls.ProcessorTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken
        {
            get
            {
                return Controls.PublicKeyTokenEditComboBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture2
        {
            get
            {
                return Controls.CultureTextBox.Text;
            }
            set
            {
                Controls.CultureTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl
        {
            get
            {
                if ((m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl == null))
                {
                    m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl = new StaticControl(this, ControlIDs.ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl);
                }
                return m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SelectManifestButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepAppRefWindowControls.SelectManifestButton
        {
            get
            {
                if ((m_cachedSelectManifestButton == null))
                {
                    m_cachedSelectManifestButton = new Button(this, ControlIDs.SelectManifestButton);
                }
                return m_cachedSelectManifestButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocationStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.LocationStaticControl
        {
            get
            {
                if ((m_cachedLocationStaticControl == null))
                {
                    m_cachedLocationStaticControl = new StaticControl(this, ControlIDs.LocationStaticControl);
                }
                return m_cachedLocationStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.ExampleHttpServershareTextBox
        {
            get
            {
                if ((m_cachedExampleHttpServershareTextBox == null))
                {
                    m_cachedExampleHttpServershareTextBox = new TextBox(this, ControlIDs.ExampleHttpServershareTextBox);
                }
                return m_cachedExampleHttpServershareTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.ProcessorTextBox
        {
            get
            {
                if ((m_cachedProcessorTextBox == null))
                {
                    m_cachedProcessorTextBox = new TextBox(this, ControlIDs.ProcessorTextBox);
                }
                return m_cachedProcessorTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepAppRefWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepAppRefWindowControls.PublicKeyTokenEditComboBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenEditComboBox == null))
                {
                    m_cachedPublicKeyTokenEditComboBox = new EditComboBox(this, ControlIDs.PublicKeyTokenEditComboBox);
                }
                return m_cachedPublicKeyTokenEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.PublicKeyTokenStaticControl
        {
            get
            {
                if ((m_cachedPublicKeyTokenStaticControl == null))
                {
                    m_cachedPublicKeyTokenStaticControl = new StaticControl(this, ControlIDs.PublicKeyTokenStaticControl);
                }
                return m_cachedPublicKeyTokenStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.CultureTextBox
        {
            get
            {
                if ((m_cachedCultureTextBox == null))
                {
                    m_cachedCultureTextBox = new TextBox(this, ControlIDs.CultureTextBox);
                }
                return m_cachedCultureTextBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button SelectManifest
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickSelectManifest()
        {
            Controls.SelectManifestButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\AppWindows\AppPermWindow.cs ===
namespace Maui.Mage.AppWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IAppPermWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAppPermWindowControls
    {
        StaticControl DetailsStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        EditComboBox NameEditComboBox  {get;}
        StaticControl PermissionSetTypeStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: AppPermWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Permissions window for Application Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AppPermWindow : Window, IAppPermWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Permissions Required";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string DetailsStaticControl = "label2";
            public const string VersionTextBox = "textBox";
            public const string NameEditComboBox = "cbxPermissions";
            public const string PermissionSetTypeStaticControl = "label1";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedDetailsStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected EditComboBox m_cachedNameEditComboBox;
        protected StaticControl m_cachedPermissionSetTypeStaticControl;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Permissions window of Application Manifests
		///  </summary>
		///  <param name="app">Window object owning the window.</param>
		///  <param name="Title"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AppPermWindow(AppType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(AppType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAppPermWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameEditComboBox.Text;
            }
            set
            {
                Controls.NameEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DetailsStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppPermWindowControls.DetailsStaticControl
        {
            get
            {
                if ((m_cachedDetailsStaticControl == null))
                {
                    m_cachedDetailsStaticControl = new StaticControl(this, ControlIDs.DetailsStaticControl);
                }
                return m_cachedDetailsStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppPermWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAppPermWindowControls.NameEditComboBox
        {
            get
            {
                if ((m_cachedNameEditComboBox == null))
                {
                    m_cachedNameEditComboBox = new EditComboBox(this, ControlIDs.NameEditComboBox);
                }
                return m_cachedNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PermissionSetTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppPermWindowControls.PermissionSetTypeStaticControl
        {
            get
            {
                if ((m_cachedPermissionSetTypeStaticControl == null))
                {
                    m_cachedPermissionSetTypeStaticControl = new StaticControl(this, ControlIDs.PermissionSetTypeStaticControl);
                }
                return m_cachedPermissionSetTypeStaticControl;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\DepWindows\DepNameWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepNameWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepNameWindowControls
    {
        StaticControl NameStaticControl  {get;}
        TextBox PermissionSetTypeTextBox  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox NameTextBox  {get;}
        StaticControl Example1000StaticControl  {get;}
        StaticControl RunLocationStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl ExampleHttpServershareStaticControl  {get;}
        StaticControl ApplicationTypeStaticControl  {get;}
        EditComboBox ProcessorEditComboBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox PublicKeyTokenEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl PublicKeyTokenStaticControl  {get;}
        TextBox PublicKeyTokenTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepNameWindow
    ///  Copyright (C) 2004 Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Name window for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepNameWindow : Window, IDepNameWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Name";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string NameStaticControl = "lblName";
            public const string PermissionSetTypeTextBox = "txtName";
            public const string VersionStaticControl = "lblVersion";
            public const string NameTextBox = "txtVersion";
            public const string Example1000StaticControl = "lblVersionExample";
            public const string RunLocationStaticControl = "lblRunLocation";
            public const string VersionTextBox = "txtLocation";
            public const string ExampleHttpServershareStaticControl = "lblRunLocationExample";
            public const string ApplicationTypeStaticControl = "lblApplicationType";
            public const string ProcessorEditComboBox = "cbxApplicationType";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string PublicKeyTokenEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string CultureEditComboBox = "cbxCulture";
            public const string PublicKeyTokenStaticControl = "lblPublicKeyToken";
            public const string PublicKeyTokenTextBox = "txtPublicKeyToken";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedNameStaticControl;
        protected TextBox m_cachedPermissionSetTypeTextBox;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedNameTextBox;
        protected StaticControl m_cachedExample1000StaticControl;
        protected StaticControl m_cachedRunLocationStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedExampleHttpServershareStaticControl;
        protected StaticControl m_cachedApplicationTypeStaticControl;
        protected EditComboBox m_cachedProcessorEditComboBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedPublicKeyTokenEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedPublicKeyTokenStaticControl;
        protected TextBox m_cachedPublicKeyTokenTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Name window for Deployment manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepNameWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepNameWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PermissionSetType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PermissionSetType
        {
            get
            {
                return Controls.PermissionSetTypeTextBox.Text;
            }
            set
            {
                Controls.PermissionSetTypeTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Processor
        {
            get
            {
                return Controls.ProcessorEditComboBox.Text;
            }
            set
            {
                Controls.ProcessorEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken
        {
            get
            {
                return Controls.PublicKeyTokenEditComboBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken2
        {
            get
            {
                return Controls.PublicKeyTokenTextBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PermissionSetTypeTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.PermissionSetTypeTextBox
        {
            get
            {
                if ((m_cachedPermissionSetTypeTextBox == null))
                {
                    m_cachedPermissionSetTypeTextBox = new TextBox(this, ControlIDs.PermissionSetTypeTextBox);
                }
                return m_cachedPermissionSetTypeTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Example1000StaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.Example1000StaticControl
        {
            get
            {
                if ((m_cachedExample1000StaticControl == null))
                {
                    m_cachedExample1000StaticControl = new StaticControl(this, ControlIDs.Example1000StaticControl);
                }
                return m_cachedExample1000StaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RunLocationStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.RunLocationStaticControl
        {
            get
            {
                if ((m_cachedRunLocationStaticControl == null))
                {
                    m_cachedRunLocationStaticControl = new StaticControl(this, ControlIDs.RunLocationStaticControl);
                }
                return m_cachedRunLocationStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.ExampleHttpServershareStaticControl
        {
            get
            {
                if ((m_cachedExampleHttpServershareStaticControl == null))
                {
                    m_cachedExampleHttpServershareStaticControl = new StaticControl(this, ControlIDs.ExampleHttpServershareStaticControl);
                }
                return m_cachedExampleHttpServershareStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.ApplicationTypeStaticControl
        {
            get
            {
                if ((m_cachedApplicationTypeStaticControl == null))
                {
                    m_cachedApplicationTypeStaticControl = new StaticControl(this, ControlIDs.ApplicationTypeStaticControl);
                }
                return m_cachedApplicationTypeStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepNameWindowControls.ProcessorEditComboBox
        {
            get
            {
                if ((m_cachedProcessorEditComboBox == null))
                {
                    m_cachedProcessorEditComboBox = new EditComboBox(this, ControlIDs.ProcessorEditComboBox);
                }
                return m_cachedProcessorEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepNameWindowControls.PublicKeyTokenEditComboBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenEditComboBox == null))
                {
                    m_cachedPublicKeyTokenEditComboBox = new EditComboBox(this, ControlIDs.PublicKeyTokenEditComboBox);
                }
                return m_cachedPublicKeyTokenEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepNameWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.PublicKeyTokenStaticControl
        {
            get
            {
                if ((m_cachedPublicKeyTokenStaticControl == null))
                {
                    m_cachedPublicKeyTokenStaticControl = new StaticControl(this, ControlIDs.PublicKeyTokenStaticControl);
                }
                return m_cachedPublicKeyTokenStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.PublicKeyTokenTextBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenTextBox == null))
                {
                    m_cachedPublicKeyTokenTextBox = new TextBox(this, ControlIDs.PublicKeyTokenTextBox);
                }
                return m_cachedPublicKeyTokenTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\ActionsPane.cs ===
namespace Maui.ManagementConsole
{

	using System;
	using System.Collections;
	using System.ComponentModel;

    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    


    #region Class for Action Items
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Actions Pane Items inside MMC 2.1
    /// </summary>
    /// <history>
    /// 	[faisalb] 11/1/2004 Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class ActionItem : Core.RemotingObject
    {
        #region Exceptions
        public class Exceptions
		{
			public class ActionItemNotFoundException : Maui.GlobalExceptions.MauiException
			{
				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				/// <param name="innerException">Inner Exception</param>
				public ActionItemNotFoundException(string message, System.Exception innerException):base(message, innerException)
				{

				}

				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				public ActionItemNotFoundException(string message):base(message)
				{
				}

                protected ActionItemNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {
                    
                }

			}
			public class ActionItemHasNoSubItemsException : Maui.GlobalExceptions.MauiException
			{
				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				/// <param name="innerException">Inner Exception</param>
				public ActionItemHasNoSubItemsException(string message, System.Exception innerException):base(message, innerException)
				{
				}

				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				public ActionItemHasNoSubItemsException(string message):base(message)
				{
				}
				/// <summary>
				/// Call to throw exception
				/// </summary>
				public ActionItemHasNoSubItemsException():base("This ActionItem does not have any sub-items")
				{
				}

                protected ActionItemHasNoSubItemsException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }
            }
        #endregion
        }

        #region Constructors, private variables
        
        private ActiveAccessibility m_actionItem = null;

		internal ActionItem(ActiveAccessibility actionItem)
		{
			m_actionItem = actionItem;
        }
        #endregion

        #region Methods

        /// <summary>
        /// Call this method to click/execute Action Item
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Update code to make sure item is visible
        /// </history>

        /// </summary>
		public void Execute()
		{
			UISynchronization.WaitForUIObjectReady(m_actionItem);

            m_actionItem.Window.WaitForResponse(ActionsGroup.DefaultTimeOut);
            //Calling ScrollToScreen to make sure item is inscreen
            ScrollToScreen();

            //Now click the item.
			m_actionItem.Click();

            //In new implementation of MMC 2.1, just after clicking MMC deletes object
            //So DONT call any function here which use action item
            //m_actionItem.Window.WaitForResponse(ActionsGroup.DefaultTimeOut);
		}

        private void ScrollToScreen()
        {
            ActiveAccessibility scrollBar = m_actionItem.Parent.Children[0];
            //If item is not ScrollBar or Item's Width is 0 or Heigh is 0, then no need to scroll
            if (scrollBar.Role == (int)MsaaRole.ScrollBar && scrollBar.Width > 0 && scrollBar.Height > 0)
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionItem.Parent;
                parentBotton = parent.Y + parent.Height;
                while (!Visible)
                {
                    actionBotton = m_actionItem.Y + m_actionItem.Height;
                    //Scroll Down
                    if (actionBotton > parentBotton)
                    {
                        scrollBar.Children[4].Click();
                    }
                    else //Scroll Up
                    {
                        scrollBar.Children[0].Click();
                    }
                }
            }
        }
        #endregion

        #region Properties

        internal ActiveAccessibility AccessibleObject
        {
            get
            {
                return m_actionItem;
            }
        }

        /// <summary>
        /// Call this method to find if item is Visible in Screen.
        /// </summary>
        public bool Visible
        {
            get
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionItem.Parent;
                actionBotton = m_actionItem.Y + m_actionItem.Height;
                parentBotton = parent.Y + parent.Height;

                return (m_actionItem.Y >= parent.Y && actionBotton <= parentBotton);
            }
        }

        /// <summary>
        /// Call this property to get Action Item Name
        /// </summary>
        /// <value>Action Item Name</value>
		public string Name
		{
			get
			{
				return m_actionItem.Name;
			}
		}

        /// <summary>
        /// Call this property to get SubItems of Action Item. If no SubItems found, this will throw ActionItemHasNoSubItemsException
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated to check if Menu is MMC Action Group
        /// </history>
        /// <param name="index">Index of Action Item</param>
        /// <returns>Menu Item</returns>
		public MenuItem this[int index]
		{
            get
            {
                if (!HasSubMenu)
                    throw new Exceptions.ActionItemHasNoSubItemsException();
                this.Execute();
                Menu menu = new Menu(ActionsGroup.DefaultTimeOut);

                //if there was no Context Menu then it will catch MMC Action Group which is not a Context Menu
                if (menu.AccessibleObject.Window.ClassName == ActionsGroup.MmcActionGroupClassName)
                    throw new Exceptions.ActionItemHasNoSubItemsException();
                return menu[index, true];
            }
        }

        /// <summary>
        /// Call this property to get SubItems of Action Item. If no SubItems found, this will throw ActionItemHasNoSubItemsException
        /// </summary>
        /// <param name="actionName">Name of Action Item</param>
        /// <returns>Menu Item</returns>
        public MenuItem this[string actionName]
        {
            get
            {
                return this[actionName, true];
            }
        }
        
        /// <summary>
        /// Call this property to get SubItems of Action Item. If no SubItems found, this will throw ActionItemHasNoSubItemsException
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated to check if Menu is MMC Action Group
        /// </history>
        /// <param name="actionName">Name of Action Item</param>
        /// <param name="caseSensitive">Case Sensitve</param>
        /// <returns>Menu Item</returns>

        public MenuItem this[string actionName, bool caseSensitive]
        {
            get
            {
                if (!HasSubMenu)
                {
                    throw new Exceptions.ActionItemHasNoSubItemsException();
                }
                Execute();
                Menu menu = new Menu(ActionsGroup.DefaultTimeOut);
                if (menu == null || menu.AccessibleObject.Window.ClassName == ActionsGroup.MmcActionGroupClassName)
                    throw new Exceptions.ActionItemHasNoSubItemsException();

                return menu[actionName, caseSensitive];
            }
        }

        /// <summary>
        /// Call this function to find number of Menu Items
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated to check if Menu is MMC Action Group
        /// </history>
        public int Count
        {
            get
            {
                if (HasSubMenu == false)
                    return 0;
                this.Execute();
                Menu menu = new Menu(ActionsGroup.DefaultTimeOut);
                if (menu.AccessibleObject.Window.ClassName == ActionsGroup.MmcActionGroupClassName)
                    return 0;
                return menu.MenuItems.Count;
            }
        }

        /// <summary>
        /// Call this property to find wheather this Action Item has Sub Items
        /// </summary>
        /// <value>boolean</value>
		public bool HasSubMenu
		{
			get
			{
				return m_actionItem.Role == ActionsGroup.PopupMenuRole;
			}
		}

        /// <summary>
        /// Call this function to find if Action Group is rendered as region
        /// </summary>
        /// <history>
        /// 	[faisalb]   3/22/2005   Created
        /// </history>
        public bool RenderedAsRegion
        {
            get
            {
                return m_actionItem.Role == (int)MsaaRole.Grouping;
            }
        }

        /// <summary>
        /// Call this function to find if Action is Checked
        /// </summary>
        /// <history>
        /// 	[faisalb]   3/22/2005   Created
        /// </history>
        public bool Checked
        {
            get
            {
                return (m_actionItem.State & (int)MsaaStates.Checked) == (int)MsaaStates.Checked;
            }
        }

        /// <summary>
        /// Call this function to find if Action is Enabled
        /// </summary>
        /// <history>
        /// 	[faisalb]   3/22/2005   Created
        /// </history>
        public bool Enabled
        {
            get
            {
                return !((m_actionItem.State & (int)MsaaStates.Unavailable) == (int)MsaaStates.Unavailable);
            }
        }

        #endregion
	}
    #endregion

    #region Class for Actions Group
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Actions Pane Groups inside MMC 2.1
    /// </summary>
    /// <history>
    /// 	[faisalb]   11/1/2004   Created
    ///     [faisalb]   22/3/2005   Updated class to take care of custom ScrollBar
    /// </history>
    /// -----------------------------------------------------------------------------

    public class ActionsGroup: Core.RemotingObject
    {
        #region Exceptions
        public class Exceptions
		{
			public class ActionGroupNotFound : GlobalExceptions.MauiException
			{
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                public ActionGroupNotFound(string message):base(message)
				{
				}
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                /// <param name="innerException">Inner Exception</param>
                public ActionGroupNotFound(string message, Exception innerException):base(message, innerException)
				{
				}

                protected ActionGroupNotFound(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }
			}
            public class ActionGroupNotExpanded : GlobalExceptions.MauiException
            {
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                public ActionGroupNotExpanded(string message):base(message)
				{
				}
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                /// <param name="innerException">Inner Exception</param>
                public ActionGroupNotExpanded(string message, Exception innerException):base(message, innerException)
				{
				}

                protected ActionGroupNotExpanded(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }

            }
            public class ActionGroupNotCollapsed : GlobalExceptions.MauiException
            {
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                public ActionGroupNotCollapsed(string message):base(message)
                {
                }
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                /// <param name="innerException">Inner Exception</param>
                public ActionGroupNotCollapsed(string message, Exception innerException):base(message, innerException)
                {
                }

                protected ActionGroupNotCollapsed(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }

            }
        }
        #endregion

        #region Constructors and Private Variables
        
        private ActiveAccessibility m_actionsGroup = null;

        #region Constants

        internal const int GroupRole = 64;
		internal const int PopupMenuRole = (int)MsaaRole.MenuPopup; //11
		internal const int DefaultTimeOut = 2000;
        internal const string MmcActionGroupClassName = "AfxFrameOrView42u";

        #endregion

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        internal ActionsGroup(ActiveAccessibility actionPane, int index)
		{
			int ChildCount = actionPane.ChildCount;
            //Changed to 1 from 0. Because now 0th will be a custom scrollbar.
            for (int i = 1; i < ChildCount; i++)
			{
				if (actionPane.Children[i].Role == GroupRole)
				{
					if (index == 0)
					{
						m_actionsGroup = actionPane.Children[i];
						break;
					}
					index--;
				}
			}
			if (m_actionsGroup == null)
			{
				throw new ActionsGroup.Exceptions.ActionGroupNotFound("Could not find ActionGroup as index " + index);
			}
		}

        internal ActionsGroup(ActiveAccessibility actionPane, string groupName):this(actionPane, groupName, true)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        internal ActionsGroup(ActiveAccessibility actionPane, string groupName, bool caseSensitive)
		{
			int ChildCount = actionPane.ChildCount;
			ActiveAccessibility performaceChild;

            //Changed to 1 from 0. Because now 0th will be a custom scrollbar.
            for (int i = 1; i < ChildCount; i++)
			{
				performaceChild = actionPane.Children[i];

                if (string.Compare(performaceChild.Name, groupName, !caseSensitive) == 0)
                {
                    m_actionsGroup = performaceChild;
                    break;
                }
            }
			if (m_actionsGroup == null)
			{
				throw new ActionsGroup.Exceptions.ActionGroupNotFound("Could not find ActionGroup as " + groupName);
			}
		}
        #endregion

        #region Properties
        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        internal ActiveAccessibility Parent
		{
			get
			{
				return m_actionsGroup.Parent;
			}
		}
        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
		internal ActiveAccessibility AccessibleObject
		{
			get
			{
				return m_actionsGroup;
			}
		}

        /// <summary>
        /// Call this property to find wheather Action Group is expended or collapsed
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        /// <value>boolean</value>
		public bool Expanded
		{
			get
			{
				return (m_actionsGroup.State & (int)MsaaStates.Expanded) == (int)MsaaStates.Expanded;
			}
		}

        /// <summary>
        /// Call this indexer to get Action Item from Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        /// <param name="index">Index of Action Item</param>
        /// <returns>Action Item</returns>
		public ActionItem this[int index]
		{
			get
			{
				int childCount = m_actionsGroup.Parent.ChildCount;
                if (childCount == ActionsGroup.GetIndex(m_actionsGroup) - 1)
				{
					throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as index " + index);
				}

				ActiveAccessibility actionItem = null;
				ActiveAccessibility actionPane = m_actionsGroup.Parent;
                
				ActiveAccessibility performaceChild;
                for (int i = ActionsGroup.GetIndex(m_actionsGroup) + 1; i < childCount; i++, index--)
				{
					performaceChild = actionPane.Children[i];
					if (index == 0 && performaceChild.Role != GroupRole)
					{
						actionItem = performaceChild;
						break;
					}

					if (performaceChild.Role == GroupRole)
					{
						throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as index " + index);
					}
				}

				return new ActionItem(actionItem);
			}
		}

		/// <summary>
        /// Call this indexer to get Action Item from Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
		/// <param name="actionName">Name of Action Item</param>
		/// <param name="caseSensitive">Case Sensitive</param>
		/// <returns>Action Item</returns>
        public ActionItem this[string actionName, bool caseSensitive]
		{
			get
			{
				int childCount = m_actionsGroup.Parent.ChildCount;
				if (childCount == ActionsGroup.GetIndex(m_actionsGroup) - 1)
				{
					throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as " + actionName);
				}

				ActiveAccessibility actionItem = null;
				ActiveAccessibility actionPane = m_actionsGroup.Parent;

				ActiveAccessibility performaceChild;
				for (int i = ActionsGroup.GetIndex(m_actionsGroup) + 1; i < childCount; i++)
				{
					performaceChild = actionPane.Children[i];
					if (performaceChild.Role == GroupRole)
					{
						throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as " + actionName);
					}

                    if (string.Compare(performaceChild.Name, actionName, !caseSensitive) == 0)
                    {
                        actionItem = actionPane.Children[i];
                        break;
                    }
				}

				return new ActionItem(actionItem);
			}
		}
        /// <summary>
        /// Call this indexer to get Action Item from Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        /// <param name="actionName">Name of Action Item</param>
        /// <returns>Action Item</returns>
        public ActionItem this[string actionName]
		{
			get
			{
				return this[actionName, true];
			}
		}

        /// <summary>
        /// Call this property to get name of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        /// <value></value>
		public string Name
		{
			get
			{
				return m_actionsGroup.Name;
			}
		}

        /// <summary>
        /// Call this property to get Count of Action Items in Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        /// <value>Count of Action Items</value>
		public int Count
		{
			get
			{
                int i, returnCount, childCount = m_actionsGroup.Parent.ChildCount;
                if (childCount == ActionsGroup.GetIndex(m_actionsGroup) - 1)
                    return 0;
                for (i = ActionsGroup.GetIndex(m_actionsGroup) + 1, returnCount = 0; i < childCount; i++)
                {
                    if (m_actionsGroup.Parent.Children[i].Role == GroupRole)
                        break;
                    returnCount++;
                }
                return returnCount;
            }
		}

        /// <summary>
        /// Call this property to find if Action Group is visible and in screen
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        public bool Visible
        {
            get
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionsGroup.Parent;
                actionBotton = m_actionsGroup.Y + m_actionsGroup.Height;
                parentBotton = parent.Y + parent.Height;

                return (m_actionsGroup.Y >= parent.Y && actionBotton <= parentBotton);
            }
        }

        #endregion

        #region Methods
        /// <summary>
        /// Call this method to Expand Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        public void Expand()
		{
			UISynchronization.WaitForUIObjectReady(m_actionsGroup);
			if (Expanded)
				return;
			//NativeMethods.SendMessageBynum(m_actionsGroup.Window.Extended.HWnd, NativeMethods.TVM_EXPAND, new IntPtr(NativeMethods.TVE_EXPAND), m_actionsGroup.Window.Extended.HWnd);
            this.Execute(); 
            
            if (!Expanded)
                throw new Exceptions.ActionGroupNotExpanded("Action Group " + this.Name + " not expanded");

        }

        /// <summary>
        /// Call this method to Collapse Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        public void Collapse()
        {
			UISynchronization.WaitForUIObjectReady(m_actionsGroup);
            if (!Expanded)
				return;
			//NativeMethods.SendMessageBynum(m_actionsGroup.Window.Extended.HWnd, NativeMethods.TVM_EXPAND, new IntPtr(NativeMethods.TVE_COLLAPSE), m_actionsGroup.Window.Extended.HWnd);

            this.Execute();

            if (Expanded)
                throw new Exceptions.ActionGroupNotCollapsed("Action Group " + this.Name + " not collapsed");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        private void Execute()
        {
            m_actionsGroup.Window.WaitForResponse(2000);
            m_actionsGroup.Window.Extended.SetFocus();

            //NativeMethods.SendMessageBynum(_ActionsGroup.Window.Extended.HWnd, NativeMethods.TVM_EXPAND, new IntPtr(NativeMethods.TVE_COLLAPSE), _ActionsGroup.Window.Extended.HWnd);
            ScrollToScreen();
            m_actionsGroup.Click();

            m_actionsGroup.Window.WaitForResponse(2000);

        }
        /// <summary>
        /// Call this method to get Action Group if your Action Group is rendered as region
        /// </summary>
        /// <history>
        ///     [faisalb]   3/22/2005   Created
        /// </history>
        /// <param name="actionRegionName">Name Action Group</param>
        /// <returns>Instance of ActionItemAsRegion</returns>
        public ActionItemAsRegion ActionItemAsRegion(string actionRegionName)
        {
            ActiveAccessibility ActiveAccessibility = this[actionRegionName].AccessibleObject;
            if (ActiveAccessibility.Role != (int)MsaaRole.Grouping)
                throw new ActionItem.Exceptions.ActionItemNotFoundException(actionRegionName + " is not Rendered as region. Hint: Use ActionItem instead of ActionItemAsRegion");

            return new ActionItemAsRegion(ActiveAccessibility);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        ///     [faisalb]   3/22/2005   Created
        /// </history>
        private void ScrollToScreen()
        {
            ActiveAccessibility scrollBar = m_actionsGroup.Parent.Children[0];
            //If item is not ScrollBar or Item's Width is 0 or Heigh is 0, then no need to scroll
            if (scrollBar.Role == (int)MsaaRole.ScrollBar && scrollBar.Width > 0 && scrollBar.Height > 0)
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionsGroup.Parent;
                parentBotton = parent.Y + parent.Height;
                while (!Visible)
                {
                    actionBotton = m_actionsGroup.Y + m_actionsGroup.Height;
                    //Scroll Down
                    if (actionBotton > parentBotton)
                    {
                        scrollBar.Children[4].Click();
                    }
                    else //Scroll Up
                    {
                        scrollBar.Children[0].Click();
                    }
                }
            }
        }


        /// <summary>
        /// This function is added to take care of Custom Scroll Bar. Maui skips MMC custom scroll bar, when scroll bar's width is 0 (means invisible)
        /// </summary>
        /// <history>
        ///     [faisalb]   3/22/2005   Created
        /// </history>
        internal static int GetIndex(ActiveAccessibility activeAccessibility)
        {
            //Maui skips MMC custom scroll bar, when scroll bar's width is 0 (means invisible)
            int index = activeAccessibility.Index;
            if (activeAccessibility.Parent.ChildCount > 0)
            {
                ActiveAccessibility scrollBar = activeAccessibility.Parent.Children[0];
                if ((MsaaRole)scrollBar.Role == MsaaRole.ScrollBar && (scrollBar.Visible == false || scrollBar.Width == 0 || scrollBar.Height == 0))
                {
                    return index + 1;
                }
            }
            return index;
        }


        #endregion

	}
    #endregion

    #region Class for Actions Group Rendered As Region

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Actions Pane which are rendered as region inside MMC 2.1
    /// </summary>
    /// <history>
    /// 	[faisalb]   22/3/2005   Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class ActionItemAsRegion
    {
        private ActiveAccessibility m_actionItemAsRegion = null;

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        internal ActionItemAsRegion(ActiveAccessibility actionItemAsRegion)
        {
            m_actionItemAsRegion = actionItemAsRegion;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        internal ActionItemAsRegion(ActiveAccessibility actionPane, int index)
        {
            m_actionItemAsRegion = actionPane.Children[index];
        }


        /// <summary>
        /// Call this method to find Name of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        public string Name
        {
            get
            {
                return m_actionItemAsRegion.Name;
            }
        }

        /// <summary>
        /// Call this to get Action Item of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        /// <param name="index">Index</param>
        /// <returns>Action Item</returns>
        public ActionItem this[int index]
        {
            get
            {
                return new ActionItem(m_actionItemAsRegion.Children[index]);
            }
        }

        /// <summary>
        /// Call this to get Action Item of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        /// <param name="actionName">Action Name</param>
        /// <returns>Action Item</returns>
        public ActionItem this[string actionName]
        {
            get
            {
                return new ActionItem(m_actionItemAsRegion.Children[actionName]);
            }
        }

        /// <summary>
        /// Call this to find number of Actions in Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        public int Count
        {
            get
            {
                return m_actionItemAsRegion.ChildCount;
            }
        }
    }
    #endregion

    #region Class for Actions Pane Window
    /// -----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: ActionsPane
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
    ///     Represents Actions Pane Window inside MMC 2.1
    ///  </summary>
	///  <history>
	/// 	[faisalb] 11/01/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class ActionsPane : Window
	{

#region "Member Variables"
        private const string WindowTitle = "ActionsPaneView";
        private const string ChildWindowTitle = "Actions";
#endregion

#region "Constructor and Init function"
        private const int Timeout = 5000;
        
        //protected internal static Window ActiveWindow;
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Internal constructor to create object of Actions Pane
        ///  </summary>
        ///  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[faisalb] 9/27/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        internal ActionsPane(Window ownerWindow) : 
                base(Init(ownerWindow))
        {
            
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[faisalb] 9/27/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
				tempWindow = new Window(WindowTitle, StringMatchSyntax.ExactMatch, "*", StringMatchSyntax.WildCard, ownerWindow, Timeout);
			}
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find Actions Pane. Make sure you enabled Actions Pane", ex);
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"

		private ActiveAccessibility Actions
		{
			get
			{
                return Extended.AccessibleObject.Children[WindowTitle].Children[ChildWindowTitle].Children[ChildWindowTitle];
            }
		}

        /// <summary>
        /// Call this indexer to get Action Group
        /// </summary>
        /// <param name="index">Index of Action Group</param>
        /// <returns>Action Group</returns>
		public ActionsGroup this [int index]
		{
			get
			{
				return new ActionsGroup(Actions, index);
			}

		}

        /// <summary>
        /// Call this indexer to get Action Group
        /// </summary>
        /// <param name="groupName">Name of Action Group</param>
        /// <returns>Action Group</returns>
        public ActionsGroup this[string groupName]
        {
			get
			{
				return new ActionsGroup(Actions, groupName);
			}

		}

        /// <summary>
        /// Call this indexer to get Action Group
        /// </summary>
        /// <param name="groupName">Name of Action Group</param>
        /// <param name="caseSensitive">Case Sensitive</param>
        /// <returns>Action Group</returns>
        public ActionsGroup this[string groupName, bool caseSensitive]
        {
            get
            {
                return new ActionsGroup(Actions, groupName);
            }

        }

#endregion
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Console.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using Maui.ManagementConsole.Dialogs;

    #region Enumerations, interfaces
    /// <summary>
    /// Specifies how console window list view is shown.
    /// </summary>
    /// <history>
    ///		[dmitriv] 6/15/2003 Created
    /// </history>
    public enum ConsoleViewMode
    {
        LargeIcons,
        SmallIcons,
        List,
        Detail
    }

    /// <summary>
    /// Options to be set on Customize View dialog.
    /// </summary>
    /// <history>
    ///		[dmitriv] 6/15/2003 Created
    ///		[faisalb] 10/28/2004 Added ActionsPane and Changed all to FFFF
    /// </history>
    [Flags()]
    public enum ConsoleViewOptions
    {
        ConsoleTree = 0x0001,
        StandardMenus = 0x0002,
        StandardToolbar = 0x0004,
        StatusBar = 0x0008,
        DescriptionBar = 0x0010,
        TaskpadNavigationTabs = 0x0020,
        SnapinMenus = 0x0040,
        SnapinToolbars = 0x0080,
        ActionsPane = 0x0100,
        All = 0xFFFF
    }

    /// <summary>
    /// Exposes controls inside Console window.
    /// </summary>
    /// <history>
    ///		[dmitriv] 6/15/2003 Created
    /// </history>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IConsoleControls
    {
        /// <summary>
        ///		Console left-hand side tree.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        TreeView Tree { get; }

        /// <summary>
        ///		Console right-hand side details list-view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        ListView Details { get; }

        /// <summary>
        ///		Header of details list-view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        Header DetailsHeader { get; }

        /// <summary>
        ///		Status bar inside console window.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        StatusBar StatusBar { get; }

        /// <summary>
        ///		Description bar above the right-hand details view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        StaticControl DescriptionBar { get; }

        /// <summary>
        ///		Actions Pane, which appears in right side of Console
        /// </summary>
        /// <history>
        ///		[faisalb] 10/28/2003 Created
        /// </history>
        ActionsPane ActionsPane { get;}
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Console Window inside MMC.
    /// </summary>
    /// <history>
    /// 	[dmitriv] 6/15/2003 Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class Console : Window, IConsoleControls
    {
        #region Constants
        private class ControlIDs
        {
            public const int TreeView = 0x31F1;
            public const int DescriptionBar = 0x31F7;
            public const int ListView = 0x31F2;
            public const int StatusBar = 0x1003;
        }
        #endregion

        #region Constructors, private variables
        private MmcApp app;
        private ConsoleNode rootNode = null;
        private int DefaultMaxTimeOut = 10000; //Maximum 10 seconds
        private const string HtmlTaskClassName = "task";

        /// <summary>
        ///		Constructor for the currently active console window.
        /// </summary>
        /// <param name="app">Application which owns this console.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console(MmcApp app) : this(app, null, 1)
        {
        }

        /// <summary>
        ///		Constructor the named window.
        /// </summary>
        /// <param name="app">Application which owns this console.</param>
        /// <param name="name">Name of the window</param>
        /// <param name="instance">
        ///		Instance of the window if there are several with the same name or name is null.
        ///	</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console(MmcApp app, string name, int instance) : base(GetConsole(app, name, instance))
        {
            this.app = app;
        }

        /// <summary>
        /// Creates new console window using specified command method.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="createUsing">Command method to use.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console(MmcApp app, CommandMethod createUsing) : base(CreateConsole(app, createUsing))
        {
            this.app = app;
        }

        /// <summary>
        /// Finds console window inside the MDI frame.
        /// </summary>
        /// <param name="app">MMC Application.</param>
        /// <param name="name">Name of console window.</param>
        /// <param name="instance">Instance in case there are more than 1 window with the same name.</param>
        /// <returns>Window handle.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private static IntPtr GetConsole(MmcApp app, string name, int instance)
        {
            UISynchronization.WaitForUIObjectReady(app.MainWindow);
            Window wnd = new Window(name, StringMatchSyntax.ExactMatch,
                MmcApp.Strings.MMCChildFrm, StringMatchSyntax.ExactMatch,
                app, app.Controls.MdiContainer, 1000, false, false, instance);
            return wnd.Extended.HWnd;
        }

        /// <summary>
        /// Creates new Console window using given command method.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="createUsing">Command method to use.</param>
        /// <returns>Create console window HWND.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private static IntPtr CreateConsole(MmcApp app, CommandMethod createUsing)
        {
            Commands.WindowNewWindow.Execute(app, createUsing);
            // just return the first window - should be top-most
            return GetConsole(app, null, 1);
        }
        #endregion

        #region Controls
        /// <summary>
        /// Provides access to all console window controls.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public IConsoleControls Controls
        {
            get
            {
                return this;
            }
        }

        TreeView IConsoleControls.Tree
        {
            get
            {
                return new TreeView(this, ControlIDs.TreeView);
            }
        }

        ListView IConsoleControls.Details
        {
            get
            {
                return new ListView(this, ControlIDs.ListView);
            }
        }

        Header IConsoleControls.DetailsHeader
        {
            get
            {
                return new Header(Controls.Details.Extended.FirstChild);
            }
        }

        StatusBar IConsoleControls.StatusBar
        {
            get
            {
                return new StatusBar(this, ControlIDs.StatusBar);
            }
        }

        StaticControl IConsoleControls.DescriptionBar
        {
            get
            {
                return new StaticControl(this, ControlIDs.DescriptionBar);
            }
        }

        /// <summary>
        /// Provides access to Actions Pane from Console
        /// </summary>
        /// <history>
        ///		[faisalb]	10/28/2003	Created
        /// </history>
        ActionsPane IConsoleControls.ActionsPane
        {
            get
            {
                return new ActionsPane(this);
            }
        }
        #endregion

        #region Indexers
        /// <summary>
        ///		Returns node with specified index in the tree.
        /// </summary>
        /// <param name="index">Index of the node to return.</param>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode this[int index]
        {
            get
            {
                return RootNode[index];
            }
        }

        /// <summary>
        ///		Returns node with specified path from the tree.
        /// </summary>
        /// <param name="path">Path of the node to return.</param>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode this[string path]
        {
            get
            {
                return RootNode[path];
            }
        }

        /// <summary>
        ///		Returns node with specified path from the tree.
        /// </summary>
        /// <param name="path">Path of the node to return.</param>
        /// <param name="instance">Instance of the node with the same path to return.</param>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode this[string path, int instance]
        {
            get
            {
                return RootNode[path, instance];
            }
        }
        #endregion

        #region Properties
        /// <summary>
        ///		MMC application which contains this console window.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public new MmcApp App
        {
            get
            {
                return app;
            }
        }

        /// <summary>
        ///		Root node inside the console.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode RootNode
        {
            get
            {
                if (rootNode == null)
                {
                    rootNode = new ConsoleNode(this, 0);
                }
                return rootNode;
            }
        }

        /// <summary>
        ///		Provides access to console item on the list-view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleItemCollection Items
        {
            get
            {
                return new ConsoleItemCollection(this);
            }
        }

        /// <summary>
        ///		Gets or sets console list view mode.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleViewMode ViewMode
        {
            get
            {
                SetFocus();
                app.Menu[app.GetIntlStr(Commands.Strings.View)].Execute();
                Menu menu = new Menu();
                ConsoleViewMode result = ConsoleViewMode.Detail;
                if (menu[app.GetIntlStr(Commands.Strings.ViewLargeIcons)].Checked)
                    result = ConsoleViewMode.LargeIcons;
                else if (menu[app.GetIntlStr(Commands.Strings.ViewSmallIcons)].Checked)
                    result = ConsoleViewMode.SmallIcons;
                else if (menu[app.GetIntlStr(Commands.Strings.ViewList)].Checked)
                    result = ConsoleViewMode.List;
                app.MainWindow.SendKeys("{ESC}");
                return result;
            }
            set
            {
                SetFocus();
                switch (value)
                {
                    case ConsoleViewMode.LargeIcons:
                        Commands.ViewLargeIcons.Execute(app, CommandMethod.MainMenu);
                        break;
                    case ConsoleViewMode.SmallIcons:
                        Commands.ViewSmallIcons.Execute(app, CommandMethod.MainMenu);
                        break;
                    case ConsoleViewMode.List:
                        Commands.ViewList.Execute(app, CommandMethod.MainMenu);
                        break;
                    case ConsoleViewMode.Detail:
                        Commands.ViewDetail.Execute(app, CommandMethod.MainMenu);
                        break;
                }
                UISynchronization.WaitForUIObjectReady(Controls.Details);
            }
        }

        /// <summary>
        ///		Gets or sets whether console tree is visible.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public bool ShowConsoleTree
        {
            get
            {
                SetFocus();
                return (Commands.ViewShowHideConsoleTree.GetToolbarItem(app).AccessibleObject.State & (int)MsaaStates.Checked) != 0;
            }
            set
            {
                SetFocus();
                if (ShowConsoleTree != value)
                    Commands.ViewShowHideConsoleTree.Execute(app);
                UISynchronization.WaitForUIObjectReady(this);
            }
        }

        /// <summary>
        ///		Gets or sets whether Actions Pane is visible.
        /// </summary>
        /// <history>
        ///		[faisalb] 10/28/2003 Created
        /// </history>
        public bool ShowActionsPane
        {
            get
            {
                SetFocus();
                return (Commands.ViewShowHideActionsPane.GetToolbarItem(app).AccessibleObject.State & (int)MsaaStates.Checked) != 0;
            }
            set
            {
                SetFocus();
                if (ShowActionsPane != value)
                    Commands.ViewShowHideActionsPane.Execute(app);
                UISynchronization.WaitForUIObjectReady(this);
            }
        }

        /// <summary>
        ///		Gets or sets view options on the console window using View | Options dialog.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleViewOptions ViewOptions
        {
            get
            {
                SetFocus();
                ConsoleViewOptions options = 0;
                CustomizeViewDialog dialog = new CustomizeViewDialog(app);
                if (dialog.Controls.ConsoleTreeCheckBox.Checked)
                    options |= ConsoleViewOptions.ConsoleTree;
                if (dialog.Controls.StandardMenusCheckBox.Checked)
                    options |= ConsoleViewOptions.StandardMenus;
                if (dialog.Controls.StandardToolbarCheckBox.Checked)
                    options |= ConsoleViewOptions.StandardToolbar;
                if (dialog.Controls.DescriptionBarCheckBox.Checked)
                    options |= ConsoleViewOptions.DescriptionBar;
                if (dialog.Controls.StatusbarCheckBox.Checked)
                    options |= ConsoleViewOptions.StatusBar;
                if (dialog.Controls.TaskPadNavigationTabsCheckBox.Checked)
                    options |= ConsoleViewOptions.TaskpadNavigationTabs;
                if (dialog.Controls.SnapinMenusCheckBox.Checked)
                    options |= ConsoleViewOptions.SnapinMenus;
                if (dialog.Controls.SnapinToolbarsCheckBox.Checked)
                    options |= ConsoleViewOptions.SnapinToolbars;
                if (dialog.Controls.ActionsPaneCheckBox.Checked)
                    options |= ConsoleViewOptions.ActionsPane;

                dialog.ClickOK();
                return options;
            }
            set
            {
                SetFocus();
                CustomizeViewDialog dialog = new CustomizeViewDialog(app);
                dialog.Controls.ConsoleTreeCheckBox.Checked = (value & ConsoleViewOptions.ConsoleTree) != 0;
                dialog.Controls.StandardMenusCheckBox.Checked = (value & ConsoleViewOptions.StandardMenus) != 0;
                dialog.Controls.StandardToolbarCheckBox.Checked = (value & ConsoleViewOptions.StandardToolbar) != 0;
                dialog.Controls.DescriptionBarCheckBox.Checked = (value & ConsoleViewOptions.DescriptionBar) != 0;
                dialog.Controls.StatusbarCheckBox.Checked = (value & ConsoleViewOptions.StatusBar) != 0;
                dialog.Controls.TaskPadNavigationTabsCheckBox.Checked = (value & ConsoleViewOptions.TaskpadNavigationTabs) != 0;
                dialog.Controls.ActionsPaneCheckBox.Checked = (value & ConsoleViewOptions.ActionsPane) != 0;
                dialog.Controls.SnapinMenusCheckBox.Checked = (value & ConsoleViewOptions.SnapinMenus) != 0;
                dialog.Controls.SnapinToolbarsCheckBox.Checked = (value & ConsoleViewOptions.SnapinToolbars) != 0;
                dialog.ClickOK();
            }
        }

        /// <summary>
        ///		Gets or sets display column list.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public string[] DisplayColumnList
        {
            get
            {
                SetFocus();
                AddRemoveColumnsDialog dialog = new AddRemoveColumnsDialog(app);
                string[] result = dialog.ColumnList;
                dialog.ClickCancel();
                return result;
            }
            set
            {
                SetFocus();
                AddRemoveColumnsDialog dialog = new AddRemoveColumnsDialog(app);
                dialog.ColumnList = value;
                dialog.ClickOK();
            }
        }

        /// <summary>
        ///		Returns status bar text.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public string StatusBarText
        {
            get
            {
                return Controls.StatusBar.Panels[0].Text;
            }
        }

        /// <summary>
        ///		Gets HTML page on the right side, if present.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public HtmlDocument HtmlPage
        {
            get
            {
                Window wnd = new Window("*", StringMatchSyntax.WildCard, WindowClassNames.InternetExplorerServer, StringMatchSyntax.ExactMatch, this, 5000);
                UISynchronization.WaitForUIObjectReady(wnd);
                return new HtmlDocument(wnd);
            }
        }
        #endregion

        #region Methods
        /// <summary>
        ///		Searches for a node with specified name under root node.
        /// </summary>
        /// <param name="text">Text of a node to find.</param>
        /// <returns>Found node or null if not found.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public ConsoleNode Find(string text)
        {
            return RootNode.Find(text);
        }

        /// <summary>
        ///		Maximizes console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Maximize()
        {
            State = WindowState.Maximize;
        }

        /// <summary>
        ///		Minimizes console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Minimize()
        {
            State = WindowState.Minimize;
        }

        /// <summary>
        ///		Restores console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Restore()
        {
            State = WindowState.Restore;
        }

        /// <summary>
        ///		Restores default column list in the list view.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void RestoreDefaultDisplayColumns()
        {
            SetFocus();
            AddRemoveColumnsDialog dialog = new AddRemoveColumnsDialog(app);
            dialog.ClickRestoreDefaults();
            dialog.ClickOK();
        }

        /// <summary>
        ///		Saves console.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Save()
        {
            Save(CommandMethod.Default);
        }

        /// <summary>
        ///		Saves console.
        /// </summary>
        /// <param name="method">How to invoke the command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Save(CommandMethod method)
        {
            SetFocus();
            Commands.FileSave.Execute(app, method);
            UISynchronization.WaitForUIObjectReady(this);
        }

        /// <summary>
        ///		Opens and returns Console Options dialog.
        /// </summary>
        /// <returns>Opened dialog instance.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Dialogs.OptionsDialog OpenOptionsDialog()
        {
            SetFocus();
            return new Dialogs.OptionsDialog(app);
        }

        /// <summary>
        ///		Saves console in specified file.
        /// </summary>
        /// <param name="fileName">File where to save.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void SaveAs(string fileName)
        {
            SaveAs(fileName, CommandMethod.Default);
        }

        /// <summary>
        ///		Saves console in specified file.
        /// </summary>
        /// <param name="fileName">File where to save.</param>
        /// <param name="method">How to invoke the command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///     [faisalb]   10/29/2004  Changed from "Save*" to "Save" and class name from "null" to "Button" because it searching something else with same title. So Save As was failing. Also added Timeout for WaitForInvalid because in XPSP2 it takes longer time
        /// </history>
        public void SaveAs(string fileName, CommandMethod method)
        {
            SetFocus();
            Commands.FileSaveAs.Execute(app, method);

            // HACK: use the actual Open dialog when it's implemented in Maui.Windows
            Window wnd = new Window("Save As", StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            new TextBox(wnd, 0x47C).Text = fileName;

            //Changed from "Save*" to "Save" and class name from "null" to "Button" because it searching something else with same title. So Save As was failing.
            new Button(wnd, "Save", StringMatchSyntax.ExactMatch, "Button", StringMatchSyntax.WildCard).Click();

            //After XPSP, Common Dialog takes long time to go away.
            wnd.WaitForInvalid(DefaultMaxTimeOut);
            // END HACK

            UISynchronization.WaitForUIObjectReady(this);
        }

        /// <summary>
        ///		Closes this console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Close()
        {
            CloseWindow();
            WaitForInvalid();
        }

        /// <summary>
        ///		Navigates on a link inside right-hand IE page.
        /// </summary>
        /// <param name="linkName">Name of the link on which to navigate.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NavigateOnLink(string linkName)
        {
            new Core.HtmlControls.HtmlLink(HtmlPage, "A", linkName).Click();
            UISynchronization.WaitForUIObjectReady(this);
            App.MainWindow.WaitForResponse();
        }

        /// <summary>
        /// Executes taskName from the Taskpad view.
        /// </summary>
        /// <param name="taskName">Name of the task to execute.</param>
        /// <history>
        ///		[zeghmit]	12/5/2003	Created
        ///		[dmitriv]	11/09/2004	Fixed to find the correct link element
        /// </history>
        internal void ExecuteTaskNoSelect(string taskName)
        {
            if (Core.Resources.ResourceManager.IsResourceID(taskName))
                taskName = App.GetIntlStr(taskName);

            // First try to see if the HTML link for the task is used with an
            // A tag.  
            //
            // If not, then we try to search for the element by inner text.  
            // If that did not work, then we throw an exception.
            try
            {
                new Core.HtmlControls.HtmlLink(HtmlPage, "A", taskName).Click();
            }
            catch (Maui.GlobalExceptions.MauiException)
            {
                // Search for the task HTML element.
                bool found = false;
                foreach (mshtml.IHTMLElement elem in HtmlPage.Document2.all)
                {
                    try
                    {
                        if ((elem.innerHTML != null) &&
                            (elem.innerHTML.Trim() == taskName.Trim()) &&
                            (elem.className.ToLower() == HtmlTaskClassName))
                        {
                            elem.click();
                            found = true;
                            break;
                        }
                    }
                    catch (System.NullReferenceException)
                    {
                        // has no className, try next
                    }
                }

                if (!found)
                    throw new NotImplementedException("Executing the task in the form in which it is " +
                        "launched in HTML or otherwise is not yet implemented.  Or " + taskName + " does not exist");
            }

            WaitForResponse();
        }

        #endregion
    }

    #region ConsoleCollection
    ///  Project   : Maui.ManagementConsole
    ///  Class     : ConsoleCollection
    /// 
    ///  Copyright (C) 2002, Microsoft Corporation
    /// ------------------------------------------------------------------------------
    ///  <summary>
    ///  Strongly-typed collection of Console objects
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    ///      [dmitriv] 5/10/2003  Created
    ///  </history>
    [Serializable()]
    public class ConsoleCollection : ICollection
    {
        private MmcApp app;

        /// <summary>
        ///		Constructor.
        /// </summary>
        /// <param name="app">MMC Application.</param>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        internal ConsoleCollection(MmcApp app)
        {
            this.app = app;
        }

        /// <summary>
        ///		Returns console with specified index.
        /// </summary>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public Console this[int index]
        {
            get
            {
                if (index < 0 || index > Count - 1)
                    throw new IndexOutOfRangeException("Index of Console Window is out of range - should be 0 <= index <= " + Count);
                return new Console(app, null, index + 1);
            }
        }

        /// <summary>
        ///		Returns console with specified name.
        /// </summary>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public Console this[string name]
        {
            get
            {
                return new Console(app, name, 1);
            }
        }

        /// <summary>
        ///		Returns console with specified name and instance number (1-based).
        /// </summary>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public Console this[string name, int instance]
        {
            get
            {
                return new Console(app, name, instance);
            }
        }

        /// <summary>
        /// Returns the count of Console Windows.
        /// </summary>
        public int Count
        {
            get
            {
                return app.Controls.MdiContainer.Extended.ChildrenCount;
            }
        }

        object ICollection.SyncRoot
        {
            get
            {
                return this;
            }
        }

        bool ICollection.IsSynchronized
        {
            get
            {
                return false;
            }
        }

        void ICollection.CopyTo(System.Array array, int index)
        {
            for (int i = 0; i < Count; i++)
                array.SetValue(this[i], index + i);
        }

        ///  <summary>
        ///    Returns an enumerator that can iterate through 
        ///       the <see cref="Maui.ManagementConsole.ConsoleCollection"/> .
        ///  </summary>
        ///  <returns>An enumerator for the collection</returns>
        ///  <remarks><seealso cref="System.Collections.IEnumerator"/></remarks>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public IEnumerator GetEnumerator()
        {
            return new ConsoleEnumerator(this);
        }

        #region ConsoleEnumerator
        private class ConsoleEnumerator : object, IEnumerator
        {
            private ConsoleCollection baseCollection;
            private int index;

            public ConsoleEnumerator(ConsoleCollection mappings)
            {
                baseCollection = mappings;
                index = -1;
            }

            object IEnumerator.Current
            {
                get
                {
                    return baseCollection[index];
                }
            }

            public bool MoveNext()
            {
                index++;
                return index <= baseCollection.Count - 1;
            }

            public void Reset()
            {
                index = -1;
            }
        }
        #endregion
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: AssemblyTitle("MAUI Management Console Automation")]
[assembly: AssemblyDescription("Base automation library for Microsoft Management Console (MMC) UI.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Automation for UI")]
[assembly: AssemblyCopyright("2003 (c) Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: AssemblyVersion("1.0.0.0")]

[assembly: AssemblyDelaySign(false)]
#if STRONG_NAME
	[assembly: AssemblyKeyFile("..\\..\\maui.snk")]
#else
	[assembly: AssemblyKeyFile("")]
	[assembly: AssemblyKeyName("")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Commands.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using Maui.Core;

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Commands
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Standard MMC command descriptors.
    /// </summary>
    /// <history>
    ///		[dmitriv]	7/5/2003	Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class Commands
    {
        /// <summary>
        ///	Command strings.
        /// </summary>
        internal class Strings
        {
            public const string File = ";&File;NativeMenuString;mmc.exe;129;1";
            public const string FileExit = File + "|;E&xit;NativeMenuString;mmc.exe;129;57665";
            public const string FileNew = File + "|;New;NativeMenuString;mmc.exe;129;57600";
            public const string FileOpen = File + "|;Open;NativeMenuString;mmc.exe;129;57601";
            public const string FileSave = File + "|;Save;NativeMenuString;mmc.exe;129;57603";
            //In MMC there are TWO spaces between Save and As.
            public const string FileSaveAs = File + "|;Save  As...;NativeMenuString;mmc.exe;129;57604";
            public const string FileOptions = File + "|;Options...;NativeMenuString;mmc.exe;129;13220";
            public const string FileAddRemoveSnapin = File + "|;Add/Remove Snap-ins...;NativeMenuString;mmc.exe;129;13201";

            public const string Action = ";&ActionAction Menu;Win32String;mmcbase.dll;14065";
            public const string ActionRefresh = ";Re&freshRefreshes the current selection.;Win32String;mmcbase.dll;14054";
            public const string ActionRename = ";Rena&meRenames the current selection.;Win32String;mmcbase.dll;14055";
            public const string ActionNewTaskpadView = ";New &Taskpad View...Creates a new taskpad view targeted at this node.;Win32String;mmcbase.dll;14057";
            public const string ActionAllTasks = ";All Tas&ksContains operations that can be performed on the object.;Win32String;mmcbase.dll;14063";
            public const string ActionNewWindowFromHere = ";New &Window from HereOpens a new window rooted at this node.;Win32String;mmcbase.dll;14047";
            public const string ActionSelectAll = ";Select &AllSelects all of the items in the listview;Win32String;mmcbase.dll;14046";
            public const string ActionProperties = ";P&ropertiesOpens property sheet for the current selection.;Win32String;mmcbase.dll;14000";
            public const string ActionExportList = ";Export &List...Exports the current list to a file.;Win32String;mmcbase.dll;14086";
            public const string ActionHelp = ";&HelpDisplays help for current selection.;Win32String;mmcbase.dll;14170";
            public const string ActionNew = ";&NewCreates a new object in this container.;Win32String;mmcbase.dll;14002";
            public const string ActionDelete = ";&DeleteDeletes the current selection.;Win32String;mmcbase.dll;14052";
            public const string ActionOpen = ";&Open;Win32String;mmcbase.dll;13349";

            public const string View = ";&View;NativeMenuString;mmc.exe;129;13239";
            public const string ViewAddRemoveColumns = View + "|;&Add/Remove Columns...;Win32String;mmcbase.dll;14001";
            public const string ViewLargeIcons = ";Lar&ge Icons;NativeMenuString;comres.dll;2937;2555";
            public const string ViewSmallIcons = ";S&mall Icons;NativeMenuString;comres.dll;2937;2557";
            public const string ViewList = ";&List;NativeMenuString;comres.dll;2937;2553";
            public const string ViewDetail = ";Detail;Win32String;UNIRES.DLL;11401";
            public const string ViewCustomize = View + "|;C&ustomize...;Win32String;mmcbase.dll;14009";

            public const string Window = ";&Window;NativeMenuString;mmc.exe;129;2";
            public const string WindowNewWindow = Window + "|;New Window;NativeMenuString;mmc.exe;129;57648";
            public const string WindowCascade = Window + "|;Cascade;NativeMenuString;mmc.exe;129;57650";
            public const string WindowTileHorizontally = Window + "|;Tile Horizontally;NativeMenuString;mmc.exe;129;57651";
            public const string WindowArrangeIcons = Window + "|;Arrange Icons;NativeMenuString;mmc.exe;129;57649";

            public const string Help = ";Help;NativeMenuString;mmc.exe;128;2";
            public const string HelpHelpTopics = Help + "|;Help Topics;NativeMenuString;mmc.exe;128;12804";
            public const string HelpAboutManagementConsole = Help + "|;About Microsoft Management Console;NativeMenuString;mmc.exe;128;57664";

            public const string ToolbarCut = ";CutCut;Win32String;mmcbase.dll;13381";
            public const string ToolbarCopy = ";CopyCopy;Win32String;mmcbase.dll;13382";
            public const string ToolbarPaste = ";PastePaste;Win32String;mmcbase.dll;13383";
            public const string ToolbarDelete = ";DeleteDelete;Win32String;mmcbase.dll;13384";
            public const string ToolbarProperties = ";PropertiesProperties;Win32String;mmcbase.dll;13385";
            public const string ToolbarUpOneLevel = ";Up One LevelUp One Level;Win32String;mmcbase.dll;13386";
            public const string ToolbarShowHideConsoleTree = ";Show/Hide Console TreeShow/Hide Console Tree;Win32String;mmcbase.dll;13387";
            public const string ToolbarShowHideActionsPane = ";Show/Hide Action PaneShow/Hide Action Pane;Win32String;mmcbase.dll;13432";
            public const string ToolbarRefresh = ";RefreshRefresh;Win32String;mmcbase.dll;13388";
            public const string ToolbarPrint = ";PrintPrint;Win32String;mmcbase.dll;13389";
            public const string ToolbarRename = ";RenameRename;Win32String;mmcbase.dll;13390";
            public const string ToolbarOpen = ";OpenOpen;Win32String;mmcbase.dll;13391";
            public const string ToolbarBack = ";BackBack;Win32String;mmcbase.dll;13392";
            public const string ToolbarForward = ";ForwardForward;Win32String;mmcbase.dll;13393";
            public const string ToolbarStop = ";StopStop;Win32String;mmcbase.dll;13394";
            public const string ToolbarHome = ";HomeHome;Win32String;mmcbase.dll;13396";
            public const string ToolbarExportList = ";Export ListExport List;Win32String;mmcbase.dll;13398";
        }

        public static Command
            // File menu items
            FileNew = new Command(Strings.FileNew, null, "^N", null),
            FileOpen = new Command(Strings.FileOpen, null, "^O", null),
            FileSave = new Command(Strings.FileSave, null, "^S", null),
            FileSaveAs = new Command(Strings.FileSaveAs, null, null, null),
            FileAddRemoveSnapIn = new Command(Strings.FileAddRemoveSnapin, null, "^M", null),
            FileOptions = new Command(Strings.FileOptions, null, null, null),
            FileExit = new Command(Strings.FileExit, null, null, null),

            // Action menu items
            ActionNewWindowFromHere = new Command(Strings.Action + "|" + Strings.ActionNewWindowFromHere, Strings.ActionNewWindowFromHere),
            ActionNewTaskPadView = new Command(Strings.Action + "|" + Strings.ActionNewTaskpadView, Strings.ActionNewTaskpadView),
            ActionDelete = new Command(Strings.Action + "|" + Strings.ActionDelete, Strings.ActionDelete, "{DELETE}", Strings.ToolbarDelete),
            ActionRename = new Command(Strings.Action + "|" + Strings.ActionRename, Strings.ActionRename, "{F2}", Strings.ToolbarRename),
            ActionRefresh = new Command(Strings.Action + "|" + Strings.ActionRefresh, "{F5}", Strings.ToolbarRefresh),
            ActionExportList = new Command(Strings.Action + "|" + Strings.ActionExportList, Strings.ActionExportList, null, Strings.ToolbarExportList),
            ActionProperties = new Command(Strings.Action + "|" + Strings.ActionProperties, Strings.ActionProperties, "%{ENTER}", Strings.ToolbarProperties),
            ActionHelp = new Command(Strings.Action + "|" + Strings.ActionHelp, Strings.ActionHelp, "{F1}", Strings.ActionHelp),
            ActionOpen = new Command(Strings.Action + "|" + Strings.ActionOpen, Strings.ActionOpen, null, Strings.ToolbarOpen),

            // View menu items
            ViewAddRemoveColumns = new Command(Strings.ViewAddRemoveColumns, null, null, null),
            ViewLargeIcons = new Command(Strings.View + "|" + Strings.ViewLargeIcons, Strings.View + "|" + Strings.ViewLargeIcons, null, null),
            ViewSmallIcons = new Command(Strings.View + "|" + Strings.ViewSmallIcons, Strings.View + "|" + Strings.ViewSmallIcons, null, null),
            ViewList = new Command(Strings.View + "|" + Strings.ViewList, null, null, null),
            ViewDetail = new Command(Strings.View + "|" + Strings.ViewDetail, null, null, null),
            ViewCustomize = new Command(Strings.ViewCustomize, null, null, null),
            ViewShowHideConsoleTree = new Command(null, null, null, Strings.ToolbarShowHideConsoleTree),
            ViewShowHideActionsPane = new Command(null, null, null, Strings.ToolbarShowHideActionsPane),

            // Window menu items
            WindowNewWindow = new Command(Strings.WindowNewWindow, null, "^W", null),
            WindowCascade = new Command(Strings.WindowCascade, null, null, null),
            WindowTileHorizontally = new Command(Strings.WindowTileHorizontally, null, null, null),
            WindowArrangeIcons = new Command(Strings.WindowArrangeIcons, null, null, null),

            // Help menu items
            HelpHelpTopics = new Command(Strings.HelpHelpTopics, null, null, null),
            HelpAboutManagementConsole = new Command(Strings.HelpAboutManagementConsole, null, null, null),

            // Edit commands			
            EditCut = new Command(null, null, "^x", Strings.ToolbarCut),
            EditCopy = new Command(null, null, "^c", Strings.ToolbarCopy),
            EditPaste = new Command(null, null, "^v", Strings.ToolbarPaste),
            EditPrint = new Command(null, null, null, Strings.ToolbarPrint),

            // Browse commands
            BrowseUpOneLevel = new Command(null, null, "{BACKSPACE}", Strings.ToolbarUpOneLevel),
            BrowseBack = new Command(null, null, "%{LEFT}", Strings.ToolbarBack),
            BrowseForward = new Command(null, null, "%{RIGHT}", Strings.ToolbarForward),
            BrowseStop = new Command(null, null, null, Strings.ToolbarStop),
            BrowseHome = new Command(null, null, null, Strings.ToolbarHome);

        // special commands to be used inside this assembly
        internal static Command
            ActionNew = new Command(Strings.Action + "|" + Strings.ActionNew + "|", Strings.ActionNew + "|"),
            ActionAllTasks = new Command(Strings.Action + "|" + Strings.ActionAllTasks + "|", Strings.ActionAllTasks + "|");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\LicWindows\LicConditionsWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicConditionsWindowControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicConditionsWindowControls
    {
        StaticControl SpecifyLocationStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        RadioButton ApplicationMustComeFromSpecificLocationOrBelowRadioButton  {get;}
        RadioButton ApplicationMustComeFromSpecificLocationRadioButton  {get;}
        RadioButton ApplicationMayComeFromAnyLocationRadioButton  {get;}
    }

#endregion


#region "Enums for RadioButton groups"
    
    
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioGroup0
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioGroup0
    {
        ApplicationMustComeFromSpecificLocationOrBelow = 0,
        ApplicationMustComeFromSpecificLocation = 1,
        ApplicationMayComeFromAnyLocation = 2,
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicConditionsWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the License Conditions window for 
    ///  Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicConditionsWindow : Window, ILicConditionsWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Conditions";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string SpecifyLocationStaticControl = "lblLocation";
            public const string VersionTextBox = "txtLocation";
            public const string ApplicationMustComeFromSpecificLocationOrBelowRadioButton = "rbSpecificLocationOrBelow";
            public const string ApplicationMustComeFromSpecificLocationRadioButton = "rbSpecificLocation";
            public const string ApplicationMayComeFromAnyLocationRadioButton = "rbAnyLocation";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedSpecifyLocationStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected RadioButton m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton;
        protected RadioButton m_cachedApplicationMustComeFromSpecificLocationRadioButton;
        protected RadioButton m_cachedApplicationMayComeFromAnyLocationRadioButton;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for License Conditions page for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicConditionsWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicConditionsWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioGroup0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioGroup0 RadioGroup0
        {
            get
            {
                if ((Controls.ApplicationMustComeFromSpecificLocationOrBelowRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.ApplicationMustComeFromSpecificLocationOrBelow;

                if ((Controls.ApplicationMustComeFromSpecificLocationRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.ApplicationMustComeFromSpecificLocation;

                if ((Controls.ApplicationMayComeFromAnyLocationRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.ApplicationMayComeFromAnyLocation;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioGroup0.ApplicationMustComeFromSpecificLocationOrBelow))
                    Controls.ApplicationMustComeFromSpecificLocationOrBelowRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup0.ApplicationMustComeFromSpecificLocation))
                    Controls.ApplicationMustComeFromSpecificLocationRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup0.ApplicationMayComeFromAnyLocation))
                    Controls.ApplicationMayComeFromAnyLocationRadioButton.ButtonState = ButtonState.Checked;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SpecifyLocationStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicConditionsWindowControls.SpecifyLocationStaticControl
        {
            get
            {
                if ((m_cachedSpecifyLocationStaticControl == null))
                {
                    m_cachedSpecifyLocationStaticControl = new StaticControl(this, ControlIDs.SpecifyLocationStaticControl);
                }
                return m_cachedSpecifyLocationStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicConditionsWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationMustComeFromSpecificLocationOrBelowRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ILicConditionsWindowControls.ApplicationMustComeFromSpecificLocationOrBelowRadioButton
        {
            get
            {
                if ((m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton == null))
                {
                    m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton = new RadioButton(this, ControlIDs.ApplicationMustComeFromSpecificLocationOrBelowRadioButton);
                }
                return m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationMustComeFromSpecificLocationRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ILicConditionsWindowControls.ApplicationMustComeFromSpecificLocationRadioButton
        {
            get
            {
                if ((m_cachedApplicationMustComeFromSpecificLocationRadioButton == null))
                {
                    m_cachedApplicationMustComeFromSpecificLocationRadioButton = new RadioButton(this, ControlIDs.ApplicationMustComeFromSpecificLocationRadioButton);
                }
                return m_cachedApplicationMustComeFromSpecificLocationRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationMayComeFromAnyLocationRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ILicConditionsWindowControls.ApplicationMayComeFromAnyLocationRadioButton
        {
            get
            {
                if ((m_cachedApplicationMayComeFromAnyLocationRadioButton == null))
                {
                    m_cachedApplicationMayComeFromAnyLocationRadioButton = new RadioButton(this, ControlIDs.ApplicationMayComeFromAnyLocationRadioButton);
                }
                return m_cachedApplicationMayComeFromAnyLocationRadioButton;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\LicWindows\LicPubTrustWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicPubTrustWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicPubTrustWindowControls
    {
        Button GetKeyButton  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl  {get;}
        StaticControl PublishersPublicKeyStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicPubTrustWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Publisher Being Trusted window for
    ///  Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicPubTrustWindow : Window, ILicPubTrustWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Publisher Being Trusted";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string GetKeyButton = "btnGetKey";
            public const string VersionTextBox = "txtPublicKey";
            public const string ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl = "lblPrompt";
            public const string PublishersPublicKeyStaticControl = "lblPublicKey";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedGetKeyButton;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl;
        protected StaticControl m_cachedPublishersPublicKeyStaticControl;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Publisher Being Trusted page for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicPubTrustWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicPubTrustWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the GetKeyButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILicPubTrustWindowControls.GetKeyButton
        {
            get
            {
                if ((m_cachedGetKeyButton == null))
                {
                    m_cachedGetKeyButton = new Button(this, ControlIDs.GetKeyButton);
                }
                return m_cachedGetKeyButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicPubTrustWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicPubTrustWindowControls.ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl
        {
            get
            {
                if ((m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl == null))
                {
                    m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl = new StaticControl(this, ControlIDs.ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl);
                }
                return m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublishersPublicKeyStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicPubTrustWindowControls.PublishersPublicKeyStaticControl
        {
            get
            {
                if ((m_cachedPublishersPublicKeyStaticControl == null))
                {
                    m_cachedPublishersPublicKeyStaticControl = new StaticControl(this, ControlIDs.PublishersPublicKeyStaticControl);
                }
                return m_cachedPublishersPublicKeyStaticControl;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button GetKey
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickGetKey()
        {
            Controls.GetKeyButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\Mage\FileTypes\LicWindows\LicTitleWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicTitleWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicTitleWindowControls
    {
        StaticControl TitleStaticControl  {get;}
        TextBox LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicTitleWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the License Title page for Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicTitleWindow : Window, ILicTitleWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "License Title";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string TitleStaticControl = "lblTitle";
            public const string LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox = "txtTitle";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedTitleStaticControl;
        protected TextBox m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for License Title window for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicTitleWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicTitleWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManually
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManually
        {
            get
            {
                return Controls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox.Text;
            }
            set
            {
                Controls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TitleStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicTitleWindowControls.TitleStaticControl
        {
            get
            {
                if ((m_cachedTitleStaticControl == null))
                {
                    m_cachedTitleStaticControl = new StaticControl(this, ControlIDs.TitleStaticControl);
                }
                return m_cachedTitleStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicTitleWindowControls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox
        {
            get
            {
                if ((m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox == null))
                {
                    m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox = new TextBox(this, ControlIDs.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox);
                }
                return m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\ConsoleNode.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using System.Collections;
	using Maui.Core;
	using Maui.Core.WinControls;

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: ConsoleNode
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Abstraction of a node of left-hand side tree-view inside Console Window.
	/// </summary>
	/// <history>
	///		[dmitriv] 6/15/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class ConsoleNode : TreeNode, ICommandTarget
	{
		#region Constructors, private variables
		private Console console = null;

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="index">Index of the node.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode (Console console, int index) : base(console.Controls.Tree, index)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="path">Path of the node.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode (Console console, string path) : base(console.Controls.Tree, path)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="path">Path of the node.</param>
		/// <param name="instance">Instance of the node under the same path.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode (Console console, string path, int instance) : base(console.Controls.Tree, path, instance)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor for known tree node.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="node">Known tree node.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		internal ConsoleNode (Console console, TreeNode node) : base(node.HWnd, node.TreeView)
		{
			this.console = console;
		}
		#endregion

		#region Indexers
		/// <summary>
		///		Returns sub-node with specified index in the tree.
		/// </summary>
		/// <param name="index">Index of the node to return.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public new ConsoleNode this [int index]
		{
			get
			{
				if (IsExpandable && !Expanded)
					Expand(true);
				return new ConsoleNode(console, (this as TreeNode)[index]);
			}
		}

		/// <summary>
		///		Expands tree node and waits for node to be expanded.
		///		To be used internally in places where we know node has to have children.
		/// </summary>
		/// <param name="node">Tree node to expand.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		private void ExpandAndWait (TreeNode node)
		{
			node.Expand(true);
			Core.Utilities.Sleeper sleeper = new Core.Utilities.Sleeper(30000);
			while (!node.IsExpandable)
			{
				sleeper.Sleep();
			}
		}

		/// <summary>
		///		Returns sub-node with specified path from the tree.
		/// </summary>
		/// <param name="path">Path of the node to return.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public new ConsoleNode this [string path]
		{
			get
			{
				TreeNode node = this;
				foreach (string pathItem in path.Split(TreeView.PathDelim.ToCharArray()))
				{
					if (node.IsExpandable && !node.Expanded)
					{
						ExpandAndWait(node);
					}
					node = (node as TreeNode)[pathItem];
				}
				return new ConsoleNode(console, node);
			}
		}

		/// <summary>
		///		Returns sub-node with specified path from the tree.
		/// </summary>
		/// <param name="path">Path of the node to return.</param>
		/// <param name="instance">Instance of the node with the same path to return.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode this[string path, int instance]
		{
			get
			{
				TreeNode node = this;
				string[] items = path.Split(TreeView.PathDelim.ToCharArray());
				for (int i = 0; i < items.Length; i++)
				{
					if (node.IsExpandable && !node.Expanded)
						ExpandAndWait(node);
					if (i < items.Length-1)
						node = (node as TreeNode)[items[i]];
					else
						node = (node as TreeNode)[items[i], instance, true];
				}
				return new ConsoleNode(console, node);
			}
		}
		#endregion

		#region ICommandTarget implementation
		/// <summary>
		///		Invokes and returns context menu on this node selecting it beforehand.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public override Menu ContextMenu
		{
			get
			{
				return GetContextMenu(true);
			}
		}

		/// <summary>
		/// Selects the node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new void Select()
		{
			Console.Extended.SetFocus();
			base.Select();
			Core.UISynchronization.WaitForUIObjectReady(console);
			console.WaitForResponse();
			console.App.MainWindow.WaitForResponse();
		}

		/// <summary>
		/// Application which owns this item.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		App ICommandTarget.App
		{
			get
			{
				return Console.App;
			}
		}

		/// <summary>
		///		Window to wait on after operation.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/31/2003	Created
		/// </history>
		Window ICommandTarget.TargetWindow
		{
			get
			{
				return Console.Controls.Tree;
			}
		}
		#endregion

		#region Properties
		/// <summary>
		///		Returns console containing this node.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console Console
		{
			get
			{
				return console;
			}
		}		

		/// <summary>
		///		Provides access to parent node of this node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new ConsoleNode ParentNode
		{
			get
			{
				return new ConsoleNode(console, base.ParentNode);
			}
		}

		/// <summary>
		///		Provides access to child nodes of this node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new ConsoleNodeCollection Nodes
		{
			get
			{
				return new ConsoleNodeCollection(this);
			}
		}

		/// <summary>
		///		Provides access to details list-view items.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItemCollection Items
		{
			get
			{
				if (!Selected)
					Select();
				return new ConsoleItemCollection(Console);
			}
		}

		/// <summary>
		///		Actions available on this node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public ConsoleActions Actions
		{
			get
			{
				return new ConsoleActions(Console, this);
			}
		}
		#endregion

		#region Methods
		/// <summary>
		///		Selects the node and returns console Details list-view.
		/// </summary>
		/// <returns>Console details list-view for this node.</returns>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		internal ListView GetDetailsView()
		{
			if (!Selected)
				Select();
			return Console.Controls.Details;
		}

		/// <summary>
		///		Searches for a node with specified name under this node.
		/// </summary>
		/// <param name="text">Text of a node to find.</param>
		/// <returns>Found node or null if not found.</returns>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new ConsoleNode Find (string text)
		{
			if (!Expanded)
			{
				Expand(true);
			}
			foreach (TreeNode node in Nodes)
			{
				ConsoleNode cn = new ConsoleNode(Console, node);
				if (cn.Text == text)
					return cn;
				else
				{
					cn = cn.Find(text);
					if (cn != null)
						return cn;
				}
			}
			return null;
		}

		/// <summary>
		///		Invokes and returns context menu for this node.
		/// </summary>
		/// <param name="selectNodeFirst">Whether to select the node before right-click on it.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Menu GetContextMenu (bool selectNodeFirst)
		{
			if (selectNodeFirst)
				Select();
			else
				EnsureVisible();
			return new Menu(Left + 10, Top + Height/2);
		}
		#endregion
	}

	#region ConsoleNodeCollection
	/// ------------------------------------------------------------------------------
	///  Project   : Maui.ManagementConsole
	///  Class     : ConsoleNodeCollection
	/// 
	///  Copyright (C) 2002, Microsoft Corporation
	/// ------------------------------------------------------------------------------
	///  <summary>
	///		Strongly-typed collection of ConsoleNode objects
	///  </summary>
	///  <remarks></remarks>
	///  <history>
	///      [dmitriv] 7/5/2003  Created
	///  </history>
	/// ------------------------------------------------------------------------------
	[Serializable()]
	public class ConsoleNodeCollection : Core.RemotingObject, ICollection
	{
		private ConsoleNode parent;

		///  <summary>
		///       Initializes a new instance of <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/>.
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		internal ConsoleNodeCollection(ConsoleNode parent)
		{
			this.parent = parent;
		}
        
		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleNode"/>.
		///  </summary>
		///  <param name="index">The zero-based index of the entry to locate in the collection.</param>
		///  <value>
		///		The entry at the specified index of the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleNode this[int index] 
		{
			get 
			{
				return parent[index];
			}
		}

		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleNode"/>.
		///  </summary>
		///  <param name="name">Name of the entry to locate in the collection.</param>
		///  <value>
		///		The entry with the specified name in the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleNode this[string name] 
		{
			get 
			{
				return parent[name];
			}
		}        
        
		///  <summary>
		///		Copies the <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> values
		///		to a one-dimensional <see cref="System.Array"/> instance at the  specified index.
		///  </summary>
		///  <param name="array">The one-dimensional <see cref="System.Array"/> that is the destination of the values copied from <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> .</param>
		///  <param name="index">The index in <paramref name="array"/> where copying begins.</param>
		///  <remarks><exception cref="System.ArgumentException"><paramref name="array"/> is multidimensional. <para>-or-</para> <para>The number of elements in the <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> is greater than the available space between <paramref name="arrayIndex"/> and the end of <paramref name="array"/>.</para></exception>
		///  <exception cref="System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>. </exception>
		///  <exception cref="System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than <paramref name="array"/>"s lowbound. </exception>
		///  <seealso cref="System.Array"/>
		///  </remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public void CopyTo(Array array, int index) 
		{
			for (int i = 0; i < Count; i++)
				array.SetValue(this[i], index+i);
		}
        
		///  <summary>
		///    Returns an enumerator that can iterate through 
		///    the <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> .
		///  </summary>
		///  <returns>An enumerator for the collection</returns>
		///  <remarks><seealso cref="System.Collections.IEnumerator"/></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public IEnumerator GetEnumerator() 
		{
			return new ConsoleNodeEnumerator(this);
		}

		/// <summary>
		///		Returns number of Nodes in collection.
		/// </summary>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public int Count
		{
			get
			{
				if (parent.IsExpandable && !parent.Expanded)
					parent.Expand(true);
				return parent.ChildCount;
			}
		}

		/// <summary>
		///		Whether collection is syncrhonized.
		/// </summary>
		bool ICollection.IsSynchronized
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		///		SyncRoot for collection.
		/// </summary>
		object ICollection.SyncRoot
		{
			get
			{
				return this;
			}
		}
        
		#region ConsoleNodeEnumerator
		public class ConsoleNodeEnumerator : object, IEnumerator 
		{            
			private ConsoleNodeCollection baseCollection;
			private int index = -1;
            
			public ConsoleNodeEnumerator(ConsoleNodeCollection baseCollection)
			{
				this.baseCollection = baseCollection;
				this.index = -1;
			}
            
			public object Current 
			{
				get 
				{
					return baseCollection[index];
				}
			}
            
			public bool MoveNext() 
			{
				return ++index < baseCollection.Count;
			}
            
			public void Reset() 
			{
				index = -1;
			}
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\ConsoleActions.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using System.Runtime.Serialization;
	using Maui.Core;
	using Maui.Core.Utilities;
	using Maui.Core.WinControls;

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: ConsoleActions
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Encapsulates actions available on both ConsoleNode and ConsoleItem.
	/// </summary>
	/// <history>
	///		[dmitriv]	7/5/2003	Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class ConsoleActions : Maui.Core.RemotingObject
	{
		#region Exceptions
		public class Exceptions
		{
			private Exceptions() {} // non-creatable class
			
			[Serializable]
				public class RenameFailedException : GlobalExceptions.MauiException 
			{
				public RenameFailedException() {}
				public RenameFailedException(string message) : base(message) {}
				public RenameFailedException(string message, Exception innerException) : base(message, innerException) {}
				protected RenameFailedException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region Constructor, variables
		private ICommandTarget target;
		private Console console;

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns the target.</param>
		/// <param name="target">Target node or item.</param>
		///  <history>
		///      [dmitriv] 5/10/2003  Created
		///  </history>
		internal ConsoleActions(Console console, ICommandTarget target)
		{
			this.console = console;
			this.target = target;
		}
		#endregion

		/// <summary>
		///		Invokes "New Window from Here" command on target element.
		/// </summary>
		/// <returns>New console window.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console NewWindowFromHere()
		{
			return NewWindowFromHere(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes "New Window from Here" command on target element.
		/// </summary>
		/// <param name="method">How to invoke target command.</param>
		/// <returns>New console window.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console NewWindowFromHere(CommandMethod method)
		{
			Commands.ActionNewWindowFromHere.Execute(target, method);
			return new Console(console.App);
		}

		/// <summary>
		///		Renames current node.
		/// </summary>
		/// <param name="newName">New name of the element.</param>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Rename (string newName)
		{
			Rename(newName, CommandMethod.Default);
		}

		/// <summary>
		///		Renames current node.
		/// </summary>
		/// <param name="newName">New name of the element.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Rename (string newName, CommandMethod method)
		{
			Commands.ActionRename.Execute(target, method);
			new TextBox(new Window(WindowType.Focused)).Text = newName;
			Keyboard.SendKeys("{ENTER}");
			console.WaitForResponse();
			string text = target is ConsoleNode ? (target as ConsoleNode).Text : (target as ConsoleItem).Text;
			if (text != newName)
				throw new Exceptions.RenameFailedException("Unable to rename element.\n"+
					"Expected name: " + newName + "\n"+
					"Actual name: " + text + "\n");
		}

		/// <summary>
		///		Deletes current node from console.
		/// </summary>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Delete()
		{
			Delete(AlertAction.ClickYes, CommandMethod.Default);
		}

		/// <summary>
		///		Deletes current node from console.
		/// </summary>
		/// <param name="alertAction">Alert action to use in case of alert.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Delete(AlertAction alertAction, CommandMethod method)
		{
			Commands.ActionDelete.Execute(target, method);
			if (alertAction != AlertAction.NoAction)
			{
				Alert alert = Alert.HandleAlert(null, AlertAction.NoAction, console.App.MainWindow, 2000);
				alert.PerformAlertAction(alertAction);
				UISynchronization.WaitForUIObjectReady(console);
			}
		}

		/// <summary>
		///		Invokes Refresh action on the element.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Refresh()
		{
			Refresh(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes Refresh action on the element.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Refresh(CommandMethod method)
		{
			Commands.ActionRefresh.Execute(target, method);
			UISynchronization.WaitForUIObjectReady(console);
		}

		/// <summary>
		///		Invokes NewTaskPadView action on the element.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void NewTaskPadView()
		{
			NewTaskPadView(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes NewTaskPadView action on the element.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void NewTaskPadView(CommandMethod method)
		{
			Commands.ActionNewTaskPadView.Execute(target, method);
			// TODO: need a dialog class and handle the dialog or return it
		}

		/// <summary>
		///		Invokes AllTasks action on the element.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExecuteTask(string taskName)
		{
			ExecuteTask(taskName, CommandMethod.Default);
		}

		/// <summary>
		///		Invokes AllTasks action on the element.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExecuteTask(string taskName, CommandMethod method)
		{
			Command cmd = new Command(Commands.ActionAllTasks.MainMenuPath + taskName, Commands.ActionAllTasks.ContextMenuPath + taskName);
			cmd.Execute(target, method);
		}

		/// <summary>
		/// Executes taskName from the Taskpad view on this console node.  A task item is not selected.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <history>
		///		[zeghmit]	12/5/2003	Created
		/// </history>
		public void ExecuteHTMLTask (string taskName)
		{
			this.console.ExecuteTaskNoSelect(taskName);
		}

		/// <summary>
		///		Invokes New action on the element.
		/// </summary>
		/// <param name="newItemType">Name of new item type to invoke command.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void AddNew(string newItemType)
		{
			AddNew(newItemType, CommandMethod.Default);
		}

		/// <summary>
		///		Invokes New action on the element.
		/// </summary>
		/// <param name="newItemType">Name of new item type to invoke command.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void AddNew(string newItemType, CommandMethod method)
		{
			Command cmd = new Command(Commands.ActionNew.MainMenuPath + newItemType, Commands.ActionNew.ContextMenuPath + newItemType);
			cmd.Execute(target, method);
		}

		/// <summary>
		///		Invokes ExportList action on the element.
		/// </summary>
		/// <param name="fileName">File name to where to export.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExportList(string fileName)
		{
			ExportList(fileName, CommandMethod.Default);
		}

		/// <summary>
		///		Invokes ExportList action on the element.
		/// </summary>
		/// <param name="fileName">File name to where to export.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExportList(string fileName, CommandMethod method)
		{
			Commands.ActionExportList.Execute(target, method);

			// HACK: use the actual Open dialog when it's implemented in Maui.Windows
			Window wnd = new Window("Export List...", StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, console.App, 3000);
			new TextBox(wnd, 0x47C).Text = fileName;
			new Button(wnd, "Save*", StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch).Click();
			wnd.WaitForInvalid();
			// END HACK

			UISynchronization.WaitForUIObjectReady(console);
		}

		/// <summary>
		///		Invokes Help action on the element.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ViewHelp()
		{
			ViewHelp(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes Help action on the element.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ViewHelp(CommandMethod method)
		{
			Commands.ActionHelp.Execute(target, method);
		}

		/// <summary>
		///		Invokes and returns properties dialog on target element.
		/// </summary>
		/// <returns>Properties dialog.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Dialogs.PropertiesDialog ViewProperties()
		{
			return ViewProperties(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes and returns properties dialog on target element.
		/// </summary>
		/// <param name="method">How to invoke target action.</param>
		/// <returns>Properties dialog.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Dialogs.PropertiesDialog ViewProperties(CommandMethod method)
		{
			Commands.ActionProperties.Execute(target, method);
			return new Dialogs.PropertiesDialog(console.App, console.App.MainWindow);
		}

		/// <summary>
		///		Invokes and returns properties dialog on target element. 
		/// </summary>
		/// <param name="method">How to invoke target action.</param>
		/// <param name="className">The window class type of the expected dialog</param>
		/// <param name="classNameMatchSyntax">The String Match Syntax for the parameter className</param>
		/// <returns>Properties dialog.</returns>
		/// <history>
		///		[carolli] 11/23/2004 Created
		/// </history>		 
		public Dialogs.PropertiesDialog ViewProperties(CommandMethod method, string className, StringMatchSyntax classNameMatchSyntax)
		{
			Commands.ActionProperties.Execute(target, method);
			return new Dialogs.PropertiesDialog(console.App, console.App.MainWindow, className, classNameMatchSyntax);
		}

		/// <summary>
		///		Invokes Open action on the node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Open()
		{
			Open(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes Open action on the node.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Open(CommandMethod method)
		{
			Commands.ActionOpen.Execute(target, method);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\ConsoleItem.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using System.Collections;
	using Maui.Core;
	using Maui.Core.WinControls;

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: ConsoleItem
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Abstraction of a node of right-hand side list-view inside Console Window.
	/// </summary>
	/// <history>
	///		[dmitriv] 6/15/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class ConsoleItem : ListViewItem, ICommandTarget
	{
		#region Constructors, private variables
		private Console console = null;

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this item.</param>
		/// <param name="index">Index of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (Console console, int index) : base(console.Controls.Details, index)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this item.</param>
		/// <param name="name">Path of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (Console console, string name) : base(console.Controls.Details, name)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="node">Console node which owns this item.</param>
		/// <param name="index">Index of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (ConsoleNode node, int index) : base(node.GetDetailsView(), index)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="node">Console node which owns this item.</param>
		/// <param name="name">Name of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (ConsoleNode node, string name) : base(node.GetDetailsView(), name)
		{
			this.console = console;
		}
		#endregion
	
		#region ICommandTarget implementation
		/// <summary>
		///		Invokes and returns context menu on this node selecting it beforehand.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public override Menu ContextMenu
		{
			get
			{
				return GetContextMenu(true);
			}
		}

		/// <summary>
		///		Selects the node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new void Select()
		{
			base.Select();
			Core.UISynchronization.WaitForUIObjectReady(console);
			console.WaitForResponse();
			console.App.MainWindow.WaitForResponse();
		}

		/// <summary>
		///		Application which owns this item.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		App ICommandTarget.App
		{
			get
			{
				return Console.App;
			}
		}

		/// <summary>
		///		Window to wait on after operation.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/31/2003	Created
		/// </history>
		Window ICommandTarget.TargetWindow
		{
			get
			{
				return Console.Controls.Details;
			}
		}
		#endregion

		#region Properties
		/// <summary>
		///		Returns console containing this node.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console Console
		{
			get
			{
				return console;
			}
		}

		/// <summary>
		///		Actions available on this item.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public ConsoleActions Actions
		{
			get
			{
				return new ConsoleActions(Console, this);
			}
		}
		#endregion

		#region Methods
		/// <summary>
		///		Invokes and returns context menu for this node.
		/// </summary>
		/// <param name="selectNodeFirst">Whether to select the node before right-click on it.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Menu GetContextMenu (bool selectNodeFirst)
		{
			if (selectNodeFirst)
				Select();
			else
				EnsureVisible();
			return new Menu(Left + 10, Top + Height/2);
		}

		/// <summary>
		/// Executes task from the Taskpad view on this item.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <history>
		///		[dmitriv] 11/22/2003 Created
		//		[zeghmit] 12/05/2003 Moved code to Console.
		/// </history>
		public void ExecuteTask (string taskName)
		{
			UISynchronization.WaitForUIObjectReady(ParentListView);
			Select();
			Console.ExecuteTaskNoSelect(taskName); 
		}
		#endregion		
	}

	#region ConsoleItemCollection
	/// ------------------------------------------------------------------------------
	///  Project   : Maui.ManagementConsole
	///  Class     : ConsoleItemCollection
	/// 
	///  Copyright (C) 2002, Microsoft Corporation
	/// ------------------------------------------------------------------------------
	///  <summary>
	///		Strongly-typed collection of ConsoleItem objects
	///  </summary>
	///  <remarks></remarks>
	///  <history>
	///      [dmitriv] 7/5/2003  Created
	///  </history>
	/// ------------------------------------------------------------------------------
	[Serializable()]
	public class ConsoleItemCollection : Core.RemotingObject, ICollection
	{
		private Console console;
		private ListView listView;

		///  <summary>
		///       Initializes a new instance of <see cref="Maui.ManagementConsole.ConsoleItemCollection"/>.
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		internal ConsoleItemCollection(Console console)
		{
			this.console = console;
			this.listView = console.Controls.Details;
		}
        
		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleItem"/>.
		///  </summary>
		///  <param name="index">The zero-based index of the entry to locate in the collection.</param>
		///  <value>
		///		The entry at the specified index of the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleItem this[int index] 
		{
			get 
			{
				return new ConsoleItem(console, index);
			}
		}

		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleItem"/>.
		///  </summary>
		///  <param name="name">Name of the entry to locate in the collection.</param>
		///  <value>
		///		The entry with the specified name in the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleItem this[string name] 
		{
			get 
			{
				return new ConsoleItem(console, name);
			}
		}        
        
		///  <summary>
		///		Copies the <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> values
		///		to a one-dimensional <see cref="System.Array"/> instance at the  specified index.
		///  </summary>
		///  <param name="array">The one-dimensional <see cref="System.Array"/> that is the destination of the values copied from <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> .</param>
		///  <param name="index">The index in <paramref name="array"/> where copying begins.</param>
		///  <remarks><exception cref="System.ArgumentException"><paramref name="array"/> is multidimensional. <para>-or-</para> <para>The number of elements in the <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> is greater than the available space between <paramref name="arrayIndex"/> and the end of <paramref name="array"/>.</para></exception>
		///  <exception cref="System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>. </exception>
		///  <exception cref="System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than <paramref name="array"/>"s lowbound. </exception>
		///  <seealso cref="System.Array"/>
		///  </remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public void CopyTo(Array array, int index) 
		{
			for (int i = 0; i < Count; i++)
				array.SetValue(this[i], index+i);
		}
        
		///  <summary>
		///    Returns an enumerator that can iterate through 
		///    the <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> .
		///  </summary>
		///  <returns>An enumerator for the collection</returns>
		///  <remarks><seealso cref="System.Collections.IEnumerator"/></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public IEnumerator GetEnumerator() 
		{
			return new ConsoleItemEnumerator(this);
		}

		/// <summary>
		///		Returns number of items in collection.
		/// </summary>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public int Count
		{
			get
			{
				return listView.Count;
			}
		}

		/// <summary>
		///		Whether collection is syncrhonized.
		/// </summary>
		bool ICollection.IsSynchronized
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		///		SyncRoot for collection.
		/// </summary>
		object ICollection.SyncRoot
		{
			get
			{
				return this;
			}
		}
        
		#region ConsoleItemEnumerator
		private class ConsoleItemEnumerator : object, IEnumerator 
		{            
			private ConsoleItemCollection baseCollection;
			private int index = -1;
            
			public ConsoleItemEnumerator(ConsoleItemCollection baseCollection)
			{
				this.baseCollection = baseCollection;
				this.index = -1;
			}
            
			public object Current 
			{
				get 
				{
					return baseCollection[index];
				}
			}
            
			public bool MoveNext() 
			{
				return ++index < baseCollection.Count;
			}
            
			public void Reset() 
			{
				index = -1;
			}
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\SnapIn.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using Maui.Core;
    using System.Collections.Specialized;

    /// <summary>
    /// Handles snap-in wizard/dialog when adding a snap-in.
    /// </summary>
    /// <history>
    ///		[dmitriv]	7/5/2003	Created
    /// </history>
    public delegate void SnapinWizardHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard);

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: MmcApplication.
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Snap-in parameters to be used when adding a snap-in.
    /// </summary>
    ///  <history>
    /// 	[dmitriv] 6/15/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class Snapin : RemotingObject
    {
        #region Private variables, constructors
        private string name = null;
        private string addedName = null;
        private string path = null;
        private string[] extensions = null;
        private string computerName = null;
        private int position = 0;
        private int addSnapInInitializationTimeout = 6000;
        private bool allowComputerChangeFromCommandLine = false;
        private SnapinWizardHandler wizardHandler = null;
        private NameValueCollection settings = new NameValueCollection();

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="name">Name of the snap-in.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Snapin(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="name">Name of the snap-in.</param>
        /// <param name="wizardHandle">Snap-in wizard handler.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Snapin(string name, SnapinWizardHandler wizardHandle)
        {
            this.name = name;
            this.WizardHandler = wizardHandle;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Name of the snap-in.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }

        /// <summary>
        /// Added name of the snap-in.
        /// </summary>
        /// <history>
        ///		[michsny]	12/28/2003	Created
        /// </history>
        public string AddedName
        {
            get
            {
                return addedName;
            }
            set
            {
                addedName = value;
            }
        }

        /// <summary>
        /// Path inside virtual snap-in tree to where to add the snap-in.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string Path
        {
            get
            {
                return path;
            }
            set
            {
                path = value;
            }
        }

        /// <summary>
        /// Position under parent snap-in.
        /// </summary>
        /// <history>
        ///		[michsny]	12/28/2003	Created
        /// </history>
        public int Position
        {
            get
            {
                return position;
            }
            set
            {
                position = value;
            }
        }

        /// <summary>
        /// Timeout for add/remove snap-in initialization
        /// </summary>
        /// <history>
        ///		[michsny]	1/20/2004	Created
        /// </history>
        public int AddSnapInInitializationTimeout
        {
            get
            {
                return addSnapInInitializationTimeout;
            }
            set
            {
                addSnapInInitializationTimeout = value;
            }
        }

        /// <summary>
        /// List of extensions to include with Snap-in.
        /// Default is to include all extensions (null value).
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string[] Extensions
        {
            get
            {
                return extensions;
            }
            set
            {
                extensions = value;
            }
        }

        /// <summary>
        /// Name of computer to manage. Local computer is the default (null value).
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string ComputerName
        {
            get
            {
                return computerName;
            }
            set
            {
                computerName = value;
            }
        }

        /// <summary>
        /// Whether to check/uncheck corresponding check-box on Snap-In Wizard.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public bool AllowComputerChangeFromCommandLine
        {
            get
            {
                return allowComputerChangeFromCommandLine;
            }
            set
            {
                allowComputerChangeFromCommandLine = value;
            }
        }

        /// <summary>
        /// Set this property to handle custom Snap-in wizard.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public SnapinWizardHandler WizardHandler
        {
            get
            {
                return wizardHandler;
            }
            set
            {
                wizardHandler = value;
            }
        }

        /// <summary>
        ///		Name-value collection of extra settings to pass to snap-in wizard handler.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public NameValueCollection Settings
        {
            get
            {
                return settings;
            }
        }
        #endregion

        #region Methods
        /// <summary>
        /// Default snap-in wizard handler.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="snapIn">Snap-in.</param>
        /// <param name="wizard">Wizard instance to handle.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        static public void DefaultWizardHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
        {
            // otherwise handle the wizard outselves
            if (snapIn.ComputerName != null)
            {
                wizard.ComputerName = snapIn.ComputerName;
            }
            if (snapIn.AllowComputerChangeFromCommandLine)
            {
                wizard.ClickAllowComputerChangeFromCommandLine();
            }
            wizard.ClickFinish();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\SnapIns.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using Maui.Core;
	using Maui.Core.WinControls;

	// TODO: localize strings in SnapinStrings class

	#region SnapinSettings
	/// <summary>
	/// Custom snap-in settings.
	/// </summary>
	/// <history>
	///		[dmitriv]	7/5/2003	Created
	/// </history>
	public class SnapinSettings
	{
		public const string LinkToWebAddressTarget = "Target";
		public const string LinkToWebAddressName = "Name";

		public const string ActiveXControlType = "Type";
		public const string ActiveXControlName = "Name";

		public const string SharedFoldersView = "View";

		public class SharedFoldersViews
		{
			public const string All = "All";
			public const string Shares = "Shares";
			public const string Sessions = "Sessions";
			public const string OpenFiles = "Open Files";
		}
	}
	#endregion

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: MmcApplication.
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Definitions of standard MMC snap-ins.
	/// </summary>
	///  <history>
	/// 	[dmitriv] 6/15/2003 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public sealed class Snapins
	{
		#region Private constructor
		private Snapins() {} // this class is pure static
		#endregion

		#region Simple snap-ins
		/// <summary>
		/// Returns parameters for .NET Framework 1.1 Configuration snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin NetFrameworkConfig1_1
		{
			get
			{
				return new Snapin(";.NET Framework 1.1 Configuration;Win32String;mscormmc.dll;30");
			}
		}

		/// <summary>
		/// Returns parameters for Component Services snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin ComponentServices
		{
			get
			{
				return new Snapin(";Component Services;Win32String;comsnap.dll;100");
			}
		}

		/// <summary>
		/// Returns parameters for Computer Management snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin ComputerManagement
		{
			get
			{
				return new Snapin(";Computer Management;Win32String;mycomput.dll;193", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Device Manager snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin DeviceManager
		{
			get
			{
				return new Snapin(";Device Manager;Win32String;devmgr.dll;4", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Disk Management snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin DiskManagement
		{
			get
			{
				return new Snapin(";Disk Management;Win32String;dmdskres.dll;1003", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Event Viewer snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin EventViewer
		{
			get
			{
				return new Snapin(";Event Viewer;Win32String;els.dll;110", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Indexing Service snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin IndexingService
		{
			get
			{
				return new Snapin(";Indexing Service;Win32String;ciadmin.dll;557", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Local Users and Groups snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin LocalUsersAndGroups
		{
			get
			{
				return new Snapin(";Local Users and Groups;Win32String;localsec.dll;5026", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Removable Storage Management snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin RemovableStorageManagement
		{
			get
			{
				return new Snapin(";Removable Storage Management;Win32String;ntmsmgr.dll;3", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Services snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin Services
		{
			get
			{
				return new Snapin(";Services;Win32String;filemgmt.dll;5", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for WMI Control snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin WmiControl
		{
			get
			{
				return new Snapin(";WMI Control;Win32String;msinfo.dll;374", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Disk Defragmenter snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin DiskDefragmenter
		{
			get
			{
				return new Snapin(";Disk Defragmenter;Win32String;dfrgsnap.dll;100");
			}
		}

		/// <summary>
		/// Returns parameters for Folder snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin Folder
		{
			get
			{
				return new Snapin(";Folder;Win32String;mmcbase.dll;14008");
			}
		}

		/// <summary>
		/// Returns parameters for FrontPage Server Extensions snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin FrontPageServerExtensions
		{
			get
			{
				return new Snapin("FrontPage Server Extensions");
			}
		}

		/// <summary>
		/// Returns parameters for Internet Information Services snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin InternetInformationServices
		{
			get
			{
				return new Snapin(";Internet Information Services;Win32String;inetmgr.dll;104");
			}
		}

		/// <summary>
		/// Returns parameters for IP Security Monitor snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin IPSecurityMonitor
		{
			get
			{
				return new Snapin(";IP Security Monitor;Win32String;ipsmsnap.dll;30");
			}
		}

		/// <summary>
		/// Returns parameters for Performance Logs and Alerts snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin PerfLogsAndAlerts
		{
			get
			{
				return new Snapin(";Performance Logs and Alerts;Win32String;smlogcfg.dll;500");
			}
		}

		/// <summary>
		/// Returns parameters for Security Configuration and Analysis snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin SecurityConfigAndAnalysis
		{
			get
			{
				return new Snapin(";Security Configuration and Analysis;Win32String;wsecedit.dll;372");
			}
		}

		/// <summary>
		/// Returns parameters for Security Templates snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin SecurityTemplates
		{
			get
			{
				return new Snapin(";Security Templates;Win32String;wsecedit.dll;24");
			}
		}
		#endregion

		#region Snap-ins with custom settings
		/// <summary>
		/// Returns parameters for Shared Folders snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin SharedFolders
		{
			get
			{
				return new Snapin(";Shared Folders;Win32String;filemgmt.dll;4", new SnapinWizardHandler(SharedFoldersHandler));
			}
		}

		/// <summary>
		/// Wizard handler for Link to Shared Fodlers snap-in.
		/// </summary>
		/// <param name="app">MMC application.</param>
		/// <param name="snapIn">Snap-in parameters.</param>
		/// <param name="wizard">Wizard to handle.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		private static void SharedFoldersHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
		{
			string value = snapIn.Settings[SnapinSettings.SharedFoldersView];
			if (value != null)
			{
				RadioButton button;
				switch (value)
				{
					case SnapinSettings.SharedFoldersViews.All:
						button = new RadioButton(wizard, 0xFF);
						break;
					case SnapinSettings.SharedFoldersViews.Shares:
						button = new RadioButton(wizard, 0x100);
						break;
					case SnapinSettings.SharedFoldersViews.Sessions:
						button = new RadioButton(wizard, 0x101);
						break;
					case SnapinSettings.SharedFoldersViews.OpenFiles:
						button = new RadioButton(wizard, 0x102);
						break;
					default:
						throw new ArgumentException("Value of SharedFoldersView setting is incorrect.");
				}
				button.Click();
			}
			Snapin.DefaultWizardHandler(app, snapIn, wizard);
		}

		/// <summary>
		/// Returns parameters for Link to Web Address snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin LinkToWebAddress
		{
			get
			{
				return new Snapin(";Link to Web Address;Win32String;mmcbase.dll;14010", new SnapinWizardHandler(LinkToWebAddressHandler));
			}
		}

		/// <summary>
		/// Wizard handler for Link to Web Address snap-in.
		/// </summary>
		/// <param name="app">MMC application.</param>
		/// <param name="snapIn">Snap-in parameters.</param>
		/// <param name="wizard">Wizard to handle.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		private static void LinkToWebAddressHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
		{
			TextBox target = new TextBox(wizard, 0x3FF);
			target.Text = snapIn.Settings[SnapinSettings.LinkToWebAddressTarget];
			wizard.ClickNext();
			TextBox name = new TextBox(wizard, 0x3FE);
			name.Text = snapIn.Settings[SnapinSettings.LinkToWebAddressName];
			wizard.ClickFinish();
		}

		/// <summary>
		/// Returns parameters for Link to Web Address snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin ActiveXControl
		{
			get
			{
				return new Snapin(";ActiveX Control;Win32String;mmcbase.dll;214", new SnapinWizardHandler(ActiveXControlHandler));
			}
		}

		/// <summary>
		/// Wizard handler for ActiveX Control snap-in.
		/// </summary>
		/// <param name="app">MMC application.</param>
		/// <param name="snapIn">Snap-in parameters.</param>
		/// <param name="wizard">Wizard to handle.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		private static void ActiveXControlHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
		{
			wizard.ClickNext();
			ListView controls = new ListView(wizard, 0x3E8);
			controls.Items[snapIn.Settings[SnapinSettings.ActiveXControlType]].Select();
			wizard.ClickNext();
			TextBox name = new TextBox(wizard, 0x3FE);
			name.Text = snapIn.Settings[SnapinSettings.ActiveXControlName];
			wizard.ClickFinish();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\AddRemoveColumnsDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{      
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;
	
	#region IAddRemoveColumnsDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddRemoveColumnsDialogControls
    {
        ListBox AvailableColumnsListBox  {get;}
        ListBox DisplayedColumnsListBox  {get;}
        Button AddButton  {get;}
        Button RemoveButton  {get;}
        Button MoveUpButton  {get;}
        Button MoveDownButton  {get;}
        Button RestoreDefaultsButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }
    #endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: AddRemoveColumnsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Add/Remove Columns Dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 5/10/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddRemoveColumnsDialog : Dialog, IAddRemoveColumnsDialogControls
    {
		#region Constants, member Variables
		private const string DialogTitle = ";Add/Remove Columns;Win32DialogString;mmcndmgr.dll;1070";

		private class ControlIDs
		{
			public const int AvailableColumnsListBox = 4084;
			public const int DisplayedColumnsListBox = 4088;
			public const int AddButton = 4085;
			public const int RemoveButton = 4086;
			public const int MoveUpButton = 4089;
			public const int MoveDownButton = 4090;
			public const int RestoreDefaultsButton = 4087;
			public const int OKButton = 1;
			public const int CancelButton = 2;
		}
		
        private ListBox m_cachedAvailableColumnsListBox;
        private ListBox m_cachedDisplayedColumnsListBox;
        private Button m_cachedAddButton;
        private Button m_cachedRemoveButton;
        private Button m_cachedMoveUpButton;
        private Button m_cachedMoveDownButton;
        private Button m_cachedRestoreDefaultsButton;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        #endregion

        #region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MMC application object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddRemoveColumnsDialog(MmcApp app) :  base(app, Init(app, CommandMethod.Default))
        {
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Constructor.
		///  </summary>
		///  <param name="app">MMC application object owning the dialog.</param>
		///  <param name="method">How to invoke the command.</param>
		///  <history>
		/// 	[dmitriv] 5/10/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AddRemoveColumnsDialog(MmcApp app, CommandMethod method) :  base(app, Init(app, method))
		{
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		This function will attempt to find a showing instance of the dialog.
        ///  </summary>
		///  <param name="app">IDEApp owning the dialog.</param>)
		///  <param name="method">How to invoke the command.</param>
		///  <returns>The dialog's Window</returns>
        ///  <history>
        /// 	[dmitriv]	5/10/2003	Created
        /// 	[dmitriv]	11/6/2003	Fixed sync issue
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            Window tempWindow;
			try
			{
				tempWindow = new Window(
					app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
					WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
					app, 200);
			}
			catch (Window.Exceptions.WindowNotFoundException)
			{
				Commands.ViewAddRemoveColumns.Execute(app, method);
				tempWindow = new Window(
					app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
					WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
					app, 3000);           
			}
			return tempWindow;
        }
        #endregion

        #region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddRemoveColumnsDialogControls Controls
        {
            get
            {
                return this;
            }
        }        
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the AvailableColumnsListBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox IAddRemoveColumnsDialogControls.AvailableColumnsListBox
        {
            get
            {
                if ((m_cachedAvailableColumnsListBox == null))
                {
                    m_cachedAvailableColumnsListBox = new ListBox(this, ControlIDs.AvailableColumnsListBox);
                }
                return m_cachedAvailableColumnsListBox;
            }
        }        
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the DisplayedColumnsListBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
		ListBox IAddRemoveColumnsDialogControls.DisplayedColumnsListBox
		{
			get
			{
				if ((m_cachedDisplayedColumnsListBox == null))
				{
					m_cachedDisplayedColumnsListBox = new ListBox(this, ControlIDs.DisplayedColumnsListBox);
				}
				return m_cachedDisplayedColumnsListBox;
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the RemoveButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.RemoveButton
        {
            get
            {
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the MoveUpButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.MoveUpButton
        {
            get
            {
                if ((m_cachedMoveUpButton == null))
                {
                    m_cachedMoveUpButton = new Button(this, ControlIDs.MoveUpButton);
                }
                return m_cachedMoveUpButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the MoveDownButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.MoveDownButton
        {
            get
            {
                if ((m_cachedMoveDownButton == null))
                {
                    m_cachedMoveDownButton = new Button(this, ControlIDs.MoveDownButton);
                }
                return m_cachedMoveDownButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the RestoreDefaultsButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.RestoreDefaultsButton
        {
            get
            {
                if ((m_cachedRestoreDefaultsButton == null))
                {
                    m_cachedRestoreDefaultsButton = new Button(this, ControlIDs.RestoreDefaultsButton);
                }
                return m_cachedRestoreDefaultsButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

		/// <summary>
		///		Gets or sets visible column list.
		/// </summary>
		public string[] ColumnList
		{
			get
			{
				string[] result = new string[Controls.DisplayedColumnsListBox.Count];
				foreach (ListBoxItem item in Controls.DisplayedColumnsListBox.Items)
					result[item.Index] = item.Text;
				return result;
			}
			set
			{
				// add all items
				repeat1:
					foreach (ListBoxItem item in Controls.AvailableColumnsListBox.Items)
					{
						if (System.Array.IndexOf(value, item.Text) >= 0)
						{
							item.Selected = true;
							ClickAdd();
							goto repeat1;
						}
					}

				// remove items from display list which are not wanted
				repeat2:
					foreach (ListBoxItem item in Controls.DisplayedColumnsListBox.Items)
					{
						if (System.Array.IndexOf(value, item.Text) < 0)
						{
							item.Selected = true;
							if (Controls.RemoveButton.IsEnabled)
							{
								ClickRemove();
								goto repeat2;
							}
							else
							{
								throw new GlobalExceptions.MauiException("It is not possible to remove column " + item.Text + " from displayed columns list! (Remove button is disabled).");
							}
						}
					}

				if (Controls.DisplayedColumnsListBox.Items.Count != value.Length)
					throw new GlobalExceptions.MauiException("Some columns from specified column list were not found!");

				// reorder items
				for (int i = 0; i < value.Length; i++)
				{
					ListBoxItem item = Controls.DisplayedColumnsListBox[value[i]];
					while (item.Index > i)
					{
						item.Selected = true;
						ClickMoveUp();
						item = Controls.DisplayedColumnsListBox[value[i]];
					}
					while (item.Index < i)
					{
						item.Selected = true;
						ClickMoveDown();
						item = Controls.DisplayedColumnsListBox[value[i]];
					}
				}
			}
		}
        #endregion

        #region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Remove
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickRemove()
        {
            Controls.RemoveButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button MoveUp
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveUp()
        {
            Controls.MoveUpButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button MoveDown
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveDown()
        {
            Controls.MoveDownButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button RestoreDefaults
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
		public virtual void ClickRestoreDefaults()
		{
			Controls.RestoreDefaultsButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
			WaitForInvalid();
			UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
			UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\MmcApp.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Threading;
    using System.Globalization;
    using System.ComponentModel;
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using Maui.ManagementConsole.Dialogs;

    #region IMmcAppControls interface
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMmcAppControls
    {
        Toolbar Toolbar { get; }
        Window MdiContainer { get; }
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: MmcApplication.
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Microsoft Management Console application.
    /// </summary>
    ///  <history>
    /// 	[dmitriv] 6/15/2003 Created
    ///		[yiqingdu]	6/17/2004 added QuitTimeout
    ///     [faisalb]   3/22/2005   Added check for Process Idle after adding SnapIn
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MmcApp : App, IMmcAppControls
    {
        #region Constants

        internal class Strings
        {
            public const string MMCMainFrame = "MMCMainFrame";
            public const string MDIClient = "MDIClient";
            public const string MMCChildFrm = "MMCChildFrm";
            public const string SaveAlertText = ";Save console settings to %1?;Win32String;mmcbase.dll;13357";

            public const int QuitTimeout = 5000;
        }

        private const int DefaultAddSnapinsTimeout = 5000;  // 5 seconds
        private const int ShortTimeout = 500;               // 0.5 seconds
        
        #endregion

        #region Constructors, private variables
        /// <summary>
        /// Constructor to start a new MMC application.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public MmcApp() : base(AdjustParameters(new AppParameters()))
        {
        }

        /// <summary>
        /// Constructor to start a new MMC application with arguments.
        /// </summary>
        /// <param name="arguments">Arguments to pass to MMC executable.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public MmcApp(string arguments) : base(AdjustParameters(new AppParameters(null, arguments)))
        {
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="parameters">Application start parameters.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public MmcApp(AppParameters parameters) : base(AdjustParameters(parameters))
        {
        }

        /// <summary>
        /// Constructor to start a new MMC application with Window.
        /// </summary>
        /// <param name="arguments">Window to pass.</param>
        /// <history>
        ///		[rongcao]	1/28/2004	Created
        /// </history>
        public MmcApp(Window window) : base(window)
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="MmcPath">Path for MMC (requires for MMC 2.1)</param>
        /// <param name="arguments">Application start parameters</param>
        /// <history>
        ///		[FaisalB]	3/16/2003	Created
        /// </history>
        public MmcApp(string MmcPath, string arguments): base(AdjustParameters(new AppParameters(MmcPath, arguments)))
        {
        }

        /// <summary>
        /// Corrects application parameters structure for base App constructor.
        /// </summary>
        /// <param name="parameters"></param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private static AppParameters AdjustParameters(AppParameters parameters)
        {
            if (parameters.ExePath == null)
                parameters.ExePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "mmc.exe");
            parameters.MainWindowClass = Strings.MMCMainFrame;
            // this is needed for MUI resource extraction 
            string lcid = Registry.GetValue(RegistryHive.Win32CurrentUser, @"Control Panel\Desktop", "MultiUILanguageID");
            if (lcid != null)
            {
                Thread.CurrentThread.CurrentCulture = new CultureInfo(Int32.Parse(lcid, NumberStyles.HexNumber));
            }
            return parameters;
        }
        #endregion

        #region Controls interface
        /// <summary>
        ///		Provides access to MMC application window controls.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public IMmcAppControls Controls
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///		Returns toolbar control of the application.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        Toolbar IMmcAppControls.Toolbar
        {
            get
            {
                return new Toolbar(MainWindow, "", 1);
            }
        }

        /// <summary>
        ///		Returns MDI client window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        Window IMmcAppControls.MdiContainer
        {
            get
            {
                return new Window(null, StringMatchSyntax.ExactMatch,
                    Strings.MDIClient, StringMatchSyntax.ExactMatch,
                    MainWindow, 200);
            }
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets collection of all console windows inside the MMC.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public ConsoleCollection Consoles
        {
            get
            {
                return new ConsoleCollection(this);
            }
        }

        /// <summary>
        /// Gets top-most console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console Console
        {
            get
            {
                return new Console(this);
            }
        }


        /// <summary>
        /// MMC has weird menu behavior on different platforms
        /// </summary>
        /// <history>
        ///		[BrianMcM]	2/4/2005	Created
        /// </history>
        public override Menu Menu
        {
            get
            {
                try
                {
                    return base.Menu;
                }
                catch (Menu.Exceptions.ItemNotFoundException)
                {
                    ActiveAccessibility mainWndAA = new ActiveAccessibility(this.MainWindow.Extended.HWnd, MsaaObjectID.Window);
            
                    // The role of the menu bar on Longhorn is tool bar, not menu bar
                    // Look for a toolbar who's first item is a menu item
                    ActiveAccessibilityCollection foundElements = ActiveAccessibility.FindUIElements(mainWndAA, NavigationFlags.VisibleOnly | NavigationFlags.FindAll, null, null, (int)MsaaRole.ToolBar, -1);
                    
                    if(foundElements == null || foundElements.Count == 0)
                    {
                        throw new Menu.Exceptions.ItemNotFoundException("Could not find AA object for Menu Bar!");
                    }

                    foreach(ActiveAccessibility menuBar in foundElements)
                    {
                        if(menuBar.Visible && menuBar.ChildCount > 0 && menuBar.Children[0].Role == (int)MsaaRole.MenuItem)
                        {
                            // Found it!
                            return new Menu(menuBar);
                        }
                    }

                    throw new Menu.Exceptions.ItemNotFoundException("Could not find AA object for Menu Bar!");
                    
                }
            }
        }

        #endregion

        #region Methods
        /// <summary>
        ///		Sets resource search paths.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        protected override void SetResourceSearchPaths()
        {
            ResourceManager.PathCache.DefaultPath =
                Environment.GetFolderPath(Environment.SpecialFolder.System) + ";" +
                Registry.GetValue(RegistryHive.Win32LocalMachine, @"Software\Microsoft\.NETFramework", "InstallRoot");
        }

        /// <summary>
        ///		Extracts string by its resource ID from the product.
        /// </summary>
        /// <param name="resourceId">Resource ID of the string.</param>
        /// <returns>Extracted string.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public override string GetIntlStr(string resourceId)
        {
            // need to perform this conversion because MMC contains 2 strings in 1
            return base.GetIntlStr(resourceId).Split('\n')[0];
        }

        /// <summary>
        ///		Adds snap-in to the application.
        /// </summary>
        /// <param name="snapIn">Snap-in to be added.  All Extensions will be enabled.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void AddSnapin(Snapin snapIn)
        {
            AddSnapins(new Snapin[] { snapIn }, DefaultAddSnapinsTimeout);
        }

        /// <summary>
        ///		Adds snap-in to the application.
        /// </summary>
        /// <param name="snapIn">Snap-in to be added.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///		[dmitriv]	12/29/2004	Added timeout parameter
        /// </history>
        public void AddSnapin(Snapin snapIn, int timeout)
        {
            AddSnapins(new Snapin[] { snapIn }, timeout);
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void AddSnapins(Snapin[] snapIns)
        {
            this.AddSnapins(snapIns, DefaultAddSnapinsTimeout);
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <param name="timeout">Timeout to wait for snapins to be initialized.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///		[dmitriv]	12/29/2003	Added timeout parameter
        ///             [michsny]	12/28/2004  Added parameters for extensions, ordering, and nesting
        ///             [michsny]	12/30/2004  Added code to manipulate new Add or Remove dialogs
        ///             [michsny]	12/30/2004  Moved code to NewUI and OldUI methods.
        /// </history>
        public void AddSnapins(Snapin[] snapIns, int timeout)
        {
            Boolean usingNewUI = AddRemoveIsUsingNewUI();

            // Now that we know which UI to use, go ahead and add the SnapIns.
            if (usingNewUI)
            {
                // Use the UI added in MMC 2.1 and enabled by default in Longhorn
                AddSnapinsUsingAddOrRemoveSnapInsDialog(snapIns, timeout);
            }
            else
            {
                // Use the UI for MMC 2.0, default prior to Longhorn
                AddSnapinsUsingAddRemoveSnapInDialog(snapIns, timeout);
            }
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console using the MMC 2.0 UI.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <param name="timeout">Timeout to wait for snapins to be initialized.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created 
        ///		[dmitriv]	12/29/2003	Added timeout parameter
        ///             [michsny]	12/28/2004  Added parameters for extensions, ordering, and nesting
        ///             [michsny]	12/30/2004  Moved code from AddSnapins to AddSnapinsUsingAddRemoveSnapInDialog
        ///             [michsny]	12/31/2004  Added code to handle extensions and nesting in old dialogs
        /// </history>
        private void AddSnapinsUsingAddRemoveSnapInDialog(Snapin[] snapIns, int timeout)
        {
            // launch the add/remove dialog
            AddRemoveSnapinDialog dialog = new AddRemoveSnapinDialog(this);

            // add snap-ins one-by-one
            foreach (Snapin snapIn in snapIns)
            {
                // check if snap-in name is resource ID - then convert it
                if (snapIn.Name.StartsWith(";"))
                    snapIn.Name = GetIntlStr(snapIn.Name);

                // select the path
                if (snapIn.Path != null)
                    dialog.SetPath(snapIn.Path);                

                // add the snap-in now
                dialog.ClickAdd();
                AddStandaloneSnapin(snapIn);

                // if extensions are specified - select them
                if (snapIn.Extensions != null)
                {
                    // check if extensions are resource ID-s and convert them
                    for (int i = 0; i < snapIn.Extensions.Length; i++)
                        if (snapIn.Extensions[i].StartsWith(";"))
                            snapIn.Extensions[i] = GetIntlStr(snapIn.Extensions[i]);

                    // select snap-in to extend
                    dialog.SnapinToExtend = snapIn.Name;

                    // say we don't want all extensions
                    dialog.AddAllExtensions = false;

                    // choose extensions to include
                    foreach (string extension in dialog.Extensions)
                    {
                        dialog.SetExtensionState(extension, Array.IndexOf(snapIn.Extensions, extension) >= 0);
                    }
                }
            }

            // close the dialog and wait for app to load everything
            dialog.ClickOK(timeout);
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console using the MMC 2.1 UI.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <param name="timeout">Timeout to wait for snapins to be initialized.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created (as AddSnapinsUI)
        ///		[dmitriv]	12/29/2003	Added timeout parameter
        ///             [michsny]	12/28/2004  Added parameters for extensions, ordering, and nesting
        ///             [michsny]	12/30/2004  Added code to handle the new UI in AddSnapInsNewUI
        ///             [michsny]	12/31/2004  Added code to handle extensions and nesting in old dialogs
        /// </history>
        private void AddSnapinsUsingAddOrRemoveSnapInsDialog(Snapin[] snapIns, int timeout)
        {
            bool selectionOfParentSnapInIsEnabled = false;

            // launch the add/remove dialog
            AddOrRemoveSnapInsDialog dialog = new AddOrRemoveSnapInsDialog(this);

            // add snap-ins one-by-one
            foreach (Snapin snapIn in snapIns)
            {
                // check if snap-in name is resource ID - then convert it
                if (snapIn.Name.StartsWith(";"))
                    snapIn.Name = GetIntlStr(snapIn.Name);

                // Select the snapin to add this snap-in under
                if (snapIn.Path != null)
                {
                    // enable the selection of the snap-in parent if it isn't currently enabled
                    if (selectionOfParentSnapInIsEnabled == false)
                    {
                        // remember if we have enabled this selection
                        selectionOfParentSnapInIsEnabled = true;

                        // open and get the advanced dialog
                        AdvancedDialog advancedDialog = new AdvancedDialog(this, dialog);

                        // check the checkbox to enable the selection of a parent snap-in
                        advancedDialog.EnableAllowChangingTheParentSnapIn();

                        // click ok and close the advanced dialog
                        advancedDialog.ClickOK();

                        // Wait up to 1 second for the snapin to be selected
                        UISynchronization.WaitForUIObjectReady(dialog, timeout);
                    }
                    // select the parent snap-in in the combobox
                    dialog.SetPath(snapIn.Path);
                }
                else
                {
                    // if we previously selected a root, but none is currently provided, reset to the default
                    if (selectionOfParentSnapInIsEnabled)
                        dialog.SetPathToConsoleRoot();                    
                }

                // select the snap-in
                dialog.SelectAvailableSnapIn(snapIn);

                // Wait up to 1 second for the snapin to be selected
                UISynchronization.WaitForUIObjectReady(dialog, timeout);

                // we need this below to determine if the snap-in has finished adding
                int addedCount = dialog.Controls.AddedSnapinsList.Count;

                // add the snap-in
                dialog.ClickAdd();

                // if there is a wizard handler, handle the wizard
                if (snapIn.WizardHandler != null)
                {
                    // handle snap-in Wizard, if handler is provided
                    snapIn.WizardHandler(this, snapIn, new SnapinWizard(this, dialog));
                }

                // Wait until the snap-in is added to the added list
                {
                    DateTime addTimeout = DateTime.Now.AddMilliseconds(snapIn.AddSnapInInitializationTimeout);                                          
                    while ((dialog.Controls.AddedSnapinsList.Count.CompareTo(addedCount) == 0) &&
                        (addTimeout.CompareTo(DateTime.Now)>0))
                    {
                        Sleeper.Delay(timeout); // wait the normal timeout length, and then check again                        
                    }
                }

                // if extensions are specified - select them, otherwise all extensions will be enabled
                if (snapIn.Extensions != null)
                {
                    // Select it in the Added list                
                    if (snapIn.AddedName != null)
                    {
                        dialog.SelectAddedSnapIn(snapIn);

                        // Wait up to 1 second for the snapin to be selected
                        UISynchronization.WaitForUIObjectReady(dialog, timeout);
                    }
                    else
                    {
                        //BUGBUG Throw and exception here
                    }

                    // Open the Extensions dialog
                    Extensions extensionsDialog = new Extensions(this, dialog);

                    // check if extensions are resource ID-s and convert them
                    for (int i = 0; i < snapIn.Extensions.Length; i++)
                        if (snapIn.Extensions[i].StartsWith(";"))
                            snapIn.Extensions[i] = GetIntlStr(snapIn.Extensions[i]);

                    // say we don't want all extensions
                    extensionsDialog.EnableOnlySelectedExtensions();

                    // initially disable every extension.  We will enable specific extensions in the next block.
                    foreach (ListViewItem extensionItem in extensionsDialog.Controls.ExtensionsList.Items)
                    {
                        extensionItem.Checked = false;
                    }

                    // choose extensions to include                    
                    foreach (string extensionName in snapIn.Extensions)
                    {
                        // enable each extension that we want to include
                        extensionsDialog.EnableExtension(extensionName);
                    }

                    // close the extensions dialog
                    extensionsDialog.ClickOK();
                }

                // if a snapin position is specified, check the current position under the
                // parent and move it up or down until it is at the specified position
                if (snapIn.Position != 0)
                {
                    // Select it in the Added list                
                    if (snapIn.AddedName != null)
                    {
                        dialog.SelectAddedSnapIn(snapIn);

                        // Wait up to 1 second for the snapin to be selected
                        UISynchronization.WaitForUIObjectReady(dialog, timeout);
                    }
                    else
                    {
                        //BUGBUG Throw and exception here
                    }

                    // the number of items at the same indent level as the added snap-in
                    int indentLevelItems = 0;

                    // obtain the indent level of the added snap-in
                    int indentLevel = dialog.Controls.AddedSnapinsList.Items[snapIn.AddedName].Indentation;

                    // get the starting index number
                    int currentIndex = dialog.Controls.AddedSnapinsList.Items[snapIn.Path].Index +1 ;

                    // get the first item to evaluate
                    ListViewItem currentItem = dialog.Controls.AddedSnapinsList.Items[currentIndex];

                    // as long as we don't drop down to the level of the parent and have more items, keep looking
                    while ((currentItem.Indentation >= indentLevel) && (currentIndex < dialog.Controls.AddedSnapinsList.Items.Count))
                    {
                        // evaluate the next item
                        currentIndex++;                        
                        currentItem = dialog.Controls.AddedSnapinsList.Items[currentIndex];

                        // if it is on the same level, count it so we know how many items are siblings
                        if (currentItem.Indentation == indentLevel)
                        {
                            indentLevelItems++;
                        }
                    }

                    // Move the item up if it is too far down
                    if (indentLevelItems < snapIn.Position)
                        for (int i = indentLevelItems; i < snapIn.Position; i++)
                        {
                            dialog.ClickMoveUp();
                        }

                    // Move the item down if it is too far up
                    if (indentLevelItems > snapIn.Position)
                        for (int i = snapIn.Position; i < indentLevelItems; i++)
                        {
                            dialog.ClickMoveDown();
                        }
                }
            }

            // close the add or remove snapins dialog and wait for app to load everything
            dialog.ClickOK();
        }

        /// <summary>
        ///		Adds particular snap-in to the application.
        /// </summary>
        /// <param name="snapIn">Snap-in to add.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///     [faisalb]   3/22/2005   Added WaitFor methods. MMC is now block the UI after adding SnapIn and waits for SnapIn to complete.
        /// </history>
        private void AddStandaloneSnapin(Snapin snapIn)
        {
            int timeout = 5000;
            int IdleTime = 500;
            // Open the Add Standalone Snapin Dialog
            AddStandaloneSnapinDialog stdDialog = new AddStandaloneSnapinDialog(this);
            stdDialog.Snapin = snapIn.Name;

            stdDialog.ClickAdd();
            if (snapIn.WizardHandler != null)
            {
                // handle snap-in Wizard, if handler is provided
                snapIn.WizardHandler(this, snapIn, new SnapinWizard(this, stdDialog));
            }
            this.Process.WaitForIdle(IdleTime, timeout);
            UISynchronization.WaitForUIObjectReady(stdDialog, timeout);
            stdDialog.ClickClose();
        }

        /// <summary>
        /// Removes specified snap-in.
        /// </summary>
        /// <param name="snapIn">Snap-in to remove.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void RemoveSnapin(Snapin snapIn)
        {
            RemoveSnapins(new Snapin[] { snapIn });
        }

        //BUGBUG - Add an overload for Remove that removes a specific instance.

        /// <summary>
        /// Removes specified snap-ins.
        /// </summary>
        /// <param name="snapIns">Snap-ins to remove.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///             [michsny]   12/28/2004  Added handling for new dialog and path in old dialog
        /// </history>
        public void RemoveSnapins(Snapin[] snapIns)
        {
            Boolean usingNewUI = AddRemoveIsUsingNewUI();

            if (usingNewUI == false)
            {
                // launch the MMC 2.0 add/remove dialog
                AddRemoveSnapinDialog dialog = new AddRemoveSnapinDialog(this);

                // remove snap-ins one-by-one
                foreach (Snapin snapIn in snapIns)
                {
                    // check if snap-in name is resource ID - then convert it
                    if (snapIn.Name.StartsWith(";"))
                        snapIn.Name = GetIntlStr(snapIn.Name);

                    // select the path
                    if (snapIn.Path != null)
                        dialog.SetPath(snapIn.Path);                    

                    // select the snap-in                    
                    dialog.Controls.AddedSnapinsListView.Items[snapIn.Name].Select();

                    // remove the snap-in
                    dialog.ClickRemove();
                }

                // close the dialog and wait for app to load everything
                dialog.ClickOK();
            }
            else
            {
                // remove the snap-ins using the new add/remove dialog
                // launch the MMC 2.1 add/remove dialog
                AddOrRemoveSnapInsDialog dialog = new AddOrRemoveSnapInsDialog(this);

                // remove snap-ins one-by-one
                foreach (Snapin snapIn in snapIns)
                {
                    // check if snap-in name is resource ID - then convert it
                    if (snapIn.Name.StartsWith(";"))
                        snapIn.Name = GetIntlStr(snapIn.Name);

                    // select the snap-in in the added list
                    dialog.SelectAddedSnapIn(snapIn);      
              
                    // remove it
                    dialog.ClickRemove();
                }

                // close the dialog and wait for app to load everything
                dialog.ClickOK();
            }
        }

        private Boolean AddRemoveIsUsingNewUI()
        {
            const int osVersionLonghorn = 6;
            const string useNewUIRegKey = "Software\\Microsoft\\MMC\\UseNewUI";

            Boolean usingNewUI = false;
            int osVersion = System.Environment.OSVersion.Version.Major;

            if (osVersion == osVersionLonghorn)
            {
                usingNewUI = true;
            }
            else
            {
                try
                {                    
                    if (Microsoft.Win32.Registry.LocalMachine.OpenSubKey(useNewUIRegKey, false) != null)
                        usingNewUI = true;
                }
                catch (Registry.Exceptions.RegistryKeyNotFoundException)
                {                    
                }
            }
            return usingNewUI;
        }
        #endregion

        #region File menu commands
        /// <summary>
        ///		Handles Save alert.
        /// </summary>
        /// <param name="alertAction">How to handle the alert.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private void HandleSaveAlert(AlertAction alertAction)
        {
            Alert alert = null;
            try
            {
                string text = GetIntlStr(Strings.SaveAlertText);
                text = text.Replace("%1", MainWindow.Caption);
                alert = Alert.HandleAlert(text, alertAction, this.MainWindow, 2000);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                return;
            }
            catch (Window.Exceptions.InvalidHWndException)
            {
                return;
            }
            if (alert == null)
                return;
            else if (alertAction != AlertAction.NoAction)
                alert.PerformAlertAction(alertAction);
            else
                throw new GlobalExceptions.MauiException("There is unhandled Save alert dialog.");
        }

        /// <summary>
        ///		Creates new console.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NewConsole()
        {
            NewConsole(AlertAction.ClickNo, CommandMethod.Default);
        }

        /// <summary>
        ///		Creates new console.
        /// </summary>
        /// <param name="handleSaveAlert">How to handle Save alert dialog if any.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NewConsole(AlertAction handleSaveAlert)
        {
            NewConsole(handleSaveAlert, CommandMethod.Default);
        }

        /// <summary>
        ///		Creates new console.
        /// </summary>
        /// <param name="handleSaveAlert">How to handle Save alert dialog if any.</param>
        /// <param name="method">Method to invoke the command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NewConsole(AlertAction handleSaveAlert, CommandMethod method)
        {
            Commands.FileNew.Execute(this, method);
            HandleSaveAlert(handleSaveAlert);

            UISynchronization.WaitForUIObjectReady(MainWindow);
            MainWindow.WaitForResponse();
        }

        /// <summary>
        /// Opens console given the file name.
        /// </summary>
        /// <param name="fileName">Console file name.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void OpenConsole(string fileName)
        {
            OpenConsole(fileName, AlertAction.ClickNo, CommandMethod.Default);
        }

        /// <summary>
        ///		Opens console given the file name.
        /// </summary>
        /// <param name="fileName">Console to open.</param>
        /// <param name="saveAlertAction">How to handle save alert if any.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void OpenConsole(string fileName, AlertAction saveAlertAction)
        {
            OpenConsole(fileName, saveAlertAction, CommandMethod.Default);
        }

        /// <summary>
        ///		Opens console given the file name.
        /// </summary>
        /// <param name="fileName">Console to open.</param>
        /// <param name="saveAlertAction">How to handle save alert if any.</param>
        /// <param name="method">Command method to invoke command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void OpenConsole(string fileName, AlertAction saveAlertAction, CommandMethod method)
        {
            Commands.FileOpen.Execute(this, method);
            HandleSaveAlert(saveAlertAction);

            // HACK: use the actual Open dialog when it's implemented in Maui.Windows
            Window wnd = new Window("Open", StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, this, 3000);
            new TextBox(wnd, 0x47C).Text = fileName;
            new Button(wnd, "Open*", StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch).Click();
            wnd.WaitForInvalid();
            // END HACK

            HandleSaveAlert(saveAlertAction);

            UISynchronization.WaitForUIObjectReady(MainWindow);
            MainWindow.WaitForResponse();
        }

        ///-----------------------------------------------------------------------------
        /// <summary>
        /// Send an ALT+F4 and wait for process to go away
        /// </summary>
        /// <returns>If an alert appears, we'll return an intialized Alert object</returns>
        /// <remarks>Any more involved functionality should be overridden in inherited classes</remarks>
        /// <history>
        ///		[yiqingdu]   906/17/2004    Converted old Quit method of App.vb to C# from VB.
        /// </history>
        ///-----------------------------------------------------------------------------
        private Alert QuitStart()
        {
            Sleeper quitSleeper = new Sleeper(Strings.QuitTimeout);
            Alert objAlert = null;
            try
            {
                this.SendKeys("%{F4}");
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                // We expect this exception since we've shut it down
            }


            while ((objAlert == null) && (quitSleeper.IsNotExpired) && this.IsRunning)
            {
                try
                {
                    objAlert = Alert.HandleAlert("", AlertAction.NoAction, this.MainWindow, 200);
                }
                catch (Window.Exceptions.WindowNotFoundException)
                {
                    // We expect this exception since we've shut it down
                }
                catch (Window.Exceptions.InvalidHWndException)
                {
                    // We expect this exception since we've shut it down
                }

                quitSleeper.Sleep();
            }

            if (objAlert != null)
                return objAlert;

            if (this.IsRunning)
                throw new Exceptions.CantQuitAppException("Closing app timed out. Consider using KillProcess instead of Quit.");

            return null;
        }

        /// <summary>
        ///		Quites the MMC application.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///		[yiqingdu]	6/17/2004	Modified to use QuitStart.
        /// </history>
        public override void Quit()
        {
            Alert alert = QuitStart();
            if (alert != null)
                alert.PerformAlertAction(AlertAction.ClickNo);

            Sleeper sleeper = new Sleeper(Strings.QuitTimeout);
            while (this.IsRunning && sleeper.IsNotExpired)
            {
                sleeper.Sleep();
            }

            if (this.IsRunning)
                throw new Exceptions.CantQuitAppException("Closing app timed out. Consider using KillProcess instead of Quit.");
        }

        /// <summary>
        ///		Quites the MMC application.
        /// </summary>
        /// <param name="saveAlertAction">How to handle Save alert if any.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Quit(AlertAction saveAlertAction)
        {
            Quit(saveAlertAction, CommandMethod.MainMenu);
        }

        /// <summary>
        ///		Quites the MMC application.
        /// </summary>
        /// <param name="saveAlertAction">How to handle Save alert if any.</param>
        /// <param name="method">How to invoke Quit command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Quit(AlertAction saveAlertAction, CommandMethod method)
        {
            Commands.FileExit.Execute(this, method);
            Sleeper quitSleeper = new Sleeper(10000);

            while (quitSleeper.IsNotExpired && IsRunning)
                HandleSaveAlert(saveAlertAction);

            if (IsRunning)
                throw new App.Exceptions.CantQuitAppException("Closing app timed out. Consider using KillProcess instead of Quit.");
        }
        #endregion

        #region Window menu commands
        /// <summary>
        ///		Layouts console windows in cascade.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Cascade()
        {
            Commands.WindowCascade.Execute(this);
        }

        /// <summary>
        ///		Tiles console windows horizontally.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void TileHorizontally()
        {
            Commands.WindowTileHorizontally.Execute(this);
        }

        /// <summary>
        ///		Arranges console window icons in the MDI container.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void ArrangeIcons()
        {
            Commands.WindowArrangeIcons.Execute(this);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\AddStandaloneSnapInDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{    
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	#region IAddStandaloneSnapinDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddStandaloneSnapinDialogControls
    {
        ListView AvailableStandaloneSnapinsListView  {get;}
        Button AddButton  {get;}
        Button CloseButton  {get;}
        TextBox DescriptionTextBox  {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: AddStandaloneSnapinDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Add Stand-alone snap-in dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 6/16/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddStandaloneSnapinDialog : Dialog, IAddStandaloneSnapinDialogControls
    {
		#region Constants
		private const string DialogTitle = ";Add Standalone Snap-in;Win32DialogString;mmcndmgr.dll;159";
        
        private class ControlIDs
        {
            public const int AvailableStandaloneSnapinsListView = 1049;
            public const int AddButton = 1;
            public const int CloseButton = 2;
            public const int DescriptionTextBox = 0xFA7;
        }
		#endregion

		#region Member Variables
        private ListView m_cachedAvailableStandaloneSnapinsListView;
        private Button m_cachedAddButton;
        private Button m_cachedCloseButton;
        private TextBox m_cachedDescriptionTextBox;
		#endregion

		#region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddStandaloneSnapinDialog(MmcApp app) : base(app, Init(app))
        {
			UISynchronization.WaitForUIObjectReady(this);
        }
      
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app)
        {
            return new Window(app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
				WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
        }
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddStandaloneSnapinDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to get the text in control DescriptionTextBox
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string Description
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
        }

		/// <summary>
		///		Gets or sets Snap-in selected in the list-view.
		/// </summary>
		public string Snapin
		{
			get
			{
				return Controls.AvailableStandaloneSnapinsListView.SelectedItem.Text;
			}
			set
			{
				Controls.AvailableStandaloneSnapinsListView.Items[value].Select();
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AvailableStandaloneSnapinsListView control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddStandaloneSnapinDialogControls.AvailableStandaloneSnapinsListView
        {
            get
            {
                if ((m_cachedAvailableStandaloneSnapinsListView == null))
                {
                    m_cachedAvailableStandaloneSnapinsListView = new ListView(this, ControlIDs.AvailableStandaloneSnapinsListView);
                }
                return m_cachedAvailableStandaloneSnapinsListView;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddStandaloneSnapinDialogControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CloseButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddStandaloneSnapinDialogControls.CloseButton
        {
            get
            {
                if ((m_cachedCloseButton == null))
                {
                    m_cachedCloseButton = new Button(this, ControlIDs.CloseButton);
                }
                return m_cachedCloseButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddStandaloneSnapinDialogControls.DescriptionTextBox
        {
            get
            {
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Close
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickClose()
        {
            Controls.CloseButton.Click();
        }
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\CustomizeViewDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region ICustomizeViewDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ICustomizeViewDialogControls
    {
        CheckBox ConsoleTreeCheckBox { get;}
        CheckBox StandardMenusCheckBox { get;}
        CheckBox StandardToolbarCheckBox { get;}
        CheckBox StatusbarCheckBox { get;}
        CheckBox DescriptionBarCheckBox { get;}
        CheckBox TaskPadNavigationTabsCheckBox { get;}
        CheckBox SnapinMenusCheckBox { get;}
        CheckBox SnapinToolbarsCheckBox { get;}
        CheckBox ActionsPaneCheckBox { get;}
        Button OKButton { get;}
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: CustomizeViewDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Customize View dialog for MMC.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 5/10/2003 Created
    /// 	[faisalb] 10/28/2003 Added Actions Pane Options
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class CustomizeViewDialog : Dialog, ICustomizeViewDialogControls
    {
        #region Constants, member variables
        private const string DialogTitle = ";Customize View;Win32DialogString;mmcndmgr.dll;1086";

        private class ControlIDs
        {
            public const int ConsoleTreeCheckBox = 4143;
            public const int StandardMenusCheckBox = 4144;
            public const int StandardToolbarCheckBox = 4139;
            public const int StatusbarCheckBox = 4141;
            public const int DescriptionBarCheckBox = 4142;
            public const int TaskPadNavigationTabsCheckBox = 4145;
            public const int SnapinMenusCheckBox = 4138;
            public const int SnapinToolbarsCheckBox = 4140;
            public const int ActionsPaneCheckBox = 4172;
            public const int OKButton = 1;
        }

        private CheckBox m_cachedConsoleTreeCheckBox;
        private CheckBox m_cachedStandardMenusCheckBox;
        private CheckBox m_cachedStandardToolbarCheckBox;
        private CheckBox m_cachedStatusbarCheckBox;
        private CheckBox m_cachedDescriptionBarCheckBox;
        private CheckBox m_cachedTaskPadNavigationTabsCheckBox;
        private CheckBox m_cachedActionsPaneCheckBox;
        private CheckBox m_cachedSnapinMenusCheckBox;
        private CheckBox m_cachedSnapinToolbarsCheckBox;
        private Button m_cachedOKButton;
        #endregion

        #region Constructor and Init function
        ///  <summary>
        ///  Constructor.
        ///  </summary>
        ///  <param name="app">MMC application object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public CustomizeViewDialog(MmcApp app) : 
                base(app, Init(app, CommandMethod.Default))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor.
        ///  </summary>
        ///  <param name="app">MMC application object owning the dialog.</param>
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public CustomizeViewDialog(MmcApp app, CommandMethod method) : 
			base(app, Init(app, method))
        {
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Find to brings up Customize View dialog.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="method">How to invoke the command.</param>
        /// <returns>Dialog window.</returns>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            Window tempWindow;
            try
            {
                UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(
                    app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
                    WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
                    app, 200);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                Commands.ViewCustomize.Execute(app, method);
                tempWindow = new Window(
                    app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
                    WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
                    app, 2000);
            }
            return tempWindow;
        }
        #endregion

        #region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ICustomizeViewDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the ConsoleTreeCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.ConsoleTreeCheckBox
        {
            get
            {
                if ((m_cachedConsoleTreeCheckBox == null))
                {
                    m_cachedConsoleTreeCheckBox = new CheckBox(this, ControlIDs.ConsoleTreeCheckBox);
                }
                return m_cachedConsoleTreeCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the StandardMenusCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.StandardMenusCheckBox
        {
            get
            {
                if ((m_cachedStandardMenusCheckBox == null))
                {
                    m_cachedStandardMenusCheckBox = new CheckBox(this, ControlIDs.StandardMenusCheckBox);
                }
                return m_cachedStandardMenusCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the StandardToolbarCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.StandardToolbarCheckBox
        {
            get
            {
                if ((m_cachedStandardToolbarCheckBox == null))
                {
                    m_cachedStandardToolbarCheckBox = new CheckBox(this, ControlIDs.StandardToolbarCheckBox);
                }
                return m_cachedStandardToolbarCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the StatusbarCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.StatusbarCheckBox
        {
            get
            {
                if ((m_cachedStatusbarCheckBox == null))
                {
                    m_cachedStatusbarCheckBox = new CheckBox(this, ControlIDs.StatusbarCheckBox);
                }
                return m_cachedStatusbarCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the DescriptionBarCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.DescriptionBarCheckBox
        {
            get
            {
                if ((m_cachedDescriptionBarCheckBox == null))
                {
                    m_cachedDescriptionBarCheckBox = new CheckBox(this, ControlIDs.DescriptionBarCheckBox);
                }
                return m_cachedDescriptionBarCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the TaskPadNavigationTabsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.TaskPadNavigationTabsCheckBox
        {
            get
            {
                if ((m_cachedTaskPadNavigationTabsCheckBox == null))
                {
                    m_cachedTaskPadNavigationTabsCheckBox = new CheckBox(this, ControlIDs.TaskPadNavigationTabsCheckBox);
                }
                return m_cachedTaskPadNavigationTabsCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the SnapinMenusCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.SnapinMenusCheckBox
        {
            get
            {
                if ((m_cachedSnapinMenusCheckBox == null))
                {
                    m_cachedSnapinMenusCheckBox = new CheckBox(this, ControlIDs.SnapinMenusCheckBox);
                }
                return m_cachedSnapinMenusCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the ActionsPaneCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[faisalb] 10/28/2004 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.ActionsPaneCheckBox
        {
            get
            {
                if ((m_cachedActionsPaneCheckBox == null))
                {
                    m_cachedActionsPaneCheckBox = new CheckBox(this, ControlIDs.ActionsPaneCheckBox);
                }
                return m_cachedActionsPaneCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the SnapinToolbarsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ICustomizeViewDialogControls.SnapinToolbarsCheckBox
        {
            get
            {
                if ((m_cachedSnapinToolbarsCheckBox == null))
                {
                    m_cachedSnapinToolbarsCheckBox = new CheckBox(this, ControlIDs.SnapinToolbarsCheckBox);
                }
                return m_cachedSnapinToolbarsCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ICustomizeViewDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        #endregion

        #region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
            WaitForInvalid();
            UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\AddRemoveSnapInDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region IAddRemoveSnapinDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddRemoveSnapinDialogControls
    {
        EditComboBox AddToComboBox { get;}
        ListView AddedSnapinsListView { get;}
        TextBox DescriptionTextBox { get;}
        Button AddButton { get;}
        Button RemoveButton { get;}
        Button AboutButton { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
        CheckBox AddAllExtensionsCheckBox { get;}
        EditComboBox SnapinToExtendComboBox { get;}
        ListView AvailableExtensionsListView { get;}
        Button ExtensionAboutButton { get;}
        Button DownloadButton { get;}
        TextBox ExtensionDescriptionTextBox { get;}
        TabControl TabControl { get;}
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: AddRemoveSnapinDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Main Add/Remove Snap-in Dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 5/11/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddRemoveSnapinDialog : Dialog, IAddRemoveSnapinDialogControls
    {
        #region Constants
        private class Strings
        {
            public const string DialogTitle = ";Add/Remove Snap-in;Win32String;mmcbase.dll;14029";
        }

        private class ControlIDs
        {
            public const int AddToComboBox = 4018;
            public const int AddedSnapinsListView = 4011;
            public const int DescriptionTextBox = 0xFA7;
            public const int AddButton = 4008;
            public const int RemoveButton = 4009;
            public const int AboutButton = 4014;
            public const int OKButton = 1;
            public const int CancelButton = 2;
            public const int SnapinToExtendComboBox = 4018;
            public const int AddAllExtensionsCheckBox = 4025;
            public const int AvailableExtensionsListView = 4020;
            public const int ExtensionAboutButton = 4014;
            public const int ExtensionDescriptionTextBox = 0xFA7;
            public const int DownloadButton = 4026;
            public const int TabControl = 0x3020;
        }
        #endregion

        #region Member Variables
        private EditComboBox m_cachedAddToComboBox;
        private ListView m_cachedAddedSnapinsListView;
        private TextBox m_cachedDescriptionTextBox;
        private Button m_cachedAddButton;
        private Button m_cachedRemoveButton;
        private Button m_cachedAboutButton;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private EditComboBox m_cachedSnapinToExtendComboBox;
        private CheckBox m_cachedAddAllExtensionsCheckBox;
        private ListView m_cachedAvailableExtensionsListView;
        private Button m_cachedExtensionAboutButton;
        private TextBox m_cachedExtensionDescriptionTextBox;
        private Button m_cachedDownloadButton;
        private TabControl m_cachedTabControl;
        #endregion

        #region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddRemoveSnapinDialog(MmcApp app) : base(app, Init(app, CommandMethod.Default))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddRemoveSnapinDialog(MmcApp app, CommandMethod method) : base(app, Init(app, method))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            Window tempWindow;
            // First check if the dialog is already up.
            try
            {
                UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 200);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                // The line below is throwing an exception...it is clicking at 0,0 instead of on the menu
                // Dmitry is investigating.
                // Commands.FileAddRemoveSnapIn.Execute(app, method);
                //BUGBUG this is a temporary workaround to the problem above                
                app.SendKeys("^m");
                Maui.TestLog.LogManager.LogHack("Init", "Hardcoded sendkeys method of opening the dialog is not localizable: Fail this after 4/1/05");
                
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            }
            return tempWindow;
        }
        #endregion

        #region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddRemoveSnapinDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to get the text in control DescriptionTextBox
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string SnapinDescription
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Returns extension description text-box's text.
        /// </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ExtensionDescription
        {
            get
            {
                return Controls.ExtensionDescriptionTextBox.Text;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Gets or sets whether to add all extensions.
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool AddAllExtensions
        {
            get
            {
                return Controls.AddAllExtensionsCheckBox.Checked;
            }
            set
            {
                Controls.AddAllExtensionsCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Gets or sets snap-in to be extended.
        /// </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string SnapinToExtend
        {
            get
            {
                return Controls.SnapinToExtendComboBox.Text;
            }
            set
            {
                Controls.SnapinToExtendComboBox.SelectByText(value);
            }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Gets list of all available extensions for the current snap-in.
        /// </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string[] Extensions
        {
            get
            {
                return Controls.AvailableExtensionsListView.EnumerateItems(";", 0).Split(';');
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddToComboBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAddRemoveSnapinDialogControls.AddToComboBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAddToComboBox == null))
                {
                    m_cachedAddToComboBox = new EditComboBox(this, ControlIDs.AddToComboBox);
                }
                return m_cachedAddToComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddedSnapinsListView control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddRemoveSnapinDialogControls.AddedSnapinsListView
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAddedSnapinsListView == null))
                {
                    m_cachedAddedSnapinsListView = new ListView(this, ControlIDs.AddedSnapinsListView);
                }
                return m_cachedAddedSnapinsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddRemoveSnapinDialogControls.DescriptionTextBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.AddButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RemoveButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.RemoveButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AboutButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.AboutButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAboutButton == null))
                {
                    m_cachedAboutButton = new Button(this, ControlIDs.AboutButton);
                }
                return m_cachedAboutButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SnapinToExtendComboBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAddRemoveSnapinDialogControls.SnapinToExtendComboBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedSnapinToExtendComboBox == null))
                {
                    m_cachedSnapinToExtendComboBox = new EditComboBox(this, ControlIDs.SnapinToExtendComboBox);
                }
                return m_cachedSnapinToExtendComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the AddAllExtensionsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IAddRemoveSnapinDialogControls.AddAllExtensionsCheckBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedAddAllExtensionsCheckBox == null))
                {
                    m_cachedAddAllExtensionsCheckBox = new CheckBox(this, ControlIDs.AddAllExtensionsCheckBox);
                }
                return m_cachedAddAllExtensionsCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AvailableExtensionsListBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddRemoveSnapinDialogControls.AvailableExtensionsListView
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedAvailableExtensionsListView == null))
                {
                    m_cachedAvailableExtensionsListView = new ListView(this, ControlIDs.AvailableExtensionsListView);
                }
                return m_cachedAvailableExtensionsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExtensionAboutButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.ExtensionAboutButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedExtensionAboutButton == null))
                {
                    m_cachedExtensionAboutButton = new Button(this, ControlIDs.ExtensionAboutButton);
                }
                return m_cachedExtensionAboutButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExtensionDescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddRemoveSnapinDialogControls.ExtensionDescriptionTextBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedExtensionDescriptionTextBox == null))
                {
                    m_cachedExtensionDescriptionTextBox = new TextBox(this, ControlIDs.ExtensionDescriptionTextBox);
                }
                return m_cachedExtensionDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DownloadButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.DownloadButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedDownloadButton == null))
                {
                    m_cachedDownloadButton = new Button(this, ControlIDs.DownloadButton);
                }
                return m_cachedDownloadButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TabControl control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IAddRemoveSnapinDialogControls.TabControl
        {
            get
            {
                if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }

        #endregion

        #region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Remove
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickRemove()
        {
            Controls.RemoveButton.Click();
            UISynchronization.WaitForUIObjectReady(this);
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button About
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAbout()
        {
            Controls.AboutButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button About
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickExtensionAbout()
        {
            Controls.ExtensionAboutButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Download
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickDownload()
        {
            Controls.DownloadButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv]	5/11/2003	Created
        /// 	[dmitriv]	12/29/2004	Added timeout argument
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            this.ClickOK(3000);
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv]	5/11/2003	Created
        /// 	[dmitriv]	12/29/2004	Added timeout argument
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK(int timeout)
        {
            Controls.OKButton.Click();
            WaitForInvalid(timeout);
            UISynchronization.WaitForUIObjectReady(App.MainWindow);
            App.MainWindow.WaitForResponse();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        /// Sets whether particular extension is enabled or disabled.
        /// </summary>
        /// <param name="extensionName">Extension to enable.</param>
        /// <param name="enabled">Whether extension should be enabled</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void SetExtensionState(string extensionName, bool enabled)
        {
            Controls.AvailableExtensionsListView[extensionName].Checked = enabled;
        }

        /// <summary>
        /// Set the Parent snap-in path
        /// </summary>
        /// <param name="path">Snap-in to select as parent</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SetPath(string path)
        {
            Controls.AddToComboBox.SelectByText(path);
        }
        
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\PropertiesDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{    
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	#region IPropertiesDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IPropertiesDialogControls
    {
        Button OKButton  {get;}
        Button CancelButton  {get;}
        Button ApplyButton  {get;}
        Button HelpButton  {get;}
        TabControl TabControl {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: PropertiesDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Property Pages Dialog for MMC.
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[dmitriv] 6/16/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class PropertiesDialog : Dialog, IPropertiesDialogControls
    {
		#region Control IDs
        public class ControlIDs
        {
            public const int OKButton = 1;
            public const int CancelButton = 2;
            public const int ApplyButton = 12321;
            public const int HelpButton = 9;
            public const int TabControl = 0x3020;
        }
		#endregion

		#region Member Variables
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private Button m_cachedApplyButton;
        private Button m_cachedHelpButton;
        private TabControl m_cachedTabControl;
		#endregion

		#region Constructor and Init function
		/// -----------------------------------------------------------------------------
		///	 <summary>
		///  Constructor to create dialog.
		///  </summary>
		///  <param name="app">MmcApp object owning the dialog.</param>
		///  <history>
		/// 	[dmitriv] 6/16/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public PropertiesDialog(MmcApp app) : base(app, Init(app, null))
		{			
		}

        /// -----------------------------------------------------------------------------
        ///	 <summary>
        ///  Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public PropertiesDialog(MmcApp app, Window previousWindow) : base(app, Init(app, previousWindow))
        {			
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="app">MmcApp object owning the dialog.</param>
        /// <param name="previousWindow">Main window</param>
        /// <param name="className">expected window class type</param>
        /// <param name="classNameMatchSyntax">expected window class type match string syntax</param>
        ///  <history>
        /// 	[carolli] 11/23/2004 Created
        ///  </history> 
        public PropertiesDialog(MmcApp app, Window previousWindow, string className, StringMatchSyntax classNameMatchSyntax) : base(app, Init(app, previousWindow, className, classNameMatchSyntax))
        {			
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        /// 	[carolli] 11/23/2004 updated.
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, Window previousWindow)
        {
			return Init (app, previousWindow, WindowClassNames.Alert, StringMatchSyntax.WildCard);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        /// 	[carolli] 11/23/2004 Add new parameter className and classNameMatchSyntax for allowing users to specify the expected dialog.
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, Window previousWindow, string className, StringMatchSyntax classNameMatchSyntax)
        {
			if (previousWindow == null)
			{
				previousWindow = new Window(WindowType.Foreground);
				new Menu(ContextMenuAccessMethod.ShiftF10)["Properties"].Execute();
			}
			
			Sleeper sleeper = new Sleeper(3000);
			while (sleeper.IsNotExpired)
			{				
				WindowCollection windows = new WindowCollection(
					"*", StringMatchSyntax.WildCard,
					className, classNameMatchSyntax, 
					app
					);
				foreach (Window wnd in windows)
					if (!wnd.Extended.HWnd.Equals(previousWindow.Extended.HWnd) &&
						wnd.Extended.IsForeground)
					{
						return wnd;
					}
                sleeper.Sleep();
			}
			throw new Window.Exceptions.WindowNotFoundException("Unable to find new MMC Property Pages dialog.");
		}
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IPropertiesDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplyButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.ApplyButton
        {
            get
            {
                if ((m_cachedApplyButton == null))
                {
                    m_cachedApplyButton = new Button(this, ControlIDs.ApplyButton);
                }
                return m_cachedApplyButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the HelpButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPropertiesDialogControls.HelpButton
        {
            get
            {
                if ((m_cachedHelpButton == null))
                {
                    m_cachedHelpButton = new Button(this, ControlIDs.HelpButton);
                }
                return m_cachedHelpButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Tab0TabControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IPropertiesDialogControls.TabControl
        {
            get
            {
                if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
			WaitForInvalid();
			UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Apply
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickApply()
        {
            Controls.ApplyButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Help
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickHelp()
        {
            Controls.HelpButton.Click();
        }
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\SnapInWizard.cs ===
namespace Maui.ManagementConsole.Dialogs
{    
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	#region ISnapinWizardControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISnapinWizardControls
    {
        RadioButton LocalComputerRadioButton  {get;}
        RadioButton AnotherComputerRadioButton  {get;}
        TextBox ComputerNameTextBox  {get;}
        Button BrowseButton  {get;}
        CheckBox AllowComputerChangeFromCommandLineCheckBox {get;}
        TabControl TabControl  {get;}
        Button BackButton  {get;}
		Button NextButton {get;}
        Button FinishButton  {get;}
        Button CancelButton  {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: SnapinWizard
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Snap-in Add Wizard.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 6/16/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SnapinWizard : Dialog, ISnapinWizardControls
    {
		#region Constants
        private class ControlIDs
        {
            public const int LocalComputerRadioButton = 972;
            public const int AnotherComputerRadioButton = 973;
            public const int ComputerNameTextBox = 0x3CE;
            public const int BrowseButton = 975;
            public const int AllowComputerChangeFromCommandLineCheckBox = 976;
            public const int TabControl = 0x3020;
			public const int NextButton = 12324;
            public const int BackButton = 12323;
            public const int FinishButton = 12325;
            public const int CancelButton = 2;
        }
		#endregion

		#region Member Variables
        private RadioButton m_cachedLocalComputerRadioButton;
        private RadioButton m_cachedAnotherComputerRadioButton;
        private TextBox m_cachedComputerNameTextBox;
        private Button m_cachedBrowseButton;
        private CheckBox m_cachedAllowComputerChangeFromCommandLineCheckBox;
        private TabControl m_cachedTabControl;
        private Button m_cachedBackButton;
		private Button m_cachedNextButton;
        private Button m_cachedFinishButton;
        private Button m_cachedCancelButton;
		#endregion

		#region Constructor
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SnapinWizard(MmcApp app, Window previousWindow) : base(app, Init(app, previousWindow))
        {
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
		///  <param name="previousWindow">Window which was in foreground before this window was opened.</param>
		///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, Window previousWindow)
        {
			Sleeper sleeper = new Sleeper(3000);
			while (sleeper.IsNotExpired)
			{
				WindowCollection windows = new WindowCollection(
					"*", StringMatchSyntax.WildCard, WindowClassNames.Alert,
					StringMatchSyntax.ExactMatch, app);
				foreach (Window wnd in windows)
					if (!wnd.Extended.HWnd.Equals(previousWindow.Extended.HWnd) &&
						wnd.Extended.IsForeground)
					{
						return wnd;
					}
				sleeper.Sleep();
			}
			throw new Window.Exceptions.WindowNotFoundException("Unable to find Snap-in Add Wizard.");
        }
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISnapinWizardControls Controls
        {
            get
            {
                return this;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Name of computer to be used. Null if current computer radio button is checked.
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ComputerName
        {
            get
            {
				if (Controls.LocalComputerRadioButton.ButtonState == ButtonState.Checked)
					return null;
				else
					return Controls.ComputerNameTextBox.Text;
            }
            set
            {
				if (value == null)
				{
					ClickLocalComputer();
				}
				else
				{
					ClickAnotherComputer();
					Controls.ComputerNameTextBox.Text = value;
				}
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocalComputerRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISnapinWizardControls.LocalComputerRadioButton
        {
            get
            {
                if ((m_cachedLocalComputerRadioButton == null))
                {
                    m_cachedLocalComputerRadioButton = new RadioButton(this, ControlIDs.LocalComputerRadioButton);
                }
                return m_cachedLocalComputerRadioButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AnotherComputerRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISnapinWizardControls.AnotherComputerRadioButton
        {
            get
            {
                if ((m_cachedAnotherComputerRadioButton == null))
                {
                    m_cachedAnotherComputerRadioButton = new RadioButton(this, ControlIDs.AnotherComputerRadioButton);
                }
                return m_cachedAnotherComputerRadioButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ComputerNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISnapinWizardControls.ComputerNameTextBox
        {
            get
            {
                if ((m_cachedComputerNameTextBox == null))
                {
                    m_cachedComputerNameTextBox = new TextBox(this, ControlIDs.ComputerNameTextBox);
                }
                return m_cachedComputerNameTextBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BrowseButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.BrowseButton
        {
            get
            {
                if ((m_cachedBrowseButton == null))
                {
                    m_cachedBrowseButton = new Button(this, ControlIDs.BrowseButton);
                }
                return m_cachedBrowseButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AllowComputerChangeFromCommandLineCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ISnapinWizardControls.AllowComputerChangeFromCommandLineCheckBox
        {
            get
            {
                if ((m_cachedAllowComputerChangeFromCommandLineCheckBox == null))
                {
                    m_cachedAllowComputerChangeFromCommandLineCheckBox = new CheckBox(this, ControlIDs.AllowComputerChangeFromCommandLineCheckBox);
                }
                return m_cachedAllowComputerChangeFromCommandLineCheckBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TabControl control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl ISnapinWizardControls.TabControl
        {
            get
            {
                if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BackButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.BackButton
        {
            get
            {
                if ((m_cachedBackButton == null))
                {
                    m_cachedBackButton = new Button(this, ControlIDs.BackButton);
                }
                return m_cachedBackButton;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the NextButton control
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/16/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button ISnapinWizardControls.NextButton
		{
			get
			{
				if ((m_cachedNextButton == null))
				{
					m_cachedNextButton = new Button(this, ControlIDs.NextButton);
				}
				return m_cachedNextButton;
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FinishButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.FinishButton
        {
            get
            {
                if ((m_cachedFinishButton == null))
                {
                    m_cachedFinishButton = new Button(this, ControlIDs.FinishButton);
                }
                return m_cachedFinishButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISnapinWizardControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button LocalComputer
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickLocalComputer()
        {
            Controls.LocalComputerRadioButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button AnotherComputer
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAnotherComputer()
        {
            Controls.AnotherComputerRadioButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Browse
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickBrowse()
        {
            Controls.BrowseButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button AllowComputerChangeFromCommandLine
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAllowComputerChangeFromCommandLine()
        {
            Controls.AllowComputerChangeFromCommandLineCheckBox.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Back
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickBack()
        {
            Controls.BackButton.Click();
			WaitForResponse();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to click on button Next
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/16/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickNext()
		{
			Controls.NextButton.Click();
			WaitForResponse();
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Finish
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickFinish()
        {
            Controls.FinishButton.Click();
			WaitForInvalid();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
        }
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\OptionsDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{
	using System;
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;

	/// <summary>
	///		Console Mode to be used with this dialog.
	/// </summary>
	public enum ConsoleAccessMode
	{
		AuthorMode,
		UserModeFullAccess,
		UserModeLimitedAccessMultipleWindows,
		UserModeLimitedAccessSingleWindow
	}

	#region IOptionsDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IOptionsDialogControls
    {
        TextBox ConsoleNameTextBox  {get;}
        Button ChangeIconButton  {get;}
        EditComboBox ConsoleAccessModeEditComboBox  {get;}
        CheckBox SaveChangedCheckBox  {get;}
        CheckBox AllowCustomizeViewsCheckBox  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
        Button ApplyButton  {get;}
		Button DeleteFilesButton  {get;}
		TabControl TabControl {get;}
    }
	#endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: OptionsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Console Options dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 6/15/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class OptionsDialog : Dialog, IOptionsDialogControls
    {
		#region Constants
		private class Strings
		{
			public const string DialogTitle = ";Options;Win32String;mmcbase.dll;13343";
			public const string AuthorMode = ";Author mode;Win32String;mmcbase.dll;13313";
			public const string UserModeFullAccess = ";User mode - full access;Win32String;mmcbase.dll;13314";
			public const string UserModeLimitedAccessMultipleWindows = ";User mode - limited access, multiple window;Win32String;mmcbase.dll;13315";
			public const string UserModeLimitedAccessSignleWindow = ";User mode - limited access, single window;Win32String;mmcbase.dll;13316";
		}

        private class ControlIDs
        {
            public const int ConsoleNameTextBox = 0x403;
            public const int ChangeIconButton = 1025;
            public const int ConsoleAccessModeEditComboBox = 1022;
            public const int SaveChangedCheckBox = 1024;
            public const int AllowCustomizeViewsCheckBox = 1029;
            public const int OKButton = 1;
            public const int CancelButton = 2;
            public const int ApplyButton = 12321;
			public const int DeleteFilesButton = 1031;
            public const int TabControl = 0x3020;
        }
		#endregion

		#region Member Variables
        private TextBox m_cachedConsoleNameTextBox;
        private Button m_cachedChangeIconButton;
        private EditComboBox m_cachedConsoleAccessModeEditComboBox;
        private CheckBox m_cachedSaveChangedCheckBox;
        private CheckBox m_cachedAllowCustomizeViewsCheckBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private Button m_cachedApplyButton;
		private Button m_cachedDeleteFilesButton;
        private TabControl m_cachedTabControl;
		#endregion

		#region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public OptionsDialog(MmcApp app) : base(app, Init(app, CommandMethod.Default))
        {
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Constructor.
		///  </summary>
		///  <param name="app">MmcApp object owning the dialog.</param>
		///  <param name="method">How to invoke the command.</param>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public OptionsDialog(MmcApp app, CommandMethod method) : base(app, Init(app, method))
		{
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
				UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            }
            catch (Exceptions.WindowNotFoundException)
            {
				Commands.FileOptions.Execute(app, method);
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            }
            return tempWindow;
        }
		#endregion

		#region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IOptionsDialogControls Controls
        {
            get
            {
                return this;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConsoleNameTextBox
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ConsoleName
        {
            get
            {
                return Controls.ConsoleNameTextBox.Text;
            }
            set
            {
                Controls.ConsoleNameTextBox.Text = value;
            }
        }

		/// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ConsoleAccessMode
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ConsoleAccessMode ConsoleAccessMode
        {
            get
            {
				string value = Controls.ConsoleAccessModeEditComboBox.Text;
				if (value == App.GetIntlStr(Strings.AuthorMode))
					return ConsoleAccessMode.AuthorMode;
				else if (value == App.GetIntlStr(Strings.UserModeFullAccess))
					return ConsoleAccessMode.UserModeFullAccess;
				else if (value == App.GetIntlStr(Strings.UserModeLimitedAccessMultipleWindows))
					return ConsoleAccessMode.UserModeLimitedAccessMultipleWindows;
				else if (value == App.GetIntlStr(Strings.UserModeLimitedAccessSignleWindow))
					return ConsoleAccessMode.UserModeLimitedAccessSingleWindow;
				else
					throw new NotSupportedException("Console mode " + value + " is not supported by this dialog class.");
            }
            set
            {
				switch (value)
				{
					case ConsoleAccessMode.AuthorMode:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.AuthorMode));
						break;
					case ConsoleAccessMode.UserModeFullAccess:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.UserModeFullAccess));
						break;
					case ConsoleAccessMode.UserModeLimitedAccessMultipleWindows:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.UserModeLimitedAccessMultipleWindows));
						break;
					case ConsoleAccessMode.UserModeLimitedAccessSingleWindow:
						Controls.ConsoleAccessModeEditComboBox.SelectByText(App.GetIntlStr(Strings.UserModeLimitedAccessSignleWindow));
						break;
				}
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Gets or sets whether to save changes to console.
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public bool SaveChangesToConsole
		{
			get
			{
				return Controls.SaveChangedCheckBox.Checked;
			}
			set
			{
				Controls.SaveChangedCheckBox.Checked = value;
			}
		}
        
		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Gets or sets whether to allows user to customize console views.
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public bool AllowUserToCustomizeViews
		{
			get
			{
				return Controls.AllowCustomizeViewsCheckBox.Checked;
			}
			set
			{
				Controls.AllowCustomizeViewsCheckBox.Checked = value;
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConsoleNameTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IOptionsDialogControls.ConsoleNameTextBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedConsoleNameTextBox == null))
                {
                    m_cachedConsoleNameTextBox = new TextBox(this, ControlIDs.ConsoleNameTextBox);
                }
                return m_cachedConsoleNameTextBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ChangeIconButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.ChangeIconButton
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedChangeIconButton == null))
                {
                    m_cachedChangeIconButton = new Button(this, ControlIDs.ChangeIconButton);
                }
                return m_cachedChangeIconButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ConsoleAccessModeEditComboBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOptionsDialogControls.ConsoleAccessModeEditComboBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedConsoleAccessModeEditComboBox == null))
                {
                    m_cachedConsoleAccessModeEditComboBox = new EditComboBox(this, ControlIDs.ConsoleAccessModeEditComboBox);
                }
                return m_cachedConsoleAccessModeEditComboBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveChangedCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IOptionsDialogControls.SaveChangedCheckBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedSaveChangedCheckBox == null))
                {
                    m_cachedSaveChangedCheckBox = new CheckBox(this, ControlIDs.SaveChangedCheckBox);
                }
                return m_cachedSaveChangedCheckBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AllowCustomizeViewsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IOptionsDialogControls.AllowCustomizeViewsCheckBox
        {
            get
            {
				if (Controls.TabControl.SelectedIndex != 0)
					Controls.TabControl.Tabs[0].Select();
				if ((m_cachedAllowCustomizeViewsCheckBox == null))
                {
                    m_cachedAllowCustomizeViewsCheckBox = new CheckBox(this, ControlIDs.AllowCustomizeViewsCheckBox);
                }
                return m_cachedAllowCustomizeViewsCheckBox;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.OKButton
        {
            get
            {
				if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.CancelButton
        {
            get
            {
				if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplyButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOptionsDialogControls.ApplyButton
        {
            get
            {
				if ((m_cachedApplyButton == null))
                {
                    m_cachedApplyButton = new Button(this, ControlIDs.ApplyButton);
                }
                return m_cachedApplyButton;
            }
        }      
		
		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Exposes access to the DeleteFilesButton control
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 - Created
		///  </history>
		/// -----------------------------------------------------------------------------
		Button IOptionsDialogControls.DeleteFilesButton
		{
			get
			{
				if (Controls.TabControl.SelectedIndex != 1)
					Controls.TabControl.Tabs[1].Select();
				if ((m_cachedDeleteFilesButton == null))
				{
					m_cachedDeleteFilesButton = new Button(this, ControlIDs.DeleteFilesButton);
				}
				return m_cachedDeleteFilesButton;
			}
		}

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TabControl control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IOptionsDialogControls.TabControl
        {
            get
            {
				if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }
		#endregion

		#region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button ChangeIcon
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickChangeIcon()
        {
            Controls.ChangeIconButton.Click();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
			WaitForInvalid();
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Apply
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/15/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickApply()
        {
            Controls.ApplyButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Routine to click on button DeleteFiles.
		///  </summary>
		///  <history>
		/// 	[dmitriv] 6/15/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual void ClickDeleteFiles()
		{
			Controls.DeleteFilesButton.Click();
		}
		#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Core\Resources\WhidbeyResourceBridge.cs ===
using System;
using System.IO;
using System.Diagnostics;
using Maui.Core.Remoting;

namespace Maui.Core.Resources
{
	/// <summary>
	/// Provides a way for MAUI to extract resources from Whidbey assemblies
	/// while running on Everett runtime.
	/// </summary>
	/// <history>
	///		[dmitriv]	6/25/2003	Created
	/// </history>
	class WhidbeyResourceBridge
	{

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			RemotingHost.Instance.InitializeServer();
			string semFileName = Process.GetCurrentProcess().MainModule.ModuleName + ".running";
			File.Create(semFileName).Close();
			while (File.Exists(semFileName))
			{
				System.Threading.Thread.Sleep(200);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\BaseFile.cs ===
using System;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{

	///-----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: BaseFile
	///
	/// Copyright (C) 2004, Microsoft Corporation
	///-----------------------------------------------------------------------------
	/// <summary>
	/// Base class for the three file types that Mage works with.  Each file comes
	/// off the Tab control from the Mage UI
	/// </summary>
	/// <history>
	/// 	[a-dwils]	3/1/04	Inserted comment block for code review
	/// </history>
	///-----------------------------------------------------------------------------

	public class BaseFile : Maui.Core.WinControls.TabControlTab
	{

#region "Control IDs"

		public class ControlIDs
		{
			public const string ListBox = "Pages";
		}

#endregion

#region "Member Variables"
		protected ListBox m_cachedListBox;
		public App m_storedApp;
#endregion

#region "Constructors"

		/// <summary>
		/// Constructor that takes in a Tab control and calls the base class constructor
		/// </summary>
		/// <param name="Tab"></param>
		/// <history>
		/// 	[a-dwils]	3/1/04	Inserted comment block for code review
		/// </history>
		public BaseFile(TabControlTab Tab) : base(Tab.Owner, Tab.Text)
		{
		}

#endregion

#region "Properties"

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the ListBox control
		///  </summary>
		///  <value>The list box that each file type shares</value>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public ListBox List	//IBaseFileControls
		{
			get
			{
				if ((m_cachedListBox == null))
				{
					m_cachedListBox = new ListBox(this.Owner, ControlIDs.ListBox);
				}
				return m_cachedListBox;
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\NewDialogs\Advanced.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region "IAdvancedDialogControls interface definition"

    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAdvancedDialogControls
    {
        CheckBox AllowChangingTheParentSnapInCheckBox { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
    }

    #endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AdvancedDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Open and manipulate the Advanced dialog, reachable from the Add or Remove Snap-ins
    ///  dialog added in MMC 2.1
    ///  </summary>
    ///  <history>
    /// 	[michsny] 12/17/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AdvancedDialog : Dialog, IAdvancedDialogControls
    {

        #region "Strings"
        public class Strings
        {
            public const string DialogTitle = ";Advanced;Win32DialogString;mmcndmgr.dll;4187";
            public const string AddDialogTitle = ";Add or Remove Snap-ins;Win32DialogString;mmcndmgr.dll;160";
            public const string ByDefaultSnapInsAreAddedUnderTheConsoleRootNodeSelectingThisCheckBoxEnablesYouToChooseTheParentSnapI = ";By default, snap-ins are added under the console root node.  Selecting this check box enables you to choose the parent snap-in under which snap-ins will be added.;Win32DialogItemString;mmcndmgr.dll;4187;-1";
            public const string AllowChangingTheParentSnapIn = ";&Allow changing the parent snap-in;Win32DialogItemString;mmcndmgr.dll;4187;4188";
            public const string OK = ";OK;Win32DialogItemString;mmcndmgr.dll;107;1";
            public const string Cancel = ";Cancel;Win32DialogItemString;mmcndmgr.dll;160;2";
        }

        #endregion

        #region "Constants"
        private const int timeout = 3000;

        #endregion

        #region "Control IDs"
        public class ControlIDs
        {
            public const int AllowChangingTheParentSnapInCheckBox = 0x105C;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

        #endregion

        #region "Member Variables"
        private StaticControl m_cachedByDefaultSnapInsAreAddedUnderTheConsoleRootNodeIStaticControl;
        private CheckBox m_cachedAllowChangingTheParentSnapInCheckBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

        #endregion

        #region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Find and manipulate the Advanced Dialog
        ///  </summary>
        //  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AdvancedDialog(App app, AddOrRemoveSnapInsDialog dialog) :  
            base(app, Init(app, dialog))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(App app, AddOrRemoveSnapInsDialog dialog)
        {
            Window tempWindow;

            // open the advanced dialog
            dialog.ClickAdvanced();

            // find the window
            tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);

            return tempWindow;
        }

        #endregion

        #region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAdvancedDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox AllowChangingTheParentSnapIn
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool AllowChangingTheParentSnapIn
        {
            get
            {
                return Controls.AllowChangingTheParentSnapInCheckBox.Checked;
            }
            set
            {
                Controls.AllowChangingTheParentSnapInCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AllowChangingTheParentSnapInCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IAdvancedDialogControls.AllowChangingTheParentSnapInCheckBox
        {
            get
            {
                if ((m_cachedAllowChangingTheParentSnapInCheckBox == null))
                {
                    m_cachedAllowChangingTheParentSnapInCheckBox = new CheckBox(this, ControlIDs.AllowChangingTheParentSnapInCheckBox);
                }
                return m_cachedAllowChangingTheParentSnapInCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAdvancedDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAdvancedDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        #endregion

        #region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/17/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// <summary>
        /// Check the checkbox to enable changing the parent snap-in
        /// </summary>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void EnableAllowChangingTheParentSnapIn()
        {
            Controls.AllowChangingTheParentSnapInCheckBox.Checked = true;
        }

        /// <summary>
        /// Un-Check the checkbox to enable changing the parent snap-in
        /// </summary>        
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void DisableAllowChangingTheParentSnapIn()
        {
            Controls.AllowChangingTheParentSnapInCheckBox.Checked = false;
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\NewDialogs\Extensions.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region "IExtensionsControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IExtensionsControls
    {
        RadioButton AlwaysEnableAllAvailableExtensionsRadioButton { get;}
        RadioButton EnableOnlySelectedExtensionsRadioButton { get;}
        ListView ExtensionsList { get;}
        Button InstallButton { get;}
        Button EditExtensionsButton { get;}
        TextBox DescriptionTextBox { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
    }

    #endregion

    #region "Enums for RadioButton groups"

    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group AllExtensionsWillBeEnabled
    ///  </summary>
    ///  <history>
    /// 	[michsny] 1/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum AllExtensionsWillBeEnabled
    {
        AlwaysEnableAllAvailableExtensions = 0,
        EnableOnlySelectedExtensions = 1,
    }

    #endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: Extensions
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Open and manipulate the Extensions dialog added in MMC 2.1
    ///  </summary>
    ///  <history>
    /// 	[michsny] 1/4/2005 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class Extensions : Dialog, IExtensionsControls
    {

        #region "Strings"
        public class Strings
        {
            public const string DialogTitle = ";Extensions for %s;Win32String;mmcbase.dll;14179";
            public const string AddDialogTitle = ";Add or Remove Snap-ins;Win32DialogString;mmcndmgr.dll;160";
            public const string YouCanSpecifyWhichExtensionsToEnableInOrderToAddOrRemoveFunctionalityInYourConsoleSnapInOrExtensionI = ";You can specify which extensions to enable, in order to add or remove functionality in your console, snap-in, or extension. If an extension is not installed, you can install it by highlighting it and then clicking Install. ;Win32DialogItemString;mmcndmgr.dll;161;-1";
            public const string AlwaysEnableAllAvailableExtensions = ";&Always enable all available extensions;Win32DialogItemString;mmcndmgr.dll;161;4189";
            public const string EnableOnlySelectedExtensions = ";&Enable only selected extensions;Win32DialogItemString;mmcndmgr.dll;161;4190";
            public const string AllCurrentlyAvailableExtensionsAsWellAsAnyExtensionsThatAreInstalledInTheFutureWillBeEnabled = ";All currently available extensions, as well as any extensions that are installed in the future, will be enabled.;Win32DialogItemString;mmcndmgr.dll;161;-1";
            public const string OnlyTheFollowingSelectedExtensionsWillBeEnabledExtensionsThatAreInstalledInTheFutureWillNotBeEnabled = ";Only the following selected extensions will be enabled. Extensions that are installed in the future will not be enabled.;Win32DialogItemString;mmcndmgr.dll;161;-1";
            public const string ExtensionsList = ";Extensions list;Win32DialogItemString;mmcndmgr.dll;161;4020";
            public const string Install = ";I&nstall;Win32DialogItemString;mmcndmgr.dll;161;4026";
            public const string EditExtensions = ";Edit E&xtensions...;Win32DialogItemString;mmcndmgr.dll;160;4176";
            public const string Description = ";Description:;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string OK = ";OK;Win32DialogItemString;mmcndmgr.dll;107;1";
            public const string Cancel = ";Cancel;Win32DialogItemString;mmcndmgr.dll;160;2";

        }

        #endregion

        #region "Constants"
            private const int timeout = 3000;

        #endregion

        #region "Control IDs"
        public class ControlIDs
        {
            public const int AlwaysEnableAllAvailableExtensionsRadioButton = 0x105D;
            public const int EnableOnlySelectedExtensionsRadioButton = 0x105E;
            public const int ExtensionsList = 0xFB4;
            public const int InstallButton = 0xFBA;
            public const int EditExtensionsButton = 0x1050;
            public const int DescriptionTextBox = 0xFA7;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

        #endregion

        #region "Member Variables"
        private RadioButton m_cachedAlwaysEnableAllAvailableExtensionsRadioButton;
        private RadioButton m_cachedEnableOnlySelectedExtensionsRadioButton;
        private ListView m_cachedExtensionsList;
        private Button m_cachedInstallButton;
        private Button m_cachedEditExtensionsButton;
        private TextBox m_cachedDescriptionTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private const int Timeout = 1000;

        #endregion

        #region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Find and manipulate the extensions dialog
        ///  </summary>
        //  <param name="app">App object owning the dialog.</param>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public Extensions(App app, AddOrRemoveSnapInsDialog dialog) : 
                base(app, Init(app, dialog))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">App owning the dialog.</param>)
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(App app, AddOrRemoveSnapInsDialog dialog)
        {
            Window tempWindow;
            string tempWindowTitle = app.GetIntlStr(Strings.DialogTitle);

            // replace the %s in the title with *
            tempWindowTitle = tempWindowTitle.Replace("%s", "*");

            // Click the button to open the extensions dialog
            dialog.ClickEditExtensions();

            // find the Extensions window
            tempWindow = new Window(tempWindowTitle, StringMatchSyntax.WildCard, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);

            return tempWindow;
        }

        #endregion

        #region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IExtensionsControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group AllExtensionsWillBeEnabled
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual AllExtensionsWillBeEnabled AllExtensionsWillBeEnabled
        {
            get
            {
                if ((Controls.AlwaysEnableAllAvailableExtensionsRadioButton.ButtonState == ButtonState.Checked))
                    return AllExtensionsWillBeEnabled.AlwaysEnableAllAvailableExtensions;

                if ((Controls.EnableOnlySelectedExtensionsRadioButton.ButtonState == ButtonState.Checked))
                    return AllExtensionsWillBeEnabled.EnableOnlySelectedExtensions;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == AllExtensionsWillBeEnabled.AlwaysEnableAllAvailableExtensions))
                    Controls.AlwaysEnableAllAvailableExtensionsRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == AllExtensionsWillBeEnabled.EnableOnlySelectedExtensions))
                    Controls.EnableOnlySelectedExtensionsRadioButton.ButtonState = ButtonState.Checked;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Description
        ///  </summary>
        ///  <value>Description Text</value>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DescriptionText
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
            set
            {
                Controls.DescriptionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AlwaysEnableAllAvailableExtensionsRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IExtensionsControls.AlwaysEnableAllAvailableExtensionsRadioButton
        {
            get
            {
                if ((m_cachedAlwaysEnableAllAvailableExtensionsRadioButton == null))
                {
                    m_cachedAlwaysEnableAllAvailableExtensionsRadioButton = new RadioButton(this, ControlIDs.AlwaysEnableAllAvailableExtensionsRadioButton);
                }
                return m_cachedAlwaysEnableAllAvailableExtensionsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EnableOnlySelectedExtensionsRadioButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IExtensionsControls.EnableOnlySelectedExtensionsRadioButton
        {
            get
            {
                if ((m_cachedEnableOnlySelectedExtensionsRadioButton == null))
                {
                    m_cachedEnableOnlySelectedExtensionsRadioButton = new RadioButton(this, ControlIDs.EnableOnlySelectedExtensionsRadioButton);
                }
                return m_cachedEnableOnlySelectedExtensionsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExtensionsList control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IExtensionsControls.ExtensionsList
        {
            get
            {
                if ((m_cachedExtensionsList == null))
                {
                    m_cachedExtensionsList = new ListView(this, ControlIDs.ExtensionsList);
                }
                return m_cachedExtensionsList;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the InstallButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.InstallButton
        {
            get
            {
                if ((m_cachedInstallButton == null))
                {
                    m_cachedInstallButton = new Button(this, ControlIDs.InstallButton);
                }
                return m_cachedInstallButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditExtensionsButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.EditExtensionsButton
        {
            get
            {
                if ((m_cachedEditExtensionsButton == null))
                {
                    m_cachedEditExtensionsButton = new Button(this, ControlIDs.EditExtensionsButton);
                }
                return m_cachedEditExtensionsButton;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IExtensionsControls.DescriptionTextBox
        {
            get
            {
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IExtensionsControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        #endregion

        #region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Install
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickInstall()
        {
            Controls.InstallButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button EditExtensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEditExtensions()
        {
            Controls.EditExtensionsButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/4/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to check the radio button to enable only selected extensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/28/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void EnableOnlySelectedExtensions()
        {
            Controls.EnableOnlySelectedExtensionsRadioButton.ButtonState = ButtonState.Checked;
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to check the radio button to enable all extensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 1/28/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void EnableAllExtensions()
        {
            Controls.AlwaysEnableAllAvailableExtensionsRadioButton.ButtonState = ButtonState.Checked;
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to check the radio button to enable a specified
        ///  </summary>
        /// <param name="extensionName">string extensionName</param>
        ///  <history>
        /// 	[michsny] 1/28/2005 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void EnableExtension(string extensionName)
        {
            try
            {
                Controls.ExtensionsList.Items[extensionName].Checked = true;
            }
            catch (Maui.Core.WinControls.ListView.Exceptions.ItemNotFoundException)
            {
                //This was ignored in the code for the old UI.
                //The test code should catch this exception and handle it if an expected extension is not available.
                throw (new Maui.GlobalExceptions.MauiException("ExtensionToEnableWasNotFound"));
            }
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Backup\Products\ManagementConsole\Dialogs\NewDialogs\AddOrRemoveSnapIns.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region "IAddOrRemoveSnapInsDialogControls interface definition"


    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddOrRemoveSnapInsDialogControls
    {
        ListView AvailableSnapinsList { get;}
        Button AddButton { get;}
        EditComboBox ParentSnapInEditComboBox { get;}
        ListView AddedSnapinsList { get;}
        Button EditExtensionsButton { get;}
        Button RemoveButton { get;}
        Button MoveUpButton { get;}
        Button MoveDownButton { get;}
        Button AdvancedButton { get;}
        TextBox DescriptionTextBox { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
    }

    #endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui
    /// Class		: AddOrRemoveSnapInsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Class to open and manipulate the "Add or Remove Snap-ins" dialog that was 
    ///     added in MMC 2.1
    ///  </summary>
    ///  <history>
    /// 	[michsny] 12/14/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddOrRemoveSnapInsDialog : Dialog, IAddOrRemoveSnapInsDialogControls
    {

        #region "Strings"
        public class Strings
        {
            public const string DialogTitle = ";Add or Remove Snap-ins;Win32DialogString;mmcndmgr.dll;160";
            public const string YouCanSelectSnapInsForThisConsoleTitleText = ";You can select snap-ins for this console from those available on your computer and configure the selected set of snap-ins. For extensible snap-ins, you can configure which extensions are enabled.;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string AvailableSnapIns = ";Available &snap-ins:;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string AvailableSnapinsList = ";AvailableSnapinsList;Win32DialogItemString;mmcndmgr.dll;160;4173";
            public const string Add = ";&Add >;Win32DialogItemString;mmcndmgr.dll;160;4008";
            public const string ParentSnapIn = ";&Parent snap-in:;Win32DialogItemString;mmcndmgr.dll;160;4182";
            public const string SelectedSnapIns = ";S&elected snap-ins:;Win32DialogItemString;mmcndmgr.dll;160;4174";
            public const string AddedSnapinsList = ";AddedSnapinsList;Win32DialogItemString;mmcndmgr.dll;160;4175";
            public const string EditExtensions = ";Edit E&xtensions...;Win32DialogItemString;mmcndmgr.dll;160;4176";
            public const string Remove = "&;Remove;Win32DialogItemString;mmcndmgr.dll;1090;1015";
            public const string MoveUp = ";Move &Up;Win32DialogItemString;mmcndmgr.dll;108;1020";
            public const string MoveDown = ";Move &Down;Win32DialogItemString;mmcndmgr.dll;108;1021";
            public const string Advanced = ";Ad&vanced...;Win32DialogItemString;mmcndmgr.dll;160;4186";
            public const string Description = ";Description:;Win32DialogItemString;mmcndmgr.dll;160;-1";
            public const string OK = ";OK;Win32DialogItemString;mmcndmgr.dll;107;1";
            public const string Cancel = ";Cancel;Win32DialogItemString;mmcndmgr.dll;160;2";
        }

        #endregion

        #region "Constants"
            private const int timeout = 3000;

        #endregion

        #region "Control IDs"
        public class ControlIDs
        {
            public const int AvailableSnapinsList = 0x104D;
            public const int AddButton = 0xFA8;
            public const int ParentSnapInStaticControl = 0x1056;
            public const int ParentSnapInEditComboBox = 0x1054;
            public const int SelectedSnapInsStaticControl = 0x104E;
            public const int AddedSnapinsList = 0x104F;
            public const int EditExtensionsButton = 0x1050;
            public const int RemoveButton = 0x1053;
            public const int MoveUpButton = 0x1051;
            public const int MoveDownButton = 0x1052;
            public const int AdvancedButton = 0x105A;
            public const int DescriptionTextBox = 0xFA7;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

        #endregion

        #region "Member Variables"
        private ListView m_cachedAvailableSnapinsList;
        private Button m_cachedAddButton;
        private EditComboBox m_cachedParentSnapInEditComboBox;
        private ListView m_cachedAddedSnapinsList;
        private Button m_cachedEditExtensionsButton;
        private Button m_cachedRemoveButton;
        private Button m_cachedMoveUpButton;
        private Button m_cachedMoveDownButton;
        private Button m_cachedAdvancedButton;
        private TextBox m_cachedDescriptionTextBox;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;

        private const int Timeout = 3000;

        #endregion

        #region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor - Opens the dialog and finds the window
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddOrRemoveSnapInsDialog(App app) : base(app, Init(app, CommandMethod.Default))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor - Opens the dialog and finds the window
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <param name="method">CommandMethod for controling the menu.</param>    
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddOrRemoveSnapInsDialog(App app, CommandMethod method) : base(app, Init(app, method))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(App app, CommandMethod method)
        {
            Window tempWindow;
            // First check if the dialog is already up.
            try
            {
                UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                // The line below is throwing an exception...it is clicking at 0,0 instead of on the menu
                // Dmitry is investigating.
                // Commands.FileAddRemoveSnapIn.Execute(app,CommandMethod.MainMenuHotKey);
                //BUGBUG this is a temporary workaround to the problem above
                app.SendKeys("^m");
                Maui.TestLog.LogManager.LogHack("Init", "Hardcoded sendkeys method of opening the dialog is not localizable: Fail this after 4/1/05");                

                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, timeout);
            }
            return tempWindow;
        }

        #endregion

        #region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddOrRemoveSnapInsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control YouCanSelectSnapInsForThisConsoleTitleText
        ///  </summary>
        ///  <value>Control Text</value>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string YouCanSelectSnapInsForThisConsoleTitleTextText
        {
            get
            {
                return Controls.ParentSnapInEditComboBox.Text;
            }
            set
            {
                Controls.ParentSnapInEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Description
        ///  </summary>
        ///  <value>Description Text</value>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string DescriptionText
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
            set
            {
                Controls.DescriptionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AvailableSnapinsList control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddOrRemoveSnapInsDialogControls.AvailableSnapinsList
        {
            get
            {
                if ((m_cachedAvailableSnapinsList == null))
                {
                    m_cachedAvailableSnapinsList = new ListView(this, ControlIDs.AvailableSnapinsList);
                }
                return m_cachedAvailableSnapinsList;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ParentSnapInEditComboBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAddOrRemoveSnapInsDialogControls.ParentSnapInEditComboBox
        {
            get
            {
                if ((m_cachedParentSnapInEditComboBox == null))
                {
                    m_cachedParentSnapInEditComboBox = new EditComboBox(this, ControlIDs.ParentSnapInEditComboBox);
                }
                return m_cachedParentSnapInEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddedSnapinsList control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddOrRemoveSnapInsDialogControls.AddedSnapinsList
        {
            get
            {
                if ((m_cachedAddedSnapinsList == null))
                {
                    m_cachedAddedSnapinsList = new ListView(this, ControlIDs.AddedSnapinsList);
                }
                return m_cachedAddedSnapinsList;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EditExtensionsButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.EditExtensionsButton
        {
            get
            {
                if ((m_cachedEditExtensionsButton == null))
                {
                    m_cachedEditExtensionsButton = new Button(this, ControlIDs.EditExtensionsButton);
                }
                return m_cachedEditExtensionsButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RemoveButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.RemoveButton
        {
            get
            {
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MoveUpButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.MoveUpButton
        {
            get
            {
                if ((m_cachedMoveUpButton == null))
                {
                    m_cachedMoveUpButton = new Button(this, ControlIDs.MoveUpButton);
                }
                return m_cachedMoveUpButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MoveDownButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.MoveDownButton
        {
            get
            {
                if ((m_cachedMoveDownButton == null))
                {
                    m_cachedMoveDownButton = new Button(this, ControlIDs.MoveDownButton);
                }
                return m_cachedMoveDownButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AdvancedButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.AdvancedButton
        {
            get
            {
                if ((m_cachedAdvancedButton == null))
                {
                    m_cachedAdvancedButton = new Button(this, ControlIDs.AdvancedButton);
                }
                return m_cachedAdvancedButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddOrRemoveSnapInsDialogControls.DescriptionTextBox
        {
            get
            {
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddOrRemoveSnapInsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        #endregion

        #region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button EditExtensions
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickEditExtensions()
        {
            Controls.EditExtensionsButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Remove
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickRemove()
        {
            Controls.RemoveButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MoveUp
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveUp()
        {
            Controls.MoveUpButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MoveDown
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveDown()
        {
            Controls.MoveDownButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Advanced
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdvanced()
        {
            Controls.AdvancedButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {            
            Controls.OKButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[michsny] 12/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// <summary>
        /// Set the Parent snap-in path
        /// </summary>
        /// <param name="path">Snap-in to select as parent</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SetPath(string path)
        {
            Controls.ParentSnapInEditComboBox.SelectByText(path);
        }

        /// <summary>
        /// Set the Parent snap-in path to the Console Root
        /// </summary>        
        /// <history>
        ///     [michsny] 1/20/2004 Created
        /// </history>
        public void SetPathToConsoleRoot()
        {
            Controls.ParentSnapInEditComboBox.SelectByIndex(0);
        }

        /// <summary>
        /// Select the specified snap-in in the available snap-ins list
        /// </summary>
        /// <param name="snapIn">SnapIn object</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SelectAvailableSnapIn(Snapin snapIn)
        {
            Controls.AvailableSnapinsList.Items[snapIn.Name].Select();
        }

        /// <summary>
        /// Select the specified snap-in in the added snap-ins list
        /// </summary>
        /// <param name="snapIn">SnapIn object</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SelectAddedSnapIn(Snapin snapIn)
        {
            Controls.AddedSnapinsList.Items[snapIn.AddedName].Select();
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\OpenDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IOpenDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IOpenDialogControls
    {
        StaticControl LookInStaticControl  {get;}
        EditComboBox LookInEditComboBox  {get;}
        Toolbar Toolbar0  {get;}
        Toolbar LookInToolbar  {get;}
        ListView FolderView  {get;}
        StaticControl FileNameStaticControl  {get;}
        EditComboBox FileNameEditComboBox  {get;}
        TextBox FileNameTextBox  {get;}
        StaticControl FilesOfTypeStaticControl  {get;}
        EditComboBox FilesOfTypeEditComboBox  {get;}
        Button OpenButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: OpenDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This dialog is for the Open file dialog that Mage uses.
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/23/2004 Created
    /// 	[a-dwils] 3/1/2004  Modified for code review
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class OpenDialog : Dialog, IOpenDialogControls
    {

#region "Control IDs"
        public class ControlIDs
        {
            public const int LookInStaticControl = 0x443;
            public const int LookInEditComboBox = 0x471;
            public const int Toolbar0 = 0x440;
            public const int LookInToolbar = 0x4A0;
            public const int FolderView = 0x1;
            public const int FileNameStaticControl = 0x442;
            public const int FileNameEditComboBox = 0x47C;
            public const int FileNameTextBox = 0x47C;
            public const int FilesOfTypeStaticControl = 0x441;
            public const int FilesOfTypeEditComboBox = 0x470;
            public const int OpenButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedLookInStaticControl;
        protected EditComboBox m_cachedLookInEditComboBox;
        protected Toolbar m_cachedToolbar0;
        protected Toolbar m_cachedLookInToolbar;
        protected ListView m_cachedFolderView;
        protected StaticControl m_cachedFileNameStaticControl;
        protected EditComboBox m_cachedFileNameEditComboBox;
        protected TextBox m_cachedFileNameTextBox;
        protected StaticControl m_cachedFilesOfTypeStaticControl;
        protected EditComboBox m_cachedFilesOfTypeEditComboBox;
        protected Button m_cachedOpenButton;
        protected Button m_cachedCancelButton;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This constructor takes in the Title of the Open dialog window
        ///  </summary>
        //  <param name="app">IDEApp object owning the dialog.</param>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public OpenDialog(MageApp app, string Title) : 
                base(app, Init(app, Title))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">IDEApp owning the dialog.</param>)
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app, string Title)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
				tempWindow = new Window(Title, StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the " + Title + " dialog.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IOpenDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LookIn
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string LookIn
        {
            get
            {
                return Controls.LookInEditComboBox.Text;
            }
            set
            {
                Controls.LookInEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FileName
        {
            get
            {
                return Controls.FileNameEditComboBox.Text;
            }
            set
            {
                Controls.FileNameEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName3
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FileName3
        {
            get
            {
                return Controls.FileNameTextBox.Text;
            }
            set
            {
                Controls.FileNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FilesOfType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FilesOfType
        {
            get
            {
                return Controls.FilesOfTypeEditComboBox.Text;
            }
            set
            {
                Controls.FilesOfTypeEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IOpenDialogControls.LookInStaticControl
        {
            get
            {
                if ((m_cachedLookInStaticControl == null))
                {
                    m_cachedLookInStaticControl = new StaticControl(this, ControlIDs.LookInStaticControl);
                }
                return m_cachedLookInStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOpenDialogControls.LookInEditComboBox
        {
            get
            {
                if ((m_cachedLookInEditComboBox == null))
                {
                    m_cachedLookInEditComboBox = new EditComboBox(this, ControlIDs.LookInEditComboBox);
                }
                return m_cachedLookInEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Toolbar0 control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar IOpenDialogControls.Toolbar0
        {
            get
            {
                if ((m_cachedToolbar0 == null))
                {
                    m_cachedToolbar0 = new Toolbar(this, ControlIDs.Toolbar0.ToString());
                }
                return m_cachedToolbar0;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInToolbar control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar IOpenDialogControls.LookInToolbar
        {
            get
            {
                if ((m_cachedLookInToolbar == null))
                {
                    m_cachedLookInToolbar = new Toolbar(this, ControlIDs.LookInToolbar.ToString());
                }
                return m_cachedLookInToolbar;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FolderView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IOpenDialogControls.FolderView
        {
            get
            {
                if ((m_cachedFolderView == null))
                {
                    m_cachedFolderView = new ListView(this, ControlIDs.FolderView);
                }
                return m_cachedFolderView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IOpenDialogControls.FileNameStaticControl
        {
            get
            {
                if ((m_cachedFileNameStaticControl == null))
                {
                    m_cachedFileNameStaticControl = new StaticControl(this, ControlIDs.FileNameStaticControl);
                }
                return m_cachedFileNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOpenDialogControls.FileNameEditComboBox
        {
            get
            {
                if ((m_cachedFileNameEditComboBox == null))
                {
                    m_cachedFileNameEditComboBox = new EditComboBox(this, ControlIDs.FileNameEditComboBox);
                }
                return m_cachedFileNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IOpenDialogControls.FileNameTextBox
        {
            get
            {
                // The ID for this control (1148) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedFileNameTextBox == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 9); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    wndTemp = wndTemp.Extended.FirstChild;
                    wndTemp = wndTemp.Extended.FirstChild;
                    m_cachedFileNameTextBox = new TextBox(wndTemp);
                }
                return m_cachedFileNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IOpenDialogControls.FilesOfTypeStaticControl
        {
            get
            {
                if ((m_cachedFilesOfTypeStaticControl == null))
                {
                    m_cachedFilesOfTypeStaticControl = new StaticControl(this, ControlIDs.FilesOfTypeStaticControl);
                }
                return m_cachedFilesOfTypeStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IOpenDialogControls.FilesOfTypeEditComboBox
        {
            get
            {
                if ((m_cachedFilesOfTypeEditComboBox == null))
                {
                    m_cachedFilesOfTypeEditComboBox = new EditComboBox(this, ControlIDs.FilesOfTypeEditComboBox);
                }
                return m_cachedFilesOfTypeEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OpenButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOpenDialogControls.OpenButton
        {
            get
            {
                // The ID for this control (1) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedOpenButton == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 13); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    m_cachedOpenButton = new Button(wndTemp);
                }
                return m_cachedOpenButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IOpenDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Open
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOpen()
        {
            Controls.OpenButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Open dialog is up already
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(string Title, MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\BrowseForFolderDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "IBrowseForFolderDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IBrowseForFolderDialogControls
    {
        TreeView TreeView  {get;}
        Button MakeNewFolderButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: BrowseForFolderDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Browse dialog window that comes up when choosing a folder in Mage
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 1/21/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class BrowseForFolderDialog : Dialog, IBrowseForFolderDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Browse For Folder";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int TreeView = 0x64;
            public const int MakeNewFolderButton = 0x3746;
            public const int OKButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        protected TreeView m_cachedTreeView;
        protected Button m_cachedMakeNewFolderButton;
        protected Button m_cachedOKButton;
        protected Button m_cachedCancelButton;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for this window, simply calls init function
        ///  </summary>
        //  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public BrowseForFolderDialog(MageApp app) : 
                base(app, Init(app))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app)
        {
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the Browse window.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IBrowseForFolderDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TreeView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TreeView IBrowseForFolderDialogControls.TreeView
        {
            get
            {
                if ((m_cachedTreeView == null))
                {
                    m_cachedTreeView = new TreeView(this, ControlIDs.TreeView);
                }
                return m_cachedTreeView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MakeNewFolderButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IBrowseForFolderDialogControls.MakeNewFolderButton
        {
            get
            {
                if ((m_cachedMakeNewFolderButton == null))
                {
                    m_cachedMakeNewFolderButton = new Button(this, ControlIDs.MakeNewFolderButton);
                }
                return m_cachedMakeNewFolderButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IBrowseForFolderDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IBrowseForFolderDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button MakeNewFolder
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickMakeNewFolder()
        {
            Controls.MakeNewFolderButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/21/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Browse dialog is up already
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\MageApp.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using Maui.TestLog;
	using System;
    using System.ComponentModel;
	using System.Collections.Specialized;


#region "IMageAppControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMageAppControls
    {
        TabControl FileTabControl  {get;}
        Toolbar MageToolbar  {get;}
		//statusBar MageStatus   {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: MageApp
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Class to describe the main Mage app, includes toolbar and main tab control
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 1/14/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MageApp : App, IMageAppControls
    {


#region "Strings"
        /// -----------------------------------------------------------
        /// <summary>
        ///  Discover the path to the app on this system
        ///  </summary>
        ///  <remarks>
        ///  <returns>the path to the Apps exe file.</returns>
        /// -----------------------------------------------------------
        private static string GetExePath()
        {
			LogManager.LogHack("MageApp.GetExePath", "Have to change to GetSdkRoot method to get exepath");
			//return WFCTestLib.Util.Utilities.GetSdkRoot() + @"\mage.exe";
			return @"C:\Program Files\Microsoft.NET\SDK\v2.0\Bin\mageui.exe";
        }
        
        public class Strings
        {
			public const string MageCaption = "BrowseForFolder";
			public const string File = "File";
			public const string Exit = "Exit";
			public const string AppMan = "Application Manifest";
			public const string DepMan = "Deployment Manifest";
			public const string TrustL = "Trust License";
			public const string MenuNew = "New";
			public const string SaveAs = "Save As";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string FileTabControl = "tabs";
            //public const string MageStatus = "status";
            public const string MageToolbar = "toolbar";
        }

#endregion

#region "Member Variables"
        protected TabControl m_cachedFileTabControl;
        protected Toolbar m_cachedMageToolbar;
        protected internal static Window ActiveWindow;
#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Mage App, calls base class constructor with exe path.
        ///  </summary>
        //  <param name="app">MageApp object owning the app. window.</param>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public MageApp() : 
                base(MageApp.GetExePath())
        {
        }
#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this app. window
        ///  </summary>
        ///  <value>An interface that groups all of the app. window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IMageAppControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileTabControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IMageAppControls.FileTabControl
        {
            get
            {
                if ((m_cachedFileTabControl == null))
                {
                    m_cachedFileTabControl = new TabControl(this.MainWindow, ControlIDs.FileTabControl);
                }
                return m_cachedFileTabControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the MageToolbar control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 1/14/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar IMageAppControls.MageToolbar
        {
            get
            {
                if ((m_cachedMageToolbar == null))
                {
                    m_cachedMageToolbar = new Toolbar(this.MainWindow);//, ControlIDs.MageToolbar);
                }
                return m_cachedMageToolbar;
            }
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the MageStatus control, not in build yet
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		/*Toolbar IMageAppControls.MageStatus
		{
			get
			{
				if ((m_cachedMageStatus == null))
				{
					m_cachedMageStatus = new StatusBar(this.MainWindow, ControlIDs.MageStatus);
				}
				return m_cachedMageStatus;
			}
		}*/

#endregion

#region Methods

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  this function will call File->Exit in the menu, it will select no if a save dialog comes up
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void QuitWithoutSave()
		{
			// click File->Exit Manifest
			StringCollection Exit = new StringCollection();
			Exit.Add(this.GetIntlStr(Strings.File));
			Exit.Add(this.GetIntlStr(Strings.Exit));
            this.Menu.ExecuteMenuItem(Exit);

			Window saveWindow = null;
			do
			{
				try
				{
					saveWindow = new Window("Mage", StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
				}
				catch (Exception ex)
				{
					break;
				}
				saveWindow.SendKeys("N");
			} while (saveWindow != null);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new application manifest through the menu
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewAppMenu()
		{
			StringCollection NewApp = new StringCollection();
			NewApp.Add(this.GetIntlStr(Strings.File));
			NewApp.Add(this.GetIntlStr(Strings.MenuNew));
			NewApp.Add(this.GetIntlStr(Strings.AppMan));
			this.Menu.ExecuteMenuItem(NewApp);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new application manifest through the toolbar
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewAppToolbar()
		{
			this.Controls.MageToolbar.ToolbarItems[0].Click();
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new deployment manifest through the menu
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewDeploymentMenu()
		{
			// click File->New->Deployment Manifest
			StringCollection NewDep = new StringCollection();
			NewDep.Add(this.GetIntlStr(Strings.File));
			NewDep.Add(this.GetIntlStr(Strings.MenuNew));
			NewDep.Add(this.GetIntlStr(Strings.DepMan));
			this.Menu.ExecuteMenuItem(NewDep);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new deployment manifest through the toolbar
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewDeploymentToolbar()
		{
			this.Controls.MageToolbar.ToolbarItems[1].Click();
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new trust license through the menu
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewLicenseMenu()
		{
			StringCollection NewLic = new StringCollection();
			NewLic.Add(this.GetIntlStr(Strings.File));
			NewLic.Add(this.GetIntlStr(Strings.MenuNew));
			NewLic.Add(this.GetIntlStr(Strings.TrustL));
			this.Menu.ExecuteMenuItem(NewLic);
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will create a new trust license through the toolbar
		///  </summary>
		///  <history>
		/// 	[a-dwils] 1/21/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public void ExecNewLicenseToolbar()
		{
			this.Controls.MageToolbar.ToolbarItems[2].Click();
		}

#endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\PreferencesDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;
	using System.Collections.Specialized;


#region "IPreferencesDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IPreferencesDialogControls
    {
        Button CancelButton  {get;}
        Button OKButton  {get;}
        Button EllipsisButton  {get;}
        CheckBox UseDefaultSigningKeyCheckBox  {get;}
        TextBox KeyFileTextBox  {get;}
        CheckBox SignManifestOnSaveCheckBox  {get;}
        StaticControl KeyFileStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: PreferencesDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Preferences dialog in the File->Preferences menu of Mage
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class PreferencesDialog : Dialog, IPreferencesDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Preferences";
			public const string File = "File";
			public const string Pref = "Preferences...";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string CancelButton = "btnCancel";
            public const string OKButton = "btnOK";
            public const string EllipsisButton = "btnBrowse";
            public const string UseDefaultSigningKeyCheckBox = "chkUseDefaultKey";
            public const string KeyFileTextBox = "txtKeyFile";
            public const string SignManifestOnSaveCheckBox = "chkSignOnSave";
            public const string KeyFileStaticControl = "label1";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedCancelButton;
        protected Button m_cachedOKButton;
        protected Button m_cachedEllipsisButton;
        protected CheckBox m_cachedUseDefaultSigningKeyCheckBox;
        protected TextBox m_cachedKeyFileTextBox;
        protected CheckBox m_cachedSignManifestOnSaveCheckBox;
        protected StaticControl m_cachedKeyFileStaticControl;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Preferences dialog, calls Init
        ///  </summary>
        //  <param name="app">MageApp object owning the dialog.</param>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public PreferencesDialog(MageApp app) : 
                base(app, Init(app))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MageApp owning the dialog.</param>)
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
				StringCollection Preferences = new StringCollection();
				Preferences.Add(app.GetIntlStr(Strings.File));
				Preferences.Add(app.GetIntlStr(Strings.Pref));
				app.Menu.ExecuteMenuItem(Preferences);
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
				if (tempWindow == null)
					throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the Preferences dialog.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IPreferencesDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox UseDefaultSigningKey
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool UseDefaultSigningKey
        {
            get
            {
                return Controls.UseDefaultSigningKeyCheckBox.Checked;
            }
            set
            {
                Controls.UseDefaultSigningKeyCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox SignManifestOnSave
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool SignManifestOnSave
        {
            get
            {
                return Controls.SignManifestOnSaveCheckBox.Checked;
            }
            set
            {
                Controls.SignManifestOnSaveCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control KeyFile
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public  string KeyFile
        {
            get
            {
                return Controls.KeyFileTextBox.Text;
            }
            set
            {
                Controls.KeyFileTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPreferencesDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPreferencesDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EllipsisButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IPreferencesDialogControls.EllipsisButton
        {
            get
            {
                if ((m_cachedEllipsisButton == null))
                {
                    m_cachedEllipsisButton = new Button(this, ControlIDs.EllipsisButton);
                }
                return m_cachedEllipsisButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the UseDefaultSigningKeyCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IPreferencesDialogControls.UseDefaultSigningKeyCheckBox
        {
            get
            {
                if ((m_cachedUseDefaultSigningKeyCheckBox == null))
                {
                    m_cachedUseDefaultSigningKeyCheckBox = new CheckBox(this, ControlIDs.UseDefaultSigningKeyCheckBox);
                }
                return m_cachedUseDefaultSigningKeyCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyFileTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IPreferencesDialogControls.KeyFileTextBox
        {
            get
            {
                if ((m_cachedKeyFileTextBox == null))
                {
                    m_cachedKeyFileTextBox = new TextBox(this, ControlIDs.KeyFileTextBox);
                }
                return m_cachedKeyFileTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignManifestOnSaveCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IPreferencesDialogControls.SignManifestOnSaveCheckBox
        {
            get
            {
                if ((m_cachedSignManifestOnSaveCheckBox == null))
                {
                    m_cachedSignManifestOnSaveCheckBox = new CheckBox(this, ControlIDs.SignManifestOnSaveCheckBox);
                }
                return m_cachedSignManifestOnSaveCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyFileStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IPreferencesDialogControls.KeyFileStaticControl
        {
            get
            {
                if ((m_cachedKeyFileStaticControl == null))
                {
                    m_cachedKeyFileStaticControl = new StaticControl(this, ControlIDs.KeyFileStaticControl);
                }
                return m_cachedKeyFileStaticControl;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis0()
        {
            Controls.EllipsisButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Preferences dialog is up already
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\SaveAsDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ISaveAsDialogControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISaveAsDialogControls
    {
        StaticControl SaveInStaticControl  {get;}
        EditComboBox LookInEditComboBox  {get;}
        Toolbar Toolbar1  {get;}
        Toolbar LookInToolbar  {get;}
        ListView FolderView  {get;}
        StaticControl FileNameStaticControl  {get;}
        EditComboBox FileNameEditComboBox  {get;}
        TextBox FileNameTextBox  {get;}
        StaticControl SaveAsTypeStaticControl  {get;}
        EditComboBox FilesOfTypeEditComboBox  {get;}
        Button SaveButton  {get;}
        Button CancelButton  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: SaveAsDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the SaveAs dialog that Mage uses
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/23/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SaveAsDialog : Dialog, ISaveAsDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Save As";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const int SaveInStaticControl = 0x443;
            public const int LookInEditComboBox = 0x471;
            public const int Toolbar1 = 0x440;
            public const int LookInToolbar = 0x4A0;
            public const int FolderView = 0x1;
            public const int FileNameStaticControl = 0x442;
            public const int FileNameEditComboBox = 0x47C;
            public const int FileNameTextBox = 0x47C;
            public const int SaveAsTypeStaticControl = 0x441;
            public const int FilesOfTypeEditComboBox = 0x470;
            public const int SaveButton = 0x1;
            public const int CancelButton = 0x2;
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedSaveInStaticControl;
        protected EditComboBox m_cachedLookInEditComboBox;
        protected Toolbar m_cachedToolbar1;
        protected Toolbar m_cachedLookInToolbar;
        protected ListView m_cachedFolderView;
        protected StaticControl m_cachedFileNameStaticControl;
        protected EditComboBox m_cachedFileNameEditComboBox;
        protected TextBox m_cachedFileNameTextBox;
        protected StaticControl m_cachedSaveAsTypeStaticControl;
        protected EditComboBox m_cachedFilesOfTypeEditComboBox;
        protected Button m_cachedSaveButton;
        protected Button m_cachedCancelButton;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Save As dialog in Mage tool
        ///  </summary>
        //  <param name="app">IDEApp object owning the dialog.</param>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SaveAsDialog(MageApp app) : 
                base(app, Init(app))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">IDEApp owning the dialog.</param>)
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MageApp app)
        {
            // First check if the dialog is already up.
            Window tempWindow = null;
            try
            {
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
            }
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the Save As dialog.", ex);
            }
            return tempWindow;
        }

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISaveAsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LookIn
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string LookIn
        {
            get
            {
                return Controls.LookInEditComboBox.Text;
            }
            set
            {
                Controls.LookInEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FileName
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FileName
        {
            get
            {
                return Controls.FileNameTextBox.Text;
            }
            set
            {
                Controls.FileNameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control FilesOfType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string FilesOfType
        {
            get
            {
                return Controls.FilesOfTypeEditComboBox.Text;
            }
            set
            {
                Controls.FilesOfTypeEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveInStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISaveAsDialogControls.SaveInStaticControl
        {
            get
            {
                if ((m_cachedSaveInStaticControl == null))
                {
                    m_cachedSaveInStaticControl = new StaticControl(this, ControlIDs.SaveInStaticControl);
                }
                return m_cachedSaveInStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISaveAsDialogControls.LookInEditComboBox
        {
            get
            {
                if ((m_cachedLookInEditComboBox == null))
                {
                    m_cachedLookInEditComboBox = new EditComboBox(this, ControlIDs.LookInEditComboBox);
                }
                return m_cachedLookInEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Toolbar1 control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar ISaveAsDialogControls.Toolbar1
        {
            get
            {
                if ((m_cachedToolbar1 == null))
                {
                    m_cachedToolbar1 = new Toolbar(this, ControlIDs.Toolbar1.ToString());
                }
                return m_cachedToolbar1;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LookInToolbar control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Toolbar ISaveAsDialogControls.LookInToolbar
        {
            get
            {
                if ((m_cachedLookInToolbar == null))
                {
                    m_cachedLookInToolbar = new Toolbar(this, ControlIDs.LookInToolbar.ToString());
                }
                return m_cachedLookInToolbar;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FolderView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView ISaveAsDialogControls.FolderView
        {
            get
            {
                if ((m_cachedFolderView == null))
                {
                    m_cachedFolderView = new ListView(this, ControlIDs.FolderView);
                }
                return m_cachedFolderView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISaveAsDialogControls.FileNameStaticControl
        {
            get
            {
                if ((m_cachedFileNameStaticControl == null))
                {
                    m_cachedFileNameStaticControl = new StaticControl(this, ControlIDs.FileNameStaticControl);
                }
                return m_cachedFileNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISaveAsDialogControls.FileNameEditComboBox
        {
            get
            {
                if ((m_cachedFileNameEditComboBox == null))
                {
                    m_cachedFileNameEditComboBox = new EditComboBox(this, ControlIDs.FileNameEditComboBox);
                }
                return m_cachedFileNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileNameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISaveAsDialogControls.FileNameTextBox
        {
            get
            {
                // The ID for this control (1148) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedFileNameTextBox == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 9); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    wndTemp = wndTemp.Extended.FirstChild;
                    wndTemp = wndTemp.Extended.FirstChild;
                    m_cachedFileNameTextBox = new TextBox(wndTemp);
                }
                return m_cachedFileNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveAsTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISaveAsDialogControls.SaveAsTypeStaticControl
        {
            get
            {
                if ((m_cachedSaveAsTypeStaticControl == null))
                {
                    m_cachedSaveAsTypeStaticControl = new StaticControl(this, ControlIDs.SaveAsTypeStaticControl);
                }
                return m_cachedSaveAsTypeStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FilesOfTypeEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ISaveAsDialogControls.FilesOfTypeEditComboBox
        {
            get
            {
                if ((m_cachedFilesOfTypeEditComboBox == null))
                {
                    m_cachedFilesOfTypeEditComboBox = new EditComboBox(this, ControlIDs.FilesOfTypeEditComboBox);
                }
                return m_cachedFilesOfTypeEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SaveButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISaveAsDialogControls.SaveButton
        {
            get
            {
                // The ID for this control (1) is used multiple times in this dialog.
                //  Investigate why and report a bug if necessary.  The generated code follows the window
                //  hierarchy path to find the control to work around this problem.
                if ((m_cachedSaveButton == null))
                {
                    Window wndTemp = this;
                    wndTemp = wndTemp.Extended.FirstChild;
                    int i;
                    for (i = 2; (i <= 13); i = (i + 1))
                    {
                        wndTemp = wndTemp.Extended.NextSibling;
                    }
                    m_cachedSaveButton = new Button(wndTemp);
                }
                return m_cachedSaveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISaveAsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Save
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickSave()
        {
            Controls.SaveButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/23/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Save As dialog is up already
		///  </summary>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Dialog, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\AppType.cs ===
using System;
using Maui.Mage.AppWindows;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{
#region "IAppTypeControls interface definition"
     
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IAppTypeControls
	{
		AppNameWindow Name {get;}
		AppFilesWindow File {get;}
		AppPermWindow Permission {get;}
	}

#endregion

	/// -----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: AppType
	///  Copyright (C) 2004, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  Class to describe the controls shown when an Application Manifest is opened
	///  </summary>
	///  <history>
	/// 	[a-dwils] 1/14/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class AppType : BaseFile, IAppTypeControls
	{

#region "Strings"
		public class Strings
		{
			public const string NameTitle = "Name";
			public const string FileTitle = "Files";
			public const string PermTitle = "Permissions Required";
		}
#endregion

#region "Member Variables"
		protected AppNameWindow m_cachedAppNameWindow;
		protected AppFilesWindow m_cachedAppFileWindow;
		protected AppPermWindow m_cachedAppPermWindow;
		public String m_ManName;
#endregion

#region "Constructors"
		/// <summary>
		/// Constructor that takes in the tab control that corresponds to the File
		/// </summary>
		/// <param name="Tab"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		public AppType(TabControlTab Tab, MageApp app) : base(Tab)
		{
			// Check to make sure window is correct type by checking
			//	elements in ListBox
			if ( (base.List[0].Text.CompareTo(app.GetIntlStr(Strings.NameTitle)) != 0) ||
				(base.List[1].Text.CompareTo(app.GetIntlStr(Strings.FileTitle)) != 0) ||
				(base.List[2].Text.CompareTo(app.GetIntlStr(Strings.PermTitle)) != 0))
			{
				throw (new Exception("TabControlTab opened was not of AppType."));
			}
			m_storedApp = app;
			m_ManName = Tab.Text + "*";
		}
#endregion

#region "Properties"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>An interface that groups all of the window's control properties together</value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IAppTypeControls Controls
		{
			get
			{
				return this;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Name window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		AppNameWindow IAppTypeControls.Name
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.NameTitle)].Click();
				if ((m_cachedAppNameWindow == null))
				{
					m_cachedAppNameWindow = new AppNameWindow(this, m_ManName);
				}
				return m_cachedAppNameWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the File window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		AppFilesWindow IAppTypeControls.File
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.FileTitle)].Click();
				if ((m_cachedAppFileWindow == null))
				{
					m_cachedAppFileWindow = new AppFilesWindow(this, m_ManName);
				}
				return m_cachedAppFileWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Permission window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		AppPermWindow IAppTypeControls.Permission
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.PermTitle)].Click();
				if ((m_cachedAppPermWindow == null))
				{
					m_cachedAppPermWindow = new AppPermWindow(this, m_ManName);
				}
				return m_cachedAppPermWindow;
			}
		}
#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\DepType.cs ===
using System;
using Maui.Mage.DepWindows;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{
	#region "IDepTypeControls interface definition"
     
	[EditorBrowsable(EditorBrowsableState.Never)]
	public interface IDepTypeControls
	{
		DepAppRefWindow AppRef {get;}
		DepDescWindow Desc {get;}
		DepNameWindow Name {get;}
		DepTLWindow TL {get;}
		DepUpdateWindow Update {get;}
	}

	#endregion

	/// -----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: DepType
	///  Copyright (C) 2004, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  Class to describe the controls shown when a Deployment Manifest is opened
	///  </summary>
	///  <history>
	/// 	[a-dwils] 1/14/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class DepType : BaseFile, IDepTypeControls
	{

#region "Strings"
		public class Strings
		{
			public const string NameTitle = "Name";
			public const string DescTitle = "Description";
			public const string UpdateTitle = "Update Options";
			public const string AppTitle = "Application Reference";
			public const string TLTitle = "Trust Licenses";
		}
#endregion

#region "Member Variables"
		protected DepAppRefWindow m_cachedDepAppRefWindow;
		protected DepDescWindow m_cachedDepDescWindow;
		protected DepNameWindow m_cachedDepNameWindow;
		protected DepTLWindow m_cachedDepTLWindow;
		protected DepUpdateWindow m_cachedDepUpdateWindow;
		public String m_ManName;
#endregion

#region "Constructors"
		/// <summary>
		/// Constructor for DepType that takes in the Tab corresponding to the file
		/// </summary>
		/// <param name="Tab"></param>
		/// <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		///  
		public DepType(TabControlTab Tab, MageApp app) : base(Tab)
		{
			// Check to make sure window is correct type by checking
			//	elements in ListBox
			if ( (base.List[0].Text.CompareTo(app.GetIntlStr(Strings.NameTitle)) != 0) ||
				(base.List[1].Text.CompareTo(app.GetIntlStr(Strings.DescTitle)) != 0) ||
				(base.List[2].Text.CompareTo(app.GetIntlStr(Strings.UpdateTitle)) != 0) ||
				(base.List[3].Text.CompareTo(app.GetIntlStr(Strings.AppTitle)) != 0) ||
				(base.List[4].Text.CompareTo(app.GetIntlStr(Strings.TLTitle))!= 0))
			{
				throw (new Exception("TabControlTab opened was not of DepType."));
			}
			m_storedApp = app;
			m_ManName = Tab.Text + "*";
		}
#endregion

		#region "Properties"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>An interface that groups all of the window's control properties together</value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual IDepTypeControls Controls
		{
			get
			{
				return this;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Application Reference window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepAppRefWindow IDepTypeControls.AppRef
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.AppTitle)].Click();
				if ((m_cachedDepAppRefWindow == null))
				{
					m_cachedDepAppRefWindow = new DepAppRefWindow(this, m_ManName);
				}
				return m_cachedDepAppRefWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Description window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepDescWindow IDepTypeControls.Desc
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.DescTitle)].Click();
				if ((m_cachedDepDescWindow == null))
				{
					m_cachedDepDescWindow = new DepDescWindow(this, m_ManName);
				}
				return m_cachedDepDescWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Name window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepNameWindow IDepTypeControls.Name
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.NameTitle)].Click();
				if ((m_cachedDepNameWindow == null))
				{
					m_cachedDepNameWindow = new DepNameWindow(this, m_ManName);
				}
				return m_cachedDepNameWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Trust Licenses window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepTLWindow IDepTypeControls.TL
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.TLTitle)].Click();
				if ((m_cachedDepTLWindow == null))
				{
					m_cachedDepTLWindow = new DepTLWindow(this, m_ManName);
				}
				return m_cachedDepTLWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Update Options window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		DepUpdateWindow IDepTypeControls.Update
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.UpdateTitle)].Click();
				if ((m_cachedDepUpdateWindow == null))
				{
					m_cachedDepUpdateWindow = new DepUpdateWindow(this, m_ManName);
				}
				return m_cachedDepUpdateWindow;
			}
		}

		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\LicType.cs ===
using System;
using Maui.Mage.LicWindows;
using Maui.Core;
using Maui.Core.WinControls;
using Maui.Core.Utilities;
using System.ComponentModel;
using System.Drawing;

namespace Maui.Mage
{

#region "ILicTypeControls interface definition"
     
		[EditorBrowsable(EditorBrowsableState.Never)]
		public interface ILicTypeControls
		{
			LicAppTrustWindow AppTrust  {get;}
			LicConditionsWindow Conditions {get;}
			LicPubTrustWindow PubTrust {get;}
			LicTitleWindow LicTitle {get;}
		}
#endregion

	/// -----------------------------------------------------------------------------
	/// Project		: Maui.Mage
	/// Class		: LicType
	///  Copyright (C) 2004, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
	///  Class to describe the controls shown when an Trust License is opened
	///  </summary>
	///  <history>
	/// 	[a-dwils] 1/14/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class LicType : BaseFile, ILicTypeControls
	{

#region "Strings"
		public class Strings
		{
			public const string LicTitle = "License Title";
			public const string AppTitle = "Application Being Trusted";
			public const string PubTitle = "Publisher Being Trusted";
			public const string CondTitle = "Conditions";
		}
#endregion

#region "Member Variables"
			LicAppTrustWindow m_cachedLicAppTrustWindow;
			LicConditionsWindow m_cachedLicConditionsWindow;
			LicPubTrustWindow m_cachedLicPubTrustWindow;
			LicTitleWindow m_cachedLicTitleWindow;
			public String m_ManName;
#endregion

#region "Constructors"
		/// <summary>
		/// Constructor for DepType that takes in the Tab corresponding to the file
		/// </summary>
		/// <param name="Tab"></param>
		/// <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		public LicType(TabControlTab Tab, MageApp app) : base(Tab)
		{
			// Check to make sure window is correct type by checking
			//	elements in ListBox
			if ( (base.List[0].Text.CompareTo(app.GetIntlStr(Strings.LicTitle)) != 0) ||
				(base.List[1].Text.CompareTo(app.GetIntlStr(Strings.AppTitle)) != 0) ||
				(base.List[2].Text.CompareTo(app.GetIntlStr(Strings.PubTitle)) != 0) ||
				(base.List[3].Text.CompareTo(app.GetIntlStr(Strings.CondTitle)) != 0) )
			{
				throw (new Exception("TabControlTab opened was not of LicType."));
			}
			m_storedApp = app;
			m_ManName = Tab.Text + "*";
		}
#endregion

#region "Properties"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the raw controls for this window
		///  </summary>
		///  <value>An interface that groups all of the window's control properties together</value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public virtual ILicTypeControls Controls
		{
			get
			{
				return this;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Application Being Trusted window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicAppTrustWindow ILicTypeControls.AppTrust
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.AppTitle)].Click();
				if ((m_cachedLicAppTrustWindow == null))
				{
					m_cachedLicAppTrustWindow = new LicAppTrustWindow(this, m_ManName);
				}
				return m_cachedLicAppTrustWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Conditions window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicConditionsWindow ILicTypeControls.Conditions
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.CondTitle)].Click();
				if ((m_cachedLicConditionsWindow == null))
				{
					m_cachedLicConditionsWindow = new LicConditionsWindow(this, m_ManName);
				}
				return m_cachedLicConditionsWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the Publisher Being Trusted window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicPubTrustWindow ILicTypeControls.PubTrust
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.PubTitle)].Click();
				if ((m_cachedLicPubTrustWindow == null))
				{
					m_cachedLicPubTrustWindow = new LicPubTrustWindow(this, m_ManName);
				}
				return m_cachedLicPubTrustWindow;
			}
		}

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Exposes access to the License Title window
		///  </summary>
		///  <value></value>
		///  <remarks></remarks>
		///  <history>
		/// 	[a-dwils] 1/16/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		LicTitleWindow ILicTypeControls.LicTitle
		{
			get
			{
				this.List[m_storedApp.GetIntlStr(Strings.LicTitle)].Click();
				if ((m_cachedLicTitleWindow == null))
				{
					m_cachedLicTitleWindow = new LicTitleWindow(this, m_ManName);
				}
				return m_cachedLicTitleWindow;
			}
		}

#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\DepWindows\DepDescWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepDescWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepDescWindowControls
    {
        StaticControl PublisherStaticControl  {get;}
        TextBox PermissionSetTypeTextBox  {get;}
        StaticControl ProductStaticControl  {get;}
        TextBox NameTextBox  {get;}
        StaticControl SupportURLStaticControl  {get;}
        TextBox VersionTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepDescWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Description window for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepDescWindow : Window, IDepDescWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Description";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string PublisherStaticControl = "lblPublisher";
            public const string PermissionSetTypeTextBox = "txtPublisher";
            public const string ProductStaticControl = "lblProduct";
            public const string NameTextBox = "txtProduct";
            public const string SupportURLStaticControl = "lblSupportUrl";
            public const string VersionTextBox = "txtSupportUrl";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedPublisherStaticControl;
        protected TextBox m_cachedPermissionSetTypeTextBox;
        protected StaticControl m_cachedProductStaticControl;
        protected TextBox m_cachedNameTextBox;
        protected StaticControl m_cachedSupportURLStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Description window for Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepDescWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepDescWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PermissionSetType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PermissionSetType
        {
            get
            {
                return Controls.PermissionSetTypeTextBox.Text;
            }
            set
            {
                Controls.PermissionSetTypeTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublisherStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepDescWindowControls.PublisherStaticControl
        {
            get
            {
                if ((m_cachedPublisherStaticControl == null))
                {
                    m_cachedPublisherStaticControl = new StaticControl(this, ControlIDs.PublisherStaticControl);
                }
                return m_cachedPublisherStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PermissionSetTypeTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepDescWindowControls.PermissionSetTypeTextBox
        {
            get
            {
                if ((m_cachedPermissionSetTypeTextBox == null))
                {
                    m_cachedPermissionSetTypeTextBox = new TextBox(this, ControlIDs.PermissionSetTypeTextBox);
                }
                return m_cachedPermissionSetTypeTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProductStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepDescWindowControls.ProductStaticControl
        {
            get
            {
                if ((m_cachedProductStaticControl == null))
                {
                    m_cachedProductStaticControl = new StaticControl(this, ControlIDs.ProductStaticControl);
                }
                return m_cachedProductStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepDescWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SupportURLStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepDescWindowControls.SupportURLStaticControl
        {
            get
            {
                if ((m_cachedSupportURLStaticControl == null))
                {
                    m_cachedSupportURLStaticControl = new StaticControl(this, ControlIDs.SupportURLStaticControl);
                }
                return m_cachedSupportURLStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepDescWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\SigningOptionsDialog.cs ===
namespace Maui.Mage
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;


#region "ISigningOptionsDialogControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ISigningOptionsDialogControls
    {
        PropertyGridView KeyFilePropertyGridView  {get;}
        RadioButton SignWithStoredCertificateRadioButton  {get;}
        TextBox PasswordTextBox  {get;}
        StaticControl PasswordStaticControl  {get;}
        Button BrowseCerts  {get;}
        TextBox CertTextBox  {get;}
        StaticControl FileStaticControl  {get;}
        RadioButton SignWithCertificateFileRadioButton  {get;}
        Button NewButton  {get;}
        Button BrowseKeys  {get;}
        TextBox KeyTextBox  {get;}
        StaticControl FileStaticControl2  {get;}
        RadioButton SignWithKeypairFileRadioButton  {get;}
        Button DontSignButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }

#endregion


#region "Enums for RadioButton groups"
    
    
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioSigningOptions
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    /// 	[a-dwils] 3/08/2004 Changed name from RadioGroup0 to RadioSigningOptions
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioSigningOptions
    {
        SignWithStoredCertificate = 0,
        SignWithCertificateFile = 1,
        SignWithKeypairFile = 2,
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: SigningOptionsDialog
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Signing Options dialog in Mage
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class SigningOptionsDialog : Dialog, ISigningOptionsDialogControls
    {


#region "Strings"
        public class Strings
        {
            public const string DialogTitle = "Signing Options - ";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string KeyFilePropertyGridView = "grid";
            public const string SignWithStoredCertificateRadioButton = "rbStoredCert";
            public const string PasswordTextBox = "txtCertPassword";
            public const string PasswordStaticControl = "lblPassword";
            public const string BrowseCerts = "btnCertBrowse";
            public const string CertTextBox = "txtCertFile";
            public const string FileStaticControl = "lblCertFile";
            public const string SignWithCertificateFileRadioButton = "rbCertFile";
            public const string NewButton = "btnNewKeyFile";
            public const string BrowseKeys = "btnBrowseKeyFile";
            public const string KeyTextBox = "txtKeyFile";
            public const string FileStaticControl2 = "lblKeyFile";
            public const string SignWithKeypairFileRadioButton = "rbKeyFile";
            public const string DontSignButton = "btnDontSign";
            public const string OKButton = "btnOK";
            public const string CancelButton = "btnCancel";
        }

#endregion

#region "Member Variables"
        protected PropertyGridView m_cachedKeyFilePropertyGridView;
        protected RadioButton m_cachedSignWithStoredCertificateRadioButton;
        protected TextBox m_cachedPasswordTextBox;
        protected StaticControl m_cachedPasswordStaticControl;
        protected Button m_cachedBrowseCerts;
        protected TextBox m_cachedCertTextBox;
        protected StaticControl m_cachedFileStaticControl;
        protected RadioButton m_cachedSignWithCertificateFileRadioButton;
        protected Button m_cachedNewButton;
        protected Button m_cachedBrowseKeys;
        protected TextBox m_cachedKeyTextBox;
        protected StaticControl m_cachedFileStaticControl2;
        protected RadioButton m_cachedSignWithKeypairFileRadioButton;
        protected Button m_cachedDontSignButton;
        protected Button m_cachedOKButton;
        protected Button m_cachedCancelButton;

#endregion

#region "Constructor and Init function"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Constructor for Signing Options dialog in Mage, calls base constructor with
        ///  instance from Init function
        ///  </summary>
        ///  <param name="app">MageApp object owning the dialog.</param>
        ///  <param name="Title"></param>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public SigningOptionsDialog(MageApp app, string Title) : 
                base(app, Init(app, Title))
        {
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MageApp owning the dialog.</param>
        ///  <param name="Title"></param>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
		private static Window Init(MageApp app, string Title)
		{
			// First check if the dialog is already up.
			Window tempWindow = null;
			try
			{
				// Using WildCard match right now until bug 248525 is fixed
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.WildCard, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
				//tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle) + Title, StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				throw new Window.Exceptions.WindowNotFoundException("Init function could not find the Signing Options dialog.", ex);
			}
			return tempWindow;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ISigningOptionsDialogControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioSigningOptions
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioSigningOptions RadioSigningOptions
        {
            get
            {
                if ((Controls.SignWithStoredCertificateRadioButton.ButtonState == ButtonState.Checked))
                    return RadioSigningOptions.SignWithStoredCertificate;

                if ((Controls.SignWithCertificateFileRadioButton.ButtonState == ButtonState.Checked))
                    return RadioSigningOptions.SignWithCertificateFile;

                if ((Controls.SignWithKeypairFileRadioButton.ButtonState == ButtonState.Checked))
                    return RadioSigningOptions.SignWithKeypairFile;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioSigningOptions.SignWithStoredCertificate))
                    Controls.SignWithStoredCertificateRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioSigningOptions.SignWithCertificateFile))
                    Controls.SignWithCertificateFileRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioSigningOptions.SignWithKeypairFile))
                    Controls.SignWithKeypairFileRadioButton.ButtonState = ButtonState.Checked;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Password
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Password
        {
            get
            {
                return Controls.PasswordTextBox.Text;
            }
            set
            {
                Controls.PasswordTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control File
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string File
        {
            get
            {
                return Controls.CertTextBox.Text;
            }
            set
            {
                Controls.CertTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control File2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string File2
        {
            get
            {
                return Controls.KeyTextBox.Text;
            }
            set
            {
                Controls.KeyTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyFilePropertyGridView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        PropertyGridView ISigningOptionsDialogControls.KeyFilePropertyGridView
        {
            get
            {
                if ((m_cachedKeyFilePropertyGridView == null))
                {
                    m_cachedKeyFilePropertyGridView = new PropertyGridView(this);//, ControlIDs.KeyFilePropertyGridView);
                }
                return m_cachedKeyFilePropertyGridView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignWithStoredCertificateRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISigningOptionsDialogControls.SignWithStoredCertificateRadioButton
        {
            get
            {
                if ((m_cachedSignWithStoredCertificateRadioButton == null))
                {
                    m_cachedSignWithStoredCertificateRadioButton = new RadioButton(this, ControlIDs.SignWithStoredCertificateRadioButton);
                }
                return m_cachedSignWithStoredCertificateRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PasswordTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISigningOptionsDialogControls.PasswordTextBox
        {
            get
            {
                if ((m_cachedPasswordTextBox == null))
                {
                    m_cachedPasswordTextBox = new TextBox(this, ControlIDs.PasswordTextBox);
                }
                return m_cachedPasswordTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PasswordStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISigningOptionsDialogControls.PasswordStaticControl
        {
            get
            {
                if ((m_cachedPasswordStaticControl == null))
                {
                    m_cachedPasswordStaticControl = new StaticControl(this, ControlIDs.PasswordStaticControl);
                }
                return m_cachedPasswordStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BrowseCerts control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.BrowseCerts
        {
            get
            {
                if ((m_cachedBrowseCerts == null))
                {
                    m_cachedBrowseCerts = new Button(this, ControlIDs.BrowseCerts);
                }
                return m_cachedBrowseCerts;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CertTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISigningOptionsDialogControls.CertTextBox
        {
            get
            {
                if ((m_cachedCertTextBox == null))
                {
                    m_cachedCertTextBox = new TextBox(this, ControlIDs.CertTextBox);
                }
                return m_cachedCertTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISigningOptionsDialogControls.FileStaticControl
        {
            get
            {
                if ((m_cachedFileStaticControl == null))
                {
                    m_cachedFileStaticControl = new StaticControl(this, ControlIDs.FileStaticControl);
                }
                return m_cachedFileStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignWithCertificateFileRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISigningOptionsDialogControls.SignWithCertificateFileRadioButton
        {
            get
            {
                if ((m_cachedSignWithCertificateFileRadioButton == null))
                {
                    m_cachedSignWithCertificateFileRadioButton = new RadioButton(this, ControlIDs.SignWithCertificateFileRadioButton);
                }
                return m_cachedSignWithCertificateFileRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NewButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.NewButton
        {
            get
            {
                if ((m_cachedNewButton == null))
                {
                    m_cachedNewButton = new Button(this, ControlIDs.NewButton);
                }
                return m_cachedNewButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BrowseKeys control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.BrowseKeys
        {
            get
            {
                if ((m_cachedBrowseKeys == null))
                {
                    m_cachedBrowseKeys = new Button(this, ControlIDs.BrowseKeys);
                }
                return m_cachedBrowseKeys;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the KeyTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ISigningOptionsDialogControls.KeyTextBox
        {
            get
            {
                if ((m_cachedKeyTextBox == null))
                {
                    m_cachedKeyTextBox = new TextBox(this, ControlIDs.KeyTextBox);
                }
                return m_cachedKeyTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the FileStaticControl2 control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ISigningOptionsDialogControls.FileStaticControl2
        {
            get
            {
                if ((m_cachedFileStaticControl2 == null))
                {
                    m_cachedFileStaticControl2 = new StaticControl(this, ControlIDs.FileStaticControl2);
                }
                return m_cachedFileStaticControl2;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SignWithKeypairFileRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ISigningOptionsDialogControls.SignWithKeypairFileRadioButton
        {
            get
            {
                if ((m_cachedSignWithKeypairFileRadioButton == null))
                {
                    m_cachedSignWithKeypairFileRadioButton = new RadioButton(this, ControlIDs.SignWithKeypairFileRadioButton);
                }
                return m_cachedSignWithKeypairFileRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DontSignButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.DontSignButton
        {
            get
            {
                if ((m_cachedDontSignButton == null))
                {
                    m_cachedDontSignButton = new Button(this, ControlIDs.DontSignButton);
                }
                return m_cachedDontSignButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ISigningOptionsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis1
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis1()
        {
            Controls.BrowseCerts.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button New
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickNew()
        {
            Controls.NewButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis2()
        {
            Controls.BrowseKeys.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button DontSign
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickDontSign()
        {
            Controls.DontSignButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button OK
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickOK()
        {
            Controls.OKButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickCancel()
        {
            Controls.CancelButton.Click();
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Routine to detect if the Signing Options dialog is up already
		///  </summary>
		///  <history>
		/// 	[a-dwils] 2/23/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		static public bool Exists(MageApp app)
		{
			bool retVal = true;
			Window tempWindow = null;
			try
			{
				// Using WildCard match right now until bug 248525 is fixed
				tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.WildCard, WindowClassNames.WinForms10Window8, StringMatchSyntax.WildCard, new Desktop(), 3000);
				//tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle) + Title, StringMatchSyntax.ExactMatch, WindowClassNames.WinForms10Window8, StringMatchSyntax.ExactMatch, new Desktop(), 3000);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{
				retVal = false;
			}
			return retVal;
		}

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\AppWindows\AppPermWindow.cs ===
namespace Maui.Mage.AppWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IAppPermWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAppPermWindowControls
    {
        StaticControl DetailsStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        EditComboBox NameEditComboBox  {get;}
        StaticControl PermissionSetTypeStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: AppPermWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Permissions window for Application Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AppPermWindow : Window, IAppPermWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Permissions Required";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string DetailsStaticControl = "label2";
            public const string VersionTextBox = "textBox";
            public const string NameEditComboBox = "cbxPermissions";
            public const string PermissionSetTypeStaticControl = "label1";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedDetailsStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected EditComboBox m_cachedNameEditComboBox;
        protected StaticControl m_cachedPermissionSetTypeStaticControl;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Permissions window of Application Manifests
		///  </summary>
		///  <param name="app">Window object owning the window.</param>
		///  <param name="Title"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AppPermWindow(AppType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(AppType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAppPermWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameEditComboBox.Text;
            }
            set
            {
                Controls.NameEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DetailsStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppPermWindowControls.DetailsStaticControl
        {
            get
            {
                if ((m_cachedDetailsStaticControl == null))
                {
                    m_cachedDetailsStaticControl = new StaticControl(this, ControlIDs.DetailsStaticControl);
                }
                return m_cachedDetailsStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppPermWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAppPermWindowControls.NameEditComboBox
        {
            get
            {
                if ((m_cachedNameEditComboBox == null))
                {
                    m_cachedNameEditComboBox = new EditComboBox(this, ControlIDs.NameEditComboBox);
                }
                return m_cachedNameEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PermissionSetTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppPermWindowControls.PermissionSetTypeStaticControl
        {
            get
            {
                if ((m_cachedPermissionSetTypeStaticControl == null))
                {
                    m_cachedPermissionSetTypeStaticControl = new StaticControl(this, ControlIDs.PermissionSetTypeStaticControl);
                }
                return m_cachedPermissionSetTypeStaticControl;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\DepWindows\DepTLWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepTLWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepTLWindowControls
    {
        Button ExportButton  {get;}
        Button RemoveButton  {get;}
        Button AddButton  {get;}
        ListBox NameListBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepTLWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Trust License window for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepTLWindow : Window, IDepTLWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Trust Licenses";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string ExportButton = "btnExport";
            public const string RemoveButton = "btnRemove";
            public const string AddButton = "btnAdd";
            public const string NameListBox = "lbxLicenses";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedExportButton;
        protected Button m_cachedRemoveButton;
        protected Button m_cachedAddButton;
        protected ListBox m_cachedNameListBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Trust License window for Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepTLWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepTLWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExportButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepTLWindowControls.ExportButton
        {
            get
            {
                if ((m_cachedExportButton == null))
                {
                    m_cachedExportButton = new Button(this, ControlIDs.ExportButton);
                }
                return m_cachedExportButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RemoveButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepTLWindowControls.RemoveButton
        {
            get
            {
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepTLWindowControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameListBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox IDepTLWindowControls.NameListBox
        {
            get
            {
                if ((m_cachedNameListBox == null))
                {
                    m_cachedNameListBox = new ListBox(this, ControlIDs.NameListBox);
                }
                return m_cachedNameListBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Export
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickExport()
        {
            Controls.ExportButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Remove
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickRemove()
        {
            Controls.RemoveButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Add
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickAdd()
        {
            Controls.AddButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\AppWindows\AppNameWindow.cs ===
namespace Maui.Mage.AppWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IAppNameWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAppNameWindowControls
    {
        StaticControl NameStaticControl  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox NameTextBox  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox ProcessorEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl PublicKeyTokenStaticControl  {get;}
        TextBox PublicKeyTokenTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: AppNameWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the Name window for Application Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AppNameWindow : Window, IAppNameWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Name";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string NameStaticControl = "lblName";
            public const string VersionStaticControl = "lblVersion";
            public const string NameTextBox = "txtName";
            public const string VersionTextBox = "txtVersion";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string ProcessorEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string CultureEditComboBox = "cbxCulture";
            public const string PublicKeyTokenStaticControl = "lblPublicKeyToken";
            public const string PublicKeyTokenTextBox = "txtPublicKeyToken";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedNameStaticControl;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedNameTextBox;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedProcessorEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedPublicKeyTokenStaticControl;
        protected TextBox m_cachedPublicKeyTokenTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for the Name window for Application Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		//  <param name="Title"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AppNameWindow(AppType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(AppType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAppNameWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Processor
        {
            get
            {
                return Controls.ProcessorEditComboBox.Text;
            }
            set
            {
                Controls.ProcessorEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken
        {
            get
            {
                return Controls.PublicKeyTokenTextBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppNameWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppNameWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAppNameWindowControls.ProcessorEditComboBox
        {
            get
            {
                if ((m_cachedProcessorEditComboBox == null))
                {
                    m_cachedProcessorEditComboBox = new EditComboBox(this, ControlIDs.ProcessorEditComboBox);
                }
                return m_cachedProcessorEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAppNameWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppNameWindowControls.PublicKeyTokenStaticControl
        {
            get
            {
                if ((m_cachedPublicKeyTokenStaticControl == null))
                {
                    m_cachedPublicKeyTokenStaticControl = new StaticControl(this, ControlIDs.PublicKeyTokenStaticControl);
                }
                return m_cachedPublicKeyTokenStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppNameWindowControls.PublicKeyTokenTextBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenTextBox == null))
                {
                    m_cachedPublicKeyTokenTextBox = new TextBox(this, ControlIDs.PublicKeyTokenTextBox);
                }
                return m_cachedPublicKeyTokenTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\AppWindows\AppFilesWindow.cs ===
namespace Maui.Mage.AppWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IAppFilesWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAppFilesWindowControls
    {
        StaticControl LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl  {get;}
        Button PopulateButton  {get;}
        Button EllipsisButton  {get;}
        TextBox NameTextBox  {get;}
        PropertyGridView VersionPropertyGridView  {get;}
        StaticControl ApplicationFilesStaticControl  {get;}
        StaticControl ApplicationDirectoryStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: AppFilesWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Class to describe the controls on the Files window for Application Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AppFilesWindow : Window, IAppFilesWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Files";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl = "label3";
            public const string PopulateButton = "btnPopulate";
            public const string EllipsisButton = "btnBrowse";
            public const string NameTextBox = "txtDirectory";
            public const string VersionPropertyGridView = "grid";
            public const string ApplicationFilesStaticControl = "label2";
            public const string ApplicationDirectoryStaticControl = "label1";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl;
        protected Button m_cachedPopulateButton;
        protected Button m_cachedEllipsisButton;
        protected TextBox m_cachedNameTextBox;
        protected PropertyGridView m_cachedVersionPropertyGridView;
        protected StaticControl m_cachedApplicationFilesStaticControl;
        protected StaticControl m_cachedApplicationDirectoryStaticControl;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for File window
		///  </summary>
		///  <param name="app">Window object owning the window.</param>
		///  <param name="Title"></param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AppFilesWindow(AppType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(AppType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAppFilesWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppFilesWindowControls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl
        {
            get
            {
                if ((m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl == null))
                {
                    m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl = new StaticControl(this, ControlIDs.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl);
                }
                return m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PopulateButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAppFilesWindowControls.PopulateButton
        {
            get
            {
                if ((m_cachedPopulateButton == null))
                {
                    m_cachedPopulateButton = new Button(this, ControlIDs.PopulateButton);
                }
                return m_cachedPopulateButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EllipsisButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAppFilesWindowControls.EllipsisButton
        {
            get
            {
                if ((m_cachedEllipsisButton == null))
                {
                    m_cachedEllipsisButton = new Button(this, ControlIDs.EllipsisButton);
                }
                return m_cachedEllipsisButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAppFilesWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionPropertyGridView control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        PropertyGridView IAppFilesWindowControls.VersionPropertyGridView
        {
            get
            {
                if ((m_cachedVersionPropertyGridView == null))
                {
                    m_cachedVersionPropertyGridView = new PropertyGridView((this));//, ControlIDs.VersionPropertyGridView);
                }
                return m_cachedVersionPropertyGridView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationFilesStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppFilesWindowControls.ApplicationFilesStaticControl
        {
            get
            {
                if ((m_cachedApplicationFilesStaticControl == null))
                {
                    m_cachedApplicationFilesStaticControl = new StaticControl(this, ControlIDs.ApplicationFilesStaticControl);
                }
                return m_cachedApplicationFilesStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationDirectoryStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IAppFilesWindowControls.ApplicationDirectoryStaticControl
        {
            get
            {
                if ((m_cachedApplicationDirectoryStaticControl == null))
                {
                    m_cachedApplicationDirectoryStaticControl = new StaticControl(this, ControlIDs.ApplicationDirectoryStaticControl);
                }
                return m_cachedApplicationDirectoryStaticControl;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Populate
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickPopulate()
        {
            Controls.PopulateButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Ellipsis0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickEllipsis0()
        {
            Controls.EllipsisButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\LicWindows\LicTitleWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicTitleWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicTitleWindowControls
    {
        StaticControl TitleStaticControl  {get;}
        TextBox LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicTitleWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the License Title page for Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicTitleWindow : Window, ILicTitleWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "License Title";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string TitleStaticControl = "lblTitle";
            public const string LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox = "txtTitle";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedTitleStaticControl;
        protected TextBox m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for License Title window for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicTitleWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicTitleWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManually
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManually
        {
            get
            {
                return Controls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox.Text;
            }
            set
            {
                Controls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TitleStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicTitleWindowControls.TitleStaticControl
        {
            get
            {
                if ((m_cachedTitleStaticControl == null))
                {
                    m_cachedTitleStaticControl = new StaticControl(this, ControlIDs.TitleStaticControl);
                }
                return m_cachedTitleStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicTitleWindowControls.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox
        {
            get
            {
                if ((m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox == null))
                {
                    m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox = new TextBox(this, ControlIDs.LocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox);
                }
                return m_cachedLocateTheApplicationDirectoryToPopulateTheTableWithTheApplicationFilesOrAddThemManuallyTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\DepWindows\DepAppRefWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepAppRefWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepAppRefWindowControls
    {
        StaticControl ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl  {get;}
        Button SelectManifestButton  {get;}
        StaticControl LocationStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl NameStaticControl  {get;}
        TextBox ExampleHttpServershareTextBox  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox ProcessorTextBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox PublicKeyTokenEditComboBox  {get;}
        StaticControl PublicKeyTokenStaticControl  {get;}
        TextBox CultureTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepAppRefWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls shown on the Application Reference page for
    ///  Deployment Manifests
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepAppRefWindow : Window, IDepAppRefWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Application Reference";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl = "lblInstructions";
            public const string SelectManifestButton = "btnBrowse";
            public const string LocationStaticControl = "lblLocation";
            public const string VersionTextBox = "txtLocation";
            public const string NameStaticControl = "lblName";
            public const string ExampleHttpServershareTextBox = "txtName";
            public const string VersionStaticControl = "lblVersion";
            public const string ProcessorTextBox = "txtVersion";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string CultureEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string PublicKeyTokenEditComboBox = "cbxCulture";
            public const string PublicKeyTokenStaticControl = "lblPublicKeyToken";
            public const string CultureTextBox = "txtPublicKeyToken";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl;
        protected Button m_cachedSelectManifestButton;
        protected StaticControl m_cachedLocationStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedNameStaticControl;
        protected TextBox m_cachedExampleHttpServershareTextBox;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedProcessorTextBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedPublicKeyTokenEditComboBox;
        protected StaticControl m_cachedPublicKeyTokenStaticControl;
        protected TextBox m_cachedCultureTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Application Referecne window of Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepAppRefWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepAppRefWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ExampleHttpServershare
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string ExampleHttpServershare
        {
            get
            {
                return Controls.ExampleHttpServershareTextBox.Text;
            }
            set
            {
                Controls.ExampleHttpServershareTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Processor
        {
            get
            {
                return Controls.ProcessorTextBox.Text;
            }
            set
            {
                Controls.ProcessorTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken
        {
            get
            {
                return Controls.PublicKeyTokenEditComboBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture2
        {
            get
            {
                return Controls.CultureTextBox.Text;
            }
            set
            {
                Controls.CultureTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl
        {
            get
            {
                if ((m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl == null))
                {
                    m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl = new StaticControl(this, ControlIDs.ClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl);
                }
                return m_cachedClickOnTheSelectManifestButtonToSelectAnApplicationManifestStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SelectManifestButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IDepAppRefWindowControls.SelectManifestButton
        {
            get
            {
                if ((m_cachedSelectManifestButton == null))
                {
                    m_cachedSelectManifestButton = new Button(this, ControlIDs.SelectManifestButton);
                }
                return m_cachedSelectManifestButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LocationStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.LocationStaticControl
        {
            get
            {
                if ((m_cachedLocationStaticControl == null))
                {
                    m_cachedLocationStaticControl = new StaticControl(this, ControlIDs.LocationStaticControl);
                }
                return m_cachedLocationStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.ExampleHttpServershareTextBox
        {
            get
            {
                if ((m_cachedExampleHttpServershareTextBox == null))
                {
                    m_cachedExampleHttpServershareTextBox = new TextBox(this, ControlIDs.ExampleHttpServershareTextBox);
                }
                return m_cachedExampleHttpServershareTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.ProcessorTextBox
        {
            get
            {
                if ((m_cachedProcessorTextBox == null))
                {
                    m_cachedProcessorTextBox = new TextBox(this, ControlIDs.ProcessorTextBox);
                }
                return m_cachedProcessorTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepAppRefWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepAppRefWindowControls.PublicKeyTokenEditComboBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenEditComboBox == null))
                {
                    m_cachedPublicKeyTokenEditComboBox = new EditComboBox(this, ControlIDs.PublicKeyTokenEditComboBox);
                }
                return m_cachedPublicKeyTokenEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepAppRefWindowControls.PublicKeyTokenStaticControl
        {
            get
            {
                if ((m_cachedPublicKeyTokenStaticControl == null))
                {
                    m_cachedPublicKeyTokenStaticControl = new StaticControl(this, ControlIDs.PublicKeyTokenStaticControl);
                }
                return m_cachedPublicKeyTokenStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepAppRefWindowControls.CultureTextBox
        {
            get
            {
                if ((m_cachedCultureTextBox == null))
                {
                    m_cachedCultureTextBox = new TextBox(this, ControlIDs.CultureTextBox);
                }
                return m_cachedCultureTextBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button SelectManifest
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickSelectManifest()
        {
            Controls.SelectManifestButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\DepWindows\DepNameWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepNameWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepNameWindowControls
    {
        StaticControl NameStaticControl  {get;}
        TextBox PermissionSetTypeTextBox  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox NameTextBox  {get;}
        StaticControl Example1000StaticControl  {get;}
        StaticControl RunLocationStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl ExampleHttpServershareStaticControl  {get;}
        StaticControl ApplicationTypeStaticControl  {get;}
        EditComboBox ProcessorEditComboBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox PublicKeyTokenEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl PublicKeyTokenStaticControl  {get;}
        TextBox PublicKeyTokenTextBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepNameWindow
    ///  Copyright (C) 2004 Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Name window for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepNameWindow : Window, IDepNameWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Name";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string NameStaticControl = "lblName";
            public const string PermissionSetTypeTextBox = "txtName";
            public const string VersionStaticControl = "lblVersion";
            public const string NameTextBox = "txtVersion";
            public const string Example1000StaticControl = "lblVersionExample";
            public const string RunLocationStaticControl = "lblRunLocation";
            public const string VersionTextBox = "txtLocation";
            public const string ExampleHttpServershareStaticControl = "lblRunLocationExample";
            public const string ApplicationTypeStaticControl = "lblApplicationType";
            public const string ProcessorEditComboBox = "cbxApplicationType";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string PublicKeyTokenEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string CultureEditComboBox = "cbxCulture";
            public const string PublicKeyTokenStaticControl = "lblPublicKeyToken";
            public const string PublicKeyTokenTextBox = "txtPublicKeyToken";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedNameStaticControl;
        protected TextBox m_cachedPermissionSetTypeTextBox;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedNameTextBox;
        protected StaticControl m_cachedExample1000StaticControl;
        protected StaticControl m_cachedRunLocationStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedExampleHttpServershareStaticControl;
        protected StaticControl m_cachedApplicationTypeStaticControl;
        protected EditComboBox m_cachedProcessorEditComboBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedPublicKeyTokenEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedPublicKeyTokenStaticControl;
        protected TextBox m_cachedPublicKeyTokenTextBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Name window for Deployment manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepNameWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepNameWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PermissionSetType
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PermissionSetType
        {
            get
            {
                return Controls.PermissionSetTypeTextBox.Text;
            }
            set
            {
                Controls.PermissionSetTypeTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Name
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Name
        {
            get
            {
                return Controls.NameTextBox.Text;
            }
            set
            {
                Controls.NameTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Processor
        {
            get
            {
                return Controls.ProcessorEditComboBox.Text;
            }
            set
            {
                Controls.ProcessorEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken
        {
            get
            {
                return Controls.PublicKeyTokenEditComboBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Culture
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken2
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string PublicKeyToken2
        {
            get
            {
                return Controls.PublicKeyTokenTextBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PermissionSetTypeTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.PermissionSetTypeTextBox
        {
            get
            {
                if ((m_cachedPermissionSetTypeTextBox == null))
                {
                    m_cachedPermissionSetTypeTextBox = new TextBox(this, ControlIDs.PermissionSetTypeTextBox);
                }
                return m_cachedPermissionSetTypeTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.NameTextBox
        {
            get
            {
                if ((m_cachedNameTextBox == null))
                {
                    m_cachedNameTextBox = new TextBox(this, ControlIDs.NameTextBox);
                }
                return m_cachedNameTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the Example1000StaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.Example1000StaticControl
        {
            get
            {
                if ((m_cachedExample1000StaticControl == null))
                {
                    m_cachedExample1000StaticControl = new StaticControl(this, ControlIDs.Example1000StaticControl);
                }
                return m_cachedExample1000StaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RunLocationStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.RunLocationStaticControl
        {
            get
            {
                if ((m_cachedRunLocationStaticControl == null))
                {
                    m_cachedRunLocationStaticControl = new StaticControl(this, ControlIDs.RunLocationStaticControl);
                }
                return m_cachedRunLocationStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.ExampleHttpServershareStaticControl
        {
            get
            {
                if ((m_cachedExampleHttpServershareStaticControl == null))
                {
                    m_cachedExampleHttpServershareStaticControl = new StaticControl(this, ControlIDs.ExampleHttpServershareStaticControl);
                }
                return m_cachedExampleHttpServershareStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationTypeStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.ApplicationTypeStaticControl
        {
            get
            {
                if ((m_cachedApplicationTypeStaticControl == null))
                {
                    m_cachedApplicationTypeStaticControl = new StaticControl(this, ControlIDs.ApplicationTypeStaticControl);
                }
                return m_cachedApplicationTypeStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepNameWindowControls.ProcessorEditComboBox
        {
            get
            {
                if ((m_cachedProcessorEditComboBox == null))
                {
                    m_cachedProcessorEditComboBox = new EditComboBox(this, ControlIDs.ProcessorEditComboBox);
                }
                return m_cachedProcessorEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepNameWindowControls.PublicKeyTokenEditComboBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenEditComboBox == null))
                {
                    m_cachedPublicKeyTokenEditComboBox = new EditComboBox(this, ControlIDs.PublicKeyTokenEditComboBox);
                }
                return m_cachedPublicKeyTokenEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepNameWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl IDepNameWindowControls.PublicKeyTokenStaticControl
        {
            get
            {
                if ((m_cachedPublicKeyTokenStaticControl == null))
                {
                    m_cachedPublicKeyTokenStaticControl = new StaticControl(this, ControlIDs.PublicKeyTokenStaticControl);
                }
                return m_cachedPublicKeyTokenStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IDepNameWindowControls.PublicKeyTokenTextBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenTextBox == null))
                {
                    m_cachedPublicKeyTokenTextBox = new TextBox(this, ControlIDs.PublicKeyTokenTextBox);
                }
                return m_cachedPublicKeyTokenTextBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: AssemblyTitle("MAUI Management Console Automation")]
[assembly: AssemblyDescription("Base automation library for Microsoft Management Console (MMC) UI.")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyProduct("Microsoft Automation for UI")]
[assembly: AssemblyCopyright("2003 (c) Microsoft Corporation")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: AssemblyVersion("1.0.0.0")]

[assembly: AssemblyDelaySign(false)]
#if STRONG_NAME
	[assembly: AssemblyKeyFile("..\\..\\maui.snk")]
#else
	[assembly: AssemblyKeyFile("")]
	[assembly: AssemblyKeyName("")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\LicWindows\LicConditionsWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicConditionsWindowControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicConditionsWindowControls
    {
        StaticControl SpecifyLocationStaticControl  {get;}
        TextBox VersionTextBox  {get;}
        RadioButton ApplicationMustComeFromSpecificLocationOrBelowRadioButton  {get;}
        RadioButton ApplicationMustComeFromSpecificLocationRadioButton  {get;}
        RadioButton ApplicationMayComeFromAnyLocationRadioButton  {get;}
    }

#endregion


#region "Enums for RadioButton groups"
    
    
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioGroup0
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioGroup0
    {
        ApplicationMustComeFromSpecificLocationOrBelow = 0,
        ApplicationMustComeFromSpecificLocation = 1,
        ApplicationMayComeFromAnyLocation = 2,
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicConditionsWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the License Conditions window for 
    ///  Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicConditionsWindow : Window, ILicConditionsWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Conditions";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string SpecifyLocationStaticControl = "lblLocation";
            public const string VersionTextBox = "txtLocation";
            public const string ApplicationMustComeFromSpecificLocationOrBelowRadioButton = "rbSpecificLocationOrBelow";
            public const string ApplicationMustComeFromSpecificLocationRadioButton = "rbSpecificLocation";
            public const string ApplicationMayComeFromAnyLocationRadioButton = "rbAnyLocation";
        }

#endregion

#region "Member Variables"
        protected StaticControl m_cachedSpecifyLocationStaticControl;
        protected TextBox m_cachedVersionTextBox;
        protected RadioButton m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton;
        protected RadioButton m_cachedApplicationMustComeFromSpecificLocationRadioButton;
        protected RadioButton m_cachedApplicationMayComeFromAnyLocationRadioButton;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for License Conditions page for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicConditionsWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicConditionsWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioGroup0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioGroup0 RadioGroup0
        {
            get
            {
                if ((Controls.ApplicationMustComeFromSpecificLocationOrBelowRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.ApplicationMustComeFromSpecificLocationOrBelow;

                if ((Controls.ApplicationMustComeFromSpecificLocationRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.ApplicationMustComeFromSpecificLocation;

                if ((Controls.ApplicationMayComeFromAnyLocationRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.ApplicationMayComeFromAnyLocation;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioGroup0.ApplicationMustComeFromSpecificLocationOrBelow))
                    Controls.ApplicationMustComeFromSpecificLocationOrBelowRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup0.ApplicationMustComeFromSpecificLocation))
                    Controls.ApplicationMustComeFromSpecificLocationRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup0.ApplicationMayComeFromAnyLocation))
                    Controls.ApplicationMayComeFromAnyLocationRadioButton.ButtonState = ButtonState.Checked;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SpecifyLocationStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicConditionsWindowControls.SpecifyLocationStaticControl
        {
            get
            {
                if ((m_cachedSpecifyLocationStaticControl == null))
                {
                    m_cachedSpecifyLocationStaticControl = new StaticControl(this, ControlIDs.SpecifyLocationStaticControl);
                }
                return m_cachedSpecifyLocationStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicConditionsWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationMustComeFromSpecificLocationOrBelowRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ILicConditionsWindowControls.ApplicationMustComeFromSpecificLocationOrBelowRadioButton
        {
            get
            {
                if ((m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton == null))
                {
                    m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton = new RadioButton(this, ControlIDs.ApplicationMustComeFromSpecificLocationOrBelowRadioButton);
                }
                return m_cachedApplicationMustComeFromSpecificLocationOrBelowRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationMustComeFromSpecificLocationRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ILicConditionsWindowControls.ApplicationMustComeFromSpecificLocationRadioButton
        {
            get
            {
                if ((m_cachedApplicationMustComeFromSpecificLocationRadioButton == null))
                {
                    m_cachedApplicationMustComeFromSpecificLocationRadioButton = new RadioButton(this, ControlIDs.ApplicationMustComeFromSpecificLocationRadioButton);
                }
                return m_cachedApplicationMustComeFromSpecificLocationRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ApplicationMayComeFromAnyLocationRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton ILicConditionsWindowControls.ApplicationMayComeFromAnyLocationRadioButton
        {
            get
            {
                if ((m_cachedApplicationMayComeFromAnyLocationRadioButton == null))
                {
                    m_cachedApplicationMayComeFromAnyLocationRadioButton = new RadioButton(this, ControlIDs.ApplicationMayComeFromAnyLocationRadioButton);
                }
                return m_cachedApplicationMayComeFromAnyLocationRadioButton;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\LicWindows\LicPubTrustWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicPubTrustWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicPubTrustWindowControls
    {
        Button GetKeyButton  {get;}
        TextBox VersionTextBox  {get;}
        StaticControl ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl  {get;}
        StaticControl PublishersPublicKeyStaticControl  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicPubTrustWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Publisher Being Trusted window for
    ///  Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicPubTrustWindow : Window, ILicPubTrustWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Publisher Being Trusted";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string GetKeyButton = "btnGetKey";
            public const string VersionTextBox = "txtPublicKey";
            public const string ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl = "lblPrompt";
            public const string PublishersPublicKeyStaticControl = "lblPublicKey";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedGetKeyButton;
        protected TextBox m_cachedVersionTextBox;
        protected StaticControl m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl;
        protected StaticControl m_cachedPublishersPublicKeyStaticControl;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Publisher Being Trusted page for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicPubTrustWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicPubTrustWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Version
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string Version
        {
            get
            {
                return Controls.VersionTextBox.Text;
            }
            set
            {
                Controls.VersionTextBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the GetKeyButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILicPubTrustWindowControls.GetKeyButton
        {
            get
            {
                if ((m_cachedGetKeyButton == null))
                {
                    m_cachedGetKeyButton = new Button(this, ControlIDs.GetKeyButton);
                }
                return m_cachedGetKeyButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicPubTrustWindowControls.VersionTextBox
        {
            get
            {
                if ((m_cachedVersionTextBox == null))
                {
                    m_cachedVersionTextBox = new TextBox(this, ControlIDs.VersionTextBox);
                }
                return m_cachedVersionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicPubTrustWindowControls.ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl
        {
            get
            {
                if ((m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl == null))
                {
                    m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl = new StaticControl(this, ControlIDs.ClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl);
                }
                return m_cachedClickTheGetKeyButtonToSelectAKeyADeploymentManifestOrKeyFileStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublishersPublicKeyStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicPubTrustWindowControls.PublishersPublicKeyStaticControl
        {
            get
            {
                if ((m_cachedPublishersPublicKeyStaticControl == null))
                {
                    m_cachedPublishersPublicKeyStaticControl = new StaticControl(this, ControlIDs.PublishersPublicKeyStaticControl);
                }
                return m_cachedPublishersPublicKeyStaticControl;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button GetKey
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickGetKey()
        {
            Controls.GetKeyButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\ActionsPane.cs ===
namespace Maui.ManagementConsole
{

	using System;
	using System.Collections;
	using System.ComponentModel;

    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    


    #region Class for Action Items
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Actions Pane Items inside MMC 2.1
    /// </summary>
    /// <history>
    /// 	[faisalb] 11/1/2004 Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class ActionItem : Core.RemotingObject
    {
        #region Exceptions
        public class Exceptions
		{
			public class ActionItemNotFoundException : Maui.GlobalExceptions.MauiException
			{
				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				/// <param name="innerException">Inner Exception</param>
				public ActionItemNotFoundException(string message, System.Exception innerException):base(message, innerException)
				{

				}

				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				public ActionItemNotFoundException(string message):base(message)
				{
				}

                protected ActionItemNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {
                    
                }

			}
			public class ActionItemHasNoSubItemsException : Maui.GlobalExceptions.MauiException
			{
				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				/// <param name="innerException">Inner Exception</param>
				public ActionItemHasNoSubItemsException(string message, System.Exception innerException):base(message, innerException)
				{
				}

				/// <summary>
				/// Call to throw exception
				/// </summary>
				/// <param name="message">Message</param>
				public ActionItemHasNoSubItemsException(string message):base(message)
				{
				}
				/// <summary>
				/// Call to throw exception
				/// </summary>
				public ActionItemHasNoSubItemsException():base("This ActionItem does not have any sub-items")
				{
				}

                protected ActionItemHasNoSubItemsException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }
            }
        #endregion
        }

        #region Constructors, private variables
        
        private ActiveAccessibility m_actionItem = null;

		internal ActionItem(ActiveAccessibility actionItem)
		{
			m_actionItem = actionItem;
        }
        #endregion

        #region Methods

        /// <summary>
        /// Call this method to click/execute Action Item
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Update code to make sure item is visible
        /// </history>

        /// </summary>
		public void Execute()
		{
			UISynchronization.WaitForUIObjectReady(m_actionItem);

            m_actionItem.Window.WaitForResponse(ActionsGroup.DefaultTimeOut);
            //Calling ScrollToScreen to make sure item is inscreen
            ScrollToScreen();

            //Now click the item.
			m_actionItem.Click();

            //In new implementation of MMC 2.1, just after clicking MMC deletes object
            //So DONT call any function here which use action item
            //m_actionItem.Window.WaitForResponse(ActionsGroup.DefaultTimeOut);
		}

        private void ScrollToScreen()
        {
            ActiveAccessibility scrollBar = m_actionItem.Parent.Children[0];
            //If item is not ScrollBar or Item's Width is 0 or Heigh is 0, then no need to scroll
            if (scrollBar.Role == (int)MsaaRole.ScrollBar && scrollBar.Width > 0 && scrollBar.Height > 0)
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionItem.Parent;
                parentBotton = parent.Y + parent.Height;
                while (!Visible)
                {
                    actionBotton = m_actionItem.Y + m_actionItem.Height;
                    //Scroll Down
                    if (actionBotton > parentBotton)
                    {
                        scrollBar.Children[4].Click();
                    }
                    else //Scroll Up
                    {
                        scrollBar.Children[0].Click();
                    }
                }
            }
        }
        #endregion

        #region Properties

        internal ActiveAccessibility AccessibleObject
        {
            get
            {
                return m_actionItem;
            }
        }

        /// <summary>
        /// Call this method to find if item is Visible in Screen.
        /// </summary>
        public bool Visible
        {
            get
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionItem.Parent;
                actionBotton = m_actionItem.Y + m_actionItem.Height;
                parentBotton = parent.Y + parent.Height;

                return (m_actionItem.Y >= parent.Y && actionBotton <= parentBotton);
            }
        }

        /// <summary>
        /// Call this property to get Action Item Name
        /// </summary>
        /// <value>Action Item Name</value>
		public string Name
		{
			get
			{
				return m_actionItem.Name;
			}
		}

        /// <summary>
        /// Call this property to get SubItems of Action Item. If no SubItems found, this will throw ActionItemHasNoSubItemsException
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated to check if Menu is MMC Action Group
        /// </history>
        /// <param name="index">Index of Action Item</param>
        /// <returns>Menu Item</returns>
		public MenuItem this[int index]
		{
            get
            {
                if (!HasSubMenu)
                    throw new Exceptions.ActionItemHasNoSubItemsException();
                this.Execute();
                Menu menu = new Menu(ActionsGroup.DefaultTimeOut);

                //if there was no Context Menu then it will catch MMC Action Group which is not a Context Menu
                if (menu.AccessibleObject.Window.ClassName == ActionsGroup.MmcActionGroupClassName)
                    throw new Exceptions.ActionItemHasNoSubItemsException();
                return menu[index, true];
            }
        }

        /// <summary>
        /// Call this property to get SubItems of Action Item. If no SubItems found, this will throw ActionItemHasNoSubItemsException
        /// </summary>
        /// <param name="actionName">Name of Action Item</param>
        /// <returns>Menu Item</returns>
        public MenuItem this[string actionName]
        {
            get
            {
                return this[actionName, true];
            }
        }
        
        /// <summary>
        /// Call this property to get SubItems of Action Item. If no SubItems found, this will throw ActionItemHasNoSubItemsException
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated to check if Menu is MMC Action Group
        /// </history>
        /// <param name="actionName">Name of Action Item</param>
        /// <param name="caseSensitive">Case Sensitve</param>
        /// <returns>Menu Item</returns>

        public MenuItem this[string actionName, bool caseSensitive]
        {
            get
            {
                if (!HasSubMenu)
                {
                    throw new Exceptions.ActionItemHasNoSubItemsException();
                }
                Execute();
                Menu menu = new Menu(ActionsGroup.DefaultTimeOut);
                if (menu == null || menu.AccessibleObject.Window.ClassName == ActionsGroup.MmcActionGroupClassName)
                    throw new Exceptions.ActionItemHasNoSubItemsException();

                return menu[actionName, caseSensitive];
            }
        }

        /// <summary>
        /// Call this function to find number of Menu Items
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated to check if Menu is MMC Action Group
        /// </history>
        public int Count
        {
            get
            {
                if (HasSubMenu == false)
                    return 0;
                this.Execute();
                Menu menu = new Menu(ActionsGroup.DefaultTimeOut);
                if (menu.AccessibleObject.Window.ClassName == ActionsGroup.MmcActionGroupClassName)
                    return 0;
                return menu.MenuItems.Count;
            }
        }

        /// <summary>
        /// Call this property to find wheather this Action Item has Sub Items
        /// </summary>
        /// <value>boolean</value>
		public bool HasSubMenu
		{
			get
			{
				return m_actionItem.Role == ActionsGroup.PopupMenuRole;
			}
		}

        /// <summary>
        /// Call this function to find if Action Group is rendered as region
        /// </summary>
        /// <history>
        /// 	[faisalb]   3/22/2005   Created
        /// </history>
        public bool RenderedAsRegion
        {
            get
            {
                return m_actionItem.Role == (int)MsaaRole.Grouping;
            }
        }

        /// <summary>
        /// Call this function to find if Action is Checked
        /// </summary>
        /// <history>
        /// 	[faisalb]   3/22/2005   Created
        /// </history>
        public bool Checked
        {
            get
            {
                return (m_actionItem.State & (int)MsaaStates.Checked) == (int)MsaaStates.Checked;
            }
        }

        /// <summary>
        /// Call this function to find if Action is Enabled
        /// </summary>
        /// <history>
        /// 	[faisalb]   3/22/2005   Created
        /// </history>
        public bool Enabled
        {
            get
            {
                return !((m_actionItem.State & (int)MsaaStates.Unavailable) == (int)MsaaStates.Unavailable);
            }
        }

        #endregion
	}
    #endregion

    #region Class for Actions Group
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Actions Pane Groups inside MMC 2.1
    /// </summary>
    /// <history>
    /// 	[faisalb]   11/1/2004   Created
    ///     [faisalb]   22/3/2005   Updated class to take care of custom ScrollBar
    /// </history>
    /// -----------------------------------------------------------------------------

    public class ActionsGroup: Core.RemotingObject
    {
        #region Exceptions
        public class Exceptions
		{
			public class ActionGroupNotFound : GlobalExceptions.MauiException
			{
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                public ActionGroupNotFound(string message):base(message)
				{
				}
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                /// <param name="innerException">Inner Exception</param>
                public ActionGroupNotFound(string message, Exception innerException):base(message, innerException)
				{
				}

                protected ActionGroupNotFound(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }
			}
            public class ActionGroupNotExpanded : GlobalExceptions.MauiException
            {
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                public ActionGroupNotExpanded(string message):base(message)
				{
				}
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                /// <param name="innerException">Inner Exception</param>
                public ActionGroupNotExpanded(string message, Exception innerException):base(message, innerException)
				{
				}

                protected ActionGroupNotExpanded(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }

            }
            public class ActionGroupNotCollapsed : GlobalExceptions.MauiException
            {
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                public ActionGroupNotCollapsed(string message):base(message)
                {
                }
                /// <summary>
                /// Call to throw exception
                /// </summary>
                /// <param name="message">Message</param>
                /// <param name="innerException">Inner Exception</param>
                public ActionGroupNotCollapsed(string message, Exception innerException):base(message, innerException)
                {
                }

                protected ActionGroupNotCollapsed(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context):base(info, context)
                {

                }

            }
        }
        #endregion

        #region Constructors and Private Variables
        
        private ActiveAccessibility m_actionsGroup = null;

        #region Constants

        internal const int GroupRole = 64;
		internal const int PopupMenuRole = (int)MsaaRole.MenuPopup; //11
		internal const int DefaultTimeOut = 2000;
        internal const string MmcActionGroupClassName = "AfxFrameOrView42u";

        #endregion

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        internal ActionsGroup(ActiveAccessibility actionPane, int index)
		{
			int ChildCount = actionPane.ChildCount;
            //Changed to 1 from 0. Because now 0th will be a custom scrollbar.
            for (int i = 1; i < ChildCount; i++)
			{
				if (actionPane.Children[i].Role == GroupRole)
				{
					if (index == 0)
					{
						m_actionsGroup = actionPane.Children[i];
						break;
					}
					index--;
				}
			}
			if (m_actionsGroup == null)
			{
				throw new ActionsGroup.Exceptions.ActionGroupNotFound("Could not find ActionGroup as index " + index);
			}
		}

        internal ActionsGroup(ActiveAccessibility actionPane, string groupName):this(actionPane, groupName, true)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        internal ActionsGroup(ActiveAccessibility actionPane, string groupName, bool caseSensitive)
		{
			int ChildCount = actionPane.ChildCount;
			ActiveAccessibility performaceChild;

            //Changed to 1 from 0. Because now 0th will be a custom scrollbar.
            for (int i = 1; i < ChildCount; i++)
			{
				performaceChild = actionPane.Children[i];

                if (string.Compare(performaceChild.Name, groupName, !caseSensitive) == 0)
                {
                    m_actionsGroup = performaceChild;
                    break;
                }
            }
			if (m_actionsGroup == null)
			{
				throw new ActionsGroup.Exceptions.ActionGroupNotFound("Could not find ActionGroup as " + groupName);
			}
		}
        #endregion

        #region Properties
        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        internal ActiveAccessibility Parent
		{
			get
			{
				return m_actionsGroup.Parent;
			}
		}
        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
		internal ActiveAccessibility AccessibleObject
		{
			get
			{
				return m_actionsGroup;
			}
		}

        /// <summary>
        /// Call this property to find wheather Action Group is expended or collapsed
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        /// <value>boolean</value>
		public bool Expanded
		{
			get
			{
				return (m_actionsGroup.State & (int)MsaaStates.Expanded) == (int)MsaaStates.Expanded;
			}
		}

        /// <summary>
        /// Call this indexer to get Action Item from Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        /// <param name="index">Index of Action Item</param>
        /// <returns>Action Item</returns>
		public ActionItem this[int index]
		{
			get
			{
				int childCount = m_actionsGroup.Parent.ChildCount;
                if (childCount == ActionsGroup.GetIndex(m_actionsGroup) - 1)
				{
					throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as index " + index);
				}

				ActiveAccessibility actionItem = null;
				ActiveAccessibility actionPane = m_actionsGroup.Parent;
                
				ActiveAccessibility performaceChild;
                for (int i = ActionsGroup.GetIndex(m_actionsGroup) + 1; i < childCount; i++, index--)
				{
					performaceChild = actionPane.Children[i];
					if (index == 0 && performaceChild.Role != GroupRole)
					{
						actionItem = performaceChild;
						break;
					}

					if (performaceChild.Role == GroupRole)
					{
						throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as index " + index);
					}
				}

				return new ActionItem(actionItem);
			}
		}

		/// <summary>
        /// Call this indexer to get Action Item from Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
		/// <param name="actionName">Name of Action Item</param>
		/// <param name="caseSensitive">Case Sensitive</param>
		/// <returns>Action Item</returns>
        public ActionItem this[string actionName, bool caseSensitive]
		{
			get
			{
				int childCount = m_actionsGroup.Parent.ChildCount;
				if (childCount == ActionsGroup.GetIndex(m_actionsGroup) - 1)
				{
					throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as " + actionName);
				}

				ActiveAccessibility actionItem = null;
				ActiveAccessibility actionPane = m_actionsGroup.Parent;

				ActiveAccessibility performaceChild;
				for (int i = ActionsGroup.GetIndex(m_actionsGroup) + 1; i < childCount; i++)
				{
					performaceChild = actionPane.Children[i];
					if (performaceChild.Role == GroupRole)
					{
						throw new ActionItem.Exceptions.ActionItemNotFoundException("Could not find ActionItem as " + actionName);
					}

                    if (string.Compare(performaceChild.Name, actionName, !caseSensitive) == 0)
                    {
                        actionItem = actionPane.Children[i];
                        break;
                    }
				}

				return new ActionItem(actionItem);
			}
		}
        /// <summary>
        /// Call this indexer to get Action Item from Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        /// <param name="actionName">Name of Action Item</param>
        /// <returns>Action Item</returns>
        public ActionItem this[string actionName]
		{
			get
			{
				return this[actionName, true];
			}
		}

        /// <summary>
        /// Call this property to get name of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        /// </history>
        /// <value></value>
		public string Name
		{
			get
			{
				return m_actionsGroup.Name;
			}
		}

        /// <summary>
        /// Call this property to get Count of Action Items in Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        /// <value>Count of Action Items</value>
		public int Count
		{
			get
			{
                int i, returnCount, childCount = m_actionsGroup.Parent.ChildCount;
                if (childCount == ActionsGroup.GetIndex(m_actionsGroup) - 1)
                    return 0;
                for (i = ActionsGroup.GetIndex(m_actionsGroup) + 1, returnCount = 0; i < childCount; i++)
                {
                    if (m_actionsGroup.Parent.Children[i].Role == GroupRole)
                        break;
                    returnCount++;
                }
                return returnCount;
            }
		}

        /// <summary>
        /// Call this property to find if Action Group is visible and in screen
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        public bool Visible
        {
            get
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionsGroup.Parent;
                actionBotton = m_actionsGroup.Y + m_actionsGroup.Height;
                parentBotton = parent.Y + parent.Height;

                return (m_actionsGroup.Y >= parent.Y && actionBotton <= parentBotton);
            }
        }

        #endregion

        #region Methods
        /// <summary>
        /// Call this method to Expand Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        public void Expand()
		{
			UISynchronization.WaitForUIObjectReady(m_actionsGroup);
			if (Expanded)
				return;
			//NativeMethods.SendMessageBynum(m_actionsGroup.Window.Extended.HWnd, NativeMethods.TVM_EXPAND, new IntPtr(NativeMethods.TVE_EXPAND), m_actionsGroup.Window.Extended.HWnd);
            this.Execute(); 
            
            if (!Expanded)
                throw new Exceptions.ActionGroupNotExpanded("Action Group " + this.Name + " not expanded");

        }

        /// <summary>
        /// Call this method to Collapse Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        public void Collapse()
        {
			UISynchronization.WaitForUIObjectReady(m_actionsGroup);
            if (!Expanded)
				return;
			//NativeMethods.SendMessageBynum(m_actionsGroup.Window.Extended.HWnd, NativeMethods.TVM_EXPAND, new IntPtr(NativeMethods.TVE_COLLAPSE), m_actionsGroup.Window.Extended.HWnd);

            this.Execute();

            if (Expanded)
                throw new Exceptions.ActionGroupNotCollapsed("Action Group " + this.Name + " not collapsed");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   11/1/2004   Created
        ///     [faisalb]   3/22/2005   Updated for Custom Scrollbars
        /// </history>
        private void Execute()
        {
            m_actionsGroup.Window.WaitForResponse(2000);
            m_actionsGroup.Window.Extended.SetFocus();

            //NativeMethods.SendMessageBynum(_ActionsGroup.Window.Extended.HWnd, NativeMethods.TVM_EXPAND, new IntPtr(NativeMethods.TVE_COLLAPSE), _ActionsGroup.Window.Extended.HWnd);
            ScrollToScreen();
            m_actionsGroup.Click();

            m_actionsGroup.Window.WaitForResponse(2000);

        }
        /// <summary>
        /// Call this method to get Action Group if your Action Group is rendered as region
        /// </summary>
        /// <history>
        ///     [faisalb]   3/22/2005   Created
        /// </history>
        /// <param name="actionRegionName">Name Action Group</param>
        /// <returns>Instance of ActionItemAsRegion</returns>
        public ActionItemAsRegion ActionItemAsRegion(string actionRegionName)
        {
            ActiveAccessibility ActiveAccessibility = this[actionRegionName].AccessibleObject;
            if (ActiveAccessibility.Role != (int)MsaaRole.Grouping)
                throw new ActionItem.Exceptions.ActionItemNotFoundException(actionRegionName + " is not Rendered as region. Hint: Use ActionItem instead of ActionItemAsRegion");

            return new ActionItemAsRegion(ActiveAccessibility);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        ///     [faisalb]   3/22/2005   Created
        /// </history>
        private void ScrollToScreen()
        {
            ActiveAccessibility scrollBar = m_actionsGroup.Parent.Children[0];
            //If item is not ScrollBar or Item's Width is 0 or Heigh is 0, then no need to scroll
            if (scrollBar.Role == (int)MsaaRole.ScrollBar && scrollBar.Width > 0 && scrollBar.Height > 0)
            {
                int actionBotton, parentBotton;
                ActiveAccessibility parent = m_actionsGroup.Parent;
                parentBotton = parent.Y + parent.Height;
                while (!Visible)
                {
                    actionBotton = m_actionsGroup.Y + m_actionsGroup.Height;
                    //Scroll Down
                    if (actionBotton > parentBotton)
                    {
                        scrollBar.Children[4].Click();
                    }
                    else //Scroll Up
                    {
                        scrollBar.Children[0].Click();
                    }
                }
            }
        }


        /// <summary>
        /// This function is added to take care of Custom Scroll Bar. Maui skips MMC custom scroll bar, when scroll bar's width is 0 (means invisible)
        /// </summary>
        /// <history>
        ///     [faisalb]   3/22/2005   Created
        /// </history>
        internal static int GetIndex(ActiveAccessibility activeAccessibility)
        {
            //Maui skips MMC custom scroll bar, when scroll bar's width is 0 (means invisible)
            int index = activeAccessibility.Index;
            if (activeAccessibility.Parent.ChildCount > 0)
            {
                ActiveAccessibility scrollBar = activeAccessibility.Parent.Children[0];
                if ((MsaaRole)scrollBar.Role == MsaaRole.ScrollBar && (scrollBar.Visible == false || scrollBar.Width == 0 || scrollBar.Height == 0))
                {
                    return index + 1;
                }
            }
            return index;
        }


        #endregion

	}
    #endregion

    #region Class for Actions Group Rendered As Region

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Actions Pane which are rendered as region inside MMC 2.1
    /// </summary>
    /// <history>
    /// 	[faisalb]   22/3/2005   Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class ActionItemAsRegion
    {
        private ActiveAccessibility m_actionItemAsRegion = null;

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        internal ActionItemAsRegion(ActiveAccessibility actionItemAsRegion)
        {
            m_actionItemAsRegion = actionItemAsRegion;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        internal ActionItemAsRegion(ActiveAccessibility actionPane, int index)
        {
            m_actionItemAsRegion = actionPane.Children[index];
        }


        /// <summary>
        /// Call this method to find Name of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        public string Name
        {
            get
            {
                return m_actionItemAsRegion.Name;
            }
        }

        /// <summary>
        /// Call this to get Action Item of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        /// <param name="index">Index</param>
        /// <returns>Action Item</returns>
        public ActionItem this[int index]
        {
            get
            {
                return new ActionItem(m_actionItemAsRegion.Children[index]);
            }
        }

        /// <summary>
        /// Call this to get Action Item of Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        /// <param name="actionName">Action Name</param>
        /// <returns>Action Item</returns>
        public ActionItem this[string actionName]
        {
            get
            {
                return new ActionItem(m_actionItemAsRegion.Children[actionName]);
            }
        }

        /// <summary>
        /// Call this to find number of Actions in Action Group
        /// </summary>
        /// <history>
        /// 	[faisalb]   22/3/2005   Created
        /// </history>
        public int Count
        {
            get
            {
                return m_actionItemAsRegion.ChildCount;
            }
        }
    }
    #endregion

    #region Class for Actions Pane Window
    /// -----------------------------------------------------------------------------
	/// Project		: Maui
	/// Class		: ActionsPane
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	///  <summary>
    ///     Represents Actions Pane Window inside MMC 2.1
    ///  </summary>
	///  <history>
	/// 	[faisalb] 11/01/2004 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public class ActionsPane : Window
	{

#region "Member Variables"
        private const string WindowTitle = "ActionsPaneView";
        private const string ChildWindowTitle = "Actions";
#endregion

#region "Constructor and Init function"
        private const int Timeout = 5000;
        
        //protected internal static Window ActiveWindow;
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Internal constructor to create object of Actions Pane
        ///  </summary>
        ///  <param name="app">Window object owning the window.</param>
        ///  <history>
        /// 	[faisalb] 9/27/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        internal ActionsPane(Window ownerWindow) : 
                base(Init(ownerWindow))
        {
            
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  This function will attempt to find the window.
        ///  </summary>
        ///  <returns>The window to find</returns>
        ///  <param name="ownerWindow">Window owning the window.</param>)
        ///  <history>
        /// 	[faisalb] 9/27/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static System.IntPtr Init(Window ownerWindow)
        {
            // First check if the window is already up.
            Window tempWindow = null;
            try
            {
				tempWindow = new Window(WindowTitle, StringMatchSyntax.ExactMatch, "*", StringMatchSyntax.WildCard, ownerWindow, Timeout);
			}
            catch (Exceptions.WindowNotFoundException ex)
            {
                throw new Window.Exceptions.WindowNotFoundException("Init function could not find Actions Pane. Make sure you enabled Actions Pane", ex);
            }
            return tempWindow.Extended.HWnd;
        }

#endregion

#region "Properties"

		private ActiveAccessibility Actions
		{
			get
			{
                return Extended.AccessibleObject.Children[WindowTitle].Children[ChildWindowTitle].Children[ChildWindowTitle];
            }
		}

        /// <summary>
        /// Call this indexer to get Action Group
        /// </summary>
        /// <param name="index">Index of Action Group</param>
        /// <returns>Action Group</returns>
		public ActionsGroup this [int index]
		{
			get
			{
				return new ActionsGroup(Actions, index);
			}

		}

        /// <summary>
        /// Call this indexer to get Action Group
        /// </summary>
        /// <param name="groupName">Name of Action Group</param>
        /// <returns>Action Group</returns>
        public ActionsGroup this[string groupName]
        {
			get
			{
				return new ActionsGroup(Actions, groupName);
			}

		}

        /// <summary>
        /// Call this indexer to get Action Group
        /// </summary>
        /// <param name="groupName">Name of Action Group</param>
        /// <param name="caseSensitive">Case Sensitive</param>
        /// <returns>Action Group</returns>
        public ActionsGroup this[string groupName, bool caseSensitive]
        {
            get
            {
                return new ActionsGroup(Actions, groupName);
            }

        }

#endregion
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\LicWindows\LicAppTrustWindow.cs ===
namespace Maui.Mage.LicWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "ILicAppTrustWindowControls interface definition"
    
    
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface ILicAppTrustWindowControls
    {
        Button SelectApplicationButton  {get;}
        CheckBox LicenseValidForAllVersionsOfTheApplicationCheckBox  {get;}
        CheckBox LicenseAppliesOnlyToASpecificApplicationCheckBox  {get;}
        StaticControl ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl  {get;}
        StaticControl NameStaticControl  {get;}
        TextBox ExampleHttpServershareTextBox  {get;}
        StaticControl VersionStaticControl  {get;}
        TextBox ProcessorTextBox  {get;}
        StaticControl ProcessorStaticControl  {get;}
        EditComboBox CultureEditComboBox  {get;}
        StaticControl CultureStaticControl  {get;}
        EditComboBox PublicKeyTokenEditComboBox  {get;}
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: LicAppTrustWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls on the Application Being Trusted page for
    ///  Trust Licenses
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class LicAppTrustWindow : Window, ILicAppTrustWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Application Being Trusted";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string SelectApplicationButton = "btnSelect";
            public const string LicenseValidForAllVersionsOfTheApplicationCheckBox = "chkValidForAllVersions";
            public const string LicenseAppliesOnlyToASpecificApplicationCheckBox = "chkSpecificApplication";
            public const string ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl = "lblInstructions";
            public const string NameStaticControl = "lblName";
            public const string ExampleHttpServershareTextBox = "txtName";
            public const string VersionStaticControl = "lblVersion";
            public const string ProcessorTextBox = "txtVersion";
            public const string ProcessorStaticControl = "lblProcessor";
            public const string CultureEditComboBox = "cbxProcessor";
            public const string CultureStaticControl = "lblCulture";
            public const string PublicKeyTokenEditComboBox = "cbxCulture";
        }

#endregion

#region "Member Variables"
        protected Button m_cachedSelectApplicationButton;
        protected CheckBox m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox;
        protected CheckBox m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox;
        protected StaticControl m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl;
        protected StaticControl m_cachedNameStaticControl;
        protected TextBox m_cachedExampleHttpServershareTextBox;
        protected StaticControl m_cachedVersionStaticControl;
        protected TextBox m_cachedProcessorTextBox;
        protected StaticControl m_cachedProcessorStaticControl;
        protected EditComboBox m_cachedCultureEditComboBox;
        protected StaticControl m_cachedCultureStaticControl;
        protected EditComboBox m_cachedPublicKeyTokenEditComboBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		/// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Application Being Trusted page for Trust Licenses
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public LicAppTrustWindow(LicType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(LicType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual ILicAppTrustWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox LicenseValidForAllVersionsOfTheApplication
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool LicenseValidForAllVersionsOfTheApplication
        {
            get
            {
                return Controls.LicenseValidForAllVersionsOfTheApplicationCheckBox.Checked;
            }
            set
            {
                Controls.LicenseValidForAllVersionsOfTheApplicationCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox LicenseAppliesOnlyToASpecificApplication
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual bool LicenseAppliesOnlyToASpecificApplication
        {
            get
            {
                return Controls.LicenseAppliesOnlyToASpecificApplicationCheckBox.Checked;
            }
            set
            {
                Controls.LicenseAppliesOnlyToASpecificApplicationCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ExampleHttpServershare
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ExampleHttpServershareText
        {
            get
            {
                return Controls.ExampleHttpServershareTextBox.Text;
            }
            set
            {
                Controls.ExampleHttpServershareTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Processor
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ProcessorText
        {
            get
            {
                return Controls.ProcessorTextBox.Text;
            }
            set
            {
                Controls.ProcessorTextBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control Culture
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string CultureText
        {
            get
            {
                return Controls.CultureEditComboBox.Text;
            }
            set
            {
                Controls.CultureEditComboBox.Text = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control PublicKeyToken
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string PublicKeyTokenText
        {
            get
            {
                return Controls.PublicKeyTokenEditComboBox.Text;
            }
            set
            {
                Controls.PublicKeyTokenEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SelectApplicationButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button ILicAppTrustWindowControls.SelectApplicationButton
        {
            get
            {
                if ((m_cachedSelectApplicationButton == null))
                {
                    m_cachedSelectApplicationButton = new Button(this, ControlIDs.SelectApplicationButton);
                }
                return m_cachedSelectApplicationButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LicenseValidForAllVersionsOfTheApplicationCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILicAppTrustWindowControls.LicenseValidForAllVersionsOfTheApplicationCheckBox
        {
            get
            {
                if ((m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox == null))
                {
                    m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox = new CheckBox(this, ControlIDs.LicenseValidForAllVersionsOfTheApplicationCheckBox);
                }
                return m_cachedLicenseValidForAllVersionsOfTheApplicationCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the LicenseAppliesOnlyToASpecificApplicationCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox ILicAppTrustWindowControls.LicenseAppliesOnlyToASpecificApplicationCheckBox
        {
            get
            {
                if ((m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox == null))
                {
                    m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox = new CheckBox(this, ControlIDs.LicenseAppliesOnlyToASpecificApplicationCheckBox);
                }
                return m_cachedLicenseAppliesOnlyToASpecificApplicationCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl
        {
            get
            {
                if ((m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl == null))
                {
                    m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl = new StaticControl(this, ControlIDs.ToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl);
                }
                return m_cachedToQuicklyPopulateFieldsWithApplicationInformationClickTheSelectApplicationButtonToOpenAnApplicationMStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the NameStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.NameStaticControl
        {
            get
            {
                if ((m_cachedNameStaticControl == null))
                {
                    m_cachedNameStaticControl = new StaticControl(this, ControlIDs.NameStaticControl);
                }
                return m_cachedNameStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicAppTrustWindowControls.ExampleHttpServershareTextBox
        {
            get
            {
                if ((m_cachedExampleHttpServershareTextBox == null))
                {
                    m_cachedExampleHttpServershareTextBox = new TextBox(this, ControlIDs.ExampleHttpServershareTextBox);
                }
                return m_cachedExampleHttpServershareTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the VersionStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.VersionStaticControl
        {
            get
            {
                if ((m_cachedVersionStaticControl == null))
                {
                    m_cachedVersionStaticControl = new StaticControl(this, ControlIDs.VersionStaticControl);
                }
                return m_cachedVersionStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorTextBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox ILicAppTrustWindowControls.ProcessorTextBox
        {
            get
            {
                if ((m_cachedProcessorTextBox == null))
                {
                    m_cachedProcessorTextBox = new TextBox(this, ControlIDs.ProcessorTextBox);
                }
                return m_cachedProcessorTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.ProcessorStaticControl
        {
            get
            {
                if ((m_cachedProcessorStaticControl == null))
                {
                    m_cachedProcessorStaticControl = new StaticControl(this, ControlIDs.ProcessorStaticControl);
                }
                return m_cachedProcessorStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ILicAppTrustWindowControls.CultureEditComboBox
        {
            get
            {
                if ((m_cachedCultureEditComboBox == null))
                {
                    m_cachedCultureEditComboBox = new EditComboBox(this, ControlIDs.CultureEditComboBox);
                }
                return m_cachedCultureEditComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CultureStaticControl control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        StaticControl ILicAppTrustWindowControls.CultureStaticControl
        {
            get
            {
                if ((m_cachedCultureStaticControl == null))
                {
                    m_cachedCultureStaticControl = new StaticControl(this, ControlIDs.CultureStaticControl);
                }
                return m_cachedCultureStaticControl;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the PublicKeyTokenEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox ILicAppTrustWindowControls.PublicKeyTokenEditComboBox
        {
            get
            {
                if ((m_cachedPublicKeyTokenEditComboBox == null))
                {
                    m_cachedPublicKeyTokenEditComboBox = new EditComboBox(this, ControlIDs.PublicKeyTokenEditComboBox);
                }
                return m_cachedPublicKeyTokenEditComboBox;
            }
        }

#endregion

#region "Methods"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button SelectApplication
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void ClickSelectApplication()
        {
            Controls.SelectApplicationButton.Click();
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\Mage\FileTypes\DepWindows\DepUpdateWindow.cs ===
namespace Maui.Mage.DepWindows
{


    using Maui.Core;
    using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System;
    using System.ComponentModel;


#region "IDepUpdateWindowControls interface definition"
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IDepUpdateWindowControls
    {
        CheckBox ThisApplicationShouldCheckForUpdatesCheckBox  {get;}
        CheckBox RequiredUpdateCheckBox  {get;}
        RadioButton InTheBackgroundAfterTheAppStartsRadioButton  {get;}
        RadioButton BeforeTheApplicationStartsRadioButton  {get;}
        RadioButton EveryTimeTheApplicationStartsRadioButton  {get;}
        RadioButton CheckEveryRadioButton  {get;}
        NumericUpDown ProcessorNumericUpDown  {get;}
        EditComboBox ExampleHttpServershareEditComboBox  {get;}
    }

#endregion


#region "Enums for RadioButton groups"
    
    
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioGroup0
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioGroup0
    {
        InTheBackgroundAfterTheAppStarts = 0,
        BeforeTheApplicationStarts = 1,
    }

    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  Enum for radio group RadioGroup1
    ///  </summary>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public enum RadioGroup1
    {
        EveryTimeTheApplicationStarts = 0,
        CheckEvery = 1,
    }

#endregion

    /// -----------------------------------------------------------------------------
    /// Project		: Maui.Mage
    /// Class		: DepUpdateWindow
    ///  Copyright (C) 2004, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///  This class describes the controls for the Update Options page for Deployment Manifests
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    /// 	[a-dwils] 2/24/2004 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class DepUpdateWindow : Window, IDepUpdateWindowControls
    {


#region "Strings"
        public class Strings
        {
			public const string ListTitle = "Update Options";
        }

#endregion

#region "Control IDs"
        public class ControlIDs
        {
            public const string ThisApplicationShouldCheckForUpdatesCheckBox = "chkCheckForUpdates";
            public const string RequiredUpdateCheckBox = "chkRequiredUpdate";
            public const string InTheBackgroundAfterTheAppStartsRadioButton = "rbBackground";
            public const string BeforeTheApplicationStartsRadioButton = "rbBeforeStart";
            public const string EveryTimeTheApplicationStartsRadioButton = "rbEveryStart";
            public const string CheckEveryRadioButton = "rbInterval";
            public const string ProcessorNumericUpDown = "udNumber";
            public const string ExampleHttpServershareEditComboBox = "cbxUnits";
        }

#endregion

#region "Member Variables"
        protected CheckBox m_cachedThisApplicationShouldCheckForUpdatesCheckBox;
        protected CheckBox m_cachedRequiredUpdateCheckBox;
        protected RadioButton m_cachedInTheBackgroundAfterTheAppStartsRadioButton;
        protected RadioButton m_cachedBeforeTheApplicationStartsRadioButton;
        protected RadioButton m_cachedEveryTimeTheApplicationStartsRadioButton;
        protected RadioButton m_cachedCheckEveryRadioButton;
        protected NumericUpDown m_cachedProcessorNumericUpDown;
        protected EditComboBox m_cachedExampleHttpServershareEditComboBox;
        protected internal static Window ActiveWindow;

#endregion

#region "Constructor and Init function"
		//// -----------------------------------------------------------------------------
		///  <summary>
		///  Constructor for Update Options page for Deployment Manifests
		///  </summary>
		//  <param name="app">Window object owning the window.</param>
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public DepUpdateWindow(DepType ownerWindow, String Title) : 
			base(Init(ownerWindow, Title))
		{
		}


		/// -----------------------------------------------------------------------------
		///  <summary>
		///  This function will attempt to find the window.
		///  </summary>
		///  <returns>The window to find</returns>
		///  <param name="ownerWindow">Window owning the window.</param>)
		///  <history>
		/// 	[a-dwils] 1/14/2004 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		private static System.IntPtr Init(DepType ownerWindow, String Title)
		{
			// First check if the window is already up.
			Window tempWindow = null;
			try
			{
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
			}
			catch (Exceptions.WindowNotFoundException ex)
			{ 
				ownerWindow.List[ownerWindow.m_storedApp.GetIntlStr(Strings.ListTitle)].Click();
				tempWindow = new Window(Title, StringMatchSyntax.RegularExpression);
				if (tempWindow != null)
					return tempWindow.Extended.HWnd;

				throw new Window.Exceptions.WindowNotFoundException("Init function could not find or bring up the window.", ex);
			}
			return tempWindow.Extended.HWnd;
		}

#endregion

#region "Properties"
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this window
        ///  </summary>
        ///  <value>An interface that groups all of the window's control properties together</value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IDepUpdateWindowControls Controls
        {
            get
            {
                return this;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioGroup0
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioGroup0 RadioGroup0
        {
            get
            {
                if ((Controls.InTheBackgroundAfterTheAppStartsRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.InTheBackgroundAfterTheAppStarts;

                if ((Controls.BeforeTheApplicationStartsRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup0.BeforeTheApplicationStarts;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioGroup0.InTheBackgroundAfterTheAppStarts))
                    Controls.InTheBackgroundAfterTheAppStartsRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup0.BeforeTheApplicationStarts))
                    Controls.BeforeTheApplicationStartsRadioButton.ButtonState = ButtonState.Checked;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Functionality for radio group RadioGroup1
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public RadioGroup1 RadioGroup1
        {
            get
            {
                if ((Controls.EveryTimeTheApplicationStartsRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup1.EveryTimeTheApplicationStarts;

                if ((Controls.CheckEveryRadioButton.ButtonState == ButtonState.Checked))
                    return RadioGroup1.CheckEvery;

                throw new RadioButton.Exceptions.CheckFailedException("No radio button selected.");
            }
            set
            {
                if ((value == RadioGroup1.EveryTimeTheApplicationStarts))
                    Controls.EveryTimeTheApplicationStartsRadioButton.ButtonState = ButtonState.Checked;
                else if ((value == RadioGroup1.CheckEvery))
                    Controls.CheckEveryRadioButton.ButtonState = ButtonState.Checked;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox ThisApplicationShouldCheckForUpdates
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool ThisApplicationShouldCheckForUpdates
        {
            get
            {
                return Controls.ThisApplicationShouldCheckForUpdatesCheckBox.Checked;
            }
            set
            {
                Controls.ThisApplicationShouldCheckForUpdatesCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Property to handle checkbox RequiredUpdate
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool RequiredUpdate
        {
            get
            {
                return Controls.RequiredUpdateCheckBox.Checked;
            }
            set
            {
                Controls.RequiredUpdateCheckBox.Checked = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to set/get the text in control ExampleHttpServershare
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string ExampleHttpServershare
        {
            get
            {
                return Controls.ExampleHttpServershareEditComboBox.Text;
            }
            set
            {
                Controls.ExampleHttpServershareEditComboBox.Text = value;
            }
        }


        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ThisApplicationShouldCheckForUpdatesCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IDepUpdateWindowControls.ThisApplicationShouldCheckForUpdatesCheckBox
        {
            get
            {
                if ((m_cachedThisApplicationShouldCheckForUpdatesCheckBox == null))
                {
                    m_cachedThisApplicationShouldCheckForUpdatesCheckBox = new CheckBox(this, ControlIDs.ThisApplicationShouldCheckForUpdatesCheckBox);
                }
                return m_cachedThisApplicationShouldCheckForUpdatesCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RequiredUpdateCheckBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IDepUpdateWindowControls.RequiredUpdateCheckBox
        {
            get
            {
                if ((m_cachedRequiredUpdateCheckBox == null))
                {
                    m_cachedRequiredUpdateCheckBox = new CheckBox(this, ControlIDs.RequiredUpdateCheckBox);
                }
                return m_cachedRequiredUpdateCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the InTheBackgroundAfterTheAppStartsRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.InTheBackgroundAfterTheAppStartsRadioButton
        {
            get
            {
                if ((m_cachedInTheBackgroundAfterTheAppStartsRadioButton == null))
                {
                    m_cachedInTheBackgroundAfterTheAppStartsRadioButton = new RadioButton(this, ControlIDs.InTheBackgroundAfterTheAppStartsRadioButton);
                }
                return m_cachedInTheBackgroundAfterTheAppStartsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the BeforeTheApplicationStartsRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.BeforeTheApplicationStartsRadioButton
        {
            get
            {
                if ((m_cachedBeforeTheApplicationStartsRadioButton == null))
                {
                    m_cachedBeforeTheApplicationStartsRadioButton = new RadioButton(this, ControlIDs.BeforeTheApplicationStartsRadioButton);
                }
                return m_cachedBeforeTheApplicationStartsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the EveryTimeTheApplicationStartsRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.EveryTimeTheApplicationStartsRadioButton
        {
            get
            {
                if ((m_cachedEveryTimeTheApplicationStartsRadioButton == null))
                {
                    m_cachedEveryTimeTheApplicationStartsRadioButton = new RadioButton(this, ControlIDs.EveryTimeTheApplicationStartsRadioButton);
                }
                return m_cachedEveryTimeTheApplicationStartsRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CheckEveryRadioButton control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        RadioButton IDepUpdateWindowControls.CheckEveryRadioButton
        {
            get
            {
                if ((m_cachedCheckEveryRadioButton == null))
                {
                    m_cachedCheckEveryRadioButton = new RadioButton(this, ControlIDs.CheckEveryRadioButton);
                }
                return m_cachedCheckEveryRadioButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ProcessorNumericUpDown control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        NumericUpDown IDepUpdateWindowControls.ProcessorNumericUpDown
        {
            get
            {
                if ((m_cachedProcessorNumericUpDown == null))
                {
                    m_cachedProcessorNumericUpDown = new NumericUpDown(this, ControlIDs.ProcessorNumericUpDown);
                }
                return m_cachedProcessorNumericUpDown;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExampleHttpServershareEditComboBox control
        ///  </summary>
        ///  <value></value>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[a-dwils] 2/24/2004 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IDepUpdateWindowControls.ExampleHttpServershareEditComboBox
        {
            get
            {
                if ((m_cachedExampleHttpServershareEditComboBox == null))
                {
                    m_cachedExampleHttpServershareEditComboBox = new EditComboBox(this, ControlIDs.ExampleHttpServershareEditComboBox);
                }
                return m_cachedExampleHttpServershareEditComboBox;
            }
        }

#endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\SnapIn.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using Maui.Core;
    using System.Collections.Specialized;

    /// <summary>
    /// Handles snap-in wizard/dialog when adding a snap-in.
    /// </summary>
    /// <history>
    ///		[dmitriv]	7/5/2003	Created
    /// </history>
    public delegate void SnapinWizardHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard);

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: MmcApplication.
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Snap-in parameters to be used when adding a snap-in.
    /// </summary>
    ///  <history>
    /// 	[dmitriv] 6/15/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class Snapin : RemotingObject
    {
        #region Private variables, constructors
        private string name = null;
        private string addedName = null;
        private string path = null;
        private string[] extensions = null;
        private string computerName = null;
        private int position = 0;
        private int addSnapInInitializationTimeout = 6000;
        private bool allowComputerChangeFromCommandLine = false;
        private SnapinWizardHandler wizardHandler = null;
        private NameValueCollection settings = new NameValueCollection();

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="name">Name of the snap-in.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Snapin(string name)
        {
            this.name = name;
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="name">Name of the snap-in.</param>
        /// <param name="wizardHandle">Snap-in wizard handler.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Snapin(string name, SnapinWizardHandler wizardHandle)
        {
            this.name = name;
            this.WizardHandler = wizardHandle;
        }
        #endregion

        #region Properties
        /// <summary>
        /// Name of the snap-in.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string Name
        {
            get
            {
                return name;
            }
            set
            {
                name = value;
            }
        }

        /// <summary>
        /// Added name of the snap-in.
        /// </summary>
        /// <history>
        ///		[michsny]	12/28/2003	Created
        /// </history>
        public string AddedName
        {
            get
            {
                return addedName;
            }
            set
            {
                addedName = value;
            }
        }

        /// <summary>
        /// Path inside virtual snap-in tree to where to add the snap-in.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string Path
        {
            get
            {
                return path;
            }
            set
            {
                path = value;
            }
        }

        /// <summary>
        /// Position under parent snap-in.
        /// </summary>
        /// <history>
        ///		[michsny]	12/28/2003	Created
        /// </history>
        public int Position
        {
            get
            {
                return position;
            }
            set
            {
                position = value;
            }
        }

        /// <summary>
        /// Timeout for add/remove snap-in initialization
        /// </summary>
        /// <history>
        ///		[michsny]	1/20/2004	Created
        /// </history>
        public int AddSnapInInitializationTimeout
        {
            get
            {
                return addSnapInInitializationTimeout;
            }
            set
            {
                addSnapInInitializationTimeout = value;
            }
        }

        /// <summary>
        /// List of extensions to include with Snap-in.
        /// Default is to include all extensions (null value).
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string[] Extensions
        {
            get
            {
                return extensions;
            }
            set
            {
                extensions = value;
            }
        }

        /// <summary>
        /// Name of computer to manage. Local computer is the default (null value).
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public string ComputerName
        {
            get
            {
                return computerName;
            }
            set
            {
                computerName = value;
            }
        }

        /// <summary>
        /// Whether to check/uncheck corresponding check-box on Snap-In Wizard.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public bool AllowComputerChangeFromCommandLine
        {
            get
            {
                return allowComputerChangeFromCommandLine;
            }
            set
            {
                allowComputerChangeFromCommandLine = value;
            }
        }

        /// <summary>
        /// Set this property to handle custom Snap-in wizard.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public SnapinWizardHandler WizardHandler
        {
            get
            {
                return wizardHandler;
            }
            set
            {
                wizardHandler = value;
            }
        }

        /// <summary>
        ///		Name-value collection of extra settings to pass to snap-in wizard handler.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public NameValueCollection Settings
        {
            get
            {
                return settings;
            }
        }
        #endregion

        #region Methods
        /// <summary>
        /// Default snap-in wizard handler.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="snapIn">Snap-in.</param>
        /// <param name="wizard">Wizard instance to handle.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        static public void DefaultWizardHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
        {
            // otherwise handle the wizard outselves
            if (snapIn.ComputerName != null)
            {
                wizard.ComputerName = snapIn.ComputerName;
            }
            if (snapIn.AllowComputerChangeFromCommandLine)
            {
                wizard.ClickAllowComputerChangeFromCommandLine();
            }
            wizard.ClickFinish();
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Console.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using Maui.ManagementConsole.Dialogs;

    #region Enumerations, interfaces
    /// <summary>
    /// Specifies how console window list view is shown.
    /// </summary>
    /// <history>
    ///		[dmitriv] 6/15/2003 Created
    /// </history>
    public enum ConsoleViewMode
    {
        LargeIcons,
        SmallIcons,
        List,
        Detail
    }

    /// <summary>
    /// Options to be set on Customize View dialog.
    /// </summary>
    /// <history>
    ///		[dmitriv] 6/15/2003 Created
    ///		[faisalb] 10/28/2004 Added ActionsPane and Changed all to FFFF
    /// </history>
    [Flags()]
    public enum ConsoleViewOptions
    {
        ConsoleTree = 0x0001,
        StandardMenus = 0x0002,
        StandardToolbar = 0x0004,
        StatusBar = 0x0008,
        DescriptionBar = 0x0010,
        TaskpadNavigationTabs = 0x0020,
        SnapinMenus = 0x0040,
        SnapinToolbars = 0x0080,
        ActionsPane = 0x0100,
        All = 0xFFFF
    }

    /// <summary>
    /// Exposes controls inside Console window.
    /// </summary>
    /// <history>
    ///		[dmitriv] 6/15/2003 Created
    /// </history>
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IConsoleControls
    {
        /// <summary>
        ///		Console left-hand side tree.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        TreeView Tree { get; }

        /// <summary>
        ///		Console right-hand side details list-view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        ListView Details { get; }

        /// <summary>
        ///		Header of details list-view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        Header DetailsHeader { get; }

        /// <summary>
        ///		Status bar inside console window.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        StatusBar StatusBar { get; }

        /// <summary>
        ///		Description bar above the right-hand details view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        StaticControl DescriptionBar { get; }

        /// <summary>
        ///		Actions Pane, which appears in right side of Console
        /// </summary>
        /// <history>
        ///		[faisalb] 10/28/2003 Created
        /// </history>
        ActionsPane ActionsPane { get;}
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Console
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Represents Console Window inside MMC.
    /// </summary>
    /// <history>
    /// 	[dmitriv] 6/15/2003 Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class Console : Window, IConsoleControls
    {
        #region Constants
        private class ControlIDs
        {
            public const int TreeView = 0x31F1;
            public const int DescriptionBar = 0x31F7;
            public const int ListView = 0x31F2;
            public const int StatusBar = 0x1003;
        }
        #endregion

        #region Constructors, private variables
        private MmcApp app;
        private ConsoleNode rootNode = null;
        private int DefaultMaxTimeOut = 10000; //Maximum 10 seconds
        private const string HtmlTaskClassName = "task";

        /// <summary>
        ///		Constructor for the currently active console window.
        /// </summary>
        /// <param name="app">Application which owns this console.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console(MmcApp app) : this(app, null, 1)
        {
        }

        /// <summary>
        ///		Constructor the named window.
        /// </summary>
        /// <param name="app">Application which owns this console.</param>
        /// <param name="name">Name of the window</param>
        /// <param name="instance">
        ///		Instance of the window if there are several with the same name or name is null.
        ///	</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console(MmcApp app, string name, int instance) : base(GetConsole(app, name, instance))
        {
            this.app = app;
        }

        /// <summary>
        /// Creates new console window using specified command method.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="createUsing">Command method to use.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console(MmcApp app, CommandMethod createUsing) : base(CreateConsole(app, createUsing))
        {
            this.app = app;
        }

        /// <summary>
        /// Finds console window inside the MDI frame.
        /// </summary>
        /// <param name="app">MMC Application.</param>
        /// <param name="name">Name of console window.</param>
        /// <param name="instance">Instance in case there are more than 1 window with the same name.</param>
        /// <returns>Window handle.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private static IntPtr GetConsole(MmcApp app, string name, int instance)
        {
            UISynchronization.WaitForUIObjectReady(app.MainWindow);
            Window wnd = new Window(name, StringMatchSyntax.ExactMatch,
                MmcApp.Strings.MMCChildFrm, StringMatchSyntax.ExactMatch,
                app, app.Controls.MdiContainer, 1000, false, false, instance);
            return wnd.Extended.HWnd;
        }

        /// <summary>
        /// Creates new Console window using given command method.
        /// </summary>
        /// <param name="app">MMC application.</param>
        /// <param name="createUsing">Command method to use.</param>
        /// <returns>Create console window HWND.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private static IntPtr CreateConsole(MmcApp app, CommandMethod createUsing)
        {
            Commands.WindowNewWindow.Execute(app, createUsing);
            // just return the first window - should be top-most
            return GetConsole(app, null, 1);
        }
        #endregion

        #region Controls
        /// <summary>
        /// Provides access to all console window controls.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public IConsoleControls Controls
        {
            get
            {
                return this;
            }
        }

        TreeView IConsoleControls.Tree
        {
            get
            {
                return new TreeView(this, ControlIDs.TreeView);
            }
        }

        ListView IConsoleControls.Details
        {
            get
            {
                return new ListView(this, ControlIDs.ListView);
            }
        }

        Header IConsoleControls.DetailsHeader
        {
            get
            {
                return new Header(Controls.Details.Extended.FirstChild);
            }
        }

        StatusBar IConsoleControls.StatusBar
        {
            get
            {
                return new StatusBar(this, ControlIDs.StatusBar);
            }
        }

        StaticControl IConsoleControls.DescriptionBar
        {
            get
            {
                return new StaticControl(this, ControlIDs.DescriptionBar);
            }
        }

        /// <summary>
        /// Provides access to Actions Pane from Console
        /// </summary>
        /// <history>
        ///		[faisalb]	10/28/2003	Created
        /// </history>
        ActionsPane IConsoleControls.ActionsPane
        {
            get
            {
                return new ActionsPane(this);
            }
        }
        #endregion

        #region Indexers
        /// <summary>
        ///		Returns node with specified index in the tree.
        /// </summary>
        /// <param name="index">Index of the node to return.</param>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode this[int index]
        {
            get
            {
                return RootNode[index];
            }
        }

        /// <summary>
        ///		Returns node with specified path from the tree.
        /// </summary>
        /// <param name="path">Path of the node to return.</param>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode this[string path]
        {
            get
            {
                return RootNode[path];
            }
        }

        /// <summary>
        ///		Returns node with specified path from the tree.
        /// </summary>
        /// <param name="path">Path of the node to return.</param>
        /// <param name="instance">Instance of the node with the same path to return.</param>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode this[string path, int instance]
        {
            get
            {
                return RootNode[path, instance];
            }
        }
        #endregion

        #region Properties
        /// <summary>
        ///		MMC application which contains this console window.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public new MmcApp App
        {
            get
            {
                return app;
            }
        }

        /// <summary>
        ///		Root node inside the console.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleNode RootNode
        {
            get
            {
                if (rootNode == null)
                {
                    rootNode = new ConsoleNode(this, 0);
                }
                return rootNode;
            }
        }

        /// <summary>
        ///		Provides access to console item on the list-view.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleItemCollection Items
        {
            get
            {
                return new ConsoleItemCollection(this);
            }
        }

        /// <summary>
        ///		Gets or sets console list view mode.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleViewMode ViewMode
        {
            get
            {
                SetFocus();
                app.Menu[app.GetIntlStr(Commands.Strings.View)].Execute();
                Menu menu = new Menu();
                ConsoleViewMode result = ConsoleViewMode.Detail;
                if (menu[app.GetIntlStr(Commands.Strings.ViewLargeIcons)].Checked)
                    result = ConsoleViewMode.LargeIcons;
                else if (menu[app.GetIntlStr(Commands.Strings.ViewSmallIcons)].Checked)
                    result = ConsoleViewMode.SmallIcons;
                else if (menu[app.GetIntlStr(Commands.Strings.ViewList)].Checked)
                    result = ConsoleViewMode.List;
                app.MainWindow.SendKeys("{ESC}");
                return result;
            }
            set
            {
                SetFocus();
                switch (value)
                {
                    case ConsoleViewMode.LargeIcons:
                        Commands.ViewLargeIcons.Execute(app, CommandMethod.MainMenu);
                        break;
                    case ConsoleViewMode.SmallIcons:
                        Commands.ViewSmallIcons.Execute(app, CommandMethod.MainMenu);
                        break;
                    case ConsoleViewMode.List:
                        Commands.ViewList.Execute(app, CommandMethod.MainMenu);
                        break;
                    case ConsoleViewMode.Detail:
                        Commands.ViewDetail.Execute(app, CommandMethod.MainMenu);
                        break;
                }
                UISynchronization.WaitForUIObjectReady(Controls.Details);
            }
        }

        /// <summary>
        ///		Gets or sets whether console tree is visible.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public bool ShowConsoleTree
        {
            get
            {
                SetFocus();
                return (Commands.ViewShowHideConsoleTree.GetToolbarItem(app).AccessibleObject.State & (int)MsaaStates.Checked) != 0;
            }
            set
            {
                SetFocus();
                if (ShowConsoleTree != value)
                    Commands.ViewShowHideConsoleTree.Execute(app);
                UISynchronization.WaitForUIObjectReady(this);
            }
        }

        /// <summary>
        ///		Gets or sets whether Actions Pane is visible.
        /// </summary>
        /// <history>
        ///		[faisalb] 10/28/2003 Created
        /// </history>
        public bool ShowActionsPane
        {
            get
            {
                SetFocus();
                return (Commands.ViewShowHideActionsPane.GetToolbarItem(app).AccessibleObject.State & (int)MsaaStates.Checked) != 0;
            }
            set
            {
                SetFocus();
                if (ShowActionsPane != value)
                    Commands.ViewShowHideActionsPane.Execute(app);
                UISynchronization.WaitForUIObjectReady(this);
            }
        }

        /// <summary>
        ///		Gets or sets view options on the console window using View | Options dialog.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public ConsoleViewOptions ViewOptions
        {
            get
            {
                SetFocus();
                ConsoleViewOptions options = 0;
                CustomizeViewDialog dialog = new CustomizeViewDialog(app);
                if (dialog.Controls.ConsoleTreeCheckBox.Checked)
                    options |= ConsoleViewOptions.ConsoleTree;
                if (dialog.Controls.StandardMenusCheckBox.Checked)
                    options |= ConsoleViewOptions.StandardMenus;
                if (dialog.Controls.StandardToolbarCheckBox.Checked)
                    options |= ConsoleViewOptions.StandardToolbar;
                if (dialog.Controls.DescriptionBarCheckBox.Checked)
                    options |= ConsoleViewOptions.DescriptionBar;
                if (dialog.Controls.StatusbarCheckBox.Checked)
                    options |= ConsoleViewOptions.StatusBar;
                if (dialog.Controls.TaskPadNavigationTabsCheckBox.Checked)
                    options |= ConsoleViewOptions.TaskpadNavigationTabs;
                if (dialog.Controls.SnapinMenusCheckBox.Checked)
                    options |= ConsoleViewOptions.SnapinMenus;
                if (dialog.Controls.SnapinToolbarsCheckBox.Checked)
                    options |= ConsoleViewOptions.SnapinToolbars;
                if (dialog.Controls.ActionsPaneCheckBox.Checked)
                    options |= ConsoleViewOptions.ActionsPane;

                dialog.ClickOK();
                return options;
            }
            set
            {
                SetFocus();
                CustomizeViewDialog dialog = new CustomizeViewDialog(app);
                dialog.Controls.ConsoleTreeCheckBox.Checked = (value & ConsoleViewOptions.ConsoleTree) != 0;
                dialog.Controls.StandardMenusCheckBox.Checked = (value & ConsoleViewOptions.StandardMenus) != 0;
                dialog.Controls.StandardToolbarCheckBox.Checked = (value & ConsoleViewOptions.StandardToolbar) != 0;
                dialog.Controls.DescriptionBarCheckBox.Checked = (value & ConsoleViewOptions.DescriptionBar) != 0;
                dialog.Controls.StatusbarCheckBox.Checked = (value & ConsoleViewOptions.StatusBar) != 0;
                dialog.Controls.TaskPadNavigationTabsCheckBox.Checked = (value & ConsoleViewOptions.TaskpadNavigationTabs) != 0;
                dialog.Controls.ActionsPaneCheckBox.Checked = (value & ConsoleViewOptions.ActionsPane) != 0;
                dialog.Controls.SnapinMenusCheckBox.Checked = (value & ConsoleViewOptions.SnapinMenus) != 0;
                dialog.Controls.SnapinToolbarsCheckBox.Checked = (value & ConsoleViewOptions.SnapinToolbars) != 0;
                dialog.ClickOK();
            }
        }

        /// <summary>
        ///		Gets or sets display column list.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public string[] DisplayColumnList
        {
            get
            {
                SetFocus();
                AddRemoveColumnsDialog dialog = new AddRemoveColumnsDialog(app);
                string[] result = dialog.ColumnList;
                dialog.ClickCancel();
                return result;
            }
            set
            {
                SetFocus();
                AddRemoveColumnsDialog dialog = new AddRemoveColumnsDialog(app);
                dialog.ColumnList = value;
                dialog.ClickOK();
            }
        }

        /// <summary>
        ///		Returns status bar text.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public string StatusBarText
        {
            get
            {
                return Controls.StatusBar.Panels[0].Text;
            }
        }

        /// <summary>
        ///		Gets HTML page on the right side, if present.
        /// </summary>
        /// <history>
        ///		[dmitriv] 6/15/2003 Created
        /// </history>
        public HtmlDocument HtmlPage
        {
            get
            {
                Window wnd = new Window("*", StringMatchSyntax.WildCard, WindowClassNames.InternetExplorerServer, StringMatchSyntax.ExactMatch, this, 5000);
                UISynchronization.WaitForUIObjectReady(wnd);
                return new HtmlDocument(wnd);
            }
        }
        #endregion

        #region Methods
        /// <summary>
        ///		Searches for a node with specified name under root node.
        /// </summary>
        /// <param name="text">Text of a node to find.</param>
        /// <returns>Found node or null if not found.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public ConsoleNode Find(string text)
        {
            return RootNode.Find(text);
        }

        /// <summary>
        ///		Maximizes console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Maximize()
        {
            State = WindowState.Maximize;
        }

        /// <summary>
        ///		Minimizes console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Minimize()
        {
            State = WindowState.Minimize;
        }

        /// <summary>
        ///		Restores console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Restore()
        {
            State = WindowState.Restore;
        }

        /// <summary>
        ///		Restores default column list in the list view.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void RestoreDefaultDisplayColumns()
        {
            SetFocus();
            AddRemoveColumnsDialog dialog = new AddRemoveColumnsDialog(app);
            dialog.ClickRestoreDefaults();
            dialog.ClickOK();
        }

        /// <summary>
        ///		Saves console.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Save()
        {
            Save(CommandMethod.Default);
        }

        /// <summary>
        ///		Saves console.
        /// </summary>
        /// <param name="method">How to invoke the command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Save(CommandMethod method)
        {
            SetFocus();
            Commands.FileSave.Execute(app, method);
            UISynchronization.WaitForUIObjectReady(this);
        }

        /// <summary>
        ///		Opens and returns Console Options dialog.
        /// </summary>
        /// <returns>Opened dialog instance.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Dialogs.OptionsDialog OpenOptionsDialog()
        {
            SetFocus();
            return new Dialogs.OptionsDialog(app);
        }

        /// <summary>
        ///		Saves console in specified file.
        /// </summary>
        /// <param name="fileName">File where to save.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void SaveAs(string fileName)
        {
            SaveAs(fileName, CommandMethod.Default);
        }

        /// <summary>
        ///		Saves console in specified file.
        /// </summary>
        /// <param name="fileName">File where to save.</param>
        /// <param name="method">How to invoke the command.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///     [faisalb]   10/29/2004  Changed from "Save*" to "Save" and class name from "null" to "Button" because it searching something else with same title. So Save As was failing. Also added Timeout for WaitForInvalid because in XPSP2 it takes longer time
        /// </history>
        public void SaveAs(string fileName, CommandMethod method)
        {
            SetFocus();
            Commands.FileSaveAs.Execute(app, method);

            // HACK: use the actual Open dialog when it's implemented in Maui.Windows
            Window wnd = new Window("Save As", StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            new TextBox(wnd, 0x47C).Text = fileName;

            //Changed from "Save*" to "Save" and class name from "null" to "Button" because it searching something else with same title. So Save As was failing.
            new Button(wnd, "Save", StringMatchSyntax.ExactMatch, "Button", StringMatchSyntax.WildCard).Click();

            //After XPSP, Common Dialog takes long time to go away.
            wnd.WaitForInvalid(DefaultMaxTimeOut);
            // END HACK

            UISynchronization.WaitForUIObjectReady(this);
        }

        /// <summary>
        ///		Closes this console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void Close()
        {
            CloseWindow();
            WaitForInvalid();
        }

        /// <summary>
        ///		Navigates on a link inside right-hand IE page.
        /// </summary>
        /// <param name="linkName">Name of the link on which to navigate.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void NavigateOnLink(string linkName)
        {
            new Core.HtmlControls.HtmlLink(HtmlPage, "A", linkName).Click();
            UISynchronization.WaitForUIObjectReady(this);
            App.MainWindow.WaitForResponse();
        }

        /// <summary>
        /// Executes taskName from the Taskpad view.
        /// </summary>
        /// <param name="taskName">Name of the task to execute.</param>
        /// <history>
        ///		[zeghmit]	12/5/2003	Created
        ///		[dmitriv]	11/09/2004	Fixed to find the correct link element
        /// </history>
        internal void ExecuteTaskNoSelect(string taskName)
        {
            if (Core.Resources.ResourceManager.IsResourceID(taskName))
                taskName = App.GetIntlStr(taskName);

            // First try to see if the HTML link for the task is used with an
            // A tag.  
            //
            // If not, then we try to search for the element by inner text.  
            // If that did not work, then we throw an exception.
            try
            {
                new Core.HtmlControls.HtmlLink(HtmlPage, "A", taskName).Click();
            }
            catch (Maui.GlobalExceptions.MauiException)
            {
                // Search for the task HTML element.
                bool found = false;
                foreach (mshtml.IHTMLElement elem in HtmlPage.Document2.all)
                {
                    try
                    {
                        if ((elem.innerHTML != null) &&
                            (elem.innerHTML.Trim() == taskName.Trim()) &&
                            (elem.className.ToLower() == HtmlTaskClassName))
                        {
                            elem.click();
                            found = true;
                            break;
                        }
                    }
                    catch (System.NullReferenceException)
                    {
                        // has no className, try next
                    }
                }

                if (!found)
                    throw new NotImplementedException("Executing the task in the form in which it is " +
                        "launched in HTML or otherwise is not yet implemented.  Or " + taskName + " does not exist");
            }

            WaitForResponse();
        }

        #endregion
    }

    #region ConsoleCollection
    ///  Project   : Maui.ManagementConsole
    ///  Class     : ConsoleCollection
    /// 
    ///  Copyright (C) 2002, Microsoft Corporation
    /// ------------------------------------------------------------------------------
    ///  <summary>
    ///  Strongly-typed collection of Console objects
    ///  </summary>
    ///  <remarks></remarks>
    ///  <history>
    ///      [dmitriv] 5/10/2003  Created
    ///  </history>
    [Serializable()]
    public class ConsoleCollection : ICollection
    {
        private MmcApp app;

        /// <summary>
        ///		Constructor.
        /// </summary>
        /// <param name="app">MMC Application.</param>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        internal ConsoleCollection(MmcApp app)
        {
            this.app = app;
        }

        /// <summary>
        ///		Returns console with specified index.
        /// </summary>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public Console this[int index]
        {
            get
            {
                if (index < 0 || index > Count - 1)
                    throw new IndexOutOfRangeException("Index of Console Window is out of range - should be 0 <= index <= " + Count);
                return new Console(app, null, index + 1);
            }
        }

        /// <summary>
        ///		Returns console with specified name.
        /// </summary>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public Console this[string name]
        {
            get
            {
                return new Console(app, name, 1);
            }
        }

        /// <summary>
        ///		Returns console with specified name and instance number (1-based).
        /// </summary>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public Console this[string name, int instance]
        {
            get
            {
                return new Console(app, name, instance);
            }
        }

        /// <summary>
        /// Returns the count of Console Windows.
        /// </summary>
        public int Count
        {
            get
            {
                return app.Controls.MdiContainer.Extended.ChildrenCount;
            }
        }

        object ICollection.SyncRoot
        {
            get
            {
                return this;
            }
        }

        bool ICollection.IsSynchronized
        {
            get
            {
                return false;
            }
        }

        void ICollection.CopyTo(System.Array array, int index)
        {
            for (int i = 0; i < Count; i++)
                array.SetValue(this[i], index + i);
        }

        ///  <summary>
        ///    Returns an enumerator that can iterate through 
        ///       the <see cref="Maui.ManagementConsole.ConsoleCollection"/> .
        ///  </summary>
        ///  <returns>An enumerator for the collection</returns>
        ///  <remarks><seealso cref="System.Collections.IEnumerator"/></remarks>
        ///  <history>
        ///      [dmitriv] 5/10/2003  Created
        ///  </history>
        public IEnumerator GetEnumerator()
        {
            return new ConsoleEnumerator(this);
        }

        #region ConsoleEnumerator
        private class ConsoleEnumerator : object, IEnumerator
        {
            private ConsoleCollection baseCollection;
            private int index;

            public ConsoleEnumerator(ConsoleCollection mappings)
            {
                baseCollection = mappings;
                index = -1;
            }

            object IEnumerator.Current
            {
                get
                {
                    return baseCollection[index];
                }
            }

            public bool MoveNext()
            {
                index++;
                return index <= baseCollection.Count - 1;
            }

            public void Reset()
            {
                index = -1;
            }
        }
        #endregion
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\ConsoleActions.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using System.Runtime.Serialization;
	using Maui.Core;
	using Maui.Core.Utilities;
	using Maui.Core.WinControls;

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: ConsoleActions
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Encapsulates actions available on both ConsoleNode and ConsoleItem.
	/// </summary>
	/// <history>
	///		[dmitriv]	7/5/2003	Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class ConsoleActions : Maui.Core.RemotingObject
	{
		#region Exceptions
		public class Exceptions
		{
			private Exceptions() {} // non-creatable class
			
			[Serializable]
				public class RenameFailedException : GlobalExceptions.MauiException 
			{
				public RenameFailedException() {}
				public RenameFailedException(string message) : base(message) {}
				public RenameFailedException(string message, Exception innerException) : base(message, innerException) {}
				protected RenameFailedException(SerializationInfo info, StreamingContext context) : base(info, context) {}
			}
		}
		#endregion

		#region Constructor, variables
		private ICommandTarget target;
		private Console console;

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns the target.</param>
		/// <param name="target">Target node or item.</param>
		///  <history>
		///      [dmitriv] 5/10/2003  Created
		///  </history>
		internal ConsoleActions(Console console, ICommandTarget target)
		{
			this.console = console;
			this.target = target;
		}
		#endregion

		/// <summary>
		///		Invokes "New Window from Here" command on target element.
		/// </summary>
		/// <returns>New console window.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console NewWindowFromHere()
		{
			return NewWindowFromHere(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes "New Window from Here" command on target element.
		/// </summary>
		/// <param name="method">How to invoke target command.</param>
		/// <returns>New console window.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console NewWindowFromHere(CommandMethod method)
		{
			Commands.ActionNewWindowFromHere.Execute(target, method);
			return new Console(console.App);
		}

		/// <summary>
		///		Renames current node.
		/// </summary>
		/// <param name="newName">New name of the element.</param>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Rename (string newName)
		{
			Rename(newName, CommandMethod.Default);
		}

		/// <summary>
		///		Renames current node.
		/// </summary>
		/// <param name="newName">New name of the element.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Rename (string newName, CommandMethod method)
		{
			Commands.ActionRename.Execute(target, method);
			new TextBox(new Window(WindowType.Focused)).Text = newName;
			Keyboard.SendKeys("{ENTER}");
			console.WaitForResponse();
			string text = target is ConsoleNode ? (target as ConsoleNode).Text : (target as ConsoleItem).Text;
			if (text != newName)
				throw new Exceptions.RenameFailedException("Unable to rename element.\n"+
					"Expected name: " + newName + "\n"+
					"Actual name: " + text + "\n");
		}

		/// <summary>
		///		Deletes current node from console.
		/// </summary>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Delete()
		{
			Delete(AlertAction.ClickYes, CommandMethod.Default);
		}

		/// <summary>
		///		Deletes current node from console.
		/// </summary>
		/// <param name="alertAction">Alert action to use in case of alert.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv] 7/5/2003 Created
		/// </history>
		public void Delete(AlertAction alertAction, CommandMethod method)
		{
			Commands.ActionDelete.Execute(target, method);
			if (alertAction != AlertAction.NoAction)
			{
				Alert alert = Alert.HandleAlert(null, AlertAction.NoAction, console.App.MainWindow, 2000);
				alert.PerformAlertAction(alertAction);
				UISynchronization.WaitForUIObjectReady(console);
			}
		}

		/// <summary>
		///		Invokes Refresh action on the element.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Refresh()
		{
			Refresh(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes Refresh action on the element.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Refresh(CommandMethod method)
		{
			Commands.ActionRefresh.Execute(target, method);
			UISynchronization.WaitForUIObjectReady(console);
		}

		/// <summary>
		///		Invokes NewTaskPadView action on the element.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void NewTaskPadView()
		{
			NewTaskPadView(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes NewTaskPadView action on the element.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void NewTaskPadView(CommandMethod method)
		{
			Commands.ActionNewTaskPadView.Execute(target, method);
			// TODO: need a dialog class and handle the dialog or return it
		}

		/// <summary>
		///		Invokes AllTasks action on the element.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExecuteTask(string taskName)
		{
			ExecuteTask(taskName, CommandMethod.Default);
		}

		/// <summary>
		///		Invokes AllTasks action on the element.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExecuteTask(string taskName, CommandMethod method)
		{
			Command cmd = new Command(Commands.ActionAllTasks.MainMenuPath + taskName, Commands.ActionAllTasks.ContextMenuPath + taskName);
			cmd.Execute(target, method);
		}

		/// <summary>
		/// Executes taskName from the Taskpad view on this console node.  A task item is not selected.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <history>
		///		[zeghmit]	12/5/2003	Created
		/// </history>
		public void ExecuteHTMLTask (string taskName)
		{
			this.console.ExecuteTaskNoSelect(taskName);
		}

		/// <summary>
		///		Invokes New action on the element.
		/// </summary>
		/// <param name="newItemType">Name of new item type to invoke command.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void AddNew(string newItemType)
		{
			AddNew(newItemType, CommandMethod.Default);
		}

		/// <summary>
		///		Invokes New action on the element.
		/// </summary>
		/// <param name="newItemType">Name of new item type to invoke command.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void AddNew(string newItemType, CommandMethod method)
		{
			Command cmd = new Command(Commands.ActionNew.MainMenuPath + newItemType, Commands.ActionNew.ContextMenuPath + newItemType);
			cmd.Execute(target, method);
		}

		/// <summary>
		///		Invokes ExportList action on the element.
		/// </summary>
		/// <param name="fileName">File name to where to export.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExportList(string fileName)
		{
			ExportList(fileName, CommandMethod.Default);
		}

		/// <summary>
		///		Invokes ExportList action on the element.
		/// </summary>
		/// <param name="fileName">File name to where to export.</param>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ExportList(string fileName, CommandMethod method)
		{
			Commands.ActionExportList.Execute(target, method);

			// HACK: use the actual Open dialog when it's implemented in Maui.Windows
			Window wnd = new Window("Export List...", StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, console.App, 3000);
			new TextBox(wnd, 0x47C).Text = fileName;
			new Button(wnd, "Save*", StringMatchSyntax.WildCard, null, StringMatchSyntax.ExactMatch).Click();
			wnd.WaitForInvalid();
			// END HACK

			UISynchronization.WaitForUIObjectReady(console);
		}

		/// <summary>
		///		Invokes Help action on the element.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ViewHelp()
		{
			ViewHelp(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes Help action on the element.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void ViewHelp(CommandMethod method)
		{
			Commands.ActionHelp.Execute(target, method);
		}

		/// <summary>
		///		Invokes and returns properties dialog on target element.
		/// </summary>
		/// <returns>Properties dialog.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Dialogs.PropertiesDialog ViewProperties()
		{
			return ViewProperties(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes and returns properties dialog on target element.
		/// </summary>
		/// <param name="method">How to invoke target action.</param>
		/// <returns>Properties dialog.</returns>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Dialogs.PropertiesDialog ViewProperties(CommandMethod method)
		{
			Commands.ActionProperties.Execute(target, method);
			return new Dialogs.PropertiesDialog(console.App, console.App.MainWindow);
		}

		/// <summary>
		///		Invokes and returns properties dialog on target element. 
		/// </summary>
		/// <param name="method">How to invoke target action.</param>
		/// <param name="className">The window class type of the expected dialog</param>
		/// <param name="classNameMatchSyntax">The String Match Syntax for the parameter className</param>
		/// <returns>Properties dialog.</returns>
		/// <history>
		///		[carolli] 11/23/2004 Created
		/// </history>		 
		public Dialogs.PropertiesDialog ViewProperties(CommandMethod method, string className, StringMatchSyntax classNameMatchSyntax)
		{
			Commands.ActionProperties.Execute(target, method);
			return new Dialogs.PropertiesDialog(console.App, console.App.MainWindow, className, classNameMatchSyntax);
		}

		/// <summary>
		///		Invokes Open action on the node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Open()
		{
			Open(CommandMethod.Default);
		}

		/// <summary>
		///		Invokes Open action on the node.
		/// </summary>
		/// <param name="method">How to invoke the action.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public void Open(CommandMethod method)
		{
			Commands.ActionOpen.Execute(target, method);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\ConsoleItem.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using System.Collections;
	using Maui.Core;
	using Maui.Core.WinControls;

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: ConsoleItem
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Abstraction of a node of right-hand side list-view inside Console Window.
	/// </summary>
	/// <history>
	///		[dmitriv] 6/15/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class ConsoleItem : ListViewItem, ICommandTarget
	{
		#region Constructors, private variables
		private Console console = null;

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this item.</param>
		/// <param name="index">Index of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (Console console, int index) : base(console.Controls.Details, index)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this item.</param>
		/// <param name="name">Path of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (Console console, string name) : base(console.Controls.Details, name)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="node">Console node which owns this item.</param>
		/// <param name="index">Index of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (ConsoleNode node, int index) : base(node.GetDetailsView(), index)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="node">Console node which owns this item.</param>
		/// <param name="name">Name of the item.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItem (ConsoleNode node, string name) : base(node.GetDetailsView(), name)
		{
			this.console = console;
		}
		#endregion
	
		#region ICommandTarget implementation
		/// <summary>
		///		Invokes and returns context menu on this node selecting it beforehand.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public override Menu ContextMenu
		{
			get
			{
				return GetContextMenu(true);
			}
		}

		/// <summary>
		///		Selects the node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new void Select()
		{
			base.Select();
			Core.UISynchronization.WaitForUIObjectReady(console);
			console.WaitForResponse();
			console.App.MainWindow.WaitForResponse();
		}

		/// <summary>
		///		Application which owns this item.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		App ICommandTarget.App
		{
			get
			{
				return Console.App;
			}
		}

		/// <summary>
		///		Window to wait on after operation.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/31/2003	Created
		/// </history>
		Window ICommandTarget.TargetWindow
		{
			get
			{
				return Console.Controls.Details;
			}
		}
		#endregion

		#region Properties
		/// <summary>
		///		Returns console containing this node.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console Console
		{
			get
			{
				return console;
			}
		}

		/// <summary>
		///		Actions available on this item.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public ConsoleActions Actions
		{
			get
			{
				return new ConsoleActions(Console, this);
			}
		}
		#endregion

		#region Methods
		/// <summary>
		///		Invokes and returns context menu for this node.
		/// </summary>
		/// <param name="selectNodeFirst">Whether to select the node before right-click on it.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Menu GetContextMenu (bool selectNodeFirst)
		{
			if (selectNodeFirst)
				Select();
			else
				EnsureVisible();
			return new Menu(Left + 10, Top + Height/2);
		}

		/// <summary>
		/// Executes task from the Taskpad view on this item.
		/// </summary>
		/// <param name="taskName">Name of the task to execute.</param>
		/// <history>
		///		[dmitriv] 11/22/2003 Created
		//		[zeghmit] 12/05/2003 Moved code to Console.
		/// </history>
		public void ExecuteTask (string taskName)
		{
			UISynchronization.WaitForUIObjectReady(ParentListView);
			Select();
			Console.ExecuteTaskNoSelect(taskName); 
		}
		#endregion		
	}

	#region ConsoleItemCollection
	/// ------------------------------------------------------------------------------
	///  Project   : Maui.ManagementConsole
	///  Class     : ConsoleItemCollection
	/// 
	///  Copyright (C) 2002, Microsoft Corporation
	/// ------------------------------------------------------------------------------
	///  <summary>
	///		Strongly-typed collection of ConsoleItem objects
	///  </summary>
	///  <remarks></remarks>
	///  <history>
	///      [dmitriv] 7/5/2003  Created
	///  </history>
	/// ------------------------------------------------------------------------------
	[Serializable()]
	public class ConsoleItemCollection : Core.RemotingObject, ICollection
	{
		private Console console;
		private ListView listView;

		///  <summary>
		///       Initializes a new instance of <see cref="Maui.ManagementConsole.ConsoleItemCollection"/>.
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		internal ConsoleItemCollection(Console console)
		{
			this.console = console;
			this.listView = console.Controls.Details;
		}
        
		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleItem"/>.
		///  </summary>
		///  <param name="index">The zero-based index of the entry to locate in the collection.</param>
		///  <value>
		///		The entry at the specified index of the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleItem this[int index] 
		{
			get 
			{
				return new ConsoleItem(console, index);
			}
		}

		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleItem"/>.
		///  </summary>
		///  <param name="name">Name of the entry to locate in the collection.</param>
		///  <value>
		///		The entry with the specified name in the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleItem this[string name] 
		{
			get 
			{
				return new ConsoleItem(console, name);
			}
		}        
        
		///  <summary>
		///		Copies the <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> values
		///		to a one-dimensional <see cref="System.Array"/> instance at the  specified index.
		///  </summary>
		///  <param name="array">The one-dimensional <see cref="System.Array"/> that is the destination of the values copied from <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> .</param>
		///  <param name="index">The index in <paramref name="array"/> where copying begins.</param>
		///  <remarks><exception cref="System.ArgumentException"><paramref name="array"/> is multidimensional. <para>-or-</para> <para>The number of elements in the <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> is greater than the available space between <paramref name="arrayIndex"/> and the end of <paramref name="array"/>.</para></exception>
		///  <exception cref="System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>. </exception>
		///  <exception cref="System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than <paramref name="array"/>"s lowbound. </exception>
		///  <seealso cref="System.Array"/>
		///  </remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public void CopyTo(Array array, int index) 
		{
			for (int i = 0; i < Count; i++)
				array.SetValue(this[i], index+i);
		}
        
		///  <summary>
		///    Returns an enumerator that can iterate through 
		///    the <see cref="Maui.ManagementConsole.ConsoleItemCollection"/> .
		///  </summary>
		///  <returns>An enumerator for the collection</returns>
		///  <remarks><seealso cref="System.Collections.IEnumerator"/></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public IEnumerator GetEnumerator() 
		{
			return new ConsoleItemEnumerator(this);
		}

		/// <summary>
		///		Returns number of items in collection.
		/// </summary>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public int Count
		{
			get
			{
				return listView.Count;
			}
		}

		/// <summary>
		///		Whether collection is syncrhonized.
		/// </summary>
		bool ICollection.IsSynchronized
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		///		SyncRoot for collection.
		/// </summary>
		object ICollection.SyncRoot
		{
			get
			{
				return this;
			}
		}
        
		#region ConsoleItemEnumerator
		private class ConsoleItemEnumerator : object, IEnumerator 
		{            
			private ConsoleItemCollection baseCollection;
			private int index = -1;
            
			public ConsoleItemEnumerator(ConsoleItemCollection baseCollection)
			{
				this.baseCollection = baseCollection;
				this.index = -1;
			}
            
			public object Current 
			{
				get 
				{
					return baseCollection[index];
				}
			}
            
			public bool MoveNext() 
			{
				return ++index < baseCollection.Count;
			}
            
			public void Reset() 
			{
				index = -1;
			}
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\ConsoleNode.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using System.Collections;
	using Maui.Core;
	using Maui.Core.WinControls;

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: ConsoleNode
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Abstraction of a node of left-hand side tree-view inside Console Window.
	/// </summary>
	/// <history>
	///		[dmitriv] 6/15/2003 Created
	/// </history>
	/// -----------------------------------------------------------------------------
	public class ConsoleNode : TreeNode, ICommandTarget
	{
		#region Constructors, private variables
		private Console console = null;

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="index">Index of the node.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode (Console console, int index) : base(console.Controls.Tree, index)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="path">Path of the node.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode (Console console, string path) : base(console.Controls.Tree, path)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="path">Path of the node.</param>
		/// <param name="instance">Instance of the node under the same path.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode (Console console, string path, int instance) : base(console.Controls.Tree, path, instance)
		{
			this.console = console;
		}

		/// <summary>
		///		Constructor for known tree node.
		/// </summary>
		/// <param name="console">Console which owns this node.</param>
		/// <param name="node">Known tree node.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		internal ConsoleNode (Console console, TreeNode node) : base(node.HWnd, node.TreeView)
		{
			this.console = console;
		}
		#endregion

		#region Indexers
		/// <summary>
		///		Returns sub-node with specified index in the tree.
		/// </summary>
		/// <param name="index">Index of the node to return.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public new ConsoleNode this [int index]
		{
			get
			{
				if (IsExpandable && !Expanded)
					Expand(true);
				return new ConsoleNode(console, (this as TreeNode)[index]);
			}
		}

		/// <summary>
		///		Expands tree node and waits for node to be expanded.
		///		To be used internally in places where we know node has to have children.
		/// </summary>
		/// <param name="node">Tree node to expand.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		private void ExpandAndWait (TreeNode node)
		{
			node.Expand(true);
			Core.Utilities.Sleeper sleeper = new Core.Utilities.Sleeper(30000);
			while (!node.IsExpandable)
			{
				sleeper.Sleep();
			}
		}

		/// <summary>
		///		Returns sub-node with specified path from the tree.
		/// </summary>
		/// <param name="path">Path of the node to return.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public new ConsoleNode this [string path]
		{
			get
			{
				TreeNode node = this;
				foreach (string pathItem in path.Split(TreeView.PathDelim.ToCharArray()))
				{
					if (node.IsExpandable && !node.Expanded)
					{
						ExpandAndWait(node);
					}
					node = (node as TreeNode)[pathItem];
				}
				return new ConsoleNode(console, node);
			}
		}

		/// <summary>
		///		Returns sub-node with specified path from the tree.
		/// </summary>
		/// <param name="path">Path of the node to return.</param>
		/// <param name="instance">Instance of the node with the same path to return.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleNode this[string path, int instance]
		{
			get
			{
				TreeNode node = this;
				string[] items = path.Split(TreeView.PathDelim.ToCharArray());
				for (int i = 0; i < items.Length; i++)
				{
					if (node.IsExpandable && !node.Expanded)
						ExpandAndWait(node);
					if (i < items.Length-1)
						node = (node as TreeNode)[items[i]];
					else
						node = (node as TreeNode)[items[i], instance, true];
				}
				return new ConsoleNode(console, node);
			}
		}
		#endregion

		#region ICommandTarget implementation
		/// <summary>
		///		Invokes and returns context menu on this node selecting it beforehand.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public override Menu ContextMenu
		{
			get
			{
				return GetContextMenu(true);
			}
		}

		/// <summary>
		/// Selects the node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new void Select()
		{
			Console.Extended.SetFocus();
			base.Select();
			Core.UISynchronization.WaitForUIObjectReady(console);
			console.WaitForResponse();
			console.App.MainWindow.WaitForResponse();
		}

		/// <summary>
		/// Application which owns this item.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		App ICommandTarget.App
		{
			get
			{
				return Console.App;
			}
		}

		/// <summary>
		///		Window to wait on after operation.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/31/2003	Created
		/// </history>
		Window ICommandTarget.TargetWindow
		{
			get
			{
				return Console.Controls.Tree;
			}
		}
		#endregion

		#region Properties
		/// <summary>
		///		Returns console containing this node.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Console Console
		{
			get
			{
				return console;
			}
		}		

		/// <summary>
		///		Provides access to parent node of this node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new ConsoleNode ParentNode
		{
			get
			{
				return new ConsoleNode(console, base.ParentNode);
			}
		}

		/// <summary>
		///		Provides access to child nodes of this node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new ConsoleNodeCollection Nodes
		{
			get
			{
				return new ConsoleNodeCollection(this);
			}
		}

		/// <summary>
		///		Provides access to details list-view items.
		/// </summary>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public ConsoleItemCollection Items
		{
			get
			{
				if (!Selected)
					Select();
				return new ConsoleItemCollection(Console);
			}
		}

		/// <summary>
		///		Actions available on this node.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public ConsoleActions Actions
		{
			get
			{
				return new ConsoleActions(Console, this);
			}
		}
		#endregion

		#region Methods
		/// <summary>
		///		Selects the node and returns console Details list-view.
		/// </summary>
		/// <returns>Console details list-view for this node.</returns>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		internal ListView GetDetailsView()
		{
			if (!Selected)
				Select();
			return Console.Controls.Details;
		}

		/// <summary>
		///		Searches for a node with specified name under this node.
		/// </summary>
		/// <param name="text">Text of a node to find.</param>
		/// <returns>Found node or null if not found.</returns>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public new ConsoleNode Find (string text)
		{
			if (!Expanded)
			{
				Expand(true);
			}
			foreach (TreeNode node in Nodes)
			{
				ConsoleNode cn = new ConsoleNode(Console, node);
				if (cn.Text == text)
					return cn;
				else
				{
					cn = cn.Find(text);
					if (cn != null)
						return cn;
				}
			}
			return null;
		}

		/// <summary>
		///		Invokes and returns context menu for this node.
		/// </summary>
		/// <param name="selectNodeFirst">Whether to select the node before right-click on it.</param>
		/// <history>
		///		[dmitriv] 6/15/2003 Created
		/// </history>
		public Menu GetContextMenu (bool selectNodeFirst)
		{
			if (selectNodeFirst)
				Select();
			else
				EnsureVisible();
			return new Menu(Left + 10, Top + Height/2);
		}
		#endregion
	}

	#region ConsoleNodeCollection
	/// ------------------------------------------------------------------------------
	///  Project   : Maui.ManagementConsole
	///  Class     : ConsoleNodeCollection
	/// 
	///  Copyright (C) 2002, Microsoft Corporation
	/// ------------------------------------------------------------------------------
	///  <summary>
	///		Strongly-typed collection of ConsoleNode objects
	///  </summary>
	///  <remarks></remarks>
	///  <history>
	///      [dmitriv] 7/5/2003  Created
	///  </history>
	/// ------------------------------------------------------------------------------
	[Serializable()]
	public class ConsoleNodeCollection : Core.RemotingObject, ICollection
	{
		private ConsoleNode parent;

		///  <summary>
		///       Initializes a new instance of <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/>.
		///  </summary>
		///  <remarks></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		internal ConsoleNodeCollection(ConsoleNode parent)
		{
			this.parent = parent;
		}
        
		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleNode"/>.
		///  </summary>
		///  <param name="index">The zero-based index of the entry to locate in the collection.</param>
		///  <value>
		///		The entry at the specified index of the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleNode this[int index] 
		{
			get 
			{
				return parent[index];
			}
		}

		///  <summary>
		///		Represents the entry at the specified index of the
		///		<see cref="Maui.ManagementConsole.ConsoleNode"/>.
		///  </summary>
		///  <param name="name">Name of the entry to locate in the collection.</param>
		///  <value>
		///		The entry with the specified name in the collection.
		///  </value>
		///  <remarks><exception cref="System.ArgumentOutOfRangeException"><paramref name="index"/> is outside the valid range of indexes for the collection.</exception></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public ConsoleNode this[string name] 
		{
			get 
			{
				return parent[name];
			}
		}        
        
		///  <summary>
		///		Copies the <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> values
		///		to a one-dimensional <see cref="System.Array"/> instance at the  specified index.
		///  </summary>
		///  <param name="array">The one-dimensional <see cref="System.Array"/> that is the destination of the values copied from <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> .</param>
		///  <param name="index">The index in <paramref name="array"/> where copying begins.</param>
		///  <remarks><exception cref="System.ArgumentException"><paramref name="array"/> is multidimensional. <para>-or-</para> <para>The number of elements in the <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> is greater than the available space between <paramref name="arrayIndex"/> and the end of <paramref name="array"/>.</para></exception>
		///  <exception cref="System.ArgumentNullException"><paramref name="array"/> is <see langword="null"/>. </exception>
		///  <exception cref="System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than <paramref name="array"/>"s lowbound. </exception>
		///  <seealso cref="System.Array"/>
		///  </remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public void CopyTo(Array array, int index) 
		{
			for (int i = 0; i < Count; i++)
				array.SetValue(this[i], index+i);
		}
        
		///  <summary>
		///    Returns an enumerator that can iterate through 
		///    the <see cref="Maui.ManagementConsole.ConsoleNodeCollection"/> .
		///  </summary>
		///  <returns>An enumerator for the collection</returns>
		///  <remarks><seealso cref="System.Collections.IEnumerator"/></remarks>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public IEnumerator GetEnumerator() 
		{
			return new ConsoleNodeEnumerator(this);
		}

		/// <summary>
		///		Returns number of Nodes in collection.
		/// </summary>
		///  <history>
		///      [dmitriv] 7/5/2003  Created
		///  </history>
		public int Count
		{
			get
			{
				if (parent.IsExpandable && !parent.Expanded)
					parent.Expand(true);
				return parent.ChildCount;
			}
		}

		/// <summary>
		///		Whether collection is syncrhonized.
		/// </summary>
		bool ICollection.IsSynchronized
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		///		SyncRoot for collection.
		/// </summary>
		object ICollection.SyncRoot
		{
			get
			{
				return this;
			}
		}
        
		#region ConsoleNodeEnumerator
		public class ConsoleNodeEnumerator : object, IEnumerator 
		{            
			private ConsoleNodeCollection baseCollection;
			private int index = -1;
            
			public ConsoleNodeEnumerator(ConsoleNodeCollection baseCollection)
			{
				this.baseCollection = baseCollection;
				this.index = -1;
			}
            
			public object Current 
			{
				get 
				{
					return baseCollection[index];
				}
			}
            
			public bool MoveNext() 
			{
				return ++index < baseCollection.Count;
			}
            
			public void Reset() 
			{
				index = -1;
			}
		}
		#endregion
	}
	#endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Commands.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using Maui.Core;

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: Commands
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Standard MMC command descriptors.
    /// </summary>
    /// <history>
    ///		[dmitriv]	7/5/2003	Created
    /// </history>
    /// -----------------------------------------------------------------------------
    public class Commands
    {
        /// <summary>
        ///	Command strings.
        /// </summary>
        internal class Strings
        {
            public const string File = ";&File;NativeMenuString;mmc.exe;129;1";
            public const string FileExit = File + "|;E&xit;NativeMenuString;mmc.exe;129;57665";
            public const string FileNew = File + "|;New;NativeMenuString;mmc.exe;129;57600";
            public const string FileOpen = File + "|;Open;NativeMenuString;mmc.exe;129;57601";
            public const string FileSave = File + "|;Save;NativeMenuString;mmc.exe;129;57603";
            //In MMC there are TWO spaces between Save and As.
            public const string FileSaveAs = File + "|;Save  As...;NativeMenuString;mmc.exe;129;57604";
            public const string FileOptions = File + "|;Options...;NativeMenuString;mmc.exe;129;13220";
            public const string FileAddRemoveSnapin = File + "|;Add/Remove Snap-ins...;NativeMenuString;mmc.exe;129;13201";

            public const string Action = ";&ActionAction Menu;Win32String;mmcbase.dll;14065";
            public const string ActionRefresh = ";Re&freshRefreshes the current selection.;Win32String;mmcbase.dll;14054";
            public const string ActionRename = ";Rena&meRenames the current selection.;Win32String;mmcbase.dll;14055";
            public const string ActionNewTaskpadView = ";New &Taskpad View...Creates a new taskpad view targeted at this node.;Win32String;mmcbase.dll;14057";
            public const string ActionAllTasks = ";All Tas&ksContains operations that can be performed on the object.;Win32String;mmcbase.dll;14063";
            public const string ActionNewWindowFromHere = ";New &Window from HereOpens a new window rooted at this node.;Win32String;mmcbase.dll;14047";
            public const string ActionSelectAll = ";Select &AllSelects all of the items in the listview;Win32String;mmcbase.dll;14046";
            public const string ActionProperties = ";P&ropertiesOpens property sheet for the current selection.;Win32String;mmcbase.dll;14000";
            public const string ActionExportList = ";Export &List...Exports the current list to a file.;Win32String;mmcbase.dll;14086";
            public const string ActionHelp = ";&HelpDisplays help for current selection.;Win32String;mmcbase.dll;14170";
            public const string ActionNew = ";&NewCreates a new object in this container.;Win32String;mmcbase.dll;14002";
            public const string ActionDelete = ";&DeleteDeletes the current selection.;Win32String;mmcbase.dll;14052";
            public const string ActionOpen = ";&Open;Win32String;mmcbase.dll;13349";

            public const string View = ";&View;NativeMenuString;mmc.exe;129;13239";
            public const string ViewAddRemoveColumns = View + "|;&Add/Remove Columns...;Win32String;mmcbase.dll;14001";
            public const string ViewLargeIcons = ";Lar&ge Icons;NativeMenuString;comres.dll;2937;2555";
            public const string ViewSmallIcons = ";S&mall Icons;NativeMenuString;comres.dll;2937;2557";
            public const string ViewList = ";&List;NativeMenuString;comres.dll;2937;2553";
            public const string ViewDetail = ";Detail;Win32String;UNIRES.DLL;11401";
            public const string ViewCustomize = View + "|;C&ustomize...;Win32String;mmcbase.dll;14009";

            public const string Window = ";&Window;NativeMenuString;mmc.exe;129;2";
            public const string WindowNewWindow = Window + "|;New Window;NativeMenuString;mmc.exe;129;57648";
            public const string WindowCascade = Window + "|;Cascade;NativeMenuString;mmc.exe;129;57650";
            public const string WindowTileHorizontally = Window + "|;Tile Horizontally;NativeMenuString;mmc.exe;129;57651";
            public const string WindowArrangeIcons = Window + "|;Arrange Icons;NativeMenuString;mmc.exe;129;57649";

            public const string Help = ";Help;NativeMenuString;mmc.exe;128;2";
            public const string HelpHelpTopics = Help + "|;Help Topics;NativeMenuString;mmc.exe;128;12804";
            public const string HelpAboutManagementConsole = Help + "|;About Microsoft Management Console;NativeMenuString;mmc.exe;128;57664";

            public const string ToolbarCut = ";CutCut;Win32String;mmcbase.dll;13381";
            public const string ToolbarCopy = ";CopyCopy;Win32String;mmcbase.dll;13382";
            public const string ToolbarPaste = ";PastePaste;Win32String;mmcbase.dll;13383";
            public const string ToolbarDelete = ";DeleteDelete;Win32String;mmcbase.dll;13384";
            public const string ToolbarProperties = ";PropertiesProperties;Win32String;mmcbase.dll;13385";
            public const string ToolbarUpOneLevel = ";Up One LevelUp One Level;Win32String;mmcbase.dll;13386";
            public const string ToolbarShowHideConsoleTree = ";Show/Hide Console TreeShow/Hide Console Tree;Win32String;mmcbase.dll;13387";
            public const string ToolbarShowHideActionsPane = ";Show/Hide Action PaneShow/Hide Action Pane;Win32String;mmcbase.dll;13432";
            public const string ToolbarRefresh = ";RefreshRefresh;Win32String;mmcbase.dll;13388";
            public const string ToolbarPrint = ";PrintPrint;Win32String;mmcbase.dll;13389";
            public const string ToolbarRename = ";RenameRename;Win32String;mmcbase.dll;13390";
            public const string ToolbarOpen = ";OpenOpen;Win32String;mmcbase.dll;13391";
            public const string ToolbarBack = ";BackBack;Win32String;mmcbase.dll;13392";
            public const string ToolbarForward = ";ForwardForward;Win32String;mmcbase.dll;13393";
            public const string ToolbarStop = ";StopStop;Win32String;mmcbase.dll;13394";
            public const string ToolbarHome = ";HomeHome;Win32String;mmcbase.dll;13396";
            public const string ToolbarExportList = ";Export ListExport List;Win32String;mmcbase.dll;13398";
        }

        public static Command
            // File menu items
            FileNew = new Command(Strings.FileNew, null, "^N", null),
            FileOpen = new Command(Strings.FileOpen, null, "^O", null),
            FileSave = new Command(Strings.FileSave, null, "^S", null),
            FileSaveAs = new Command(Strings.FileSaveAs, null, null, null),
            FileAddRemoveSnapIn = new Command(Strings.FileAddRemoveSnapin, null, "^M", null),
            FileOptions = new Command(Strings.FileOptions, null, null, null),
            FileExit = new Command(Strings.FileExit, null, null, null),

            // Action menu items
            ActionNewWindowFromHere = new Command(Strings.Action + "|" + Strings.ActionNewWindowFromHere, Strings.ActionNewWindowFromHere),
            ActionNewTaskPadView = new Command(Strings.Action + "|" + Strings.ActionNewTaskpadView, Strings.ActionNewTaskpadView),
            ActionDelete = new Command(Strings.Action + "|" + Strings.ActionDelete, Strings.ActionDelete, "{DELETE}", Strings.ToolbarDelete),
            ActionRename = new Command(Strings.Action + "|" + Strings.ActionRename, Strings.ActionRename, "{F2}", Strings.ToolbarRename),
            ActionRefresh = new Command(Strings.Action + "|" + Strings.ActionRefresh, "{F5}", Strings.ToolbarRefresh),
            ActionExportList = new Command(Strings.Action + "|" + Strings.ActionExportList, Strings.ActionExportList, null, Strings.ToolbarExportList),
            ActionProperties = new Command(Strings.Action + "|" + Strings.ActionProperties, Strings.ActionProperties, "%{ENTER}", Strings.ToolbarProperties),
            ActionHelp = new Command(Strings.Action + "|" + Strings.ActionHelp, Strings.ActionHelp, "{F1}", Strings.ActionHelp),
            ActionOpen = new Command(Strings.Action + "|" + Strings.ActionOpen, Strings.ActionOpen, null, Strings.ToolbarOpen),

            // View menu items
            ViewAddRemoveColumns = new Command(Strings.ViewAddRemoveColumns, null, null, null),
            ViewLargeIcons = new Command(Strings.View + "|" + Strings.ViewLargeIcons, Strings.View + "|" + Strings.ViewLargeIcons, null, null),
            ViewSmallIcons = new Command(Strings.View + "|" + Strings.ViewSmallIcons, Strings.View + "|" + Strings.ViewSmallIcons, null, null),
            ViewList = new Command(Strings.View + "|" + Strings.ViewList, null, null, null),
            ViewDetail = new Command(Strings.View + "|" + Strings.ViewDetail, null, null, null),
            ViewCustomize = new Command(Strings.ViewCustomize, null, null, null),
            ViewShowHideConsoleTree = new Command(null, null, null, Strings.ToolbarShowHideConsoleTree),
            ViewShowHideActionsPane = new Command(null, null, null, Strings.ToolbarShowHideActionsPane),

            // Window menu items
            WindowNewWindow = new Command(Strings.WindowNewWindow, null, "^W", null),
            WindowCascade = new Command(Strings.WindowCascade, null, null, null),
            WindowTileHorizontally = new Command(Strings.WindowTileHorizontally, null, null, null),
            WindowArrangeIcons = new Command(Strings.WindowArrangeIcons, null, null, null),

            // Help menu items
            HelpHelpTopics = new Command(Strings.HelpHelpTopics, null, null, null),
            HelpAboutManagementConsole = new Command(Strings.HelpAboutManagementConsole, null, null, null),

            // Edit commands			
            EditCut = new Command(null, null, "^x", Strings.ToolbarCut),
            EditCopy = new Command(null, null, "^c", Strings.ToolbarCopy),
            EditPaste = new Command(null, null, "^v", Strings.ToolbarPaste),
            EditPrint = new Command(null, null, null, Strings.ToolbarPrint),

            // Browse commands
            BrowseUpOneLevel = new Command(null, null, "{BACKSPACE}", Strings.ToolbarUpOneLevel),
            BrowseBack = new Command(null, null, "%{LEFT}", Strings.ToolbarBack),
            BrowseForward = new Command(null, null, "%{RIGHT}", Strings.ToolbarForward),
            BrowseStop = new Command(null, null, null, Strings.ToolbarStop),
            BrowseHome = new Command(null, null, null, Strings.ToolbarHome);

        // special commands to be used inside this assembly
        internal static Command
            ActionNew = new Command(Strings.Action + "|" + Strings.ActionNew + "|", Strings.ActionNew + "|"),
            ActionAllTasks = new Command(Strings.Action + "|" + Strings.ActionAllTasks + "|", Strings.ActionAllTasks + "|");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\AddRemoveColumnsDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{      
	using Maui.Core;
	using Maui.Core.WinControls;
	using Maui.Core.Utilities;
	using System.ComponentModel;
	
	#region IAddRemoveColumnsDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddRemoveColumnsDialogControls
    {
        ListBox AvailableColumnsListBox  {get;}
        ListBox DisplayedColumnsListBox  {get;}
        Button AddButton  {get;}
        Button RemoveButton  {get;}
        Button MoveUpButton  {get;}
        Button MoveDownButton  {get;}
        Button RestoreDefaultsButton  {get;}
        Button OKButton  {get;}
        Button CancelButton  {get;}
    }
    #endregion
    
    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: AddRemoveColumnsDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Add/Remove Columns Dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 5/10/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddRemoveColumnsDialog : Dialog, IAddRemoveColumnsDialogControls
    {
		#region Constants, member Variables
		private const string DialogTitle = ";Add/Remove Columns;Win32DialogString;mmcndmgr.dll;1070";

		private class ControlIDs
		{
			public const int AvailableColumnsListBox = 4084;
			public const int DisplayedColumnsListBox = 4088;
			public const int AddButton = 4085;
			public const int RemoveButton = 4086;
			public const int MoveUpButton = 4089;
			public const int MoveDownButton = 4090;
			public const int RestoreDefaultsButton = 4087;
			public const int OKButton = 1;
			public const int CancelButton = 2;
		}
		
        private ListBox m_cachedAvailableColumnsListBox;
        private ListBox m_cachedDisplayedColumnsListBox;
        private Button m_cachedAddButton;
        private Button m_cachedRemoveButton;
        private Button m_cachedMoveUpButton;
        private Button m_cachedMoveDownButton;
        private Button m_cachedRestoreDefaultsButton;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        #endregion

        #region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MMC application object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddRemoveColumnsDialog(MmcApp app) :  base(app, Init(app, CommandMethod.Default))
        {
        }

		/// -----------------------------------------------------------------------------
		///  <summary>
		///		Constructor.
		///  </summary>
		///  <param name="app">MMC application object owning the dialog.</param>
		///  <param name="method">How to invoke the command.</param>
		///  <history>
		/// 	[dmitriv] 5/10/2003 Created
		///  </history>
		/// -----------------------------------------------------------------------------
		public AddRemoveColumnsDialog(MmcApp app, CommandMethod method) :  base(app, Init(app, method))
		{
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		This function will attempt to find a showing instance of the dialog.
        ///  </summary>
		///  <param name="app">IDEApp owning the dialog.</param>)
		///  <param name="method">How to invoke the command.</param>
		///  <returns>The dialog's Window</returns>
        ///  <history>
        /// 	[dmitriv]	5/10/2003	Created
        /// 	[dmitriv]	11/6/2003	Fixed sync issue
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            Window tempWindow;
			try
			{
				tempWindow = new Window(
					app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
					WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
					app, 200);
			}
			catch (Window.Exceptions.WindowNotFoundException)
			{
				Commands.ViewAddRemoveColumns.Execute(app, method);
				tempWindow = new Window(
					app.GetIntlStr(DialogTitle), StringMatchSyntax.ExactMatch,
					WindowClassNames.Alert, StringMatchSyntax.ExactMatch,
					app, 3000);           
			}
			return tempWindow;
        }
        #endregion

        #region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddRemoveColumnsDialogControls Controls
        {
            get
            {
                return this;
            }
        }        
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the AvailableColumnsListBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListBox IAddRemoveColumnsDialogControls.AvailableColumnsListBox
        {
            get
            {
                if ((m_cachedAvailableColumnsListBox == null))
                {
                    m_cachedAvailableColumnsListBox = new ListBox(this, ControlIDs.AvailableColumnsListBox);
                }
                return m_cachedAvailableColumnsListBox;
            }
        }        
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the DisplayedColumnsListBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
		ListBox IAddRemoveColumnsDialogControls.DisplayedColumnsListBox
		{
			get
			{
				if ((m_cachedDisplayedColumnsListBox == null))
				{
					m_cachedDisplayedColumnsListBox = new ListBox(this, ControlIDs.DisplayedColumnsListBox);
				}
				return m_cachedDisplayedColumnsListBox;
			}
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.AddButton
        {
            get
            {
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the RemoveButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.RemoveButton
        {
            get
            {
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the MoveUpButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.MoveUpButton
        {
            get
            {
                if ((m_cachedMoveUpButton == null))
                {
                    m_cachedMoveUpButton = new Button(this, ControlIDs.MoveUpButton);
                }
                return m_cachedMoveUpButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the MoveDownButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.MoveDownButton
        {
            get
            {
                if ((m_cachedMoveDownButton == null))
                {
                    m_cachedMoveDownButton = new Button(this, ControlIDs.MoveDownButton);
                }
                return m_cachedMoveDownButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the RestoreDefaultsButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.RestoreDefaultsButton
        {
            get
            {
                if ((m_cachedRestoreDefaultsButton == null))
                {
                    m_cachedRestoreDefaultsButton = new Button(this, ControlIDs.RestoreDefaultsButton);
                }
                return m_cachedRestoreDefaultsButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveColumnsDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

		/// <summary>
		///		Gets or sets visible column list.
		/// </summary>
		public string[] ColumnList
		{
			get
			{
				string[] result = new string[Controls.DisplayedColumnsListBox.Count];
				foreach (ListBoxItem item in Controls.DisplayedColumnsListBox.Items)
					result[item.Index] = item.Text;
				return result;
			}
			set
			{
				// add all items
				repeat1:
					foreach (ListBoxItem item in Controls.AvailableColumnsListBox.Items)
					{
						if (System.Array.IndexOf(value, item.Text) >= 0)
						{
							item.Selected = true;
							ClickAdd();
							goto repeat1;
						}
					}

				// remove items from display list which are not wanted
				repeat2:
					foreach (ListBoxItem item in Controls.DisplayedColumnsListBox.Items)
					{
						if (System.Array.IndexOf(value, item.Text) < 0)
						{
							item.Selected = true;
							if (Controls.RemoveButton.IsEnabled)
							{
								ClickRemove();
								goto repeat2;
							}
							else
							{
								throw new GlobalExceptions.MauiException("It is not possible to remove column " + item.Text + " from displayed columns list! (Remove button is disabled).");
							}
						}
					}

				if (Controls.DisplayedColumnsListBox.Items.Count != value.Length)
					throw new GlobalExceptions.MauiException("Some columns from specified column list were not found!");

				// reorder items
				for (int i = 0; i < value.Length; i++)
				{
					ListBoxItem item = Controls.DisplayedColumnsListBox[value[i]];
					while (item.Index > i)
					{
						item.Selected = true;
						ClickMoveUp();
						item = Controls.DisplayedColumnsListBox[value[i]];
					}
					while (item.Index < i)
					{
						item.Selected = true;
						ClickMoveDown();
						item = Controls.DisplayedColumnsListBox[value[i]];
					}
				}
			}
		}
        #endregion

        #region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Remove
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickRemove()
        {
            Controls.RemoveButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button MoveUp
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveUp()
        {
            Controls.MoveUpButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button MoveDown
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickMoveDown()
        {
            Controls.MoveDownButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button RestoreDefaults
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
		public virtual void ClickRestoreDefaults()
		{
			Controls.RestoreDefaultsButton.Click();
			UISynchronization.WaitForUIObjectReady(this);
		}
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            Controls.OKButton.Click();
			WaitForInvalid();
			UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/10/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
			WaitForInvalid();
			UISynchronization.WaitForUIObjectReady(App.MainWindow);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\SnapIns.cs ===
namespace Maui.ManagementConsole
{
	using System;
	using Maui.Core;
	using Maui.Core.WinControls;

	// TODO: localize strings in SnapinStrings class

	#region SnapinSettings
	/// <summary>
	/// Custom snap-in settings.
	/// </summary>
	/// <history>
	///		[dmitriv]	7/5/2003	Created
	/// </history>
	public class SnapinSettings
	{
		public const string LinkToWebAddressTarget = "Target";
		public const string LinkToWebAddressName = "Name";

		public const string ActiveXControlType = "Type";
		public const string ActiveXControlName = "Name";

		public const string SharedFoldersView = "View";

		public class SharedFoldersViews
		{
			public const string All = "All";
			public const string Shares = "Shares";
			public const string Sessions = "Sessions";
			public const string OpenFiles = "Open Files";
		}
	}
	#endregion

	/// -----------------------------------------------------------------------------
	///  Project	: Maui.ManagementConsole
	///  Class		: MmcApplication.
	///  Copyright (C) 2002, Microsoft Corporation
	/// -----------------------------------------------------------------------------
	/// <summary>
	///		Definitions of standard MMC snap-ins.
	/// </summary>
	///  <history>
	/// 	[dmitriv] 6/15/2003 Created
	///  </history>
	/// -----------------------------------------------------------------------------
	public sealed class Snapins
	{
		#region Private constructor
		private Snapins() {} // this class is pure static
		#endregion

		#region Simple snap-ins
		/// <summary>
		/// Returns parameters for .NET Framework 1.1 Configuration snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin NetFrameworkConfig1_1
		{
			get
			{
				return new Snapin(";.NET Framework 1.1 Configuration;Win32String;mscormmc.dll;30");
			}
		}

		/// <summary>
		/// Returns parameters for Component Services snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin ComponentServices
		{
			get
			{
				return new Snapin(";Component Services;Win32String;comsnap.dll;100");
			}
		}

		/// <summary>
		/// Returns parameters for Computer Management snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin ComputerManagement
		{
			get
			{
				return new Snapin(";Computer Management;Win32String;mycomput.dll;193", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Device Manager snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin DeviceManager
		{
			get
			{
				return new Snapin(";Device Manager;Win32String;devmgr.dll;4", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Disk Management snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin DiskManagement
		{
			get
			{
				return new Snapin(";Disk Management;Win32String;dmdskres.dll;1003", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Event Viewer snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin EventViewer
		{
			get
			{
				return new Snapin(";Event Viewer;Win32String;els.dll;110", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Indexing Service snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin IndexingService
		{
			get
			{
				return new Snapin(";Indexing Service;Win32String;ciadmin.dll;557", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Local Users and Groups snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin LocalUsersAndGroups
		{
			get
			{
				return new Snapin(";Local Users and Groups;Win32String;localsec.dll;5026", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Removable Storage Management snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin RemovableStorageManagement
		{
			get
			{
				return new Snapin(";Removable Storage Management;Win32String;ntmsmgr.dll;3", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Services snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin Services
		{
			get
			{
				return new Snapin(";Services;Win32String;filemgmt.dll;5", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for WMI Control snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin WmiControl
		{
			get
			{
				return new Snapin(";WMI Control;Win32String;msinfo.dll;374", new SnapinWizardHandler(Snapin.DefaultWizardHandler));
			}
		}

		/// <summary>
		/// Returns parameters for Disk Defragmenter snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin DiskDefragmenter
		{
			get
			{
				return new Snapin(";Disk Defragmenter;Win32String;dfrgsnap.dll;100");
			}
		}

		/// <summary>
		/// Returns parameters for Folder snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin Folder
		{
			get
			{
				return new Snapin(";Folder;Win32String;mmcbase.dll;14008");
			}
		}

		/// <summary>
		/// Returns parameters for FrontPage Server Extensions snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin FrontPageServerExtensions
		{
			get
			{
				return new Snapin("FrontPage Server Extensions");
			}
		}

		/// <summary>
		/// Returns parameters for Internet Information Services snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin InternetInformationServices
		{
			get
			{
				return new Snapin(";Internet Information Services;Win32String;inetmgr.dll;104");
			}
		}

		/// <summary>
		/// Returns parameters for IP Security Monitor snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin IPSecurityMonitor
		{
			get
			{
				return new Snapin(";IP Security Monitor;Win32String;ipsmsnap.dll;30");
			}
		}

		/// <summary>
		/// Returns parameters for Performance Logs and Alerts snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin PerfLogsAndAlerts
		{
			get
			{
				return new Snapin(";Performance Logs and Alerts;Win32String;smlogcfg.dll;500");
			}
		}

		/// <summary>
		/// Returns parameters for Security Configuration and Analysis snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin SecurityConfigAndAnalysis
		{
			get
			{
				return new Snapin(";Security Configuration and Analysis;Win32String;wsecedit.dll;372");
			}
		}

		/// <summary>
		/// Returns parameters for Security Templates snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin SecurityTemplates
		{
			get
			{
				return new Snapin(";Security Templates;Win32String;wsecedit.dll;24");
			}
		}
		#endregion

		#region Snap-ins with custom settings
		/// <summary>
		/// Returns parameters for Shared Folders snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin SharedFolders
		{
			get
			{
				return new Snapin(";Shared Folders;Win32String;filemgmt.dll;4", new SnapinWizardHandler(SharedFoldersHandler));
			}
		}

		/// <summary>
		/// Wizard handler for Link to Shared Fodlers snap-in.
		/// </summary>
		/// <param name="app">MMC application.</param>
		/// <param name="snapIn">Snap-in parameters.</param>
		/// <param name="wizard">Wizard to handle.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		private static void SharedFoldersHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
		{
			string value = snapIn.Settings[SnapinSettings.SharedFoldersView];
			if (value != null)
			{
				RadioButton button;
				switch (value)
				{
					case SnapinSettings.SharedFoldersViews.All:
						button = new RadioButton(wizard, 0xFF);
						break;
					case SnapinSettings.SharedFoldersViews.Shares:
						button = new RadioButton(wizard, 0x100);
						break;
					case SnapinSettings.SharedFoldersViews.Sessions:
						button = new RadioButton(wizard, 0x101);
						break;
					case SnapinSettings.SharedFoldersViews.OpenFiles:
						button = new RadioButton(wizard, 0x102);
						break;
					default:
						throw new ArgumentException("Value of SharedFoldersView setting is incorrect.");
				}
				button.Click();
			}
			Snapin.DefaultWizardHandler(app, snapIn, wizard);
		}

		/// <summary>
		/// Returns parameters for Link to Web Address snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin LinkToWebAddress
		{
			get
			{
				return new Snapin(";Link to Web Address;Win32String;mmcbase.dll;14010", new SnapinWizardHandler(LinkToWebAddressHandler));
			}
		}

		/// <summary>
		/// Wizard handler for Link to Web Address snap-in.
		/// </summary>
		/// <param name="app">MMC application.</param>
		/// <param name="snapIn">Snap-in parameters.</param>
		/// <param name="wizard">Wizard to handle.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		private static void LinkToWebAddressHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
		{
			TextBox target = new TextBox(wizard, 0x3FF);
			target.Text = snapIn.Settings[SnapinSettings.LinkToWebAddressTarget];
			wizard.ClickNext();
			TextBox name = new TextBox(wizard, 0x3FE);
			name.Text = snapIn.Settings[SnapinSettings.LinkToWebAddressName];
			wizard.ClickFinish();
		}

		/// <summary>
		/// Returns parameters for Link to Web Address snap-in.
		/// </summary>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		public static Snapin ActiveXControl
		{
			get
			{
				return new Snapin(";ActiveX Control;Win32String;mmcbase.dll;214", new SnapinWizardHandler(ActiveXControlHandler));
			}
		}

		/// <summary>
		/// Wizard handler for ActiveX Control snap-in.
		/// </summary>
		/// <param name="app">MMC application.</param>
		/// <param name="snapIn">Snap-in parameters.</param>
		/// <param name="wizard">Wizard to handle.</param>
		/// <history>
		///		[dmitriv]	7/5/2003	Created
		/// </history>
		private static void ActiveXControlHandler(MmcApp app, Snapin snapIn, Dialogs.SnapinWizard wizard)
		{
			wizard.ClickNext();
			ListView controls = new ListView(wizard, 0x3E8);
			controls.Items[snapIn.Settings[SnapinSettings.ActiveXControlType]].Select();
			wizard.ClickNext();
			TextBox name = new TextBox(wizard, 0x3FE);
			name.Text = snapIn.Settings[SnapinSettings.ActiveXControlName];
			wizard.ClickFinish();
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\Dialogs\AddRemoveSnapInDialog.cs ===
namespace Maui.ManagementConsole.Dialogs
{
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using System.ComponentModel;

    #region IAddRemoveSnapinDialogControls interface definition
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IAddRemoveSnapinDialogControls
    {
        EditComboBox AddToComboBox { get;}
        ListView AddedSnapinsListView { get;}
        TextBox DescriptionTextBox { get;}
        Button AddButton { get;}
        Button RemoveButton { get;}
        Button AboutButton { get;}
        Button OKButton { get;}
        Button CancelButton { get;}
        CheckBox AddAllExtensionsCheckBox { get;}
        EditComboBox SnapinToExtendComboBox { get;}
        ListView AvailableExtensionsListView { get;}
        Button ExtensionAboutButton { get;}
        Button DownloadButton { get;}
        TextBox ExtensionDescriptionTextBox { get;}
        TabControl TabControl { get;}
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: AddRemoveSnapinDialog
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    ///  <summary>
    ///		Main Add/Remove Snap-in Dialog.
    ///  </summary>
    ///  <history>
    /// 	[dmitriv] 5/11/2003 Created
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class AddRemoveSnapinDialog : Dialog, IAddRemoveSnapinDialogControls
    {
        #region Constants
        private class Strings
        {
            public const string DialogTitle = ";Add/Remove Snap-in;Win32String;mmcbase.dll;14029";
        }

        private class ControlIDs
        {
            public const int AddToComboBox = 4018;
            public const int AddedSnapinsListView = 4011;
            public const int DescriptionTextBox = 0xFA7;
            public const int AddButton = 4008;
            public const int RemoveButton = 4009;
            public const int AboutButton = 4014;
            public const int OKButton = 1;
            public const int CancelButton = 2;
            public const int SnapinToExtendComboBox = 4018;
            public const int AddAllExtensionsCheckBox = 4025;
            public const int AvailableExtensionsListView = 4020;
            public const int ExtensionAboutButton = 4014;
            public const int ExtensionDescriptionTextBox = 0xFA7;
            public const int DownloadButton = 4026;
            public const int TabControl = 0x3020;
        }
        #endregion

        #region Member Variables
        private EditComboBox m_cachedAddToComboBox;
        private ListView m_cachedAddedSnapinsListView;
        private TextBox m_cachedDescriptionTextBox;
        private Button m_cachedAddButton;
        private Button m_cachedRemoveButton;
        private Button m_cachedAboutButton;
        private Button m_cachedOKButton;
        private Button m_cachedCancelButton;
        private EditComboBox m_cachedSnapinToExtendComboBox;
        private CheckBox m_cachedAddAllExtensionsCheckBox;
        private ListView m_cachedAvailableExtensionsListView;
        private Button m_cachedExtensionAboutButton;
        private TextBox m_cachedExtensionDescriptionTextBox;
        private Button m_cachedDownloadButton;
        private TabControl m_cachedTabControl;
        #endregion

        #region Constructor and Init function
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddRemoveSnapinDialog(MmcApp app) : base(app, Init(app, CommandMethod.Default))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Constructor.
        ///  </summary>
        ///  <param name="app">MmcApp object owning the dialog.</param>
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public AddRemoveSnapinDialog(MmcApp app, CommandMethod method) : base(app, Init(app, method))
        {
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		This function will attempt to find a showing instance of the dialog.
        ///  </summary>
        ///  <returns>The dialog's Window</returns>
        ///  <param name="app">MmcApp owning the dialog.</param>)
        ///  <param name="method">How to invoke the command.</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        private static Window Init(MmcApp app, CommandMethod method)
        {
            Window tempWindow;
            // First check if the dialog is already up.
            try
            {
                UISynchronization.WaitForUIObjectReady(app.MainWindow);
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 200);
            }
            catch (Window.Exceptions.WindowNotFoundException)
            {
                // The line below is throwing an exception...it is clicking at 0,0 instead of on the menu
                // Dmitry is investigating.
                // Commands.FileAddRemoveSnapIn.Execute(app, method);
                //BUGBUG this is a temporary workaround to the problem above                
                app.SendKeys("^m");
                Maui.TestLog.LogManager.LogHack("Init", "Hardcoded sendkeys method of opening the dialog is not localizable: Fail this after 4/1/05");
                
                tempWindow = new Window(app.GetIntlStr(Strings.DialogTitle), StringMatchSyntax.ExactMatch, WindowClassNames.Alert, StringMatchSyntax.ExactMatch, app, 3000);
            }
            return tempWindow;
        }
        #endregion

        #region Properties
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the raw controls for this dialog
        ///  </summary>
        ///  <value>An interface that groups all of the dialog's control properties together</value>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual IAddRemoveSnapinDialogControls Controls
        {
            get
            {
                return this;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to get the text in control DescriptionTextBox
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string SnapinDescription
        {
            get
            {
                return Controls.DescriptionTextBox.Text;
            }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Returns extension description text-box's text.
        /// </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual string ExtensionDescription
        {
            get
            {
                return Controls.ExtensionDescriptionTextBox.Text;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Gets or sets whether to add all extensions.
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public bool AddAllExtensions
        {
            get
            {
                return Controls.AddAllExtensionsCheckBox.Checked;
            }
            set
            {
                Controls.AddAllExtensionsCheckBox.Checked = value;
            }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Gets or sets snap-in to be extended.
        /// </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string SnapinToExtend
        {
            get
            {
                return Controls.SnapinToExtendComboBox.Text;
            }
            set
            {
                Controls.SnapinToExtendComboBox.SelectByText(value);
            }
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        ///		Gets list of all available extensions for the current snap-in.
        /// </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public string[] Extensions
        {
            get
            {
                return Controls.AvailableExtensionsListView.EnumerateItems(";", 0).Split(';');
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddToComboBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAddRemoveSnapinDialogControls.AddToComboBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAddToComboBox == null))
                {
                    m_cachedAddToComboBox = new EditComboBox(this, ControlIDs.AddToComboBox);
                }
                return m_cachedAddToComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddedSnapinsListView control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddRemoveSnapinDialogControls.AddedSnapinsListView
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAddedSnapinsListView == null))
                {
                    m_cachedAddedSnapinsListView = new ListView(this, ControlIDs.AddedSnapinsListView);
                }
                return m_cachedAddedSnapinsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddRemoveSnapinDialogControls.DescriptionTextBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedDescriptionTextBox == null))
                {
                    m_cachedDescriptionTextBox = new TextBox(this, ControlIDs.DescriptionTextBox);
                }
                return m_cachedDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AddButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.AddButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAddButton == null))
                {
                    m_cachedAddButton = new Button(this, ControlIDs.AddButton);
                }
                return m_cachedAddButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the RemoveButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.RemoveButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedRemoveButton == null))
                {
                    m_cachedRemoveButton = new Button(this, ControlIDs.RemoveButton);
                }
                return m_cachedRemoveButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AboutButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.AboutButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 0)
                    Controls.TabControl.Tabs[0].Select();
                if ((m_cachedAboutButton == null))
                {
                    m_cachedAboutButton = new Button(this, ControlIDs.AboutButton);
                }
                return m_cachedAboutButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the OKButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.OKButton
        {
            get
            {
                if ((m_cachedOKButton == null))
                {
                    m_cachedOKButton = new Button(this, ControlIDs.OKButton);
                }
                return m_cachedOKButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the CancelButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.CancelButton
        {
            get
            {
                if ((m_cachedCancelButton == null))
                {
                    m_cachedCancelButton = new Button(this, ControlIDs.CancelButton);
                }
                return m_cachedCancelButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the SnapinToExtendComboBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        EditComboBox IAddRemoveSnapinDialogControls.SnapinToExtendComboBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedSnapinToExtendComboBox == null))
                {
                    m_cachedSnapinToExtendComboBox = new EditComboBox(this, ControlIDs.SnapinToExtendComboBox);
                }
                return m_cachedSnapinToExtendComboBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Exposes access to the AddAllExtensionsCheckBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        CheckBox IAddRemoveSnapinDialogControls.AddAllExtensionsCheckBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedAddAllExtensionsCheckBox == null))
                {
                    m_cachedAddAllExtensionsCheckBox = new CheckBox(this, ControlIDs.AddAllExtensionsCheckBox);
                }
                return m_cachedAddAllExtensionsCheckBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the AvailableExtensionsListBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        ListView IAddRemoveSnapinDialogControls.AvailableExtensionsListView
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedAvailableExtensionsListView == null))
                {
                    m_cachedAvailableExtensionsListView = new ListView(this, ControlIDs.AvailableExtensionsListView);
                }
                return m_cachedAvailableExtensionsListView;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExtensionAboutButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.ExtensionAboutButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedExtensionAboutButton == null))
                {
                    m_cachedExtensionAboutButton = new Button(this, ControlIDs.ExtensionAboutButton);
                }
                return m_cachedExtensionAboutButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the ExtensionDescriptionTextBox control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TextBox IAddRemoveSnapinDialogControls.ExtensionDescriptionTextBox
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedExtensionDescriptionTextBox == null))
                {
                    m_cachedExtensionDescriptionTextBox = new TextBox(this, ControlIDs.ExtensionDescriptionTextBox);
                }
                return m_cachedExtensionDescriptionTextBox;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the DownloadButton control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        Button IAddRemoveSnapinDialogControls.DownloadButton
        {
            get
            {
                if (Controls.TabControl.SelectedIndex != 1)
                    Controls.TabControl.Tabs[1].Select();
                if ((m_cachedDownloadButton == null))
                {
                    m_cachedDownloadButton = new Button(this, ControlIDs.DownloadButton);
                }
                return m_cachedDownloadButton;
            }
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Exposes access to the TabControl control
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 - Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        TabControl IAddRemoveSnapinDialogControls.TabControl
        {
            get
            {
                if ((m_cachedTabControl == null))
                {
                    m_cachedTabControl = new TabControl(this, ControlIDs.TabControl);
                }
                return m_cachedTabControl;
            }
        }

        #endregion

        #region Methods
        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Add
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAdd()
        {
            Controls.AddButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Remove
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickRemove()
        {
            Controls.RemoveButton.Click();
            UISynchronization.WaitForUIObjectReady(this);
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button About
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickAbout()
        {
            Controls.AboutButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button About
        ///  </summary>
        ///  <remarks></remarks>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickExtensionAbout()
        {
            Controls.ExtensionAboutButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///  Routine to click on button Download
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 6/16/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickDownload()
        {
            Controls.DownloadButton.Click();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv]	5/11/2003	Created
        /// 	[dmitriv]	12/29/2004	Added timeout argument
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK()
        {
            this.ClickOK(3000);
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button OK
        ///  </summary>
        ///  <history>
        /// 	[dmitriv]	5/11/2003	Created
        /// 	[dmitriv]	12/29/2004	Added timeout argument
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickOK(int timeout)
        {
            Controls.OKButton.Click();
            WaitForInvalid(timeout);
            UISynchronization.WaitForUIObjectReady(App.MainWindow);
            App.MainWindow.WaitForResponse();
        }

        /// -----------------------------------------------------------------------------
        ///  <summary>
        ///		Routine to click on button Cancel
        ///  </summary>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public virtual void ClickCancel()
        {
            Controls.CancelButton.Click();
            WaitForInvalid();
        }

        /// -----------------------------------------------------------------------------
        /// <summary>
        /// Sets whether particular extension is enabled or disabled.
        /// </summary>
        /// <param name="extensionName">Extension to enable.</param>
        /// <param name="enabled">Whether extension should be enabled</param>
        ///  <history>
        /// 	[dmitriv] 5/11/2003 Created
        ///  </history>
        /// -----------------------------------------------------------------------------
        public void SetExtensionState(string extensionName, bool enabled)
        {
            Controls.AvailableExtensionsListView[extensionName].Checked = enabled;
        }

        /// <summary>
        /// Set the Parent snap-in path
        /// </summary>
        /// <param name="path">Snap-in to select as parent</param>
        /// <history>
        ///     [michsny] 1/11/2004 Created
        /// </history>
        public void SetPath(string path)
        {
            Controls.AddToComboBox.SelectByText(path);
        }
        
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\xonline-ext\MAUI\Products\ManagementConsole\MmcApp.cs ===
namespace Maui.ManagementConsole
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Threading;
    using System.Globalization;
    using System.ComponentModel;
    using Maui.Core;
    using Maui.Core.WinControls;
    using Maui.Core.Utilities;
    using Maui.ManagementConsole.Dialogs;

    #region IMmcAppControls interface
    [EditorBrowsable(EditorBrowsableState.Never)]
    public interface IMmcAppControls
    {
        Toolbar Toolbar { get; }
        Window MdiContainer { get; }
    }
    #endregion

    /// -----------------------------------------------------------------------------
    ///  Project	: Maui.ManagementConsole
    ///  Class		: MmcApplication.
    ///  Copyright (C) 2002, Microsoft Corporation
    /// -----------------------------------------------------------------------------
    /// <summary>
    ///		Microsoft Management Console application.
    /// </summary>
    ///  <history>
    /// 	[dmitriv] 6/15/2003 Created
    ///		[yiqingdu]	6/17/2004 added QuitTimeout
    ///     [faisalb]   3/22/2005   Added check for Process Idle after adding SnapIn
    ///  </history>
    /// -----------------------------------------------------------------------------
    public class MmcApp : App, IMmcAppControls
    {
        #region Constants

        internal class Strings
        {
            public const string MMCMainFrame = "MMCMainFrame";
            public const string MDIClient = "MDIClient";
            public const string MMCChildFrm = "MMCChildFrm";
            public const string SaveAlertText = ";Save console settings to %1?;Win32String;mmcbase.dll;13357";

            public const int QuitTimeout = 5000;
        }

        private const int DefaultAddSnapinsTimeout = 5000;  // 5 seconds
        private const int ShortTimeout = 500;               // 0.5 seconds
        
        #endregion

        #region Constructors, private variables
        /// <summary>
        /// Constructor to start a new MMC application.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public MmcApp() : base(AdjustParameters(new AppParameters()))
        {
        }

        /// <summary>
        /// Constructor to start a new MMC application with arguments.
        /// </summary>
        /// <param name="arguments">Arguments to pass to MMC executable.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public MmcApp(string arguments) : base(AdjustParameters(new AppParameters(null, arguments)))
        {
        }

        /// <summary>
        /// Constructor.
        /// </summary>
        /// <param name="parameters">Application start parameters.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public MmcApp(AppParameters parameters) : base(AdjustParameters(parameters))
        {
        }

        /// <summary>
        /// Constructor to start a new MMC application with Window.
        /// </summary>
        /// <param name="arguments">Window to pass.</param>
        /// <history>
        ///		[rongcao]	1/28/2004	Created
        /// </history>
        public MmcApp(Window window) : base(window)
        {
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="MmcPath">Path for MMC (requires for MMC 2.1)</param>
        /// <param name="arguments">Application start parameters</param>
        /// <history>
        ///		[FaisalB]	3/16/2003	Created
        /// </history>
        public MmcApp(string MmcPath, string arguments): base(AdjustParameters(new AppParameters(MmcPath, arguments)))
        {
        }

        /// <summary>
        /// Corrects application parameters structure for base App constructor.
        /// </summary>
        /// <param name="parameters"></param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        private static AppParameters AdjustParameters(AppParameters parameters)
        {
            if (parameters.ExePath == null)
                parameters.ExePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System), "mmc.exe");
            parameters.MainWindowClass = Strings.MMCMainFrame;
            // this is needed for MUI resource extraction 
            string lcid = Registry.GetValue(RegistryHive.Win32CurrentUser, @"Control Panel\Desktop", "MultiUILanguageID");
            if (lcid != null)
            {
                Thread.CurrentThread.CurrentCulture = new CultureInfo(Int32.Parse(lcid, NumberStyles.HexNumber));
            }
            return parameters;
        }
        #endregion

        #region Controls interface
        /// <summary>
        ///		Provides access to MMC application window controls.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public IMmcAppControls Controls
        {
            get
            {
                return this;
            }
        }

        /// <summary>
        ///		Returns toolbar control of the application.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        Toolbar IMmcAppControls.Toolbar
        {
            get
            {
                return new Toolbar(MainWindow, "", 1);
            }
        }

        /// <summary>
        ///		Returns MDI client window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        Window IMmcAppControls.MdiContainer
        {
            get
            {
                return new Window(null, StringMatchSyntax.ExactMatch,
                    Strings.MDIClient, StringMatchSyntax.ExactMatch,
                    MainWindow, 200);
            }
        }
        #endregion

        #region Properties
        /// <summary>
        /// Gets collection of all console windows inside the MMC.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public ConsoleCollection Consoles
        {
            get
            {
                return new ConsoleCollection(this);
            }
        }

        /// <summary>
        /// Gets top-most console window.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public Console Console
        {
            get
            {
                return new Console(this);
            }
        }


        /// <summary>
        /// MMC has weird menu behavior on different platforms
        /// </summary>
        /// <history>
        ///		[BrianMcM]	2/4/2005	Created
        /// </history>
        public override Menu Menu
        {
            get
            {
                try
                {
                    return base.Menu;
                }
                catch (Menu.Exceptions.ItemNotFoundException)
                {
                    ActiveAccessibility mainWndAA = new ActiveAccessibility(this.MainWindow.Extended.HWnd, MsaaObjectID.Window);
            
                    // The role of the menu bar on Longhorn is tool bar, not menu bar
                    // Look for a toolbar who's first item is a menu item
                    ActiveAccessibilityCollection foundElements = ActiveAccessibility.FindUIElements(mainWndAA, NavigationFlags.VisibleOnly | NavigationFlags.FindAll, null, null, (int)MsaaRole.ToolBar, -1);
                    
                    if(foundElements == null || foundElements.Count == 0)
                    {
                        throw new Menu.Exceptions.ItemNotFoundException("Could not find AA object for Menu Bar!");
                    }

                    foreach(ActiveAccessibility menuBar in foundElements)
                    {
                        if(menuBar.Visible && menuBar.ChildCount > 0 && menuBar.Children[0].Role == (int)MsaaRole.MenuItem)
                        {
                            // Found it!
                            return new Menu(menuBar);
                        }
                    }

                    throw new Menu.Exceptions.ItemNotFoundException("Could not find AA object for Menu Bar!");
                    
                }
            }
        }

        #endregion

        #region Methods
        /// <summary>
        ///		Sets resource search paths.
        /// </summary>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        protected override void SetResourceSearchPaths()
        {
            ResourceManager.PathCache.DefaultPath =
                Environment.GetFolderPath(Environment.SpecialFolder.System) + ";" +
                Registry.GetValue(RegistryHive.Win32LocalMachine, @"Software\Microsoft\.NETFramework", "InstallRoot");
        }

        /// <summary>
        ///		Extracts string by its resource ID from the product.
        /// </summary>
        /// <param name="resourceId">Resource ID of the string.</param>
        /// <returns>Extracted string.</returns>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public override string GetIntlStr(string resourceId)
        {
            // need to perform this conversion because MMC contains 2 strings in 1
            return base.GetIntlStr(resourceId).Split('\n')[0];
        }

        /// <summary>
        ///		Adds snap-in to the application.
        /// </summary>
        /// <param name="snapIn">Snap-in to be added.  All Extensions will be enabled.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void AddSnapin(Snapin snapIn)
        {
            AddSnapins(new Snapin[] { snapIn }, DefaultAddSnapinsTimeout);
        }

        /// <summary>
        ///		Adds snap-in to the application.
        /// </summary>
        /// <param name="snapIn">Snap-in to be added.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///		[dmitriv]	12/29/2004	Added timeout parameter
        /// </history>
        public void AddSnapin(Snapin snapIn, int timeout)
        {
            AddSnapins(new Snapin[] { snapIn }, timeout);
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        /// </history>
        public void AddSnapins(Snapin[] snapIns)
        {
            this.AddSnapins(snapIns, DefaultAddSnapinsTimeout);
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <param name="timeout">Timeout to wait for snapins to be initialized.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created
        ///		[dmitriv]	12/29/2003	Added timeout parameter
        ///             [michsny]	12/28/2004  Added parameters for extensions, ordering, and nesting
        ///             [michsny]	12/30/2004  Added code to manipulate new Add or Remove dialogs
        ///             [michsny]	12/30/2004  Moved code to NewUI and OldUI methods.
        /// </history>
        public void AddSnapins(Snapin[] snapIns, int timeout)
        {
            Boolean usingNewUI = AddRemoveIsUsingNewUI();

            // Now that we know which UI to use, go ahead and add the SnapIns.
            if (usingNewUI)
            {
                // Use the UI added in MMC 2.1 and enabled by default in Longhorn
                AddSnapinsUsingAddOrRemoveSnapInsDialog(snapIns, timeout);
            }
            else
            {
                // Use the UI for MMC 2.0, default prior to Longhorn
                AddSnapinsUsingAddRemoveSnapInDialog(snapIns, timeout);
            }
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console using the MMC 2.0 UI.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <param name="timeout">Timeout to wait for snapins to be initialized.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created 
        ///		[dmitriv]	12/29/2003	Added timeout parameter
        ///             [michsny]	12/28/2004  Added parameters for extensions, ordering, and nesting
        ///             [michsny]	12/30/2004  Moved code from AddSnapins to AddSnapinsUsingAddRemoveSnapInDialog
        ///             [michsny]	12/31/2004  Added code to handle extensions and nesting in old dialogs
        /// </history>
        private void AddSnapinsUsingAddRemoveSnapInDialog(Snapin[] snapIns, int timeout)
        {
            // launch the add/remove dialog
            AddRemoveSnapinDialog dialog = new AddRemoveSnapinDialog(this);

            // add snap-ins one-by-one
            foreach (Snapin snapIn in snapIns)
            {
                // check if snap-in name is resource ID - then convert it
                if (snapIn.Name.StartsWith(";"))
                    snapIn.Name = GetIntlStr(snapIn.Name);

                // select the path
                if (snapIn.Path != null)
                    dialog.SetPath(snapIn.Path);                

                // add the snap-in now
                dialog.ClickAdd();
                AddStandaloneSnapin(snapIn);

                // if extensions are specified - select them
                if (snapIn.Extensions != null)
                {
                    // check if extensions are resource ID-s and convert them
                    for (int i = 0; i < snapIn.Extensions.Length; i++)
                        if (snapIn.Extensions[i].StartsWith(";"))
                            snapIn.Extensions[i] = GetIntlStr(snapIn.Extensions[i]);

                    // select snap-in to extend
                    dialog.SnapinToExtend = snapIn.Name;

                    // say we don't want all extensions
                    dialog.AddAllExtensions = false;

                    // choose extensions to include
                    foreach (string extension in dialog.Extensions)
                    {
                        dialog.SetExtensionState(extension, Array.IndexOf(snapIn.Extensions, extension) >= 0);
                    }
                }
            }

            // close the dialog and wait for app to load everything
            dialog.ClickOK(timeout);
        }

        /// <summary>
        ///		Adds snap-in(s) to the current console using the MMC 2.1 UI.
        /// </summary>
        /// <param name="snapIns">Snap-In collection to be added.</param>
        /// <param name="timeout">Timeout to wait for snapins to be initialized.</param>
        /// <history>
        ///		[dmitriv]	7/5/2003	Created (as AddSnapinsUI)
        ///		[dmitriv]	12/29/2003	Added timeout parameter
        ///             [michsny]	12/28/2004  Added parameters for extensions, ordering, and nesting
        ///             [michsny]	12/30/2004  Added code to handle the new UI in AddSnapInsNewUI
        ///             [michsny]	12/31/2004  Added code to handle extensions and nesting in old dialogs
        /// </history>
        private void AddSnapinsUsingAddOrRemoveSnapInsDialog(Snapin[] snapIns, int timeout)
        {
            bool selectionOfParentSnapInIsEnabled = false;

            // launch the add/remove dialog
            AddOrRemoveSnapInsDialog dialog = new AddOrRemoveSnapInsDialog(this);

            // add snap-ins one-by-one
            foreach (Snapin snapIn in snapIns)
            {
                // check if snap-in name is resource ID - then convert it
                if (snapIn.Name.StartsWith(";"))
                    snapIn.Name = GetIntlStr(snapIn.Name);

                // Select the snapin to add this snap-in under
                if (snapIn.Path != null)
                {
                    // enable the selection of the snap-in parent if it isn't currently enabled
                    if (selectionOfParentSnapInIsEnabled == false)
                    {
                        // remember if we have enabled this selection
                        selectionOfParentSnapInIsEnabled = true;

                        // open and get the advanced dialog
                        AdvancedDialog advancedDialog = new AdvancedDialog(this, dialog);

                        // check the checkbox to enable the selection of a parent snap-in
                        advancedDialog.EnableAllowChangingTheParentSnapIn();

                        // click ok and close the advanced dialog
                        advancedDialog.ClickOK();

                        // Wait up to 1 second for the snapin to be selected
                        UISynchronization.WaitForUIObjectReady(dialog, timeout);
                    }
                    // select the parent snap-in in the combobox
                    dialog.SetPath(snapIn.Path);
                }
                else
                {
                    // if we previously selected a root, but none is currently provided, reset to the default
                    if (selectionOfParentSnapInIsEnabled