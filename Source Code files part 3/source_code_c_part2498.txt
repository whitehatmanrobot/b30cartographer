ISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoCollection, "_NewEnum", DISPID_NEWENUM, _NewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()


BEGIN_INTERFACE_MAP(CAutoCollection, CAutoObj)
	// UNCOMMENT IF COPYING
	// See note at the top of ide\include\autocol.h for info on how
	//  to use this collection class as an example
	/* INTERFACE_PART(CAutoCollection, IID_IDualObjs, Dispatch)
	INTERFACE_PART(CAutoCollection, IID_IObjs, Dispatch)
    DUAL_ERRORINFO_PART(CAutoCollection) */
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
DS_IMPLEMENT_ENABLE_DUAL(CAutoCollection, DualObjs)
DS_DELEGATE_DUAL_INTERFACE(CAutoCollection, DualObjs)
// UNCOMMENT IF COPYING
// See note at the top of ide\include\autocol.h for info on how
//  to use this collection class as an example
// IMPLEMENT_DUAL_ERRORINFO(CAutoCollection, IID_IObjs)


/////////////////////////////////////////////////////////////////////////////
// CAutoCollection message handlers

long CAutoCollection::GetCount() 
{
	return m_pPtrlData->GetCount();
}

LPUNKNOWN CAutoCollection::_NewEnum() 
{
	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlData);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}

LPDISPATCH CAutoCollection::Item(const VARIANT FAR& index) 
{
    // coerce index to VT_I4
	COleVariant coercedIndex(index);
	coercedIndex.ChangeType(VT_I4);
	//DER 12 Apr 96 - store IDispatch*'s --- CAutoObj* pObj = NULL;
	IDispatch* pObj = NULL ;
    POSITION pos = m_pPtrlData->FindIndex(coercedIndex.lVal);
    if (pos != NULL)
	{
		/* DER 12 Apr 96 - Use IDispatch instead of CAutoObj
        pObj = (CAutoObj*)m_pPtrlData->GetAt(pos);
		ASSERT (pObj != NULL);
		ASSERT_KINDOF(CAutoObj, pObj);
		*/
        pObj = m_pPtrlData->GetAt(pos);
		ASSERT (pObj != NULL);
	}
	else
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}
    
	ASSERT (pObj != NULL);
	/* DER Use IDispatch instead of CAutoObj 
	return pObj->GetIDispatch(TRUE) ;        // AddRef
	*/
	pObj->AddRef();
	return pObj ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autoapp.cpp ===
// autoapp.cpp : implementation file
//

#include "stdafx.h"
#include <srcapi.h>	 // For the output window
#include <srcguid.h> // Don't Initguid this!!

#include <utilauto.h>
#include "autoguid.h"
#include "autodocs.h"
#include "autoprjs.h"
#include <aut1gui_.h>	// For IAddIn
#include <aut1api_.h>	// For IAddIn
#include <bldguid_.h>	// For IAutoBld
#include <bldapi_.h>	// For IAutoBld
#include <dlgbase.h>
#include "cmduiena.h"
#include "tap.h"
#include "toolexpt.h"

#include "resource.h"
#include "autostat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#ifdef _DEBUG
/*
See UTILAUTO.H
*/
#if 0 
	// {9FD2DF21-190D-11CF-8E4D-00AA004254C4}
	static const GUID CLSID_ApplicationDebug =  
	{ 0x9fd2df21, 0x190d, 0x11cf, { 0x8e, 0x4d, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4 }};
#endif

// {E8BEA480-DDE4-11cf-9C4A-00A0C90A632C}
static const GUID CLSID_ApplicationDebug  = 
{ 0xe8bea480, 0xdde4, 0x11cf, { 0x9c, 0x4a, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c } };

#define APP_CLSID CLSID_ApplicationDebug
#else
#define APP_CLSID CLSID_Application
#endif

class CAutoUIDisableRestore {
public:
	CAutoUIDisableRestore(){
		m_bState = g_AutomationState.DisplayUI();
		g_AutomationState.DisableUI();
	}
	~CAutoUIDisableRestore(){
		if(m_bState){
			g_AutomationState.EnableUI();
		}
	}
private:
	BOOL m_bState;
};

/////////////////////////////////////////////////////////////////////////////
// CApplication


IMPLEMENT_DYNCREATE(CApplication, CAutoObj)

CApplication* CApplication::m_pAppObj = NULL;
DWORD CApplication::m_dwCookie = 0xFFFFFFFF;

// Static create member creates at most one instance
CApplication* CApplication::Create()
{
	if (!m_pAppObj)
		return (m_pAppObj = new CApplication());

	m_pAppObj->ExternalAddRef();
	return m_pAppObj;
}

CApplication::CApplication()
{
	// This object should be created using the Create static
	//  member function, not by directly calling new or allocating
	//  one on the stack.
	ASSERT (m_pAppObj == NULL);

	EnableDualAutomation();
	EnableConnections();

	m_pAddIn = NULL;
	m_pBld = NULL;
	m_bZombified = FALSE;
	m_nEnableModelessLevels = 0;
	EventQueueInit();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();

	VERIFY(SUCCEEDED(RegisterActiveObject((IUnknown *) GetIDispatch(FALSE),
			APP_CLSID, 0, &m_dwCookie)));
}


void CApplication::Destroy()
{
	if (m_dwCookie != 0xFFFFFFFF)
		RevokeActiveObject(m_dwCookie, 0);
	ExternalRelease();
}


CApplication::~CApplication()
{
	// If we were already zombified, we've already unlocked the app.
	//  If we weren't zombified, we should unlock it now.  Just
	//  call Zombify and it'll know what to do.
	Zombify();

	theApp.m_pAutoApp = NULL;
	EventQueueDestroy();
	
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	AfxOleUnlockApp();
}

// Provides access to IAddIn (defined in pkgs\include\aut1api.h)
IAddIn* CApplication::GetAddInInterface()
{
	if (m_pAddIn != NULL)
		return m_pAddIn;
	
	if (FAILED(theApp.FindInterface(IID_IAddIn, (LPVOID*) &m_pAddIn))
		|| m_pAddIn == NULL)
	{
		m_pAddIn = NULL;
		return NULL;
	}
	
	return m_pAddIn;
}

// Provides access to IAddIn (defined in pkgs\include\aut1api.h)
IAutoBld* CApplication::GetBldInterface()
{
	if (m_pBld != NULL)
		return m_pBld;
	
	if (FAILED(theApp.FindInterface(IID_IAutoBld, (LPVOID*) &m_pBld))
		|| m_pBld == NULL)
	{
		m_pBld = NULL;
		return NULL;
	}
	
	return m_pBld;
}

void CApplication::Zombify()
{
	// We move the unlock app call here from the destructor, b/c before,
	//  it was never called since the order was:
	// destructor -> unlock -> allows app to exit -> package OnExit -> VbaTerminate
	//  -> destroy app object (last arrow to follow vbapp sample) = destructor.
	if (m_bZombified == TRUE)
		return;
	m_bZombified = TRUE;

	if (m_pAddIn != NULL)
		m_pAddIn->Release();

	if (m_pBld != NULL)
		m_pBld->Release();

	while (m_nEnableModelessLevels != 0)
	{
		// If a naughty macro or add-in doesn't re-enable us enough
		//  times (i.e., not calling EnableModeless(TRUE) for each
		//  EnableModeless(FALSE)), we'll do it ourselves here
		EnableModeless(TRUE);
	}
}


void CApplication::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CApplication, CAutoObj)
	//{{AFX_MSG_MAP(CApplication)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CApplication, CAutoObj)
	//{{AFX_DISPATCH_MAP(CApplication)
	DISP_PROPERTY_EX(CApplication, "Height", GetHeight, SetHeight, VT_I4)
	DISP_PROPERTY_EX(CApplication, "Width", GetWidth, SetWidth, VT_I4)
	DISP_PROPERTY_EX(CApplication, "Top", GetTop, SetTop, VT_I4)
	DISP_PROPERTY_EX(CApplication, "Left", GetLeft, SetLeft, VT_I4)
	DISP_PROPERTY_EX(CApplication, "Name", GetName, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CApplication, "Debugger", GetDebugger, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "Version", GetVersion, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CApplication, "Path", GetPath, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CApplication, "CurrentDirectory", GetCurrentDirectory, SetCurrentDirectory, VT_BSTR)
	DISP_PROPERTY_EX(CApplication, "FullName", GetFullName, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CApplication, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "ActiveDocument", GetActiveDocument, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "Windows", GetWindows, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "Documents", GetDocuments, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "ActiveWindow", GetActiveWindow, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "WindowState", GetWindowState, SetWindowState, VT_I4)
	DISP_PROPERTY_EX(CApplication, "TextEditor", GetTextEditor, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "Projects", GetProjects, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CApplication, "ActiveConfiguration", GetActiveConfiguration, SetActiveConfiguration, VT_DISPATCH)
	DISP_FUNCTION(CApplication, "GetPackageExtension", GetPackageExtension, VT_DISPATCH, VTS_BSTR)
	DISP_FUNCTION(CApplication, "Quit", Quit, VT_EMPTY, VTS_NONE)
	DISP_FUNCTION(CApplication, "PrintToOutputWindow", PrintToOutputWindow, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CApplication, "ExecuteCommand", ExecuteCommand, VT_EMPTY, VTS_BSTR)
	DISP_FUNCTION(CApplication, "AddCommandBarButton", AddCommandBarButton, VT_EMPTY, VTS_I4 VTS_BSTR VTS_I4)
	DISP_FUNCTION(CApplication, "AddKeyBinding", AddKeyBinding, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BSTR)
	DISP_FUNCTION(CApplication, "Build", Build, VT_EMPTY, VTS_VARIANT)
	DISP_FUNCTION(CApplication, "RebuildAll", RebuildAll, VT_EMPTY, VTS_VARIANT)
	DISP_DEFVALUE(CApplication, "Name")
	DISP_PROPERTY_EX(CApplication, "Visible", GetVisible, SetVisible, VT_BOOL)
	DISP_PROPERTY_EX(CApplication, "ActiveProject", GetActiveProject, SetActiveProject, VT_DISPATCH)
	DISP_FUNCTION(CApplication, "ExecuteConfiguration", ExecuteConfiguration, VT_EMPTY, VTS_VARIANT)
	DISP_FUNCTION(CApplication, "Clean", Clean, VT_EMPTY, VTS_VARIANT)
	DISP_PROPERTY_EX(CApplication, "Errors", GetErrors, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CApplication, "Warnings", GetWarnings, SetNotSupported, VT_I4)
	DISP_FUNCTION(CApplication, "AddProject", AddProject, VT_EMPTY, VTS_BSTR VTS_BSTR VTS_BSTR VTS_BOOL )
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CApplication, "SetAddInInfo", 0x00020001, SetAddInInfo, VT_EMPTY, VTS_I4 VTS_DISPATCH VTS_I4 VTS_I4 VTS_I4)
	DISP_FUNCTION_ID(CApplication, "AddCommand", 0x00020002, AddCommand, VT_BOOL, VTS_BSTR VTS_BSTR VTS_I4 VTS_I4)
	DISP_PROPERTY_EX_ID(CApplication, "Active", 0x00020003, GetActive, SetActive, VT_BOOL)
	DISP_FUNCTION_ID(CApplication, "EnableModeless", 0x00020004, EnableModeless, VT_EMPTY, VTS_BOOL)
END_DISPATCH_MAP()


BEGIN_INTERFACE_MAP(CApplication, CAutoObj)
	INTERFACE_PART(CApplication, IID_IDispApplication, Dispatch)
	INTERFACE_PART(CApplication, IID_IApplication, Dispatch)
	INTERFACE_PART(CApplication, IID_IConnectionPointContainer, ConnPtContainer)
    DUAL_ERRORINFO_PART(CApplication)
	INTERFACE_PART(CApplication, IID_IServiceProvider, ServiceProvider)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CApplication, IID_IApplication)
DS_IMPLEMENT_ENABLE_DUAL(CApplication, Application)
DS_DELEGATE_DUAL_INTERFACE(CApplication, Application)

BEGIN_CONNECTION_MAP(CApplication, CAutoObj)
    CONNECTION_PART(CApplication, IID_IApplicationEvents, ApplicationCP)
    CONNECTION_PART(CApplication, IID_IDispApplicationEvents, DispApplicationCP)
END_CONNECTION_MAP()

// Note: we add support for IID_DApplication to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

/* REMOVED see dualimpl.doc

// {9FD2DF20-190D-11CF-8E4D-00AA004254C4}
static const IID IID_DApplication =
{ 0x9fd2df20, 0x190d, 0x11cf, { 0x8e, 0x4d, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4 } };
*/

/* REMOVED see dualimpl.doc                                 
BEGIN_INTERFACE_MAP(CApplication, CAutoObj)
	INTERFACE_PART(CApplication, IID_DApplication, Dispatch)
	INTERFACE_PART(CApplication, IID_IApplication, Application)
END_INTERFACE_MAP()*/

#ifdef _DEBUG

#if 0 
// {9FD2DF21-190D-11CF-8E4D-00AA004254C4}
IMPLEMENT_OLECREATE(CApplication, "MSDEVD.APPLICATION", 
					0x9fd2df21, 0x190d, 0x11cf, 0x8e, 0x4d, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4)
#endif

// {E8BEA480-DDE4-11cf-9C4A-00A0C90A632C}
DS_IMPLEMENT_OLECREATE(CApplicationFactory, CApplication, "MSDEVD.APPLICATION", 
					0xe8bea480, 0xdde4, 0x11cf, 0x9c, 0x4a, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c)

#else
// {FB7FDAE2-89B8-11cf-9BE8-00A0C90A632C}
DS_IMPLEMENT_OLECREATE(CApplicationFactory, CApplication, "MSDEV.APPLICATION", 
	0xfb7fdae2, 0x89b8, 0x11cf, 0x9b, 0xe8, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c);
#endif

BOOL CApplicationFactory::Register()
{
	if (theApp.m_bRunInvisibly)
		return COleObjectFactory::Register();

	// Deliberately don't register class object with active running
	//  class object table, since we always want CoGetClassObject
	//  (& thus CoCreateInstance) to launch new instance of the server each time.
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation of IApplication interface

DELEGATE_GET(CApplication, Application, Left,long)
DELEGATE_GET(CApplication, Application, Top,long)
DELEGATE_GET(CApplication, Application, Height,long)
DELEGATE_GET(CApplication, Application, Width,long)
DELEGATE_GET(CApplication, Application, Errors,long)
DELEGATE_GET(CApplication, Application, Warnings,long)

DELEGATE_PUT(CApplication, Application,Left,long)
DELEGATE_PUT(CApplication, Application,Top,long)
DELEGATE_PUT(CApplication, Application,Height,long)
DELEGATE_PUT(CApplication, Application,Width,long)

DELEGATE_BSTR_GET(CApplication, Application, Name, Name) 
DELEGATE_BSTR_GET(CApplication, Application, Version, Version) 
DELEGATE_BSTR_GET(CApplication, Application, Path, Path) 
DELEGATE_BSTR_GET(CApplication, Application, CurrentDirectory, CurrentDirectory) 
DELEGATE_BSTR_PUT(CApplication, Application, CurrentDirectory, CurrentDirectory) 

DELEGATE_BSTR_GET(CApplication, Application, FullName, FullName) 

DELEGATE_GET(CApplication,Application,Application,LPDISPATCH)
DELEGATE_GET(CApplication,Application,Parent,LPDISPATCH)

DELEGATE_GET(CApplication,Application,ActiveDocument,LPDISPATCH)
DELEGATE_GET(CApplication,Application,ActiveWindow,LPDISPATCH)

DELEGATE_GET(CApplication,Application,Windows,LPDISPATCH)
DELEGATE_GET(CApplication,Application,Documents,LPDISPATCH)
DELEGATE_GET(CApplication,Application,Projects,LPDISPATCH)

DELEGATE_PUT(CApplication, Application, WindowState, DsWindowState)
DELEGATE_GET(CApplication, Application, WindowState, DsWindowState)

DELEGATE_GET(CApplication,Application,Debugger,LPDISPATCH)
DELEGATE_GET(CApplication,Application,TextEditor,LPDISPATCH)

DELEGATE_GET(CApplication,Application,ActiveConfiguration,LPDISPATCH)
DELEGATE_PUT(CApplication,Application,ActiveConfiguration,LPDISPATCH)

DELEGATE_BOOL_GET(CApplication,Application,Visible)
DELEGATE_BOOL_PUT(CApplication,Application,Visible)

DELEGATE_NO_PARAMS(CApplication, Application, Quit)

DELEGATE_GET(CApplication,Application,ActiveProject,LPDISPATCH)
DELEGATE_PUT(CApplication,Application,ActiveProject,LPDISPATCH)

DELEGATE_BOOL_PUT(CApplication,Application,Active)
DELEGATE_BOOL_GET(CApplication,Application,Active)

STDMETHODIMP CApplication::XApplication::GetPackageExtension(THIS_ BSTR szExtensionName, IDispatch * FAR* pExt)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		CString strName = szExtensionName ;
		*pExt = pThis->GetPackageExtension(strName) ;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CApplication::XApplication::PrintToOutputWindow(THIS_ BSTR Message)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		CString strMessage = Message ;
		pThis->PrintToOutputWindow(strMessage) ;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::ExecuteCommand(THIS_ BSTR szCommandName)
{
	METHOD_PROLOGUE(CApplication, Dispatch)

	CAutoUIDisableRestore disable;
	TRY_DUAL(IID_IApplication)
	{
		CString strCommandName = szCommandName ;
		pThis->ExecuteCommand(strCommandName) ;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::AddCommandBarButton(THIS_ long nButtonType, BSTR szCmdName, long dwCookie)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		CString strCmdName = szCmdName ;
		pThis->AddCommandBarButton(nButtonType, strCmdName, dwCookie);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::AddKeyBinding(THIS_ BSTR szKey, BSTR szCommandName, BSTR szEditor)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		CString strKey = szKey;
		CString strCommandName = szCommandName;
		CString strEditor = szEditor;
		pThis->AddKeyBinding(strKey, strCommandName, strEditor);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::Build(THIS_ VARIANT configuration)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		pThis->Build(configuration) ;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::RebuildAll(THIS_ VARIANT configuration)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		pThis->RebuildAll(configuration) ;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::Clean(THIS_ VARIANT configuration)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		pThis->Clean(configuration);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::AddProject(THIS_ BSTR szName, BSTR szPath, BSTR szType, VARIANT_BOOL bAddDefaultFolders)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		CString strProjName(szName);
		CString strProjPath(szPath);
		CString strProjType(szType);
		pThis->AddProject(strProjName, strProjPath, strProjType, bAddDefaultFolders);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::ExecuteConfiguration(THIS_ VARIANT Reserved)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		pThis->ExecuteConfiguration(Reserved) ;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::SetAddInInfo(THIS_ long nInstanceHandle, IDispatch * pCmdDispatch, long nIDBitmapResourceMedium, long nIDBitmapResourceLarge, long dwCookie)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		pThis->SetAddInInfo(nInstanceHandle, pCmdDispatch, 
			nIDBitmapResourceMedium, nIDBitmapResourceLarge, dwCookie);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::AddCommand(THIS_ BSTR szCmdName, BSTR szMethodName, long nBitmapOffset, long dwCookie, VARIANT_BOOL FAR* pbResult)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		CString strCmdName = szCmdName;
		CString strMethodName = szMethodName;
		*pbResult = (pThis->AddCommand(strCmdName, strMethodName, nBitmapOffset, dwCookie)) ? -1 : 0;
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CApplication::XApplication::EnableModeless(THIS_ VARIANT_BOOL bEnable)
{
	METHOD_PROLOGUE(CApplication, Dispatch)
	
	TRY_DUAL(IID_IApplication)
	{
		BOOL bEnable2 = (bEnable == VARIANT_TRUE);
		pThis->EnableModeless(bEnable2);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of CApplication dispatch handlers



LPDISPATCH CApplication::GetPackageExtension(LPCTSTR szExtensionName) 
{
	return theApp.GetPackageExtension(szExtensionName);
}

LPDISPATCH CApplication::GetTextEditor() 
{
	return GetPackageExtension("TextEditor") ;
}

LPDISPATCH CApplication::GetDebugger() 
{
	return GetPackageExtension("debugger") ;
}

long CApplication::GetHeight() 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if (pWnd != NULL) 
	{
		pWnd->AssertValid();
		CRect rect;
		pWnd->GetWindowRect(&rect);
		return rect.Height();
	}
	return 0 ;
}

void CApplication::SetHeight(long nNewValue) 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if ((pWnd != NULL) &&
		(nNewValue > 0)  && 
		(nNewValue < GetSystemMetrics(SM_CYSCREEN)))
	{
		pWnd->AssertValid();
		CRect rect ;
		pWnd->GetWindowRect(&rect) ;
		pWnd->MoveWindow(rect.left, rect.top, 
					rect.Width(), nNewValue, TRUE);
	}
}

long CApplication::GetWidth() 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if (pWnd != NULL)
	{
		pWnd->AssertValid();
		CRect rect;
		pWnd->GetWindowRect(&rect);
		return rect.Width();
	}
	return 0;
}

void CApplication::SetWidth(long nNewValue) 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if ((pWnd != NULL) &&
		(nNewValue > 0)  && 
		(nNewValue < GetSystemMetrics(SM_CXSCREEN)))
	{
		pWnd->AssertValid();
		CRect rect ;
		pWnd->GetWindowRect(&rect) ;
		pWnd->MoveWindow(rect.left, rect.top, 
					nNewValue, rect.Height(), TRUE);
	}
}

long CApplication::GetTop() 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if (pWnd != NULL) 
	{
		pWnd->AssertValid();
		CRect rect;
		pWnd->GetWindowRect(&rect);
		return rect.top;
	}
	return 0 ;
}

void CApplication::SetTop(long nNewValue) 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if ((pWnd != NULL) &&
		(nNewValue > 0)  && 
		(nNewValue < GetSystemMetrics(SM_CYSCREEN)))
	{
		pWnd->AssertValid();
		CRect rect ;
		pWnd->GetWindowRect(&rect) ;
		pWnd->MoveWindow(rect.left, nNewValue, 
					rect.Width(), rect.Height(), TRUE);
	}
}

long CApplication::GetLeft() 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if (pWnd != NULL) 
	{
		pWnd->AssertValid();
		CRect rect;
		pWnd->GetWindowRect(&rect);
		return rect.left;
	}
	return 0 ;
}

void CApplication::SetLeft(long nNewValue) 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	if ((pWnd != NULL) &&
		(nNewValue > 0)  && 
		(nNewValue < GetSystemMetrics(SM_CXSCREEN)))
	{
		pWnd->AssertValid();
		CRect rect ;
		pWnd->GetWindowRect(&rect) ;
		pWnd->MoveWindow(nNewValue, rect.top, 
					rect.Width(), rect.Height(), TRUE) ;
	}
}

BSTR CApplication::GetName() 
{
	CString strResult;
	//strResult = "Microsoft Developer Studio" ;
	if(strResult.LoadString(IDS_AUTOAPP_NAME))
	{
		return strResult.AllocSysString();
	}
	return NULL ;
}



BSTR CApplication::GetVersion() 
{
	CString strResult;

	//5.0
	if(strResult.LoadString(IDS_AUTOAPP_VERSION))
	{
		return strResult.AllocSysString();
	}
	return NULL ;
}


BSTR CApplication::GetPath() 
{
	const int MAX_LENGTH = 512 ;

	CString strResult;
	LPTSTR str = strResult.GetBufferSetLength(MAX_LENGTH) ;

	DWORD dwNum = ::GetModuleFileName(AfxGetApp()->m_hInstance,
									str, MAX_LENGTH);
	strResult.ReleaseBuffer() ;

	if (dwNum == 0)
	{
		TRACE0("CApplication: GetFullName failed.\r\n") ;
		return NULL ;
	}
	else
	{
		// Find ending "\" ;
		int index = strResult.ReverseFind('\\');
		if (index != -1)
		{
			// ReverseFind returns the zero based index,
			// which happens to be the count of items we want.
			strResult = strResult.Left(index) ;
		}
		return strResult.AllocSysString();
	}

}


BSTR CApplication::GetCurrentDirectory() 
{
	const int MAX_LENGTH = 512 ;
	CString strResult;

	LPTSTR str = strResult.GetBufferSetLength(MAX_LENGTH) ;

	DWORD dwNum = ::GetCurrentDirectory(MAX_LENGTH, str);
	strResult.ReleaseBuffer() ;

	if (dwNum == 0)
		TRACE0("CApplication: GetFullName failed.\r\n") ;

	return strResult.AllocSysString();
}

void CApplication::SetCurrentDirectory(LPCTSTR lpszNewValue) 
{
	if (lpszNewValue != NULL)
	{
		::SetCurrentDirectory(lpszNewValue);
	}
}

BSTR CApplication::GetFullName() 
{
	const int MAX_LENGTH = 512 ;

	CString strResult;
	LPTSTR str = strResult.GetBufferSetLength(MAX_LENGTH) ;

	DWORD dwNum = ::GetModuleFileName(AfxGetApp()->m_hInstance,
									str, MAX_LENGTH);
	strResult.ReleaseBuffer() ;

	if (dwNum == 0)
	{
		TRACE0("CApplication: GetFullName failed.\r\n") ;
		return NULL ;
	}
	
	return strResult.AllocSysString();
}


LPDISPATCH CApplication::GetApplication() 
{
	ASSERT(m_pAppObj != NULL) ;
    return m_pAppObj->GetIDispatch(TRUE);
}


LPDISPATCH CApplication::GetParent() 
{
	ASSERT(m_pAppObj != NULL) ;
    return m_pAppObj->GetIDispatch(TRUE);
}


LPDISPATCH CApplication::GetActiveDocument() 
{
	// See - PSS ID Number: Q108587

	CMDIFrameWnd* pMainFrame = (CMDIFrameWnd*)(AfxGetApp()->m_pMainWnd);
	if (pMainFrame != NULL)
	{
		ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd))) ;

		CMDIChildWnd* pDocFrame = pMainFrame->MDIGetActive() ;
		if (pDocFrame != NULL)
		{
			CPartDoc* pDoc = (CPartDoc*)pDocFrame->GetActiveDocument() ;
			if (pDoc != NULL)
			{
				ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc))) ;
				pDoc->AssertValid() ;
				return pDoc->GetAutomationObject(TRUE) ;
			}
		}
	}
	return NULL;

}


LPDISPATCH CApplication::GetWindows() 
{
	// Create the Windows automation object.
	CAutoWindows* pAutoWins = new CAutoWindows(NULL);

	// Get and return the IDispatch pointer for CAutoDocuments, but don't addref.
	return pAutoWins->GetIDispatch(FALSE);
}

LPDISPATCH CApplication::GetDocuments() 
{
	// Create the Documents automation object.
	CAutoDocuments* pAutoDocs = new CAutoDocuments();

	// Get and return the IDispatch pointer for CAutoDocuments, but don't addref.
	return pAutoDocs->GetIDispatch(FALSE);
}


LPDISPATCH CApplication::GetActiveWindow() 
{
	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	CPartFrame* pChildWnd = (CPartFrame*)pMainFrame->MDIGetActive() ;
	if (pChildWnd != NULL)
	{
		ASSERT(pChildWnd->IsKindOf(RUNTIME_CLASS(CPartFrame))) ;
		pChildWnd->AssertValid() ;
		return pChildWnd->GetAutomationObject(TRUE) ;
	}

	return NULL;
}

void CApplication::Quit() 
{
	// See filecmds.cpp | CVshellPackage::OnFileSaveAllExit

	// Save all files and then quit.
	theApp.SaveAll(FALSE, FILTER_DEBUG);

	// Quit
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_APP_EXIT, 0L);
}

DsWindowState CApplication::GetWindowState() 
{
	// Main window can't docking or float.
	DsWindowState state = dsWindowStateNormal ;

	CWnd* pMainWnd = AfxGetMainWnd();
	if (pMainWnd->IsIconic())
	{
		state = dsWindowStateMinimized ;
	}
	else if (pMainWnd->IsZoomed())
	{
		state = dsWindowStateMaximized ;
	}

	return state;
}


void CApplication::SetWindowState(DsWindowState nNewValue) 
{
	int nCmdShow ;

	switch(nNewValue)
	{
	case dsWindowStateMaximized :
	    nCmdShow = SW_SHOWMAXIMIZED ;
		break;
	case dsWindowStateMinimized :
		nCmdShow = SW_MINIMIZE ;
		break;
	case dsWindowStateNormal:
		nCmdShow = SW_SHOWNORMAL;
		break;
	default:
		// Main window cannot be docked or floated.
		// TODO: ERROR
		return ;
	}
	AfxGetMainWnd()->ShowWindow(nCmdShow) ;
}

UINT CApplication::s_idOutputWindow = 0;
BOOL CApplication::s_bOutputWindow = FALSE;

void CApplication::PrintToOutputWindow(LPCTSTR strMessage) 
{
	LPOUTPUTWINDOW pI;
	HRESULT hr = theApp.FindInterface(IID_IOutputWindow, (void**)&pI);
	if (SUCCEEDED(hr))
	{
		if (!s_bOutputWindow)
		{
			// Create the output window tab.
			pI->OutputWindowAddVwin("Macro", FALSE, &s_idOutputWindow);
			s_bOutputWindow = TRUE ;
		}
		
		// Output the string.
		pI->OutputWindowQueueHit(s_idOutputWindow, strMessage, TRUE, TRUE, FALSE);
		pI->Release() ;
	}
}

// Execute any arbitrary command, by name
void CApplication::ExecuteCommand(LPCTSTR szCommandName) 
{
	ASSERT_VALID(this);

	UINT nCmdID=0;
	CAutoUIDisableRestore disable;

	// search the command well (inefficient, but essential)
	if(theCmdCache.GetCommandID(szCommandName, &nCmdID))
	{
		// Special case: For DevStudio 96 bug 21643, we're rerouting 
		//  ExecuteCommand("ApplicationExit") to Application::Quit.  Otherwise
		//  we crash thrice.
		if (nCmdID == ID_APP_EXIT)
		{
			Quit();
			return;
		}

		// Check to see if the command has been disabled before calling its update handler
		CTE* pCTE = theCmdCache.GetCommandEntry(nCmdID);
		BOOL bEnabled = (pCTE == NULL || (pCTE->flags & (CT_NOUI | CT_NOKEY)) == 0);
		
		if (bEnabled)
		{
			CCmdUIEnable state;
			state.m_nID = nCmdID;
			state.DoUpdate(AfxGetApp()->m_pMainWnd, TRUE);
			bEnabled = state.m_bEnabled;
		}

		if (bEnabled)
		{
			// Shouldn't be able to ExecuteCommand while we're in the
			//  middle of an existing asynchronous command
			ASSERT (theApp.GetCurrentAsyncCmdLevel() == 0);

			// Fire off command
			theApp.m_pMainWnd->SendMessage(WM_COMMAND, MAKEWPARAM((WORD)nCmdID, 1));

			// If this is an asynchronous command, we need to push our
			//  own message pump until the command is really finished.
			//  For example, ToolsCustomize displays a modeless window, disables
			//  the IDE, and then returns.  We want ExecuteCommand to wait until
			//  the window is dismissed before it returns, though.  So we must
			//  push our own message pump onto the stack here, and when we
			//  receive word that the dialog was dismissed, only then can we
			//  return to the caller.

			// Pump until command is finished (for synchronous commands, this
			//  won't even loop)
			while (theApp.GetCurrentAsyncCmdLevel() != 0)
				theApp.IdleAndPump();
		}
	}
	else
	{
		DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_INVALIDCOMMAND);
	}

	// FUTURE: We should consider a FindCommandId/ExecuteCommandId pair. FindCommand could find the
	// command id that goes with the string, and then ExecuteCommandId could execute it. 
}

void CApplication::AddKeyBinding(LPCTSTR szKey, LPCTSTR szCommandName, LPCTSTR szEditor) 
{
	ASSERT_VALID(this);

	UINT nCmdID=0;

	// search the command well 
	if(theCmdCache.GetCommandID(szCommandName, &nCmdID))
	{
		// work out which keymap is being modified
		POSITION pos = CKeymap::c_keymaps.GetHeadPosition();
		BOOL bFound=FALSE;
		CKeymap* pKeymap=NULL;
		while (pos != NULL)
		{
			pKeymap = (CKeymap*)(void*)CKeymap::c_keymaps.GetNext(pos);
			if (pKeymap->m_strName==szEditor)
			{
				bFound=TRUE;
				break;
			}
		}
		
		if(!bFound)
		{
			DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_INVALIDEDITOR);
		}

		//translate the key binding into a key code 
		WORD kcPrime=0;
		WORD kcChord=0;
		BOOL bChord=FALSE;
		int iOffset=0;

		kcPrime=::GetKeyCodeFromName(szKey,&iOffset);

		if(kcPrime==0)
		{
			DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_BADFIRSTKEY);
		}
		
		if(szKey[iOffset]!=(TCHAR)0) {
			bChord=TRUE;
			
			kcChord=GetKeyCodeFromName(szKey,&iOffset);

			if(kcChord==0)
			{
				DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_BADSECONDKEY);
			}
		
			if(szKey[iOffset]!=(TCHAR)0)
			{
				DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_TOOMANYKEYS);
				// error
			}
		}

		// bind the command to the code
		if (bChord)
		{
			pKeymap->SetKey(kcPrime, kcChord, nCmdID);
		}
		else
		{
			pKeymap->SetKey(kcPrime, nCmdID);
		}
		
		pKeymap->m_bDirty = TRUE;
	}
	else
	{
		DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_INVALIDCOMMAND);
	}
}


//
//
//

BOOL CApplication::GetActive() 
{
	CWnd* pWnd = AfxGetMainWnd(); 
	HWND hWndFore = ::GetForegroundWindow() ;
	return (hWndFore == pWnd->m_hWnd) ;
}

void CApplication::SetActive(BOOL bNewValue) 
{
	BOOL bActive = GetActive() ;
	if (bActive == bNewValue)
	{
		// Already in the correct state.
		return ;
	}

	// Change state.
	CWnd* pWnd = AfxGetMainWnd(); 
	if (bNewValue)
	{
		// Activate the window.
		VERIFY(pWnd->SetForegroundWindow()) ;
	}
	else
	{
		// Deactivate the window by activating the next window in the Z-order
		CWnd* pNextWnd = pWnd->GetWindow(GW_HWNDNEXT);
		if(pNextWnd == NULL) // we got to the end of the list
		{
			// Get the first window.
			pNextWnd  = pWnd->GetWindow(GW_HWNDFIRST);
		}

		// Only activate if it is different than the current window.
		if (pNextWnd != pWnd)
		{
			VERIFY(pNextWnd->SetForegroundWindow()) ;
		}
	}
}
/////////////////////////////////////////////////////////////////////////////
// Add-In methods delegate to devaut1 via IAddIn...

void CApplication::SetAddInInfo(long nInstanceHandle, LPDISPATCH pCmdDispatch, long nIDBitmapResourceMedium, long nIDBitmapResourceLarge, long dwCookie) 
{
	// Get access to devaut1 package
	IAddIn* pAddIn = GetAddInInterface();
	if (pAddIn == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NODEVAUT1);
	}

	// If this fails, it will call DsThrowOleDispatchException for us
	pAddIn->SetAddInInfo(nInstanceHandle, pCmdDispatch,
		nIDBitmapResourceMedium, nIDBitmapResourceLarge, dwCookie);
}

BOOL CApplication::AddCommand(LPCTSTR szCmdName, LPCTSTR szMethodName, long nBitmapOffset, long dwCookie) 
{
	// Get access to devaut1 package
	IAddIn* pAddIn = GetAddInInterface();
	if (pAddIn == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NODEVAUT1);
	}

	// If this fails, it will call DsThrowOleDispatchException for us
	return (pAddIn->AddCommand(szCmdName, szMethodName, nBitmapOffset, dwCookie) == S_OK);
}

void CApplication::EnableModeless(BOOL bEnable)
{
	// Orion Bug 8416 - CMainFrame::OnActivateApp is asserting when we should down
	// with an BeforeDocumentClose macro which contains a MsgBox. This is because
	// this message attempts to activate an app which is hidden and which we want
	// to stay hidden.
	if (theApp.m_pMainWnd->IsWindowVisible())
	{
		if (bEnable)
		{
			if (m_nEnableModelessLevels == 0)
				// An Enable w/out a Disable?  I don't THINK so.s
				return;

			AfxGetApp()->EnableModeless(TRUE);
			// Reset the dockmgr state
			PostModalWindow();

			m_nEnableModelessLevels--;

			// If we're down to zero, make sure any queued events are
			//  thrown now.
			if (m_nEnableModelessLevels == 0)
				EventQueueRemoveAll();
		}
		else
		{
			PreModalWindow();
			// allow OLE servers to disable themselves
			AfxGetApp()->EnableModeless(FALSE);

			// Remember we're being disabled so if a naughty macro or
			//  add-in doesn't re-enable us enough times, we can do that
			//  on zombification.
			m_nEnableModelessLevels++;
		}
	}
}

void CApplication::AddCommandBarButton(long nButtonType, LPCTSTR szCmdName, long dwCookie) 
{
	// Get access to devaut1 package
	IAddIn* pAddIn = GetAddInInterface();
	if (pAddIn == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NODEVAUT1);
	}

	// If this fails, it will call DsThrowOleDispatchException for us
	pAddIn->AddCommandBarButton(nButtonType, szCmdName, dwCookie);
}


IMPLEMENT_ADDREF		(CApplication, ServiceProvider)
IMPLEMENT_RELEASE		(CApplication, ServiceProvider)
IMPLEMENT_QUERYINTERFACE(CApplication, ServiceProvider)

HRESULT CApplication::XServiceProvider::QueryService(
	REFGUID guidService, REFIID iid, void ** ppvObj)
{
	ASSERT(NULL != ppvObj);
	METHOD_PROLOGUE(CApplication, ServiceProvider)
	return theApp.GetService(guidService, iid, ppvObj);
}

// BUILD SYSTEM members defer to build package via IAutoBld

long CApplication::GetErrors()
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}

	long nErrs;
	pBld->Errors(nErrs);
	return nErrs;
}

long CApplication::GetWarnings()
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}

	long nWarns;
	pBld->Warnings(nWarns);
	return nWarns;
}

LPDISPATCH CApplication::GetProjects() 
{
	LPDISPATCH pRet;
	CAutoProjects *pProjects = CAutoProjects::Create();
	pRet = pProjects->GetIDispatch(FALSE);
	return pRet;
}

void CApplication::Build(const VARIANT FAR& configuration) 
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}
	
	HRESULT hr = pBld->Build(configuration, FALSE);
	if (FAILED(hr))
		DsThrowOleDispatchException(hr, IDS_AUTOAPP_NOBLDNOW);
}

void CApplication::RebuildAll(const VARIANT FAR& configuration) 
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}
	
	HRESULT hr = pBld->Build(configuration, TRUE);
	if (FAILED(hr))
		DsThrowOleDispatchException(hr, IDS_AUTOAPP_NOBLDNOW);
}

void CApplication::Clean(const VARIANT FAR& configuration)
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}
	
	HRESULT hr = pBld->Clean(configuration);
	if (FAILED(hr))
		DsThrowOleDispatchException(hr, IDS_AUTOAPP_NOBLDNOW);
}

void CApplication::AddProject(LPCTSTR strName, LPCTSTR strPath, LPCTSTR strType, VARIANT_BOOL bAddDefaultFolders)
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}
	
	HRESULT hr = pBld->AddProject(strName, strPath, strType, bAddDefaultFolders);
	if (FAILED(hr))
		DsThrowOleDispatchException(hr, IDS_AUTOAPP_CANTADDPROJECT);

}

LPDISPATCH CApplication::GetActiveConfiguration() 
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}
	
	LPDISPATCH pRet;
	pBld->GetDefaultConfiguration(&pRet);
	return pRet;
}

void CApplication::SetActiveConfiguration(LPDISPATCH newValue) 
{
	IAutoBld* pBld = GetBldInterface();
	if (pBld == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOBLD);
	}
	
	pBld->SetDefaultConfiguration(newValue);
}


LPDISPATCH CApplication::GetActiveProject() 
{
	IProjectWorkspace *pProjWks = g_IdeInterface.GetProjectWorkspace();
	IPkgProject *pPP;
	VERIFY(SUCCEEDED(pProjWks->GetActiveProject(&pPP)));
	if (pPP == NULL)
	{
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_NOPROJECT);
	}
	LPDISPATCH pDisp = NULL;
	pPP->GetAutomationObject(&pDisp);
	pPP->Release();
	return pDisp;
}

void CApplication::SetActiveProject(LPDISPATCH newValue) 
{
	if(newValue==NULL)
		DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_INVALID_PROJ);

	// Let's make sure that we have a project automation object
	COleRef<IGenericProject> pProject;
	if(FAILED(newValue->QueryInterface(IID_IGenericProject, (void **)&pProject)))
		DsThrowOleDispatchException(E_INVALIDARG, IDS_AUTOAPP_INVALID_PROJ);

	// We are going to compare the names of the internal projects and find
	// the one that we should make active. This is OK because the names of the
	// projects in a workspace are unique.
	BSTR bstrNewProjName;
	VERIFY(SUCCEEDED(pProject->get_Name(&bstrNewProjName)));
	IProjectWorkspace *pPW = g_IdeInterface.GetProjectWorkspace();
	ASSERT(pPW != NULL);
	CADWORD PkgProjects;
	IPkgProject *pProjMatch = NULL;
	VERIFY(SUCCEEDED(pPW->GetLoadedProjects(&PkgProjects)));
	for(int i=0; i<PkgProjects.cElems; i++)
	{
		LPCOLESTR wstrName, wstrPath;
		DWORD dwFlags, dwPackID;
		((IPkgProject *)PkgProjects.pElems[i])->GetProjectInfo(&wstrName, 
							&wstrPath, &dwPackID, &dwFlags);
		if(wcscmp(bstrNewProjName, wstrName) == 0)
		{
			pProjMatch = (IPkgProject *)PkgProjects.pElems[i];
			pProjMatch->AddRef();
		}

		((IPkgProject *)PkgProjects.pElems[i])->Release();
		::CoTaskMemFree((void *)wstrName);
		::CoTaskMemFree((void *)wstrPath);
		if(pProjMatch != NULL)
			break;
	}
	CoTaskMemFree((void *)PkgProjects.pElems);
	::SysFreeString(bstrNewProjName);
	
	if(pProjMatch == NULL)
		DsThrowOleDispatchException(E_UNEXPECTED, IDS_AUTOAPP_INVALID_PROJ);

	pPW->SetActiveProject(pProjMatch, FALSE);
	pProjMatch->Release();
}

void CApplication::ExecuteConfiguration(const VARIANT FAR& configuration) 
{
	if (configuration.vt == VT_ERROR)
	{
		// Default passes no params--just build active config
		CWnd* pWnd = AfxGetMainWnd();
		if (pWnd == NULL)
		{
			ASSERT(FALSE);
			return;
		}

		pWnd->SendMessage(WM_COMMAND, MAKEWPARAM(IDM_PROJECT_EXECUTE, 1));
	}

	// FUTURE: If configuration is non-empty, then execute that specific configuration
	//  instead of the active one.
}

BOOL CApplication::GetVisible() 
{
	CWnd* pWnd = AfxGetMainWnd();
	if (pWnd == NULL)
		DsThrowCannedOleDispatchException(E_UNEXPECTED);

	return pWnd->IsWindowVisible();
}

void CApplication::SetVisible(BOOL bNewValue) 
{
	CMainFrame* pWnd = static_cast<CMainFrame*>(AfxGetMainWnd());
	ASSERT_KINDOF(CMainFrame, pWnd) ;

	if (pWnd == NULL)
	{
		DsThrowCannedOleDispatchException(E_UNEXPECTED);
	}

	if (bNewValue == FALSE && pWnd->IsWindowVisible() == TRUE)
	{
		// If we're becoming invisible, remember if we were just maximized
		m_bMaximizeApp = theApp.m_bMaximizeApp;
	}
	else if (bNewValue == TRUE)
	{
		// If launched by automation but suddenly made visible, then user
		//  is in control
		AfxOleSetUserCtrl(TRUE);
	}

	// If we're making the app visible, be sure to get its maximized state right,
	//  by seeing whether it was maximized when it was last made invisible.
	pWnd->ShowWindow(bNewValue ? (m_bMaximizeApp ? SW_SHOWMAXIMIZED : SW_SHOW)
							   : SW_HIDE);

	// Bug 14790 --- The stupid docking windows are WM_POPUPs so they do not hide when the 
	// main frame hides. Therefore, we need to explicitly hide and unhide them.
	// If m_bRunInvisibly is TRUE, ShowManager will not call ShowPalettes and the
	// palette (ie floating windows) will not get updated.
	theApp.m_bRunInvisibly = FALSE; // Always set to false before the next call.
	pWnd->m_pManager->ShowManager(bNewValue, updNow, TRUE);
	theApp.m_bRunInvisibly = !bNewValue; 
}


// BEGIN_PATHETICNESS [davbr]
// The following code is required to convince the linker/compiler/whatever
//  to reference the Application's connection point interfaces.  Without
//  this code, we'll get unresolved externals for the vector deleteting
//  destructors.  Don't ask, I have no idea.
void ForceVectors()
{
	CApplication::XApplicationCP *pClass = new CApplication::XApplicationCP[2];
	CApplication::XDispApplicationCP *pClass2 = new CApplication::XDispApplicationCP[2];
}

static void (*pFunc)() = ForceVectors;
// END_PATHETICNESS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autodocd.h ===
// AutoDocD.h : header file
//
#ifndef __AutoDocD_H__
#define __AutoDocD_H__

#include <utilauto.h>

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

#define _DUAL_

class CPartDoc ;


/////////////////////////////////////////////////////////////////////////////
// CAutoDocumentDefault command target

class CAutoDocumentDefault : public CAutoObj
{
	DECLARE_DYNAMIC(CAutoDocumentDefault)

	CAutoDocumentDefault(CPartDoc* pDoc);           // protected constructor used by dynamic creation

// Attributes
public:
	CPartDoc* m_pDoc;
	void NoDoc() ;

// Operations
public:
#ifdef _DUAL_
  DECLARE_DUAL_ERRORINFO()
#endif

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoDocumentDefault)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

	// CPartDoc calls this so we NULL m_pDoc.
	void AssociatedObjectReleased();

// Implementation
	virtual ~CAutoDocumentDefault();
protected:

#ifdef _DUAL_
	DS_BEGIN_DUAL_INTERFACE_PART(GenericDocument)
		STDMETHOD(get_Name)(THIS_ BSTR FAR* pName) ;
		STDMETHOD(get_FullName)(THIS_ BSTR FAR* pName) ;
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppApplication) ;
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppParent) ;
		STDMETHOD(get_Path)(THIS_ BSTR FAR* pPath) ;
		STDMETHOD(get_Saved)(THIS_ VARIANT_BOOL FAR* pSaved) ;
		STDMETHOD(get_ActiveWindow)(THIS_ IDispatch * FAR* ppWindow) ;
		STDMETHOD(get_ReadOnly)(THIS_ VARIANT_BOOL FAR* pReadOnly) ;
		STDMETHOD(put_ReadOnly)(THIS_ VARIANT_BOOL ReadOnly) ;
		STDMETHOD(get_Type)(THIS_ BSTR FAR* pType) ;
		STDMETHOD(get_Windows)(THIS_ IDispatch * FAR* ppWindows) ;
		STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) ;
		STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) ;
		STDMETHOD(NewWindow)(THIS_ IDispatch * FAR* ppWindow) ;
		STDMETHOD(Save)(THIS_ VARIANT vFilename, VARIANT vBoolPrompt, DsSaveStatus FAR* pSaved) ;
		STDMETHOD(Undo)(THIS_ VARIANT_BOOL FAR* pSuccess) ;
		STDMETHOD(Redo)(THIS_ VARIANT_BOOL FAR* pSuccess) ;
		STDMETHOD(PrintOut)(THIS_ VARIANT_BOOL FAR* pSuccess) ;
		STDMETHOD(Close)(THIS_ VARIANT vSaveChanges, DsSaveStatus FAR* pSaved) ;
		DS_DECLARE_VTBL_PAD_10()
	DS_END_DUAL_INTERFACE_PART(GenericDocument)

	DS_DECLARE_ENABLE_DUAL(CAutoDocumentDefault, GenericDocument)
#endif

	// Generated message map functions
	//{{AFX_MSG(CAutoDocumentDefault)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

/* Removed see DualImpl.doc
	DECLARE_OLECREATE(CAutoDocumentDefault)
*/

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoDocumentDefault)
	afx_msg BSTR GetName();
	afx_msg BSTR GetFullName();
	afx_msg LPDISPATCH GetApplication();
	afx_msg LPDISPATCH GetParent();
	afx_msg BSTR GetPath();
	afx_msg BOOL GetSaved();
	afx_msg void SetSaved(BOOL bNewValue);
	afx_msg BSTR GetType();
	afx_msg BOOL GetReadOnly();
	afx_msg void SetReadOnly(BOOL bReadOnly) ;
	afx_msg LPDISPATCH GetActiveWindow();
	afx_msg LPDISPATCH GetWindows();
	afx_msg BOOL GetActive();
	afx_msg void SetActive(BOOL bNewValue);
	afx_msg BOOL Redo();
	afx_msg BOOL Undo();
	afx_msg LPDISPATCH NewWindow();
	afx_msg BOOL PrintOut();
	//}}AFX_DISPATCH

	afx_msg DsSaveStatus Close(const VARIANT FAR& longSaveChanges);
	afx_msg DsSaveStatus Save(const VARIANT FAR& filename, const VARIANT FAR& longSaveChanges);
	
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

};

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __AutoDocD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autoguid.h ===
// GUIDs used in our automation object model that are not exposed to the user
//  in include\objmodel\appguid.h.  These are the dispinterface IDs and the
//  CLSIDs which are declared in the type library and used internally to 
//  implement the objects, but are not exposed to C++ clients through our
//  headers.

// {2769BF40-1930-11cf-8E4D-00AA004254C4}
DEFINE_GUID(IID_IDispApplication, 
0x2769bf40, 0x1930, 0x11cf, 0x8e, 0x4d, 0x0, 0xaa, 0x0, 0x42, 0x54, 0xc4);

// {E9EB1AE1-89A8-11CF-9BE8-00A0C90A632C}
DEFINE_GUID(IID_IDispDocuments,
0xE9EB1AE1L,0x89A8,0x11CF,0x9B,0xE8,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// {E9EB1AE2-89A8-11CF-9BE8-00A0C90A632C}
DEFINE_GUID(CLSID_Documents,
0xE9EB1AE2L,0x89A8,0x11CF,0x9B,0xE8,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// AutoWindows Dispatch GUID.
// {5774D191-96E1-11CF-9C00-00A0C90A632C}
DEFINE_GUID(IID_IDispWindows,
0x5774D191L, 0x96E1, 0x11CF, 0x9C, 0x00, 0x00, 0xA, 0xC9, 0x0A, 0x63, 0x2C);

// {5774D192-96E1-11CF-9C00-00A0C90A632C}
DEFINE_GUID(CLSID_Windows,
0x5774D192L, 0x96E1, 0x11CF, 0x9C, 0x00, 0x00, 0xA0, 0xC9, 0x0A, 0x63, 0x2C);

// DispInterface
// {E1870221-933A-11CF-9BF9-00A0C90A632C}
DEFINE_GUID(IID_IDispGenericDocument,
0xE1870221L,0x933A,0x11CF,0x9B,0xF9,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// {E1870222-933A-11CF-9BF9-00A0C90A632C}
DEFINE_GUID(CLSID_GenericDocument,
0xE1870222L,0x933A,0x11CF,0x9B,0xF9,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// DispInterface
// {E1870223-933A-11CF-9BF9-00A0C90A632C}
DEFINE_GUID(IID_IDispGenericWindow,
0xE1870223L,0x933A,0x11CF,0x9B,0xF9,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// {E1870224-933A-11CF-9BF9-00A0C90A632C}
DEFINE_GUID(CLSID_GenericWindow,
0xE1870224L,0x933A,0x11CF,0x9B,0xF9,0x00,0xA0,0xC9,0x0A,0x63,0x2C);

// {DFAC7C40-A810-11CF-AD07-00A0C9034965}
DEFINE_GUID(IID_IDispProjects,
0xDFAC7C40L,0xA810,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {DFAC7C41-A810-11CF-AD07-00A0C9034965}
DEFINE_GUID(CLSID_Projects,
0xDFAC7C41L,0xA810,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);



/////////////////////////////////////////////////////////////////////////
// AutoCollection IDs

// {5FCF79C0-648E-11cf-AD07-00A0C9034965}
DEFINE_GUID(IID_IDualObjs,
0x5FCF79C0L,0x648E,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);

// {5C26FC60-6076-11CF-AD07-00A0C9034965}
DEFINE_GUID(IID_IObjs,
0x5C26FC60L,0x6076,0x11CF,0xAD,0x07,0x00,0xA0,0xC9,0x03,0x49,0x65);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autofrm.cpp ===
/*
AutoFrm.cpp -

This file contains the default implementations of the OLE Automation Windows
Objects for CPartFrame. See shldocs.h for the declarations. Each CPartFrame 
derived class has its own CAutoObj automation object. These automation objects
implement the necessary code. Most of these automation objects can simply call
these functions in CPartFrm. Those that need different implementations of these
functions should NOT override these. These functions are NOT virtual. Instead 
change the implementation in your CAutoObj derived class.

12 Apr 96 Created Dale
*/
#include "stdafx.h"

#include "utilauto.h"
#include "autostat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
//
//
BSTR CPartFrame::GetCaption()
{
	CString strResult;
	GetWindowText(strResult) ;
	return strResult.AllocSysString();
}

/* Do not implement
void CPartFrame::SetCaption(LPCTSTR lpszNewValue)
{
	ASSERT(lpszNewValue == NULL) ;
	if (lpszNewValue != NULL)
	{
		SetWindowText(lpszNewValue) ;
	}
}
*/

//
//
//

long CPartFrame::GetLeft()
{
	// Get client rectangle
	CRect rect;
	GetWindowRect(&rect);

	// Convert to client co-ordinate relative to frame.
	CWnd* pMdiClient = GetParent();
	pMdiClient->ScreenToClient(&rect) ;

	return rect.left;
}

void CPartFrame::SetLeft(long nNewValue)
{
	// TODO: Docking

	// Get parent frame to check for valid values.
	CWnd* pMdiClient = GetParent();
	CRect rectMdiClient;
	pMdiClient->GetClientRect(&rectMdiClient) ; //DER - What's the real space I have...

	// Check for valid values.
	if ((nNewValue >= 0)  && 
		(nNewValue < rectMdiClient.Width()))
	{
		// Get the existing dimensions of the window.
		CRect rect ;
		GetWindowRect(&rect) ;		

		// Convert to client co-ordinates.
		pMdiClient->ScreenToClient(&rect) ;

		// Move
		MoveWindow(nNewValue, rect.top, 
					rect.Width(), rect.Height(), TRUE);
	}

}

long CPartFrame::GetTop()
{
	// Get client rectangle
	CRect rect;
	GetWindowRect(&rect);

	// Convert to client co-ordinate relative to frame.
	CWnd* pMdiClient = GetParent();
	pMdiClient->ScreenToClient(&rect) ;

	return rect.top;
}

void CPartFrame::SetTop(long nNewValue)
{
	// TODO: Docking

	// Get parent frame to check for valid values.
	CWnd* pMdiClient = GetParent();
	CRect rectMdiClient;
	pMdiClient->GetClientRect(&rectMdiClient) ; //DER - What's the real space I have...

	// Check for valid values.
	if ((nNewValue >= 0)  && 
		(nNewValue < rectMdiClient.Height()))
	{
		// Get the existing dimensions of the window.
		CRect rect ;
		GetWindowRect(&rect) ;		

		// Convert to client co-ordinates.
		pMdiClient->ScreenToClient(&rect) ;

		// Move
		MoveWindow(rect.left, nNewValue, 
					rect.Width(), rect.Height(), TRUE);
	}
}

long CPartFrame::GetHeight()
{
	// Get client rectangle
	CRect rect;
	GetWindowRect(&rect);

	// Convert to client co-ordinate relative to frame.
	CWnd* pMdiClient = GetParent();
	pMdiClient->ScreenToClient(&rect) ;

	return rect.Height();
}

void CPartFrame::SetHeight(long nNewValue)
{
	// TODO: Docking

	// Get parent frame to check for valid values.
	//
	// NOTE - Use GetParent and not GetParentFrame.
	// We want to get the MDICLIENT window.
	//
	CWnd* pMdiClient = GetParent();
	CRect rectMdiClient;
	pMdiClient->GetClientRect(&rectMdiClient) ; //DER - What's the real space I have...	

	// Check for valid values.
	if ((nNewValue >= 0)  && 
		(nNewValue < rectMdiClient.Height())) 
	{
		// Get the existing dimensions of the window.
		CRect rect ;
		GetWindowRect(&rect) ;		

		// Convert to client co-ordinates.
		pMdiClient->ScreenToClient(&rect) ; 

		// Move
		MoveWindow(rect.left, rect.top, 
					rect.Width(), nNewValue, TRUE);
	}
}

long CPartFrame::GetWidth()
{
	// Get rectangle for window.
	CRect rect;
	GetWindowRect(&rect);

	// Convert to client co-ordinate relative to frame.
	CWnd* pMdiClient = GetParent();
	pMdiClient->ScreenToClient(&rect) ;

	return rect.Width();
}

void CPartFrame::SetWidth(long nNewValue)
{
	// TODO: Docking

	// Get parent frame to check for valid values.
	CWnd* pMdiClient = GetParent();
	CRect rectMdiClient;
	pMdiClient->GetClientRect(&rectMdiClient) ; //DER - What's the real space I have...

	// Check for valid values.
	if ((nNewValue >= 0)  && 
		(nNewValue < rectMdiClient.Width()))
	{
		// Get the existing dimensions of the window.
		CRect rect ;
		GetWindowRect(&rect) ;		

		// Convert to client co-ordinates.
		pMdiClient->ScreenToClient(&rect) ;

		// Move
		MoveWindow(rect.left, rect.top, 
					nNewValue, rect.Height(), TRUE);
	}
}

long CPartFrame::GetIndex()
{
	const long cBadCount = -1;
	long count = cBadCount;

	IDispatch* pDispatch = NULL;
	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));
	ASSERT_KINDOF(CMainFrame, pMainFrame) ;

#ifdef _DEBUG
	BOOL bFound = FALSE ;
#endif
	CPartFrame* pMDIChild = (CPartFrame*)GetWindow(GW_HWNDFIRST);
	ASSERT_KINDOF(CPartFrame, pMDIChild) ;
	while(pMDIChild != NULL)
	{
		if(!IsValidMDICycleMember(pMDIChild))
			continue;

		// Make sure that it is automatable
		pDispatch = pMDIChild->GetAutomationObject(TRUE); //ToDo...Fix the False case
		if (pDispatch == NULL)
		{
			continue ;
		}
		else
		{
			pDispatch->Release() ;
		}

		// We have a window. Increment the count.
		count++ ;
		if(pMDIChild == this) // we completed the loop
		{
			// We have found our current window, so quit.
#ifdef _DEBUG
			bFound = TRUE ;
#endif
			break;
		}

		// Find next window.
		pMDIChild = (CPartFrame*)pMDIChild->GetWindow(GW_HWNDNEXT);
		ASSERT_KINDOF(CPartFrame, pMDIChild) ;
	}
	ASSERT(bFound = TRUE) ;
	ASSERT(count != cBadCount) ;

	return count;
}

static LPDISPATCH NextWin(CPartFrame* pMDIChildStart, BOOL goUp)
{
	IDispatch* pDispatch = NULL;
	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	DWORD dwNextWin = goUp ? GW_HWNDPREV : GW_HWNDNEXT;
	DWORD dwFirstWin = goUp ? GW_HWNDLAST : GW_HWNDFIRST;
	CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
	CPartFrame* pMDIChild = pMDIChildStart;
	while( TRUE )
	{
		pMDIChild = (CPartFrame *)pMDIChild->GetWindow(dwNextWin);
		if(pMDIChild == NULL) // we got to the end of the list
			pMDIChild = (CPartFrame *)pMDIActiveChild->GetWindow(dwFirstWin);

		if(pMDIChild == pMDIActiveChild) // we completed the loop
			break;

		if(!IsValidMDICycleMember(pMDIChild))
			continue;
				// Get the automation object for this document.
		pDispatch = pMDIChild->GetAutomationObject(TRUE);
		if (pDispatch != NULL)
			break;
	}
	if(pDispatch == NULL)
		pDispatch = pMDIActiveChild->GetAutomationObject(TRUE) ;

	return pDispatch;
}

LPDISPATCH CPartFrame::GetNext()
{
	return NextWin(this, FALSE);
}

LPDISPATCH CPartFrame::GetPrevious()
{
	return NextWin(this, TRUE);
}

DsWindowState CPartFrame::GetWindowState() 
{
	// Main window can't docking or float.
	DsWindowState state = dsWindowStateNormal ;

	if (IsIconic())
	{
		state = dsWindowStateMinimized ;
	}
	else if (IsZoomed())
	{
		state = dsWindowStateMaximized ;
	}
	return state;
}


void CPartFrame::SetWindowState(DsWindowState nNewValue) 
{
	int nCmdShow ;

	switch(nNewValue)
	{
	case dsWindowStateMaximized :
	    nCmdShow = SW_SHOWMAXIMIZED ;
		break;
	case dsWindowStateMinimized :
		nCmdShow = SW_MINIMIZE ;
		break;
	case dsWindowStateNormal:
		nCmdShow = SW_SHOWNORMAL;
		break;
	default:
		// Main window cannot be docked or floated.
		// TODO: ERROR
		return ;
	}
	ShowWindow(nCmdShow) ;
}

DsSaveStatus CPartFrame::AutomationClose(const VARIANT FAR& vtLongSaveChanges)
{
	g_AutomationState.SaveChanges(vtLongSaveChanges);
	
	// Attempt to close the frame
	CloseFrame();

	// Return if the save was canceled. (HandleError resets status.)
	DsSaveStatus status = g_AutomationState.SavePromptResult() ;		

	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;

	// Return if the save was canceled.
	return status ;		
};

BOOL CPartFrame::GetActive()
{
	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
	ASSERT(pMDIActiveChild != NULL) ;
	return (pMDIActiveChild == this) ;
}

void CPartFrame::SetActive(BOOL bActive)
{
	BOOL bCurrentlyActive = GetActive() ;

	if (bActive == bCurrentlyActive) 
	{
		// Optimization. Current state is already
		// correct so don't do any work.
		return ;
	}

	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	if (bActive)	// Make this window active.
	{
		pMainFrame->MDIActivate(this) ;		
	}
	else			// Make this window in-active.
	{
		// We will activate the next window.
		CPartFrame* pMDIChild = (CPartFrame*)GetWindow(GW_HWNDNEXT);
		ASSERT_KINDOF(CPartFrame, pMDIChild) ;
		if(pMDIChild == NULL) // we got to the end of the list
		{
			// Get the first window.
			pMDIChild = (CPartFrame*)GetWindow(GW_HWNDFIRST);
			ASSERT_KINDOF(CPartFrame, pMDIChild) ;
		}

		// Only activate if it is different than the current window.
		if (pMDIChild != this)
		{
			pMainFrame->MDIActivate(pMDIChild) ;		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autoprjs.cpp ===
// AutoPrjs.cpp : implementation file
//

#include "stdafx.h"
#include "AutoPrjs.h"
#include "autoguid.h"
#include <main.h>
#include <ObjModel\appauto.h>
#include "toolexpt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAutoProjects dual implementation

STDMETHODIMP CAutoProjects::XProjects::get_Application(IDispatch * FAR* Application)
{
	METHOD_PROLOGUE(CAutoProjects, Dispatch)
	
	TRY_DUAL(IID_IProjects)
	{
		*Application = pThis->GetApplication();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProjects::XProjects::get_Count(long FAR* Count)
{
	METHOD_PROLOGUE(CAutoProjects, Dispatch)
	
	TRY_DUAL(IID_IProjects)
	{
		*Count = pThis->GetCount();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProjects::XProjects::get_Parent(IDispatch * FAR* Parent)
{
	METHOD_PROLOGUE(CAutoProjects, Dispatch)
	
	TRY_DUAL(IID_IProjects)
	{
		*Parent = pThis->GetParent();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProjects::XProjects::get__NewEnum(IUnknown * FAR* _NewEnum)
{
	METHOD_PROLOGUE(CAutoProjects, Dispatch)
	
	TRY_DUAL(IID_IProjects)
	{
		*_NewEnum = pThis->GetNewEnum();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

STDMETHODIMP CAutoProjects::XProjects::Item(VARIANT Index, IGenericProject FAR* FAR* Item)
{
	METHOD_PROLOGUE(CAutoProjects, Dispatch)
	
	TRY_DUAL(IID_IProjects)
	{
		*Item = (IGenericProject*) pThis->Item(Index);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}

/////////////////////////////////////////////////////////////////////////////
// CAutoProjects
// This class represents the collection of all projects in the currently
//  open workspace.  An instance of this class is created by 
//  CBldPackage::GetPackageExtension in vproj.cpp (via CAutoProjects::Create).

IMPLEMENT_DYNCREATE(CAutoProjects, CAutoObj)

CAutoProjects::CAutoProjects()
{
	EnableDualAutomation();

	m_pPtrlProjects = NULL;
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CAutoProjects::~CAutoProjects()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}


void CAutoProjects::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	// Release each individual project & the collection
	POSITION pos = m_pPtrlProjects->GetHeadPosition();
	while (pos != NULL)
	{
		IDispatch* pDispatch = m_pPtrlProjects->GetNext(pos);
		ASSERT (pDispatch != NULL);
		pDispatch->Release() ;
	}

	// The collection is in charge of cleaning this up.
	delete m_pPtrlProjects ;
	m_pPtrlProjects = NULL;


	CAutoObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoProjects, CAutoObj)
	//{{AFX_MSG_MAP(CAutoProjects)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoProjects, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoProjects)
	DISP_PROPERTY_EX(CAutoProjects, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoProjects, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoProjects, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoProjects, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_DEFVALUE(CAutoProjects, "Item")
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoProjects, "_NewEnum", DISPID_NEWENUM, GetNewEnum, SetNotSupported, VT_UNKNOWN)
END_DISPATCH_MAP()

BEGIN_INTERFACE_MAP(CAutoProjects, CAutoObj)
 	INTERFACE_PART(CAutoProjects, IID_IDispProjects, Dispatch)
 	INTERFACE_PART(CAutoProjects, IID_IProjects, Dispatch)
    DUAL_ERRORINFO_PART(CAutoProjects)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoProjects, IID_IProjects)
DS_IMPLEMENT_ENABLE_DUAL(CAutoProjects, Projects)
DS_DELEGATE_DUAL_INTERFACE(CAutoProjects, Projects)

/////////////////////////////////////////////////////////////////////////////
// CAutoProjects message handlers

LPDISPATCH CAutoProjects::GetApplication() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

long CAutoProjects::GetCount() 
{
	IProjectWorkspace *pPW = g_IdeInterface.GetProjectWorkspace();
	CADWORD PkgProjects;
	VERIFY(SUCCEEDED(pPW->GetLoadedProjects(&PkgProjects)));

	// Release the CADWORD now
	for(int i=0; i<PkgProjects.cElems; i++)
	{
		((IPkgProject *)PkgProjects.pElems[i])->Release();
	}
	CoTaskMemFree((void *)PkgProjects.pElems);

	return PkgProjects.cElems;
}

LPUNKNOWN CAutoProjects::GetNewEnum() 
{
	// This is a live collection, so we need to update our
	// list of projects every time we look at them.
	BuildNewList();

	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlProjects);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}

LPDISPATCH CAutoProjects::GetParent() 
{
	// The parent of the Projects collection is the Application object
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

LPDISPATCH CAutoProjects::Item(const VARIANT FAR& index) 
{
	// Check to see if there isn't a parameter.
	if (index.vt == VT_ERROR)
	{
		// Parameter is optional and is not supplied.
		// Return a pointer to this collection.
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}
	// This is a live collection, so we need to update our
	// list of projects every time we look at them.
	BuildNewList();

	// Check to see if the parameter is a string
	if (index.vt == VT_BSTR)
	{
		LPDISPATCH pDispRetProject = NULL;
		POSITION pos = m_pPtrlProjects->GetHeadPosition();
		while (pos != NULL)
		{
			IGenericProject *pCurrProject = (IGenericProject *)m_pPtrlProjects->GetNext(pos);
			BSTR bstrName;
			pCurrProject->get_Name(&bstrName);
			if(wcscmp(bstrName, index.bstrVal) == 0)
			{
				pDispRetProject = pCurrProject;
				pDispRetProject->AddRef();
			}
			::SysFreeString(bstrName);
			if(pDispRetProject != NULL)
				break;
		}
		return pDispRetProject ;
	}

    // coerce index to VT_I4
	COleVariant coercedIndex(index);
	coercedIndex.ChangeType(VT_I4);
 	IDispatch* pObj = NULL ;
	POSITION pos = NULL;
	// Subtract 1 from index, since we expect a 1-based index.
	if(coercedIndex.lVal > 0)
	    pos = m_pPtrlProjects->FindIndex(coercedIndex.lVal-1);
    if (pos != NULL)
	{
        pObj = m_pPtrlProjects->GetAt(pos);
		ASSERT (pObj != NULL);
	}
	else
	{
		DsThrowCannedOleDispatchException(E_INVALIDARG);
	}
    
	ASSERT (pObj != NULL);
	pObj->AddRef();
	return pObj ;
}

CAutoProjects* CAutoProjects::Create()
{
	// Make a new CAutoProjects
	CAutoProjects* pProjects = new CAutoProjects;
	pProjects->m_pPtrlProjects = new CDispatchList;
	return pProjects;
}

void CAutoProjects::BuildNewList()
{
	ASSERT(m_pPtrlProjects != NULL);
	POSITION pos = m_pPtrlProjects->GetHeadPosition();
	while (pos != NULL)
	{
		IGenericProject *pCurrProject = (IGenericProject *)m_pPtrlProjects->GetNext(pos);
		pCurrProject->Release();
	}

	// Now empty the list to prepare for the new elements.
	m_pPtrlProjects->RemoveAll();

	// Enumerate through Projects, create a CAutoProject for each,
	//  and put them all in m_pPtrlProjects.
	IProjectWorkspace *pPW = g_IdeInterface.GetProjectWorkspace();
	CADWORD PkgProjects;
	VERIFY(SUCCEEDED(pPW->GetLoadedProjects(&PkgProjects)));
	for(int i=0; i<PkgProjects.cElems; i++)
	{
		LPDISPATCH pDisp;
		VERIFY(SUCCEEDED(((IPkgProject *)PkgProjects.pElems[i])->GetAutomationObject(&pDisp)));
		((IPkgProject *)PkgProjects.pElems[i])->Release();
		m_pPtrlProjects->AddTail(pDisp);
	}
	// Free the CADWORD now
	CoTaskMemFree((void *)PkgProjects.pElems);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autoprjs.h ===
// AutoPrjs.h : header file
//
#include <utilauto.h>
#include <ObjModel\appauto.h>
#include <ObjModel\appguid.h>


/////////////////////////////////////////////////////////////////////////////
// CAutoProjects command target
// This class represents the collection of all projects in the currently
//  open workspace.  An instance of this class is created by 
//  CBldPackage::GetPackageExtension in vproj.cpp (via CAutoProjects::Create).

class CAutoProjects : public CAutoObj
{
	DECLARE_DYNCREATE(CAutoProjects)

	CAutoProjects();           // protected constructor used by dynamic creation

// Attributes
public:
	static CAutoProjects* Create();

// Operations
public:
	DECLARE_DUAL_ERRORINFO();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoProjects)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDispatchList* m_pPtrlProjects;
	virtual ~CAutoProjects();

	// Generated message map functions
	//{{AFX_MSG(CAutoProjects)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoProjects)
	afx_msg LPDISPATCH GetApplication();
	afx_msg long GetCount();
	afx_msg LPDISPATCH GetParent();
	afx_msg LPDISPATCH Item(const VARIANT FAR& Index);
	//}}AFX_DISPATCH
	afx_msg LPUNKNOWN GetNewEnum();
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
 	DS_BEGIN_DUAL_INTERFACE_PART(Projects)
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* Application);
		STDMETHOD(get_Count)(THIS_ long FAR* Count);
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* Parent);
		STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* _NewEnum);
		STDMETHOD(Item)(THIS_ VARIANT Index, IGenericProject FAR* FAR* Item);
 	DS_END_DUAL_INTERFACE_PART(Projects)
 
 	DS_DECLARE_ENABLE_DUAL(CAutoProjects, Projects)

private:
	void BuildNewList();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autowind.cpp ===
// AutoWindowDefault.cpp : implementation file
//

#include "stdafx.h"
#include "AutoWinD.h"
#include "autoguid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// Delegate to Dispatch implementation

// properties

DELEGATE_BSTR_GET(CAutoWindowDefault,GenericWindow, Caption, Caption)
DELEGATE_BSTR_GET(CAutoWindowDefault,GenericWindow, Type, Type)

DELEGATE_BOOL_PUT(CAutoWindowDefault,GenericWindow,Active)

DELEGATE_BOOL_GET(CAutoWindowDefault,GenericWindow,Active)

DELEGATE_GET(CAutoWindowDefault,GenericWindow,Left,long)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Top,long)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Height,long)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Width,long)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Index,long)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,WindowState,DsWindowState)

DELEGATE_PUT(CAutoWindowDefault,GenericWindow,Left,long)
DELEGATE_PUT(CAutoWindowDefault,GenericWindow,Top,long)
DELEGATE_PUT(CAutoWindowDefault,GenericWindow,Height,long)
DELEGATE_PUT(CAutoWindowDefault,GenericWindow,Width,long)
DELEGATE_PUT(CAutoWindowDefault,GenericWindow,WindowState,DsWindowState)

DELEGATE_GET(CAutoWindowDefault,GenericWindow,Next,LPDISPATCH)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Previous,LPDISPATCH)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Application,LPDISPATCH)
DELEGATE_GET(CAutoWindowDefault,GenericWindow,Parent,LPDISPATCH)

DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoWindowDefault,GenericWindow,Close,VARIANT, DsSaveStatus)

/////////////////////////////////////////////////////////////////////////////
// CAutoWindowDefault

IMPLEMENT_DYNAMIC(CAutoWindowDefault, CAutoWindowObj)

CAutoWindowDefault::CAutoWindowDefault(CPartFrame* pFrame)
{
	ASSERT( pFrame != NULL) ;
	m_pAssociatedPartFrame = pFrame ;

#ifdef _DUAL_
	EnableDualAutomation();
#else
	EnableAutomation() ;
#endif
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
}

CAutoWindowDefault::~CAutoWindowDefault()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.

	if (m_pAssociatedPartFrame != NULL)
	{
		m_pAssociatedPartFrame->AutomationObjectReleased() ;
	}

	AfxOleUnlockApp();
}

//
// CPartFrame and CPartDoc call this function to inform us
// that they are being deleted.
//
void CAutoWindowDefault::AssociatedObjectReleased()
{
	m_pAssociatedPartFrame = NULL ;
}



void CAutoWindowDefault::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoWindowObj::OnFinalRelease();
}


BEGIN_MESSAGE_MAP(CAutoWindowDefault, CAutoWindowObj)
	//{{AFX_MSG_MAP(CAutoWindowDefault)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoWindowDefault, CAutoWindowObj)
	//{{AFX_DISPATCH_MAP(CAutoWindowDefault)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Caption", GetCaption, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Type", GetType, SetNotSupported, VT_BSTR)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Active", GetActive, SetActive, VT_BOOL)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Left", GetLeft, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Top", GetTop, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Height", GetHeight, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Width", GetWidth, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Index", GetIndex, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Next", GetNext, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Previous", GetPrevious, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoWindowDefault, "WindowState", GetWindowState, SetWindowState, VT_I4)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoWindowDefault, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoWindowDefault, "Close", Close, VT_I4, VTS_VARIANT)
	DISP_DEFVALUE(CAutoWindowDefault, "Caption")
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IAutoViewDefault to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

/*
// {E1870223-933A-11CF-9BF9-00A0C90A632C}
static const IID IID_IAutoViewDefault =
{ 0xe1870223, 0x933a, 0x11cf, { 0x9b, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c } };
*/

BEGIN_INTERFACE_MAP(CAutoWindowDefault, CAutoWindowObj)
	INTERFACE_PART(CAutoWindowDefault, IID_IDispGenericWindow, Dispatch)
	INTERFACE_PART(CAutoWindowDefault, IID_IGenericWindow, Dispatch)
#ifdef _DUAL_
	DUAL_ERRORINFO_PART(CAutoWindowDefault)
#endif
END_INTERFACE_MAP()

#ifdef _DUAL_
IMPLEMENT_DUAL_ERRORINFO(CAutoWindowDefault, IID_IGenericWindow)
DS_IMPLEMENT_ENABLE_DUAL(CAutoWindowDefault, GenericWindow)
DS_DELEGATE_DUAL_INTERFACE(CAutoWindowDefault, GenericWindow)
DS_IMPLEMENT_VTBL_PAD_10(CAutoWindowDefault, GenericWindow)
#endif

/* See DualImpl.doc
// {E1870224-933A-11CF-9BF9-00A0C90A632C}
IMPLEMENT_OLECREATE(CAutoWindowDefault, "VSHELL7.AUTOVIEWDEFAULT", 0xe1870224, 0x933a, 0x11cf, 0x9b, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c)
*/


/////////////////////////////////////////////////////////////////////////////
// This function checks to see if the associated frame is still alive.
// If it is not alive, it returns TRUE. If it is alive it throws an exception 
// and returns false.
void CAutoWindowDefault::NoFrame() 
{
	if (m_pAssociatedPartFrame == NULL) 
	{
		DsThrowShellOleDispatchException(DS_E_WINDOW_RELEASED); 
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAutoWindowDefault message handlers

BSTR CAutoWindowDefault::GetCaption() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetCaption() ;
}


LPDISPATCH CAutoWindowDefault::GetApplication()
{	
	return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

LPDISPATCH CAutoWindowDefault::GetParent()
{
	NoFrame();

	// Get the the view for this frame....
	CView *pView = m_pAssociatedPartFrame->GetActiveView();
	ASSERT(pView);

	// Get the document for this view.
	CPartDoc* pDoc = static_cast<CPartDoc*>(pView->GetDocument());

	// Return the IDispatch pointer...
	return pDoc->GetAutomationObject(TRUE);
}

BSTR CAutoWindowDefault::GetType() 
{
	CString strResult;
	strResult = "Generic" ;
	return strResult.AllocSysString();
}


BOOL CAutoWindowDefault::GetActive() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetActive() ;
}

void CAutoWindowDefault::SetActive(BOOL bNewValue) 
{
	NoFrame();
	m_pAssociatedPartFrame->SetActive(bNewValue) ;
}

long CAutoWindowDefault::GetLeft() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetLeft() ;
}

void CAutoWindowDefault::SetLeft(long nNewValue) 
{
	NoFrame();
	m_pAssociatedPartFrame->SetLeft(nNewValue) ;
}

long CAutoWindowDefault::GetTop() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetTop() ;
}

void CAutoWindowDefault::SetTop(long nNewValue) 
{
	NoFrame();
	m_pAssociatedPartFrame->SetTop(nNewValue) ;
}

long CAutoWindowDefault::GetHeight() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetHeight() ;
}

void CAutoWindowDefault::SetHeight(long nNewValue) 
{
	NoFrame();
	m_pAssociatedPartFrame->SetHeight(nNewValue) ;
}

long CAutoWindowDefault::GetWidth() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetWidth() ;
}

void CAutoWindowDefault::SetWidth(long nNewValue) 
{
	NoFrame();
	m_pAssociatedPartFrame->SetWidth(nNewValue) ;
}

long CAutoWindowDefault::GetIndex() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetIndex();
}

LPDISPATCH CAutoWindowDefault::GetNext() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetNext() ;
}


LPDISPATCH CAutoWindowDefault::GetPrevious() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetPrevious() ;
}


DsWindowState CAutoWindowDefault::GetWindowState() 
{
	NoFrame();
	return m_pAssociatedPartFrame->GetWindowState() ;
}

void CAutoWindowDefault::SetWindowState(DsWindowState nNewValue) 
{
	NoFrame();
	m_pAssociatedPartFrame->SetWindowState(nNewValue) ;
}

DsSaveStatus CAutoWindowDefault::Close(const VARIANT FAR& vtSaveChanges) 
{
	// TODO: Add your dispatch handler code here
	NoFrame();
	return m_pAssociatedPartFrame->AutomationClose(vtSaveChanges) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autostat.h ===
#ifndef __AutoStat_h__
#define __AutoStat_h__
////////////////////////////////////////////////////////////////////////////
//
// CShellAutomationState
//
//
class CShellAutomationState : public IDsAutomationState
{
public:
	// If TRUE, you can display UI. If FALSE do not display any UI.
	virtual BOOL DisplayUI() 
		{return m_bDisplayUI; }

	// If TRUE, you should save changes, if FALSE you should discard changes.
	virtual BOOL SaveChanges() 
		{return m_bSaveChanges; }

	// Use one of the the following functions to set the error code.
	//
	// Set the error with a CFileException::m_cause type error. 
	// Translates the error into an HRESULT for automation purposes.
	// Used by the global function SetError
	virtual void SetFileError(int FileExceptionError) ;

	// What is this for?
	// Set the return value of the current operation.
	virtual void SetError(HRESULT hResult);

	// Set to signal that the Save prompt was canceled.
	virtual void SetSavePromptCanceled()		
		{m_bSavePromptCanceled = TRUE; }

	// For use only by the Automation Code.
	// The following will change!!!
public:
	void Reset() ;

	// Get the result of the current opreation
	HRESULT GetError()
		{return m_hResult; }

	// Reset the error state and throw exception on error.
	// Returns successful HRESULTs.
	HRESULT HandleError();

	// Enable or disable UI.
	// Only enable ui if you absolutely have to!
	virtual void EnableUI()
		{m_bDisplayUI = TRUE;}
	virtual void DisableUI()
		{m_bDisplayUI = FALSE;}

	void SetSaveChanges(BOOL bFlag) 
		{m_bSaveChanges = bFlag; }

	// Go straight from varient to the correct flags.
	void SaveChanges(const VARIANT FAR& vtLongSaveChanges);
	void SetPromptState(const VARIANT FAR& vtBoolPrompt);

	// Returns dsSaveCanceled if the save prompt was canceled.
	DsSaveStatus SavePromptResult() ;

	CShellAutomationState() 
		{Reset();}
	// Internal Implemenation
private:
	HRESULT m_hResult ; // Error Value

	//TODO: Change to enums.
	BOOL m_bSaveChanges;	// True if changes are to be saved.
	BOOL m_bDisplayUI ;		// True if the function can display UI. If FALSE, 
	BOOL m_bSavePromptCanceled ;
};

//
// Used by the core automation code.
//
extern CShellAutomationState g_AutomationState ;

#endif // __AutoStat_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autostat.cpp ===
/////////////////////////////////////////////////////////////////////////////
//  CAutomationState Object
//
//  This global object contains the state of automation currently happening 
//  in the 
// Use one of the the following functions to set the error code.
//
#include "stdafx.h"
#include "utilauto.h"
#include "autostat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void CShellAutomationState::Reset()
{ 
	m_bDisplayUI = TRUE ; 
	m_bSaveChanges = TRUE; 
	m_hResult = S_OK;
	m_bSavePromptCanceled = FALSE ;
} 

// Set the error with a CFileException::m_cause type error. 
// Translates the error into an HRESULT for automation purposes.
// Used by the global function SetError
void CShellAutomationState::SetFileError(int FileExceptionError)
{
	// Do not overwrite an existing error:
	if (m_hResult != S_OK) 
	{
		return ;
	}

	switch(FileExceptionError)
	{
		// The following errors means everything is A-OK.
	case (CFileException::none):		//No error occurred.
		m_hResult = S_OK ;
		break ;

		// The Following are the unique file errors that the automation state handles
	case (CFileException::endOfFile):   //The end of file was reached.
		m_hResult = DS_E_ENDOFFILE ;
		break ;

	case CFileException::fileNotFound:		//The file could not be located.
		m_hResult = DS_E_FILENOTFOUND ;
		break;

	case CFileException::badPath:			//All or part of the path is invalid.
		m_hResult = DS_E_BADPATH ;
		break ;

	case CFileException::accessDenied:		//The file could not be accessed.
		m_hResult = DS_E_ACCESSDENIED ;
		break ;

	case CFileException::invalidFile:		//There was an attempt to use an invalid file handle.
		m_hResult = DS_E_INVALIDFILE ;
		break ;

	case CFileException::diskFull:			//The disk is full.
		m_hResult = DS_E_DISKFULL ;
		break ;

	case CFileException::sharingViolation:  //SHARE.EXE was not loaded, or a shared region was locked.
		m_hResult = DS_E_SHARINGVIOLATION;
		break ;

	// The following errors all return E_FAIL. 
	case CFileException::tooManyOpenFiles:  //The permitted number of open files was exceeded.
	case CFileException::removeCurrentDir:  //The current working directory cannot be removed.
	case CFileException::directoryFull:		//There are no more directory entries.
	case CFileException::badSeek:			//There was an error trying to set the file pointer.
	case CFileException::hardIO:			//There was a hardware error.
	case CFileException::lockViolation:		//There was an attempt to lock a region that was already locked.
	case CFileException::generic:			//An unspecified error occurred.
	default:
		m_hResult = DS_E_UNKNOWN ;
	};
}

// Set the return value of the current operation.
void CShellAutomationState::SetError(HRESULT hResult /*= S_OK*/)
{
	m_hResult = hResult ;
}

// Takes a varient holding a DsSaveChanges enum and correct sets up the AutomationState.
// bAlwaysSave is used by Save to ensure that the user didn't specify DontSaveChanges to 
// Save.
void CShellAutomationState::SaveChanges(const VARIANT FAR& vtLongSaveChanges)
{
	const long DefaultValue = -1 ;
	Reset() ;

	// Fail if the parameter is a boolean.
	if (vtLongSaveChanges.vt == VT_BOOL)
	{
		DsThrowShellOleDispatchException(DS_E_BAD_PARAM_VALUE) ;
	}

	// Convert variant to a long.
	long lSaveChanges ;
	::ConvertVariantToLong(vtLongSaveChanges, lSaveChanges, DefaultValue) ;
	
	// Use parameter
	switch(lSaveChanges)
	{
	case DefaultValue: // Default value used.
		m_bDisplayUI = FALSE;
		break ;
	case dsSaveChangesYes:			
		m_bDisplayUI = FALSE;
		break ;
	case dsSaveChangesNo:
		m_bDisplayUI = FALSE;
		m_bSaveChanges = FALSE ;
		break ;
	case dsSaveChangesPrompt:
		m_bDisplayUI = TRUE ;
		break ;
	default:
		DsThrowShellOleDispatchException(DS_E_BAD_PARAM_VALUE) ;
	}
}

void CShellAutomationState::SetPromptState(const VARIANT FAR& vtBoolPrompt)
{
	// Reset State
	Reset() ;
	
	// Convert parameter to a bool.
	BOOL bPrompt;
	::ConvertVariantToBOOL(vtBoolPrompt, bPrompt, FALSE) ;

	// Set up state.
	if (bPrompt)
	{
		// Show UI.
		m_bDisplayUI = TRUE ;
	}
	else
	{
		// Don't show UI.
		m_bDisplayUI = FALSE;
	}

}

//
// Throws exceptions if the automation state has an error.
//
HRESULT CShellAutomationState::HandleError()
{
	// Get the error.
	HRESULT hr = GetError() ;

	// Set the automation state to default.
	Reset() ; 

	// Handle the errors.
	if (FAILED(hr))
	{
		// There was an error reported.
		DsThrowShellOleDispatchException(hr) ;		
	}

	// Return success codes.
	return hr ;
}

//
//
//
DsSaveStatus CShellAutomationState::SavePromptResult()
{
	return m_bSavePromptCanceled ? dsSaveCanceled : dsSaveSucceeded; 
}

//
// Global automation state object
//
CShellAutomationState g_AutomationState ;

//
// Global Pointer Used by Packages.
//
extern AFX_EXT_DATADEF IDsAutomationState* g_pAutomationState = &g_AutomationState ;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autosave.cpp ===
#include "stdafx.h"

#include "resource.h"

CAutosave AFX_EXT_DATADEF gAutosaver;


/* Private Data *************************************************************/

static CString gstrAutosaveSubdir = "$AUTSAV$";
static CString gstrUntitledSubdir = "$UNTTLD$";	
static BOOL fHaveUntitledDir = FALSE;

/* Private Methods **********************************************************/

void
CAutosave::GetUntitledDir()
{
	CPath pathModule;
	char szModuleFileName[MAX_PATH];
    
// Create the untitled autosave directory.
    
	GetModuleFileName(NULL, szModuleFileName, MAX_PATH);
	pathModule.Create(szModuleFileName);
	m_dirUntitled.CreateFromPath(pathModule);
	m_dirUntitled.AppendSubdirName(gstrUntitledSubdir);
	if (m_dirUntitled.CreateOnDisk() && SetFileAttributes((char *)(const char *)m_dirUntitled, FILE_ATTRIBUTE_HIDDEN))
		fHaveUntitledDir = TRUE;
}

/* Public Methods ***********************************************************/

CAutosave::CAutosave()
{ 
	m_fEnabled = FALSE; 
	m_nSaveInterval = 30; 
	m_hWndTimerOwner = NULL;
}

CAutosave::~CAutosave()
{
// Remove the untitled autosave directory when we bring down the SUSHI 
// session.  It is pefectly acceptable for this call to fail -- the 
// directory may not be empty.

	m_dirUntitled.RemoveFromDisk();	
	return;
}

BOOL
CAutosave::Enable(
	UINT nSaveInterval)
{
	if (m_hWndTimerOwner == NULL)
	{
		TRACE("Can't enable autosaver - no timer window owner!\n");
		return FALSE;
	}

// If the Autosaver is currently enabled, then they're asking us to reset
// the save interval.

	if (m_fEnabled)
	{
		if (nSaveInterval == m_nSaveInterval)
			return(TRUE);
		VERIFY(KillTimer(m_hWndTimerOwner, m_nTimerID));
		m_fEnabled = FALSE;
	}

// make sure the timer interval is valid
	if (!nSaveInterval)
	{
		TRACE("Autosave timer interval invalid--not set.\n");
		return(FALSE);
	}

// Start a new timer for the autosaver.

	m_nTimerID = SetTimer(m_hWndTimerOwner, IDT_AUTOSAVE,
						  60000*nSaveInterval, NULL);
	if (m_nTimerID == 0)
	{
		TRACE("Unable to install autosave timer.\n");
		return(FALSE);
	}

// Everything's kosher.  Make sure we have directory for untitled files.

	if (!fHaveUntitledDir)
		GetUntitledDir();

	TRACE("Autosaver enabled.\n");
	m_nSaveInterval = nSaveInterval;
	m_fEnabled = TRUE;
	m_fInTick = FALSE;
	return(TRUE);
}

BOOL 
CAutosave::Disable()
{
	if (!m_fEnabled)
		return(TRUE);
	else if (KillTimer(m_hWndTimerOwner, m_nTimerID))
	{
		m_fEnabled = FALSE;
		return(TRUE);
	}
	else
		return(FALSE);
}

BOOL 
CAutosave::GetAutosaveName(
	BOOL fUntitledDoc,
	const CPath &pathDirtyFile,				
	CPath &pathAutosave,
	enum DirAction fCreateDir)
{
	CDir dirDirtyFile;
	CDir dirAutosave;

	dirDirtyFile.CreateFromPath(pathDirtyFile);

// For titled documents, the autosave directory is off the document's directory.
// For untitled documents, the autosave path is off VCPP.DLL's directory.
 
	if (!fUntitledDoc)
	{
		//struct _stat statDir;

	// Make sure that an autosave subdirectory exists, & create
	// a CDir object for it.

		dirAutosave = dirDirtyFile;
		dirAutosave.AppendSubdirName(gstrAutosaveSubdir);
		
		if (lstrlen(dirAutosave) > MAX_PATH)
		{
			m_ErrorStatus = fCreateDir ? PathTooLong : NoSubdirectory;
			return FALSE;
		}
		
        if (!dirAutosave.ExistsOnDisk())
			if (fCreateDir)
			{
				if (!dirAutosave.CreateOnDisk())
				{
					m_ErrorStatus = CantMakeSubdirectory;
					return FALSE;
				}
				VERIFY(SetFileAttributes((char *)(const char *)dirAutosave, 
										 FILE_ATTRIBUTE_HIDDEN));
			}
			else
			{
				m_ErrorStatus = NoSubdirectory;
				return FALSE;
			}
		/*			
		else
			if (!statDir.st_mode & _S_IFDIR)  
			{
				m_ErrorStatus = CantMakeSubdirectory;
				return FALSE;
			} */
	}
	else
		dirAutosave = m_dirUntitled;

	if (!pathAutosave.CreateFromDirAndFilename(dirAutosave, 
										  pathDirtyFile.GetFileName()))
	{
		m_ErrorStatus = PathTooLong;
		return FALSE;
	}

	m_ErrorStatus = Success;
	return TRUE;
}

BOOL
CAutosave::RecoverAutosaveFileCheck(
	const CPath &pathUserFile)
{
	CPath pathAutosave;
	CDir dirAutosave;

	if (!AutosaveFileExists(pathUserFile, pathAutosave))
		return(TRUE);

	DWORD dwAttribs = 0;

	if (pathUserFile.ExistsOnDisk()) 
		VERIFY((dwAttribs = GetFileAttributes((char *)(const char *)pathUserFile)) != -1);

	// dolphin 4693 [patbr]
	// handling of available autosave file when source file being opened is read-only was inadequate.
	// rather than simply reword the message, we now handle the read-only source file same as writable
	// file, except that we use different message to let user know that he is overwriting read-only file.
	if (dwAttribs & FILE_ATTRIBUTE_READONLY)
	{
		switch (QuestionBox(IDS_AUTOSAVE_READONLY, MB_YESNOCANCEL, (const char *)pathUserFile, (const char *)pathUserFile))
		{
			case IDYES:
				VERIFY(SetFileAttributes((char *)(const char *)pathUserFile, FILE_ATTRIBUTE_NORMAL));
				VERIFY(CopyFile((char *)(const char *)pathAutosave, (char *)(const char *)pathUserFile, FALSE));
				return(TRUE);

			case IDNO:
				VERIFY(SetFileAttributes((char *)(const char *)pathAutosave, FILE_ATTRIBUTE_NORMAL));
				pathAutosave.DeleteFromDisk();
				dirAutosave.CreateFromPath(pathAutosave);
				dirAutosave.RemoveFromDisk();
				return(TRUE);

			default:
				return(FALSE);
		}
	}
	else
	{
		switch (QuestionBox(IDS_AUTOSAVE_DETECTED_BACKUP, MB_YESNOCANCEL, (const char *)pathUserFile, (const char *)pathUserFile)) 					
		{
			case IDYES:
				VERIFY(CopyFile((char *)(const char *)pathAutosave, (char *)(const char *)pathUserFile, FALSE));
				return(TRUE);

			case IDNO:
				VERIFY(SetFileAttributes((char *)(const char *)pathAutosave, FILE_ATTRIBUTE_NORMAL));
				pathAutosave.DeleteFromDisk();
				dirAutosave.CreateFromPath(pathAutosave);
				dirAutosave.RemoveFromDisk();
				return(TRUE);

			default:
				return(FALSE);
		}
	}
	return TRUE;
}

void
CAutosave::RemoveAutosaveFile(
	BOOL fUntitled,
	const CPath &pathUserFile)
{
// Clobber an existing autosave file -- even if it is read-only.

	CPath pathAutosave;

	VERIFY(GetAutosaveName(fUntitled, pathUserFile, pathAutosave, DontCreateDir)
		 	|| m_ErrorStatus == NoSubdirectory);

	if (m_ErrorStatus == NoSubdirectory)
		return;	 // No directory => No file to remove.				 	

	if (pathAutosave.ExistsOnDisk())
	{
		VERIFY(SetFileAttributes((char *)(const char *)pathAutosave, 
								 FILE_ATTRIBUTE_NORMAL));
		pathAutosave.DeleteFromDisk();
	}

// Attempt to remove the autosave directory.  This will fail if we can't do it.

	if (!fUntitled)
	{	
		CDir dirAutosave;
		dirAutosave.CreateFromPath(pathAutosave);
		dirAutosave.RemoveFromDisk();
	}

// Outta here.

	return;
}

BOOL
CAutosave::AutosaveFileExists(
	const CPath &pathUserFile, 
	CPath &pathAutosave)
{
	VERIFY(GetAutosaveName(FALSE, pathUserFile, pathAutosave, DontCreateDir)
		 	|| m_ErrorStatus == NoSubdirectory);
	
	if (m_ErrorStatus != NoSubdirectory)
	{
		return (pathAutosave.ExistsOnDisk());
	}
	else
		return FALSE;
}

void
CAutosave::ExitTick()
{
	ASSERT(m_fInTick);
	m_fInTick = FALSE;
	while (!m_pathlistErrors.IsEmpty())
	{
		CString str;
		CPath *ppathErrEntry = (CPath *)m_pathlistErrors.RemoveHead();
		MsgBox(Error, MsgText(str, IDS_AUTOSAVE_ERROR, (const char *)*ppathErrEntry));
		delete ppathErrEntry;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autowind.h ===
// AutoWindowDefault.h : header file
//

#include <utilauto.h>

#define _DUAL_


class CPartFrame;

/////////////////////////////////////////////////////////////////////////////
// CAutoWindowDefault command target

class CAutoWindowDefault : public CAutoWindowObj
{
	DECLARE_DYNAMIC(CAutoWindowDefault)

	CAutoWindowDefault(CPartFrame* pFrame);           // protected constructor used by dynamic creation

// Attributes
public:
	CPartFrame* m_pAssociatedPartFrame ;

	void NoFrame() ;

// Operations
public:
#ifdef _DUAL_
  DECLARE_DUAL_ERRORINFO()
#endif

// Overrides

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutoWindowDefault)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

	// CPartFrame calls this so we NULL m_pAssociatedPartFrame.
	void AssociatedObjectReleased();

// Implementation
protected:
	#ifdef _DUAL_
	DS_BEGIN_DUAL_INTERFACE_PART(GenericWindow)
		STDMETHOD(get_Caption)(THIS_ BSTR FAR* pbstrCaption) ;
		STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrCaption) ;
		STDMETHOD(put_Active)(THIS_ VARIANT_BOOL bActive) ;
		STDMETHOD(get_Active)(THIS_ VARIANT_BOOL FAR* pbActive) ;
		STDMETHOD(put_Left)(THIS_ long lVal) ;
		STDMETHOD(get_Left)(THIS_ long FAR* plVal) ;
		STDMETHOD(put_Top)(THIS_ long lVal) ;
		STDMETHOD(get_Top)(THIS_ long FAR* plVal) ;
		STDMETHOD(put_Height)(THIS_ long lVal) ;
		STDMETHOD(get_Height)(THIS_ long FAR* plVal) ;
		STDMETHOD(put_Width)(THIS_ long lVal) ;
		STDMETHOD(get_Width)(THIS_ long FAR* plVal) ;
		STDMETHOD(get_Index)(THIS_ long FAR* plVal) ;
		STDMETHOD(get_Next)(THIS_ IDispatch * FAR* ppDispatch) ;
		STDMETHOD(get_Previous)(THIS_ IDispatch * FAR* ppDispatch) ;
		STDMETHOD(put_WindowState)(THIS_ DsWindowState lVal) ;
		STDMETHOD(get_WindowState)(THIS_ DsWindowState FAR* plVal) ;
		STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDispatch) ;
		STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDispatch) ;
		STDMETHOD(Close)(THIS_ VARIANT vtSaveChanges, DsSaveStatus FAR* pSaved) ;
		DS_DECLARE_VTBL_PAD_10()
	DS_END_DUAL_INTERFACE_PART(GenericWindow)

	DS_DECLARE_ENABLE_DUAL(CAutoWindowDefault, GenericWindow)
#endif

	virtual ~CAutoWindowDefault();

	// Generated message map functions
	//{{AFX_MSG(CAutoWindowDefault)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

/* dualimpl.doc
	DECLARE_OLECREATE(CAutoWindowDefault)
*/

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CAutoWindowDefault)
	afx_msg BSTR GetCaption();
	afx_msg LPDISPATCH GetParent() ;
	afx_msg LPDISPATCH GetApplication() ;
	afx_msg BSTR GetType();
	afx_msg BOOL GetActive();
	afx_msg void SetActive(BOOL bNewValue);
	afx_msg long GetLeft();
	afx_msg long GetTop();
	afx_msg long GetHeight();
	afx_msg long GetWidth();
	afx_msg long GetIndex();
	afx_msg LPDISPATCH GetNext();
	afx_msg LPDISPATCH GetPrevious();
	afx_msg DsWindowState GetWindowState();
	afx_msg void SetWindowState(DsWindowState nNewValue);
	afx_msg void SetLeft(long nNewValue);
	afx_msg void SetTop(long nNewValue);
	afx_msg void SetHeight(long nNewValue);
	afx_msg void SetWidth(long nNewValue);
	afx_msg DsSaveStatus Close(const VARIANT FAR& boolSaveChanges);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\autowins.cpp ===
// AutoWins.cpp : implementation file
//

#include "stdafx.h"
#include <utilauto.h>
#include "autoguid.h"
#include "resource.h"

#include "autostat.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Implementation of CAutoWindows' dual interface
DELEGATE_GET(CAutoWindows, Windows, Count, long)
DELEGATE_GET(CAutoWindows, Windows, Application, IDispatch*)
DELEGATE_GET(CAutoWindows, Windows, Parent, IDispatch*)

DELEGATE_ONE_PARAM(CAutoWindows, Windows, Arrange, VARIANT)
DELEGATE_ONE_PARAM_WITH_RETVAL(CAutoWindows, Windows, CloseAll, VARIANT, DsSaveStatus)


STDMETHODIMP CAutoWindows::XWindows::get__NewEnum(IUnknown** _NewEnum)
{
	METHOD_PROLOGUE(CAutoWindows, Dispatch)
	
	TRY_DUAL(IID_IWindows)
	{
		*_NewEnum = pThis->_NewEnum();
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


STDMETHODIMP CAutoWindows::XWindows::Item(VARIANT index, IDispatch* FAR* Item)
{
	METHOD_PROLOGUE(CAutoWindows, Dispatch)
	
	TRY_DUAL(IID_IWindows)
	{
		*Item = pThis->Item(index);
		return NOERROR;
	}
	CATCH_ALL_DUAL
}


/////////////////////////////////////////////////////////////////////////////
// CAutoWindows

//IMPLEMENT_DYNCREATE(CAutoWindows, CAutoObj)
IMPLEMENT_DYNAMIC(CAutoWindows, CAutoObj)

CAutoWindows::CAutoWindows(CPartDoc* pOwnerDoc)
{
//	EnableAutomation();
	EnableDualAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
	AfxOleLockApp();
	
	// CAutoWindows has two modes: Either it is owned by a document
	// or it has all MDI windows in it. 
	// If m_pOwnerDoc is NULL, we will work with the entire MDI space.
	// If m_pOwnerDoc is non-NULL, it points to a document whose windows we will use.
	m_pOwnerDoc = pOwnerDoc ;

	// We do not need to do a Sync here, because the first
	// time that someone gets the item will sync.
	m_pPtrlData = NULL ;
}


CAutoWindows::~CAutoWindows()
{
	DeleteCollection() ; //@sync

	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

//
// Delete the contents of the collection. [@sync]
//
void CAutoWindows::DeleteCollection()
{	
	if (m_pPtrlData != NULL)
	{
		POSITION pos = m_pPtrlData->GetHeadPosition();
		while (pos != NULL)
		{
			IDispatch* pDispatch = m_pPtrlData->GetNext(pos);
			ASSERT (pDispatch != NULL);
			pDispatch->Release() ;
		}

		// The collection is in charge of cleaning this up.
		delete m_pPtrlData ;

		m_pPtrlData = NULL ; 
	}
}

void CAutoWindows::OnFinalRelease()
{

	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CAutoObj::OnFinalRelease();
}

//
// This function is used to keep the internal pointer list in
// sync with the real world.
//
void CAutoWindows::Sync()
{
	// Fill a pointer list with IDispatch* for each document.
	CDispatchList* pDispatchPtrList = new CDispatchList;

	if (m_pOwnerDoc == NULL)
	{
		// This code originated in COpenDocsDlg (opendocs.h|cpp)

		// get a pointer to the main frame
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

		// This code is similar to the Arrange code in the Windows object.

		CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
		if (pMDIActiveChild != NULL)
		{
			CPartFrame* pMDIChild =(CPartFrame *)pMDIActiveChild->GetWindow(GW_HWNDFIRST);
			while( pMDIChild != NULL)
			{
				if(IsValidMDICycleMember(pMDIChild))
				{
					// Get the automation object for this document.
					IDispatch* pDispatch = pMDIChild->GetAutomationObject(TRUE) ;
					if (pDispatch != NULL)
					{
						pDispatchPtrList->AddTail(pDispatch);
					}
				}

				// Get the next window.
				pMDIChild = (CPartFrame *)pMDIChild->GetWindow(GW_HWNDNEXT);
			}
		}
	}
	else
	{
		// Get all of the windows associated with the owner document.
		POSITION pos = m_pOwnerDoc->GetFirstViewPosition();
		while (pos != NULL)
		{
			CPartView *pView = static_cast<CPartView*>(m_pOwnerDoc->GetNextView(pos));
			ASSERT(pView);
			ASSERT_KINDOF(CPartView, pView) ;

			if (pView) // defensive code
			{
				CPartFrame* pFrame = static_cast<CPartFrame*>(pView->GetParentFrame());
				ASSERT(pFrame);
				ASSERT_KINDOF(CPartFrame, pFrame) ;
				if (pFrame) // defensive code
				{
					IDispatch* pDispatch = pFrame->GetAutomationObject(TRUE) ;
					if (pDispatch != NULL)
					{
						pDispatchPtrList ->AddTail(pDispatch);
					}
				}
			}
		}
	}

	// If there is already a collection, delete it.
	DeleteCollection() ;

	// Assign the new pointer.
	m_pPtrlData = pDispatchPtrList ;
}



BEGIN_MESSAGE_MAP(CAutoWindows, CAutoObj)
	//{{AFX_MSG_MAP(CAutoWindows)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CAutoWindows, CAutoObj)
	//{{AFX_DISPATCH_MAP(CAutoWindows)
	DISP_PROPERTY_EX(CAutoWindows, "Count", GetCount, SetNotSupported, VT_I4)
	DISP_PROPERTY_EX(CAutoWindows, "Application", GetApplication, SetNotSupported, VT_DISPATCH)
	DISP_PROPERTY_EX(CAutoWindows, "Parent", GetParent, SetNotSupported, VT_DISPATCH)
	DISP_FUNCTION(CAutoWindows, "Item", Item, VT_DISPATCH, VTS_VARIANT)
	DISP_FUNCTION(CAutoWindows, "Arrange", Arrange, VT_EMPTY, VTS_VARIANT)
	DISP_FUNCTION(CAutoWindows, "CloseAll", CloseAll, VT_I4, VTS_VARIANT)
	DISP_DEFVALUE(CAutoWindows, "Item")
	//}}AFX_DISPATCH_MAP
	DISP_PROPERTY_EX_ID(CAutoWindows, "_NewEnum", DISPID_NEWENUM, _NewEnum, SetNotSupported, VT_UNKNOWN)
	// Not In Spec DISP_FUNCTION(CAutoWindows, "Add", Add, VT_DISPATCH, VTS_PBSTR)
END_DISPATCH_MAP()

/* REMOVED see DualImpl.doc
// Note: we add support for IID_IWindows to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {5774D191-96E1-11CF-9C00-00A0C90A632C}
static const IID IID_IWindows =
{ 0x5774d191, 0x96e1, 0x11cf, { 0x9c, 0x0, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c } };
*/

BEGIN_INTERFACE_MAP(CAutoWindows, CAutoObj)
	INTERFACE_PART(CAutoWindows, IID_IDispWindows, Dispatch)
	INTERFACE_PART(CAutoWindows, IID_IWindows, Dispatch)
    DUAL_ERRORINFO_PART(CAutoWindows)
END_INTERFACE_MAP()

// Implement ISupportErrorInfo to indicate we support the 
// OLE Automation error handler.
IMPLEMENT_DUAL_ERRORINFO(CAutoWindows, IID_IWindows)
DS_IMPLEMENT_ENABLE_DUAL(CAutoWindows, Windows)
DS_DELEGATE_DUAL_INTERFACE(CAutoWindows, Windows)

/* See DualImpl.doc
// {5774D192-96E1-11CF-9C00-00A0C90A632C}
IMPLEMENT_OLECREATE(CAutoWindows, "VSHELL7.AUTOWINDOWS", 0x5774d192, 0x96e1, 0x11cf, 0x9c, 0x0, 0x0, 0xa0, 0xc9, 0xa, 0x63, 0x2c)
*/

/////////////////////////////////////////////////////////////////////////////
// CAutoWindows message handlers
long CAutoWindows::GetCount() 
{
	Sync() ;

	return m_pPtrlData->GetCount();
}

LPUNKNOWN CAutoWindows::_NewEnum() 
{
	Sync() ;

	CEnumVariantObjs* pEnumVariant = new CEnumVariantObjs(m_pPtrlData);
	
	if (pEnumVariant == NULL)
		DsThrowCannedOleDispatchException(E_OUTOFMEMORY);

	// We don't QueryInterface, since we don't want the IEnumVARIANT
	//  AddRef'd.  The "new CEnumVariantObjs" above already AddRefs it for
	//  us.
	return &pEnumVariant->m_xEnumVariant;
}


// This function takes the number index or a string 
// representing the caption.
// We decided not to take the Type of the window since this
// wasn't generally useful.
LPDISPATCH CAutoWindows::Item(const VARIANT FAR& vtIndex) 
{
	Sync() ;

	BOOL bHaveValidIndex = FALSE ;
	long lIndex ;

	// Covert the vtIndex to a string representing the caption.
	CString strCaptionWanted;
	CString strDefault("") ;
	HRESULT hr = ::ConvertVariantToCString(vtIndex, strCaptionWanted, strDefault, FALSE ) ;
	if (hr == S_FALSE)
	{
		// Parameter is optional and is not supplied, so use the default.
		// Return a pointer to this collection.
		return GetIDispatch(TRUE) ;
	}
	else if (hr == S_OK)
	{
		CString strCaption ;
		// Iterate through the windows in this collection, and return
		//  the first one we find with this type
		POSITION pos = m_pPtrlData->GetHeadPosition();
		while (pos != NULL)
		{
			LPDISPATCH pDispWnd = m_pPtrlData->GetNext(pos);
			IGenericWindow* pIWindow = NULL;
			VERIFY(SUCCEEDED(pDispWnd->QueryInterface(IID_IGenericWindow, (void**) &pIWindow)));
			if (pIWindow == NULL)
			{
				ASSERT (FALSE);
				continue;
			}
			// Get the caption.
			BSTR bszCaption;
			VERIFY(SUCCEEDED(pIWindow->get_Caption(&bszCaption)));
			
			// Convert to a CString
			strCaption = bszCaption ;

			// Free bstr
			::SysFreeString(bszCaption);

			// remove change indicators (" *") from the captions
			CAutoWindowObj::RemoveChangeIndicatorFromWindowCaption(strCaptionWanted);
			CAutoWindowObj::RemoveChangeIndicatorFromWindowCaption(strCaption);

			// Compare
			if (strCaptionWanted.CompareNoCase(strCaption) == 0)
			{
				// Found a match!
				return pIWindow;		// No need to AddRef, since QueryInterface did that for us
			}

			// Release interface and goto next one.
			pIWindow->Release();
		}
	}

	// Converting to a BSTR failed or the filename didn't exist.
	// So attempt converting to an index.
	hr = ::ConvertVariantToLong(vtIndex, lIndex, 0, FALSE) ;
	if (hr == S_FALSE || lIndex == 0)
	{
		// 0 is an illegal value.
		DsThrowShellOleDispatchException(DS_E_CANNOT_FIND_WINDOW) ;
	}

	// Get item from array
	IDispatch* pObj = NULL ;
    POSITION pos = m_pPtrlData->FindIndex(lIndex-1);
    if (pos != NULL)
	{
        pObj = m_pPtrlData->GetAt(pos);
		ASSERT (pObj != NULL);
	}
	else
	{
		DsThrowShellOleDispatchException(DS_E_CANNOT_FIND_WINDOW) ;
	}
    
	ASSERT (pObj != NULL);
	pObj->AddRef();
	return pObj ;
}

LPDISPATCH CAutoWindows::GetApplication() 
{

	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}



LPDISPATCH CAutoWindows::GetParent() 
{
	ASSERT(theApp.m_pAutoApp != NULL) ;
    return theApp.m_pAutoApp->GetIDispatch(TRUE);
}


DsSaveStatus CAutoWindows::CloseAll(const VARIANT FAR& vtLongSaveChanges) 
{

	// Do we close all MDI windows or just those actually in the collection.
	if (m_pOwnerDoc == NULL) 
	{
		// Convert the variant into a valid automation state.
		g_AutomationState.SaveChanges(vtLongSaveChanges);
		
		// get a pointer to the main frame
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

		// Attempt to close all windows
		pMainFrame->OnWindowCloseAll() ;

		// Return if the save was canceled. (HandleError resets status.)
		DsSaveStatus status = g_AutomationState.SavePromptResult() ;		

		// Handle errors caught by the automation state. Cleans up the state.
		g_AutomationState.HandleError() ;

		// Return if the save was canceled.
		return status ;
	}
	else
	{
		Sync() ;

		// Iterate through the windows in this collection, and 
		//  close them.
		POSITION pos = m_pPtrlData->GetHeadPosition();
		while (pos != NULL)
		{
			LPDISPATCH pDispWnd = m_pPtrlData->GetNext(pos);

			// Get the window interface.
			IGenericWindow* pWindow = NULL;
			VERIFY(SUCCEEDED(pDispWnd->QueryInterface(IID_IGenericWindow, (void**) &pWindow)));
			if (pWindow == NULL)
			{
				ASSERT (FALSE);
				continue;
			}
			
			// Close the window.
			DsSaveStatus saveStatus ;
			VERIFY(SUCCEEDED(pWindow->Close(vtLongSaveChanges, &saveStatus))) ;
			pWindow->Release() ;
			if (saveStatus == dsSaveCanceled)
			{
				return dsSaveCanceled ;
			}
		}
		return dsSaveSucceeded ;
	}
} 

//
// This helper function minimizes all MDI child windows.
//
void MinimizeAllMDI()
{ 
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));
	
	CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
	if (pMDIActiveChild != NULL)
	{
		CPartFrame* pMDIChild =(CPartFrame *)pMDIActiveChild->GetWindow(GW_HWNDFIRST);
		while( pMDIChild != NULL)
		{
			//if(!IsValidMDICycleMember(pMDIChild))
			CPartFrame* pTemp = (CPartFrame *)pMDIChild->GetWindow(GW_HWNDNEXT);
			pMDIChild->ShowWindow(SW_MINIMIZE ) ;
			pMDIChild = pTemp ;
		}
	}
}
//
//
//
void CAutoWindows::Arrange(const VARIANT FAR& vtArrangeStyle)
{
	BOOL bDone = FALSE ;
	
	// Convert VARIANT To a long
	const long lDefault = dsTileHorizontal;
	long lIndex ;
	::ConvertVariantToLong(vtArrangeStyle, lIndex, lDefault) ;

	// Catch the bad values.
	switch(lIndex)
	{
	// Iconify all of the windows
	case dsMinimize:
	case dsCascade:
	case dsTileVertical:
	case dsTileHorizontal:
		break ;
	default:
		::DsThrowCannedOleDispatchException(E_INVALIDARG);
		break ;
	}

	// get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT(pMainFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));
	CMDIChildWnd* pMdiChild = pMainFrame->MDIGetActive() ;
	if (pMdiChild == NULL)
	{
		//There is no one to arrange
		return ;
	}
	CWnd* pMdiClient = pMdiChild->GetParent() ;
	ASSERT(pMdiClient != NULL) ;

	if (m_pOwnerDoc != NULL)
	{
		Sync() ;

		// We only want to Arrange the windows inside the collection. 
		// The easiest way to do this is to minimize everybody,
		// restore our windows, then do the function.
		// This applies to everything, but minimization.
		// If we are minimizing, we just minimize the windows and get out.


		// Turn off drawing...

		pMdiClient->SetRedraw(FALSE) ;


		if (lIndex != dsMinimize)
		{
			// Minimize Everybody - only if we are not minimizing
			MinimizeAllMDI() ;
		}

		// Restore our windows.
		POSITION pos = m_pPtrlData->GetHeadPosition();
		while (pos != NULL)
		{
			LPDISPATCH pDispWnd = m_pPtrlData->GetNext(pos);

			// Get the window interface.
			IGenericWindow* pIWindow = NULL;
			VERIFY(SUCCEEDED(pDispWnd->QueryInterface(IID_IGenericWindow, (void**) &pIWindow)));
			if (pIWindow == NULL)
			{
				ASSERT (FALSE);
				continue;
			}

			// Restore the window unless we are minimizing.
			HRESULT hr = pIWindow->put_WindowState((lIndex == dsMinimize) ? dsWindowStateMinimized  : dsWindowStateNormal) ;
			if (FAILED(hr))
			{
				::DsThrowCannedOleDispatchException(hr);
			}
		}

		// If we are minimizing we are done.
		if (lIndex == dsMinimize)
		{
			bDone = TRUE ;
		}
	}

	// Now is the time to actually arrange the windows.
	// If we are working on the entire MDI space, we have not done anything
	// yet. However, if we are only working on the subset of windows in the
	// collection, we have minimized everything else.

	if (!bDone)
	{
		switch(lIndex)
		{
		// Iconify all of the windows
		case dsMinimize:
			ASSERT(m_pOwnerDoc == NULL) ;
			MinimizeAllMDI() ;
			break ;
		// Cascade all of the windows.
		case dsCascade:
			pMainFrame->MDICascade() ;
			break ;

		// Tile the winows vertically
		case dsTileVertical:
			pMainFrame->MDITile(MDITILE_VERTICAL) ;
			break ;

		// Tile the windows horizontally. (This is the default.)
		case dsTileHorizontal:
			pMainFrame->MDITile(MDITILE_HORIZONTAL) ;
			break ;
		default:
			ASSERT(0) ;
		}
	}

	if (m_pOwnerDoc != NULL)
	{
		//Turn Redraw back on and update window.
		pMdiClient->SetRedraw(TRUE) ;

		CRect rectMdiClient ;
		pMdiClient->GetWindowRect(&rectMdiClient) ;
		::InvalidateRect(NULL, rectMdiClient, TRUE) ;
	}
}

/* Not in spec
LPDISPATCH CAutoWindows::Add(BSTR FAR* docType) 
{
	// TODO: Add your dispatch handler code here
	DsThrowCannedOleDispatchException(E_NOTIMPL);

	return NULL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barbdr.h ===
///////////////////////////////////////////////////////////////////////////////
//	BDRBAR.H
//      Contains declarations relavant to CBorderBar.
///////////////////////////////////////////////////////////////////////////////

#ifndef __BDRBAR_H__
#define __BDRBAR_H__

class CDockManager;

/////////////////////////////////////////////////////////////////////////////
// CBorderBar window

class CBorderBar : public CWnd
{
// Construction
public:
	CBorderBar();
	virtual ~CBorderBar();
	
	BOOL Create(CWnd* pParent, CDockManager* pManager, DWORD dwStyle,
		HWND hwndChild, UINT nID, BOOL bRegister = FALSE, DOCKINIT FAR* lpdi = NULL);

	void RecalcLayout();

// Attributes
public:
	UINT m_nID;
	int m_cxLeftBorder, m_cxRightBorder;
	int m_cyTopBorder, m_cyBottomBorder;

	BOOL m_bCaption:1;
	BOOL m_bHorz:1;
	BOOL m_bBtnClose:1;
	BOOL m_bBtnMax:1;
	BOOL m_bBtnPushed:1;

	int m_nBtnCapture;
	
// Operations
public:

	// Generated message map functions
protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();
	virtual int OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	
	//{{AFX_MSG(CBorderBar)
	afx_msg void OnNcPaint();
	afx_msg UINT OnNcHitTest(CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	afx_msg LRESULT OnRouteChildMessage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnEnableChild(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetMinMaxInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetMoveSize(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetTrackSize(WPARAM wParam, LPARAM lParam);

	LRESULT OnSizeMessage(UINT message, DOCKPOS dp,
		WPARAM wParam, LPARAM lParam);

	enum
	{
		BUTTON_NIL = -1,
		BUTTON_CLOSE = 0,
		BUTTON_MAX,
	};

	int InCaptionButtonRect(CPoint point) const;
	void GetCaptionButtonRect(int nType, CRect& rectButton) const;
	void DrawCaptionButton(int nType, CDC* pdc, BOOL bPushed);
	
	DECLARE_MESSAGE_MAP()
    DECLARE_DYNAMIC(CBorderBar)
};

#endif	// __BDRBAR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barchoic.h ===
///////////////////////////////////////////////////////////////////////////////
//	BARCHOIC.H
//      See description in barchoic.cpp
///////////////////////////////////////////////////////////////////////////////

#ifndef __BARCHOIC_H__
#define __BARCHOIC_H__

#ifndef __BARCUST_H__
#include "barcust.h"
#endif

//	class CToolBar;
//		class CCustomBar;
			class CChoiceBar;

/////////////////////////////////////////////////////////////////////////////
// CChoiceBar window

class CToolCustomizer;

class CChoiceBar : public CCustomBar
{
public:
	CToolCustomizer* m_pCustomizer;
    CObArray m_aUsage;

	CChoiceBar();
	~CChoiceBar();

// Construction.	
public:

	virtual ORIENTATION GetOrient() const;
// Operations.
public:
	CToolCustomizer* GetCustomizer();
	void SetCustomizer(CToolCustomizer *);

// Message map functions.
protected:
    //{{AFX_MSG(CChoiceBar)
	//}}AFX_MSG

	DECLARE_DYNAMIC(CChoiceBar)

#ifdef _DEBUG
public:
	void AssertValid() const;
#endif
};

#endif	// __BARCHOIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barchoic.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  BARCHOIC.CPP
//      Implements CChoiceBar, the choose a button bar class.

// This subclass is requred because the choose button dialog box contains a CCustomBar which does not wish to
// share its customizer with the other CASBars (because we want to display one selected toolbar button at the same
// time as allowing selection changes within the choose button dialog).

// This subclass also ensures that the embedded bar has a default orientation of orNil, to avoid grabbers being drawn in
// the dialog.
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "barchoic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//	CChoiceBar
//		Derived from CCustomBar, provides a bar with a unique customiser

IMPLEMENT_DYNAMIC(CChoiceBar, CCustomBar)

//	CChoiceBar::CChoiceBar
CChoiceBar::CChoiceBar()           
{
	// this bar has a private customizer
	m_pCustomizer=NULL;
}

//	CChoiceBar::~CChoiceBar
CChoiceBar::~CChoiceBar()
{
}

CToolCustomizer *CChoiceBar::GetCustomizer()
{
	return m_pCustomizer;
}

void CChoiceBar::SetCustomizer(CToolCustomizer *theCustomizer)
{
	m_pCustomizer=theCustomizer;
}

ORIENTATION CChoiceBar::GetOrient() const 
{
	return orNil;
}

#ifdef _DEBUG
void CChoiceBar::AssertValid() const
{
	// deliberate skipping of base class, because we changed the assumptions... 
	CWnd::AssertValid();

	ASSERT(m_nCount == 0 || m_pData != NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barbdr.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  BDRBAR.CPP
//      Contains implementations for CBorderBar.
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "shell.h"
#include "barbdr.h"
#include "barglob.h"
#include "util.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//	CBorderBar
//		Class for wrapping a single window with a border area when docked
//		so that it sort of looks like a toolbar for one window.  The border,
//		however, disappears when the window is floating.
//

#ifdef _DEBUG
extern BOOL bChicagoLookOnNT;
inline BOOL OnChicago() { return theApp.m_bWin4 || bChicagoLookOnNT; }
#else
inline BOOL OnChicago() { return theApp.m_bWin4; }
#endif

// Buttons larger than this value will be drawn with different drawing code.
const int cLargeCaptionButtonThreshold=8;

//	CBorderBar::CBorderBar
//		Constructor.

CBorderBar::CBorderBar()
{
	m_cyTopBorder = m_cyBottomBorder = g_mt.cyToolBorder;
	m_cxLeftBorder = m_cxRightBorder = g_mt.cxToolBorder;

	m_bCaption = FALSE;
	m_bHorz = FALSE;
	m_bBtnClose = FALSE;
	m_bBtnMax = FALSE;

	m_nBtnCapture = BUTTON_NIL;
	m_bBtnPushed = FALSE;
}

CBorderBar::~CBorderBar()
{
}

//	CBorderBar::Create
//		Creates the window, puts the child in the window, and registers
//		with the docks when necessary.

BOOL CBorderBar::Create(CWnd* pParent, CDockManager* pManager, DWORD dwStyle,
	HWND hwndChild, UINT nID, BOOL bRegister /*=FALSE*/, DOCKINIT FAR* lpdi /*=NULL*/)
{
    // create the HWND
    CRect rect;
    rect.SetRectEmpty();	// Size later.
    
    if (pParent == NULL)
    	pParent = pManager->GetDock(dpHide);
    
	m_nID =	nID;
	ASSERT(LOWORD(m_nID) == ::GetDlgCtrlID(hwndChild));
    if (pParent == NULL || !CWnd::Create(AfxRegisterWndClass(CS_DBLCLKS,
            						::LoadCursor(NULL, IDC_ARROW),
            						(HBRUSH) (COLOR_BTNFACE + 1)),
            	"",
    			dwStyle | WS_CHILD | WS_BORDER | WS_CLIPCHILDREN,
    			rect,
    			pParent,
    			LOWORD(m_nID)))
	{
        return FALSE;
	}

    ::SetParent(hwndChild, GetSafeHwnd());
    ::ShowWindow(hwndChild, SW_SHOWNOACTIVATE);
    
	if (dwStyle & DWS_STRETCHY)
	{
		m_bBtnClose = m_bBtnMax = TRUE;
	}
	else
	{
		m_bBtnClose=TRUE;
		m_bBtnMax=FALSE;
	}

	EnableToolTips();

    if (bRegister)
    {
		if (pManager->RegisterWnd(this, lpdi) == NULL)
		{
	        DestroyWindow();
	        return FALSE;
		}

		// Only after registering do we have the correct dock position for
		// layout calcultation.

		RecalcLayout();
	}

    return TRUE;
}

void CBorderBar::RecalcLayout()
{
    CRect rect;
    CWnd* pChild;
	DOCKPOS dp;
    
    GetClientRect(rect);
    if ((pChild = GetTopWindow()) != NULL && (dp = DkWGetDock(m_nID)) != dpHide)
    {
    	if (dp == dpNil || dp == dpMDI)
		{
			m_bCaption = FALSE;
			if (!OnChicago())
        		rect.InflateRect(g_mt.cxBorder, g_mt.cyBorder);
		}
        else
        {
			m_bCaption = TRUE;
			if (dp == dpLeft || dp == dpRight)
			{
				m_bHorz = FALSE;
				m_cxLeftBorder = g_mt.cxToolBorder;
				m_cyTopBorder = g_mt.cyToolCaption + g_mt.cyToolCapBorder * 2;
			}
			else
			{
				m_bHorz = TRUE;
				m_cxLeftBorder = g_mt.cxToolCaption + g_mt.cxToolCapBorder * 2;
				m_cyTopBorder = g_mt.cyToolBorder;

				// If toolbar is visible, it provides the top border.
				// But, if it is vertically docked we need space for the
				// caption.

				CWnd* pBar = GetDescendantWindow(AFX_IDW_TOOLBAR);
				if (pBar != NULL && (pBar->GetStyle() & WS_VISIBLE) != 0)
					m_cyTopBorder -= g_mt.cyToolBorder;
			}

        	rect.left += m_cxLeftBorder;
        	rect.top += m_cyTopBorder;
        	rect.right -= m_cxRightBorder;
        	rect.bottom -= m_cyBottomBorder;
        }
		
		CRect rectCurrent;
		pChild->GetWindowRect(rectCurrent);
		ScreenToClient(rectCurrent);
        
		if (rect != rectCurrent)
		{
	        pChild->SetWindowPos(NULL, rect.left, rect.top,
	            rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
		}
    }
}

IMPLEMENT_DYNAMIC(CBorderBar, CWnd)

BEGIN_MESSAGE_MAP(CBorderBar, CWnd)
	//{{AFX_MSG_MAP(CBorderBar)
	ON_WM_NCPAINT()
	ON_WM_NCHITTEST()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_SETFOCUS()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_GETMINMAXINFO, OnGetMinMaxInfo)
	ON_REGISTERED_MESSAGE(DWM_GETMOVESIZE, OnGetMoveSize)
    ON_REGISTERED_MESSAGE(DWM_GETTRACKSIZE, OnGetTrackSize)
	ON_REGISTERED_MESSAGE(DWM_SHOWWINDOW, OnRouteChildMessage)
	ON_REGISTERED_MESSAGE(DWM_GETDATA, OnRouteChildMessage)
	ON_REGISTERED_MESSAGE(DWM_ENABLECHILD, OnEnableChild)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xffff, OnToolTipText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xffff, OnToolTipText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBorderBar message handlers

// Override to allow hwnd buttons to nominate an id for their tooltip, depending
// on their context
int CBorderBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	int nHit=InCaptionButtonRect(point);

	if(nHit!=BUTTON_NIL)
	{
		CRect btn;
		int nTip=0;
		GetCaptionButtonRect(nHit, btn);
		pTI->rect=btn;
		switch(nHit)
		{
			case BUTTON_CLOSE:
				nTip=IDS_DOCK_HIDE;
				break;

			case BUTTON_MAX:
				{
					MAX_STATE stateMax = DkWGetMaxState(m_nID);
					if (stateMax == stateMaximize ||
						stateMax == stateDisabled)
					{
						nTip=IDS_DOCK_EXPAND;
					}
					else
					{
						nTip=IDS_DOCK_CONTRACT;
					}
				}
				break;

			default: 
				ASSERT(FALSE);
		}
		pTI->uId = nHit;
		pTI->hwnd = m_hWnd;
		CString strTip;
		VERIFY(strTip.LoadString(nTip));
		// will be freed in tip code
		pTI->lpszText = _strdup(strTip);
	}
	else
	{
		nHit=-1;
	}


	return nHit;
}

//	CBorderBar::WindowProc
//		All dockable windows call DkPreHandle message.

LRESULT CBorderBar::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LONG lResult;

	if (DkPreHandleMessage(GetSafeHwnd(),
		message, wParam, lParam, &lResult))
		return lResult;

	return CWnd::WindowProc(message, wParam, lParam);
}

//	CBorderBar::OnCommand
//		Routes all commands to the window's owner.

BOOL CBorderBar::OnCommand(WPARAM wParam, LPARAM lParam)
{
    return !!GetParent()->SendMessage(WM_COMMAND, wParam, lParam);
}

//	CBorderBar::PostNcDestroy
//		Self deletion.

void CBorderBar::PostNcDestroy()
{
	delete this;
}

//	CBorderBar;:OnRouteChildMessage
//		For routing DWM_* from the dock manager to the child window.

LRESULT CBorderBar::OnRouteChildMessage(WPARAM wParam, LPARAM lParam)
{
	ASSERT(GetTopWindow() != NULL);
	return	GetTopWindow()->SendMessage(GetCurrentMessage()->message,
		wParam, lParam);
}

LRESULT CBorderBar::OnGetMinMaxInfo(WPARAM wParam, LPARAM lParam)
{
	ASSERT(GetTopWindow() != NULL);
	GetTopWindow()->SendMessage(WM_GETMINMAXINFO, wParam, lParam);
	
	if (OnChicago())
	{
		LPMINMAXINFO lpMMI = (LPMINMAXINFO) lParam;

		lpMMI->ptMinTrackSize.x += g_mt.cxBorder * 2;
		lpMMI->ptMinTrackSize.y += g_mt.cyBorder * 2;
		lpMMI->ptMaxTrackSize.x += g_mt.cxBorder * 2;
		lpMMI->ptMaxTrackSize.y += g_mt.cyBorder * 2;
	}

	return 0L;
}

LRESULT CBorderBar::OnGetTrackSize(WPARAM wParam, LPARAM lParam)
{
	return OnSizeMessage(DWM_GETTRACKSIZE, dpNil, wParam, lParam);
}

//	CBorderBar::OnGetMoveSize
//		Docked window size grows by the size of the border, so that child
//		window size will not change to show the border when docked.

LRESULT CBorderBar::OnGetMoveSize(WPARAM wParam, LPARAM lParam)
{
	return OnSizeMessage(DWM_GETMOVESIZE, (DOCKPOS) wParam, wParam, lParam);
}

LRESULT CBorderBar::OnSizeMessage(UINT message, DOCKPOS dp,
	WPARAM wParam, LPARAM lParam)
{
	CSize size((short) LOWORD(lParam), (short) HIWORD(lParam));

	if (dp == dpHorzInit)
	{
		size.cx -= g_mt.cxToolCaption + g_mt.cxToolCapBorder * 2 +
			m_cxRightBorder + g_mt.cxBorder * 2;
		size.cy -= g_mt.cyToolBorder + m_cyBottomBorder + g_mt.cyBorder * 2;
	}
	else if(dp == dpVertInit)
	{
		size.cx -= g_mt.cxToolBorder + m_cxRightBorder + g_mt.cxBorder * 2;
		size.cy -= g_mt.cyToolCaption + g_mt.cxToolCapBorder * 2 +
			m_cyBottomBorder + g_mt.cyBorder * 2;
	}
	else if (OnChicago())
	{
		size.cx -= g_mt.cxBorder * 2;
		size.cy -= g_mt.cyBorder * 2;
	}
	
	LRESULT lResult = GetTopWindow()->SendMessage(message,
		wParam, MAKELPARAM((WORD)(short) size.cx, (WORD)(short) size.cy));
		
	if (lResult)
	{
		size.cx = (short) LOWORD(lResult);
		size.cy = (short) HIWORD(lResult);
	}
	
	switch (dp)
	{
	case dpTop:
	case dpBottom:
	case dpHorzInit:
		//BLOCK:
		{
			size.cx += g_mt.cxToolCaption + g_mt.cxToolCapBorder * 2 +
				m_cxRightBorder + g_mt.cxBorder * 2;
			size.cy += g_mt.cyToolBorder + m_cyBottomBorder + g_mt.cyBorder * 2;

			CWnd* pBar = GetDescendantWindow(AFX_IDW_TOOLBAR);
			if (pBar != NULL && (pBar->GetStyle() & WS_VISIBLE) != 0)
				size.cy -= g_mt.cyToolBorder;
		}
		break;

	case dpLeft:
	case dpRight:
	case dpVertInit:
		size.cx += g_mt.cxToolBorder + m_cxRightBorder + g_mt.cxBorder * 2;
		size.cy += g_mt.cyToolCaption + g_mt.cxToolCapBorder * 2 +
			m_cyBottomBorder + g_mt.cyBorder * 2;
		break;

	case dpNil:
		if (OnChicago())
		{
			size.cx += g_mt.cxBorder * 2;
			size.cy += g_mt.cyBorder * 2;
		}
		break;
	}
	
	return MAKELRESULT((WORD)(short) size.cx, (WORD)(short) size.cy);
}

//	CBorderBar::OnEnableChild
//		Calls enable window on the child window.  Used to disable input
//		during customize mode.

LRESULT CBorderBar::OnEnableChild(UINT wParam, LPARAM lParam)
{
	ASSERT(GetTopWindow() != NULL);
	GetTopWindow()->EnableWindow(wParam);
	
	return 0L;
}

void CBorderBar::GetCaptionButtonRect(int nType, CRect& rectButton) const
{
	CRect rectClient;
	GetClientRect(rectClient);

	CPoint ptTopLeft;

	// Horizontal windows have a vertical caption.
	if (m_bHorz)
	{
		ptTopLeft.x = rectClient.left +
			((g_mt.cxToolCaption + g_mt.cxToolCapBorder * 2) - g_mt.cxToolCapButton) / 2;
		ptTopLeft.y = g_mt.cyToolBorder +
			(g_mt.cyToolCapButton + g_mt.cyToolCapGap) * nType;
	}
	else
	{
		ptTopLeft.x = rectClient.right - g_mt.cxToolBorder - g_mt.cxToolCapButton -
			(g_mt.cxToolCapButton + g_mt.cxToolCapGap) * nType;
		ptTopLeft.y = rectClient.top +
			((g_mt.cyToolCaption + g_mt.cyToolCapBorder * 2) - g_mt.cyToolCapButton) / 2;
	}

	rectButton.SetRect(ptTopLeft.x, ptTopLeft.y,
		ptTopLeft.x + g_mt.cxToolCapButton, ptTopLeft.y + g_mt.cyToolCapButton);
}

int CBorderBar::InCaptionButtonRect(CPoint point) const
{
	if (m_bBtnClose)
	{
		CRect rect;
		GetCaptionButtonRect(BUTTON_CLOSE, rect);
		if (rect.PtInRect(point))
			return BUTTON_CLOSE;
	}
	
	if (m_bBtnMax)
	{
		CRect rect;
		GetCaptionButtonRect(BUTTON_MAX, rect);
		if (rect.PtInRect(point))
			return BUTTON_MAX;
	}

	return BUTTON_NIL;
}

void CBorderBar::DrawCaptionButton(int nType, CDC* pdc, BOOL bPushed)
{
	CRect rectButton;
	GetCaptionButtonRect(nType, rectButton);
	if (!::RectVisible(pdc->m_hDC, rectButton))
		return;

	// Draw the button itself
	COLORREF colorLt = globalData.clrBtnHilite;
	COLORREF colorDk = globalData.clr3dDkShadow;
	if (bPushed)
		pdc->Draw3dRect(rectButton, colorDk, colorLt);
	else
		pdc->Draw3dRect(rectButton, colorLt, colorDk);

	rectButton.InflateRect(-1, -1);
	colorLt = globalData.clrBtnFace;
	colorDk = globalData.clrBtnShadow;
	if (bPushed)
		pdc->Draw3dRect(rectButton, colorDk, colorLt);
	else
		pdc->Draw3dRect(rectButton, colorLt, colorDk);

	rectButton.InflateRect(-1, -1);
	pdc->FillSolidRect(rectButton, colorLt);

	if (bPushed)
		rectButton.OffsetRect(1, 1);

	// Draw the glyph on the button
	BOOL bLarge=FALSE;
	if(g_mt.cxToolCapButton>cLargeCaptionButtonThreshold)
	{
		bLarge=TRUE;
	}

	CPen penDk(PS_SOLID, 1, globalData.clr3dDkShadow);
	CPen* ppenOld = pdc->SelectObject(&penDk);

	if (nType == BUTTON_CLOSE)
	{
		if(bLarge)
		{
			CPoint ptCenter=rectButton.CenterPoint();
			// center isn't the real center, since we're offset.
			ptCenter.x-=1;
			ptCenter.y-=1;

#if 0
			pdc->MoveTo(rectButton.left+1, rectButton.top);
			pdc->LineTo(ptCenter.x+1, ptCenter.y);
			pdc->MoveTo(rectButton.right-3, rectButton.top);
			pdc->LineTo(ptCenter.x-1, ptCenter.y);
			pdc->MoveTo(rectButton.left+1, rectButton.bottom-2);
			pdc->LineTo(ptCenter.x+1, ptCenter.y);
			pdc->MoveTo(rectButton.right-3, rectButton.bottom-2);
			pdc->LineTo(ptCenter.x-1, ptCenter.y);
#endif
			pdc->MoveTo(rectButton.left+1, rectButton.top+1);
			pdc->LineTo(rectButton.right - 2, rectButton.bottom - 2);
			pdc->MoveTo(rectButton.left+2, rectButton.top+1);
			pdc->LineTo(rectButton.right - 1, rectButton.bottom - 2);
			pdc->MoveTo(rectButton.right - 3, rectButton.top+1);
			pdc->LineTo(rectButton.left , rectButton.bottom - 2);
			pdc->MoveTo(rectButton.right - 2, rectButton.top+1);
			pdc->LineTo(rectButton.left +1, rectButton.bottom - 2);
		}
		else
		{
			pdc->MoveTo(rectButton.left, rectButton.top);
			pdc->LineTo(rectButton.right - 1, rectButton.bottom - 1);
			pdc->MoveTo(rectButton.right - 2, rectButton.top);
			pdc->LineTo(rectButton.left - 1, rectButton.bottom - 1);
		}
	}
	else if (nType == BUTTON_MAX)
	{
		MAX_STATE stateMax = DkWGetMaxState(m_nID);

		CPen penGray(PS_SOLID, 1, globalData.clrBtnShadow);
		if (stateMax == stateDisabled)
			pdc->SelectObject(&penGray);

		if (m_bHorz)
		{
			if (stateMax == stateRestore)
			{
				pdc->MoveTo(rectButton.left, rectButton.top);
				pdc->LineTo(rectButton.left, rectButton.bottom - 1);
				pdc->MoveTo(rectButton.left + 1, rectButton.top + 1);
				pdc->LineTo(rectButton.left + 1, rectButton.bottom - 2);
				if(bLarge)
				{
					pdc->MoveTo(rectButton.left + 2, rectButton.top + 2);
					pdc->LineTo(rectButton.left + 2, rectButton.bottom - 3);
					pdc->MoveTo(rectButton.left + 3, rectButton.top + 3);
					pdc->LineTo(rectButton.left + 3, rectButton.bottom - 4);
				}
				else
				{
					pdc->SelectObject(&penGray);
					pdc->MoveTo(rectButton.left + 2, rectButton.top + 1);
					pdc->LineTo(rectButton.left - 1, rectButton.top - 2);
					pdc->MoveTo(rectButton.left + 2, rectButton.bottom - 3);
					pdc->LineTo(rectButton.left - 1, rectButton.bottom);
				}
			}
			else
			{
				pdc->MoveTo(rectButton.right - 2, rectButton.top);
				pdc->LineTo(rectButton.right - 2, rectButton.bottom - 1);
				pdc->MoveTo(rectButton.right - 3, rectButton.top + 1);
				pdc->LineTo(rectButton.right - 3, rectButton.bottom - 2);
				
				if(bLarge)
				{
					pdc->MoveTo(rectButton.right - 4, rectButton.top+2);
					pdc->LineTo(rectButton.right - 4, rectButton.bottom - 3);
					pdc->MoveTo(rectButton.right - 5, rectButton.top + 3);
					pdc->LineTo(rectButton.right - 5, rectButton.bottom - 4);
				}
				else
				{
					pdc->SelectObject(&penGray);
					pdc->MoveTo(rectButton.right - 4, rectButton.top + 1);
					pdc->LineTo(rectButton.right - 1, rectButton.top - 2);
					pdc->MoveTo(rectButton.right - 4, rectButton.bottom - 3);
					pdc->LineTo(rectButton.right - 1, rectButton.bottom);
				}
			}
		}
		else
		{
			if (stateMax == stateRestore)
			{
				pdc->MoveTo(rectButton.left, rectButton.top);
				pdc->LineTo(rectButton.right - 1, rectButton.top);
				pdc->MoveTo(rectButton.left + 1, rectButton.top + 1);
				pdc->LineTo(rectButton.right - 2, rectButton.top + 1);

				if(bLarge)
				{
					pdc->MoveTo(rectButton.left + 2, rectButton.top + 2);
					pdc->LineTo(rectButton.right - 3, rectButton.top + 2);
					pdc->MoveTo(rectButton.left + 3, rectButton.top + 3);
					pdc->LineTo(rectButton.right - 4, rectButton.top + 3);
				}
				else
				{
					pdc->SelectObject(&penGray);
					pdc->MoveTo(rectButton.left + 1, rectButton.top + 2);
					pdc->LineTo(rectButton.left - 2, rectButton.top - 1);
					pdc->MoveTo(rectButton.right - 3, rectButton.top + 2);
					pdc->LineTo(rectButton.right, rectButton.top - 1);
				}
			}
			else
			{
				pdc->MoveTo(rectButton.left, rectButton.bottom - 2);
				pdc->LineTo(rectButton.right - 1, rectButton.bottom - 2);
				pdc->MoveTo(rectButton.left + 1, rectButton.bottom - 3);
				pdc->LineTo(rectButton.right - 2, rectButton.bottom - 3);
				
				if(bLarge)
				{
					pdc->MoveTo(rectButton.left + 2 , rectButton.bottom - 4);
					pdc->LineTo(rectButton.right - 3, rectButton.bottom - 4);
					pdc->MoveTo(rectButton.left + 3, rectButton.bottom - 5);
					pdc->LineTo(rectButton.right - 4, rectButton.bottom - 5);
				}
				else
				{
					pdc->SelectObject(&penGray);
					pdc->MoveTo(rectButton.left + 1, rectButton.bottom - 4);
					pdc->LineTo(rectButton.left - 2, rectButton.bottom - 1);
					pdc->MoveTo(rectButton.right - 3, rectButton.bottom - 4);
					pdc->LineTo(rectButton.right, rectButton.bottom - 1);
				}
			}
		}
		// [fabriced] This call is necessary because there is a CPen going out of scope.
		// we need to deselect the object first, so that it can be deleted.
		pdc->SelectObject(ppenOld);
	}

	pdc->SelectObject(ppenOld);
}

void CBorderBar::OnPaint()
{
	CPaintDC dc(this);

	if (m_bCaption)
	{
		CRect rect;
		GetClientRect(rect);

		// Horizontal windows have a vertical caption.
		if (m_bHorz)
		{
			rect.InflateRect(-g_mt.cxToolCapBorder, -g_mt.cyToolBorder);
			rect.right = rect.left + g_mt.cxToolCaption;
		}
		else
		{
			rect.InflateRect(-g_mt.cxToolBorder, -g_mt.cyToolCapBorder);
			rect.bottom = rect.top + g_mt.cyToolCaption;
		}

		CRect rcBtn;
		if (m_bBtnMax)
			GetCaptionButtonRect(BUTTON_MAX, rcBtn);
		else if (m_bBtnClose)
			GetCaptionButtonRect(BUTTON_CLOSE, rcBtn);
		if (!rcBtn.IsRectNull())
		{
			// Subtract the button rect from the bar rect.
			if (m_bHorz)
				rect.top = rcBtn.bottom + 3;
			else
				rect.right = rcBtn.left - 3;
		}

		COLORREF colorLt = ::GetSysColor(COLOR_BTNHILIGHT);
		COLORREF colorDk = ::GetSysColor(COLOR_BTNSHADOW);
		dc.FillSolidRect(rect.left, rect.top, rect.Width(), rect.Height(),
			::GetSysColor(COLOR_BTNFACE));
		if (m_bHorz)
		{
			dc.Draw3dRect(rect.left, rect.top, 3, rect.Height(),
				colorLt, colorDk);
			dc.Draw3dRect(rect.left + 4, rect.top, 3, rect.Height(),
				colorLt, colorDk);
		}
		else
		{
			dc.Draw3dRect(rect.left, rect.top, rect.Width(), 3,
				colorLt, colorDk);
			dc.Draw3dRect(rect.left, rect.top + 4, rect.Width(), 3,
				colorLt, colorDk);
		}

		if (m_bBtnClose)
			DrawCaptionButton(BUTTON_CLOSE, &dc, FALSE);
		if (m_bBtnMax)
			DrawCaptionButton(BUTTON_MAX, &dc, FALSE);
	}
}

void CBorderBar::OnNcPaint()
{
	if (OnChicago())
		return;		// Dockwnd paints the border.

	CWnd::OnNcPaint();
}

//	CBorderBar::OnNcHitTest
//		Checks for HTCAPTION for dock managed moving.  May have to route to
//		the child to get its HTCAPTION, if it is disabled.

UINT CBorderBar::OnNcHitTest(CPoint point)
{
	ASSERT(GetTopWindow() != NULL);
	
	CRect rect;
	GetTopWindow()->GetWindowRect(rect);
	
	if (rect.PtInRect(point))
	{
		// In case the child window is disabled.
		UINT nHitTest = (UINT) GetTopWindow()->SendMessage(WM_NCHITTEST,
			0, MAKELPARAM(point.x, point.y));
		
		if (nHitTest != HTCAPTION)
			return HTCLIENT;
	}

	ScreenToClient(&point);
	if (InCaptionButtonRect(point) != BUTTON_NIL)
		return HTCLIENT;

	return HTCAPTION;
}

//	CBorderBar::OnLButtonDown
//		Child window must be disabled, and not returning HTCAPTION, so
//		we beep to let the user now that the normal functionality is disabled.
//		Also handle button clicks for caption buttons.

void CBorderBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	int nButton = InCaptionButtonRect(point);
	if (nButton == BUTTON_NIL)
	{
		MessageBeep(UINT(-1));	// Only happens when child is disabled.
		return;
	}
	else if (nButton == BUTTON_MAX && DkWGetMaxState(m_nID) == stateDisabled)
	{
		return;
	}

	SetCapture();
	m_nBtnCapture = nButton;
	m_bBtnPushed = TRUE;

	CClientDC dc(this);
	DrawCaptionButton(m_nBtnCapture, &dc, TRUE);
}

void CBorderBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_nBtnCapture == BUTTON_NIL)
		return;

	BOOL bClose = FALSE;
	if (InCaptionButtonRect(point) == m_nBtnCapture)
	{
		CRect rectButton;
		GetCaptionButtonRect(m_nBtnCapture, rectButton);
		InvalidateRect(rectButton);

		if (m_nBtnCapture == BUTTON_CLOSE)
			bClose = TRUE;
		else if (m_nBtnCapture == BUTTON_MAX)
			DkWMaximizeRestore(m_nID);
	}

	ReleaseCapture();
	m_nBtnCapture = BUTTON_NIL;
	m_bBtnPushed = FALSE;

	// Do this last, since it may destroy the window.
	if (bClose)
		DkWShowWindow(m_nID, FALSE);
}

void CBorderBar::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_nBtnCapture == BUTTON_NIL)
		return;

	BOOL bChange = FALSE;

	if (GetCapture() != this)
	{
		bChange = m_bBtnPushed;

		m_nBtnCapture = BUTTON_NIL;
		m_bBtnPushed = FALSE;
	}
	else if (InCaptionButtonRect(point) == m_nBtnCapture)
	{
		bChange = !m_bBtnPushed;
		m_bBtnPushed = TRUE;
	}
	else
	{
		bChange = m_bBtnPushed;
		m_bBtnPushed = FALSE;
	}

	if (bChange)
	{
		CClientDC dc(this);
		DrawCaptionButton(m_nBtnCapture, &dc, m_bBtnPushed);
	}
}

//	CBorderBar::OnSize
//		Size the child to stay with this window, and compensate for any
//		border we may have to show because of the dock.

void CBorderBar::OnSize(UINT nType, int cx, int cy)
{
    if (nType == SIZE_RESTORED)
		RecalcLayout();
     
	CWnd::OnSize(nType, cx, cy);
}

//	CBorderBar::OnSetFocus
//		Pass focus to the child.

void CBorderBar::OnSetFocus(CWnd* pOldWnd)
{
	CWnd* pChild = GetTopWindow();
	if (pChild != NULL)
		pChild->SetFocus();
}

BOOL CBorderBar::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)
{
	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);

	// allow top level routing frame to handle the message
	if (GetRoutingFrame() != NULL)
		return FALSE;

	return CTheApp::HandleToolTipText(nID, pNMHDR, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barcust.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  BARCUST.CPP
//      Contains implementation of the CCustomBar class
///////////////////////////////////////////////////////////////////////////////

/* 
This class implements all of the customisation and command bar functionality for command bars. You should use it for all
bars which are not to participate in the docking windows. Docking is handled by a subclass - CASBar.

It inherits from the CToolBar class, which implements a manually drawn command bar style toolbar, with no diversity of
button types (ordinary only). 

When most of the CCustomBar class was implemented, we had made a decision to avoid modifications to oldbar.cpp, to ease
reintegration with MFC's version of this class at some later date. This explains much of the design rationale for CCustomBar.

When we decided to do the command bar look for toolbars, it became clear that we would not be able to maintain this rule for
the drawing code, and substantial modifications were made to the oldbar.cpp code. 

Important members added by this class

m_sizeMaxLayout is the maximum width/height of the bar, in horizontal and vertical postures
m_sizeFixedLayout is the minimum height/width of the bar in horizontal and vertical postures, except for vertical docking

A max width, min height bar (e.g. docked at top) is m_sizeMaxLayout.cx, and m_sizeFixedLayout.cy;
A min width, max height bar (e.g. floating thin) is m_sizeMaxLayout.cy, and m_sizeFixedLayout.cx;

Vertical bars must are always very thin, and have their window controls drawn in a special way.

m_pButtonExtra is allocated on demand. See btnextra.h for a description

CCustomBarProxy m_Proxy;

Proxies are described more fully in the header file barprxy.h

MDI Child System Menu Implementation
------------------------------------

When we are MDI hosting we allow an extra menu to be pulled from the main menu bar. That menu is given the s_nDroppedItem
value equal to m_nCount. It is a constructed command bar menu.
Actually, I'm fairly unhappy with the way I chose to implement this - I think that a set of special buttons
might have been simpler, though there would still have been a number of special cases.

Use of FIND_SLOW_CMDUI
----------------------

This will help when searching for slow cmdui update handlers in the product. The code tracks the longest cmdui handler, and emits a 
trace message for any handler that is within 90% of the current highest known value. There are two separate defines, one for menus,
in cbmenu.cpp, and one for toolbars, in barcust.cpp. 

The main problem with this code is that once a very slow cmdui handler is hit, other handlers may not trace any more because the maximum 
has become too high. Things like the file menu MRU handlers (which are very slow) can cause this problem.

*/

#include "stdafx.h"

#include "shell.h"
#include "barcust.h"
#include "bardlgs.h"
#include "barglob.h"
#include "ipchost.h"
#include "shlmenu.h"
#include "custbtn.h"
#include "shell.h"
#include "menuprxy.h"
#include "prxycust.h"

IMPLEMENT_DYNAMIC(CCustomBar, CToolBar);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define AUTOUPDATE_BUTTONS

// Define this to one to trace on Cmdui handlers that are in the slowest 10% of the range
// See above for an explanation of this define
#ifdef _DEBUG
#define FIND_SLOW_CMDUI 0
#else
#define FIND_SLOW_CMDUI 0
#endif

// descriptions of these messages are in barcust.h
UINT DSM_BARSELECTCHANGING = RegisterMessage("DevStudioToolbarSelectionChanging");
extern UINT DSM_DROPMENU = RegisterMessage("DevStudioDropPendingMenu");

int CCustomBar::s_nDroppedItem=-1;
CCustomBar* CCustomBar::s_pDroppedBar=NULL;
CBMenuPopup *CCustomBar::s_pSystemMenu=NULL;
CPoint CCustomBar::s_ptLastMove(0,0);

// TRUE if, during a cmdui update, an enable happened in a bar (the menu bar) that needs a recalclayout after cmdui. This happens
// when things have lost/got the invisible bit.
BOOL CCustomBar::s_bRecalcLayoutPending=FALSE;

///////////////////////////////////////////////////////////////////////////////
//      CCustomBar
//              Derived from MFC CToolBar, this enhancement allows functionality such
//              as toolbar sizing, standard for HWNDs in toolbars, and customizing.
//              providing a base class for both CASBar and the toolbars in the VRES
//              toolbar editors.
//

// static data members.

HCURSOR CCustomBar::s_hcurVSize = NULL;

//      CCustomBar::CCustomBar
//      Construction.
CCustomBar::CCustomBar()           
{
	// Attach the proxy.
	m_Proxy.AttachBar(this);

	if (s_hcurVSize == NULL)
	VERIFY(s_hcurVSize = AfxGetApp()->LoadCursor(IDCUR_VSIZE));

	SetDefaultSizes(theApp.m_bLargeToolBars);

	m_cyDefaultGap = m_cxDefaultGap / 2;    // MFC sets m_cxDefaultGap.
	m_cyTopBorder = m_cyBottomBorder = 1; //g_mt.cyToolBorder;
	m_cxLeftBorder = m_cxRightBorder = 1; //g_mt.cxToolBorder;
	m_glyphStatus=cGlyphsAbsent;
	CSize sizeButton=GetButtonSize(orNil);
	m_sizeFixedLayout.cx = GetLeftBorder(orNil) + GetRightBorder(orNil) +
		sizeButton.cx + g_mt.cxBorder * 2;
	m_sizeFixedLayout.cy = GetTopBorder(orNil) + GetBottomBorder(orNil) +
		sizeButton.cy + g_mt.cyBorder * 2;
		
	m_pButtonExtra = NULL;
	m_nTiles = 0;
	m_hIconMDI=NULL;
	m_nMDITrack=cMDINotDrawn;
}

//      CCustomBar::~CCustomBar
//              Destructor.

CCustomBar::~CCustomBar()
{
	RemoveExtra();
	Empty();

	// bar can't be destroyed while system menu is down, so destroy it
	if(s_pSystemMenu)
	{
		delete s_pSystemMenu;
		s_pSystemMenu=NULL;
	}
	if(m_hIconMDI)
	{
		::DestroyIcon(m_hIconMDI);
		m_hIconMDI=NULL;
	}
}

BOOL CCustomBar::Create(DWORD dwStyle, const CRect& rect,
	CWnd* pParent, UINT nID)
{
	// Use RecalcLayout to update size after setting buttons and bitmap.
	//
	CRect rectInit(rect.top, rect.left,
		rect.top, rect.left);
    
	dwStyle |= (WS_CHILD | DWS_SIZABLE);
	m_dwStyle = dwStyle & ~CBRS_GRIPPER; // No MFC Gripper bar, we're doing our own.

    if (pParent == NULL ||
	!CWnd::Create(AfxRegisterWndClass(CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
			  ::LoadCursor(NULL, IDC_ARROW),
			  (HBRUSH) (COLOR_BTNFACE + 1)),
		"",
			dwStyle,
			rect,
			pParent,
			nID))
	{
	return FALSE;
	}
	
	return TRUE;
}

// Like SetSize, but without any redraw action.
void CCustomBar::SetDefaultSizes(BOOL bLarge)
{
	if(!bLarge)
	{
		CToolBar::SetDefaultSizes();
	}
	else
	{
		// UISG standard large sizes
		m_sizeButton=GetDefaultButtonSize(TRUE);
		m_sizeImage=GetDefaultBitmapSize(TRUE);
		m_cyTopBorder = m_cyBottomBorder = 4;

		// adjust sizes when running on Win4
		if (globalData.bWin4)
		{
			m_sizeButton.cx = 39;
			m_cySharedBorder = m_cxSharedBorder = 0;
			m_cxDefaultGap = 8;
		}
		else
		{
			m_cxDefaultGap = 6;
			m_cySharedBorder = m_cxSharedBorder = 1;
		}
	}
}

CSize CCustomBar::GetDefaultBitmapSize(BOOL bLarge)
{
	if(!bLarge)
	{
		return CToolBar::GetDefaultBitmapSize();
	}
	else
	{
		return globalData.csLargeButtonGlyph;
	}
}

CSize CCustomBar::GetDefaultButtonSize(BOOL bLarge)
{
	if(!bLarge)
	{
		return CToolBar::GetDefaultButtonSize();
	}
	else
	{
		return globalData.csLargeButton;
	}
}

BOOL CCustomBar::LoadBitmap(LPCSTR lpszResourceName, BOOL bUpdateTiles /*=FALSE*/)
{
	BOOL bRet = CToolBar::LoadBitmap(lpszResourceName);
	if (bUpdateTiles)
		m_nTiles = CountTiles();

	return bRet;
}

void CCustomBar::SetBitmap(HBITMAP hbmImageWell, BOOL bUpdateTiles /*=FALSE*/)
{
	if (m_hbmImageWell != NULL)
		::DeleteObject(m_hbmImageWell);     // get rid of old one

	m_hbmImageWell = hbmImageWell;
	if (bUpdateTiles)
		m_nTiles = CountTiles();
}

BOOL CCustomBar::SetButtons(const UINT FAR* lpIDArray, int nIDCount)
{
	if (lpIDArray != NULL)  
		RemoveExtra();
	Empty();        // Note: Destroys the image well.

	if (!CToolBar::SetButtons(lpIDArray, nIDCount))
		return FALSE;

	SetGlyphStatus(cGlyphsUnknown);

	return TRUE;
}

int CCustomBar::CountTiles()
{
	BITMAP bmStruct;
	if (m_hbmImageWell == NULL ||
		::GetObject(m_hbmImageWell, sizeof(BITMAP), &bmStruct) == 0)
		return 0;

	return bmStruct.bmWidth / m_sizeImage.cx;
}

ORIENTATION CCustomBar::GetOrient() const
{
	return orHorz;
}

HWND CCustomBar::GetControl(UINT nID)
{
	return NULL;
}

CCustomBar* CCustomBar::NewBar(UINT nID, const CPoint& pt)
{
	return NULL;
}

void CCustomBar::MoveBar(const CRect& rect)
{
	SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(),
		SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);    
}

void CCustomBar::OnSelChange(int nIndex)
{
}

void CCustomBar::OnDeleteSelection()
{
}

void CCustomBar::OnBarActivate()
{
}

void CCustomBar::OnButtonSize()
{
}

BOOL CCustomBar::IsStaticItem(int nIndex)
{
	return FALSE;
}

void CCustomBar::RemoveControl(HWND hwndRemove)
{
	::DestroyWindow(hwndRemove);
}

//      CCustomBar::GetHSize
//              Gets the horizontal dock snap size (all buttons in one row).

CSize CCustomBar::GetHSize(ORIENTATION or)
{
	CSize size(m_sizeMaxLayout.cx, m_sizeFixedLayout.cy);

	return size;
}

//      CCustomBar::GetVSize
//              Gets the vertical dock snap size (all buttons in one column).
//              Returns null size if can't put all buttons in one column, because
//              of an oversized HWND.

CSize CCustomBar::GetVSize()
{
    CSize size;

	size = Fit(GetVWidth(), orVert);
    
    return size;
}

//      CCustomBar::GetVWidth
//              Gets the vertical dock snap width (all buttons in one column).

int CCustomBar::GetVWidth() const
{
	CSize sizeButton=GetButtonSize(orVert);

	return GetLeftBorder(orVert) + GetRightBorder(orVert) + sizeButton.cx + g_mt.cxBorder * 2;
}

//      CCustomBar::GetSize
//              Given a size and a HitTest code, returns the best fit size restricted
//              on either width or height, depending on the HitTest code.

CSize CCustomBar::GetSize(UINT nHitTest, CSize size)
{
	int nLeft, nRight, nMid;
	
	nLeft = m_sizeFixedLayout.cx;

	ORIENTATION or=GetOrient();

	// can't have floating windows larger than screen - windows enforces this, so we have to
	BOOL bSizeLimit=(or==orNil); // true if size limit should be enforced

	CSize sizeLimit(0,0);

	if(bSizeLimit)
	{
		CWnd *pDesktop=GetDesktopWindow();
		ASSERT(pDesktop!=NULL);
		CRect rectDesktop;
		pDesktop->GetWindowRect(rectDesktop);
		sizeLimit=rectDesktop.Size();

		ASSERT(sizeLimit.cx!=0 && sizeLimit.cy!=0);
	}
	
	switch (nHitTest)
	{
	case HTTOP:
	case HTBOTTOM:
		nRight = m_sizeMaxLayout.cx;
		break;
		
	case HTLEFT:
	case HTRIGHT:
		nRight = max(size.cx, m_sizeFixedLayout.cx);
		size.cy = Fit(size.cx, orNil).cy;       // use the fit height
		break;
		
	default:
		ASSERT(FALSE);
		break;
	}

	// Binary search for the pixel farthest left (smallest width) that
	// keeps the height less than or equal to size.cy.
	//
	while (nLeft < nRight)
	{
		nMid = (nLeft + nRight) / 2;
			
		if (Fit(nMid, orNil).cy > size.cy)
			nLeft = nMid + 1;
		else if (nMid > nLeft && Fit(nMid - 1, orNil).cy <= size.cy)
			nRight = nMid - 1;
		else
			nLeft = nRight = nMid;
	}
		
	if(bSizeLimit)
	{
		ASSERT(sizeLimit.cx!=0 && sizeLimit.cy!=0);
		if(nRight > sizeLimit.cx)
		{
			// if we exceed the screen width, then we can no longer treat this bar as a single line one, and must
			// instead use the same method as for HTRIGHT
			if(nHitTest==HTTOP || nHitTest==HTBOTTOM)
			{
				nRight = max(size.cx, m_sizeFixedLayout.cx);
			}
			else
			{
				nRight=Fit(sizeLimit.cx,orNil).cx;
			}
		}
	}
	
	size.cx = nRight;
	size.cy = Fit(size.cx, orNil).cy;
	
	return size;
}

//      CCustomBar::RecalcSizes
//              Recalculates the various layout sizes.  Used when the button layout
//              changes.

void CCustomBar::RecalcSizes()
{
	// minimum acceptable width, used for calculating maximum height
	int xMinWidth;

	// Start with defaults.
	CSize sizeButton=GetButtonSize(orNil);

	m_sizeFixedLayout.cx = GetLeftBorder(orNil) + GetRightBorder(orNil) +
		sizeButton.cx + g_mt.cxBorder * 2;
	m_sizeFixedLayout.cy = GetTopBorder(orNil) + GetBottomBorder(orNil) +
		sizeButton.cy + g_mt.cyBorder * 2;
		

	if (m_nCount == 0)
	{
		m_sizeMaxLayout = m_sizeFixedLayout;
		return;
	}

	xMinWidth=m_sizeFixedLayout.cx;

	m_sizeMaxLayout.cx = GetLeftBorder(orHorz) + g_mt.cxBorder;

	if(IsMDIHost())
	{
		// caption button width
		m_sizeFixedLayout.cx=max(m_sizeFixedLayout.cx, GetLeftBorder(orNil) + GetRightBorder(orNil) +
				2*globalData.csCaptionButton.cx + g_mt.cxBorder * 2);
		// small icon width
		m_sizeFixedLayout.cx=max(m_sizeFixedLayout.cx, GetLeftBorder(orNil) + GetRightBorder(orNil) +
				globalData.csSmallIcon.cx + g_mt.cxBorder * 2);

		// altogether
		m_sizeMaxLayout.cx+=GetLeftMDIArea(orNil)+GetRightMDIArea(orNil);
	}
		
	BOOL bInGroup = FALSE;
	CRect rectTmp;
    AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;

    for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
    {
		if(pTBB->nStyle & TBBS_INVISIBLE)
		{
			continue;
		}

		if (pTBB->nStyle & TBBS_SEPARATOR)
		{
			bInGroup = FALSE;
			m_sizeMaxLayout.cx += m_cxDefaultGap;
		}
		else if (pTBB->nStyle & TBBS_HWND)
		{
			::GetWindowRect(GetButtonExtra(iButton)->GetControl(), rectTmp);

			m_sizeMaxLayout.cx += rectTmp.Width() - m_cxSharedBorder;
			m_sizeFixedLayout.cx = max(m_sizeFixedLayout.cx,
				GetLeftBorder(orNil) + GetRightBorder(orNil) +
				rectTmp.Width() + g_mt.cxBorder * 2);
		}
		else
		{
			// buttons can have text, glyph, or both
			CSize sizeContent;

			// start by working out the size of the content of this button
			if (pTBB->nStyle & TBBS_TEXTUAL) {
				// measure string accounts for the glyph
				MeasureString(iButton, sizeContent, orHorz);
			} else {
				sizeContent=m_sizeImage;
			}

			// calculate extra width added by internal blank area around text
			int internalBorder=sizeButton.cx-m_sizeImage.cx - m_cxSharedBorder;

			// calculate potential width
			m_sizeMaxLayout.cx+=sizeContent.cx + internalBorder;

			// calculate minimum width
			m_sizeFixedLayout.cx = max(     m_sizeFixedLayout.cx, GetLeftBorder(orNil) + GetRightBorder(orNil) + 
										sizeContent.cx + internalBorder + g_mt.cxBorder * 2);
		}       
		
		if (!bInGroup)
		{
			// no overlap for first button in a group
			bInGroup = TRUE;
			m_sizeMaxLayout.cx += m_cxSharedBorder;
		}        
	}       // for

	m_sizeMaxLayout.cx += GetRightBorder(orNil) + g_mt.cxBorder;    // no overlap on last button

	// martynl: We must preinit maxLayout.cy here because Fit relies on it being set to something
	// sensible.
	m_sizeMaxLayout.cy = GetTopBorder(orVert) +  g_mt.cyBorder + sizeButton.cy;
	m_sizeMaxLayout.cy = Fit(xMinWidth, orVert).cy;
}

// Warning: GetTextExtent returns the width of the text in cx, even for a vertical font. 
// martynl 06May96
// Its funny how I wanted GetTextExtent to work the way its does, but someone else didn't....
// :-) der
// That just means you have a twisted (or should I say rotated?) mind... :) martynl

// We are now caching the length of the string in a button extra field. If the cached values are negative, then they are
// for a vertical bar. We always update the cache. This caching avoids dcs, fonts, ampersand stripping. Should be a big
// performance win. The cost is a dword per bar item, once window, textual or customglyph buttons are added to the bar.
// martynl 25Jun96
void CCustomBar::MeasureString(int iButton, CSize &stringSize, ORIENTATION or)
{
    AFX_TBBUTTON* pTBB = _GetButtonPtr(iButton);

	ASSERT(pTBB->nStyle & TBBS_TEXTUAL);

	// if there are text buttons, then the bar must have extra info
	ASSERT(HasButtonExtra());

	CSize sizeLabel=GetButtonExtra(iButton)->GetLabelSize();

	if( (sizeLabel.cx<0 && or!=orVert) ||
		(sizeLabel.cx>0 && or==orVert))
	{
		sizeLabel=CSize(0,0);
	}
	if(sizeLabel.cx==0)
	{
		// determine size of string if drawn in that font
		CDC *pDC=GetDC();               // dev context of the toolbar

		// select the button font
		CFont *pOldFont=pDC->SelectObject(GetTextFont(or));

		sizeLabel=globalData.GetTextExtentNoAmpersands(pDC, GetButtonExtra(iButton)->GetLabel());

		// clean up context
		pDC->SelectObject(pOldFont);
		VERIFY(ReleaseDC(pDC));

		if(or!=orVert)
		{
			EditButtonExtra(iButton)->SetLabelSize(sizeLabel);
		}
		else
		{
			EditButtonExtra(iButton)->SetLabelSize(CSize(-sizeLabel.cx, -sizeLabel.cy));
		}
	}
	else
	{
		if(or==orVert)
		{
			sizeLabel.cx=-sizeLabel.cx;
			sizeLabel.cy=-sizeLabel.cy;
		}
	}

	if(or==orVert)
	{
		stringSize.cx=sizeLabel.cy;
		stringSize.cy=sizeLabel.cx;

		stringSize.cy+=cExtraTextBorder;
	}
	else
	{
		stringSize=sizeLabel;

		stringSize.cx+=cExtraTextBorder;
	}

	// if it's a menu not on the main menu bar, it gets a dropdown (or dropright) arrow
	if( (pTBB->nStyle & TBBS_MENU)!=0 &&
		(GetBarStyle() & CTBRS_MAINMENU)==0)
	{
		HBITMAP hbmArrow=GetMenuArrow(or);

		// figure the size of the bitmap
		BITMAP bmp;
		::GetObject(hbmArrow, sizeof(bmp), &bmp);

		ASSERT(bmp.bmWidth!=0);
		ASSERT(bmp.bmHeight!=0);

		if(or==orVert)
		{
			stringSize.cy+=bmp.bmHeight;
			stringSize.cx=max(stringSize.cx, bmp.bmWidth);
		}
		else
		{
			stringSize.cx+=bmp.bmWidth;
			stringSize.cy=max(stringSize.cy, bmp.bmHeight);
		}
	}

	if(pTBB->nStyle & TBBS_GLYPH)
	{
		if(or==orVert)
		{
			stringSize.cy+=m_sizeImage.cy;
			stringSize.cx=max(stringSize.cx, m_sizeImage.cx);
		}
		else
		{
			stringSize.cx+=m_sizeImage.cx;
			stringSize.cy=max(stringSize.cy, m_sizeImage.cy);
		}
	}
}

//      CCustomBar::RecalcLayout
//              Given a HitTest code (specifies whether to ristrict resizing by height,
//              or width), resizes the toolbar to accomadate button layout changes.

void CCustomBar::RecalcLayout(UINT nHTSize /*=HTRIGHT*/, ORIENTATION *pOr)
{
	// removed by martynl becuase the code (appears to) work fine in a dialog,
	// and is needed for the customize button dialog. martynl 27Mar96
	// ASSERT(!IsInDialog());
	
	ORIENTATION or;
	if(pOr)
	{
		or=*pOr;	
	}
	else
	{
		or=GetOrient();
	}
	
	CSize size;
	CRect rect;
	GetWindowRect(rect);

	RecalcSizes();
	
	CSize sizeWindow=rect.Size();

	switch (or)
	{
	case orHorz:
		size = GetHSize(or);
		break;

	case orVert:
		size = GetVSize();
		break;
	
	case orNil:
		size = GetSize(nHTSize, sizeWindow);
		break;

	default:
		ASSERT(FALSE);
		break;
	}
	
	BOOL bSameSize=FALSE;

	// If it's a menu bar, the dock manager will be adjusting it if it's docked, so we only compare the other dimension
	if((m_dwStyle & CTBRS_MAINMENU)!=0 &&
		or!=orNil)
	{
		if(or!=orHorz)
		{
			bSameSize=(size.cx==sizeWindow.cx);
		}
		else
		{
			// If this is a docked menu, then the size we calculated above isn't going to be right for the case where
			// the bar has just wrapped to two lines, since Get(H/V)Size assume no wrapping. So we work out whether a wrap will
			// happen. The actual wrapping is done in the dock manager when it gets the MoveBar below.
			CSize sizeFit=Fit(sizeWindow.cx, orHorz);

			bSameSize=(	sizeFit.cy==sizeWindow.cy+1 ||
						sizeFit.cy==sizeWindow.cy); // Nasty hack. Why the plus one? Somewhere, sometimes, a -1 is applied to window sizes when docked
		}
	}
	else
	{
		bSameSize=(size == sizeWindow);
	}

	if (bSameSize)
	{
		// Send a size message to ensure correct placement of Hwnd controls.
		SendMessage(WM_SIZE, SIZE_RESTORED, MAKELPARAM(size.cx, size.cy));
		InvalidateRect(NULL);
		UpdateWindow();
	}
	else
	{
		rect.right = rect.left + size.cx;
		rect.bottom = rect.top + size.cy;
		MoveBar(rect);
	}
}

//      CCustomBar::ShiftImage
//              Given and image index, a number of tiles to shift, and an array of
//              new IDs (if the number of tiles is positive), Shifts the tiles of
//              the current image well at the given index, and inserts new tiles
//              if necessary.

BOOL CCustomBar::ShiftImage(int nImage, int nTiles,
	TRANSFER_TBBUTTON* pTrans /*=NULL*/)
{
	ASSERT(nTiles == 1 || nTiles == -1);

	HDC hdcClient = ::GetDC(m_hWnd);
	HDC hdcDest = ::CreateCompatibleDC(hdcClient);
	HDC hdcSrc = ::CreateCompatibleDC(hdcClient);
		
	HBITMAP hbmNewWell = ::CreateCompatibleBitmap(hdcClient,
		(m_nTiles + nTiles) * m_sizeImage.cx, m_sizeImage.cy);
	::ReleaseDC(m_hWnd, hdcClient);
	
	if (hbmNewWell == NULL || hdcDest == NULL || hdcSrc == NULL)
	{       
		// May RIP.
		::DeleteObject(hbmNewWell);
		::DeleteDC(hdcSrc);
		::DeleteDC(hdcDest);
		return FALSE;
	}
		
	HBITMAP hbmOldDest = (HBITMAP) ::SelectObject(hdcDest, hbmNewWell);
	HBITMAP hbmOldSrc = (HBITMAP) ::SelectObject(hdcDest, hbmNewWell);      // Get old bitmap.
	if (m_hbmImageWell != NULL)
		hbmOldSrc = (HBITMAP) ::SelectObject(hdcSrc, m_hbmImageWell);
	
	// Blt the image well up to the given index into the new bitmap.
	CRect rect(0, 0, nImage * m_sizeImage.cx, m_sizeImage.cy);
		
	if (!rect.IsRectEmpty())
	{
		::BitBlt(hdcDest, rect.left, rect.top, rect.Width(), rect.Height(),
			hdcSrc, rect.left, rect.top, SRCCOPY);
	}
	
	// Blt the rest of the image well to its new location (overlaps first
	// Blt if nTiles is negative).
	rect.left = rect.right;
	if (nTiles > 0)
		rect.left += nTiles * m_sizeImage.cx;
		
	rect.right = (m_nTiles + nTiles) * m_sizeImage.cx;
		
	if (!rect.IsRectEmpty())
	{
		::BitBlt(hdcDest, rect.left, rect.top, rect.Width(), rect.Height(),
			hdcSrc, rect.left - nTiles * m_sizeImage.cx, rect.top, SRCCOPY);
	}

	if (nTiles > 0 && pTrans!=NULL)
	{
		// load the appropriate bitmap, if required
		pTrans->LoadCommandBitmap(theApp.m_bLargeToolBars);

		// Blt new command glyph.

		// This code used to assert that pTrans must be non-NULL. Now, however,
		// shiftimage is used by MakeBitmap to return a toolbar button to
		// its native state. In this case, no pTrans is used.

		// If old glyph is too small, fill new location with background.
		if (m_sizeImage.cx > pTrans->sizeImage.cx ||
			m_sizeImage.cy > pTrans->sizeImage.cy)
		{
			CBrush* pbr = GetSysBrush(CMP_COLOR_LTGRAY);
			HBRUSH hbrOld = (HBRUSH) ::SelectObject(hdcDest, pbr->m_hObject);
			::PatBlt(hdcDest, m_sizeImage.cx * nImage, 0,
				m_sizeImage.cx, m_sizeImage.cy, PATCOPY);
			::SelectObject(hdcDest, hbrOld);
		}

		int xShiftNew = max(0, (m_sizeImage.cx - pTrans->sizeImage.cx) / 2);
		int yShiftNew = max(0, (m_sizeImage.cy - pTrans->sizeImage.cy) / 2);
		int xShiftCur = max(0, (pTrans->sizeImage.cx - m_sizeImage.cx) / 2);
		int yShiftCur = max(0, (pTrans->sizeImage.cy - m_sizeImage.cy) / 2);
		int cxBlt = min(pTrans->sizeImage.cx, m_sizeImage.cx);
		int cyBlt = min(pTrans->sizeImage.cy, m_sizeImage.cy);

		::SelectObject(hdcSrc, pTrans->hbmImageWell);
		::BitBlt(hdcDest,
			(m_sizeImage.cx * nImage) + xShiftNew, yShiftNew, cxBlt, cyBlt,
			hdcSrc, (pTrans->sizeImage.cx * pTrans->iImage) + xShiftCur, yShiftCur,
			SRCCOPY);
	}

	::SelectObject(hdcDest, hbmOldDest);
	::SelectObject(hdcSrc, hbmOldSrc);
	::DeleteDC(hdcSrc);
	::DeleteDC(hdcDest);

	if (m_hbmImageWell != NULL)
		::DeleteObject(m_hbmImageWell);
	m_hbmImageWell = hbmNewWell;
	m_nTiles += nTiles;
	return TRUE;
}

//      CCustomBar::DeleteButton
//              Deletes the button at the given index from the toolbar.  Also
//              automitically removes redundant separators left by delete.  If we are permanently removing a 
//              textual button then its label string can be removed from the list of
//              labels

void CCustomBar::DeleteButton(int nIndex, BOOL bMoving /*=FALSE*/)
{
	ASSERT(0 <= nIndex && nIndex < m_nCount);
	ASSERT(m_nCount > 0);
	ASSERT_VALID(this);

	if( s_pDroppedBar==this)
	{
		CancelMenu();
	}

	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*) m_pData;
	TBBUTTON_EXTRA* pExtra = m_pButtonExtra;
	BOOL bButton = ((pTBB[nIndex].nStyle & TBBS_SEPARATOR) == 0);

	// Deal with the HWND.
	if (!bMoving && (pTBB[nIndex].nStyle & TBBS_HWND) != 0)
	{
		HWND hwndFocus = ::GetFocus();
		HWND hwndControl = GetButtonExtra(nIndex)->GetControl();
		if (hwndControl == hwndFocus || ::IsChild(hwndControl, hwndFocus))
			LoseFocus();

		RemoveControl(hwndControl);
	}

	if (m_nCount - 1 == 0)
	{
		Empty();
	}
	else
	{
		if(pTBB[nIndex].nStyle & TBBS_TEXTUAL) 
		{
			RemoveTextLabel(nIndex);
		}

		if(pTBB[nIndex].nStyle & TBBS_CUSTOMBITMAP)
		{
			// remove the mapping and delete the associated object
			if(HasButtonExtra())
			{
				HBITMAP hbmCustom=GetButtonExtra(nIndex)->GetGlyph();
				::DeleteObject(hbmCustom);
			}
		}
	
		AFX_TBBUTTON* pTBBNext = pTBB;
		TBBUTTON_EXTRA* pExtraNext = pExtra;

		BOOL bImageShift=FALSE;

		if(pTBB[nIndex].nStyle & TBBS_GLYPH)
		{
			if (!ShiftImage(pTBB[nIndex].iImage, -1))
				return;

			// because we just deleted a glyphed button, we no longer know if we have any left
			SetGlyphStatus(cGlyphsUnknown);

			bImageShift=TRUE;
		}
		
		int nNewCount = 0;
		int iNext=0; // the destination index (of tbbnext)
		for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++, pExtra++)
		{
			ASSERT(pTBB != NULL);
			if (iButton == nIndex)
				continue;
				
			// If it is a separator for the first or last position, or
			// following another separator, skip it.
			//
			if (!((pTBB->nStyle & TBBS_SEPARATOR) != 0 &&
				(pTBBNext == m_pData || (((pTBBNext - 1)->nStyle & TBBS_SEPARATOR) != 0))))
			{
				// move button itself
				*pTBBNext = *pTBB;

				// only copy button extra if it's valid
				if(HasButtonExtra())
				{
					*pExtraNext = *pExtra;
					pExtraNext++;
				}

				// if we deleted a glyph from the well before this button, and this
				// button has a glyph, then adjust its index
				if (bImageShift &&
					iButton > nIndex &&
					(pTBBNext->nStyle & TBBS_GLYPH) != 0
					)
				{
					pTBBNext->iImage--;
				}
				
				pTBBNext++;
				nNewCount++; iNext++;
			}
		}
		m_nCount=nNewCount;
		
		// No ending separator.
		ASSERT(pTBBNext != m_pData);
		if (((pTBBNext - 1)->nStyle & TBBS_SEPARATOR) != 0)
			m_nCount--;
		
		ASSERT(m_nCount > 0);
	}
	ASSERT_VALID(this);
}

void CCustomBar::RemoveTextLabel(int nIndex)
{
	ASSERT_VALID(this);

	// should always already be extra data, otherwise how could we delete a label
	ASSERT(GetButtonExtra(nIndex)!=NULL);

	EditButtonExtra(nIndex)->SetLabel("");
	
	// remove the flag
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*) m_pData;
	pTBB[nIndex].nStyle &= ~(TBBS_TEXTUAL|TBBS_CUSTOMTEXT);
}

// CCustomBar::AppendButton
//		Adds a button to the end of the bar with a specified command id

int CCustomBar::AppendButton(UINT nId)
{
	ASSERT(nId!=0);

	TRANSFER_TBBUTTON trans(nId);

	int nIndex=InsertButton(m_nCount, trans, FALSE, gapNil);

	Invalidate();

	return nIndex;
}

//      CCustomBar::InsertButton
//              Inserts a button into the bar at the given index.  Also deals with
//              any separators that may need to be added.
//              Can also insert just a separator, when TRANSFER_TBBUTTON is appropriate.
//				Returns the index where the button was inserted

int CCustomBar::InsertButton(int nIndex, TRANSFER_TBBUTTON& trans,
	BOOL bReplace, GAP gap)
{
	ASSERT(0 <= nIndex && nIndex <= m_nCount);
	ASSERT_VALID(this);

	if( s_pDroppedBar==this)
	{
		CancelMenu();
	}

	// load the appropriate bitmap, if required
	trans.LoadCommandBitmap(theApp.m_bLargeToolBars);

	int iButton=0;
	int iDestButton=0;
	int iInsertedAt=0;
	BOOL bHwnd = ((trans.nStyle & TBBS_HWND) != 0);
	TBBUTTON_EXTRA newExtra;
	newExtra.Create();
	BOOL bShiftImage=FALSE; // true if the image was shifted
	
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*) m_pData;
	AFX_TBBUTTON* pTBBNext;
	AFX_TBBUTTON* pTBBNew = pTBBNext =
		(AFX_TBBUTTON*) calloc(m_nCount + 2, sizeof(AFX_TBBUTTON));
	TBBUTTON_EXTRA* pExtra = m_pButtonExtra;
	TBBUTTON_EXTRA* pExtraNext=NULL;
	TBBUTTON_EXTRA* pExtraNew=NULL;

	BOOL bNeedExtra=FALSE; // true if a block of extra information is needed in the destination bar

	if(     pExtra ||
		trans.extra.IsUsed() ||
		bHwnd)
	{
		bNeedExtra=TRUE;
		pExtraNew = pExtraNext = new TBBUTTON_EXTRA[m_nCount + 2];
	}
		
	int nImageIndex=0;
	
	if (pTBBNew == NULL || (bNeedExtra && pExtraNew == NULL))
		goto cleanup;
	
	// Deal with the HWND.
	if (bHwnd)
	{
		ASSERT(bNeedExtra);

		newExtra.SetControl(trans.extra.GetControl());

		if (newExtra.GetControl() == NULL)
			newExtra.SetControl(GetControl(trans.nID));
	
		if (newExtra.GetControl() == NULL)
			goto cleanup;
					
		CWnd* pWnd = CWnd::FromHandle(newExtra.GetControl());
		pWnd->SetParent(this);
		if (IsValidCtrlSize(pWnd))
			pWnd->ShowWindow(SW_SHOWNOACTIVATE);
		else
			pWnd->ShowWindow(SW_HIDE);
	}

	// deal with the label
	if(!trans.extra.GetLabel().IsEmpty())
	{
		newExtra.SetLabel(trans.extra.GetLabel());
	}
	
	// deal with the custom bitmap
	if(trans.extra.GetGlyph()!=NULL)
	{
		newExtra.SetGlyph(GLOBAL_DATA::DuplicateBitmap(this, trans.extra.GetGlyph()));
	}

	// New Image.
	nImageIndex = nIndex; 
	while (nImageIndex < m_nCount &&
		(pTBB[nImageIndex].nStyle & TBBS_GLYPH) == 0)
	{
		nImageIndex++;
	}

	// At this point, nImageIndex is the index of the first button following the selection which has a glyph

	if(trans.nStyle & TBBS_GLYPH)
	{
		if (nImageIndex == m_nCount)
			nImageIndex = m_nTiles;
		else if (m_nCount > 0)
			nImageIndex = pTBB[nImageIndex].iImage;
		
		if (!ShiftImage(nImageIndex, 1, &trans))
			goto cleanup;
		else
			bShiftImage=TRUE;

		// because we just added a glyphed button, we know we are a glyphed bar
		SetGlyphStatus(cGlyphsPresent);
	}

	// Update the data.
	for (iButton = 0; iButton <= m_nCount; iButton++, pTBBNext++, iDestButton++)
	{
		if (iButton != nIndex)
		{
			*pTBBNext = *pTBB++;
			if(bNeedExtra && pExtra)
			{
				*pExtraNext = *pExtra++;
			}


			if (bShiftImage && 
				iButton > nIndex &&
				(pTBBNext->nStyle & TBBS_GLYPH) != 0)
			{
				pTBBNext->iImage++;
			}
		}
		else
		{
			if (gap == gapBefore && nIndex > 0 &&
				((pTBBNext - 1)->nStyle & TBBS_SEPARATOR) == 0)
			{
				pTBBNext->nID = ID_SEPARATOR;
				pTBBNext->nStyle = TBBS_SEPARATOR;
				pTBBNext->iImage = m_cxDefaultGap + 2;
				if(bNeedExtra)
				{
					pExtraNext->Create();
					pExtraNext++;
				}
				pTBBNext++;
				iDestButton++;
			}
				
			iInsertedAt=iDestButton;
			pTBBNext->nID = trans.nID;
			// remove extruded style in here, in case along the way the button picked it up.
			pTBBNext->nStyle = (trans.nStyle) & (~TBBS_EXTRUDED);
			pTBBNext->iImage = nImageIndex;
			if(bNeedExtra)
			{
				*pExtraNext=newExtra;
			}
			
			if (bReplace)
			{
				pTBB++; iButton++;
				if(bNeedExtra && pExtra)
				{
					pExtra++;
				}
			}
			
			if (gap == gapAfter && nIndex < m_nCount &&
				(pTBB->nStyle & TBBS_SEPARATOR) == 0)
			{
				pTBBNext++;     
				iDestButton++;
				pTBBNext->nID = ID_SEPARATOR;
				pTBBNext->nStyle = TBBS_SEPARATOR;
				if(bNeedExtra)
				{
					pExtraNext++;
					pExtraNext->Create();
				}
				pTBBNext->iImage = m_cxDefaultGap + 2;
			}
		}
		if(bNeedExtra)
		{
			pExtraNext++;
		}
	}

	m_nCount=(pTBBNext - pTBBNew);

	if (m_pData != NULL)
		free(m_pData);
	m_pData = pTBBNew;

	if (HasButtonExtra())
		delete [] m_pButtonExtra;
	m_pButtonExtra = pExtraNew;

	ASSERT_VALID(this);

	return iInsertedAt;

// If we failed cleanup, may be somewhat complex, so we handle it here,
// using a goto (only way to get to this control path). 

cleanup:
	if (pTBBNew != NULL)
		free(pTBBNew);

	if (pExtraNew != NULL)
		free((void*) pExtraNew);
		
	newExtra.Destroy();

	// allow callers to detect failure
	return -1;
}

//      CCustomBar::Empty
//              Deletes data, and image well, and sets relavant counts to 0.

void CCustomBar::Empty()
{
	if (m_pData != NULL)
	{
		m_nCount = 0;
		free(m_pData);
		m_pData = NULL;
	}

	if (HasButtonExtra())
	{
		delete [] m_pButtonExtra;
		m_pButtonExtra = NULL;
	}

	if (m_hbmImageWell != NULL)
	{
		m_nTiles = 0;
		::DeleteObject(m_hbmImageWell);
		m_hbmImageWell = NULL;
	}

	// because we just cleared the bar, we know we are an unglyphed bar
	SetGlyphStatus(cGlyphsAbsent);
}

//      CCustomBar::RemoveWindows
//              Removes all windows referenced in m_pData.
void CCustomBar::RemoveWindows()
{
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		if (pTBB->nStyle & TBBS_HWND)
		{
			ASSERT(GetButtonExtra(iButton)!=NULL);
			HWND hwndControl=EditButtonExtra(iButton)->GetControl();
			EditButtonExtra(iButton)->SetControl(NULL);
			RemoveControl(hwndControl);
			pTBB->nStyle &=~(TBBS_HWND|TBBS_SIZABLE);
		}
	}
}


//      CCustomBar::RemoveExtra
//              Removes all extra information for the bar
void CCustomBar::RemoveExtra()
{
	RemoveWindows();

	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		if(pTBB->nStyle & TBBS_TEXTUAL)
		{
			ASSERT(GetButtonExtra(iButton)!=NULL);
			EditButtonExtra(iButton)->SetLabel("");
			pTBB->nStyle &=~(TBBS_TEXTUAL|TBBS_CUSTOMTEXT);
		}
		if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
		{
			// there doesn't have to be a glyph, so we must be careful
			if(HasButtonExtra())
			{
				if(GetButtonExtra(iButton)->GetGlyph())
				{
					HBITMAP hbmCustom=EditButtonExtra(iButton)->GetGlyph();
					EditButtonExtra(iButton)->SetGlyph(NULL);
					::DeleteObject(hbmCustom);
					pTBB->nStyle &=~TBBS_CUSTOMBITMAP;
				}
			}
		}
	}
}

//      CCustomBar::IsGap
//              Determines whether a separator is located at the given index.

BOOL CCustomBar::IsGap(int nIndex)
{
	if (nIndex < 0 || nIndex >= m_nCount)
		return FALSE;
	else
		return ((((AFX_TBBUTTON*)m_pData) + nIndex)->nStyle & TBBS_SEPARATOR) != 0;
}

BOOL CCustomBar::IsValidCtrlSize(CWnd* pWnd)
{
	CRect rectClient, rectCtrl;
	GetClientRect(rectClient);
	pWnd->GetWindowRect(rectCtrl);

	return (rectCtrl.Width() <=
		rectClient.Width() - GetLeftBorder(orNil) - GetRightBorder(orNil));
}

// This decides the HT code for a bar expansion at a given bar location
UINT CCustomBar::GetExpansionConstraint(const CRect &rect, ORIENTATION *pOrBar, BOOL bUseOrient/*=FALSE*/)
{
	CRect rectClient, rectWindow;
	GetClientRect(rectClient);
	GetWindowRect(rectWindow);

	ORIENTATION orBar;
	if(bUseOrient)
	{
		ASSERT(pOrBar);
		orBar=*pOrBar;
	}
	else
	{
		orBar= GetOrient();
	}
		
	// Treat undocked but dock sized windows as if they were docked,
	if (orBar == orNil)
	{
		if (rectWindow.Height() == GetHSize(orHorz).cy)
			orBar = orHorz; // Force single row of buttons.
		else if (rectWindow.Width() == GetVWidth())
			orBar = orVert; // Force single column of buttons.
	}

	UINT nHTSize = HTRIGHT; // Sizing width restricted.
	if (orBar == orHorz || (orBar == orNil &&
		(rect.left <= rectClient.left || rect.right >= rectClient.right)))
	{
		nHTSize = HTBOTTOM;     // Sizing height restricted.
	}

	if(pOrBar)
	{
		*pOrBar=orBar;
	}

	return nHTSize;
}

//      CCustomBar::GetItemRect
//              Override of CToolbar function to support sizable toolbars.

void CCustomBar::GetItemRect(int nIndex, LPRECT lpRect, ORIENTATION or) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0 && nIndex < m_nCount);
	ASSERT(AfxIsValidAddress(lpRect, sizeof(RECT)));

	CRect rect;
	BOOL bWrapped = FALSE;
	
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton <= nIndex; iButton++, pTBB++)
	{
		EnumItemRects(iButton, rect, bWrapped, or);
	}
	
	::CopyRect(lpRect, rect);
}

//      CCustomBar::DoPaint
//              Override of CToolbar function to support sizable toolbars.
//              Also draws selection for toolbar customizing.

void CCustomBar::DoPaint(CDC* pDC)
{
	ASSERT_VALID(this);
	ASSERT_VALID(pDC);

	CControlBar::DoPaint(pDC);      // draw border
	DrawGrabber(pDC);
	BOOL bTextInitialised=FALSE;    // used to ensure that time is not wasted initialising the
									// device context for font drawing unless actually required

	// these are only valid when bTextInitialised is true. And then they contain the values
	// to restore at the end of the routine.
	CFont *pOldFont=NULL;                   
	UINT oldAlign=0;
	
	if (m_nCount == 0)
		return;

	DrawState ds;
	if (m_nTiles > 0 && !PrepareDrawButton(ds))
		return;     // something went wrong

	CRect rect;
	CWnd* pWndChild = GetTopWindow();
	CToolCustomizer* pCustomizer = GetCustomizer();

	ORIENTATION or=GetOrient();

	CSize sizeButton=GetButtonSize(or);

	if (pCustomizer != NULL && pCustomizer->m_pSelectBar->GetRealObject() == this)
	{
		// If we have the selection, update window controls so that we
		// won't paint over the selection.  We paint in the same order
		// as windows.  This is expensive and ugly, so we only do it
		// if we really need to.

		BOOL bUpdateAllControls = FALSE;
		CRect rectSel, rectWnd;

		GetItemRect(pCustomizer->m_nSelectIndex, rectSel, or);
		ClientToScreen(rectSel);

		while (pWndChild != NULL)
		{
			pWndChild->GetWindowRect(rectWnd);
			if (pWndChild->IsWindowVisible() &&
				rect.IntersectRect(rectWnd, rectSel))
			{
				bUpdateAllControls = TRUE;
				break;
			}
			pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
		}

		if (bUpdateAllControls)
		{
			while (pWndChild != NULL)
			{
				pWndChild->GetWindowRect(rectWnd);
				if (pWndChild->IsWindowVisible())
					pWndChild->UpdateWindow();
				pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
			}
		}
	}

	BOOL bWrapped = FALSE;
	
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		EnumItemRects(iButton, rect, bWrapped, or);
		
		if(pTBB->nStyle & TBBS_INVISIBLE)
		{
			continue;
		}

		if (::RectVisible(pDC->m_hDC, &rect))
		{
			ASSERT(pTBB != NULL);
			if ((pTBB->nStyle & (TBBS_SEPARATOR|TBBS_TEXTUAL)) == 0 &&
				!IsVisibleControl(iButton))
			{
				DrawButton(pDC, rect.left, rect.top,
					pTBB->iImage, pTBB->nStyle
#ifdef AUTOUPDATE_BUTTONS
					);
#else
					& ~TBBS_DISABLED);
#endif
			}

			if (pTBB->nStyle & TBBS_SEPARATOR)
			{
				int cSep = (pTBB->iImage - 1) / 2;
				if (or == orVert)
				{
					pDC->FillSolidRect(rect.left, rect.top + cSep,
						sizeButton.cx, 1, globalData.clrBtnShadow);
					pDC->FillSolidRect(rect.left, rect.top + cSep + 1,
						sizeButton.cx, 1, globalData.clrBtnHilite);
				}
				else // orNil has same painting style as orHorz
				{
					pDC->FillSolidRect(rect.left + cSep,     rect.top,
						1, sizeButton.cy, globalData.clrBtnShadow);
					pDC->FillSolidRect(rect.left + cSep + 1, rect.top,
						1, sizeButton.cy, globalData.clrBtnHilite);
				}
				// REVIEW: if sep at end of line, paint horz instead.
			}

			if(pTBB->nStyle & TBBS_TEXTUAL)
			{
				if(!bTextInitialised)
				{
					pOldFont=pDC->SelectObject(GetTextFont(GetOrient()));
					bTextInitialised=TRUE;
				}

				// set the 'button size to the width of this button. This will cause the
				// DrawButton routine to draw correctly. Must restore it afterwards
				CSize oldButtonSize=m_sizeButton;
				CSize oldImageSize=m_sizeImage;

				// calculate 'fake' image and button widths that correspond to this button.
				m_sizeImage.cx=rect.Width()-(oldButtonSize.cx-oldImageSize.cx);
				m_sizeButton.cx=rect.Width();
				m_sizeImage.cy=rect.Height()-(oldButtonSize.cy-oldImageSize.cy);
				m_sizeButton.cy=rect.Height();

				// draw the frame, and get coordinates for the text
				CRect drawBounds;
				DrawButton(pDC, rect.left, rect.top, pTBB->iImage, pTBB->nStyle, TRUE, &drawBounds);

				// restore button and image sizes
				m_sizeButton=oldButtonSize;
				m_sizeImage=oldImageSize;

				// determine colours
				COLORREF oldBack=pDC->SetBkColor(globalData.clrBtnFace);

				// if it's got a drop arrow, then place the text within the right/bottom portion of the button
				int nArrowWidth=0; 
				int nArrowHeight=0;
				HBITMAP hbmArrow=NULL;
				
				if(     (pTBB->nStyle & TBBS_MENU)!=0 &&
					(GetBarStyle() & CTBRS_MAINMENU)==0)
				{
					if(pTBB->nStyle & TBBS_DISABLED)
					{
						hbmArrow=GetDisabledMenuArrow(or);
					}
					else
					{
						hbmArrow=GetMenuArrow(or);
					}

					// figure the size of the bitmap
					BITMAP bmp;
					::GetObject(hbmArrow, sizeof(bmp), &bmp);

					nArrowWidth=bmp.bmWidth;
					nArrowHeight=bmp.bmHeight;
				}
				int nGlyphWidth=0;
				int nGlyphHeight=0;
				if( pTBB->nStyle & TBBS_GLYPH)
				{
					nGlyphWidth=m_sizeImage.cx;
					nGlyphHeight=m_sizeImage.cy;
				}

				UINT oldAlign;

				CSize stringHeight;
				MeasureString(iButton, stringHeight, or); 

				UINT MenuTextFlags = GLOBAL_DATA::e_mtoCenterAlign ;
				if(or==orVert)
				{
					// Text is vertical.
					MenuTextFlags |= GLOBAL_DATA::e_mtoVertical ;

					// Adjust the boundary.
					drawBounds.top+=nGlyphHeight;
					drawBounds.bottom-=nArrowHeight;
					int dx=(drawBounds.Width()-stringHeight.cx)/2;
					drawBounds.left+=dx;
					drawBounds.right-=dx;
				}
				else
				{
					// Adjust the boundary
					drawBounds.left+=nGlyphWidth;
					drawBounds.right-=nArrowWidth;
					int dy=(drawBounds.Height()-stringHeight.cy)/2;
					drawBounds.top+=dy;
					drawBounds.bottom-=dy;
				}

				COLORREF oldText ;
				if(pTBB->nStyle & TBBS_DISABLED) 
				{
					// Text is disabled.
					MenuTextFlags |= GLOBAL_DATA::e_mtoDisabled ;
				}
				else
				{
					// Text color is not set by MenuTextOut.
					oldText=pDC->SetTextColor(globalData.clrBtnText);
				}

				globalData.MenuTextOut(pDC, &drawBounds, 
								GetButtonExtra(iButton)->GetLabel(), 
								MenuTextFlags);

				// Cleanup...
				if((pTBB->nStyle & TBBS_DISABLED)==0) 
				{
					pDC->SetTextColor(oldText);
				}

				if(nArrowWidth>0)
				{
					// need to draw dropdown menu button
					CDC dcArrow;
					dcArrow.CreateCompatibleDC( pDC );
					ASSERT(hbmArrow!=NULL);
					CBitmap *pOldBitmap = dcArrow.SelectObject(CBitmap::FromHandle(hbmArrow));

					// vertically centre arrow, and put it to the right of the text
					CPoint drawArrow;
					
					if(or==orVert)
					{
						drawArrow=CPoint(drawBounds.left+(drawBounds.Width()-nArrowWidth)/2, 
									 drawBounds.bottom);
					}
					else
					{
						drawArrow=CPoint(drawBounds.right, 
									 drawBounds.top+(drawBounds.Height()-nArrowHeight)/2);
					}

					// draw it
					pDC->BitBlt(drawArrow.x, drawArrow.y, nArrowWidth,nArrowHeight, &dcArrow, 0, 0, SRCCOPY);

					dcArrow.SelectObject( pOldBitmap );
				}

				if(nGlyphWidth>0)
				{
					CPoint drawGlyph;

					if(or==orVert)
					{
						drawGlyph=CPoint(drawBounds.left+(drawBounds.Width()-nGlyphWidth)/2, 
									 drawBounds.top-m_sizeImage.cy);
					}
					else
					{
						drawGlyph=CPoint(drawBounds.left-m_sizeImage.cx, 
									 drawBounds.top+(drawBounds.Height()-nGlyphHeight)/2);
					}

					DrawButtonGlyph(pDC, drawGlyph.x, drawGlyph.y, CPoint(0,0), pTBB->iImage, pTBB->nStyle, sizeButton, m_sizeImage, s_hDCGlyphs, s_hDCMono);
				}

				pDC->SetBkColor(oldBack);
			}

			if (pCustomizer != NULL &&
				pCustomizer->m_pSelectBar->GetRealObject() == this &&
				pCustomizer->m_nSelectIndex == iButton)
			{
				COLORREF crBk = pDC->SetBkColor(RGB(0xFF, 0xFF, 0xFF));
				COLORREF crFG = pDC->SetTextColor(RGB(0, 0, 0));
		
				pCustomizer->DrawSelection(pDC);

				pDC->SetBkColor(crBk);
				pDC->SetTextColor(crFG);
			}
		}
	}
	
	// Remember whether we drew these controls
	if(IsMDIHost())
	{
		DrawMDIControls(pDC);
		if(m_nMDITrack==cMDINotDrawn)
		{
			m_nMDITrack=cMDINoButton;
		}
	}
	else
	{
		m_nMDITrack=cMDINotDrawn;
	}

	if (m_nTiles > 0)
		EndDrawButton(ds);

	// clean up context
	if(bTextInitialised)
	{
		pDC->SelectObject(pOldFont);
		pDC->SetTextAlign(oldAlign);
	}
}

//      CCustomBar::HitTest
//              Override of CToolbar function to support sizable toolbars.

int CCustomBar::HitTest(CPoint point, BOOL bCheckWindow) const // in window relative coords
{
	if(bCheckWindow)
	{
		// always return -1 if the point isn't inside our window
		CPoint ptScreen=point;
		ClientToScreen(&ptScreen);
		CWnd *pWndHit=CWnd::WindowFromPoint(ptScreen);
		if(pWndHit->GetSafeHwnd()!=this->GetSafeHwnd() && !IsChild(pWndHit))
		{
			return -1;
		}
	}

	CRect rect;
	BOOL bWrapped = FALSE;
	
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	ORIENTATION or=GetOrient();
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		EnumItemRects(iButton, rect, bWrapped, or);
		
		if (point.x < rect.left && point.y < rect.top)
			return -1;      // we have passed the point.
			
		ASSERT(pTBB != NULL);
		if ((pTBB->nStyle & TBBS_SEPARATOR) == 0)
		{
			if (rect.PtInRect(point))
				return iButton; // Hit!
		}
	}
	return -1;      // nothing hit
}

//      CCustomBar::SizeTest
//              Variant on HitTest, to determine whether the given point lies within
//              an active sizing region.  We must be in customize mode, with the
//              sizable control selected for this to return positive.

int CCustomBar::SizeTest(CPoint point)
{
	CToolCustomizer* pCustomizer = GetCustomizer();
	if (pCustomizer != NULL && pCustomizer->m_pSelectBar->GetRealObject() == this)
	{
		ORIENTATION or = GetOrient();
		int nIndex = HitTest(point);
		
		if (or != orVert &&     // No sizing in vert docks.
			!pCustomizer->m_pSelectBar->IsInDialog() &&
			pCustomizer->m_nSelectIndex == nIndex &&
			(GetButtonStyle(nIndex) & TBBS_SIZABLE) != 0)
		{
			ASSERT(GetButtonStyle(nIndex) & TBBS_HWND);
			if (!::IsWindowVisible(GetButtonExtra(nIndex)->GetControl()))
				return -1;

			CRect rect;
			GetItemRect(nIndex, rect, or);
			rect.left = rect.right - g_mt.cxFrame;
			
			if (rect.PtInRect(point))
				return nIndex;
		}
	}
	
	return -1;
}

//      CCustomBar::IndexFromPoint
//              Returns the insertion index for a button based on the specified point
//              If no intersection is found, then we return either the first or last
//              button in the row that contains the rect's center.  If the mid point
//              is within a separator, then we return the separator index.

// pButtonRect contains the rect of the button with the index that we actually matched.

// These debugging aids help one trace problems with index from point, since one often needs to see the results of several
// calls to spot the inconsistency.
#if 0
#define IFP_TRACE(msg) TRACE0(msg "\n\r") 
#define IFP_TRACE_PT(msg, pt) TRACE0(msg); TRACE2("x: %d, y: %d\n\r", pt.x, pt.y)
#define IFP_TRACE_IRECT(msg, index, rect) TRACE0(msg); TRACE1("n: %d,", index); TRACE2("l: %d, t: %d, ", rect.left, rect.top); TRACE2("b: %d, r: %d\n\r", rect.right, rect.bottom);
#else
#define IFP_TRACE(msg)
#define IFP_TRACE_PT(msg, pt)
#define IFP_TRACE_IRECT(msg, index, rect)
#endif

int CCustomBar::IndexFromPoint(const CPoint& pt, CRect *pButtonRect)
{
	int nyRowFirst;
	int nRowFirst = -2, nRowLast = -2;
	int nIndex=-2;
	CRect rectOld, rectTest;
	CRect rectFirst, rectRowFirst, rectRowLast, rectMatch;
	BOOL bWrapped = FALSE;
	int iButtonOld=-1;
	BOOL bFoundVisible=FALSE;

	IFP_TRACE_PT("Starting IndexFromPoint", pt);
	
	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	ORIENTATION or=GetOrient();
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		EnumItemRects(iButton, rectTest, bWrapped, or);
		
		IFP_TRACE_IRECT("Button ", iButton, rectTest);

		if((pTBB->nStyle & TBBS_INVISIBLE)!=0)
		{
			// skip all invisibles
			continue;
		}

		if (!bFoundVisible)
		{
			rectFirst = rectOld = rectTest;
			IFP_TRACE_IRECT("Initial ", iButton, rectFirst);
			bFoundVisible=TRUE;
		}

		if(pt.y<rectTest.top && pt.x<rectTest.left)
		{
			break;
		}       
		
		ASSERT(pTBB != NULL);

		if (rectTest.bottom > pt.y)
		{
			if (nRowFirst == -2)
			{
				nRowFirst = iButtonOld;
				nyRowFirst = rectTest.bottom;
				rectRowFirst=rectOld;
				IFP_TRACE_IRECT("RowFirst ", nRowFirst, rectRowFirst);
			}
			else if (nRowLast == -2 && rectTest.top > nyRowFirst)
			{
				rectRowLast=rectTest;
				nRowLast = iButton;
				IFP_TRACE_IRECT("RowFirst ", nRowLast, rectRowLast);
			}
		}
		
		if (rectTest.PtInRect(pt))
		{
			CPoint ptCenter=rectTest.CenterPoint();
			IFP_TRACE_PT("IndexFromPoint Center ", ptCenter);

			BOOL bNext=FALSE;

			if(or==orVert)
			{
				if(pt.y>ptCenter.y)
				{
					bNext=TRUE;
				}
			}
			else
			{
				if(pt.x>ptCenter.x)
				{
					bNext=TRUE;
				}
			}

			if(bNext)
			{
				nIndex=iButton;
				rectMatch=rectTest;
			}
			else
			{
				nIndex=iButtonOld;
				rectMatch=rectOld;
			}
			IFP_TRACE_IRECT("Match", nIndex, rectMatch);
			break;
		}

		// only track the previous visible button
		if((pTBB->nStyle & TBBS_INVISIBLE)==0)
		{
			rectOld = rectTest;
			iButtonOld=iButton;
		}
	}
	if (nIndex!=-2)
	{
		if(pButtonRect)
		{
			*pButtonRect=rectMatch;
		}
		IFP_TRACE("Return match\n\r");
		return nIndex;
	}

	// hold final rect in rectMatch
	rectMatch=rectTest;

	// no intersection, we must be on the fringes somewhere
	GetClientRect(rectTest);
	if ((or!=orVert && pt.y < rectFirst.top) ||
		(or==orVert && pt.x < rectFirst.left))
	{
		if(pButtonRect)
		{
			*pButtonRect=rectFirst;
		}
		IFP_TRACE("Return first");
		return -1;
	}

	if ((or!=orVert && pt.y > rectTest.bottom) ||
		(or==orVert && pt.x > rectTest.right))
	{
		if(pButtonRect)
		{
			*pButtonRect=rectMatch;
		}
		IFP_TRACE("Return match");
		return m_nCount-1;
	}

	if ((or!=orVert && pt.x < rectTest.left) ||
		(or==orVert && pt.y < rectTest.top))
	{
		if(pButtonRect)
		{
			*pButtonRect=rectRowFirst;
		}
		IFP_TRACE("Return rowfirst");
		return nRowFirst;
	}

	if(nRowLast!=-2)
	{
		if(pButtonRect)
		{
			*pButtonRect=rectRowLast;
		}
		IFP_TRACE("Return rowlast");
		return nRowLast;
	}
	else
	{
		if(pButtonRect)
		{
			*pButtonRect=rectMatch;
		}
		IFP_TRACE("Return match/2");
		return m_nCount-1;
	}
}

//      CCustomBar::Fit
//              Returns the best size for the toolbar, given an approximate width.

CSize CCustomBar::Fit(int nWidth, ORIENTATION or)
{
	if (m_nCount == 0)
		return m_sizeFixedLayout;
		
	CSize size(0, 0);
	CRect rect;
	CRect rectClient(g_mt.cxBorder, g_mt.cyBorder, nWidth - g_mt.cxBorder,
		m_sizeMaxLayout.cy - g_mt.cyBorder);
	BOOL bWrapped = FALSE;
	
	for (int iButton = 0; iButton < m_nCount; iButton++)
	{
		EnumItemRects(iButton, rect, bWrapped, or, rectClient);
		if (!IsGap(iButton))
		{
			size.cx = max(size.cx, rect.right);
			size.cy = max(size.cy, rect.bottom);
		}

		// on the last button, we must account for the mdi controls
		if(iButton==m_nCount-1)
		{
			int nMDIRight=rect.right+GetRightMDIArea(or);
			if(nMDIRight > rectClient.right)
			{
				// System buttons caused a wrap, so pretend that the last button is 1 row higher than it really is.
				CSize sizeButton=GetButtonSize(or);
				size.cy+=sizeButton.cy;
			}
			else
			{
				size.cx=max(size.cx, nMDIRight);
			}
		}
	}

	size.cx += GetRightBorder(or) + g_mt.cxBorder;
	size.cy += GetBottomBorder(or) + g_mt.cyBorder;

	return size;
}

//      CCustomBar::EnumItemRects
//              Because of the way toolbars are sized, getting the rectangle of a
//              given item is a fairly complex task.  This function allows item rect
//              enumeration, within a given toolbar rect (lpRect), by incrementing the
//              item index, and passing in the last rect, and wrapped state bool and a
//              bar orientation

void CCustomBar::EnumItemRects(int nItem, CRect& rect, BOOL& bWrapped, ORIENTATION or,
	LPCRECT lpRect /*=NULL*/) const
{
	ASSERT(nItem < m_nCount);

	CSize sizeButton=GetButtonSize(or);

	// true when we've just been forced to the next line by a vertical text button
	BOOL bVerticalWrapped=FALSE;

	AFX_TBBUTTON* pTBB = ((AFX_TBBUTTON*)m_pData) + nItem;

	// If no rect is given, use the window's client rect.
	CRect rectClient;

	if (lpRect != NULL) {
		rectClient = *lpRect;
	} else {
		GetClientRect(rectClient);

		int yScroll=GetScrollPos(SB_VERT);
		int xScroll=GetScrollPos(SB_HORZ);
		rectClient.OffsetRect(-xScroll,-yScroll);
	}

	rectClient.left += GetLeftBorder(or);
	rectClient.right -= m_cxRightBorder;

	rectClient.top += GetTopBorder(or);

	// determine if this is the very first item on the bar, or the first visible one
	BOOL bFirst=TRUE;
	int nPrev=nItem-1;

	// After the loop, this will point to the previous visible toolbar button before the current one.
	AFX_TBBUTTON* pTBBPrev = ((AFX_TBBUTTON*)m_pData) + nItem-1;
	while(nPrev>=0)
	{
		if((pTBBPrev->nStyle & TBBS_INVISIBLE)==0)
		{
			bFirst=FALSE;
			break;
		}
		--pTBBPrev;
		--nPrev;
	}
	
	if (!bFirst)
	{
		if(pTBB->nStyle & TBBS_INVISIBLE)
		{
			if(or!=orVert)
			{
				rect.left=rect.right;
			}
			else
			{
				rect.top=rect.bottom;
			}
			return;
		}

		// if the last item was a tall vertical item, we must go underneath, so we have wrapped
		if(	rect.Height()>sizeButton.cy ||
			(rect.Height()==0 && or==orVert))
		{
			// possibly a vertical button, but check
			if(pTBBPrev->nStyle & TBBS_TEXTUAL)
			{
				rect.top = rect.bottom;
				rect.left -= (sizeButton.cx - rect.Width()) / 2;      // Re-align to col.

				bVerticalWrapped=TRUE;
			}
		}

		if(!bVerticalWrapped)
		{
			if(or!=orVert)
			{
				rect.left = rect.right;

				// text buttons are always top aligned, so this is not necessary. We only need it for window controls
				if((pTBBPrev->nStyle & TBBS_TEXTUAL)==0)
				{
					rect.top -= (sizeButton.cy - rect.Height()) / 2;      // Re-align to row.
				}
			}
			else
			{
				rect.top=rect.bottom;
			}
		}
	}
	else
	{
		rect.left = rectClient.left+GetLeftMDIArea(or);
		rect.top = rectClient.top+GetTopMDIArea(or);

		// invisible buttons exist theoretically with zero size but the right height

		if(pTBB->nStyle & TBBS_INVISIBLE)
		{
			if(or!=orVert)
			{
				rect.right=rect.left;
				rect.bottom=rect.top + sizeButton.cy;
			}
			else
			{
				rect.bottom=rect.top;
				rect.right=rect.left+sizeButton.cx;
			}
			return;
		}
	}

	if (pTBB->nStyle & TBBS_SEPARATOR)
	{
		if(!bVerticalWrapped)
		{
			if(or!=orVert)
			{
				rect.right = rect.left + m_cxDefaultGap;
				rect.bottom = rect.top + sizeButton.cy;
			}
			else
			{
				rect.bottom= rect.top+ m_cxDefaultGap; // Not a typo. Reversed bar, so we use x.
				rect.right= rect.left+ sizeButton.cx;
			}
		}
	}
	else
	{
		if (pTBB->nStyle & TBBS_TEXTUAL) 
		{
			/* function is const, and must remain that way as it is called from 
			const framework functions. But to get a DC we need a non-cost window
			pointer. Nasty, but I can't see any other way to measure this text. 
			I think it's safe to say that rom-ability is not an issue here.
			martynl 08Apr96
			*/
			CCustomBar *pVariableThis=const_cast<CCustomBar*>(this);

			// determine size of string if drawn in that font
			CSize stringSize;
			pVariableThis->MeasureString(nItem, stringSize, or);

			// the size from which the text height is derived
			CSize sizeTextHeight; 
			sizeTextHeight=sizeButton;

			if(or==orVert)
			{
				rect.right=rect.left+sizeTextHeight.cx;
				rect.bottom = rect.top + stringSize.cy + (sizeButton.cy - m_sizeImage.cy);
			}
			else
			{
				rect.right = rect.left + stringSize.cx + (sizeButton.cx - m_sizeImage.cx);
				rect.bottom = rect.top + sizeTextHeight.cy; 
			}
		}
		else if ((pTBB->nStyle & TBBS_HWND) == 0)
		{
			rect.right = rect.left + sizeButton.cx;
			rect.bottom = rect.top + sizeButton.cy;
		}
		else 
		{
			CRect rectTmp;
			
			::GetWindowRect(GetButtonExtra(nItem)->GetControl(), rectTmp);
			if (or==orVert)
			{
				rect.right = rect.left + sizeButton.cx;
				rect.bottom = rect.top + sizeButton.cy;
			}
			else
			{
				rect.top += (sizeButton.cy - rectTmp.Height()) / 2;
				rect.right = rect.left + rectTmp.Width();
				rect.bottom = rect.top + rectTmp.Height();
			}
		}
	}

	if (nItem == 0)
		return;
	BOOL bInGroup = (((pTBB - 1)->nStyle & TBBS_SEPARATOR) == 0);

	if(!bVerticalWrapped && or!=orVert)
	{
		if (bInGroup && rect.left != rectClient.left)
		{
			rect.left -= m_cxSharedBorder; rect.right -= m_cxSharedBorder;  // overlap
		
			if (rect.right > rectClient.right)
			{
				bWrapped = TRUE;
				rect.OffsetRect(rectClient.left - rect.left,
					sizeButton.cy - m_cySharedBorder);    // overlap
			}
				
		}
		else
		{
			int nGroupEnd = rect.right;     // no overlap on last button.
			
			// Check the extent of this group.
			while (++nItem < m_nCount && ((++pTBB)->nStyle & TBBS_SEPARATOR) == 0)
			{
				if (pTBB->nStyle & TBBS_INVISIBLE)
				{
					continue;
				}

				if ((pTBB->nStyle & (TBBS_TEXTUAL|TBBS_HWND)) == 0)
				{
					nGroupEnd += sizeButton.cx - m_cxSharedBorder;  // overlap
				}
				else
				{
					if(pTBB->nStyle & TBBS_TEXTUAL)
					{
						CSize stringSize;

						// see comment above about this cast
						CCustomBar *pVariableThis=const_cast<CCustomBar*>(this);

						pVariableThis->MeasureString(nItem, stringSize, orHorz);

						nGroupEnd+= sizeButton.cx-m_sizeImage.cx+stringSize.cx;
					}
					else
					{
						CRect rectTmp;
						::GetWindowRect(GetButtonExtra(nItem)->GetControl(), rectTmp);
						
						if (rectTmp.Width() > rectClient.Width())
							nGroupEnd += sizeButton.cx - m_cxSharedBorder;  // overlap
						else
							nGroupEnd += rectTmp.Width() - m_cxSharedBorder;  // overlap
					}
				}
			}
				
			if (nGroupEnd > rectClient.right || bWrapped)
			{
				bWrapped = FALSE;
				rect.OffsetRect(rectClient.left - rect.left,
					sizeButton.cy + m_cyDefaultGap);
			}
		}
	}
}

// This retrieves a pointer to the appropriate font object
CFont *CCustomBar::GetTextFont(ORIENTATION or)
{
	ASSERT_VALID(this);

	if(or==orVert)
	{
		if((m_dwStyle & CTBRS_MAINMENU)!=0)
		{
			// menu bars use the menu font
			return globalData.GetMenuVerticalFont();
		}
		else
		{
			return CFont::FromHandle(globalData.GetButtonVerticalFont(theApp.m_bLargeToolBars));
		}
	}
	else
	{
		if((m_dwStyle & CTBRS_MAINMENU)!=0)
		{
			// menu bars use the menu font
			return globalData.GetMenuFont(FALSE);
		}
		else
		{
			return CFont::FromHandle(globalData.GetButtonFont(theApp.m_bLargeToolBars));
		}
	}
}

HBITMAP CCustomBar::GetMenuArrow(ORIENTATION or)
{
	ASSERT_VALID(this);

	if(or==orVert)
	{
		return globalData.GetMenuArrowVertical();
	}
	else
	{
		return globalData.GetMenuArrow();
	}
}

HBITMAP CCustomBar::GetDisabledMenuArrow(ORIENTATION or)
{
	ASSERT_VALID(this);

	if(or==orVert)
	{
		return globalData.GetMenuArrowVerticalDisabled();
	}
	else
	{
		return globalData.GetMenuArrowDisabled();
	}
}

// default version gets the menu text
void CCustomBar::AddText(int nIndex)
{
	AFX_TBBUTTON *pTBB=_GetButtonPtr(nIndex);

	LPCSTR pText;

	theCmdCache.GetCommandString(pTBB->nID, STRING_MENUTEXT, &pText);
	if (!pText || *pText=='\0')
	{
		theCmdCache.GetCommandString(pTBB->nID, STRING_COMMAND, &pText);
	}

	CString text(pText);
	AddText(nIndex, text, FALSE);
}

// makes the button textual, and gives it the specified label
void CCustomBar::AddText(int nIndex, const CString &text, BOOL bCustom/*=TRUE*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0 && nIndex < m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[nIndex]);
	
	ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);

	ASSERT(!text.IsEmpty());

	if(text.IsEmpty())
	{
		return;
	}

	EditButtonExtra(nIndex)->SetLabel(text);

	// modify toolbar button
	pTBB->nStyle |= TBBS_TEXTUAL;
	if(bCustom)
	{
		pTBB->nStyle |= TBBS_CUSTOMTEXT;
	}
	else
	{
		pTBB->nStyle &= ~TBBS_CUSTOMTEXT;
	}

	ASSERT_VALID(this);
}


//      CCustomBar::BltCommandBitmap
//              Used for constructing toolbar image wells.  Gets the command bitmap
//              from the command table, and blts it to the image well DC.
BOOL CCustomBar::BltCommandBitmap(HBITMAP hbmSrc, int nGlyph,
	HDC hdcDest, int nDest, HDC hdcSrc)
{
	if (nGlyph == -1)
		return FALSE;

	hbmSrc = (HBITMAP) ::SelectObject(hdcSrc, hbmSrc);

	BitBlt(hdcDest, m_sizeImage.cx * nDest, 0, m_sizeImage.cx, m_sizeImage.cy,
		hdcSrc, m_sizeImage.cx * nGlyph, 0, SRCCOPY);
	
	::SelectObject(hdcSrc, hbmSrc);
	
	return TRUE;
}

void CCustomBar::ButtonModified(int nIndex, BOOL bSized)
{
	if(bSized)
	{
		CRect rectNew;
		GetItemRect(nIndex, &rectNew, GetOrient());

		// redraw bars
		RecalcLayout(GetExpansionConstraint(rectNew));
	}
	OnButtonSize(); // REVIEW:: !!! extra bardockx func with better name
}

// remove the textual status of a button, which should already have a glyph
void CCustomBar::RemoveText(int nIndex)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0 && nIndex < m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[nIndex]);
	
	// can't be a separator
	ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);

	ASSERT((pTBB->nStyle & (TBBS_TEXTUAL | TBBS_GLYPH))!=0);

	CToolCustomizer* pCustomizer = GetCustomizer();

	int iImage=0;

	AFX_TBBUTTON* pTBBFix=((AFX_TBBUTTON *)m_pData);

	// remove the label
	RemoveTextLabel(nIndex);
}

void CCustomBar::RemoveBitmap(int nIndex)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0 && nIndex < m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[nIndex]);
	
	// can't be a separator
	ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);

	ASSERT((pTBB->nStyle & (TBBS_TEXTUAL | TBBS_GLYPH))==(TBBS_TEXTUAL | TBBS_GLYPH));

	if((pTBB->nStyle & TBBS_GLYPH)==0)
	{
		return;
	}

	// because we just deglyphed a button, we no longer know whether we are a glyphed bar
	SetGlyphStatus(cGlyphsUnknown);

	CToolCustomizer* pCustomizer = GetCustomizer();

	// do a full conversion to text
	// delete bitmap from well
	if(!ShiftImage(pTBB->iImage, -1))
	{
		return;
	}

	// delete any custom glyph
	if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
	{
		HBITMAP hbmCustom=EditButtonExtra(nIndex)->GetGlyph();
		if(hbmCustom)
		{
			::DeleteObject(hbmCustom);
			EditButtonExtra(nIndex)->SetGlyph(NULL);
		}
	}

	AFX_TBBUTTON* pTBBFix=((AFX_TBBUTTON *)m_pData)+nIndex+1;

	// adjust the iImage value for all the following buttons
	for (int iButton = nIndex+1; iButton < m_nCount; iButton++, pTBBFix++)
	{
		// If it is an image button, shift the image index by one
		if ((pTBBFix->nStyle & (TBBS_GLYPH)))
		{
			pTBBFix->iImage--;
		}
	}

	pTBB->nStyle &=~(TBBS_CUSTOMBITMAP | TBBS_GLYPH);
}

// makes a button use the a bitmap:
// There are three possible entry situations, dictated by bsSource
void CCustomBar::AddBitmap(int nIndex, BITMAPSOURCE bsSource, HBITMAP hbmCustom)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0 && nIndex < m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[nIndex]);
	
	ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);

	CToolCustomizer* pCustomizer = GetCustomizer();

	if((pTBB->nStyle & TBBS_GLYPH)==0)
	{
		// if we can't find any glyphs before here, then we'll go in first
		int iImage=0;

		AFX_TBBUTTON* pTBBFix=((AFX_TBBUTTON *)m_pData)+nIndex-1;

		// deduce the correct iImage value for this button
		for (int iButton = nIndex-1; iButton >= 0; iButton--, pTBBFix--)
		{
			// if this button has a glyph, it can tell us the correct image index
			if(pTBBFix->nStyle & TBBS_GLYPH)
			{
				iImage=pTBBFix->iImage+1;
				break;
			}
		}

		// enlarge the image well
		if (!ShiftImage(iImage, 1))
		{
			return; 
		}

		// set up image to point to new space in well
		pTBB->iImage=iImage;

		pTBB->nStyle |= TBBS_GLYPH;

		pTBBFix=((AFX_TBBUTTON *)m_pData)+m_nCount-1;

		// adjust the iImage value for all the following buttons
		for (iButton = m_nCount-1; iButton > nIndex; iButton--, pTBBFix--)
		{
			// If it is an image button, shift the image index by one
			if (pTBBFix->nStyle & TBBS_GLYPH)
			{
				pTBBFix->iImage++;
			}
		}

		// because we just glyphed a button, we know we are a glyphed bar
		SetGlyphStatus(cGlyphsPresent);
	}

	// remove custom bitmap if going
	if((pTBB->nStyle & TBBS_CUSTOMBITMAP)!=0)
	{
		if(HasButtonExtra())
		{
			HBITMAP hbmOldCustom=GetButtonExtra(nIndex)->GetGlyph();
			if(hbmOldCustom)
			{
				::DeleteObject(hbmOldCustom);
				EditButtonExtra(nIndex)->SetGlyph(NULL);
			}
		}

		pTBB->nStyle &= ~TBBS_CUSTOMBITMAP;
	}

	if(bsSource!=cBitmapSourcePackage)
	{
		// result will be a custom bitmap
		if(bsSource==cBitmapSourceClipboard)
		{
			// attempts to paste in a custom glyph from the clipboard
			GLOBAL_DATA::PasteGlyph(this, m_hbmImageWell, pTBB->iImage, m_sizeImage);
		}
		else
		{
			// copy the custom bitmap to the image well
			HDC hdcClient = ::GetDC(m_hWnd);
			HDC hdcDest = ::CreateCompatibleDC(hdcClient);
			HDC hdcSrc = ::CreateCompatibleDC(hdcClient);
			::ReleaseDC(m_hWnd, hdcClient);
			HBITMAP hbmOld = (HBITMAP) ::SelectObject(hdcDest, m_hbmImageWell);
			HBITMAP hbmOldSrc = (HBITMAP) ::SelectObject(hdcSrc, hbmCustom);

			BitBlt(hdcDest, pTBB->iImage*m_sizeImage.cx, 0, m_sizeImage.cx, m_sizeImage.cy, hdcSrc, 0, 0, SRCCOPY);

			::SelectObject(hdcDest, hbmOld);
			::SelectObject(hdcSrc, hbmOldSrc);

			::DeleteDC(hdcSrc);
			::DeleteDC(hdcDest);
		}

		pTBB->nStyle |= TBBS_CUSTOMBITMAP;
	}
	else
	{
		// copy the new bitmap to the image well
		HDC hdcClient = ::GetDC(m_hWnd);
		HDC hdcDest = ::CreateCompatibleDC(hdcClient);
		HDC hdcSrc = ::CreateCompatibleDC(hdcClient);
		::ReleaseDC(m_hWnd, hdcClient);
		HBITMAP hbmOld = (HBITMAP) ::SelectObject(hdcDest, m_hbmImageWell);

		RefreshButtonBitmap(hdcDest, hdcSrc, nIndex);

		::SelectObject(hdcDest, hbmOld);

		::DeleteDC(hdcSrc);
		::DeleteDC(hdcDest);
	}

	// allow subclasses to take any action relevant to the change of button
	OnButtonSize();

	CRect rectNew;
	GetItemRect(nIndex, &rectNew, GetOrient());

	// redraw bars
	RecalcLayout(GetExpansionConstraint(rectNew));

	ASSERT_VALID(this);
}

void CCustomBar::InsertSeparator(int nIndex)
{
	ASSERT(nIndex!=0);
	InsertButton(nIndex,*CToolCustomizer::CreateSeparatorTransfer(), FALSE, gapNil);
	CRect rectNew;
	GetItemRect(nIndex, &rectNew, GetOrient());

	RecalcLayout(GetExpansionConstraint(rectNew));
}

void CCustomBar::RemoveSeparator(int nIndex)
{
	ASSERT(nIndex!=0);

	DeleteButton(nIndex-1);
	OnDeleteSelection();
	RecalcLayout();
}

// re-get all button bitmaps, either from their packages or from their custom bitmap
void CCustomBar::RefreshButtonBitmaps()
{
	if (m_nCount == 0)
		return;

	ASSERT(m_pData != NULL && m_hbmImageWell != NULL);
		
	HDC hdcClient = ::GetDC(m_hWnd);
	HDC hdcDest = ::CreateCompatibleDC(hdcClient);
	HDC hdcSrc = ::CreateCompatibleDC(hdcClient);
	::ReleaseDC(m_hWnd, hdcClient);

	if (hdcDest == NULL || hdcSrc == NULL)
	{       
		// May RIP.
		::DeleteDC(hdcSrc);
		::DeleteDC(hdcDest);
		return;
	}

	HBITMAP hbmOld = (HBITMAP) ::SelectObject(hdcDest, m_hbmImageWell);

	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
	{
		if (pTBB->nStyle & TBBS_GLYPH)
		{
			RefreshButtonBitmap(hdcDest, hdcSrc, iButton);
		}
	}

	::SelectObject(hdcDest, hbmOld);
	::DeleteDC(hdcSrc);
	::DeleteDC(hdcDest);
}

// re-get just one bitmap
void CCustomBar::RefreshButtonBitmap(HDC hdcDest, HDC hdcSrc, int nIndex)
{
	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[nIndex]);
		
	if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
	{
		// copy or scale as appropriate
		if(     HasButtonExtra() &&
			GetButtonExtra(nIndex)->GetGlyph()!=NULL)
		{
			BITMAP bmp;
			VERIFY(::GetObject(GetButtonExtra(nIndex)->GetGlyph(), sizeof(BITMAP), &bmp));

			if(     bmp.bmHeight==m_sizeImage.cy &&
				bmp.bmWidth==m_sizeImage.cx)
			{
				BltCommandBitmap(GetButtonExtra(nIndex)->GetGlyph(), 0, hdcDest, pTBB->iImage, hdcSrc);
			}
			else
			{
				GLOBAL_DATA::ScaleBitmap(hdcDest, m_sizeImage, CPoint(m_sizeImage.cx*pTBB->iImage, 0), GetButtonExtra(nIndex)->GetGlyph(), CSize(bmp.bmWidth, bmp.bmHeight));
			}
		}
	}
	else
	{
		CPackage* pPackage;

		VERIFY((theApp.GetCommandBtnInfo(pTBB->nID, &pPackage) & (TBBS_SEPARATOR|TBBS_INVISIBLE)) == 0);

		int iGlyph;
		HBITMAP hbmWell;
		VERIFY(theApp.GetCommandBitmap(pTBB->nID, &hbmWell, &iGlyph, theApp.m_bLargeToolBars));

		BltCommandBitmap(hbmWell, iGlyph, hdcDest, pTBB->iImage, hdcSrc);
	}
}

// TRUE if a paste button bitmap operation would be legal on the currently selected button
BOOL CCustomBar::CanPasteImage()
{
	BOOL bEnable=FALSE;

	if (OpenClipboard())
	{
		UINT nClipFmt = 0;
		do
		{
			nClipFmt = EnumClipboardFormats(nClipFmt);
			
			switch (nClipFmt)
			{
			case CF_BITMAP:
			case CF_DIB:
				bEnable = TRUE;
				break;
			}
		}
		while (!bEnable && nClipFmt != 0);

		CloseClipboard();
	}

	CToolCustomizer* pCustomizer = GetCustomizer();

	// neither of these should ever be false, but for safety we check for them in the 
	// if clause as well
	ASSERT(pCustomizer!=NULL);
	ASSERT(pCustomizer->m_pSelectBar->GetRealObject()==this);

	// validate selection index
	ASSERT(pCustomizer->m_nSelectIndex>=0);
	ASSERT(pCustomizer->m_nSelectIndex<m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[pCustomizer->m_nSelectIndex]);

	if((pCustomizer!=NULL &&
		pCustomizer->m_pSelectBar!=NULL &&
		pCustomizer->m_pSelectBar->IsInDialog()) ||
	   (pTBB->nStyle & (TBBS_SEPARATOR))!=0 ||
	    IsVisibleControl(pCustomizer->m_nSelectIndex))
	{
		return FALSE;
	}
	else
	{
		return bEnable;
	}
}

// true if a reset button image operation is legal on the current selection
BOOL CCustomBar::CanResetImage()
{
	CToolCustomizer* pCustomizer = GetCustomizer();

	// neither of these should ever be false, but for safety we check for them in the 
	// if clause as well
	ASSERT(pCustomizer!=NULL);
	ASSERT(pCustomizer->m_pSelectBar->GetRealObject()==this);

	// validate selection index
	ASSERT(pCustomizer->m_nSelectIndex>=0);
	ASSERT(pCustomizer->m_nSelectIndex<m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[pCustomizer->m_nSelectIndex]);

	// can't reset if there's no glyph
	BOOL bHasGlyph=theApp.HasCommandBitmap(pTBB->nID);

	if((pCustomizer!=NULL &&
		pCustomizer->m_pSelectBar!=NULL &&
		pCustomizer->m_pSelectBar->IsInDialog()) ||
		IsVisibleControl(pCustomizer->m_nSelectIndex) ||
	   (pTBB->nStyle & (TBBS_CUSTOMBITMAP))==0 ||
	   (pTBB->nStyle & (TBBS_MENU))!=0 ||
	   !bHasGlyph)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

// true if the user is allowed to choose an image for this button
BOOL CCustomBar::CanChooseAppearance()
{
	CToolCustomizer* pCustomizer = GetCustomizer();

	// neither of these should ever be false, but for safety we check for them in the 
	// if clause as well
	ASSERT(pCustomizer!=NULL);
	ASSERT(pCustomizer->m_pSelectBar->GetRealObject()==this);

	// validate selection index
	ASSERT(pCustomizer->m_nSelectIndex>=0);
	ASSERT(pCustomizer->m_nSelectIndex<m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[pCustomizer->m_nSelectIndex]);

	if((pCustomizer!=NULL &&
		pCustomizer->m_pSelectBar!=NULL &&
		pCustomizer->m_pSelectBar->IsInDialog()) ||
		IsVisibleControl(pCustomizer->m_nSelectIndex))
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

void CCustomBar::PasteButtonImage()
{
	CToolCustomizer* pCustomizer = GetCustomizer();

	ASSERT(pCustomizer->m_pSelectBar->GetRealObject()==this);

	// validate selection index
	ASSERT(pCustomizer->m_nSelectIndex>=0);
	ASSERT(pCustomizer->m_nSelectIndex<m_nCount);

	// make a custom bitmap for this based on the clipboard
	AddBitmap(pCustomizer->m_nSelectIndex,cBitmapSourceClipboard);
	ButtonModified(pCustomizer->m_nSelectIndex, TRUE);
}

void CCustomBar::ResetButtonImage()
{
	CToolCustomizer* pCustomizer = GetCustomizer();

	ASSERT(pCustomizer->m_pSelectBar->GetRealObject()==this);

	// validate selection index
	ASSERT(pCustomizer->m_nSelectIndex>=0);
	ASSERT(pCustomizer->m_nSelectIndex<m_nCount);

	AFX_TBBUTTON* pTBB = &(((AFX_TBBUTTON*)m_pData)[pCustomizer->m_nSelectIndex]);

	ASSERT((pTBB->nStyle & (TBBS_HWND|TBBS_SEPARATOR))==0);

	BOOL bModified=FALSE;

	if(pTBB->nStyle & (TBBS_CUSTOMBITMAP))
	{
		if(theApp.HasCommandBitmap(pTBB->nID))
		{
			AddBitmap(pCustomizer->m_nSelectIndex);
			bModified=TRUE;
		}
	}
	if(pTBB->nStyle & TBBS_CUSTOMTEXT)
	{
		AddText(pCustomizer->m_nSelectIndex);
		bModified=TRUE;
	}

	if(bModified)
	{
		ButtonModified(pCustomizer->m_nSelectIndex, TRUE);
	}

}

BEGIN_MESSAGE_MAP(CCustomBar, CToolBar)
	//{{AFX_MSG_MAP(CCustomBar)
	ON_WM_KILLFOCUS()
	ON_WM_SETCURSOR()
	ON_WM_GETMINMAXINFO()
	ON_WM_SIZE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	ON_WM_MOUSEMOVE()
	ON_WM_DESTROY()
	ON_WM_VSCROLL()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
	ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
//      CCustomBar message handlers

#define CToolCmdUI COldToolCmdUI

class CCustomToolCmdUI : public CToolCmdUI        // class private to this file !
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

void CCustomToolCmdUI::Enable(BOOL bOn)
{
	CToolCmdUI::Enable(bOn);

	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nStyle=pToolBar->GetButtonStyle(m_nIndex);

	// Buttons on the menu bar are hidden when disabled
	if(	(nStyle & TBBS_MENU)!=0 &&
		(pToolBar->GetBarStyle() & CTBRS_MAINMENU)!=0)
	{
		if(bOn)
		{
			if(nStyle & TBBS_INVISIBLE)
			{
				// make it visible
				nStyle&=~TBBS_INVISIBLE;
				CCustomBar::s_bRecalcLayoutPending=TRUE;
			}
		}
		else
		{
			if((nStyle & TBBS_INVISIBLE)==0)
			{
				// make it invisible
				nStyle|=TBBS_INVISIBLE;
				CCustomBar::s_bRecalcLayoutPending=TRUE;
			}
		}
	}

	// disabled buttons can't stay extruded, and the bar must lose the capture if it had it for this button
	if(!bOn)
	{
		if(pToolBar->GetCapture()==pToolBar &&
			(pToolBar->GetCaptureIndex()==m_nIndex ||
			 pToolBar->GetCaptureIndex()==- m_nIndex - 2))
		{
			pToolBar->CancelMode();
		}

		nStyle &= ~TBBS_EXTRUDED;
	}
	
	ASSERT(!(nStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nStyle);
}

void CCustomToolCmdUI::SetCheck(int nCheck)
{
	CToolCmdUI::SetCheck(nCheck);
}

void CCustomToolCmdUI::SetText(LPCTSTR lpszNew)
{
	CToolCmdUI::SetText(lpszNew);
}

//      CCustomBar::OnUpdateCmdUI
//              Override CToolbar function, so we can enable the buttons during
//              customize mode without enabling menus/accelerators.

void CCustomBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CCustomToolCmdUI state;
	state.m_pOther = this;
	CCmdUI stateWnd;
	CWnd wndTemp;       // very temporary window just for CmdUI update
	CToolCustomizer* pCustomizer = GetCustomizer();
	s_bRecalcLayoutPending=FALSE;

#if FIND_SLOW_CMDUI
	static UINT nMaxCmdUI=1;
#endif

	state.m_nIndexMax = (UINT)m_nCount;
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax;
	  state.m_nIndex++)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(state.m_nIndex);

		if (pTBB->nStyle & TBBS_HWND)
		{
			wndTemp.m_hWnd = GetButtonExtra(state.m_nIndex)->GetControl(); // quick and dirty attach
			if ((pCustomizer == NULL || pCustomizer->m_bTemp) &&
				(pTBB->nStyle & TBBS_ENABLEWND) == 0)
			{
				
				stateWnd.m_nID = (UINT)(WORD) ::GetDlgCtrlID(wndTemp.m_hWnd);
				stateWnd.m_pOther = &wndTemp;
				stateWnd.DoUpdate(pTarget, bDisableIfNoHndler &&
					(wndTemp.SendMessage(WM_GETDLGCODE) & DLGC_BUTTON) != 0);
				// only buttons get automagically disabled
			}
			else
			{
				wndTemp.EnableWindow(TRUE);
			}
		}
		
		// Ignore pressed buttons or separators
		// Let CToolCmdUI handle disabling and repaints for Hwnds too.
		//
		if (!(pTBB->nStyle & (TBBS_PRESSED|TBBS_SEPARATOR)))
		{
			if (pCustomizer == NULL || pCustomizer->m_bTemp || (pTBB->nStyle & TBBS_MENU))
			{
				state.m_nID = pTBB->nID;
				
#if FIND_SLOW_CMDUI
				int nTick=::GetTickCount();
#endif
				state.DoUpdate(pTarget, bDisableIfNoHndler);

#if FIND_SLOW_CMDUI
				int nNewTick=::GetTickCount();

				UINT nDiffTick=nNewTick-nTick;

				// Trace if it's in the slowest 10%
				if((double) nDiffTick > (double) nMaxCmdUI * 0.9)
				{
					TRACE2("CCustomBar::OnUpdateCmdUI: Cmd %d took %d ticks.\n\r", state.m_nID, nDiffTick);
				}

				if(nDiffTick>nMaxCmdUI)
				{
					nMaxCmdUI=nDiffTick;
				}
#endif
			}
			else
			{
				UINT nNewStyle =
					GetButtonStyle(state.m_nIndex) & ~TBBS_DISABLED;
				SetButtonStyle(state.m_nIndex, nNewStyle);
			}
		}
	}

	// If invisibility was changed, we need to recalc layout
	if(s_bRecalcLayoutPending && IsWindowVisible())
	{
		ASSERT((GetBarStyle() & CTBRS_MAINMENU)!=0);
		RecalcLayout(GetExpansionConstraint(CRect(0,0,0,0), NULL));
		Invalidate();
	}

	wndTemp.m_hWnd = NULL;      // quick and dirty detach
}

//      CCustomBar::OnSetCursor
//              Override to show the size cursor in customize mode.

BOOL CCustomBar::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CToolCustomizer* pCustomizer = GetCustomizer();
	if (pCustomizer != NULL)
	{
		CPoint pt;
		::GetCursorPos(&pt);
		ScreenToClient(&pt);
		
		if (SizeTest(pt) != -1)
			::SetCursor(s_hcurVSize);
		else
			::SetCursor(::LoadCursor(NULL, IDC_ARROW));
		
		return TRUE;
	}
	
	return CToolBar::OnSetCursor(pWnd, nHitTest, message);
}

//      CCustomBar::OnLButtonDown
//              Handles the customizing calls for button moving, and control sizing.

void CCustomBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	int nIndex;
	CToolCustomizer* pCustomizer = GetCustomizer();

	if (pCustomizer == NULL)
	{
		// Update the whole toolbar.  This is over-kill, but easy to code.
		CToolBar::OnIdleUpdateCmdUI((WPARAM) FALSE, 0L);

		if(IsMDIHost())
		{
			if(CheckMDIButtons(nFlags, point))
			{
				return;
			}
		}

		nIndex = HitTest(point);

#ifndef AUTOUPDATE_BUTTONS
		if (nIndex != -1 &&
			(nStyle & TBBS_DISABLED) != 0)
		{
			MessageBeep(-1);
			return;
		}
#endif
		
		if(nIndex!=-1)
		{
			AFX_TBBUTTON* pTBB = _GetButtonPtr(nIndex);

			if((pTBB->nStyle & (TBBS_MENU|TBBS_DISABLED))==TBBS_MENU)
			{
				// draw it pressed
				pTBB->nStyle |= TBBS_PRESSED;
				InvalidateButton(nIndex);
				UpdateWindow(); // immediate feedback

				// act on the pressing
				OnButtonPressed(nIndex);

				// draw it unpressed
				pTBB->nStyle &= ~TBBS_PRESSED;
				InvalidateButton(nIndex);
			}
			else
			{
				CToolBar::OnLButtonDown(nFlags, point);
			}
		}
		else
		{
			CToolBar::OnLButtonDown(nFlags, point);
		}
	}
	else
	{
		nIndex = SizeTest(point);

		if (nIndex != -1)
		{
			ClientToScreen(&point);
			pCustomizer->DoButtonSize(point, GetProxy(), nIndex);
		}
		else if ((nIndex = HitTest(point)) != -1)
		{
			// if it's a menu button, then drop it, unless it's already dropped
			AFX_TBBUTTON *pTBB=_GetButtonPtr(nIndex);
			
			ClientToScreen(&point);
			OnCancelMode();

			BOOL bDeletePending;

			BOOL bExpandPending=FALSE;

			// close menu before dragging starts
			if(pTBB->nStyle & TBBS_MENU)
			{
				if(theCmdCache.GetMenu(pTBB->nID)->m_hWnd)
				{
					ExpandItem(nIndex, FALSE);
				}
				else
				{
					if(     s_pDroppedBar!=NULL &&
						s_nDroppedItem!=-1)
					{
						s_pDroppedBar->ExpandItem(s_nDroppedItem, FALSE);
					}
					bExpandPending=TRUE;
				}
			}
					
			if(pCustomizer->DoButtonMove(point, GetProxy(), nIndex, &bDeletePending))
			{
				// something was moved - do no more
				if(bDeletePending)
				{
					// delete ourselves tidily - after this, we're in the member function of a deleted object, so must be
					// careful to do no more
					UINT nIDWnd = (UINT) GetDlgCtrlID();
					pCustomizer->m_pManager->RemoveWnd(MAKEDOCKID(PACKAGE_SUSHI, nIDWnd));
					return;
				}
			}
			else
			{
				// no move happened
				if(pTBB->nStyle & TBBS_MENU)
				{
					if(bExpandPending)
					{
						ExpandItem(nIndex, TRUE);
					}
				}
			}
		}
	}
}

//      CCustomBar::OnLButtonUp
//              Handles the customizing calls for button moving, and control sizing.

void CCustomBar::OnLButtonUp(UINT nFlags, CPoint point)
{
	// handle MDI tracking separately
	if(m_nMDITrack>=cMDIDragging)
	{
		ASSERT(IsMDIHost());

		if(m_nMDITrack!=cMDIDragPending)
		{
			ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

			CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

			BOOL bMaximized;
			CMDIChildWnd *pActive=pMainWnd->MDIGetActive(&bMaximized);

			switch(m_nMDITrack)
			{
				case cMDIRestore:
					pActive->MDIRestore();
					break;
				case cMDIMinimize:
					pActive->CloseWindow();
					break;
				case cMDIClose:
					pActive->SendMessage(WM_CLOSE,0,0);
					break;
			}

			int nHit=m_nMDITrack;
			
			m_nMDITrack=cMDINoButton;

			if(nHit!=cMDIDragPending)
			{
				CRect buttons[cMDIRectCount];

				GetMDIButtonRects(buttons);

				InvalidateRect(buttons[nHit]);
				UpdateWindow();
			}
		}
		else
		{
			m_nMDITrack=cMDINoButton;
		}
		if(GetCapture()==this)
		{
			ReleaseCapture();
		}
	}
	else
	{
		CToolBar::OnLButtonUp(nFlags, point);
	}
}

//      CCustomBar::OnLButtonDblClk
//              Close icon in menu bars.

void CCustomBar::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// handle MDI tracking separately
	if(IsMDIHost() && HitTestMDI(point)==cMDIIcon)
	{
		// double click to close window

		ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

		CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

		BOOL bMaximized;
		CWnd *pActive=pMainWnd->MDIGetActive(&bMaximized);

		pActive->SendMessage(WM_SYSCOMMAND, SC_CLOSE, MAKELONG(-1, -1));
	}
	else
	{
		CToolBar::OnLButtonDblClk(nFlags, point);
	}
}

BOOL CCustomBar::OnButtonPressed(int iButton)
{
	AFX_TBBUTTON* pTBB = _GetButtonPtr(iButton);

	// if it's an enabled menu, then pull
	if(     (pTBB->nStyle & TBBS_MENU)!=0 &&
		(pTBB->nStyle & TBBS_DISABLED)==0)
	{
		CMainFrame *pFrame=(CMainFrame *)theApp.m_pMainWnd;

		if (theApp.m_bMenuDirty)
		{
			pFrame->RebuildMenus();
		}

		ExpandItem(iButton,TRUE);

		return TRUE;
	}
	else
	{
		return CToolBar::OnButtonPressed(iButton);
	}
}

void CCustomBar::UpdateButton(int nIndex)
{
	CToolBar::UpdateButton(nIndex);
}

//      CCustomBar::OnRButtonDown
//              Handles the potential popup menu for customising toolbar buttons.

void CCustomBar::OnRButtonDown(UINT nFlags, CPoint point)
{
	CToolBar::OnRButtonDown(nFlags, point);
}

//      CCustomBar::OnGetMinMaxInfo
//              For dock sizing.

void CCustomBar::OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI)
{
	CToolBar::OnGetMinMaxInfo(lpMMI);

	lpMMI->ptMinTrackSize.x = m_sizeFixedLayout.cx;
	lpMMI->ptMinTrackSize.y = m_sizeFixedLayout.cy;
	lpMMI->ptMaxTrackSize.x = m_sizeMaxLayout.cx;
	lpMMI->ptMaxTrackSize.y = m_sizeMaxLayout.cy;
}

void CCustomBar::OnSize(UINT nType, int cx, int cy)
{
    if (nType == SIZE_RESTORED)
    {
		CRect rect, rectWnd;
		CWnd* pWnd;

		// Count the number of controls int the toolbar.
		int nControls = 0;
		AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
		for (int iButton = 0; iButton < m_nCount; iButton++, pTBB++)
		{
			ASSERT(pTBB != NULL);
			if ((pTBB->nStyle & TBBS_HWND) == 0)
				continue;

			pWnd = CWnd::FromHandle(GetButtonExtra(iButton)->GetControl());
			ASSERT(pWnd != NULL);

			if (!IsValidCtrlSize(pWnd))
			{
				CWnd* pWndFocus = GetFocus();
				if (pWnd == pWndFocus || pWnd->IsChild(pWndFocus))
					LoseFocus();

				pWnd->ShowWindow(SW_HIDE);
			}
			else
			{
				pWnd->ShowWindow(SW_SHOWNOACTIVATE);
				nControls++;
			}
		}

		if (nControls == 0)
			return;
		
	    HDWP hdwp = ::BeginDeferWindowPos(nControls);
		pTBB = (AFX_TBBUTTON*)m_pData;
		for (iButton = 0; iButton < m_nCount; iButton++, pTBB++)
		{
			ASSERT(pTBB != NULL);
			if ((pTBB->nStyle & TBBS_HWND) == 0)
				continue;

			pWnd = CWnd::FromHandle(GetButtonExtra(iButton)->GetControl());
			ASSERT(pWnd != NULL);

			pWnd->GetWindowRect(rectWnd);
			ScreenToClient(rectWnd);
			GetItemRect(iButton, rect, GetOrient());
		
			CRect rectDrop = rect;
			::GetDroppedRect(pWnd->m_hWnd, rectDrop);

			// z-order so updates in DoPaint don't cause trash when controls
			// overlap.
	    hdwp = ::DeferWindowPos(hdwp, pWnd->GetSafeHwnd(), HWND_BOTTOM,
		rect.left, rect.top, rect.Width(), rectDrop.Height(),
		SWP_NOACTIVATE);
		}

		// Fix for selection hiding and 3d bug.  Make sure everything stays
		// invalid without flashing.
		if ((GetStyle() & WS_VISIBLE) == 0)
			::EndDeferWindowPos(hdwp);
		else
		{
			ShowWindow(SW_HIDE);
			::EndDeferWindowPos(hdwp);
			ShowWindow(SW_SHOWNOACTIVATE);
		}
	}
}

//      CCustomBar::OnSizeParent
//              Not sure we still get called with this one, but we certainly don't
//              want the standard MFC behavior here.

LRESULT CCustomBar::OnSizeParent(UINT, LPARAM)
{
    return 0;
}

//      CCustomBar::OnIdleUpdateCmdUI
//              Speed up captures.

LRESULT CCustomBar::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam)
{
#ifdef AUTOUPDATE_BUTTONS
	// ignore if mouse capture on someone else, and not on one of our children, or we're hidden
	CWnd *pWndCapture=GetCapture();
    IMsoComponentHost * pCompHost = theApp.GetStdCompMgr()->GetIMsoComponentHost();
	if (!pCompHost->FContinueIdle() ||
		!IsWindowVisible() || 
		(pWndCapture != NULL && pWndCapture != this && !IsChild(pWndCapture)))
#endif
		return 0L;
		
	return CToolBar::OnIdleUpdateCmdUI(wParam, lParam);
}

//      CCustomBar::OnDestroy
//              Remove our control windows.

void CCustomBar::OnDestroy()
{
	RemoveWindows();
	
	CToolBar::OnDestroy();
}

// Override to allow hwnd buttons to nominate an id for their tooltip, depending
// on their context
int CCustomBar::OnToolHitTest(CPoint point, TOOLINFO* pTI) const
{
	ASSERT_VALID(this);

	// check id using standard toolbar code
	int nHit = CToolBar::OnToolHitTest(point, pTI);
	if (nHit != -1)
	{
		int iButton = HitTest(point);
		if (iButton != -1)
		{
			AFX_TBBUTTON* pTBB = _GetButtonPtr(iButton);

			BOOL bWindowVisible=FALSE;

			// menu buttons don't get tooltips
			if(pTBB->nStyle & TBBS_MENU)
			{
				nHit=-1;
			}
		}
	}
	return nHit;
}

void CCustomBar::OnMouseMove(UINT nFlags, CPoint point)
{
	// handle MDI tracking separately
	if(m_nMDITrack>=cMDIDragging)
	{
		ASSERT(IsMDIHost());
		if(GetCapture()!=this)
		{
			SetCapture();
		}
		//
		int nHit=HitTestMDI(point);

		// don't act on these two, but remember we are dragging
		if(nHit==cMDIIcon ||
			nHit==cMDINoButton)
		{
			nHit=cMDIDragPending;
		}

		if(nHit!=m_nMDITrack)
		{
			CRect buttons[cMDIRectCount];

			GetMDIButtonRects(buttons);

			if(m_nMDITrack!=cMDIDragPending)
			{
				InvalidateRect(buttons[m_nMDITrack]);
			}

			m_nMDITrack=nHit;

			if(m_nMDITrack!=cMDIDragPending)
			{
				InvalidateRect(buttons[m_nMDITrack]);
			}
			UpdateWindow();
		}
	}

	// adjust dropped menu if appropriate
	if( s_pDroppedBar==this && 
		GetCustomizer()==NULL)
	{
		AFX_TBBUTTON* pTBB =NULL;
		if(s_nDroppedItem<m_nCount)
		{
			pTBB=_GetButtonPtr(s_nDroppedItem);
		}
		int iCurrentHit=HitTest(point);
		if(iCurrentHit==-1)
		{
			// If no bar button was hit, maybe we floated over the mdi system icon.
			int nMDIHit=HitTestMDI(point);
			if(nMDIHit==cMDIIcon)
			{
				iCurrentHit=m_nCount;
			}
		}

		// if dropped item is positive, we're mid push, and need to transfer the push allegiance
		if(s_nDroppedItem>=0)
		{
			if(iCurrentHit!=-1 && iCurrentHit!=s_nDroppedItem)
			{
				// will point at button, unless we are over mdi icon
				AFX_TBBUTTON* pTBBNew = NULL;

				if(iCurrentHit<m_nCount)
				{
					pTBBNew=_GetButtonPtr(iCurrentHit);
				}

				BOOL bPost=FALSE;

				if(pTBB)
				{
					if((pTBB->nStyle & TBBS_DISABLED)==0)
					{
						// what was the old thing?
						if(pTBB->nStyle & TBBS_MENU)
						{
							ExpandItem(s_nDroppedItem,FALSE);
							bPost=TRUE;
						}
						else
						{
							//deextrude it
							pTBB->nStyle &= ~(TBBS_EXTRUDED);
							InvalidateButton(s_nDroppedItem);
						}
					}
				}
				else
				{
					ASSERT(s_nDroppedItem==m_nCount);
					// if the menu is open, close it.
					if(s_pSystemMenu)
					{
						ExpandItem(s_nDroppedItem,FALSE);
						bPost=TRUE;
					}
				}

				if(iCurrentHit!=-1)
				{
					if(pTBBNew)
					{
						if((pTBBNew->nStyle & TBBS_DISABLED)==0)
						{
							// we hit something new; what is it?
							if(pTBBNew->nStyle & TBBS_MENU)
							{
								if(bPost)
								{
									// we have to post here so that the new menu's modal loop isn't started inside the
									// old menu's message handler.
									PostMessage(DSM_DROPMENU, iCurrentHit, FALSE);
								}
								else
								{
									ExpandItem(iCurrentHit, TRUE);
								}
							}
							else
							{
								pTBBNew->nStyle |= TBBS_EXTRUDED;
								InvalidateButton(iCurrentHit);
							}
						}
					}
					else
					{
						// system menu
						ASSERT(iCurrentHit==m_nCount);

						if(bPost)
						{
							// we have to post here so that the new menu's modal loop isn't started inside the
							// old menu's message handler.
							PostMessage(DSM_DROPMENU, iCurrentHit, FALSE);
						}
						else
						{
							ExpandItem(iCurrentHit, TRUE);
						}
					}
					if(m_iButtonCapture==s_nDroppedItem &&
						m_iButtonCapture!=-1)
					{
						// we're in a push operation, so adjust the capture too
						m_iButtonCapture=iCurrentHit;
					}
				}

				if(!bPost)
				{
					s_nDroppedItem=iCurrentHit; // note that this allows m_iDroppedItem to get set to
												// a nonmenu during a drag. Hmmm.
				}
			}
		}
	}

	// call base class to do usual stuff.
	CToolBar::OnMouseMove(nFlags, point);
}

// don't extrude if we're a hwnd button
BOOL CCustomBar::ShouldExtrude(int iButton)
{
	return !IsVisibleControl(iButton) && CToolBar::ShouldExtrude(iButton);
}

TBBUTTON_EXTRA *CCustomBar::EditButtonExtra(int iButton)
{ 
	if(!HasButtonExtra())
	{
		m_pButtonExtra= new TBBUTTON_EXTRA[m_nCount];
	}
	ASSERT(HasButtonExtra());
	
	return &(m_pButtonExtra[iButton]);
};

// called when the toolbar scroll bar is hit
// used only in customisation mode
void CCustomBar::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	// should be from our own bar
	ASSERT(pScrollBar==NULL);

	int offset=0;                                                   // ammount to offset the bar by
	int current=GetScrollPos(SB_VERT);              // position before the move
	int minScroll; 
	int maxScroll;                                                  // range of the bar
	CRect rectTools;                                                // tools pane size (used as 'page' size)

	GetWindowRect(rectTools);
	GetScrollRange(SB_VERT,&minScroll, &maxScroll);

	ASSERT(minScroll==0);

	CSize sizeButton=GetButtonSize(GetOrient());

	switch(nSBCode) {
	case SB_BOTTOM:
		offset=maxScroll-current;
		break;

	case SB_LINEDOWN:
		offset= sizeButton.cy+m_cySharedBorder;
		break;

	case SB_LINEUP:
		offset= -(sizeButton.cy+m_cySharedBorder);
		break;

	case SB_PAGEDOWN:
		offset=rectTools.Size().cy;
		break;

	case SB_PAGEUP:
		offset=-rectTools.Size().cy;
		break;

	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		offset=nPos-current;
		break;

	case SB_TOP: 
		offset=-current;
		break;
	}

	// check for going outside range
	if(current+offset<0) {
		offset=-current;
	}
	if(current+offset>maxScroll) {
		offset=maxScroll-current;
	}

	// scroll the bar, and the toolbar
	SetScrollPos(SB_VERT,current+offset);
	ScrollWindow(0,-offset);
	UpdateWindow();
}

/////////////////////////////////////////////////////////////////////////////
// CCustomBar diagnostics

#ifdef _DEBUG
void CCustomBar::AssertValid() const
{
	// deliberate skipping of base class, because we changed the assumptions... 
	CWnd::AssertValid();

	ASSERT(m_nCount == 0 || m_pData != NULL);

	AFX_TBBUTTON* pTBB = (AFX_TBBUTTON*)m_pData;
	for(int iButton=0; iButton <m_nCount; ++iButton, ++pTBB)
	{
		// invisible button could be anything.
		if(pTBB->nStyle & TBBS_INVISIBLE)
		{
			continue;
		}

		if((pTBB->nStyle & TBBS_SEPARATOR)==0)
		{
			ASSERT((pTBB->nStyle & TBBS_GLYPH)!=0 || (pTBB->nStyle & TBBS_TEXTUAL)!=0);
			ASSERT(pTBB->nID!=0);
		}

		if(pTBB->nStyle & TBBS_TEXTUAL)
		{
			ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);

			ASSERT(!GetButtonExtra(iButton)->GetLabel().IsEmpty());
		}

		if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
		{
			ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);
		}

		if(pTBB->nStyle & TBBS_CUSTOMTEXT)
		{
			ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);
			ASSERT((pTBB->nStyle & (TBBS_TEXTUAL))!=0);
		}

		if(pTBB->nStyle & TBBS_HWND)
		{
			ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);
		}

		if(pTBB->nStyle & TBBS_SEPARATOR)
		{
			ASSERT((pTBB->nStyle & (TBBS_CUSTOMBITMAP|TBBS_CUSTOMTEXT|TBBS_SIZABLE|TBBS_TEXTUAL|TBBS_HWND|TBBS_MENU))==0);
		}

		if(pTBB->nStyle & TBBS_SIZABLE)
		{
			ASSERT(pTBB->nStyle & TBBS_HWND);
			ASSERT((pTBB->nStyle & (TBBS_SEPARATOR))==0);
		}

		if(pTBB->nStyle & TBBS_GLYPH)
		{
			ASSERT(pTBB->iImage>=0);
			ASSERT(pTBB->iImage<m_nTiles);
		}
	}
}
#endif

void GetDroppedRect(HWND hwnd, LPRECT lpRect)
{
	CString strClass;
	::GetClassName(hwnd, strClass.GetBuffer(16), 16);
	strClass.ReleaseBuffer();

	if (strClass.CompareNoCase("ComboBox") == 0)
	{
		::SendMessage(hwnd, CB_GETDROPPEDCONTROLRECT, 0,
			(LPARAM) (LPVOID) lpRect);
	}
}

// TRUE if this bar is currently required to host the MDI gadgets
BOOL CCustomBar::IsMDIHost(void) const
{
	if(m_dwStyle & CTBRS_MAINMENU)
	{
		ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

		CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

		BOOL bMaximized;
		pMainWnd->MDIGetActive(&bMaximized);
		if(bMaximized)
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}
}

void CCustomBar::UpdateMDIIcon()
{
	if(m_hIconMDI)
	{
		::DestroyIcon(m_hIconMDI);
		m_hIconMDI=NULL;
	}
	if(IsMDIHost())
	{
		CRect buttons[cMDIRectCount];

		GetMDIButtonRects(buttons);
		
		InvalidateRect(buttons[cMDIIcon]);
	}
}

int CCustomBar::GetLeftBorder(ORIENTATION or) const
{
	if (or == orHorz)
	{
		return cGrabberWidth;
	}
	else
	{
		return 1;
	}
}

int CCustomBar::GetRightBorder(ORIENTATION or) const
{
	return 1;
}

int CCustomBar::GetTopBorder(ORIENTATION or) const
{
	if (or == orVert)
	{
		return cGrabberHeight;
	}
	else
	{
		return 3;
	}
}

int CCustomBar::GetBottomBorder(ORIENTATION or) const
{
	return 3;
}

int CCustomBar::GetLeftMDIArea(ORIENTATION or) const
{
	if (or != orVert && IsMDIHost())
	{
		return globalData.csSmallIcon.cx;
	}
	else
	{
		return 0;
	}
}

int CCustomBar::GetRightMDIArea(ORIENTATION or) const
{
	if(or!=orVert && IsMDIHost())
	{
		// 3 buttons, plus a space between 2 of them and the close button
		return 3*globalData.csCaptionButton.cx+globalData.cxPreCloseGap+globalData.cxPostCloseGap+globalData.cxPreMinimizeGap;
	}
	else
	{
		return 0;
	}
}

int CCustomBar::GetTopMDIArea(ORIENTATION or) const
{
	if (or == orVert && IsMDIHost())
	{
		return globalData.csSmallIcon.cy;
	}
	else
	{
		return 0;
	}
}

int CCustomBar::GetBottomMDIArea(ORIENTATION or) const
{
	if(or==orVert && IsMDIHost())
	{
		// 3 buttons, plus a space between 2 of them and the close button
		return 3*globalData.csCaptionButton.cy+globalData.cyPreCloseGap+globalData.cyPostCloseGap+globalData.cyPreMinimizeGap;
	}
	else
	{
		return 0;
	}
}

void CCustomBar::DrawGrabber(CDC* pDC)
{
	CRect rc;
	ORIENTATION or = GetOrient();
	GetClientRect(rc);

	if (or == orHorz)
	{
		pDC->FillSolidRect(rc.left, rc.top, 8, rc.Height(), globalData.clrBtnFace);
		pDC->Draw3dRect(rc.left + 1, rc.top + 1, 3, rc.Height() - 2,
			globalData.clrBtnHilite, globalData.clrBtnShadow);
		pDC->Draw3dRect(rc.left + 5, rc.top + 1, 3, rc.Height() - 2,
			globalData.clrBtnHilite, globalData.clrBtnShadow);
	}
	else if (or == orVert)
	{
		pDC->FillSolidRect(rc.left, rc.top, rc.Width(), 8, globalData.clrBtnFace);
		pDC->Draw3dRect(rc.left + 1, rc.top + 1, rc.Width() - 2, 3,
			globalData.clrBtnHilite, globalData.clrBtnShadow);
		pDC->Draw3dRect(rc.left + 1, rc.top + 5, rc.Width() - 2, 3,
			globalData.clrBtnHilite, globalData.clrBtnShadow);
	}
}

// Stolen and adapted from Office 97 (tbsys.cpp: FDrawMDISystemIcon)
/*----------------------------------------------------------------------------
	TBS::FDrawMDISystemIcon

	Does its best to draw the document icon in the given hdc and rectangle.
------------------------------------------------------------------- JBELT --*/
BOOL CCustomBar::DrawMDIDocumentIcon(CDC* pDC, const CRect &rectIcon)
{
	// get the MDI child window
	// if didn't get the icon yet, get it now
	// I don't believe this icon can change on the fly so I'm caching it forever
	if (!m_hIconMDI)
	{
		HICON hicon = NULL;

		// try getting it from the document window
		ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

		CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

		BOOL bMaximized;
		CWnd *pWnd=pMainWnd->MDIGetActive(&bMaximized);

		if (pWnd->GetSafeHwnd()!=NULL)
		{
			if ((hicon = (HICON) pWnd->SendMessage(WM_GETICON, FALSE, 0)) != NULL)
				goto LGotIcon;
			if ((hicon = (HICON) GetClassLong(pWnd->GetSafeHwnd(), GCL_HICONSM)) != NULL)
				goto LGotIcon;
		}

		// last resort: get it from the app itself (this will be the app icon)
		if (pMainWnd)
		{
			if ((hicon = (HICON) pMainWnd->SendMessage(WM_GETICON, FALSE, 0)) != NULL)
				goto LGotIcon;
			if ((hicon = (HICON) GetClassLong(pWnd->GetSafeHwnd(), GCL_HICONSM)) != NULL)
				goto LGotIcon;
		}

		return FALSE;
LGotIcon:
		/* Got the Icon, lets make a copy of it */
		ASSERT(hicon != NULL);
		if ((m_hIconMDI = CopyIcon(hicon)) == NULL)
			return FALSE;
	}

	// draw it
	ASSERT(m_hIconMDI);

	::DrawIconEx(pDC->GetSafeHdc(), rectIcon.left, rectIcon.top, m_hIconMDI, globalData.csSmallIcon.cx, globalData.csSmallIcon.cy, 0, globalData.hbrBtnFace,0);
	return TRUE;
}

void CCustomBar::DrawMDIControls(CDC* pDC)
{
	ASSERT(IsMDIHost());

	ORIENTATION or=GetOrient();

	CRect rects[cMDIRectCount];

	GetMDIButtonRects(rects);

	DrawMDIDocumentIcon(pDC, rects[cMDIIcon]);
	pDC->DrawFrameControl(rects[cMDIClose], DFC_CAPTION, DFCS_CAPTIONCLOSE | (m_nMDITrack==cMDIClose ? DFCS_PUSHED : 0));
	pDC->DrawFrameControl(rects[cMDIMinimize], DFC_CAPTION, DFCS_CAPTIONMIN | (m_nMDITrack==cMDIMinimize ? DFCS_PUSHED : 0));
	pDC->DrawFrameControl(rects[cMDIRestore], DFC_CAPTION, DFCS_CAPTIONRESTORE | (m_nMDITrack==cMDIRestore ? DFCS_PUSHED : 0));
}

// tests and acts on 
BOOL CCustomBar::CheckMDIButtons(UINT nFlags, CPoint point)
{
	MDIBUTTON nHit=HitTestMDI(point);

	ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

	CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

	BOOL bMaximized;
	CWnd *pActive=pMainWnd->MDIGetActive(&bMaximized);

	switch(nHit)
	{
		default:
			ASSERT(FALSE);
			// drop thru
		case cMDINoButton:
			return FALSE;

		case cMDIIcon:
			if(pActive)
			{
				// prime for potential double click
				CPoint ptScreen=point;
				ClientToScreen(&ptScreen);
				CBMenuPopup::SetSystemClick(GetMessageTime(), ptScreen);
				pActive->SendMessage(WM_SYSCOMMAND, SC_MOUSEMENU, MAKELONG(ptScreen.x, ptScreen.y));
			}
			break;

		case cMDIMinimize:
		case cMDIRestore:
		case cMDIClose:
			{
				// start mdi tracking
				m_nMDITrack=nHit;
				CRect buttons[cMDIRectCount];

				GetMDIButtonRects(buttons);
				
				InvalidateRect(buttons[nHit]);
				UpdateWindow();

				SetCapture();
			}
			break;
	}

	return TRUE;
}

// gets the rects of the mdi buttons
void CCustomBar::GetMDIButtonRects(CRect rects[cMDIRectCount])
{
	ORIENTATION or=GetOrient();

	CSize sizeButton=GetButtonSize(or);

	int rowHeight=m_cyDefaultGap+sizeButton.cy;
	int colWidth=m_cxDefaultGap+sizeButton.cx;

	// draw the doc icons at the right edge of the left border, or the bottom edge of the top border
	if(or!=orVert)
	{
		rects[cMDIIcon].left=GetLeftBorder(or);
		rects[cMDIIcon].right=rects[cMDIIcon].left+globalData.csSmallIcon.cx;
		rects[cMDIIcon].top=(rowHeight-globalData.csSmallIcon.cy)/2;
		rects[cMDIIcon].bottom=rects[cMDIIcon].top+globalData.csSmallIcon.cy;
	}
	else
	{
		rects[cMDIIcon].top=GetTopBorder(or);
		rects[cMDIIcon].bottom=rects[cMDIIcon].top+globalData.csSmallIcon.cy;
		rects[cMDIIcon].left=(colWidth-globalData.csSmallIcon.cx)/2;
		rects[cMDIIcon].right=rects[cMDIIcon].left+globalData.csSmallIcon.cx;
	}

	// now the three control icons
	// start with the close one at the right, and move leftwards, wrapping upwards if necessary.
	// Never split up the two maximize/restore buttons
	CRect rectClient;

	GetClientRect(rectClient);

	if(or!=orVert)
	{
		rects[cMDIClose].bottom=rectClient.bottom-(rowHeight-globalData.csCaptionButton.cy)/2;
		rects[cMDIClose].top=rects[cMDIClose].bottom- globalData.csCaptionButton.cy;

		rects[cMDIClose].right=rectClient.right-globalData.cxPostCloseGap;
		rects[cMDIClose].left=rects[cMDIClose].right-globalData.csCaptionButton.cx;
	}
	else
	{
		rects[cMDIClose].right=rectClient.right-(colWidth-globalData.csCaptionButton.cx)/2;
		rects[cMDIClose].left=rects[cMDIClose].right - globalData.csCaptionButton.cx;

		rects[cMDIClose].bottom=rectClient.bottom-globalData.cyPostCloseGap;
		rects[cMDIClose].top=rects[cMDIClose].bottom-globalData.csCaptionButton.cy;
	}

	// the two buttons are always minimize and restore, because we are always maximized. If we're not
	// maximized, then we won't be drawing the buttons on the bar.

	rects[cMDIMinimize]=rects[cMDIClose];

	if(or!=orVert)
	{
		rects[cMDIMinimize].OffsetRect(-2*(globalData.csCaptionButton.cx)-globalData.cxPreCloseGap,0);

		if(rects[cMDIMinimize].left<globalData.cxPreMinimizeGap)
		{       
			// wrap to previous line
			rects[cMDIMinimize].top-=(sizeButton.cy + m_cyDefaultGap);
			rects[cMDIMinimize].bottom-=(sizeButton.cy + m_cyDefaultGap);
			rects[cMDIMinimize].right=rectClient.right-globalData.cxPostCloseGap;
			rects[cMDIMinimize].left=rects[cMDIMinimize].right-2*globalData.csCaptionButton.cx;
		}
	}
	else
	{
		rects[cMDIMinimize].OffsetRect(0,-2*(globalData.csCaptionButton.cy)-globalData.cyPreCloseGap);

		// for the moment, vbars don't wrap, so no need to watch wrap here
	}

	rects[cMDIRestore]=rects[cMDIMinimize];
	if(or!=orVert)
	{
		rects[cMDIRestore].OffsetRect(globalData.csCaptionButton.cx,0);
	}
	else
	{
		rects[cMDIRestore].OffsetRect(0,globalData.csCaptionButton.cy);
	}
}

// checks if an MDI button was hit
CCustomBar::MDIBUTTON CCustomBar::HitTestMDI(CPoint point)
{
	CRect buttons[cMDIRectCount];

	GetMDIButtonRects(buttons);

	for(MDIBUTTON iButton=cMDIRectFirst; iButton<=cMDIRectLast; iButton=(MDIBUTTON)(((int)iButton)+1))
	{
		if(buttons[iButton].PtInRect(point))
		{
			return iButton;
		}
	}

	return cMDINoButton;
}

// cancels this menu, or any menu that contains it
void CCustomBar::HideInvalidDestination(UINT nId)
{
	if(s_pDroppedBar)
	{
		ASSERT(s_nDroppedItem!=-1);
		s_pDroppedBar->HideInvalidBarDestination(nId);
	}
}

// implements specific menu cancelling for bars
void CCustomBar::HideInvalidBarDestination(UINT nId)
{
	ASSERT(s_nDroppedItem>=0);

	if(s_nDroppedItem<m_nCount)
	{
		AFX_TBBUTTON *pTBB=_GetButtonPtr(s_nDroppedItem);

		if(pTBB->nID==nId)
		{
			CancelMenu();
		}
		else
		{
			CBMenuPopup *pMenuTest=theCmdCache.GetMenu(nId);
			if(pMenuTest->ContainsMenu(pTBB->nID))
			{
				CancelMenu();
			}
			else
			{
				CBMenuPopup *pMenu=GetItemMenu(s_nDroppedItem);

				ASSERT(pMenu);
				pMenu->HideInvalidMenuDestination(nId);
			}
		}
	}
}

// cancels any open menu
void CCustomBar::CancelMenu(void)
{
	if(s_pDroppedBar)
	{
		ASSERT(s_nDroppedItem!=-1);
		s_pDroppedBar->ExpandItem(s_nDroppedItem, FALSE);
	}
}

// Expand now copes with expanding m_nIndex, which gets us the mdi child menu
int CCustomBar::ExpandItem(int nIndex, BOOL bExpand, BOOL bKeyboard)
{
	// pull up whatever was down
	if(bExpand && s_pDroppedBar!=NULL)
	{
		// can't recurse badly, because bExpand will be false.
		s_pDroppedBar->ExpandItem(s_nDroppedItem, FALSE);

		if(!theApp.IsCustomizing())
		{
			// POST ourselves a message causing the real expansion. May not be necessary, but helps protect against
			// bad recursion bugs.
			PostMessage(DSM_DROPMENU, nIndex, bKeyboard);

			return 0;
		}
	}

	// must be a valid button index or m_nCount
	ASSERT(nIndex>=0);
	ASSERT(nIndex< m_nCount || nIndex==m_nCount);

	AFX_TBBUTTON* pTBB=NULL;
	CBMenuPopup* pPopup=NULL;
	CWnd *pMDIChild=NULL;
	BOOL bMaximized=FALSE;

	// The window which the command will be sent to; used to allow mdi menu to route messages to mdi child
	CWnd *pPostTarget=NULL;

	if(nIndex==m_nCount && (GetBarStyle() & CTBRS_MAINMENU)!=0)
	{
		if(bExpand)
		{
			if(s_pSystemMenu!=NULL)
			{
				// menu is already up, so quit.
				return m_nCount;
			}

			// duplicate the system menu

			// Find active child
			CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

			pMDIChild=pMainWnd->MDIGetActive(&bMaximized);
			
			if(pMDIChild)
			{
				pPostTarget=pMDIChild;

				CMenu *pSourceMenu=pMDIChild->GetSystemMenu(FALSE);

				s_pSystemMenu=new CBMenuPopup;

				// copy menu items 
				int nSourceItems=pSourceMenu->GetMenuItemCount();
				for(int iSource=0;iSource<nSourceItems;++iSource)
				{
					UINT nID=pSourceMenu->GetMenuItemID(iSource);

					// don't expect submenus on the main menu
					ASSERT(nID!=-1);

					if(nID==0)
					{
						s_pSystemMenu->InsertMenu(-1, MF_BYPOSITION | MF_SEPARATOR, 0);
					}
					else
					{
						CString menuName;
						pSourceMenu->GetMenuString(iSource, menuName, MF_BYPOSITION);

						UINT nFlags=pSourceMenu->GetMenuState(iSource, MF_BYPOSITION);
						s_pSystemMenu->InsertMenu(-1, MF_BYPOSITION|nFlags, nID, menuName);
					}
				}

				// make sure we see cancellation notices
				s_pSystemMenu->SetPassBackCancel(TRUE);
			}
			else
			{
				nIndex=0;
			}
		}
		pPopup=s_pSystemMenu;
	}
	
	BOOL bReturnCmd=FALSE;

	if(nIndex<m_nCount)
	{
		pTBB= _GetButtonPtr(nIndex);
		ASSERT(pTBB->nStyle & TBBS_MENU);
		pPopup = theCmdCache.GetMenu(pTBB->nID);
		ASSERT(pPopup != NULL);
	}
	else
	{
		// mdi always gets the command back, so it can be sent to the MDI child.
		if(pPostTarget)
		{
			bReturnCmd=TRUE;
		}
	}

	CSize offset;

	// hide it or show it?
	if (bExpand)
	{
		if (pPopup->GetSafeHwnd() != NULL)
		{
			return -1;
		}

		RECT rectAvoid=CRect(0,0,0,0);

		int xPos=0;
		int yPos=0;
		if(pTBB || bMaximized)
		{
			if(pTBB)
			{
				// draw it pressed
				pTBB->nStyle |= TBBS_PRESSED;
				InvalidateButton(nIndex);

				// drop the menu.
				GetItemRect(nIndex, &rectAvoid, GetOrient());
				ClientToScreen(&rectAvoid);
			}
			else
			{
				CRect buttons[cMDIRectCount];

				GetMDIButtonRects(buttons);

				ClientToScreen(buttons[cMDIIcon]);

				rectAvoid=buttons[cMDIIcon];
			}
			ORIENTATION or=GetOrient();
			xPos = (or == orVert) ? rectAvoid.right+1 : rectAvoid.left-1;
			yPos = (or == orVert) ? rectAvoid.top-1 : rectAvoid.bottom+1;
		}
		else
		{
			ASSERT(pMDIChild);

			if(pMDIChild->IsIconic())
			{
				CRect rcWindow;
				pMDIChild->GetWindowRect(&rcWindow);

				// initially try it below the mdi lump
				yPos=rcWindow.bottom;
				xPos=rcWindow.left;

				// but always avoid the mdi lump
				rectAvoid=rcWindow;

			}
			else
			{
				CRect rcChild;
				pMDIChild->GetClientRect(&rcChild);
				pMDIChild->ClientToScreen(&rcChild);
				CRect rcWindow;
				pMDIChild->GetWindowRect(&rcWindow);

				// initially try it at the top left of the client
				yPos=rcChild.top;
				xPos=rcChild.left;

				// but always avoid the title bar
				rectAvoid.top=rcWindow.top;
				rectAvoid.left=rcWindow.left;
				rectAvoid.right=rcWindow.right;
				rectAvoid.bottom=rcChild.top;
			}
		}

		if(GetCapture()==this)
		{
			ReleaseCapture();
		}

		ASSERT(nIndex!=-1);
		s_nDroppedItem=nIndex;
		s_pDroppedBar=this;
		BOOL bBarFocus=FALSE;
		UINT nCmd=pPopup->TrackDropDownMenu(      xPos, yPos, theApp.m_pMainWnd, NULL, rectAvoid,
									this,   // The menu will forward mouse and keyboard messages to this window.
									bKeyboard,  // When navagating by keyboard, the first menu item is selected.
									&bBarFocus,
									bReturnCmd
									);

		if(bReturnCmd && pPostTarget && nCmd!=0)
		{
			pPostTarget->PostMessage(WM_SYSCOMMAND, nCmd);
		}

		if(s_pSystemMenu)
		{
			delete s_pSystemMenu;
			s_pSystemMenu=NULL;
		}

		return bBarFocus ? nIndex : -1;
	}
	else
	{
		if (pPopup->GetSafeHwnd() != NULL)
			pPopup->Done(0);

		s_nDroppedItem=-1;
		s_pDroppedBar=NULL;

		if(pTBB)
		{
			// unpress the button.
			pTBB->nStyle &= ~TBBS_PRESSED;
			InvalidateButton(nIndex);
		}

		return -1;
	}
}

// menu calls this when it is completed, to stop the bar tracking
void CCustomBar::MenuDone()
{
	if(s_pDroppedBar==this && s_nDroppedItem!=-1 && s_nDroppedItem!=m_nCount)
	{
		AFX_TBBUTTON* pTBB = _GetButtonPtr(s_nDroppedItem);
		pTBB->nStyle &= ~(TBBS_PRESSED|TBBS_EXTRUDED);
		InvalidateButton(s_nDroppedItem);
	}
	m_iButtonCapture=s_nDroppedItem=-1;
	s_pDroppedBar=NULL;
}


// true if the item can receive the focus in key mode 
BOOL CCustomBar::CanFocus(int iButton)
{
	if(iButton == m_nCount &&
		GetBarStyle() & CTBRS_MAINMENU)
	{
		return TRUE;
	}

	if(IsVisibleControl(iButton))
	{
		return FALSE;
	}
	else
	{
		return (GetButtonStyle(iButton) & (TBBS_SEPARATOR|TBBS_INVISIBLE|TBBS_DISABLED))==0;
	}
};


BOOL CCustomBar::IsVisibleControl(int iButton) const
{ 
	if((GetButtonStyle(iButton) & TBBS_HWND)==0)
	{
		return FALSE;
	}
	else
	{
		return ::IsWindowVisible(GetButtonExtra(iButton)->GetControl());
	}
};

void CCustomBar::AdjustMenuBar()
{ 
	ASSERT(m_dwStyle & CTBRS_MAINMENU);

	ORIENTATION or=GetOrient();
	if(or!=orNil)
	{
		RecalcLayout();
	}
}

CBMenuPopup *CCustomBar::GetItemMenu(int iButton)
{
	// must be a valid button index or m_nCount
	ASSERT(iButton>=0);
	ASSERT(iButton< m_nCount || iButton==m_nCount);

	if(iButton==m_nCount)
	{
		return s_pSystemMenu;
	}
	else
	{
		return theCmdCache.GetMenu(GetItemID(iButton));
	}
}

afx_msg void CCustomBar::OnKillFocus(CWnd *pNew)
{
	if(s_pDroppedBar!=NULL)
	{
		MenuDone();
	}
	CToolBar::OnKillFocus(pNew);
}

// FindButton:
//	Checks if a given command id is present somewhere in the bar.
BOOL CCustomBar::FindButton(UINT nId) const
{
	AFX_TBBUTTON *pTBB=_GetButtonPtr(0);

	for(int i=0;i<m_nCount;++i, ++pTBB)
	{
		if((pTBB->nStyle & (TBBS_INVISIBLE|TBBS_SEPARATOR))==0)
		{
			if(pTBB->nID==nId)
			{
				return TRUE;
			}
		}
	}
	return FALSE;
}

// EnsureMDIControls
//  Ensures that the state of MDI controls on the bar maps to the current window state
void CCustomBar::EnsureMDIControls(void)
{
	if(IsMDIHost())
	{
		if(m_nMDITrack==cMDINotDrawn)
		{
			RecalcLayout(GetOrient()==orVert ? HTRIGHT : HTBOTTOM);
			Invalidate();
		}
	}
	else
	{
		if(m_nMDITrack!=cMDINotDrawn)
		{
			RecalcLayout();
			Invalidate();
		}
	}
}

// finds the next visible item after the one specified
int CCustomBar::FindNextVisibleItem(int nIndex, BOOL bForward)
{
	int nNextVisible=-1;
	int iItem=nIndex;
	int nOffset=1;

	// determine direction
	if(!bForward)
	{
		nOffset=-1;
	}

	iItem+=nOffset;

	// iterate over bar
	while(	iItem>=0 &&
			iItem<m_nCount &&		// iterate all items
			nNextVisible==-1)		// until we find the answer
	{
		AFX_TBBUTTON *pTBB=_GetButtonPtr(iItem);

		if(	(pTBB->nStyle & TBBS_INVISIBLE)==0 &&				// visible item
			(pTBB->nStyle & TBBS_SEPARATOR)==0 )				// that's not a separator
		{
			nNextVisible=iItem;
		}
		else
		{
			iItem+=nOffset;
		}
	}

	// check if we overran
	if(	iItem>=m_nCount ||
		iItem<0)
	{
		iItem=-1;
	}

	return iItem;
}

// TRUE if the bar has glyphs, or is non-menu
BOOL CCustomBar::HasGlyphs(void) const 
{
	if((m_dwStyle & CTBRS_MAINMENU)==0)
	{
		// non-menu bars always have glyphs, effectively. Such is life.
		return TRUE;
	}
	else
	{
		if(m_glyphStatus==cGlyphsUnknown)
		{
			// calculate if required
			AFX_TBBUTTON *pTBB=_GetButtonPtr(0);

			m_glyphStatus=cGlyphsAbsent;

			for(int iButton=0; iButton< m_nCount; ++iButton, ++pTBB)
			{
				// separators and invisible buttons have no influence
				if(pTBB->nStyle & (TBBS_SEPARATOR | TBBS_INVISIBLE))
				{
					continue;
				}
				if((pTBB->nStyle & TBBS_GLYPH)!=0 ||		// has a glyph
					IsVisibleControl(iButton))				// or is a control which is visible (controls can rely on having as much space as a normal bar)
				{
					m_glyphStatus=cGlyphsPresent;
					break;
				}
			}
		}	

		ASSERT(m_glyphStatus!=cGlyphsUnknown);

		return (m_glyphStatus==cGlyphsPresent);
	}
}

// get the size of buttons in the bar
CSize CCustomBar::GetButtonSize(ORIENTATION or) const 
{
	if(HasGlyphs())
	{
		return m_sizeButton;
	}
	else
	{
		CSize sizeDiff=m_sizeButton-m_sizeImage;
		if(or==orVert)
		{
			return CSize(globalData.GetMenuVerticalHeight()+sizeDiff.cx, m_sizeButton.cy);
		}
		else
		{
			return CSize(m_sizeButton.cx, globalData.GetMenuTextHeight()+sizeDiff.cy);
		}
	}
}

// update the text of a button
void CCustomBar::UpdateText(int nIndex, LPCTSTR newText)
{
	AFX_TBBUTTON *pTBB=_GetButtonPtr(nIndex);
	if(pTBB->nStyle & TBBS_TEXTUAL)
	{
		// If the text has a tab in it, we're updating the control too.
		CString strNewText=newText;
		int tabIndex;
		tabIndex=strNewText.Find('\t');
		if(tabIndex!=-1)
		{
			strNewText=strNewText.Left(tabIndex);
		}
			
		if(strNewText!=GetButtonExtra(nIndex)->GetLabel())
		{
			AddText(nIndex, strNewText, FALSE);
			if(	GetSafeHwnd() &&
				::IsWindowVisible(GetSafeHwnd()))
			{
				RecalcLayout();	
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barctrl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	BARCTRL.CPP
//		File for special toolbar controls.  At the very least, any control
//		for use in a toolbar must be call DkPreHandleMessage before calling
//		its own WindowProc.
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "bardockx.h"
#include "shlbar.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////
//	CDockEdit
//		This is a specialized CEdit which can be created in dockable
//		windows.

BOOL CDockEdit::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	if (!CEdit::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	SetFont(GetStdFont(0));

	SubclassCtl3d();

	return TRUE;
}

LRESULT	CDockEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LONG lResult;

	if (DkPreHandleMessage(GetSafeHwnd(),
		message, wParam, lParam, &lResult))
		return lResult;

	// forward tooltip text notifications to bar, directly
	if(message==WM_NOTIFY)
	{
		NMHDR* pNMHDR = (NMHDR*)lParam;
		if(pNMHDR->code == TTN_NEEDTEXT)
		{
			CWnd *pWnd=GetParent();
			if(pWnd)
			{
				return pWnd->SendMessage(message, wParam, lParam);
			}
		}
	}
		
	return CEdit::WindowProc(message, wParam, lParam);
}

BOOL CDockEdit::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN)
		return FALSE;

	switch (pMsg->wParam)
	{
	default:
		return FALSE;
	
	case 'Z':
	case 'X':
	case 'C':
	case 'V':
		if (GetKeyState(VK_CONTROL) >= 0)
			return FALSE;
		break;

	case VK_DELETE:
		if (GetKeyState(VK_CONTROL) < 0 || GetKeyState(VK_MENU) < 0)
			return FALSE;
		break;
		
	case VK_INSERT:
		if (GetKeyState(VK_CONTROL) >= 0 && GetKeyState(VK_SHIFT) >= 0)
			return FALSE;
		break;
		
	case VK_BACK:
	case VK_UP:
	case VK_DOWN:
	case VK_LEFT:
	case VK_RIGHT:
	case VK_NEXT:
	case VK_PRIOR:
	case VK_HOME:
	case VK_END:
		break;
	}

	// Getting this far means we should short-circuit the normal
	// accelerator processing and dispatch immediately...
	TranslateMessage(pMsg);
	DispatchMessage(pMsg);

	return TRUE;
}
	
///////////////////////////////////////////////////////////////////////////////
//	CDockCombo
//		This includes a subclass of both the ComboBox window as well as its
//		edit control.

//	CDockComboEdit::GetSuperProcAddr
//		Can't just use CEdit here, since a combo edit control is likely to
//		have a different window proc.

CDockComboEdit::CDockComboEdit(BOOL fDockable /* = TRUE */)
{
	m_fDockable = fDockable; // lets us use the same control in a dialog if FALSE
}


WNDPROC* CDockComboEdit::GetSuperWndProcAddr()
{
	static WNDPROC NEAR pfnSuper;
	return &pfnSuper;
}

//	CDockComboEdit::WindowProc
//		Call DkPreHandleMessage, and disable SetCursor if we are in customize
//		mode.

LRESULT CDockComboEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	LONG lResult;

	if (m_fDockable && DkPreHandleMessage(GetSafeHwnd(),
		message, wParam, lParam, &lResult))
		return lResult;

	if (message == WM_SETCURSOR && theApp.IsCustomizing())
		return 0L;
	
	// forward tooltip text notifications to bar, directly
	if(message==WM_NOTIFY)
	{
		NMHDR* pNMHDR = (NMHDR*)lParam;
		if(pNMHDR->code == TTN_NEEDTEXT)
		{
			CWnd *pWnd=GetParent();
			if(pWnd)
			{
				return pWnd->SendMessage(message, wParam, lParam);
			}
		}
	}
		
	return CWnd::WindowProc(message, wParam, lParam);
}

//	CDockCombo::CDockCombo
//  initialize edit item pointer to null...

CDockCombo::CDockCombo(BOOL fDockable /* = TRUE */)
{
	m_pChildEdit = NULL;
	m_fDockable = fDockable;
}

//	CDockCombo::Create
//		Subclass the edit control.

BOOL CDockCombo::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	if (!CComboBox::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	m_pChildEdit = SubclassEdit();
	SetFont(GetStdFont(0));

	SubclassCtl3d();

	return TRUE;
}

CWnd* CDockCombo::SubclassEdit()
{
	// HACK: We have used this way of finding Edit control since
	// v2.0, and it still works on Win95.  This is not likely to
	// change.

	CWnd* pWnd = GetDlgItem(1001);
	if (pWnd != NULL)
	{
		CDockComboEdit* pEdit = new CDockComboEdit(m_fDockable);
		pEdit->SubclassWindow(pWnd->GetSafeHwnd());
		return pEdit;
	}

	return NULL;
}

void CDockCombo::PostNcDestroy()
{
	delete m_pChildEdit;
}

//	CDockCombo::WindowProc
//		Call DkPreHandleMessage, but allow Alt-Up and Alt-Down to go to the
//		combo.

LRESULT CDockCombo::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	if (message != WM_SYSKEYDOWN ||
		!(wParam == VK_DOWN || wParam == VK_UP))
	{
		LONG lResult;
	
		if (m_fDockable && DkPreHandleMessage(GetSafeHwnd(),
			message, wParam, lParam, &lResult))
			return lResult;
	}
	
	// forward tooltip text notifications to bar, directly
	if(message==WM_NOTIFY)
	{
		NMHDR* pNMHDR = (NMHDR*)lParam;
		if(pNMHDR->code == TTN_NEEDTEXT)
		{
			CWnd *pWnd=GetParent();
			if(pWnd)
			{
				return pWnd->SendMessage(message, wParam, lParam);
			}
		}
	}
		
	return CComboBox::WindowProc(message, wParam, lParam);
}


///////////////////////////////////////////////////////////////////////////////
//	CToolbarCombo

BEGIN_MESSAGE_MAP(CToolbarCombo, CDockCombo)
	//{{AFX_MSG_MAP(CToolbarCombo)
	ON_WM_NCHITTEST()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
//	CToolbarCombo message handlers.

//	CToolbarCombo::OnNcHitTest
//		Hack to make gray area between edit and drop button cause a toolbar
//		move.

UINT CToolbarCombo::OnNcHitTest(CPoint point)
{
	ScreenToClient(&point);
	if (ChildWindowFromPoint(point) == this)
	{
		CRect rect;
		GetClientRect(rect);
		
		if (point.x < rect.right - ::GetSystemMetrics(SM_CXVSCROLL))
			return HTCAPTION;
	}
	
	return CDockCombo::OnNcHitTest(point);
}

///////////////////////////////////////////////////////////////////////////////
//	Control utility functions.
//

void SizeComboToContent(CComboBox* pCombo, int nMax)
{
	ASSERT_VALID(pCombo);
	int cyEdit = (int)::SendMessage(pCombo->m_hWnd, CB_GETITEMHEIGHT, UINT(-1), 0);

	CDC* pDC = pCombo->GetDC();
	CFont* pFontOld;
	CFont* pFont = pCombo->GetFont();

	if (pFont != NULL)
		pFontOld = pDC->SelectObject(pFont);

	// FUTURE:  Need better way to get height
	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	if (pFont != NULL)
		pDC->SelectObject(pFontOld);

	pCombo->ReleaseDC(pDC);

	int cyHeight = pCombo->GetCount();
	if (nMax > 0 && cyHeight > nMax)
		cyHeight = nMax;

	cyHeight = cyEdit +	cyHeight * tm.tmHeight +
		GetSystemMetrics(SM_CYBORDER) * 3;

	CRect rectCombo;
	pCombo->GetDroppedControlRect(&rectCombo);
	if (theApp.m_bWin4)
	{
		// Win95 does its own size to content.  Leave it alone, if we have
		// enough space.  But they also need a little more space than the
		// old shell, so just add an extra line.

		cyHeight += tm.tmHeight;
		if (rectCombo.Height() > cyHeight)
			cyHeight = rectCombo.Height();
	}

	if (rectCombo.Height() != cyHeight)
	{
		pCombo->SetWindowPos(NULL, 0, 0, rectCombo.Width(), cyHeight,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bardlgs.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  BARDLGS.CPP
//      Contains implementations for the major classes relavant to Sushi
//              toolbars CToolbarDialog, and CCustomDialog.
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "bardockx.h"
#include "bardlgs.h"
#include "resource.h"
#include "barcust.h"
#include "menuprxy.h"
#include "prxycust.h"
#include "btnctl.h"
#include "customiz.h"
#include <process.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolbarDialog dialog
//              Toolbar management dialog, for hiding/showing docked windows
//              ("toolbars"), reseting/deleting toolbars, creating new custom
//              toolbars.

//      CToolbarCheckList::SetCheck
//              Override CCheckList for check notification to the dialog.

void CToolbarCheckList::SetCheck(int nItem, BOOL bCheck)
{
	// Allow parent to veto action
	CToolbarDialog* pParent = (CToolbarDialog*) GetParent();

	CDockWorker* pDocker = pParent->GetWorker(nItem);
	
	// if it's the menu bar, and we are not full screen, then you can't hide it
	if (LOWORD(pDocker->m_nIDWnd) == IDTB_MENUBAR &&
		!IS_STATE_FULLSCREEN(DkGetDockState()) &&
		bCheck==FALSE)
		return;

	CCheckList::SetCheck(nItem, bCheck);
	UpdateWindow();

	ASSERT(pParent != NULL);
	pParent->UpdateVisible(nItem);
}

IMPLEMENT_DYNAMIC(CToolbarDialog, CDlgTab)

//      CToolbarDialog::CToolbarDialog
//              Construction.  Creates a CToolCustomizer.  

CToolbarDialog::CToolbarDialog(CDockManager* pManager, CWnd* pParent /*=NULL*/)
	: CDlgTab(CToolbarDialog::IDD, IDS_TOOLBARS)
{
	m_pManager = pManager;
	LockManager(TRUE);

	m_nSel = LB_ERR;
	//{{AFX_DATA_INIT(CToolbarDialog)
	m_strName = "";
	m_bToolTips = theApp.m_bToolTips;
	m_bKeys = theApp.m_bToolTipKeys;
	m_bLargeToolBars = theApp.m_bLargeToolBars;
	//}}AFX_DATA_INIT
}

CToolbarDialog::~CToolbarDialog()
{
	LockManager(FALSE);
}

BOOL CToolbarDialog::Create()
{
	return CDlgTab::Create(MAKEINTRESOURCE(CToolbarDialog::IDD), m_pParentWnd);
}

void CToolbarDialog::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CToolbarDialog)
	DDX_Control(pDX, IDC_NAME_TEXT, m_statName);
	DDX_Control(pDX, IDC_NAME_EDIT, m_edName);
	DDX_Control(pDX, IDC_DELETE, m_btnDelete);
	DDX_Control(pDX, IDC_RESET, m_btnReset);
	DDX_Control(pDX, IDC_RESET_ALL_BARS, m_btnResetAllBars);
	DDX_Text(pDX, IDC_NAME_EDIT, m_strName);
	DDV_MaxChars(pDX, m_strName, 100);
	DDX_Check(pDX, IDC_TOOLTIPS, m_bToolTips);
	DDX_Check(pDX, IDC_KEYS, m_bKeys);
	DDX_Check(pDX, IDC_LARGETOOLBARS, m_bLargeToolBars);
	//}}AFX_DATA_MAP
}

//      CToolbarDialog::LockManager
//              Make sure the CDockManager that we reference does not go away.

void CToolbarDialog::LockManager(BOOL bLock)
{
	CMainFrame* pFrame = (CMainFrame*) m_pManager->m_pFrame;
	ASSERT(pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	pFrame->LockDockState(bLock);
}

//      CToolbarDialog::UpdateVisible
//              For real time hide/show of toolbars in synch with checkboxes.

BOOL CToolbarDialog::UpdateVisible(int nItem)
{
	ASSERT(nItem >= 0 && nItem < m_aToolWorkers.GetSize());
	
	CDockWorker* pDocker = GetWorker(nItem);
	
	// Low overhead if check and visible same
	pDocker->ShowWindow(m_lbToolbars.GetCheck(nItem));

	return TRUE;
}

//      CToolbarDialog::UpdateCheck
//              Called in CDockWorker::ShowWindow to keep check list in synch with
//              user actions hide/showing toolbars.

void CToolbarDialog::UpdateCheck(UINT nIDWnd)
{
	int nBars = m_aToolWorkers.GetSize();
	CDockWorker* pDocker;
	
	for (int i = 0; i < nBars; i++)
	{
		pDocker = GetWorker(i);
		
		if (pDocker->m_nIDWnd == nIDWnd)
			m_lbToolbars.SetCheck(i, pDocker->IsVisible());
	}
}

//      CToolbarDialog::AddToolbar
//              Allows adding of toolbar to the list in case user customization creates
//              new toolbar.

void CToolbarDialog::AddToolbar(CDockWorker* pDocker)
{
	m_aToolWorkers.Add(pDocker);
	
	CString str;
	pDocker->GetText(str);
	int nBar = m_lbToolbars.AddString(str);
	
	if (nBar != LB_ERR)
		m_lbToolbars.SetCheck(nBar, pDocker->IsVisible());
}

//      CToolbarDialog::RemoveToolbar
//              Allows adding of toolbar to the list in case user customization creates
//              new toolbar.

void CToolbarDialog::RemoveToolbar(CDockWorker* pDocker)
{
	int nCount = m_aToolWorkers.GetSize();
	for (int i = 0; i < nCount && m_aToolWorkers[i] != pDocker; i++)
		;

	if (i < nCount)
	{
		m_aToolWorkers.RemoveAt(i);
		m_lbToolbars.DeleteString(i);

		if (m_lbToolbars.SetCurSel(m_nSel) == LB_ERR)
		{
			m_lbToolbars.SetCurSel(m_nSel - 1);
		}
		
		m_nSel = LB_ERR;
		
		OnSelChangeToolbar();
	}
}

BEGIN_MESSAGE_MAP(CToolbarDialog, CDlgTab)
	//{{AFX_MSG_MAP(CToolbarDialog)
	ON_BN_CLICKED(IDC_DELETE, OnClickedDelete)
	ON_BN_CLICKED(IDC_RESET, OnClickedReset)
	ON_BN_CLICKED(IDC_RESET_ALL_BARS, OnClickedResetAllBars)
	ON_BN_CLICKED(IDC_NEW, OnClickedNew)
	ON_BN_CLICKED(IDC_TOOLTIPS, OnClickedToolTips)
	ON_BN_CLICKED(IDC_KEYS, OnClickedKeys)
	ON_LBN_SELCHANGE(IDC_TOOLBAR, OnSelChangeToolbar)
	ON_WM_SYSCOMMAND()
	ON_WM_ENABLE()
	ON_BN_CLICKED(IDC_LARGETOOLBARS, OnClickedLargeToolBars)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CToolbarDialog message handlers

//      CToolbarDialog::OnInitDialog
//              Initializes list, and calls OnSelChangeToolbar to init selection
//              dependant states.

BOOL CToolbarDialog::OnInitDialog()
{
	// Initialize listbox first to avoid flashing.
	CDlgTab::OnInitDialog();
	
	VERIFY(m_lbToolbars.SubclassDlgItem(IDC_TOOLBAR, this));

	if (!m_bToolTips)
		GetDlgItem(IDC_KEYS)->EnableWindow(FALSE);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

BOOL CToolbarDialog::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	if (!CDlgTab::Activate(pParentWnd, position))
		return FALSE;

	// Initialize the listbox and corresponding worker array.
	m_aToolWorkers.RemoveAll();
	m_pManager->ArrayOfType(dtEdit, &m_aToolWorkers, TRUE, TRUE, dtEmbeddedToolbar);

	m_lbToolbars.ResetContent();
	m_lbToolbars.SetRedraw(FALSE);
	
	CString str;
	int nBars = m_aToolWorkers.GetSize();
	CDockWorker* pDocker;
	
	int iBar = 0;
	for (int i = 0; i < nBars; i++)
	{
		pDocker = GetWorker(i);

		if (!pDocker->IsAvailable())
			m_aToolWorkers.RemoveAt(iBar);
		else
		{
			pDocker->GetText(str);
			m_lbToolbars.AddString(str);
			m_lbToolbars.SetCheck(iBar, pDocker->IsVisible());
			iBar++;
		}
	}
	
	m_lbToolbars.SetRedraw(TRUE);

	m_lbToolbars.SetCurSel(0);
	
	OnSelChangeToolbar();

	theApp.ActivateDraggableCustomizePage(this);

	return TRUE;
}

void CToolbarDialog::Deactivate(CTabbedDialog* pParentWnd)
{
	UpdateData();

	CDockWorker* pDocker = GetWorker(m_nSel);
	if (!m_strName.IsEmpty() && pDocker != NULL)
		pDocker->SetText(m_strName);
	
	CDlgTab::Deactivate(pParentWnd);

	theApp.DeactivateDraggableCustomizePage(pParentWnd);

}

//      CToolbarDialog::OnClickedNew
//              Allows the creation of a new toolbar, bringing up the New
//              Toolbar dialog.

void CToolbarDialog::OnClickedNew()
{
	CNewBarDialog dlg(this);
	
	if (dlg.DoModal() == IDOK)
	{
		CASBar* pBar = new CASBar;
		if (!pBar->Create(m_pManager, TBB_NIL, NULL, dlg.m_strName))
		{
			delete pBar;
			AfxMessageBox (IDS_ERROR_TOOLBAR_CREATE);
			return;
		}
	}
}

//      CToolbarDialog::OnClickedDelete
//              Deletes the toolbar, if it is a custom toolbar.

void CToolbarDialog::OnClickedDelete()
{
	CDockWorker* pDocker = GetWorker(m_nSel);
	
	if (LOWORD(pDocker->m_nIDWnd) < IDTB_SHELL_BASE)
		return;
	
	if (pDocker->m_nIDPackage == PACKAGE_SUSHI &&
		LOWORD(pDocker->m_nIDWnd) >= IDTB_CUSTOM_BASE)
	{
		// Delete the toolbar.
		ASSERT(CASBar::s_pCustomizer != NULL);
		if (pDocker->m_pWnd == CASBar::s_pCustomizer->m_pSelectBar->GetRealObject())
			CASBar::s_pCustomizer->SetSelection(NULL, 0);
			
		// RemoveWnd calls our RemoveBar function to update the dialog.
		m_pManager->RemoveWnd(pDocker->m_nIDWnd);
	}
}

// resets the nIndex bar in the list
void CToolbarDialog::ResetBar(int nIndex)
{
	CDockWorker* pDocker = GetWorker(nIndex);
	
	if (LOWORD(pDocker->m_nIDWnd) < IDTB_SHELL_BASE)
		return;
	
	if (pDocker->m_nIDPackage != PACKAGE_SUSHI ||
		LOWORD(pDocker->m_nIDWnd) < IDTB_CUSTOM_BASE)
	{
		// Reset the toolbar to the standard.

		CASBar* pBar = (CASBar*) pDocker->m_pWnd;
		if (pBar != NULL)
		{
			pBar->Reset();
		}
	}
}

//      CToolbarDialog::OnClickedResetAllBars
//              Resets all toolbars
void CToolbarDialog::OnClickedResetAllBars()
{
	int nBars=m_lbToolbars.GetCount();

	for(int iBar=0; iBar<nBars; ++iBar)
	{
		ResetBar(iBar);
	}
}

//      CToolbarDialog::OnClickedReset
//              Resets the toolbar
void CToolbarDialog::OnClickedReset()
{
	ResetBar(m_nSel);
}

void CToolbarDialog::OnClickedToolTips()
{
	UpdateData();
	theApp.m_bToolTips = m_bToolTips;
	GetDlgItem(IDC_KEYS)->EnableWindow(m_bToolTips);
}

void CToolbarDialog::OnClickedKeys()
{
	UpdateData();
	theApp.m_bToolTipKeys = m_bKeys;
}

// fixes bug in SDK headers. This function declaration was missing
#undef BroadcastSystemMessage
extern "C" WINUSERAPI long  WINAPI  BroadcastSystemMessage(DWORD, LPDWORD, UINT, WPARAM, LPARAM);

void CToolbarDialog::OnClickedLargeToolBars() 
{
	// update the dialog information
	UpdateData();
	if(theApp.m_bLargeToolBars!=m_bLargeToolBars) {
		theApp.m_bLargeToolBars = m_bLargeToolBars;

		CWnd* pMainWnd = AfxGetApp()->m_pMainWnd;
		pMainWnd->SetRedraw(FALSE);

		DWORD dwDestination=BSM_APPLICATIONS;

		// NOTE: This function is ripe for cleanup.

		// notify others that bar sizes are changing
		// Orion Bug #: 14130 - BroadcastSystemMessage crashes on Win95. So don't use it.
		//BroadcastSystemMessage(BSF_NOHANG	| BSF_NOTIMEOUTIFNOTHUNG, &dwDestination ,DSM_BARSIZECHANGING,theApp.m_bLargeToolBars,_getpid());
		pMainWnd->SendMessage(DSM_BARSIZECHANGING,theApp.m_bLargeToolBars,_getpid());

		// Also need to notify all of the windows associated with a CDockWorker.
		// This is needed so that the Controls toolbar used by the Dialog editor is updated.

		CObArray aWorkers ;
		CMainFrame* pFrame=(CMainFrame*)AfxGetMainWnd();
		pFrame->m_pManager->ArrayOfType(dtNil, &aWorkers);

		int nViews = aWorkers.GetSize();
		CDockWorker* pDocker;
		for (int i = 0; i < nViews; i++)
		{
			pDocker = (CDockWorker*) aWorkers.GetAt(i);
			if (pDocker!= NULL && pDocker->m_pWnd != NULL)
			{
				pDocker->m_pWnd->SendMessageToDescendants(DSM_BARSIZECHANGING, theApp.m_bLargeToolBars, _getpid(), TRUE, FALSE); 
			}
		}

		// now cycle thru the visible toolbars
		int barIndex=0;
		while(barIndex<CASBar::s_aUsage.GetSize()) {
			CASBar *pBar=(CASBar *)(CASBar::s_aUsage[barIndex]);
		
			ASSERT(pBar!=NULL);

			pBar->SetButtonSize(m_bLargeToolBars);

			++barIndex;
		}

		pMainWnd->SetRedraw(TRUE);
	    pMainWnd->RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_UPDATENOW);
	}
}

//      CToolbarDialog::OnSelChangeToolbar
//              Handles updating the name edit control (and name string), and the
//              Delete/reset text.

void CToolbarDialog::OnSelChangeToolbar()
{
	int nCurSel = m_lbToolbars.GetCurSel();
	
	CDockWorker* pDockerOld = GetWorker(m_nSel);
	CDockWorker* pDocker = GetWorker(nCurSel);
	
	if (pDockerOld != NULL)
	{
		// Set the CDockWorker text.
		CString strOldTitle;
		pDockerOld->GetText(strOldTitle);
		UpdateData();
		
		if (!m_strName.IsEmpty() && strOldTitle != m_strName)
		{
			pDockerOld->SetText(m_strName);
			
			BOOL bCheckOld = m_lbToolbars.GetCheck(m_nSel);
			m_lbToolbars.SetRedraw(FALSE);
			m_lbToolbars.DeleteString(m_nSel);
			m_lbToolbars.InsertString(m_nSel, m_strName);
			m_lbToolbars.SetCheck(m_nSel, bCheckOld);
			m_lbToolbars.SetCurSel(nCurSel);
			m_lbToolbars.SetRedraw(TRUE);
		}
	}
	
	m_nSel = nCurSel;

	BOOL bEnableDelete=FALSE;
	BOOL bEnableReset=FALSE;
		
	// Update the edit control text, and delete/reset button.
	if (pDocker == NULL)
	{
		m_strName.Empty();
	}
	else
	{
		pDocker->GetText(m_strName);
	
		BOOL bCustom = (pDocker->m_nIDPackage == PACKAGE_SUSHI &&
			LOWORD(pDocker->m_nIDWnd) >= IDTB_CUSTOM_BASE);
		m_statName.EnableWindow(bCustom);
		m_edName.EnableWindow(bCustom);
		if(LOWORD(pDocker->m_nIDWnd) >= IDTB_SHELL_BASE)
		{
			if (bCustom)
			{
				bEnableDelete=TRUE;
			}
			else
			{
				bEnableReset=TRUE;
			}
		}
	}

	// ensure that the default button isn't disabled
	DWORD def=GetDefID();
	BOOL bMoveDef=FALSE;
	if(HIWORD(def)==DC_HASDEFID)
	{
		int id=LOWORD(def);

		if((id==IDC_DELETE && !bEnableDelete) ||
			(id==IDC_RESET && !bEnableReset))
		{
			// make the new button the default
			SetDefID(IDC_NEW);
			m_lbToolbars.SetFocus();
		}
	}

	m_btnDelete.EnableWindow(bEnableDelete);
	m_btnReset.EnableWindow(bEnableReset);

	UpdateData(FALSE);
}

//      CToolbarDialog::OnSysCommand
//              Disallow switching to the main window.

void CToolbarDialog::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID & 0xfff0)
    {
    case SC_PREVWINDOW:
    case SC_NEXTWINDOW:
	if (LOWORD(lParam) == VK_F6)
		return;
	break;
    }
	
	CDlgTab::OnSysCommand(nID, lParam);
}

//      CToolbarDialog::OnEnable
//              Enable/disable the main window when we get enabled/disabled.

void CToolbarDialog::OnEnable(BOOL bEnable)
{
	CDlgTab::OnEnable(bEnable);

	ASSERT(m_pManager->m_pFrame != NULL);
	m_pManager->m_pFrame->EnableWindow(bEnable);
}

//      CToolbarDialog::GetWorker
//      Gets the CDockWorker for the given index from m_aToolWorkers, or for
//              the current selection if no index is given.

CDockWorker* CToolbarDialog::GetWorker(int nIndex)
{
	if (nIndex < 0 || nIndex >= m_aToolWorkers.GetSize())
		return NULL;
	else
		return (CDockWorker*) m_aToolWorkers.GetAt(nIndex);
}

/////////////////////////////////////////////////////////////////////////////
// CNewBarDialog dialog
//              Allows user to name a new toolbar.  Brought up via the New button
//              in the CToolbarDialog.

//      CNewBarDialog::CNewBarDialog
//              Cunstruction.

CNewBarDialog::CNewBarDialog(CWnd* pParent /*=NULL*/)
	: C3dDialog(CNewBarDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewBarDialog)
	m_strName = "";
	//}}AFX_DATA_INIT
}

void CNewBarDialog::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewBarDialog)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Text(pDX, IDC_NAME, m_strName);
	//}}AFX_DATA_MAP
	DDV_MaxChars(pDX, m_strName, _MAX_DOCK_CAPTION);
}

BEGIN_MESSAGE_MAP(CNewBarDialog, C3dDialog)
	//{{AFX_MSG_MAP(CNewBarDialog)
	ON_EN_CHANGE(IDC_NAME, OnChangeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewBarDialog message handlers

//      CNewBarDialog::OnChangedName
//              Do not allow unnamed toolbars.

void CNewBarDialog::OnChangeName()
{
	UpdateData();
	m_btnOK.EnableWindow(!m_strName.IsEmpty());
}

//      CToolbarDialog::OnOK
//              Ends modeless dialog.

void CNewBarDialog::OnOK()
{
	UpdateData();

	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;

	CObArray aWorkers;
	pManager->ArrayOfType(dtNil, &aWorkers, FALSE, TRUE);

	// check for duplicates with existing docking windows
	CDockWorker* pDocker;
	CString str;

	int nWorkers=aWorkers.GetSize();

	for (int i = 0; i < nWorkers; i++)
	{
		pDocker = (CDockWorker*) aWorkers[i];

		if (LOWORD(((CDockWorker*) aWorkers[i])->m_nIDWnd) < IDTB_SHELL_BASE)
			continue;

		pDocker->GetText(str);

		if(str.CompareNoCase(m_strName)==0)
		{
			// duplicates existing bar name
			AfxMessageBox(IDS_ERROR_DUPLICATE_TOOLBAR_NAME, MB_OK | MB_ICONEXCLAMATION);
			return;
		}
	}

	C3dDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
// CCustomDialog dialog
//              Displays available controls for customizing, allowing the user
//              to drag displayed controls onto toolbars.

IMPLEMENT_DYNAMIC(CCustomDialog, CCommandTab)

//      CCustomDialog::CCustomDialog
//              Construction.  Creates a CToolCustomizer. 

CCustomDialog::CCustomDialog(CDockManager* pManager, CWnd* pParent /*=NULL*/)
	: CCommandTab(CCustomDialog::IDD, IDS_COMMANDS)
{
	m_pManager = pManager;
	LockManager(TRUE);

	m_pGroups=NULL;
	m_nSel = LB_ERR;
	m_lfCurrent=cListFillNone;
	m_iTextListBase=-1;
	//{{AFX_DATA_INIT(CCustomDialog)
	//}}AFX_DATA_INIT
}

CCustomDialog::~CCustomDialog()
{
	if(m_pGroups)
	{
		CAppToolGroups::ReleaseAppToolGroups();
	}

	DestroyToolbars();

	LockManager(FALSE);

	// These won't be referenced until customization begins (if ever), so they're just wasted memory
	theApp.UnloadPackageBitmaps();
}

void CCustomDialog::DestroyToolbars(void)
{
	int nCount = m_aToolbars.GetSize();
	for (int i = 0; i < nCount; i++)
	{
		if(m_aToolbars[i])
		{
			((CASBar*) m_aToolbars[i])->DestroyWindow();    // Auto-deleting.
		}
	}

	m_aToolbars.RemoveAll();

	if(m_cbCategories.GetSafeHwnd())
	{
		m_cbCategories.ResetContent();
	}

	m_aIds.RemoveAll();
}

BOOL CCustomDialog::Create()
{
	return CCommandTab::Create(CCustomDialog::IDD, m_pParentWnd);
}

void CCustomDialog::DoDataExchange(CDataExchange* pDX)
{
	CCommandTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCustomDialog)
	DDX_Control(pDX, IDC_TEXTLIST, m_lbTextList);
	DDX_Control(pDX, IDC_CATEGORIES_COMBO, m_cbCategories);
	DDX_Control(pDX, IDC_DESCRIPTION, m_statDescription);
	DDX_Control(pDX, IDC_TOOLS, m_statTools);
	DDX_Control(pDX, IDC_RESET_ALL_MENUS, m_btnResetAllMenus);
	DDX_Control(pDX, IDC_MENU_FILTER, m_cbMenuFilter);
	//}}AFX_DATA_MAP
}

//      CCustomDialog::LockManager
//              Make sure the CDockManager that we reference does not go away.

void CCustomDialog::LockManager(BOOL bLock)
{
	CMainFrame* pFrame = (CMainFrame*) m_pManager->m_pFrame;
	ASSERT(pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));

	pFrame->LockDockState(bLock);
}

//      CCustomDialog::SetDescriptionText
//              For displaying the status line of the selected button.

void CCustomDialog::SetDescriptionText(UINT nID)
{
	CString strPrompt;
	LPCTSTR lpsz = NULL;
	if (nID != 0)
	{
		BOOL fRet = theCmdCache.GetCommandString(nID, STRING_PROMPT, &lpsz);
		if (fRet)
			strPrompt = lpsz;
		else
			TRACE1("No String for ID = 0x%x.\n", nID);
	}

	m_statDescription.SetWindowText(strPrompt);
}

BEGIN_MESSAGE_MAP(CCustomDialog, CCommandTab)
	//{{AFX_MSG_MAP(CCustomDialog)
	ON_CBN_SELCHANGE(IDC_CATEGORIES_COMBO, OnSelChangeCategories)
	ON_CBN_SELCHANGE(IDC_MENU_FILTER, OnSelChangeMenuFilter)
	ON_WM_SYSCOMMAND()
	ON_REGISTERED_MESSAGE(DSM_BARSELECTCHANGING, OnBarSelectChanging)
	ON_REGISTERED_MESSAGE(DSM_COMMANDREMOVED, OnCommandRemoved)
	ON_LBN_SELCHANGE(IDC_TEXTLIST, OnSelChangeTextList)
	ON_BN_CLICKED(IDC_RESET_ALL_MENUS, OnClickedResetAllMenus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CCustomDialog::CreateToolbars(void)
{
	CStringArray rgTitles;

	// REVIEW: Optimize, somehow.
	m_pGroups->CreateCustomizeToolbars(this, m_pManager, &m_aToolbars, &rgTitles, &m_aIds);
		
	CRect rectTools;
	m_statTools.GetWindowRect(rectTools);
	ScreenToClient(rectTools);
	
	CString strTitle;
	CASBar* pBar;
	int nCount = m_aToolbars.GetSize();

	for (int i = 0; i < nCount; i++)
	{
		pBar = GetToolbar(i);
		if(pBar)
		{
			pBar->SetParent(this);
			pBar->SetWindowPos(&wndTop, rectTools.left, rectTools.top,
				rectTools.Width(), rectTools.Height(), SWP_NOACTIVATE);

			// if relevant, set up scroll bar info
			SCROLLINFO si;

			si.cbSize=sizeof(SCROLLINFO);
			si.fMask=SIF_POS | SIF_RANGE;
			si.nMin=si.nMax=0;
			si.nPos=0;
			si.nTrackPos=0;

			CSize statSize=rectTools.Size();
			statSize.cx-=::GetSystemMetrics(SM_CXVSCROLL);
			CSize barFit=pBar->GetSize(HTRIGHT, statSize);

			if(rectTools.Size().cy < barFit.cy) {
				// scroll bar will be required
				si.nMax=barFit.cy-rectTools.Size().cy;
			}

			pBar->SetScrollInfo(SB_VERT,&si);
			
		}
		m_cbCategories.AddString(rgTitles[i]);
	}

	ASSERT(IDS_ALLCOMMANDS+1==IDS_DELETEDCOMMANDS);
	ASSERT(IDS_DELETEDCOMMANDS+1==IDS_MENUS);
	ASSERT(IDS_MENUS+1==IDS_NEWMENU);

	// point at first text entry
	m_iTextListBase=m_cbCategories.GetCount();

	// add the textual entries
	CString textList;
	for(listFill lf=cListFillFirst; lf< cListFillFirst+cListFillCount; lf=(listFill)((int)lf+1))
	{
		textList.LoadString(cTextListStringBase+lf-cListFillFirst);
		m_cbCategories.AddString(textList);
	}

	//hide the all commands list
	m_lbTextList.ShowWindow(SW_HIDE);

	m_cbCategories.SetCurSel(0);
	OnSelChangeCategories();

}

/////////////////////////////////////////////////////////////////////////////
// CCustomDialog message handlers

//      CCustomDialog::OnInitDialog
//              Create the custom toolbars to be displayed in this dialog, and
//              fill the list with their names.

BOOL CCustomDialog::OnInitDialog()
{
	CCommandTab::OnInitDialog();
	
	SetDescriptionText(0);

	ReloadMacros();
	m_pGroups  = CAppToolGroups::GetAppToolGroups(TRUE);

	// Fill the menu filters list
	ASSERT(IDS_MENUFILTER_CURRENT+1==IDS_MENUFILTER_ALL);

	CString strFilter;
	strFilter.LoadString(IDS_MENUFILTER_CURRENT);
	m_cbMenuFilter.AddString(strFilter);
	strFilter.LoadString(IDS_MENUFILTER_ALL);
	m_cbMenuFilter.AddString(strFilter);

	m_cbMenuFilter.SetCurSel(0);

	CreateToolbars();

	OnSelChangeMenuFilter();

	m_btnModifySelection.SubclassDlgItem(IDC_MODIFY, this);
	m_btnModifySelection.SetPopup(CToolCustomizer::GetButtonMenu());
	m_btnModifySelection.m_pMenuParent=AfxGetMainWnd();

	m_statDescription.SetFont(GetStdFont(font_Normal));
	GetDlgItem(IDC_INFORMATION)->SetFont(GetStdFont(font_Normal));

	OnBarSelectChanging(0,0);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

//      CCustomDialog::OnSelChangeCategories
//              Change the visible button group.
void CCustomDialog::OnSelChangeCategories()
{
	int nCurSel=m_cbCategories.GetCurSel();
	CWnd *pButtonGroup=GetDlgItem(IDC_BUTTONGROUP);
	CWnd *pCommands=GetDlgItem(IDC_COMMANDS_TEXT);

	ASSERT(pButtonGroup!=NULL);

	ASSERT(m_iTextListBase!=-1);

	if (m_nSel == nCurSel)
		return;

	// first show the new
	CASBar* pBar = GetToolbar(nCurSel);
	if (pBar != NULL)
	{
		pBar->ShowWindow(SW_SHOWNOACTIVATE);
	}
	else
	{
		// do we need to fill the list?
		listFill lfNew;
		if(nCurSel>=m_iTextListBase)
		{
			lfNew=(listFill) (nCurSel-(int)m_iTextListBase+cListFillFirst);
		}
		else
		{
			lfNew=(listFill)nCurSel;
		}
		if(lfNew!=m_lfCurrent)
		{
			m_lbTextList.SetRedraw(FALSE);
			m_lbTextList.ResetContent();

			switch(lfNew)
			{
				case cListFillCommands:
					theCmdCache.FillAllCommandsList(&m_lbTextList);
					break;

				case cListFillDeletedCommands:
					theCmdCache.FillDeletedCommandsList(&m_lbTextList);
					break;

				case cListFillMenus:
					theCmdCache.FillMenuList(&m_lbTextList);
					break;

				case cListFillNewMenu:
					theCmdCache.FillNewMenuList(&m_lbTextList);
					break;

				default:
					{
						// We must be a text category in the bars section, so fill
						for(int i=0;i<m_pGroups->m_nGroups; ++i)
						{
							if(m_pGroups->m_rgGroups[i].m_nId==m_aIds[nCurSel])
							{
								// found the group
								m_pGroups->m_rgGroups[i].FillCommandList(&m_lbTextList,TRUE);
								break;
							}
						}
					}
					break;
					
			}
			m_lbTextList.SetRedraw(TRUE);
			m_lbTextList.Invalidate();

			m_lfCurrent=lfNew;
		}
		m_lbTextList.SetCurSel(-1);
		OnSelChangeTextList();
		m_lbTextList.ShowWindow(SW_SHOWNOACTIVATE);
	}
	
	CASBar* pBarOld = GetToolbar(m_nSel);
	if (pBarOld != NULL)
	{
		pBarOld->ShowWindow(SW_HIDE);

		if(CASBar::s_pCustomizer)
		{
			// Clear customizer selection.
			if (CASBar::s_pCustomizer->m_pSelectBar &&
				pBarOld == CASBar::s_pCustomizer->m_pSelectBar->GetRealObject())
				CASBar::s_pCustomizer->SetSelection(NULL, 0);
		}

		if(pBar==NULL)
		{
			pButtonGroup->ShowWindow(SW_HIDE);
			pCommands->ShowWindow(SW_SHOWNOACTIVATE);
		}
	}
	else
	{
		// if we've moved from a text item to a button item, hide the list
		if(pBar!=NULL)
		{
			m_lbTextList.ShowWindow(SW_HIDE);
			pButtonGroup->ShowWindow(SW_SHOWNOACTIVATE);
			pCommands->ShowWindow(SW_HIDE);
		}
	}

	m_nSel = m_cbCategories.GetCurSel();
	SetDescriptionText(0);
}

//      CCustomDialog::OnSysCommand
//              Disallow switching to the main window.

void CCustomDialog::OnSysCommand(UINT nID, LPARAM lParam)
{
    switch (nID & 0xfff0)
    {
    case SC_PREVWINDOW:
    case SC_NEXTWINDOW:
	if (LOWORD(lParam) == VK_F6)
	    return;
	break;
    }
	
	CCommandTab::OnSysCommand(nID, lParam);
}

LRESULT CCustomDialog::OnBarSelectChanging(WPARAM wParam, LPARAM lParam)
{
	// update description
	UINT nIndex=(UINT)wParam;
	CToolBarProxy* pBar= (CToolBarProxy*) lParam;

	UINT nID = 0;
	if (pBar != NULL)
	{
		UINT nStyle; int iImage;
		pBar->GetButtonInfo(nIndex, nID, nStyle, iImage);
	}

	SetDescriptionText(nID);

	// update availability of buttons
	BOOL bEnableChoose=FALSE;
	if (CASBar::s_pCustomizer!=NULL &&
		CASBar::s_pCustomizer->m_pSelectBar != NULL)
	{
		bEnableChoose=TRUE;
	}
	CButton *pChoose=(CButton *)GetDlgItem(IDC_MODIFY);
	ASSERT(pChoose!=NULL);
	pChoose->EnableWindow(bEnableChoose);

	return 0;
}

//      CCustomDialog::GetToolbar
//      Gets the CASBar for the given index from m_aToolbars, or for
//              the current selection if no index is given.
CASBar* CCustomDialog::GetToolbar(int nIndex)
{
	if (nIndex < 0 || nIndex >= m_aToolbars.GetSize())
		return NULL;
	else
		return (CASBar*) m_aToolbars[nIndex];
}

BOOL CCustomDialog::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	if (!CCommandTab::Activate(pParentWnd, position))
		return FALSE;

	// TRUE if a command list needs to be rebuilt
	BOOL bReList=FALSE;

	if (m_pGroups != NULL)
	{
		if (m_pGroups->ScanCommandCache())
		{
			DestroyToolbars();
			CreateToolbars();

			if(GetToolbar()==NULL)
			{
				bReList=TRUE;
			}
		}
	}

	theApp.ActivateDraggableCustomizePage(this);

	// If the deleted or all commands list are visible, refill them to allow for any 
	// customization that happened in other tabs
	if(bReList ||
		m_lfCurrent==cListFillCommands ||
		m_lfCurrent==cListFillDeletedCommands)
	{
		// fake change to force refill
		if(	m_lfCurrent==cListFillNewMenu)
		{
			m_lfCurrent=cListFillDeletedCommands;
		}
		else
		{
			m_lfCurrent=cListFillNewMenu;
		}
		m_nSel=cListFillNewMenu+m_iTextListBase-cListFillFirst;
		OnSelChangeCategories();
	}

	// If we're supposed to auto-select a command (launched from
	//  Tools.Macro), then do it now.  In the key customize dlg this
	//  is done in OnInitDialog.  In CCustomDlg, though, we must do
	//  this in Activate, since it must happen after the call to
	//  ActivateDraggableCustomizePage; otherwise, we'll assert
	//  in OnSelChangeCategories, that CASBar::s_pCustomizer is NULL.
	AutoSelectInitialCommand();

	OnSelChangeMenuFilter();

	return TRUE;
}

void CCustomDialog::AutoSelectInitialCommand()
{
	if (m_strInitialCommand.IsEmpty())
		return;

	CToolGroup* pToolGroup = m_pGroups->GroupFromCommandName(m_strInitialCommand);
	if (pToolGroup == NULL)
	{
		ASSERT(FALSE);
		m_strInitialCommand.Empty();
		return;
	}

	// Found the right group.  Select it in the list
	int nCategoryToSelect = 
		m_cbCategories.FindStringExact(-1, pToolGroup->m_strGroup);
	if (nCategoryToSelect == CB_ERR)
	{
		// The command's category isn't in the combo.  Can't be!
		ASSERT(FALSE);
		m_strInitialCommand.Empty();
		return;
	}

	m_cbCategories.SetCurSel(nCategoryToSelect);
	OnSelChangeCategories();

	if (GetToolbar(nCategoryToSelect) == NULL)
	{
		// Select the command passed in
		m_lbTextList.SelectString(-1, m_strInitialCommand);
		OnSelChangeTextList();
	}

	// Done with m_strInitialCommand, so empty it out
	m_strInitialCommand.Empty();
}

void CCustomDialog::Deactivate(CTabbedDialog* pParentWnd)
{
	CCommandTab::Deactivate(pParentWnd);

	theApp.DeactivateDraggableCustomizePage(pParentWnd);

	CMainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();
	// revert menus to their normal state
	pFrame->RebuildMenus();
}

// Update the command description text after the selection changes
void CCustomDialog::OnSelChangeTextList() 
{
	UINT nIndex=m_lbTextList.GetCurSel();
	
	// currently, we show no description for menus
	if(nIndex!=LB_ERR)
	{
		UINT nID = m_lbTextList.GetItemData(nIndex);

		SetDescriptionText(nID);

		CTE *pCTE=theCmdCache.GetCommandEntry(nID);
		if(pCTE)
		{
			if(pCTE->flags & CT_MENU)
			{
				CASBar::HideInvalidDestination(nID);
			}
		}
	}
	else
	{
		SetDescriptionText(0);
	}
}

// Update the menus after the menu filter is changed.
void CCustomDialog::OnSelChangeMenuFilter() 
{
	UINT nIndex=m_cbMenuFilter.GetCurSel();

	CMainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();

	if(nIndex==cMenuFilterCurrent)
	{
		// hide transients, but show only for this editor
		pFrame->RebuildMenus(FALSE, TRUE, TRUE);
	}
	else
	{
		// hide transients, and show for all editors
		pFrame->RebuildMenus(TRUE, TRUE, TRUE);
	}
}

//      CCustomDialog::OnClickedResetAllMenus
//              Resets all menus
void CCustomDialog::OnClickedResetAllMenus()
{
	// ask mainframe to reset all menus
	CMainFrame*pFrame=(CMainFrame*)AfxGetMainWnd();

	pFrame->ResetAllMenus();

	if(	CASBar::s_pMenuBar)
	{
		CASBar::s_pMenuBar->Reset();
	}

	// get the menus rebuilt into customized form
	OnSelChangeMenuFilter();
}

// Called when a command was removed by customization
LRESULT CCustomDialog::OnCommandRemoved(WPARAM wParam, LPARAM lParam)
{
	// only add to the list if the current fill is deleted commands. Doesn't matter if the list is actually visible
	if(m_lfCurrent==cListFillDeletedCommands)
	{
		// This is called when a command is deleted
		UINT nIDCmd=(UINT)wParam;

		// get the command table entry for the missing command 
		CTE *pCTEMissing=theCmdCache.GetCommandEntry(nIDCmd);
		
		// Add the command to the list box, if it's not already in there
		LPCTSTR lpszCmdName = pCTEMissing->szCommand;
		int nOldIndex=m_lbTextList.FindStringExact(0, lpszCmdName);
		if(nOldIndex==LB_ERR)
		{
			int index = m_lbTextList.AddString(lpszCmdName);
			if(index!=LB_ERR)
			{
				m_lbTextList.SetItemData(index, (DWORD) pCTEMissing->id);
			}
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bardlgs.h ===
///////////////////////////////////////////////////////////////////////////////
//	BARDLGS.H
//      Contains declarations for the dockable toolbar dialogs.
///////////////////////////////////////////////////////////////////////////////

#ifndef __BARDLGS_H__
#define __BARDLGS_H__

#include "dlgbase.h"
#include "utilctrl.h"
#include "btnctl.h"
#include "resource.h"
#include "customiz.h"

class CDockManager;
class CDockWorker;
class CASBar;

/////////////////////////////////////////////////////////////////////////////
// CToolbarDialog dialog

//	CToolbarCheckList control.
//		Override CCheckList for check notification to the dialog.

class CToolbarCheckList : public CCheckList
{
public:
	virtual void SetCheck(int nItem, BOOL bCheck);
};

class CToolbarDialog : public CDlgTab
{
// Construction
public:
	CToolbarDialog(CDockManager* pManager, CWnd* pParent = NULL);
	~CToolbarDialog();

	virtual BOOL Create();
	
	void LockManager(BOOL bLock);
	void UpdateCheck(UINT nIDWnd);
	BOOL UpdateVisible(int nItem);
	void AddToolbar(CDockWorker* pDocker);
	void RemoveToolbar(CDockWorker* pDocker);
	CDockWorker* GetWorker(int nIndex = LB_ERR);
	BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	void Deactivate(CTabbedDialog* pParentWnd);

// Dialog Data
	//{{AFX_DATA(CToolbarDialog)
	enum { IDD = IDD_TOOLBARS };
	CStatic m_statName;
	CEdit	m_edName;
	CButton	m_btnDelete;
	CButton	m_btnReset;
	CButton	m_btnResetAllBars;
	CButton	m_btnShow;
	CString	m_strName;
	BOOL m_bToolTips;
	BOOL m_bKeys;
	BOOL	m_bLargeToolBars;
	//}}AFX_DATA
	CToolbarCheckList m_lbToolbars;
	
	int m_nSel;
	CDockManager* m_pManager;
	CObArray m_aToolWorkers;

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CToolbarDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedDelete();
	afx_msg void OnClickedReset();
	afx_msg void OnClickedResetAllBars();
	afx_msg void OnClickedNew();
	afx_msg void OnClickedToolTips();
	afx_msg void OnClickedKeys();
	afx_msg void OnSelChangeToolbar();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnClickedLargeToolBars();
	//}}AFX_MSG

	// resets the nIndex bar in the list
	void ResetBar(int nIndex);
    
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CToolbarDialog)
};

/////////////////////////////////////////////////////////////////////////////
// CNewBarDialog dialog

class CNewBarDialog : public C3dDialog
{
// Construction
public:
	CNewBarDialog(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CNewBarDialog)
	enum { IDD = IDD_NEWTOOLBAR };
	CButton	m_btnOK;
	CString	m_strName;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CNewBarDialog)
	afx_msg void OnChangeName();
	afx_msg void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CCustomDialog dialog

class CCustomDialog : public CCommandTab
{
// Construction
public:
	CCustomDialog(CDockManager* pManager, CWnd* pParent = NULL);
	~CCustomDialog();

	virtual BOOL Create();
	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

	void LockManager(BOOL bLock);
	CASBar* GetToolbar(int nIndex = LB_ERR);
	void SetDescriptionText(UINT nID);
	
// Dialog Data
	//{{AFX_DATA(CCustomDialog)
	enum { IDD = IDDP_CUSTOMIZE_TOOLBARS };
	CButtonDragListBox	m_lbTextList;
	CComboBox			m_cbCategories;
	CComboBox			m_cbMenuFilter;
	CStatic				m_statDescription;
	CStatic				m_statTools;
	CButton				m_btnResetAllMenus;
	CMenuBtn			m_btnModifySelection;
	//}}AFX_DATA

	int m_nSel;
	CDockManager* m_pManager;
	CObArray m_aToolbars;
	// ids of categories; used for text categories
	CWordArray m_aIds;
	CAppToolGroups *m_pGroups;
	enum listFill	{	cListFillFirst=-5,
						cListFillCommands=-5,			// all commands
						cListFillDeletedCommands=-4,	// all commands which have been deleted from toolbars or menus
						cListFillMenus=-3,				// all menu bars
						cListFillNewMenu=-2,			// an empty custom menu
						cListFillCount=4,				// number of items
						cListFillNone=-1,
						cListFillNormalFirst=0
	};
	enum { cTextListStringBase=IDS_ALLCOMMANDS }; // the strings for the other
	enum menuFilters {	cMenuFilterCurrent=0,
						cMenuFilterAll=1 };
	enum { cMenuFilterStringBase=IDS_MENUFILTER_CURRENT };

									// possible text list entries should be monotonically
									// increasing from here.
	listFill m_lfCurrent;			// tells what the text list is currently filled with
									// to minimize the number of list re-fills
	int	m_iTextListBase;			// the item number within the categories list box that
									// contains the first text list item.
	
// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	void AutoSelectInitialCommand();
	// creates the toolbar set
	void CreateToolbars(void);
	// destroys it
	void DestroyToolbars(void);
	

	// Generated message map functions
	//{{AFX_MSG(CCustomDialog)
	afx_msg void OnSelChangeCategories();
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg LRESULT OnBarSelectChanging(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSelChangeTextList();
	afx_msg void OnSelChangeMenuFilter();
	afx_msg void OnClickedResetAllMenus();
    afx_msg LRESULT OnCommandRemoved(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CCustomDialog)
};

#endif __BARDLGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barcust.h ===
///////////////////////////////////////////////////////////////////////////////
//      BARCUST.H
//      Contains declarations for the major classes relavant to Sushi
//              toolbars CToolCustomizer, CASBar, CBorderBar, CToolbarDialog, and
//              CCustomDialog.
///////////////////////////////////////////////////////////////////////////////

#ifndef __BARCUST_H__
#define __BARCUST_H__

#include "transbut.h"
#include "custprxy.h"

//	class CWnd;
//		class CToolBar;
			class CCustomBar;
struct TRANSFER_TBBUTTON;
struct TBBUTTON_EXTRA;

class CDockManager;

/////////////////////////////////////////////////////////////////////////////
// CCustomBar window
// Toolbar button overview
// All toolbar buttons have a glyph, except separators and textual buttons. Hwnd buttons are
// only drawn as HWNDs when horizontal; when vertical, they pay attention to styles such as
// TEXTUAL, CUSTOMBITMAP, etc.

// The master (saved) copy of each custom bitmap is considered to be the one the user last 
// *edited*. This is independent of which one the user last displayed. When the user is 
// displaying the other button size (not the size of the edited bitmap), then the extra
// button info contains the master. Otherwise, the master is within the image well.

// martynl 15Apr96

// This struct contains the extra information that can be required by each button
// This class must contain no virtuality, and no base class

// Note that the array of these structures won't be allocated until the first one is required.
// This means that you should only use GetXXX() functions if you are sure the data will already
// be there. If the presence of data is in question (for example with a custom bitmap button
// where you have not yet established the presence of a second bitmap), then you should
// use CCustomBar::HasButtonExtra() first to check if the extra array is present.


extern void GetDroppedRect(HWND hwnd, LPRECT rect);

// These two styles extend the CBRS_ styles in MFC CControlBar; We should ensure 
// that the value of this constant is distinct from all of MFC's CBRS_ styles. 
// Currently, the highest CBRS_ style is 0x8000.

// This style is an augmentive style to CControlBar::GetBarStyle(). It inhibits the
// control bar's dragging functionality for moving or copying buttons. We need this
// for the custom button dialog.  martynl 27Mar96
#define CTBRS_NODRAG    0x10000

// This style is an augmentive style to CControlBar::GetBarStyle(). It tells a command
// bar that it should behave like, and draw like, a main menu. Menus on the main menu
// are drawn without dropdown arrows. Also, main menus cannot be deleted, and have the 
// primary keyboard semantics.
// martynl 23Apr96
#define CTBRS_MAINMENU  0x20000

/* The GetItemRect problem

One of the major problems with CCustomBar in 4.x is that it overrides CToolBar::GetItemRect without
modifying its parameter list. This means that GetItemRect doens't know, when it's called, what
orientation the bar is in [information which is required to correcly enumerate button rects].

The solution to GetItemRect's problems appears to be clear - just call GetOrient to determine the correct
orientation of the bar. However, this will not work.

The CCustomBar class incorporates a number of speculative positioning routines. This is code that tries
to decide what shape a bar would (or should) be in a future context. For example, this code is used to 
drag size the bar, and by the docking manager to draw a snapsize outline of the bar during bar dragging.

Because GetItemRect is called from within speculative positioning routines (Fit, GetSize, GetVSize, etc)
it can't call GetOrient, because GetOrient returns the current orientation, not the orientation that is
being speculatively calculated.

This problem was further exacerbated in 4.0 by our desire to keep the CToolBar class roughly as it was when 
we took it from MFC. So we couldn't change the parameters of GetItemRect without spoiling the virtual function
table.

So 4.x solved the problem with a nasty hack in GetItemRect. There was only one type of item in 4.x that was
sized and rendered differently depending on orientation: the window button. (TBBS_HWND). So 4.x measured 
the window for the button and, if the window was too large for the bar size, it would assume the bar was
vertical.

This worked ok in 4.0 (though it led to an odd situation if you resize a sizeable hwnd button to very small, 
and then vertically dock it). 

5.0 adds loads of buttons and toolbar areas which are different in different orientations. So I've solved
the problem by passing an orientation to GetItemRect, and promoting the definition of orientation to the oldbar
code.

To allow older users of the code to maintain the same GetItemRect interface to CToolBar, an inline function
in shlbar.h does a translation. However, this function is overridden privately in CCustomBar, since all
custombar derived callers must specify orientation depending on whether their code can be called speculatively
or not.

martynl 19/06/96

*/

class CCustomBar : public CToolBar
{
	friend class CToolCustomizer;
	friend struct TRANSFER_TBBUTTON;
	friend class CCustomBarProxy;


public:
	// Bar and Index of the currently dropped menu item, or NULL and -1
	// Only one menu can be dropped from all bars at any give time, so this is static
	static CCustomBar *s_pDroppedBar;
	static int s_nDroppedItem;
	// A pointer to the current system menu, if there is one. 
	static CBMenuPopup *s_pSystemMenu;
	// the screen coordinates point where the last MouseMove was processed. We skip if we've processed a move 
	// very close to this before - stabilizes joint keyboard and mouse usage.
	static CPoint s_ptLastMove;
	// TRUE if this CCmdUI update has created a requirement for a recalclayout
	static BOOL s_bRecalcLayoutPending;

	// cancels any dropped menu on any bar
	static void CancelMenu(void);
	// cancels this menu, or any menu that contains it
	static void HideInvalidDestination(UINT nId);
	// implements specific menu cancelling for bars
	void HideInvalidBarDestination(UINT nId);
    
// Construction.        
    CCustomBar();
    virtual ~CCustomBar();
							   
    BOOL Create(DWORD dwStyle, const CRect& rect, CWnd* pParent, UINT nID);

// Operations.
public:
    BOOL IsInDialog();

#ifdef _DEBUG
	virtual void AssertValid() const;
#endif
	
	virtual CToolCustomizer* GetCustomizer() = 0;
	virtual ORIENTATION GetOrient() const;
	virtual BOOL IsStaticItem(int nIndex);

	virtual CCustomBar* NewBar(UINT nID, const CPoint& pt);
	virtual void MoveBar(const CRect& rect);
	virtual void OnSelChange(int nIndex);
	virtual void OnDeleteSelection();
	virtual void OnBarActivate();
	virtual void OnButtonSize();

	virtual void GetButtonTransferInfo(int nIndex, DWORD& dwData,
		TRANSDATA_CALLBACK* lplpDataCallback) const {;}
		// Override to add data to the TRANSFER_BUTTON struct.

	// This function gets the extra button data, but can return NULL in release versions, and 
	// ASSERT in debug versions. Use it to access data that you expect to already exist. 
	// If you don't know if the button extra info exists, use HasButtonExtra()
	// Get functions only.
	inline const TBBUTTON_EXTRA *GetButtonExtra(int iButton) const { ASSERT(m_pButtonExtra!=NULL); return &(m_pButtonExtra[iButton]); };
	// use to check if extra info is available
	inline BOOL HasButtonExtra(void) const { return (m_pButtonExtra!=NULL); };
	// This function gets the extra button data, and cannot return NULL, because it will
	// allocate the button data if necessary.
	TBBUTTON_EXTRA *EditButtonExtra(int iButton);

	virtual HWND GetControl(UINT nID);
	virtual void RemoveControl(HWND hwndRemove);
	virtual void LoseFocus() {;}    // Override for hwnd controls.

    virtual CSize GetHSize(ORIENTATION or);
    virtual CSize GetVSize();
	virtual int GetVWidth() const;
    virtual CSize GetSize(UINT nHitTest, CSize size);
    virtual void RecalcLayout(UINT nHTSize = HTRIGHT, ORIENTATION *pOr=NULL);
    virtual void RecalcSizes();

	// sets up default button sizes for small or large toolbars
	// does not initiate any redraw 
	void SetDefaultSizes(BOOL bLarge);
	// returns the size of a standard toolbar bitmap
	static CSize GetDefaultBitmapSize(BOOL bLarge);
	// returns the size of a standard toolbar button
	static CSize GetDefaultButtonSize(BOOL bLarge);

	// Warning: Non-virtual overrides.
	BOOL LoadBitmap(LPCSTR lpszResourceName, BOOL bUpdateTiles = TRUE);
	BOOL LoadBitmap(UINT nIDResource, BOOL bUpdateTiles = TRUE);
	void SetBitmap(HBITMAP hbmImageWell, BOOL bUpdateTiles = TRUE);
	// lpIDArray can be NULL to allocate empty buttons
	BOOL SetButtons(const UINT FAR* lpIDArray, int nIDCount);
    
	CSize Fit(int nWidth, ORIENTATION or);
	int IndexFromPoint(const CPoint& pt, CRect *pButtonRect=NULL);
	BOOL IsGap(int nIndex);
	BOOL IsValidCtrlSize(CWnd* pWnd);
	virtual void GetItemRect(int nIndex, LPRECT lpRect, ORIENTATION or) const;
	void EnumItemRects(int nIndex, CRect& rect, BOOL& bWrapped, ORIENTATION or,
		LPCRECT lpRect = NULL) const;

	BOOL ShiftImage(int nIndex, int nTiles,
		TRANSFER_TBBUTTON* pTrans = NULL);
	BOOL BltCommandBitmap(HBITMAP, int nGlyph,
		HDC hdcDest, int nDest, HDC hdcSrc);
	virtual void DeleteButton(int nIndex, BOOL bMoving = FALSE);
	virtual int InsertButton(int nIndex, TRANSFER_TBBUTTON& trans,
		BOOL bReplace, GAP gap);
	// add this command id button to the end of the bar. Returns the insertion index
	virtual int AppendButton(UINT nId);

	// a button must always have at least one of a label or a glyph (unless it's a separator).
	// So to convert a button, first add the new properties, then remove the old if required

	// add or replace the label of a button
	void AddText(int nIndex); // default menu text
	void AddText(int nIndex, const CString &text, BOOL bCustom);
	// add or replace the bitmap of a button.
	void AddBitmap(int nIndex, BITMAPSOURCE bsSource=cBitmapSourcePackage, HBITMAP hbmCustom=NULL);
	// remove the label from a glyph+label button
	void RemoveText(int nIndex);
	// remove the glyph from a glyph+label button
	void RemoveBitmap(int nIndex);

	// returns TRUE if this bar could paste the current clipboard
	BOOL CanPasteImage(void);
	// returns TRUE if the selected button could be reset
	BOOL CanResetImage(void);
	// returns true if the choose button dialog could be applied to the selected button
	BOOL CanChooseAppearance(void);
	// call to invoke choose/edit/paste/reset button dialog on the selected button
	void ChooseButtonAppearance(void);
	void EditButtonImage(void);
	void PasteButtonImage(void);
	void ResetButtonImage(void);
	// called to update the enable status of a button
	virtual void UpdateButton(int nIndex);
	CToolBarProxy* GetProxy()
		{ return &m_Proxy; }
	// Returns TRUE if the item is expecting to regain the focus to the bar
	virtual int ExpandItem(int nIndex, BOOL bExpand, BOOL bKeyboard=FALSE);
	// menu calls this when it is completed, to stop the bar tracking
	virtual void MenuDone();
	virtual void AdjustMenuBar();
	virtual CBMenuPopup *GetItemMenu(int iButton);
	virtual void UpdateMDIIcon();
	// Does this bar contain a button with this command id
	BOOL FindButton(UINT nId) const;
	void EnsureMDIControls(void);
	int FindNextVisibleItem(int nIndex, BOOL bForward);
	// update the text of a button
	virtual void UpdateText(int nIndex, LPCTSTR newText);
	// Returns the HT code to use to resize the bar when expanding it. This function decides whether the bar
	// wants to be stretched vertically or horizontally, given the rect position that the expansion is occurring
	// If bUseOrient is TRUE, then orBar must point at a valid incoming orientation
	UINT GetExpansionConstraint(const CRect &expand, ORIENTATION *orBar=NULL, BOOL bUseOrient=FALSE);

protected:
	// removes any windows, custom bitmap data or strings from the bar extra data
	void RemoveExtra();
	// removes any windows
	void RemoveWindows();
	void Empty();
	// always use this function to access the font for drawing textual toolbar buttons
	// it will create the font as required. martynl 21Mar96
	CFont *GetTextFont(ORIENTATION or);
	// removes a string from the extra information
	void RemoveTextLabel(int nIndex);
	// causes button bitmaps to be reloaded from packages or custom bitmaps
	void RefreshButtonBitmaps();
	// causes a button bitmap to be reloaded from package or custom bitmap; copies
	// the bitmap for pTBB into hdcdest
	void RefreshButtonBitmap(HDC hdcDest, HDC hdcSrc, int nIndex);
	// gets the bitmaps for menu arrows
	HBITMAP GetMenuArrow(ORIENTATION or);
	HBITMAP GetDisabledMenuArrow(ORIENTATION or);
	// helper: measure the size of a string button if drawn into the bar
	void MeasureString(int nIndex, CSize &, ORIENTATION or);
	// Removes a separator before a button
	void RemoveSeparator(int iButton);
	// Inserts a separator before a button
	void InsertSeparator(int iButton);
	// call when a button has been modified, to update internal status, mark dirty, recalc
	void ButtonModified(int nIndex, BOOL bSized);
	// Over time we should move to using functions to interpret button flags, rather than testing
	// the flags directly
	// TRUE if the item can popup in keyboard focus
	BOOL CanFocus(int iButton);
	// TRUE if it's an hwnd button whose hwnd is visible
	BOOL IsVisibleControl(int iButton) const;
	// TRUE if this bar is the current host of the MDI gadgets
	BOOL IsMDIHost(void) const;
	// draws the small document icon in the top/left corner
	BOOL DrawMDIDocumentIcon(CDC* pDC, const CRect &rectIcon);
	// draws the MDI controls on a menu bar (doc icon, & min restore close)
	void DrawMDIControls(CDC* pDC);
	// tests and acts on 
	BOOL CheckMDIButtons(UINT nFlags, CPoint point);

	enum MDIBUTTON {
		cMDINotDrawn=-3,	// MDI buttons aren't even drawn
		cMDINoButton=-2,	// MDI buttons are drawn but inactive
		cMDIDragging=-1,	// Anything higher than this means a drag is happening
		cMDIDragPending=-1, // this is used when a drag is in progress, but the mouse isn't over a button
		cMDIIcon=0,
		cMDIRectFirst=0,
		cMDIMinimize=1,
		cMDIRestore=2,
		cMDIClose=3,
		cMDIRectLast=3,
		cMDIRectCount=4
	};
	
	// gets the rects of the mdi buttons
	void GetMDIButtonRects(CRect rects[cMDIRectCount]);
	// checks if an MDI button was hit
	MDIBUTTON HitTestMDI(CPoint point);

	int CountTiles();

	enum GLYPHSTATUS {
		cGlyphsUnknown=0,
		cGlyphsAbsent=1,
		cGlyphsPresent=2
	};

	// returns whether the bar contains any glyphs at all, for drawing purposes (only the main menu bar might say no)
	BOOL HasGlyphs(void) const;
	// sets the glyphs status when it is known
	void SetGlyphStatus(GLYPHSTATUS gs) { m_glyphStatus=gs; };
	// get the size of buttons in the bar
	CSize GetButtonSize(ORIENTATION or) const;
	
	virtual void DoPaint(CDC* pDC);
	virtual int HitTest(CPoint point, BOOL bCheckWindow=TRUE) const;
	int SizeTest(CPoint point);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL OnButtonPressed(int iButton);
	virtual int OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual BOOL ShouldExtrude(int iButton);

    //{{AFX_MSG(CASBar)
	afx_msg void OnKillFocus(CWnd *);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
    
	DECLARE_DYNAMIC(CCustomBar);
    DECLARE_MESSAGE_MAP()

	int GetLeftBorder(ORIENTATION or) const;
	int GetTopBorder(ORIENTATION or) const;
	int GetRightBorder(ORIENTATION or) const;
	int GetBottomBorder(ORIENTATION or) const;
	int GetLeftMDIArea(ORIENTATION or) const;
	int GetTopMDIArea(ORIENTATION or) const;
	int GetRightMDIArea(ORIENTATION or) const;
	int GetBottomMDIArea(ORIENTATION or) const;
	void DrawGrabber(CDC* pDC);



// Attributes.
protected:
	int m_cxRightBorder;
	int m_cyDefaultGap;
	CSize m_sizeMaxLayout;
	CSize m_sizeFixedLayout;
	int m_nTiles;
	TBBUTTON_EXTRA *m_pButtonExtra;     // may be NULL
	CCustomBarProxy m_Proxy;
    static HCURSOR s_hcurVSize;
	// it's an enum so that we don't allocate storage
	enum {
		cExtraTextBorder=3, // extra width added around string contained in
							// a textual button, for cosmetic purposes
		cGrabberWidth=8,    // when on left
		cGrabberHeight=8    // when at top
	};

	// stuff used by main menu bar; could go in a subclass
	HICON m_hIconMDI;
	// the mdi drawing/tracking status of the bar
	int m_nMDITrack;
	// knows whether the bar has glyphs at the moment, or whether we need to recalc the fact
	mutable GLYPHSTATUS m_glyphStatus; 

private:
	// Do not use this. See comment at top of class.
	using CToolBar::GetItemRect;
};

extern UINT DSM_BARSELECTCHANGING;
// This message will be sent whenever the selected toolbar button has changed during
// toolbar customisation
// WPARAM: nIndex - index of newly selected button
// LPARAM: pBar - pointer to bar containing newly selected button

extern UINT DSM_DROPMENU;
// WPARAM: index of item to drop (prevalidated)
// LPARAM: keyboard flag

inline BOOL CCustomBar::IsInDialog()
{       ASSERT(GetParent() != NULL);
	return GetParent()->IsKindOf(RUNTIME_CLASS(CDialog)); }

inline BOOL CCustomBar::LoadBitmap(UINT nIDResource, BOOL bUpdateTiles /*=TRUE*/)
	{ return LoadBitmap(MAKEINTRESOURCE(nIDResource), bUpdateTiles); }

#endif  // __BARCUST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bardockx.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  BARDOCKX.CPP
//      Contains implementations CASBar, the dockable toolbar class.
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "shell.h"
#include "bardockx.h"
#include "bardlgs.h"
#include "util.h"
#include "shlmenu.h"
#include "barglob.h"
#include "shell.h"
#include "menuprxy.h"
#include "prxycust.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//      CASBar
//              Derived from CCustomBar, provides docking and command functionality
//              to sushi toolbars.
//

#ifdef _DEBUG
extern BOOL bChicagoLookOnNT;
inline BOOL OnChicago() { return theApp.m_bWin4 || bChicagoLookOnNT; }
#else
inline BOOL OnChicago() { return theApp.m_bWin4; }
#endif

UINT DSM_BARSIZECHANGING = RegisterMessage("DevStudioToolbarSizeChanging");

IMPLEMENT_DYNAMIC(CASBar, CCustomBar)

// static data members.

CObArray NEAR CASBar::s_aUsage;
CToolCustomizer* CASBar::s_pCustomizer = NULL;
CASBar *CASBar::s_pMenuBar=NULL;
CWnd *CASBar::s_pOldFocus=NULL;

//      CASBar::CASBar
//      Construction.

CASBar::CASBar()           
{
	m_bDirty = TRUE;        // Assume we want to write to reg DB.
	m_iKeySelect=-1;
	m_bDropPending=FALSE;

	s_aUsage.Add(this);
}

//      CASBar::~CASBar
//              Destructor, removes the toolbar from the usage list.

CASBar::~CASBar()
{
	int nCount = s_aUsage.GetSize();
	for (int i = 0; i < nCount; i++)
	{
		if (s_aUsage[i] == this)
		{
			s_aUsage.RemoveAt(i);
			break;
		}
	}

	ASSERT(i < nCount);
}

//      CASBar::Create
//              Create function used for a new custom toolbar with one, or no command
//              IDs.  (use -1 for nID for empty toolbar).

BOOL CASBar::Create(CDockManager* pManager, UINT nID, LPCRECT lpRect /*=NULL*/,
	LPCSTR lpszTitle /*=NULL*/)
{
    static DOCKINIT BASED_CODE diInit = {
	0,
	PACKAGE_SUSHI,
		PACKET_NIL,
	"",
	INIT_VISIBLE | INIT_CANHORZ | INIT_CANVERT,
	dtToolbar,
	dpNil,
	dpTop,
	{0,0,0,0}};
	
	TOOLBARINIT tbi;
	DOCKINIT di = diInit;
	
	tbi.nIDCount = 1;
	di.nIDWnd = pManager->GetCustomID();
	tbi.nIDWnd = MAKEDOCKID(di.nIDPackage,di.nIDWnd);

	if (lpszTitle != NULL)
	{
		lstrcpy(di.szCaption, lpszTitle);
	}
	else
	{
		CString strFormat;
		VERIFY( strFormat.LoadString( IDS_DEFTBTITLE ) );

		wsprintf(di.szCaption, strFormat, LOWORD(tbi.nIDWnd) - IDTB_CUSTOM_BASE);
	}
	CSize sizeButton=GetButtonSize(orNil);
	
	CRect rect;
	if (lpRect != NULL)
	{
		rect = *lpRect;

		// Check if we should create this in a dock.
		CPoint ptTest((rect.left + rect.right) / 2,
			(rect.top + rect.bottom) / 2);
		CWnd* pWnd = WindowFromPoint(ptTest);
		
		if (pWnd != NULL && pWnd->IsKindOf(RUNTIME_CLASS(CDockWnd)))
		{
			di.dpInit = ((CDockWnd*) pWnd)->m_dp;
			di.fInit &= ~INIT_VISIBLE;
			di.fInit |= INIT_POSITION;
		}
	}       
	else
	{
		CRect rectDummy;
		pManager->GetDeskRects(rect, rectDummy);
		rect.right = rect.left + sizeButton.cx;
		rect.bottom = rect.top + sizeButton.cy;
		rect.OffsetRect(20, 20);        // Semi-random choice.
	}
	
	di.rectFloat.left = rect.left - m_cxLeftBorder - g_mt.cxBorder;
	di.rectFloat.top = rect.top - m_cyTopBorder - g_mt.cyBorder;
	di.rectFloat.right = rect.right + m_cxRightBorder + g_mt.cxBorder;
	di.rectFloat.bottom = rect.bottom + m_cyBottomBorder + g_mt.cyBorder;

	BOOL bReturn = Create(NULL, pManager, WS_BORDER, &tbi, &nID,
		NULL, TRUE, &di);

	// Move it into the dock if it is not a floater.
	if (bReturn && di.dpInit != dpNil)
	{
		// Custom toolbars always need to be written to the reg DB.
		m_bDirty = TRUE;
	
		DkWMoveWindow(tbi.nIDWnd, di.dpInit,
			&di.rectFloat);
	}
		
	return bReturn;
}

//      CASBar::Create
//              This is where the window is really created.  Above creates call this
//              one.

BOOL CASBar::Create(CWnd* pParent, CDockManager* pManager, DWORD dwStyle,
	TOOLBARINIT FAR* lptbi, UINT FAR* lpIDArray, HGLOBAL hglobInit,
	BOOL bRegister /*=FALSE*/, DOCKINIT FAR* lpdi /*=NULL*/)
{
    // create the HWND
    CRect rect;
    rect.SetRectEmpty();    // Size reset in SetButtons.
    
    if (pParent == NULL)
	{
		ASSERT_VALID(pManager);
		pParent = pManager->GetDock(dpHide);
	}

	dwStyle |= (CBRS_TOOLTIPS | CBRS_FLYBY | DWS_SIZABLE);

	if( lptbi &&
		lptbi->nIDWnd==MAKEDOCKID(PACKAGE_SUSHI, IDTB_MENUBAR)) // nasty hack.
	{
		dwStyle|=DWS_MENUBAR;
	}

	// the TOOLBARINIT structure should now always be filled with a MAKEDOCKID result
	// in its nIDWnd field. This assertion will fail if the field didn't include
	// the required package id.
	ASSERT(HIWORD(lptbi->nIDWnd)!=0);

	m_nIDWnd=lptbi->nIDWnd;

    if (!CCustomBar::Create(dwStyle, rect, pParent, LOWORD(lptbi->nIDWnd)))
	{
		delete this;
		return FALSE;
	}

	// if this is the main menu bar, set up the correct toolbar style
	if( lptbi &&
		lptbi->nIDWnd==MAKEDOCKID(PACKAGE_SUSHI, IDTB_MENUBAR)) // nasty hack.
	{
		m_dwStyle |= CTBRS_MAINMENU;
		ASSERT(s_pMenuBar==NULL);
		s_pMenuBar=this;
	}

	SetOwner(pManager->m_pFrame);   // MFC uses owner for command and notify routing.

    // Set buttons before docking for size.
    if (hglobInit != NULL)
    {
		if(!GetProxy()->SetData(hglobInit))
		{
			DestroyWindow();
			return FALSE;
		}
		lptbi->nIDCount = m_nCount;
		lpIDArray = NULL;
    }
    
    if (!DynSetButtons(lpIDArray, lptbi->nIDCount))
    {
		DestroyWindow();
		return FALSE;
    }
    
    if (bRegister)
    {
		lpdi->fInit |= INIT_CANHORZ | INIT_CANVERT;
	
		// Make sure this is a valid rectangle.
		LRESULT lSize = OnGetMoveSize(lpdi->dpInit,
			MAKELPARAM(lpdi->rectFloat.right - lpdi->rectFloat.left,
			lpdi->rectFloat.bottom - lpdi->rectFloat.top));
		lpdi->rectFloat.right = lpdi->rectFloat.left + LOWORD(lSize);
		lpdi->rectFloat.bottom = lpdi->rectFloat.top + HIWORD(lSize);
	
	CDockWorker* pDocker;
		ASSERT_VALID(pManager);
	    if ((pDocker = pManager->RegisterWnd(this, lpdi)) == NULL)
	    {
		DestroyWindow();
		return FALSE;
		}
		
		if (s_pCustomizer != NULL && s_pCustomizer->m_pDialog != NULL &&
			s_pCustomizer->m_pDialog->IsKindOf(RUNTIME_CLASS(CToolbarDialog)))
		{
			((CToolbarDialog*) s_pCustomizer->m_pDialog)->AddToolbar(pDocker);
		}
	}

    return TRUE;
}

//      CASBar::DynSetButtons
//              Completely resets the button information (data, and imagewell) for
//              the bar.  May be passed an ID array, or use existing data in m_pData,
//              usually loaded from disk.

BOOL CASBar::DynSetButtons(const UINT FAR* lpIDArray, int nIDCount)
{
	int nTiles = 0;
	AFX_TBBUTTON* pTBBNew = NULL;
	TBBUTTON_EXTRA* pExtraNew = NULL;
	HBITMAP hbmNewWell = NULL;
	BOOL bExtraUsed=FALSE; // TRUE if the extra data has been written to.
	GLYPHSTATUS glyphs=cGlyphsUnknown; // as we iterate, remember the glyphs

	ASSERT(nIDCount >= 0);
	if (nIDCount > 0)
	{
		ASSERT(lpIDArray != NULL || m_pData != NULL);

		// If lpIDArray is NULL, then the data comes from the reg DB,
		// otherwise we assume the toolbar is clean.

		if (lpIDArray != NULL)
			m_bDirty = FALSE;
		
		HDC hdcClient = ::GetDC(m_hWnd);
		HDC hdcDest = ::CreateCompatibleDC(hdcClient);
		HDC hdcSrc = ::CreateCompatibleDC(hdcClient);
		
		hbmNewWell = ::CreateCompatibleBitmap(hdcClient,
			nIDCount * m_sizeImage.cx, m_sizeImage.cy);
		::ReleaseDC(m_hWnd, hdcClient);
	
		if (hbmNewWell == NULL || hdcDest == NULL || hdcSrc == NULL)
		{       
			// May RIP.
			::DeleteObject(hbmNewWell);
			::DeleteDC(hdcSrc);
			::DeleteDC(hdcDest);
			return FALSE;
		}
			
		HBITMAP hbmOld = (HBITMAP) ::SelectObject(hdcDest, hbmNewWell);

		CPackage* pPackage;
		
		AFX_TBBUTTON* pTBBNext = pTBBNew =
			(AFX_TBBUTTON*) calloc(nIDCount, sizeof(AFX_TBBUTTON));
		pExtraNew = new TBBUTTON_EXTRA[nIDCount];
		
		int iDest; // index into the destination extra array

		for (int i = 0; i < nIDCount; i++)
		{
			iDest=pTBBNext-pTBBNew;

			if (lpIDArray == NULL)
				*pTBBNext = ((AFX_TBBUTTON*) m_pData)[i];
			else
				pTBBNext->nID = lpIDArray[i];

			if(pTBBNext->nID==-1)
			{
				continue;
			}

			/* despite the fact that 4.x wrote the nStyle information
			out to the registry, the 4.x version of this code just ignored it
			and used the package's version. We use an amalgam of these two 
			strategies. If the button is of a type which cannot be user
			configured, or if the toolbar is not being loaded, then we just use
			the package value. Otherwise, we take notice of the user's optional
			flags. martynl 27Mar96
			*/
			UINT nStyle = theApp.GetCommandBtnInfo(pTBBNext->nID, &pPackage);

			// separator buttons use the package style
			if( (nStyle & (TBBS_SEPARATOR))!=0 ||
				lpIDArray!=NULL)
			{
				// if we're not loading from the registry, or if the button can't be 
				// styled, then use the package versions
				pTBBNext->nStyle = nStyle;
			}
			else
			{
				// if we're loading from the registry, combine the 
				// loaded style and the package style
				UINT nMaskedStyle=pTBBNext->nStyle & (  TBBS_TEXTUAL | TBBS_GLYPH | TBBS_CUSTOMBITMAP | 
														TBBS_CUSTOMTEXT | TBBS_MENU | TBBS_SEPARATOR);

				// allow the registry to control glyph and textual, since it knows what it saved
				UINT nMaskedPackageStyle=nStyle & ~(TBBS_GLYPH|TBBS_TEXTUAL|TBBS_CUSTOMBITMAP|TBBS_CUSTOMTEXT);

				pTBBNext->nStyle = nMaskedPackageStyle | nMaskedStyle;
			}

			// if it's not a separator, and we can't find a package for this command, then it must be invisible
			if((pTBBNext->nStyle & TBBS_SEPARATOR)==0 &&
				pPackage==NULL)
			{
				ASSERT(pTBBNext->nStyle & TBBS_INVISIBLE);
			}

			// window loading means we must create the window
			if (pTBBNext->nStyle & TBBS_HWND)
			{
				HWND hwnd =     pPackage->GetDockableWindow(pTBBNext->nID, NULL);
	
				CWnd* pWnd;
				if (hwnd == NULL || (pWnd = CWnd::FromHandle(hwnd)) == NULL)
					continue;
					
				pWnd->SetParent(this);
				if (lpIDArray == NULL)
				{
					CRect rect;
					pWnd->GetWindowRect(rect);
					::GetDroppedRect(pWnd->m_hWnd, rect);
					
					pWnd->SetWindowPos(NULL, 0, 0,
						pTBBNext->iImage, rect.Height(),
						SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
				}

				if (IsValidCtrlSize(pWnd))
					pWnd->ShowWindow(SW_SHOWNOACTIVATE);
				else
					pWnd->ShowWindow(SW_HIDE);

				pExtraNew[iDest].SetControl(hwnd);
				bExtraUsed=TRUE;
			}

			if (pTBBNext->nStyle & TBBS_SEPARATOR)
			{
				// ditch initial or double separators 
				if (pTBBNext == pTBBNew ||
					((pTBBNext - 1)->nStyle & TBBS_SEPARATOR) != 0)
					continue;

				pTBBNext->iImage = m_cxDefaultGap + 2;
			}
			
			if(pTBBNext->nStyle & TBBS_GLYPH)
			{
				// because we just glyphed a button, we know we are a glyphed bar
				if((pTBBNext->nStyle & TBBS_INVISIBLE)==0)
				{
					glyphs=cGlyphsPresent;
				}

				if (pTBBNext->nStyle & TBBS_CUSTOMBITMAP)
				{
					// we don't want to get the bitmap from the package, but from the
					// saved DIB, which will already be loaded and converted into a DDB In
					// the custom glyph object. At this point we transfer to the well 
					// if appropriate

					// setup internal data
					pTBBNext->iImage = nTiles++;

					// get button bitmap
					HBITMAP hbmCustom=GetButtonExtra(i)->GetGlyph();

					// will always be a bitmap at the moment
					ASSERT(hbmCustom!=NULL);

					BITMAP bmp;
					VERIFY(::GetObject(hbmCustom, sizeof(BITMAP), &bmp));

					if(     bmp.bmHeight==m_sizeImage.cy &&
						bmp.bmWidth==m_sizeImage.cx)
					{
						// transfer to well, lose source
						HBITMAP hbmSrc = (HBITMAP) ::SelectObject(hdcSrc, hbmCustom);

						VERIFY(BitBlt(hdcDest, m_sizeImage.cx * pTBBNext->iImage, 0, m_sizeImage.cx, m_sizeImage.cy, hdcSrc, 0, 0, SRCCOPY));
						
						::SelectObject(hdcSrc, hbmSrc);

						// no longer need it
						::DeleteObject(hbmCustom);
						pExtraNew[iDest].SetGlyph(NULL);
					}
					else
					{
						// scale to well, keep source
						GLOBAL_DATA::ScaleBitmap(hdcDest, m_sizeImage, CPoint(m_sizeImage.cx*pTBBNext->iImage, 0), hbmCustom, CSize(bmp.bmWidth, bmp.bmHeight));
						pExtraNew[iDest].SetGlyph(hbmCustom);
						bExtraUsed=TRUE;
					}
				}
				else
				{
					// if it's invisible, then it does need a space in the well
					if (pTBBNext->nStyle & TBBS_INVISIBLE)
					{
						pTBBNext->iImage = nTiles++;
					}
					else
					{
						if (pTBBNext->nID == TBB_NIL || pPackage == NULL)
						{
							continue; // Because of the extra data, this isn't going to work as we hope/expect. Fix. !!!
						}

						HBITMAP hbmWell;
						int iGlyph;
						VERIFY(theApp.GetCommandBitmap(pTBBNext->nID, &hbmWell, &iGlyph, theApp.m_bLargeToolBars));
						
						if(!BltCommandBitmap(hbmWell, iGlyph, hdcDest, nTiles, hdcSrc))
						{
							continue;
						}
						else
						{
							pTBBNext->iImage = nTiles++;
						}
					}
				}
			}

			
			if (pTBBNext->nStyle & TBBS_TEXTUAL)
			{
				if(lpIDArray!=NULL || (pTBBNext->nStyle & TBBS_CUSTOMTEXT)==0)
				{
					// creating from scratch, so we need to get the label to go with this command
					// get the title from the command table
					LPCSTR pName;
					theCmdCache.GetCommandString(pTBBNext->nID, STRING_MENUTEXT, &pName);

					CString name(pName);
					pExtraNew[iDest].SetLabel(name);
					bExtraUsed=TRUE;
				}
				else
				{
					// labels are already in the extra array
					ASSERT(!GetButtonExtra(i)->GetLabel().IsEmpty());
					pExtraNew[iDest].SetLabel(EditButtonExtra(i)->GetLabel());
					bExtraUsed=TRUE;
				}
			}
			
			pTBBNext++;
		}       // for
		
		::SelectObject(hdcDest, hbmOld);
		::DeleteDC(hdcSrc);
		::DeleteDC(hdcDest);
			
		if (pTBBNext != pTBBNew && ((pTBBNext - 1)->nStyle  & TBBS_SEPARATOR)!=0)
			pTBBNext--;
		
		nIDCount = (int) (pTBBNext - pTBBNew);
	}       // if nIDCount > 0

	// if we're not loading from disk, then we're resetting (otherwise, windows won't have existed
	// correctly in the old bar)
	if(lpIDArray != NULL)
	{
		// windows will have been duplicated, so lose them
		RemoveWindows();
	}
	Empty();

	if (nIDCount == 0)
	{
		if (hbmNewWell != NULL)
			::DeleteObject(hbmNewWell);
		if (pTBBNew != NULL)
			free(pTBBNew);
		if (pExtraNew != NULL)
			delete [] pExtraNew;
	}
	else
	{
		m_pData = pTBBNew;
		if(bExtraUsed)
		{
			m_pButtonExtra = pExtraNew;
		}
		else
		{
			m_pButtonExtra=NULL;
			delete [] pExtraNew;
		}
		m_nCount = nIDCount;
		m_hbmImageWell = hbmNewWell;
		m_nTiles = nTiles;

		// transfer calculated glyph status to bar
		SetGlyphStatus(glyphs);

		ASSERT_VALID(this);

		if (!IsInDialog())
			OnUpdateCmdUI((CFrameWnd*) AfxGetApp()->m_pMainWnd, TRUE);
	}
	
	RecalcSizes();
	
	return TRUE;
}

CToolCustomizer* CASBar::GetCustomizer()
{
	return s_pCustomizer;
}

ORIENTATION CASBar::GetOrient() const
{
	DOCKPOS dp = DkWGetDock(m_nIDWnd);

	CRect rectWindow;
	GetWindowRect(rectWindow);

	switch(dp)
	{
	default:
	case dpEmbedded:
		return orNil;

	case dpTop:
	case dpBottom:
		// empty bars always have their size driven by their dock. Also, one button bars
		// whose size is the same as the width of a single button have the same fudge.
		// This implies a slight unpleasantness - if you empty a converse
		// docked bar in place, when you add to it will have lost its
		// converse-ness, and you will need to use shift+drag again to
		// regain it. Tough luck.
		if( m_nCount==0 ||
			m_nCount==1 && rectWindow.Width() == GetVWidth())
		{
			return orHorz;
		}
	case dpLeft:
	case dpRight:
		if( m_nCount==0 ||
			m_nCount==1 && rectWindow.Width() == GetVWidth())
		{
			return orVert;
		}
		else
		{
			// since SHIFT+DRAG will dock reversed, we need to check the actual size to work out
			if (rectWindow.Width() == GetVWidth())
			{
				return orVert;
			}
			else
			{
				return orHorz;
			}
		}
	}
}

CCustomBar* CASBar::NewBar(UINT nID, const CPoint& pt)
{
	CASBar* pBar = new CASBar;
	CSize sizeButton=CCustomBar::GetDefaultButtonSize(theApp.m_bLargeToolBars);

	CRect rectInit( pt.x-sizeButton.cx/2,
					pt.y-sizeButton.cy/2,
					pt.x+sizeButton.cx/2,
					pt.y+sizeButton.cy/2);
	if (!pBar->Create(((CMainFrame*) AfxGetMainWnd())->m_pManager,
		nID, rectInit))
	{
		// auto delete inside this creation function
		return NULL;
	}
	
	return pBar;
}

void CASBar::MoveBar(const CRect& rect)
{
	DkWMoveWindow(m_nIDWnd, dpCurrent, rect);

	if (GetOrient() == orNil)
	{
		InvalidateRect(NULL);
		UpdateWindow();
	}
}

void CASBar::OnBarActivate()
{
	CPaletteWnd* pPalette = (CPaletteWnd*) GetParent();
	if (pPalette->IsKindOf(RUNTIME_CLASS(CPaletteWnd)))
		pPalette->ActivateNoFocus();
}

HWND CASBar::GetControl(UINT nID)
{
	CPackage* pPackage;

	VERIFY(theApp.GetCommandBtnInfo(nID, &pPackage) & TBBS_HWND);
	if (pPackage == NULL)
	{
		TRACE("CASBar::GetControl(%d); could not get package!\n", nID);
		return NULL;
	}

	return pPackage->GetDockableWindow(nID, NULL);
}

void CASBar::OnButtonSize()
{
	m_bDirty = TRUE;
}

void CASBar::LoseFocus()
{
	AfxGetApp()->m_pMainWnd->SetFocus();
}

void CASBar::DeleteButton(int nIndex, BOOL bMoving /*=FALSE*/)
{
	m_bDirty = TRUE;

	CCustomBar::DeleteButton(nIndex, bMoving);
}

int CASBar::InsertButton(int nIndex, TRANSFER_TBBUTTON& trans,
	BOOL bReplace, GAP gap)
{
	m_bDirty = TRUE;

	return CCustomBar::InsertButton(nIndex, trans, bReplace, gap);
}

BEGIN_MESSAGE_MAP(CASBar, CCustomBar)
	//{{AFX_MSG_MAP(CASBar)
	ON_WM_KILLFOCUS()
	ON_WM_NCPAINT()
    ON_WM_NCHITTEST()
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEACTIVATE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_SYSCOMMAND()
	ON_WM_KEYDOWN()
	ON_WM_SYSKEYDOWN()
	//}}AFX_MSG_MAP
	ON_REGISTERED_MESSAGE(DWM_GETDATA, OnGetData)
    ON_REGISTERED_MESSAGE(DWM_GETMOVESIZE, OnGetMoveSize)
    ON_REGISTERED_MESSAGE(DWM_GETTRACKSIZE, OnGetTrackSize)
    ON_REGISTERED_MESSAGE(DMM_NCLBUTTONDOWN, OnDkNcLButtonDown)
    ON_REGISTERED_MESSAGE(DMM_NCLBUTTONDBLCLK, OnDkNcLButtonDown)
    ON_REGISTERED_MESSAGE(DSM_DROPMENU, OnDropMenu)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
//      CASBar message handlers

//      CASBar::PostNcDestroy
//              Dock manager does not delete windows, so we auto-delete.

void CASBar::PostNcDestroy()
{
	if(s_pMenuBar==this)
	{
		s_pMenuBar=NULL;
	}
	delete this;
}

//      CASBar::WindowProc
//              All dockable windows call DkPreHandleMessage.

LRESULT CASBar::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// Starting from Orion #6081, we don't steal the rbuttondown message here
	// this allows us to control it more precisely below, and choose whether we
	// want to show our base class' toolbar customisation popup. martynl 22Mar96
	if (message != DMM_NCLBUTTONDOWN && message != DMM_NCLBUTTONDBLCLK &&
		message != WM_RBUTTONDOWN &&
		message != WM_RBUTTONUP &&
		message != WM_LBUTTONDBLCLK)
	{
		LONG lResult;
	
		if (DkPreHandleMessage(GetSafeHwnd(),
			message, wParam, lParam, &lResult))
			return lResult;
	}

	return CCustomBar::WindowProc(message, wParam, lParam);
}

void CASBar::OnNcPaint()
{
	// Since an ASBar can now have a scroll bar (when there are a large number of buttons
	// present and the bar is contained within the customize toolbars dialogue), we can't
	// omit nc painting when we need the scroll bars. martynl 07Mar96
	if (OnChicago() && 
		(GetStyle() & (WS_VSCROLL | WS_HSCROLL))==0) {
		return;         // Dockwnd paints the border.
	}

	CCustomBar::OnNcPaint();
}

//      CASBar::OnNcHitTest
//      All non-button area is HTCAPTION for dock moving.

UINT CASBar::OnNcHitTest(CPoint pt)
{
	DOCKPOS dp = DkWGetDock(m_nIDWnd);

	CWnd* pParent = GetParent();
	
    ScreenToClient(&pt);
    if (!IsInDialog() && HitTest(pt, FALSE) < 0 && (!IsMDIHost() || HitTestMDI(pt)==cMDINoButton))
	{
		if(dp==dpEmbedded)
		{
			// embedded bars don't drag by their empty areas.
			return HTCLIENT;
		}
		else
		{
			return HTCAPTION;     // nothing hit
		}
	}
    else
    {
		ClientToScreen(&pt);
		return CCustomBar::OnNcHitTest(pt);
    }
}

//      CASBar::OnLButtonDown
//              Handles the customizing calls for button moving, and control sizing.

void CASBar::OnLButtonDown(UINT nFlags, CPoint point)
{
	BOOL bTemp = (s_pCustomizer == NULL && (::GetKeyState(VK_MENU) & ~1) != 0);

	int nIndex = HitTest(point);
	UINT nStyle=0;

	// cache style of button to be dragged
	if (nIndex != -1 && nIndex < m_nCount)
	{
		nStyle = GetButtonStyle(nIndex);
	}

	if (bTemp)
	{
		s_pCustomizer = new CToolCustomizer(
			((CMainFrame*) AfxGetMainWnd())->m_pManager,
			NULL, s_aUsage, TRUE, FALSE);
	}

	CCustomBar::OnLButtonDown(nFlags, point);

	if (bTemp)
	{
		delete s_pCustomizer;
		s_pCustomizer = NULL;

		// If we dragged a menu, we need to rebuild to sort out the menu bar
		if(nStyle & TBBS_MENU)
		{
			CMainFrame *pFrame=(CMainFrame *)theApp.m_pMainWnd;
			pFrame->RebuildMenus();
		}
	}
}

//      CASBar::OnRButtonDown
//              Chooses between a base class popup (for customisation) and a popup from the dock manager
void CASBar::OnRButtonDown(UINT nFlags, CPoint point)
{
	LONG ignored;   // we can safely ignore the lresult return, because there's no significance
					// to button down return values

	const MSG *pMsg=GetCurrentMessage();
	if(!DkPreHandleMessage(GetSafeHwnd(), WM_RBUTTONDOWN, pMsg->wParam, pMsg->lParam, &ignored))
	{
		CCustomBar::OnRButtonDown(nFlags, point);
	}
}

//      CASBar::OnRButtonUp
//              Chooses between a base class popup (for customisation) and a popup from the dock manager
void CASBar::OnRButtonUp(UINT nFlags, CPoint point)
{
	CToolCustomizer *pCustomizer=GetCustomizer();

	if(pCustomizer)
	{
		int nIndex = HitTest(point);

		if (nIndex != -1)
		{
			if (this != pCustomizer->m_pSelectBar->GetRealObject()
				|| nIndex != pCustomizer->m_nSelectIndex)
			{
				pCustomizer->SetSelection(GetProxy(), nIndex);
			}
		}

		CPoint scrPlace=point;
		ClientToScreen(&scrPlace);

		if(pCustomizer->DisplayButtonMenu(nFlags, scrPlace))
		{
			// customizer has done it already
			return;
		}
	}

	LONG ignored;   // we can safely ignore the lresult return, because there's no significance
					// to button down return values

	const MSG *pMsg=GetCurrentMessage();
	if(!DkPreHandleMessage(GetSafeHwnd(), WM_RBUTTONUP, pMsg->wParam, pMsg->lParam, &ignored))
	{
		CCustomBar::OnRButtonUp(nFlags, point);
	}
}

//      CASBar::OnLButtonDblClk
//              On a button, translate to LButtonDown.

void CASBar::OnLButtonDblClk(UINT nFlags, CPoint pt)
{
	if(IsMDIHost() && HitTestMDI(pt)==cMDIIcon)
	{
		// double click to close window

		ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

		CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

		BOOL bMaximized;
		CWnd *pActive=pMainWnd->MDIGetActive(&bMaximized);

		pActive->SendMessage(WM_SYSCOMMAND, SC_CLOSE, MAKELONG(pt.x, pt.y));
	}
	else
	{
	    SendMessage(WM_LBUTTONDOWN, nFlags, MAKELPARAM(pt.x, pt.y));
	}
}

int CASBar::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest,
	UINT message)
{
	// Because of a what appears to be a SetWindowPos bug
	// when we try to ActivateNoFocus() in CPaletteWnd, we  need to hide
	// the tool tip here.

	//DestroyToolTip(TRUE, TRUE);
	CancelToolTips();

	// test if active window is a browser popup window
	CWnd * pWndActiveView = GetActiveWindow();
	if (pWndActiveView && pWndActiveView->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd)))
	{
		return MA_NOACTIVATE;
	}

	CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
	if (pDocker != NULL && pDocker->GetDock() == dpNil)
	{
		ASSERT(pDocker->m_pWnd != NULL);

		if (theApp.m_bDeactByOtherApp)
			pDocker->m_pWnd->SetFocus();

		return MA_NOACTIVATE;
	}
		
	// Note: CCustomBar::OnMouseActivate seems to be changing the focus
	// for us away from the toolbar customize dialog when clicking in the
	// embedded toolbar...skipping it and going over its head to CWnd
	//return CCustomBar::OnMouseActivate(pDesktopWnd, nHitTest, message);
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

// causes the bar's buttons to become large or small
BOOL CASBar::SetButtonSize(BOOL bLarge)
{
	// remember current orientation for later
	ORIENTATION or=GetOrient();

	UINT nConstraint=GetExpansionConstraint(CRect(0,0,0,0), &or, TRUE); 

	// remember current button size for later scaling
	CSize oldSizeButton=m_sizeButton;
	CSize oldSizeImage=m_sizeImage;
	// to be conservative, assume the button has borders on all sides;
	oldSizeButton.cx+=m_cxSharedBorder;
	oldSizeButton.cy+=m_cySharedBorder;
	
	// set size values
	SetDefaultSizes(bLarge);

	// This process is complicated by the presence of custom bitmaps. We only store
	// custom bitmaps separately if they are of the wrong size for the current bar
	// Otherwise, we store the current custom bitmap inside the image well. To ensure
	// custom bitmaps are preserved here, we need to perform a three-step process:

	// 1. Copy any custom bitmaps which were not derived from another size into the
	// extra data.
	// 2. Refresh bitmaps. This will copy across or scale all custom bitmaps
	// 3. Delete any custom bitmaps which are the same size as the current bar
	// martynl 07May96

	// build a new image well for the new size
	HBITMAP hbmNewWell = NULL;
	
	HDC hdcClient = ::GetDC(m_hWnd);

	if(hdcClient==NULL) {
		return FALSE;
	}
	
	hbmNewWell = ::CreateCompatibleBitmap(hdcClient,
		m_nCount * m_sizeImage.cx, m_sizeImage.cy);
	::ReleaseDC(m_hWnd, hdcClient);

	if (hbmNewWell == NULL) {       
		return FALSE;
	}

	// Duplicate all custom bitmaps stored within the well into the extra data
	AFX_TBBUTTON *pTBB=(AFX_TBBUTTON *)m_pData;
	for(int iButton=0; iButton<m_nCount; ++iButton, ++pTBB)
	{
		if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
		{
			// we need to copy the bitmap out either if there isn't a custom bitmap already
			if(     !HasButtonExtra() ||
				GetButtonExtra(iButton)->GetGlyph()==NULL)
			{
				EditButtonExtra(iButton)->SetGlyph(GLOBAL_DATA::DuplicateBitmap(this,
								m_hbmImageWell, oldSizeImage, CPoint(oldSizeImage.cx * pTBB->iImage, 0)));
			}
		}
	}

	// delete the old well
	if(m_hbmImageWell)
	{
		::DeleteObject(m_hbmImageWell);
	}
	
	m_hbmImageWell = hbmNewWell;

	// get bitmaps from packages into the new well, also copy across custom bitmaps
	RefreshButtonBitmaps();

	// lose custom bitmaps that are same size as well
	pTBB=(AFX_TBBUTTON *)m_pData;
	for(iButton=0; iButton<m_nCount; ++iButton, ++pTBB)
	{
		if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
		{
			if(     HasButtonExtra() &&
				GetButtonExtra(iButton)->GetGlyph()!=NULL)
			{
				BITMAP bmp;
				VERIFY(::GetObject(GetButtonExtra(iButton)->GetGlyph(), sizeof(BITMAP), &bmp));

				if(     bmp.bmHeight==m_sizeImage.cy &&
					bmp.bmWidth==m_sizeImage.cx)
				{
					::DeleteObject(GetButtonExtra(iButton)->GetGlyph());
					EditButtonExtra(iButton)->SetGlyph(NULL);
				}
			}
		}

		// flush the label sizes cache coz the font size just changed
		if((pTBB->nStyle & TBBS_TEXTUAL)!=0)
		{
			EditButtonExtra(iButton)->SetLabelSize(CSize(0,0));
		}
	}

	RecalcLayout(nConstraint, &or);

	// If it's embedded, we need to size it ourself, since the parent will normally control the embedded bar size
	CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();
	CDockWorker *pDocker=pFrame->m_pManager->WorkerFromWindow(this);

	if(pDocker &&
		pDocker->GetDock()==dpEmbedded)
	{
		// size the bar
		CSize sizeNew = GetHSize(or);

		SetWindowPos(NULL, 0,0, sizeNew.cx, sizeNew.cy, SWP_NOMOVE | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);
		
		// now tell the parent to sort itself out
		CWnd *pWndParent=GetParent();
		if(pWndParent &&
			!pWndParent->IsIconic())
		{
			// size the parent to its current size
			CRect rectCurrent;
			pWndParent->GetWindowRect(rectCurrent);
			CSize sizeCurrent=rectCurrent.Size();
			UINT nSize = pWndParent->IsZoomed() ? SIZE_MAXIMIZED : SIZE_RESTORED;

			pWndParent->SendMessage(WM_SIZE, nSize, MAKELPARAM(sizeCurrent.cx, sizeCurrent.cy));
		}
	}

	return TRUE; // success
}

void CASBar::OnSysColorChange()
{
	HBITMAP hbmSave = m_hbmImageWell;
	m_hbmImageWell = NULL;  // So CToolbar won't destroy the image well.

	CCustomBar::OnSysColorChange();

	m_hbmImageWell = hbmSave;

	RefreshButtonBitmaps();
}

void CASBar::OnSysCommand(UINT nID, LONG lParam)
{
	if(nID == SC_KEYMENU)
		GetParent()->SendMessage(WM_SYSCOMMAND, nID, lParam);
	else
		CCustomBar::OnSysCommand(nID, lParam);
}

LRESULT CASBar::OnGetData(WPARAM, LPARAM)
{
	return (LRESULT)(LPVOID) (m_bDirty ? GetProxy()->GetData() : NULL);
}

//      CASBar::OnGetTrackSize
//              For dock worker implementation of snap sizing.

LRESULT CASBar::OnGetTrackSize(UINT wParam, LPARAM lParam)
{
	CSize size((short) LOWORD(lParam), (short) HIWORD(lParam));
	
	size = GetSize(wParam, size);
	
	return MAKELRESULT((WORD)(short) size.cx, (WORD)(short) size.cy);
}

//      CASBar::OnGetMoveSize
//              Returns the various sizes for dock positions of the toolbar.

LRESULT CASBar::OnGetMoveSize(UINT wParam, LPARAM lParam)
{
	CSize size((short) LOWORD(lParam), (short) HIWORD(lParam));
	
	DOCKPOS dp = (DOCKPOS) wParam;
	
	switch (dp)
	{
	case dpTop:
	case dpBottom:
	case dpHorzInit:
	case dpEmbedded:
		size = GetHSize(orHorz);
		break;

	case dpLeft:
	case dpRight:
	case dpVertInit:
		size = GetVSize();
		break;
		
	case dpNil:
		if(s_pMenuBar==this)
		{
			// floating menu bars shouldn't grow to multiple lines unless they have to.
			size=GetSize(HTBOTTOM, size);
		}
		else
		{
			size = GetSize(HTRIGHT, size);
		}
		break;
	}
		
	return MAKELRESULT((WORD)(short) size.cx, (WORD)(short) size.cy);
}

//      CASBar::OnDkNcLButtonDown
//              Send HTCLIENTs to the bar.  These may come from HWND controls that
//              may need to be sized.  Otherwise just forward as usual.

LRESULT CASBar::OnDkNcLButtonDown(UINT wParam, LPARAM lParam)
{
	HGLOBAL hglob = (HGLOBAL) lParam;
    MOUSESTRUCT FAR* lpmst = (MOUSESTRUCT FAR*) GlobalLock(hglob);
    MOUSESTRUCT mst = *lpmst;
    GlobalUnlock(hglob);
    
	if (mst.nHitTest == HTCLIENT &&
		(s_pCustomizer != NULL || (::GetKeyState(VK_MENU) & ~1) != 0))
	{
		ScreenToClient(&mst.pt);
		SendMessage(WM_LBUTTONDOWN, 0, MAKELPARAM(mst.pt.x, mst.pt.y));
		return TRUE;
	}
	else if (mst.nHitTest == HTCAPTION && IsInDialog())
	{
		// If we are in a dialog, then block HTCAPTIONs from children
		// or they will be movable.
		//
		return TRUE;
	}

	LRESULT lResult;
	const MSG* pMsg = GetCurrentMessage();
		
	if (DkPreHandleMessage(GetSafeHwnd(),
		pMsg->message, wParam, lParam, &lResult))
		return lResult;
		
	return 0L;
}

// REVIEW: This should be in CCustomBar, I think.
LRESULT CASBar::OnDropMenu(UINT wParam, LPARAM lParam)
{
	if(s_pSystemMenu!=NULL && wParam!=m_nCount)
	{
		delete s_pSystemMenu;
		s_pSystemMenu=NULL;
	}
	// redraw anything that needs to be done
	return ExpandItem(wParam, TRUE, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// Keyboard interface
afx_msg void CASBar::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(!KeyDown(nChar, nRepCnt, nFlags))
	{
		CCustomBar::OnKeyDown(nChar, nRepCnt, nFlags);
	}
}

afx_msg void CASBar::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(!KeyDown(nChar, nRepCnt, nFlags))
	{
		CCustomBar::OnSysKeyDown(nChar, nRepCnt, nFlags);
	}
}

BOOL CASBar::KeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	BOOL bProcessed=FALSE;

	// hmm. One variable?
	if(s_pDroppedBar!=NULL)
	{
		m_iKeySelect=s_nDroppedItem;
	}

	// vertical bars treat keyboard differently
	ORIENTATION or=GetOrient();
	BOOL bVertBar=(or==orVert);

	BOOL bMoveSelection=FALSE;      // true if a selection move is decoded from this keystroke
	int iNewSelection=0;            // button index of the new selection
	BOOL bActivateNewSelection=FALSE; // TRUE if the keyboard indicates that the new selection
								// should be pressed

	if(bVertBar)
	{
		switch(nChar)
		{
			case VK_UP:
				// up means previous
				nChar=VK_LEFT;
				break;
			case VK_DOWN:
				// down means next
				nChar=VK_RIGHT;
				break;
			case VK_RIGHT:
			case VK_LEFT:
				// right means dropout
				nChar=VK_RETURN;
				break;

		}
	}

	if(m_iKeySelect!=-1)
	{
		// down means enter on a menu button
		if( (m_iKeySelect==m_nCount ||
			(GetButtonStyle(m_iKeySelect) & TBBS_MENU)) &&
			!bVertBar &&
			(nChar==VK_DOWN ||
			 nChar==VK_UP))
		{
			nChar=VK_RETURN;
		}
	}

	CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

	BOOL bMaximized;
	CWnd *pMDIChild=pMainWnd->MDIGetActive(&bMaximized);
	
	int maxIndex=m_nCount-1;
	if((GetBarStyle() & CTBRS_MAINMENU)!=0 &&
		pMDIChild!=NULL &&
		s_pCustomizer==NULL) // can't customize system menu.
	{
		maxIndex+=1;
	}

	// we now assume a horizontal one
	// find next selection
	switch(LOBYTE(nChar))
	{
		case VK_LEFT:
			if(m_iKeySelect!=-1)
			{
				// previous button
				bMoveSelection=TRUE;
				int iInitialSelection=iNewSelection=m_iKeySelect;
				do
				{
					iNewSelection-=1;
					if(iNewSelection<0)
					{
						iNewSelection=maxIndex;
					}
				}
				while(iNewSelection!=iInitialSelection && !CanFocus(iNewSelection));
				if(iNewSelection!=iInitialSelection)
				{
					bMoveSelection=TRUE;
				}
				bProcessed=TRUE;
			}
			break;
		
		case VK_TAB:
			if(m_iKeySelect!=-1)
			{
				if(GetKeyState(VK_CONTROL))
				{
					int nOffset=1;
					if( GetKeyState(VK_SHIFT))
					{
						// previous bar
						nOffset=-1;
					}

					// find us within the list of all toolbars
					int iBar=0;
					int nSize=s_aUsage.GetSize();

					while(iBar < nSize)
					{
						if(s_aUsage[iBar]==this)
						{
							break;
						}
						++iBar;
					}

					if(iBar>=nSize)
					{
						// not found ourselves, which is very odd
						ASSERT(FALSE);
					}

					// move to next/previous bar
					iBar+=nOffset;

					if(iBar<0)
					{
						iBar=nSize-1;
					}

					if(iBar>=nSize)
					{
						iBar=0;
					}

					CASBar *pNewBar=(CASBar *)s_aUsage[iBar];

					ASSERT(pNewBar!=NULL);

					// cause it to take focus
					LoseKeyFocus();
					pNewBar->GainKeyFocus(0);
					bProcessed=TRUE;
					break;
				}
			}
			// deliberate drop thru to right
		case VK_RIGHT:
			if(m_iKeySelect!=-1)
			{
				// next button
				int iInitialSelection=iNewSelection=m_iKeySelect;
				bMoveSelection=TRUE;
				do
				{
					iNewSelection+=1;
					if(iNewSelection>maxIndex)
					{
						iNewSelection=0;
					}
				}
				while(iInitialSelection!=iNewSelection && !CanFocus(iNewSelection));
				if(iNewSelection!=iInitialSelection)
				{
					bMoveSelection=TRUE;
				}
				bProcessed=TRUE;
			}
			break;

			// Note: Horizontal toolbars have all rows the same height
			// This code would not work for a vertical toolbars, but vertical toolbars
			// have their VK_UP mapped to VK_LEFT, so never get here
		case VK_UP:
			// previous row, roughly same position
		case VK_DOWN:
			if(m_iKeySelect!=-1 && m_iKeySelect!=maxIndex)
			{
				// next row, roughly same position
				ASSERT(!bVertBar);

				// if this is a one line bar, then this has no meaning
				CRect rectWindow;
				GetWindowRect(rectWindow);
				if (rectWindow.Height() == GetHSize(orHorz).cy)
					break;
				
				// iterate till we are on the right line, then till the centre point of the
				// button passes the centre point of this button. Because GetItemRect is very
				// inefficient, we use EnumItemRects directly, and only move forward thru
				// the buttons. Otherwise, this routine would be much easier.

				CRect rectCurrent;
				GetItemRect(m_iKeySelect, rectCurrent, or);
				CPoint ptCurrentCenter=rectCurrent.CenterPoint();
				CRect rectTest;
				int iButton=0;
				BOOL bWrapped=FALSE;
				BOOL bRowFound=FALSE;
				CSize sizeButton=GetButtonSize(or);
				int nRowHeight=sizeButton.cy+m_cyDefaultGap;
				int yCenterTarget=0;
				CRect rectClient;
				GetClientRect(rectClient);

				// find centre of target line
				if(nChar==VK_UP)
				{
					yCenterTarget=ptCurrentCenter.y-nRowHeight;
					if(yCenterTarget<0)
					{
						// wrap to bottom of toolbar
						yCenterTarget=rectClient.bottom-nRowHeight/2;
					}
				}
				else
				{
					yCenterTarget=ptCurrentCenter.y+nRowHeight;
					if(yCenterTarget>rectClient.bottom)
					{
						// wrap to bottom of toolbar
						yCenterTarget=nRowHeight/2;
					}
				}

				// find start of correct line
				do
				{
					EnumItemRects(iButton, rectTest, bWrapped, or);

					// find out distance between centre points
					int yDiff=rectTest.Height()-yCenterTarget;

					// get the absolute value for comparison purposes
					int ayDiff=yDiff;
					if(ayDiff<0)
					{
						ayDiff=-ayDiff;
					}

					// because the centring of the items may not be precise (windows, for example)
					// we need to do an imprecise comparison here
					
					// if it's near 0, they must be one row apart
					if(ayDiff>-3 && ayDiff <3)
					{
						bRowFound=TRUE;
					}
					else
					{
						++iButton;
					}
				}
				while(iButton<m_nCount && !bRowFound);

				if(!bRowFound)
				{
					// there really should always be a row
					ASSERT(FALSE);
				}
				else
				{
					// now walk until the horz centre point of the button passes the horz
					// centre point of our current button

					int xCenterTarget=ptCurrentCenter.x;

					CRect rectOld=rectTest;

					while(iButton < m_nCount &&
						  rectTest.top<rectOld.bottom &&   // give up if we wrap to next line
						  rectTest.CenterPoint().x < xCenterTarget)
					{
						++iButton;
						rectOld=rectTest;
						EnumItemRects(iButton, rectTest, bWrapped, or);
					}
					
					if(iButton==m_nCount)
					{
						bMoveSelection=TRUE;
						// we walked into the last button, so move to that one
						iNewSelection=m_nCount-1; // assumes last cannot be separator, which
												  // is enforced elsewhere
						ASSERT((GetButtonStyle(iNewSelection) & TBBS_SEPARATOR)!=0);
					}
					else
					{
						// at this point, we've found two possibilities
						// rectOld is at iButton -1, 
						// rectTest is at iButton
						// Which is nearer the center of our button?

						bMoveSelection=TRUE;
						int oldDiff=rectOld.CenterPoint().x - xCenterTarget;
						int newDiff=rectTest.CenterPoint().x - xCenterTarget;
						
						if(oldDiff<0)
						{
							oldDiff=-oldDiff;
						}
						if(newDiff<0)
						{
							newDiff=-newDiff;
						}

						if(oldDiff<newDiff)
						{
							iNewSelection=iButton-1;
						}
						else
						{
							iNewSelection=iButton;
						}

						ASSERT(iNewSelection>0);
						ASSERT(iNewSelection<m_nCount);
					}
				}
				bProcessed=TRUE;
			}
			break;

		case VK_MENU:
			if(nRepCnt>1)
			{
				break;
			}
			if(m_iKeySelect==-1)
			{
				GainKeyFocus(0);
				bMoveSelection=TRUE;
				iNewSelection=0;
				bProcessed=TRUE;
				break;
			}
			else
			{
				// drop thru to escape
			}
		case VK_ESCAPE:
			// cancel keyboard mode
			LoseKeyFocus();
			bMoveSelection=TRUE;
			iNewSelection=-1;
			bProcessed=TRUE;
			break;

		case VK_RETURN:
			if(m_iKeySelect!=-1)
			{
				int iKeySelect=m_iKeySelect;
				LoseKeyFocus();
				
				BOOL bMenu=TRUE;
				BOOL bEnabled=TRUE;
				if(iKeySelect<m_nCount)
				{
					AFX_TBBUTTON *pTBB=_GetButtonPtr(iKeySelect);
					if((pTBB->nStyle & TBBS_MENU)==0)
					{
						bMenu=FALSE;
					}
					if((pTBB->nStyle & TBBS_DISABLED))
					{
						bEnabled=FALSE;
					}
				}
				if(bEnabled)
				{
					if(bMenu)
					{
						ExpandItem(iKeySelect, TRUE, TRUE);
					}
					else
					{
						OnButtonPressed(iKeySelect);
					}
				}
				bProcessed=TRUE;
			}
			break;

		case VK_SUBTRACT:
			if(Menu::IsShowingCmdBars())
			{
				if(	s_pDroppedBar!=s_pMenuBar ||
					s_nDroppedItem!=m_nCount)
				{
					ASSERT(theApp.m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

					CMDIFrameWnd *pMainWnd=(CMDIFrameWnd *)(theApp.m_pMainWnd);

					BOOL bMaximized;
					CWnd *pActive=pMainWnd->MDIGetActive(&bMaximized);
					if(	pActive &&
						s_pCustomizer==NULL)
					{
						s_pMenuBar->ExpandItem(s_pMenuBar->m_nCount, TRUE, TRUE);
					}
					bProcessed=TRUE;
				}
			}
			break;

		default:
			// this is the case where we need to scan for accelerators - nasty, because we
			// have to scan for all that menu related crap, and we have to be sure that it'll 
			// work right on J systems, etc.

			// davidga tells me (martynl) that accelerators can only ever be sbcs, even in an
			// mbcs environment, which makes things somewhat simpler

			// we scan the menu for one full iteration, taking note of the number of times
			// we meet this accelerator, the first time we meet it, and the first time
			// we meet it when iButton is greater than the current iButton. If there is 
			// exactly one instance of this accelerator, then we drop it down. If there is
			// more than one, then we move to the next one after the current position,
			// wrapping around if appropriate.

			// martynl 24May96

			{
				if( s_pDroppedBar!=NULL &&
					s_nDroppedItem!=-1)
				{
					// something is pulled down, pass this key onto that
					CBMenuPopup *pMenu=s_pDroppedBar->GetItemMenu(s_nDroppedItem);
					if(pMenu)
					{
						pMenu->SendMessage(WM_KEYDOWN, nChar, MAKELONG(nRepCnt, nFlags));
						bProcessed=TRUE;
						break;
					}
				}

				if(nChar<'0' || nChar>'Z')
				{
					break;
				}

				int iFirstFind=-1;  // first one (nearest start of bar)
				int iNextFind=-1;   // first one after current item (can be same as iFirstFind)
				int nFinds=0;       // total number of finds

				// this loop will terminate early once iNextFind is found - any button
				// after that would never get selected this tiem anyway
				for(int iButton=0; iButton<m_nCount && (iNextFind==-1 || nFinds<2); ++iButton)
				{
					UINT nStyle=GetButtonStyle(iButton);
					if((nStyle & TBBS_TEXTUAL)!=0 &&
						(nStyle & TBBS_INVISIBLE)==0 )
					{

						TCHAR chAccel=0;
						const CString Label = GetButtonExtra(iButton)->GetLabel();
						ASSERT(!Label.IsEmpty());

						CString strLabel = Label;

						chAccel=GLOBAL_DATA::ExtractAccelerator(Label);
				
						if(chAccel!=0)
						{
							// it's an accelerator, now what's the key code
							if(tolower(chAccel)==tolower(LOBYTE(nChar)))
							{
								// same key - this is one
								++nFinds;

								if(iFirstFind==-1)
								{
									iFirstFind=iButton;
								}

								if(iNextFind==-1 &&
									iButton> m_iKeySelect)
								{
									iNextFind=iButton;
								}
							}
						}
					}
				}
				// now know how many matches
				if(nFinds>0)
				{
					ASSERT(iFirstFind!=-1);
					// some matches, some action
					if(nFinds==1)
					{
						if(iFirstFind!=m_iKeySelect || !(GetButtonStyle(iFirstFind) & TBBS_MENU))
						{
							bMoveSelection=TRUE;
							iNewSelection=iFirstFind;
							bActivateNewSelection=TRUE;
						}
						else
						{
							int iKeySelect=m_iKeySelect;
							LoseKeyFocus();
							ExpandItem(iKeySelect, TRUE, TRUE);
						}
					}
					else
					{
						// if there's one just after us, go for that
						if(iNextFind!=-1)
						{
							bMoveSelection=TRUE;
							iNewSelection=iNextFind;
						}
						else
						{
							// otherwise, wrap around. 

							// Because we found more than one valid possibility, and because
							// iNextFind is -1, there must
							// be one other selection before iNextFind.
							ASSERT(iFirstFind!=m_iKeySelect);

							bMoveSelection=TRUE;
							iNewSelection=iFirstFind;
						}
					}
				}
				bProcessed=TRUE;
			}
			break;

	}

	// act on next selection
	if(bMoveSelection)
	{
		if(m_iKeySelect!=-1)
		{
			int nKeySelect=m_iKeySelect;

			if(nKeySelect!=m_nCount)
			{
				// undraw current selection
				UINT nOldStyle=GetButtonStyle(nKeySelect);

				// if it's a menu, it could be dropped or extruded
				if(nOldStyle & TBBS_MENU)
				{
					if(nOldStyle & TBBS_PRESSED)
					{
						ExpandItem(nKeySelect,FALSE);
						m_bDropPending=TRUE;
						nOldStyle &=~TBBS_PRESSED;
					}
					else
					{
						m_bDropPending=FALSE;
						nOldStyle &=~TBBS_EXTRUDED;
					}
				}
				else
				{
					nOldStyle&=~TBBS_EXTRUDED;
				}

				SetButtonStyle(nKeySelect, nOldStyle);
				InvalidateButton(nKeySelect);
			}
			else
			{
				if(s_pSystemMenu!=NULL)
				{
					ExpandItem(nKeySelect,FALSE);
					m_bDropPending=TRUE;
				}
				else
				{
					m_bDropPending=FALSE;
				}
			}
		}

		m_iKeySelect=iNewSelection;

		if(m_iKeySelect>=0)
		{
			// default style used for system menu
			UINT nNewStyle=TBBS_MENU;
			if(m_iKeySelect!=m_nCount)
			{
				nNewStyle = GetButtonStyle(m_iKeySelect);
			}
			int iKeySelect=m_iKeySelect;

			if(nNewStyle & TBBS_MENU)
			{
				if(m_bDropPending || bActivateNewSelection)
				{
					LoseKeyFocus();
					PostMessage(DSM_DROPMENU, iKeySelect,TRUE);
				}
				else
				{
					nNewStyle |=TBBS_EXTRUDED;
				}
			}
			else
			{
				if(bActivateNewSelection)
				{
					nNewStyle |=TBBS_PRESSED;
				}
				else
				{
					nNewStyle |=TBBS_EXTRUDED;
				}
			}
			

			if(iKeySelect!=m_nCount)
			{
				SetButtonStyle(iKeySelect,  nNewStyle);
				InvalidateButton(iKeySelect);
			}

			if(nNewStyle & TBBS_PRESSED)
			{
				LoseKeyFocus();
				if(nNewStyle & TBBS_MENU)
				{
					ExpandItem(iKeySelect, TRUE, TRUE);
				}
				else
				{
					// command button on menu bar
					if(iKeySelect<m_nCount && iKeySelect>=0)
					{
						// press the button
						OnButtonPressed(iKeySelect);

						// If the command was Exit, we'd better
						// do nothing and return
						if(!theApp.m_bQuitting)
						{
							// draw it unpressed after command is done
							nNewStyle &= ~ TBBS_PRESSED;
							SetButtonStyle(iKeySelect,  nNewStyle);
							InvalidateButton(iKeySelect);
						}
					}
				}
			}
		}
		else
		{
			LoseKeyFocus();
		}
	}
	return bProcessed;
}

afx_msg void CASBar::OnKillFocus(CWnd *pNew)
{
	if(m_iKeySelect!=-1)
	{
		if(m_iKeySelect!=m_nCount)
		{
			// undraw current selection
			UINT nOldStyle=GetButtonStyle(m_iKeySelect);

			// if it's a menu, it could be dropped or extruded
			if(nOldStyle & TBBS_MENU)
			{
				if(nOldStyle & TBBS_PRESSED)
				{
					ExpandItem(m_iKeySelect,FALSE);
					m_bDropPending=TRUE;
					nOldStyle &=~TBBS_PRESSED;
				}
				else
				{
					m_bDropPending=FALSE;
					nOldStyle &=~TBBS_EXTRUDED;
				}
			}
			else
			{
				nOldStyle&=~TBBS_EXTRUDED;
			}

			SetButtonStyle(m_iKeySelect, nOldStyle);
			InvalidateButton(m_iKeySelect);
		}
		m_iKeySelect=-1;
	}

	// ensable ime
	imeEnableIME( NULL, TRUE );
	
	CCustomBar::OnKillFocus(pNew);
}

BOOL CASBar::OnButtonPressed(int iButton)
{
	LoseKeyFocus();
	return CCustomBar::OnButtonPressed(iButton);
}

void CASBar::LoseKeyFocus(void)
{

	// lose the visible focus
	if(m_iKeySelect!=-1 && m_iKeySelect!=m_nCount)
	{
		SetButtonStyle(m_iKeySelect, GetButtonStyle(m_iKeySelect) & ~ TBBS_EXTRUDED);
		InvalidateButton(m_iKeySelect);
	}

	m_iKeySelect=-1;
	m_bDropPending=FALSE;

	// donate the focus to the main MDI child
	if(GetFocus()==this && s_pOldFocus && ::IsWindow(s_pOldFocus->GetSafeHwnd()))
	{
		s_pOldFocus->SetFocus();
	}
	s_pOldFocus=NULL;
}

void CASBar::GainKeyFocus(int iFocus)
{
	// lose parent extrusions
	OnCancelMode();

	s_pOldFocus=GetFocus();
	// take the focus and draw it
	m_iKeySelect=iFocus;
	m_bDropPending=FALSE;
	if(m_iKeySelect!=m_nCount)
	{
		SetButtonStyle(m_iKeySelect, GetButtonStyle(m_iKeySelect) | TBBS_EXTRUDED);
		InvalidateButton(m_iKeySelect);
	}
	::SetFocus(this->GetSafeHwnd());

	// disable ime
	imeEnableIME( NULL, FALSE );
}

// menu calls this when it is completed, to stop the bar tracking
void CASBar::MenuDone()
{
	LoseKeyFocus();
	CCustomBar::MenuDone();
}

// Removes all references to command id from all bars
void CASBar::RemoveAllCommandReferences(UINT id)
{
	// we need to recheck the size of s_ausage every time, because RemoveCommandReferences can result
	// in the deletion of the bar.
	for (int i = 0; i < s_aUsage.GetSize();)
	{
		CASBar *pBar=(CASBar *)(s_aUsage[i]);

		if(!pBar->RemoveCommandReferences(id))
		{
			// only increment if the bar wasn't deleted
			++i;
		}

	}
}

// Removes reference to command id from this bar
BOOL CASBar::RemoveCommandReferences(UINT id)
{
	AFX_TBBUTTON *pTBB=(AFX_TBBUTTON *)m_pData;

	BOOL bDeleted=FALSE;

	for(int iButton=0; iButton<m_nCount;)
	{
		if(pTBB->nID==id)
		{
			DeleteButton(iButton);
			bDeleted=TRUE;

			// in This case we can be sure that the next button is at pTBB, or that iButton will now be >=m_nCount
		}
		else
		{
			// don't increment if we deleted, because things will have moved up
			++iButton;
			++pTBB;
		}
	}

	if(bDeleted)
	{
		if(m_nCount==0)
		{
			// delete bar
			UINT nIDWnd = (UINT) GetDlgCtrlID();
			CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();
			pFrame->m_pManager->RemoveWnd(MAKEDOCKID(PACKAGE_SUSHI, nIDWnd));
			return TRUE;
		}
		else
		{
			RecalcLayout();
		}
	}
	return FALSE;
}

CSize CASBar::GetHSize(ORIENTATION or)
{
	return CCustomBar::GetHSize(or);
}

CSize CASBar::GetSize(UINT nHitTest, CSize size)
{
	return CCustomBar::GetSize(nHitTest, size);
}

// Returns TRUE if the item is expecting to regain the focus to the bar
int CASBar::ExpandItem(int nIndex, BOOL bExpand, BOOL bKeyboard)
{
	int nDroppedItem=CCustomBar::ExpandItem(nIndex, bExpand, bKeyboard);
	
	if(bExpand && nDroppedItem!=-1)
	{
		if(nDroppedItem<m_nCount)
		{
			AFX_TBBUTTON* pTBB = _GetButtonPtr(nDroppedItem);
			pTBB->nStyle &= ~(TBBS_PRESSED);
			pTBB->nStyle |= (TBBS_EXTRUDED);
			InvalidateButton(nDroppedItem);
			GainKeyFocus(nDroppedItem);
		}
		else
		{
			GainKeyFocus(nDroppedItem);
		}
	}
	return nDroppedItem;
}

void CASBar::OnMouseMove(UINT nFlags, CPoint point)
{
	// if there's a keyboard selection, and menus are not dropped then moving the mouse should move that
	if(m_iKeySelect!=-1 && s_pDroppedBar==NULL && GetCustomizer()==NULL)
	{
		int iCurrentHit=HitTest(point);
		if(iCurrentHit==-1)
		{
			// If no bar button was hit, maybe we floated over the mdi system icon.
			int nMDIHit=HitTestMDI(point);
			if(nMDIHit==cMDIIcon)
			{
				iCurrentHit=m_nCount;
			}
		}

		if(iCurrentHit>=0)
		{
			AFX_TBBUTTON* pTBB=NULL;

			if(m_iKeySelect!=m_nCount)
			{
				pTBB=_GetButtonPtr(m_iKeySelect);
			}

			//deextrude it
			if(pTBB)
			{
				pTBB->nStyle &= ~(TBBS_EXTRUDED);
				InvalidateButton(m_iKeySelect);
			}

			m_iKeySelect=iCurrentHit;

			if(m_iKeySelect!=m_nCount)
			{
				pTBB =_GetButtonPtr(m_iKeySelect);
			}
			else
			{
				pTBB=NULL;
			}

			if(pTBB)
			{
				//deextrude it
				pTBB->nStyle |= TBBS_EXTRUDED;
				InvalidateButton(m_iKeySelect);
			}

			m_iKeySelect=iCurrentHit;
		}
	}
	else
	{
		CCustomBar::OnMouseMove(nFlags, point);
	}
}

static BOOL bLastAltDown=FALSE;			// true if the very last input message was an alt-down message

BOOL CASBar::StealMenuMessage(MSG *pMsg)
{
	// Orion 96 Bug # 13133: Pressing alt in a tabbed dialog when not in a control resulted
	// in the main menu getting activated.
	// Don't steal messages if the main frame is not active
	if (!AfxGetMainWnd()->IsWindowEnabled())
	{
		return FALSE ;
	}

	// don't steal keyboard messages during customization
	if(s_pCustomizer!=NULL)
	{
		bLastAltDown=FALSE;

		return FALSE;
	}

	// We only pass the alt message to the menu bar if it happens ALTdown/ALTup with no other input messages between
	if(Menu::IsShowingCmdBars())
	{
		if(pMsg->message==WM_SYSKEYDOWN &&
			pMsg->wParam==VK_MENU &&
			LOWORD(pMsg->lParam)<=1 &&
			(pMsg->lParam & 0x40000000)==0) // don't set it true if this is an autorepeat. Bit 30 is set if the key was down before the message was send, implying a resend
		{
			bLastAltDown=TRUE;
		}
		else
		{
			// Orion 14688 - The WM_SYSKEYUP is translated to a WM_KEYUP by the time it gets here.
			if((pMsg->message==WM_SYSKEYUP || pMsg->message==WM_KEYUP) &&
				pMsg->wParam==VK_MENU &&
				Menu::IsShowingCmdBars() &&
				bLastAltDown)
			{
				bLastAltDown=FALSE;
				// send alt thru to custom bar
				if(s_pMenuBar->KeyDown(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam)))
				{
					return TRUE;
				}
			}

			if(	bLastAltDown &&
				((pMsg->message>=WM_KEYFIRST && pMsg->message<=WM_KEYLAST) ||
				(pMsg->message>=WM_MOUSEFIRST && pMsg->message<=WM_MOUSELAST)) )
			{
				//Orion 96 Bug 14688: Releasing capture sends fake mousemoves. If the mouse
				// move is fake, ignore it.
				if (pMsg->message == WM_MOUSEMOVE) 
				{
					if (pMsg->wParam == 0x0000) // (0,0) 
					{
						return FALSE ;
					}					
				}
				
				if( pMsg->message!=WM_SYSKEYDOWN ||
					pMsg->wParam!=VK_MENU)
				{
					// don't set it false if this is an autorepeat
					bLastAltDown=FALSE;
				}
			}
		}
	}

	if((pMsg->message==WM_SYSKEYDOWN) &&
		((	pMsg->wParam>='0' &&
			pMsg->wParam<='Z' ) ||
			pMsg->wParam==VK_SUBTRACT) &&
		Menu::IsShowingCmdBars() &&
		s_pMenuBar)
	{
		// send thru to custom bar
		if(s_pMenuBar->KeyDown(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam)))
		{
			return TRUE;
		}
	}

	if((pMsg->message==WM_SYSKEYDOWN ||
		pMsg->message==WM_KEYDOWN) &&
		Menu::IsShowingCmdBars() &&
		s_pDroppedBar!=NULL &&
		s_nDroppedItem!=-1)
	{
		// send thru to custom menu
		CBMenuPopup *pMenu=s_pDroppedBar->GetItemMenu(CASBar::s_nDroppedItem);
		if(pMenu)
		{
			pMenu->KeyDown(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam));
			return TRUE;
		}
	}

	return FALSE;
}

// Take key messages for the toolbar navigation very early on.
BOOL CASBar::EarlyStealMenuMessage(MSG *pMsg)
{
	// Orion 96 Bug # 13133: Pressing alt in a tabbed dialog when not in a control resulted
	// in the main menu getting activated.
	// Don't steal messages if the main frame is not active
	if (!AfxGetMainWnd()->IsWindowEnabled())
	{
		return FALSE ;
	}

	// This is the same as the alt-down code in Steal, but we're only interested in clearing the last alt flag
	// We only pass the alt message to the menu bar if it happens ALTdown/ALTup with no other input messages between
	if(Menu::IsShowingCmdBars())
	{
		if(pMsg->message==WM_SYSKEYDOWN &&
			pMsg->wParam==VK_MENU &&
			LOWORD(pMsg->lParam)<=1 &&
			(pMsg->lParam & 0x40000000)==0) // don't set it true if this is an autorepeat
		{
			// do nothing
		}
		else
		{
			if((pMsg->message==WM_SYSKEYUP || pMsg->message==WM_KEYUP) &&
				pMsg->wParam==VK_MENU &&
				Menu::IsShowingCmdBars() &&
				bLastAltDown)
			{
				// in the steal code, this will process the alt. Here, it must just be ignored.
			}
			else
			{
				if(	bLastAltDown &&
					((pMsg->message>=WM_KEYFIRST && pMsg->message<=WM_KEYLAST) ||
					(pMsg->message>=WM_MOUSEFIRST && pMsg->message<=WM_MOUSELAST)) )
				{
					//Orion 96 Bug 14688: Releasing capture sends fake mousemoves. If the mouse
					// move is fake, ignore it.
					if (pMsg->message == WM_MOUSEMOVE) 
					{
						if (pMsg->wParam == 0x0000) // (0,0) 
						{
							return FALSE ;
						}					
					}
					
					if( pMsg->message!=WM_SYSKEYDOWN ||
						pMsg->wParam!=VK_MENU)
					{
						// don't set it false if this is an autorepeat
						bLastAltDown=FALSE;
					}
				}
			}
		}
	}
	else
	{
		if (pMsg->message == WM_SYSKEYDOWN || pMsg->message == WM_SYSKEYUP)
		{
			CASBar::ForceReleaseCapture();
		}
	}

	if((pMsg->message==WM_SYSKEYDOWN ||
		pMsg->message==WM_KEYDOWN) &&
		pMsg->wParam!=VK_MENU &&
		Menu::IsShowingCmdBars() &&
		s_pMenuBar &&
		s_pMenuBar->m_iKeySelect>=0 &&
		s_pDroppedBar==NULL)
	{
		// send thru to custom bar
		if(s_pMenuBar->KeyDown(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam)))
		{
			return TRUE;
		}
	}
	return FALSE;
}

// Reset to default buttons
void CASBar::Reset(void)
{
	CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();
	CDockWorker *pDocker=pFrame->m_pManager->WorkerFromWindow(this);

	CPackage* pGrp = theApp.GetPackage(pDocker->m_nIDPackage);
	if (pGrp == NULL)
		return;
	
	HGLOBAL hglob = pGrp->GetToolbarData(LOWORD(pDocker->m_nIDWnd));

	if (hglob != NULL)
	{
		if(CASBar::s_pDroppedBar==this)
		{
			CASBar::CancelMenu();
		}

		// first we need to remove the selection
		if(CASBar::s_pCustomizer &&
			CASBar::s_pCustomizer->m_pSelectBar &&
			CASBar::s_pCustomizer->m_pSelectBar->GetWindow()==this)
		{
			CASBar::s_pCustomizer->SetSelection(NULL,0);
		}

		TOOLBARINIT FAR* lptbi = (TOOLBARINIT*) ::GlobalLock(hglob);
		UINT FAR* lpIDArray = (UINT FAR*) (lptbi + 1);

		DynSetButtons(lpIDArray, lptbi->nIDCount);

		if(LOWORD(pDocker->m_nIDWnd)==IDTB_MENUBAR)
		{
			CMainFrame *pFrame=(CMainFrame *)theApp.m_pMainWnd;

			pFrame->RebuildMenus();
		}

		RecalcLayout();
		
		::GlobalUnlock(hglob);
		::GlobalFree(hglob);
	}
}

void CASBar::ForceReleaseCapture(void)
{
	CWnd* pWndWithCapture = GetCapture() ;
	if (pWndWithCapture && pWndWithCapture->IsKindOf(RUNTIME_CLASS(CASBar)))
	{
		// Turn capture off.
		((CASBar *)pWndWithCapture)->m_iButtonCapture = -1;
		ReleaseCapture();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barglob.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "barglob.h"
#include "resource.h"
#include <stdlib.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// SPI value taken from NT source (currently undocced), with Manager approval.
#define SPI_GETMENUSHOWDELAY      106
#define REGISTRY_MENUSHOWDELAY_KEY "Control Panel\\Desktop"
#define REGISTRY_MENUSHOWDELAY_VALUE "MenuShowDelay"

/////////////////////////////////////////////////////////////////////////////
// Cached system metrics, etc

GLOBAL_DATA globalData;

// Initialization code
GLOBAL_DATA::GLOBAL_DATA()
{
	// Cache various target platform version information
	DWORD dwVersion = ::GetVersion();
	nWinVer = (LOBYTE(dwVersion) << 8) + HIBYTE(dwVersion);
	bWin32s = (dwVersion & 0x80000000) != 0;
	bWin4 = (BYTE)dwVersion >= 4;
	bNotWin4 = 1 - bWin4;   // for convenience
#ifndef _MAC
	bSmCaption = bWin4;
#else
	bSmCaption = TRUE;
#endif
	bWin31 = bWin32s && !bWin4; // Windows 95 reports Win32s

	// Border attributes
	hbrLtGray = ::CreateSolidBrush(RGB(192, 192, 192));
	hbrDkGray = ::CreateSolidBrush(RGB(128, 128, 128));
	ASSERT(hbrLtGray != NULL);
	ASSERT(hbrDkGray != NULL);

	// Cached system values (updated in CWnd::OnSysColorChange)
	hbrBtnFace = NULL;
	hbrBtnShadow = NULL;
	hbrBtnHilite = NULL;
	hbrWindowFrame = NULL;
	hpenBtnShadow = NULL;
	hpenBtnHilite = NULL;
	hpenBtnText = NULL;
	UpdateSysColors();

	// cxBorder2 and cyBorder are 2x borders for Win4
	cxBorder2 = bWin4 ? CX_BORDER*2 : CX_BORDER;
	cyBorder2 = bWin4 ? CY_BORDER*2 : CY_BORDER;

	// allocated on demand
	hStatusFont = NULL;
	hToolTipsFont = NULL;
	hButtonVerticalFont = NULL;
	hButtonVerticalFontLarge = NULL;
	pFontMenuText=NULL;
	pFontMenuBold=NULL;
	pFontMenuVertical=NULL;
	nMenuTextHeight=0;
	bDeleteMenuText=FALSE;
	bDeleteMenuBold=FALSE;
	bDeleteMenuVertical=FALSE;

	hbmMenuArrow=NULL;
	hbmMenuArrowDisabled=NULL;
	hbmMenuArrowVertical=NULL;
	hbmMenuArrowVerticalDisabled=NULL;

	// information about toolbar sizes
	csSmallButtonGlyph.cx=16;
	csSmallButtonGlyph.cy=16;
	csLargeButtonGlyph.cx=32;
	csLargeButtonGlyph.cy=32;
	csSmallButton.cx=24;
	csSmallButton.cy=22;
	csLargeButton.cx=40;
	csLargeButton.cy=38;

	// determined empirically. No known systemmetric returns these, but on NT40, at least, they don't change even when
	// the system font size is ridculously large (e.g. 40)
	cxPreCloseGap=2;
	cyPreCloseGap=2;
	cxPostCloseGap=1;
	cyPostCloseGap=1;
	cxPreMinimizeGap=1;
	cyPreMinimizeGap=1;

	// Cached system metrics (updated in CWnd::OnWinIniChange)
	UpdateSysMetrics();
}

// Termination code
GLOBAL_DATA::~GLOBAL_DATA()
{
	FlushMenuFonts();

	// cleanup standard brushes
	AfxDeleteObject((HGDIOBJ*)&hbrLtGray);
	AfxDeleteObject((HGDIOBJ*)&hbrDkGray);
	AfxDeleteObject((HGDIOBJ*)&hbrBtnFace);
	AfxDeleteObject((HGDIOBJ*)&hbrBtnShadow);
	AfxDeleteObject((HGDIOBJ*)&hbrBtnHilite);
	AfxDeleteObject((HGDIOBJ*)&hbrWindowFrame);

	// cleanup standard pens
	AfxDeleteObject((HGDIOBJ*)&hpenBtnShadow);
	AfxDeleteObject((HGDIOBJ*)&hpenBtnHilite);
	AfxDeleteObject((HGDIOBJ*)&hpenBtnText);

	// clean up objects we don't actually create
	AfxDeleteObject((HGDIOBJ*)&hStatusFont);
	AfxDeleteObject((HGDIOBJ*)&hToolTipsFont);
	AfxDeleteObject((HGDIOBJ*)&hButtonVerticalFont);
	AfxDeleteObject((HGDIOBJ*)&hButtonVerticalFontLarge);

	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrow);
	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrowDisabled);
	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrowVertical);
	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrowVerticalDisabled);
}

void GLOBAL_DATA::UpdateSysColors()
{
	ASSERT(COLOR_3DHIGHLIGHT == COLOR_BTNHIGHLIGHT);
	ASSERT(COLOR_3DSHADOW == COLOR_BTNSHADOW);

	clrBtnFace = ::GetSysColor(COLOR_BTNFACE);
	clrBtnShadow = ::GetSysColor(COLOR_BTNSHADOW);
	clr3dDkShadow = ::GetSysColor(COLOR_3DDKSHADOW);
	clrBtnHilite = ::GetSysColor(COLOR_BTNHIGHLIGHT);
	clrBtnText = ::GetSysColor(COLOR_BTNTEXT);
	clrGrayText = ::GetSysColor(COLOR_GRAYTEXT);
	clrWindowFrame = ::GetSysColor(COLOR_WINDOWFRAME);
	clrMenu = ::GetSysColor(COLOR_MENU);

	AfxDeleteObject((HGDIOBJ*)&hbrBtnFace);
	AfxDeleteObject((HGDIOBJ*)&hbrBtnShadow);
	AfxDeleteObject((HGDIOBJ*)&hbrBtnHilite);
	AfxDeleteObject((HGDIOBJ*)&hbrWindowFrame);

	hbrBtnFace = ::CreateSolidBrush(clrBtnFace);
	ASSERT(hbrBtnFace != NULL);
	hbrBtnShadow = ::CreateSolidBrush(clrBtnShadow);
	ASSERT(hbrBtnShadow != NULL);
	hbrBtnHilite = ::CreateSolidBrush(clrBtnHilite);
	ASSERT(hbrBtnHilite != NULL);
	hbrWindowFrame = ::CreateSolidBrush(clrWindowFrame);
	ASSERT(hbrWindowFrame != NULL);

	AfxDeleteObject((HGDIOBJ*)&hpenBtnShadow);
	AfxDeleteObject((HGDIOBJ*)&hpenBtnHilite);
	AfxDeleteObject((HGDIOBJ*)&hpenBtnText);

	hpenBtnShadow = ::CreatePen(PS_SOLID, 0, clrBtnShadow);
	ASSERT(hpenBtnShadow != NULL);
	hpenBtnHilite = ::CreatePen(PS_SOLID, 0, clrBtnHilite);
	ASSERT(hpenBtnHilite != NULL);
	hpenBtnText = ::CreatePen(PS_SOLID, 0, clrBtnText);
	ASSERT(hpenBtnText != NULL);

	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrow);
	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrowDisabled);
	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrowVertical);
	AfxDeleteObject((HGDIOBJ*)&hbmMenuArrowVerticalDisabled);
	hbmMenuArrow=NULL;
	hbmMenuArrowDisabled=NULL;
	hbmMenuArrowVertical=NULL;
	hbmMenuArrowVerticalDisabled=NULL;
}

void GLOBAL_DATA::UpdateSysMetrics()
{
	// Device metrics for screen
	HDC hDCScreen = GetDC(NULL);
	ASSERT(hDCScreen != NULL);
	cxPixelsPerInch = GetDeviceCaps(hDCScreen, LOGPIXELSX);
	cyPixelsPerInch = GetDeviceCaps(hDCScreen, LOGPIXELSY);
	ReleaseDC(NULL, hDCScreen);

	csSmallIcon.cx=GetSystemMetrics(SM_CXSMICON);
	csSmallIcon.cy=GetSystemMetrics(SM_CYSMICON);
	csCaptionButton.cx=GetSystemMetrics(SM_CXMENUSIZE);
	csCaptionButton.cy=GetSystemMetrics(SM_CYMENUSIZE);

	// Those nice people over in office fortunately worked this out for me:
		// MSDN or Win95 is lying to me. The icon sizes are *not* SM_CXMENUSIZE and SM_CYMENUSIZE.
		// The values used below are the empirical result of painstaking pixel counting in
		// different Win95 schemes. (fix 14286)
	// Who am I to argue with the Office source code? Anyway, painstaking pixel counting sounds like
	// the sort of thing you want someone else to do... :)

	csCaptionButton.cx-=2;
	csCaptionButton.cy-=4;

	if(!SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &nMenuShowDelay, FALSE))
	{
		nMenuShowDelay=400;

		// Under Win95 build 950 the SPI_ value is not supported apparently, so we use the registry directly. Mostly
		// ok, unless you've recently changed the double-click speed. 
		CString strKey = REGISTRY_MENUSHOWDELAY_KEY;

		HKEY hKey;
		if( RegOpenKeyEx(HKEY_CURRENT_USER, (char*)(const char*)strKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
		{
			unsigned char abBuf[512];
			DWORD dwcb = 511;
			DWORD dwType = REG_SZ;
			CString strValue=REGISTRY_MENUSHOWDELAY_VALUE;
			if( (RegQueryValueEx(hKey, strValue, NULL, &dwType, abBuf, &dwcb) == ERROR_SUCCESS) && (dwcb > 0) )
			{
				int val=atoi((char *)abBuf);
				if(val>=0)
				{
					nMenuShowDelay=val;
				}
			}
			RegCloseKey(hKey);
		}
	}

	FlushMenuFonts();

	// get details of double clicks
	tmDoubleClick=GetDoubleClickTime();
	cxDoubleClick=GetSystemMetrics(SM_CXDOUBLECLK)/2;
	cyDoubleClick=GetSystemMetrics(SM_CYDOUBLECLK)/2;
}

//
// MenuTextOut
// One stop shopping for drawing text on menus and toolbars.
//
//
void GLOBAL_DATA::MenuTextOut(CDC* pDC, 
				 const CRect* pRect,    // Bounding rectangle
				 const CString& text, 
				 UINT eFlags /*= e_LeftAlign*/)
{
	ASSERT( pRect != NULL) ;
	ASSERT( !pRect->IsRectEmpty() && !pRect->IsRectNull()) ;

	if (text.IsEmpty())
	{
		return ;
	}

	// If disabled use the shadow drawing function.
	if (eFlags & e_mtoDisabled)
	{
		DisabledTextOut(pDC, pRect, text, eFlags);
	}
	else
	{
		// If not disabled call the underlining function directly.
		UnderlineTextOut(pDC, pRect, text, eFlags);
	}
}

//
// DisabledTextOut is to be called from MenuTextOut.
//
void GLOBAL_DATA::DisabledTextOut(      CDC *pDC, 
									const CRect* pRect,
									const CString &text,
									UINT eFlags)
{
	BOOL bPainted=FALSE;

	if(UseWin4Look())
	{
		// only attempt embossed look if button face and 3d colour are same,
		// and the button face colour is different from the highlight colour; 
		// otherwise, revert to Win3x style dithering
		if( clrBtnFace != clrBtnHilite  &&
			clrMenu == clrBtnFace)
		{
			int iOldBkMode = pDC->SetBkMode(TRANSPARENT) ;
			COLORREF oldText=pDC->SetTextColor(globalData.clrBtnHilite);

			// draw the text
			CRect rectShadow(pRect) ;
			rectShadow.OffsetRect(1,1) ;
			UnderlineTextOut(pDC, &rectShadow, text, eFlags);
			pDC->SetTextColor(globalData.clrBtnShadow);
			UnderlineTextOut(pDC, pRect, text, eFlags);

			// clean up
			pDC->SetBkMode(iOldBkMode) ;
			pDC->SetTextColor(oldText);

			bPainted=TRUE;
		}
	}

	if(!bPainted)
	{
		// according to the docs for graystring, we can just draw the text ourselves
		// unless either the gray colour is dithered, or the gray colour is black

		if( clrGrayText != pDC->GetNearestColor(clrGrayText) || 
			clrGrayText == RGB(0,0,0))
		{
			//TODO: GrayString doesn't do underlining.
			//paint grey
			bPainted=pDC->GrayString(NULL, NULL, (LPARAM)((LPCTSTR)text),
									 text.GetLength(), pRect->left, pRect->top, 
									 pRect->Width(),pRect->Height());
		} 

		if(!bPainted)
		{
			// get here if graystring was inappropriate, or if it reported an error
			COLORREF oldText=pDC->SetTextColor(globalData.clrBtnText);
			UnderlineTextOut(pDC, pRect, text, eFlags);
			pDC->SetTextColor(oldText);
		}
	}
}
/////////////////////////////////////////////////////////////////////////////
/*-----------------------------------------------------------------------_---
  6 jun 96 stolen from MSO.

  Hey, there's a comment, must mean I stole this from Mso which I did. I 
  changed it to use TCHARs and CString instead of Mso's wide strings that
  keep a zero in the first byte.

  Instead of returning a pointer, it returns an index into the CString. This
  index is -1 if an & is not found.

  MSO Comment below:

  MsoPwchStripAmpersandsWtz

	Strip odd '&' chars from the string 'wtz' in place, and return a pointer 
	to the character after the last odd '&' (the character to underline 
	as per Windows DrawText rules), or NULL if none.  As per DrawText,
	consecutive pairs of '&'s will leave a real '&' character, and all
	odd '&'s are removed even though only the last may be underlined.
------------------------------------------------------------------- DAVEPA -*/

int GLOBAL_DATA::StripAmpersands(TCHAR* pstart, int len)
{
	int indexUnderline = -1 ;
	for (TCHAR *pch = pstart ; *pch ; pch++)
	{
		if (*pch == '&')
		{
			memcpy(pch, pch + 1, (len - (pch - pstart)) * sizeof(TCHAR));
			len--;
			if (*pch && *pch != '&')
			{
				indexUnderline = pch - pstart ;
			}
		}
	}
	return indexUnderline;  
}
/////////////////////////////////////////////////////////////////////////////

void GLOBAL_DATA::UnderlineTextOut(CDC* pdc, 
								   const CRect* pRect,
								   LPCTSTR str, 
								   UINT eFlags) 
{
	BOOL bVertical = (eFlags & e_mtoVertical);
	int alignVertical = (bVertical) ? TA_BOTTOM : TA_TOP ;
	UINT oldAlign=pdc->SetTextAlign(TA_LEFT | alignVertical);
	
	// Make a copy of the string, because we are going to change it in place.
	int len = _tcslen(str) ;
	ASSERT( len > 0) ;

	TCHAR* szStripped = new TCHAR[len+1];
	_tcscpy(szStripped, str) ;

	// Find the & charater and strip it. 
	int indexUnderline = StripAmpersands(szStripped, len) ;
	if (indexUnderline >=0)
	{
		// Underline was found so string length changed.
		len = _tcslen(szStripped) ;
	}

	// Get the size.
	CSize sizeText = pdc->GetTextExtent(szStripped, len) ;

	// New rect for adjusting the size in.
	CRect rectAligned(pRect) ;

	// Center the text in its normal Y direction.
	if (bVertical)
	{
		rectAligned.left += (pRect->Width() - sizeText.cy) / 2 ;
		rectAligned.right -= (pRect->Width() - sizeText.cy) / 2 ;
	}
	else
	{
		rectAligned.top += (pRect->Height() - sizeText.cy) / 2 ;
	}

	// Center the text horizontally.
	if (eFlags & e_mtoCenterAlign)
	{
		if (bVertical)
		{
			rectAligned.top += (pRect->Height() - sizeText.cx) / 2 ;
			rectAligned.bottom -= (pRect->Height() - sizeText.cx) / 2 ;
		}
		else
		{
			rectAligned.left += (pRect->Width() - sizeText.cx) / 2 ;
		}
	}
	else if (eFlags & e_mtoRightAlign)
	{
		if (bVertical)
		{
			rectAligned.top = rectAligned.bottom - sizeText.cx ;
		}
		else
		{
			rectAligned.left = rectAligned.right - sizeText.cx ;
		}

	}
	
	// Print the text.
	pdc->ExtTextOut(rectAligned.left, rectAligned.top, 0, &rectAligned, szStripped, _tcslen(szStripped),NULL) ;

	if (indexUnderline != -1)
	{
		// draw underline by hand
		// all I'm doing here is drawing a line one pixel thick two pixels below (or
		// to the left of, depending on orientation) the font baseline. Instead of
		// calling LineTo which requires a pen, I blast the line out with ExtTextOut.
		// (three consecutive ExtTextOuts don't work, because Windows won't draw the
		// underline under a single character properly)

		// Get the metrics for the text.
		TEXTMETRIC tm ;
		pdc->GetTextMetrics(&tm) ;

		// Get the starting point for the underline
		CSize sizeBeforeUnderline = pdc->GetTextExtent(szStripped, indexUnderline);
		if (indexUnderline != 0)        // only subtract overhang if underline is not first character (fix 45383)
		{
			sizeBeforeUnderline.cx -= tm.tmOverhang;
		}

		// Get width of the underling
		CSize sizeUnderline = pdc->GetTextExtent(&szStripped[indexUnderline], 1 ) ;
		sizeUnderline.cx -= tm.tmOverhang;

		CRect rc;
		if (bVertical)
		{
			rc.left = rectAligned.right - tm.tmAscent - 2;
			rc.top  = rectAligned.top + sizeBeforeUnderline.cx;

			rc.right = rc.left + 1;                         // +1 so that the underlineline has thickness 1
			rc.bottom = rc.top  + sizeUnderline.cx;
		}
		else
		{
			rc.left = rectAligned.left + sizeBeforeUnderline.cx;
			rc.top = rectAligned.top + tm.tmAscent+1;

			rc.right = rc.left + sizeUnderline.cx;
			rc.bottom = rc.top + 1;                         // +1 so that the underlineline has thickness 1
		}

		// Draw the underline.
		COLORREF crText = pdc->GetTextColor() ;
		int iOldBkMode = pdc->SetBkMode(OPAQUE);
		COLORREF crBkSav = pdc->SetBkColor(crText);
		pdc->ExtTextOut(0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
		pdc->SetBkColor(crBkSav);
		pdc->SetBkMode(iOldBkMode) ;

	}

	delete [] szStripped ;

	pdc->SetTextAlign(oldAlign);

};

//
//      GetTextExtentNoAmpersands
//
//      Gets the width of a line of text, stripping out the ampersands.
//
CSize GLOBAL_DATA::GetTextExtentNoAmpersands(CDC* pdc, const CString& str ) const
{
	ASSERT(!str.IsEmpty()) ;

	// Get the length of the string to measure
	int len = str.GetLength() ;

	// Make a copy of this string.
	TCHAR* szStripped = new TCHAR[len+1];
	_tcscpy(szStripped, (LPCTSTR)str) ;

	// Find the & charater and strip it. 
	int indexUnderline = StripAmpersands(szStripped, len) ;

	if (indexUnderline >=0)
	{
		// Underline was found so string length changed.
		len = _tcslen(szStripped) ;
	}

	// Get the size.
	CSize size = pdc->GetTextExtent(szStripped, len) ;

	// Cleanup
	delete [] szStripped ;

	return size ;
}

/////////////////////////////////////////////////////////////////////////////

// Accessors for on-demand loaded items
HFONT GLOBAL_DATA::GetButtonFont(BOOL bLarge)
{
	if(bLarge)
	{
		return static_cast<HFONT>(GetStdFont(font_Large)->m_hObject);
	}
	else
	{
		return static_cast<HFONT>(GetStdFont(font_Normal)->m_hObject);
	}
}

// Accessors for on-demand loaded items
// Vertical fonts are troublesome, as there appears to be no guarantee that a user will
// actually have any TT font on their machine at a given time.
HFONT GLOBAL_DATA::GetButtonVerticalFont(BOOL bLarge)
{
	HFONT *phFont;
	if(bLarge)
	{
		phFont=&hButtonVerticalFontLarge;
	}
	else
	{
		phFont=&hButtonVerticalFont;
	}

	// auto cache flush if size has changed
	if(*phFont==NULL)
	{
		HFONT hHoriz=GetButtonFont(bLarge);
		
		LOGFONT lfHoriz;

		VERIFY(::GetObject(hHoriz,sizeof(LOGFONT), &lfHoriz));

		lfHoriz.lfEscapement=-900;
		lfHoriz.lfOrientation=-900;
		lfHoriz.lfOutPrecision=OUT_TT_ONLY_PRECIS;
		lfHoriz.lfPitchAndFamily=FF_SWISS | VARIABLE_PITCH;
		
		*phFont=CreateFontIndirect(&lfHoriz);

		BOOL bValid=TRUE;

		if(!*phFont)
		{
			bValid=FALSE;
		}
		else
		{
			LOGFONT lfVert;

			VERIFY(::GetObject(*phFont,sizeof(LOGFONT), &lfVert));

			// must be vertical
			if(     lfVert.lfEscapement!=-900 ||
				lfVert.lfOrientation!=-900)
			{
				bValid=FALSE;
				::DeleteObject(*phFont);
			}
		}

		if(!bValid)
		{
			// try again, for any font family
			lfHoriz.lfPitchAndFamily=FF_SWISS | VARIABLE_PITCH;
			lfHoriz.lfFaceName[0]='\0';

			*phFont=CreateFontIndirect(&lfHoriz);
		}
	}

	ASSERT(*phFont!=NULL);

	return *phFont;
}

HBITMAP GLOBAL_DATA::LoadSysColorBitmap(UINT id)
{
	HINSTANCE hInstance = AfxFindResourceHandle(MAKEINTRESOURCE(id), RT_BITMAP);
	ASSERT( hInstance != NULL );
	HRSRC hRsrc = ::FindResource(hInstance, MAKEINTRESOURCE(id), RT_BITMAP);

	HBITMAP hbmLoad = AfxLoadSysColorBitmap(hInstance, hRsrc);

	ASSERT(hbmLoad!=NULL);

	return hbmLoad;
}

HBITMAP GLOBAL_DATA::GetMenuArrow()
{
	if(hbmMenuArrow==NULL)
	{
		hbmMenuArrow=LoadSysColorBitmap(IDB_MENUBTN_ARROW);
	}
	return hbmMenuArrow;
}

HBITMAP GLOBAL_DATA::GetMenuArrowDisabled()
{
	if(hbmMenuArrowDisabled==NULL)
	{
		hbmMenuArrowDisabled=LoadSysColorBitmap(IDB_MENUBTN_ARROWD);
	}
	return hbmMenuArrowDisabled;
}

HBITMAP GLOBAL_DATA::GetMenuArrowVertical()
{
	if(hbmMenuArrowVertical==NULL)
	{
		hbmMenuArrowVertical=LoadSysColorBitmap(IDB_MENUBTN_ARROWV);
	}
	return hbmMenuArrowVertical;
}

HBITMAP GLOBAL_DATA::GetMenuArrowVerticalDisabled()
{
	if(hbmMenuArrowVerticalDisabled==NULL)
	{
		hbmMenuArrowVerticalDisabled=LoadSysColorBitmap(IDB_MENUBTN_ARROWVD);
	}
	return hbmMenuArrowVerticalDisabled;
}

// duplicates the portion of the selected bitmap beginning at the specified point and with area 
// specified by size 
HBITMAP GLOBAL_DATA::DuplicateBitmap(CWnd *pWnd, HBITMAP hbmBitmap, CSize size, CPoint offset)
{
	HBITMAP hbmDuplicate;

	// get dcs for src and dest
	HDC hdcClient = ::GetDC(pWnd->GetSafeHwnd());
	HDC hdcDest = ::CreateCompatibleDC(hdcClient);
	HDC hdcSrc = ::CreateCompatibleDC(hdcClient);

	// Get details of source bitmap
	BITMAP bmpSrcData;
	::GetObject(hbmBitmap, sizeof(BITMAP), &bmpSrcData);

	if(size.cx==0 && size.cy==0)
	{
		size.cx=bmpSrcData.bmWidth;
		size.cy=bmpSrcData.bmHeight;
	}
		
	// create dest
	hbmDuplicate=CreateBitmap(size.cx, size.cy, bmpSrcData.bmPlanes, bmpSrcData.bmBitsPixel, NULL);
	::ReleaseDC(pWnd->GetSafeHwnd(), hdcClient);
	
	if (hbmDuplicate==NULL || hdcDest == NULL || hdcSrc == NULL)
	{       
		// May RIP.
		::DeleteObject(hbmDuplicate);
		::DeleteDC(hdcSrc);
		::DeleteDC(hdcDest);
		return NULL;
	}
			
	// setup dcs
	HBITMAP hbmOldDest = (HBITMAP) ::SelectObject(hdcDest, hbmDuplicate);
	HBITMAP hbmOldSrc = (HBITMAP) ::SelectObject(hdcSrc, hbmBitmap);
	
	::BitBlt(hdcDest, 0, 0, size.cx, size.cy, hdcSrc, offset.x, offset.y,  SRCCOPY);

	// clean up
	::SelectObject(hdcDest, hbmOldDest);
	::SelectObject(hdcSrc, hbmOldSrc);
	::DeleteDC(hdcSrc);
	::DeleteDC(hdcDest);

	return hbmDuplicate;
}

BOOL GLOBAL_DATA::ScaleBitmap(CWnd *pWnd, HBITMAP dest, CSize destSize, CPoint destOffset, const  HBITMAP src, CSize srcSize)
{
	HDC hdcClient = ::GetDC(pWnd->GetSafeHwnd());
	HDC hdcDest = ::CreateCompatibleDC(hdcClient);
		
	// create dest
	::ReleaseDC(pWnd->GetSafeHwnd(), hdcClient);
	
	if (hdcDest == NULL)
	{       
		// May RIP.
		::DeleteDC(hdcDest);
		return FALSE;
	}
		
	// setup dcs
	HBITMAP hbmOldDest = (HBITMAP) ::SelectObject(hdcDest, dest);

	BOOL rv=ScaleBitmap(hdcDest, destSize, destOffset, src, srcSize);

	::SelectObject(hdcDest, hbmOldDest);
	::DeleteDC(hdcDest);

	return rv;
}

BOOL GLOBAL_DATA::ScaleBitmap(HDC hdcDest, CSize destSize, CPoint destOffset, const  HBITMAP src, CSize srcSize)
{
	// get dc for src
	HDC hdcSrc = ::CreateCompatibleDC(hdcDest);

	if (hdcSrc == NULL)
	{       
		// May RIP.
		::DeleteDC(hdcSrc);
		return FALSE;
	}
		
	// setup dcs
	HBITMAP hbmOldSrc = (HBITMAP) ::SelectObject(hdcSrc, src);
	
	// copy and stretch
	BOOL rv=::StretchBlt(hdcDest, destOffset.x, destOffset.y, destSize.cx, destSize.cy, hdcSrc, 0, 0, srcSize.cx, srcSize.cy, SRCCOPY);
	ASSERT(rv);
	
	// clean up
	::SelectObject(hdcSrc, hbmOldSrc);
	::DeleteDC(hdcSrc);

	return rv;
}


// DIB functions stolen from the DIBLOOK sample

#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD)(lpbi)) == sizeof(BITMAPINFOHEADER))

static WORD WINAPI DIBNumColors(LPSTR lpbi)
{
	WORD wBitCount;  // DIB bit count

	/*  If this is a Windows-style DIB, the number of colors in the
	 *  color table can be less than the number of bits per pixel
	 *  allows for (i.e. lpbi->biClrUsed can be set to some value).
	 *  If this is the case, return the appropriate value.
	 */

	if (IS_WIN30_DIB(lpbi))
	{
		DWORD dwClrUsed;

		dwClrUsed = ((LPBITMAPINFOHEADER)lpbi)->biClrUsed;
		if (dwClrUsed != 0)
			return (WORD)dwClrUsed;
	}

	/*  Calculate the number of colors in the color table based on
	 *  the number of bits per pixel for the DIB.
	 */
	if (IS_WIN30_DIB(lpbi))
		wBitCount = ((LPBITMAPINFOHEADER)lpbi)->biBitCount;
	else
		wBitCount = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;

	/* return number of colors based on bits per pixel */
	switch (wBitCount)
	{
		case 1:
			return 2;

		case 4:
			return 16;

		case 8:
			return 256;

		default:
			return 0;
	}
}

static WORD WINAPI PaletteSize(LPSTR lpbi)
{
   /* calculate the size required by the palette */
   if (IS_WIN30_DIB (lpbi))
	  return (WORD)(::DIBNumColors(lpbi) * sizeof(RGBQUAD));
   else
	  return (WORD)(::DIBNumColors(lpbi) * sizeof(RGBTRIPLE));
}

static LPSTR WINAPI FindDIBBits(LPSTR lpbi)
{
	return (lpbi + *(LPDWORD)lpbi + ::PaletteSize(lpbi));
}

void GLOBAL_DATA::PasteGlyph(CWnd *pWnd, HBITMAP hbmWell, int iImage, CSize sizeImage)
{
	BOOL bPasteFailed=FALSE;
	HDC hdcClient = NULL;
	HDC hdcDest = NULL;
	HGLOBAL hDib=NULL;
	HBITMAP hbmOldDest=NULL;
	HWND hWnd=pWnd->GetSafeHwnd();

	{ 
		// BLOCK containing gotos
		// start by filling in background, in case things go wrong
		hdcClient = ::GetDC(hWnd);
		hdcDest = ::CreateCompatibleDC(hdcClient);


		if (hdcDest == NULL)
		{       
			TRACE("Cannot get dc\n");
			bPasteFailed=TRUE;
			goto lPasteFailed;
		}

		hbmOldDest = (HBITMAP) ::SelectObject(hdcDest, hbmWell);

		// fill in backgroyund
		CBrush* pbr = GetSysBrush(CMP_COLOR_LTGRAY);
		HBRUSH hbrOld = (HBRUSH) ::SelectObject(hdcDest, pbr->m_hObject);
		::PatBlt(hdcDest, sizeImage.cx * iImage, 0,     sizeImage.cx, sizeImage.cy, PATCOPY);
		::SelectObject(hdcDest, hbrOld);

		// copy from current clipboard
		if (!pWnd->OpenClipboard())
		{
			// reporting error with Beep following convention in resource editor
			TRACE("Cannot open clipboard\n");
			bPasteFailed=TRUE;
			goto lPasteFailed;
		}
		
		// Enumerate the cliboard contents to determine what is available.
		// If a CF_BITMAP is seen, stop looking. If CF_DIB is seen, set a 
		// flag and proceed. 
		
		BOOL bBitmapAvailable = FALSE;
		BOOL bDibAvailable = FALSE;

		UINT nClipFmt = 0;
		do
		{
			nClipFmt = EnumClipboardFormats(nClipFmt);
			
			switch (nClipFmt)
			{
			case CF_BITMAP:
				bBitmapAvailable = TRUE;
				break;
				
			case CF_DIB:
				bDibAvailable = TRUE;
				break;
			}
		}
		while (!bBitmapAvailable && nClipFmt != 0);

		if(!bBitmapAvailable && !bDibAvailable)
		{
			// reporting error with Beep following convention in resource editor
			TRACE("Cannot find appropriate format\n");
			bPasteFailed=TRUE;
			goto lPasteFailed;
		}

		CSize sizePaste;
		CBitmap *pClipBitmap=NULL;
		LPBITMAPINFO lpDib=NULL;

		if(bBitmapAvailable)
		{
			pClipBitmap = CBitmap::FromHandle((HBITMAP)GetClipboardData(CF_BITMAP));

			// Clipboard occasionally lies, when app's use defered rendering,
			// but don't actually produce the goods on demand.

			if (pClipBitmap == NULL)
			{
				TRACE("Cannot access bitmap format\n");
				bPasteFailed=TRUE;
				goto lPasteFailed;
			}

			BITMAP bm;
			pClipBitmap->GetObject(sizeof(BITMAP), &bm);
			sizePaste.cx = bm.bmWidth;
			sizePaste.cy = bm.bmHeight;
		}
		else
		{
			ASSERT(bDibAvailable);

			hDib = (HGLOBAL)GetClipboardData(CF_DIB);
			if (hDib == NULL)
			{
				TRACE("Cannot access dib format\n");
				bPasteFailed=TRUE;
				goto lPasteFailed;
			}

			lpDib = (LPBITMAPINFO)GlobalLock(hDib);
			if (lpDib->bmiHeader.biSize != sizeof (BITMAPINFOHEADER))
			{
				// Can't deal with OS/2 style DIBs...
				GlobalUnlock(hDib);
				TRACE("Cannot use OS2 dib format\n");
				bPasteFailed=TRUE;
				goto lPasteFailed;
			}

			sizePaste.cx = lpDib->bmiHeader.biWidth;
			sizePaste.cy = lpDib->bmiHeader.biHeight;
		}

		sizePaste.cx=min(sizeImage.cx, sizePaste.cx);
		sizePaste.cy=min(sizeImage.cy, sizePaste.cy);

		if(bBitmapAvailable)
		{
			HDC hdcSrc = ::CreateCompatibleDC(hdcClient);

			if (hdcSrc == NULL)
			{       
				TRACE("Cannot get dc\n");
				bPasteFailed=TRUE;
				goto lPasteFailed;
			}
		
			HBITMAP hbmOldSrc = (HBITMAP) ::SelectObject(hdcSrc, (HBITMAP)(*pClipBitmap));

			BitBlt(hdcDest, iImage*sizeImage.cx, 0, sizePaste.cx, sizePaste.cy, hdcSrc, 0, 0, SRCCOPY);

			::SelectObject(hdcSrc, hbmOldSrc);
			::DeleteDC(hdcSrc);
		}
		else
		{
			LPSTR    lpDIBBits=::FindDIBBits((LPSTR) lpDib);
			SetDIBitsToDevice(hdcDest,iImage*sizeImage.cx,0,sizePaste.cx, sizePaste.cy, 0,0, 0, sizePaste.cy, lpDIBBits, lpDib, DIB_RGB_COLORS);
		}
	}

lPasteFailed:
	if(hdcClient)
	{
		::ReleaseDC(hWnd, hdcClient);
	}

	if(hdcDest!=NULL)
	{
		::SelectObject(hdcDest, hbmOldDest);
		::DeleteDC(hdcDest);
	}

	if (hDib != NULL)
		GlobalUnlock(hDib);
	
	CloseClipboard();

	if(bPasteFailed)
	{
		MessageBeep(0);
		// returning here is not a disaster. The well has been filled with a grey
		// background.
		return;
	}
}

// Code stolen and adapted from MFC - had to, they don't make it public.
#define RGB_TO_RGBQUAD(r,g,b)   (RGB(b,g,r))
#define CLR_TO_RGBQUAD(clr)     (RGB(GetBValue(clr), GetGValue(clr), GetRValue(clr)))

struct TBCOLORMAP
{
	// use DWORD instead of RGBQUAD so we can compare two RGBQUADs easily
	DWORD rgbqFrom;
	int iSysColorTo;
};

// This table is copied from MFC
static const TBCOLORMAP sysColorMap[] =
{
	// mapping from color in DIB to system color
	{ RGB_TO_RGBQUAD(0x00, 0x00, 0x00),  COLOR_BTNTEXT },       // black
	{ RGB_TO_RGBQUAD(0x80, 0x80, 0x80),  COLOR_BTNSHADOW },     // dark grey
	{ RGB_TO_RGBQUAD(0xC0, 0xC0, 0xC0),  COLOR_BTNFACE },       // bright grey
	{ RGB_TO_RGBQUAD(0xFF, 0xFF, 0xFF),  COLOR_BTNHIGHLIGHT }   // white
};
const int nMaps = 4;

#define WIDTHBYTES(i)   ((i+31)/32*4)      /* ULONG aligned ! */

// This is the palette for all of our toolbars. We use this palette for all custom bitmaps too,
// meaning that a bitmap pasted from one of our own bars cannot be rendered incorrectly
PALETTEENTRY stdToolbarPalette[]=
{
	{ 0x00,0x00,0x00,0x0 },
	{ 0x00,0x00,0x80,0x0 },
	{ 0x00,0x80,0x00,0x0 },
	{ 0x00,0x80,0x80,0x0 },
	{ 0x80,0x00,0x00,0x0 },
	{ 0x80,0x00,0x80,0x0 },
	{ 0x80,0x80,0x00,0x0 },
	{ 0x80,0x80,0x80,0x0 },
	{ 0xC0,0xC0,0xC0,0x0 },
	{ 0x00,0x00,0xF0,0x0 },
	{ 0x00,0xF0,0x00,0x0 },
	{ 0x00,0xF0,0xF0,0x0 },
	{ 0xF0,0x00,0x00,0x0 },
	{ 0xF0,0x00,0xF0,0x0 },
	{ 0xF0,0xF0,0x00,0x0 },
	{ 0xF0,0xF0,0xF0,0x0 }
};

// Assorted DIB functions stolen from the CROPDIB sample
/* DibNumColors(pv)
 *
 * Returns the number of palette entries in the palette. The <pv> parameter
 * can point to a BITMAPINFOHEADER or BITMAPCOREHEADER structure.
 */
WORD GLOBAL_DATA::DibNumColors(
    VOID FAR * pv)          // Pointer to the bitmap info header structure
{
    LPBITMAPINFOHEADER lpbi= ((LPBITMAPINFOHEADER)pv);

    int nBitCount;

    /* With a BITMAPINFOHEADER structure, the number of palette entries
     * is in biClrUsed; otherwise, the count depends on the number of bits
     * per pixel.
     */
    if (lpbi->biSize != sizeof(BITMAPCOREHEADER))
    {
	if(lpbi->biClrUsed != 0)
	    return (WORD)lpbi->biClrUsed;

	nBitCount = lpbi->biBitCount;
    }

    switch (nBitCount)
    {
	case 1:
	    return 2;

	case 4:
	    return 16;

	case 8:
	    return 256;

	default:
	    return 0;
    }
}

/* PaletteSize(pv)
 *
 * Returns the size of the palette in bytes. The <pv> parameter can point
 * to a BITMAPINFOHEADER or BITMAPCOREHEADER structure.
 */
WORD GLOBAL_DATA::PaletteSize(
    VOID FAR * pv)          // Pointer to the bitmap info header structure
{
    LPBITMAPINFOHEADER lpbi ((LPBITMAPINFOHEADER)pv);

    WORD    NumColors;

    NumColors = DibNumColors(lpbi);

	return NumColors * sizeof(RGBQUAD);
}

// This code has to manually convert a DDB to a DIB for the above palette

HANDLE GLOBAL_DATA::SaveSysColorBitmap(HBITMAP hbmSrc)
{
	ASSERT(hbmSrc!=NULL);

	if (hbmSrc != NULL)
	{
		// LOGPALETTE includes one palette entry in size
		LOGPALETTE *pLogPal=(LOGPALETTE *)calloc(1,sizeof(LOGPALETTE)+sizeof(stdToolbarPalette)-sizeof(PALETTEENTRY));

		ASSERT(pLogPal!=NULL);

		pLogPal->palVersion=0x300;
		pLogPal->palNumEntries=sizeof(stdToolbarPalette)/sizeof(PALETTEENTRY);
		memcpy(pLogPal->palPalEntry, stdToolbarPalette, sizeof(stdToolbarPalette));

		HPALETTE hPal=::CreatePalette(pLogPal);

		HANDLE hDIB=CreateLogicalDib(hbmSrc, 4, hPal);

		::DeleteObject(hPal);

		free(pLogPal);

		return hDIB;
	}

	return NULL;
}

HBITMAP GLOBAL_DATA::LoadSysColorBitmap(LPBITMAPINFOHEADER lpBitmap)
{
	if (lpBitmap == NULL)
		return NULL;

	// make copy of BITMAPINFOHEADER so we can modify the color table
	const int nColorTableSize = 16;
	UINT nSize = lpBitmap->biSize + nColorTableSize * sizeof(RGBQUAD);
	LPBITMAPINFOHEADER lpBitmapInfo = (LPBITMAPINFOHEADER)::malloc(nSize);
	if (lpBitmapInfo == NULL)
		return NULL;
	memcpy(lpBitmapInfo, lpBitmap, nSize);

	// color table is in RGBQUAD DIB format
	DWORD* pColorTable =
		(DWORD*)(((LPBYTE)lpBitmapInfo) + (UINT)lpBitmapInfo->biSize);

	for (int iColor = 0; iColor < nColorTableSize; iColor++)
	{
		// look for matching RGBQUAD color in original
		for (int i = 0; i < nMaps; i++)
		{
			if (pColorTable[iColor] == sysColorMap[i].rgbqFrom)
			{
				pColorTable[iColor] =
						CLR_TO_RGBQUAD(::GetSysColor(sysColorMap[i].iSysColorTo));
				break;
			}
		}
	}

	// now load it into one of our screen-type bitmaps, using the adjusted colour table.
	int nWidth = (int)lpBitmapInfo->biWidth;
	int nHeight = (int)lpBitmapInfo->biHeight;
	HDC hDCScreen = ::GetDC(NULL);
	HBITMAP hbm = ::CreateCompatibleBitmap(hDCScreen, nWidth, nHeight);

	if (hbm != NULL)
	{
		HDC hDCGlyphs = ::CreateCompatibleDC(hDCScreen);
		HBITMAP hbmOld = (HBITMAP)::SelectObject(hDCGlyphs, hbm);

		LPBYTE lpBits;
		lpBits = (LPBYTE)(lpBitmap + 1);
		lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

		StretchDIBits(hDCGlyphs, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight,
			lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);
		SelectObject(hDCGlyphs, hbmOld);

		::DeleteDC(hDCGlyphs);
	}
	::ReleaseDC(NULL, hDCScreen);

	// free copy of bitmap info struct and resource itself
	::free(lpBitmapInfo);

	return hbm;
}

// Code stolen and modified from an CROPDIB example

/*  CreateLogicalDib(hbm, biBits, hPal)
 *
 *  Given a DDB and a HPALETTE create a "logical" DIB. If the HPALETTE is
 *  NULL, it uses the system palette.
 *
 *  A "logical" DIB is a DIB where the DIB color table *exactly* matches
 *  the passed logical palette.  There will be no system colors in the
 *  color table, and a pixel value of <n> in the DIB corresponds to logical
 *  palette index <n>.
 *
 *  Why create a "logical" DIB? When the DIB is written to a disk file and
 *  then reloaded, the logical palette created from the DIB color table 
 *  exactly matches the one used originaly to create the bitmap. It also
 *  prevents GDI from doing nearest color matching on PC_RESERVED palettes.
 *
 *  To create the logical DIB, we call GetDIBits() with the DIB_PAL_COLORS
 *  option. We then convert the palette indices returned in the color table
 *  to logical RGB values.  The entire logical palette passed to <hpal> 
 *  is always copied to the DIB color table.
 *
 *  The DIB color table will have exactly the same number of entries as
 *  the logical palette.  Normally GetDIBits() sets the biClrUsed field to
 *  the maximum colors supported by the device, regardless of the number of
 *  colors in the logical palette. If the logical palette contains more 
 *  than 256 colors, the function truncates the color table at 256 entries.
 */

HANDLE GLOBAL_DATA::CreateLogicalDib(
    HBITMAP hbm,        // DDB to copy
    WORD biBits,        // New DIB: bit count: 8, 4, or 0
    HPALETTE hpal)      // New DIB: palette
{
    LPBITMAPINFOHEADER  lpbiDDB;      // Temporary pointer to DDB BITMAPINFO
    WORD FAR *          lpDDBClrTbl;  // Pointer to DIB color table

    HANDLE              hLDib;
    LPBITMAPINFOHEADER  lpLDib;       // Pointer to logical DIB header
    BYTE FAR *          lpLDibBits;   // Pointer to logical DIB bits
    RGBQUAD FAR *       lpLDibRGB;    // Pointer to logical DIB color table
    WORD                nLDibColors;  // How many colors in logical DIB
    DWORD               dwLDibLen;    // Size of logical DIB

    HDC                 hdc;          // Temp stuff, working variables
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    PALETTEENTRY        peT;
    DWORD               dw;
    int                 n;
    HPALETTE            hpalT;

	ASSERT(hpal!=NULL);
    if (hbm == NULL)
	return NULL;

    VERIFY(GetObject(hpal,sizeof(nLDibColors),(LPSTR)&nLDibColors));
    VERIFY(GetObject(hbm,sizeof(bm),(LPSTR)&bm));

    /* Truncate palette entries at 256 if the logical palette has more
     * than 256 entries.
     */
    if (nLDibColors > 256)
	nLDibColors = 256;

    /* If bit count is zero, fill in bit count based on number of colors
     * in palette.
     */
    if (biBits == 0)
	biBits = nLDibColors > 16 ? 8 : 4;

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = biBits;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * 
				bm.bmHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = nLDibColors;
    bi.biClrImportant       = 0;

    dwLDibLen = bi.biSize + PaletteSize(&bi) + bi.biSizeImage;

    hLDib = GlobalAlloc(GMEM_FIXED,dwLDibLen);
				    
    if (!hLDib)
	return NULL;

    lpbiDDB = (LPBITMAPINFOHEADER)GlobalAlloc(GMEM_FIXED,bi.biSize + 256 * sizeof(RGBQUAD));

    if (!lpbiDDB)
    {
	GlobalFree(hLDib);
	return NULL;
    }

    hdc = ::GetDC(NULL);
    hpalT = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    lpLDib = (LPBITMAPINFOHEADER)GlobalLock(hLDib);

    *lpbiDDB  = bi;
    *lpLDib = bi;

    /* Get the DIB bits. With DIB_PAL_COLORS flag, the color table is
     * filled with logical palette indices.
     */
    lpLDibBits = (BYTE *)lpLDib + (WORD)lpLDib->biSize + PaletteSize(lpLDib);

    GetDIBits(hdc,                    // Device context
	      hbm,                    // Bitmap we're copying
	      0,                      // Starting scan line
	      (WORD)bi.biHeight,      // Number of scan lines to copy
	      lpLDibBits,           // Receives bitmap bits in DIB format
	      (LPBITMAPINFO)lpbiDDB,  // Receives DDB color table
	      DIB_PAL_COLORS);        // Usage--copy indices into the 
				      // currently realized logical palette

    /* Convert the DIB bits from indices into the color table (which
     * contains indices into the logical palette) to direct indices
     * into the logical palette.
     *
     * lpDDBClrTbl   Points to the DIB color table, which is a WORD array of
     *               logical palette indices.
     *
     * lpLDibBits    Points to the DIB bits. Each DIB pixel is a index into
     *               the DIB color table.
     */
    lpDDBClrTbl = (WORD FAR *)((LPSTR)lpbiDDB + (WORD)lpbiDDB->biSize);

    if (biBits == 8)
    {
	for (dw = 0; dw < bi.biSizeImage; dw++, ((BYTE *)lpLDibBits)++)
	    *lpLDibBits = (BYTE)lpDDBClrTbl[*lpLDibBits];
    }
    else // biBits == 4
    {
	for (dw = 0; dw < bi.biSizeImage; dw++, ((BYTE *)lpLDibBits)++)
	    *lpLDibBits = (BYTE)(lpDDBClrTbl[*lpLDibBits & 0x0F] |
			     (lpDDBClrTbl[(*lpLDibBits >> 4) & 0x0F] << 4));
    }

    /* Now copy the RGBs in the logical palette to the DIB color table.
     */
    lpLDibRGB = (RGBQUAD FAR *)((LPSTR)lpLDib + (WORD)lpLDib->biSize);

    for (n=0; n<nLDibColors; n++, lpLDibRGB++)
    {
	GetPaletteEntries(hpal,n,1,&peT);

	lpLDibRGB->rgbRed      = peT.peRed;
	lpLDibRGB->rgbGreen    = peT.peGreen;
	lpLDibRGB->rgbBlue     = peT.peBlue;
	lpLDibRGB->rgbReserved = (BYTE)0;
    }

    GlobalUnlock(hLDib);
    GlobalFree(lpbiDDB);

    SelectPalette(hdc,hpalT,FALSE);
    ::ReleaseDC(NULL,hdc);

    return hLDib;
}

TCHAR GLOBAL_DATA::ExtractAccelerator(LPCTSTR item)
{
	CString strLabel(item);
	BOOL bFinished=FALSE;
	TCHAR chAccel=0;
	while(!bFinished)
	{
		int iAmpersand;
		if ((iAmpersand = strLabel.Find('&')) != -1)
		{
			ASSERT(strLabel.GetLength() > iAmpersand+1);    // & can't be last char
			if (strLabel[iAmpersand + 1] == '&')
			{
				strLabel = strLabel.Right(strLabel.GetLength() - (iAmpersand + 2));
			}
			else
			{
				chAccel = strLabel[iAmpersand + 1];
				bFinished=TRUE;
			}
		}
		else
		{
			bFinished=TRUE;
		}
	}
	return chAccel;
}                               


// This code is shared between the popup menu and the custom button dialog, so it's been put here
		
// Because buttons can have compulsory, optional or forbidden states for each of text and image,
// there are a complex set of options. This table summarises:

/*
				IF      IF      IF      IO      IO      IO      IC      IC      IC
				TF      TO      TC      TF      TO      TC      TF      TO      TC


I               D       D       D       D       E       D       D       E       D
T               D       D       D       D       E       E       D       D       D
IT              D       D       D       D       E       E       D       E       D

IL              D       D       D       E       C       C       E       E       E
TE              D       E       E       D       C       E       D       C       E

DG              N       Y               Y               Y               Y               Y               Y               Y               Y

Key:

Rows describe the availability of items within this dialog:
I: Image Only Radio button
T: Text ONly Radio button
IT: Image and Text Radio Button
IL: The image list (m_pButtonSource)
TL: The text entry field
DG: Should the dialog be visible at all

Columns describe the values of m_aoCanText and m_aoCanImage
IF: m_aoCanImage==cAppearanceForbidden
IO: m_aoCanImage==cAppearanceOptional
IC: m_aoCanImage==cAppearanceCompulsory
TF: m_aoCanText==cAppearanceForbidden
TO: m_aoCanText==cAppearanceOptional
TC: m_aoCanText==cAppearanceCompulsory

Table entries are as follows:
D: Control is disabled
E: Control is enabled
C: Control is enabled conditionally, depending on current state of I, T and IT.
Y: Dialog is available
N: Dialog is unavailable

Could use a karnaugh map, I guess, but I think I'll do it manually.

When the radio buttons are disabled, their current state will still correctly reflect the only valid state of the dialog

martynl 24Jun96

*/

// local helper function
static inline BOOL EverythingDisabled(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage)
{
	// no radio buttons if
	return aoText==cAppearanceForbidden || aoImage==cAppearanceForbidden || 
						(aoText==cAppearanceCompulsory && aoImage==cAppearanceCompulsory);
}


BOOL GLOBAL_DATA::CanChooseImageOnly(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage)
{
	return !(EverythingDisabled(aoText, aoImage) || aoText==cAppearanceCompulsory);
}

BOOL GLOBAL_DATA::CanChooseTextOnly(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage)
{
	return !(EverythingDisabled(aoText, aoImage) || aoImage==cAppearanceCompulsory);
}

BOOL GLOBAL_DATA::CanChooseImageText(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage)
{
	return !EverythingDisabled(aoText, aoImage);
}

// gets the font that would be used in a menu at this time
CFont *GLOBAL_DATA::GetMenuFont(BOOL bDefault)
{
	CFont **ppFont=NULL;
	BOOL *pbDelete;

	if(!bDefault)
	{
		ppFont=&pFontMenuText;
		pbDelete=&bDeleteMenuText;
	}
	else
	{
		ppFont=&pFontMenuBold;
		pbDelete=&bDeleteMenuBold;
	}

	ASSERT(ppFont!=NULL);

	// if the font's already loaded, use it
	if(*ppFont)
	{
		return *ppFont;
	}
	else
	{
		// load the font
		NONCLIENTMETRICS ncm;
		ncm.cbSize=sizeof(ncm);

		SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE);

		if(bDefault)
		{
			// make it a bold font. 700 is the defined weight for bold
			if(ncm.lfMenuFont.lfWeight < 700)
			{
				ncm.lfMenuFont.lfWeight=700;
			}
			else
			{
				// it's already bold or heaver, so make it as heavy as possible
				ncm.lfMenuFont.lfWeight=1000;
			}
		}

		// so now create the font
		*ppFont=new CFont;

		if(!((*ppFont)->CreateFontIndirect(&ncm.lfMenuFont)))
		{
			delete *ppFont;
			// creation failed. Fall back on our default internals. 
			*ppFont=GetStdFont(bDefault ? font_Bold : font_Normal);
			*pbDelete=FALSE;
		}
		else
		{
			*pbDelete=TRUE;
		}

		return *ppFont;
	}
}

// gets the font that would be used in a menu at this time
CFont *GLOBAL_DATA::GetMenuVerticalFont()
{
	// if the font's already loaded, use it
	if(pFontMenuVertical)
	{
		return pFontMenuVertical;
	}
	else
	{
		// load the font
		NONCLIENTMETRICS ncm;
		ncm.cbSize=sizeof(ncm);

		SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE);

		ncm.lfMenuFont.lfEscapement=-900;
		ncm.lfMenuFont.lfOrientation=-900;
		ncm.lfMenuFont.lfOutPrecision=OUT_TT_ONLY_PRECIS;

		// so now create the font
		pFontMenuVertical=new CFont;

		if(!((pFontMenuVertical)->CreateFontIndirect(&ncm.lfMenuFont)))
		{
			delete pFontMenuVertical;
			// creation failed. Fall back on our default internals. 
			pFontMenuVertical=CFont::FromHandle(GetButtonVerticalFont(GetLargeMenuButtons()));
			bDeleteMenuVertical=FALSE;
		}
		else
		{
			LOGFONT lfVert;

			VERIFY(pFontMenuVertical->GetObject(sizeof(LOGFONT), &lfVert));

			// must be vertical
			if( lfVert.lfEscapement!=-900 ||
				lfVert.lfOrientation!=-900)
			{
				delete pFontMenuVertical;
				// creation failed. Fall back on our default internals. 
				pFontMenuVertical=CFont::FromHandle(GetButtonVerticalFont(GetLargeMenuButtons()));
				bDeleteMenuVertical=FALSE;
			}
			else
			{
				bDeleteMenuVertical=TRUE;
			}
		}

		return pFontMenuVertical;
	}
}

// Deletes any cached fonts
void GLOBAL_DATA::FlushMenuFonts(void)
{
	nMenuTextHeight=0;
	if(pFontMenuText!=NULL)
	{
		// don't delete if we fell back onto a standard font due to resource limitations
		if(bDeleteMenuText)
		{
			delete pFontMenuText;
		}
		pFontMenuText=NULL;
	}

	if(pFontMenuBold!=NULL)
	{
		// don't delete if we fell back onto a standard font due to resource limitations
		if(bDeleteMenuBold)
		{
			delete pFontMenuBold;
		}
		pFontMenuBold=NULL;
	}
	if(pFontMenuVertical!=NULL)
	{
		// don't delete if we fell back onto a standard font due to resource limitations
		if(bDeleteMenuVertical)
		{
			delete pFontMenuVertical;
		}
		pFontMenuVertical=NULL;
	}
}

int GLOBAL_DATA::GetMenuTextHeight(void)
{
	if(nMenuTextHeight==0)
	{
		// get the font that will be used to draw menu items
		CFont *pFont=GetMenuFont(FALSE);

		// get the size of large glyphs
		CSize sizeLargeBitmap=CCustomBar::GetDefaultBitmapSize(TRUE);
		
		TEXTMETRIC tm;

		// determine maximum size of the font
		CDC dc;               
		dc.CreateCompatibleDC(NULL);

		// select the menu font
		CFont *pOldFont=dc.SelectObject(pFont);

		dc.GetTextMetrics(&tm);

		nMenuTextHeight=tm.tmHeight;

		// large buttons if the text is larger than a large button
		bLargeMenuButtons=tm.tmHeight>=sizeLargeBitmap.cy;

		dc.SelectObject(pOldFont);
	}

	return nMenuTextHeight;
}

int GLOBAL_DATA::GetMenuVerticalHeight(void)
{
	if(nMenuVerticalHeight==0)
	{
		// get the font that will be used to draw menu items
		CFont *pFont=GetMenuVerticalFont();

		TEXTMETRIC tm;

		// determine maximum size of the font
		CDC dc;               
		dc.CreateCompatibleDC(NULL);

		// select the menu font
		CFont *pOldFont=dc.SelectObject(pFont);

		dc.GetTextMetrics(&tm);

		nMenuVerticalHeight=tm.tmHeight;

		dc.SelectObject(pOldFont);
	}

	return nMenuVerticalHeight;
}

BOOL GLOBAL_DATA::GetLargeMenuButtons(void)
{
	GetMenuTextHeight();

	return bLargeMenuButtons;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bardockx.h ===
///////////////////////////////////////////////////////////////////////////////
//      BARDOCKX.H
//      Declarations for the dockable toolbar class CASBar.
//
// This class adds the following functionality to CCustomBar; Dockability, savability,
// some menu bar functionality
///////////////////////////////////////////////////////////////////////////////

#ifndef __BARDOCKX_H__
#define __BARDOCKX_H__

#ifndef __BARCUST_H__
#include "barcust.h"
#endif

//      class CToolBar;
//              class CCustomBar;
					class CASBar;

class CDockManager;

/////////////////////////////////////////////////////////////////////////////
// CASBar window

class CASBar : public CCustomBar
{
public:
	// these steal messages for use by the menu bar
	static BOOL StealMenuMessage(MSG *pMsg);
	static BOOL EarlyStealMenuMessage(MSG *pMsg);

public:
	static CToolCustomizer* s_pCustomizer;
    static CObArray NEAR s_aUsage;
	static CASBar *s_pMenuBar;
	static CWnd *s_pOldFocus;
	
// Construction.        
public:
    CASBar();
    virtual ~CASBar();

	// If these create functions fail, they call delete this;
	BOOL Create(CDockManager* pManager, UINT nID, LPCRECT lpRect = NULL,
		LPCSTR lpszTitle = NULL);
    BOOL Create(CWnd* pParent, CDockManager* pManager, DWORD dwStyle,
				TOOLBARINIT FAR* lptbi, UINT FAR* lpIDArray, HGLOBAL hglobInit,
				BOOL bRegister = FALSE, DOCKINIT FAR* lpdi = NULL);

// Operations.
public:
	virtual CToolCustomizer* GetCustomizer();
	virtual ORIENTATION GetOrient() const;

	virtual CCustomBar* NewBar(UINT nID, const CPoint& pt);
	virtual void MoveBar(const CRect& rect);
	virtual void OnBarActivate();
	virtual void OnButtonSize();
	virtual BOOL KeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);

	virtual HWND GetControl(UINT nID);
	virtual void LoseFocus();
	static void ForceReleaseCapture();

	virtual void DeleteButton(int nIndex, BOOL bMoving = FALSE);
	virtual int InsertButton(int nIndex, TRANSFER_TBBUTTON& trans,
		BOOL bReplace, GAP gap);

	// Used for saving and loading data
    HGLOBAL GetData();
    BOOL SetData(HGLOBAL hglob);

    BOOL DynSetButtons(const UINT FAR* lpIDArray, int nIDCount);

	// used to specify whether to use large or small toolbar buttons
	// returns FALSE on error
	BOOL SetButtonSize(BOOL bLarge);

	// This class always remembers the menu bar pointer, so it can provide it as required
	static CASBar *GetMenuBar(void) {return s_pMenuBar;};
	static void UpdateMenuBar(CFrameWnd* pTarget) { if(s_pMenuBar) s_pMenuBar->OnUpdateCmdUI(pTarget, TRUE);}

	// menu calls this when it is completed, to stop the bar tracking
	virtual void MenuDone();

	// Returns TRUE if the item is expecting to regain the focus to the bar
	virtual int ExpandItem(int nIndex, BOOL bExpand, BOOL bKeyboard=FALSE);

	// Call from outside when a command table entry is going away. Iterates over all bars
	static void RemoveAllCommandReferences(UINT id);
	// used by the above
	BOOL RemoveCommandReferences(UINT id);

	virtual CSize GetSize(UINT nHitTest, CSize size);
	virtual CSize GetHSize(ORIENTATION or);

	// Sets the dirty state of the bar. 
	void SetDirty(BOOL bDirty) { m_bDirty=TRUE; };

	// reset the bar
	void Reset(void);
	
	int m_iKeySelect;                                       // the currently activated keyboarding button

// Attributes.
protected:
	UINT m_nIDWnd;  // the dock ID (MAKEDOCKID) of this toolbar - combination of the package id and the window id
	BOOL m_bDirty;  // Save to reg DB?
										// or -1 if not.
	BOOL m_bDropPending; // if TRUE, then the next time the keyboard navigates to a menu item
					   // it should drop down
    

	HANDLE CASBar::SaveSysColorBitmap(HBITMAP hbmSrc);
	HBITMAP CASBar::LoadSysColorBitmap(LPBITMAPINFOHEADER lpBitmap);
	HANDLE CASBar::CreateLogicalDib(HBITMAP hbm, WORD biBits,HPALETTE hpal);

// Message map functions.
protected:
	virtual void PostNcDestroy();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnButtonPressed(int iButton);
	virtual void LoseKeyFocus(void);
	virtual void GainKeyFocus(int iFocus=0);
	// This function will return TRUE if the button menu was displayed, and FALSE if not.
	// The button menu is the copy/paste/reset/edit/choose
	// toolbar button popup menu displayed only when a toolbar is being customised.
	// martynl 22Mar96
	BOOL DisplayButtonMenu(UINT nFlags, CPoint point);

    //{{AFX_MSG(CASBar)
	afx_msg void OnKillFocus(CWnd *);
	afx_msg void OnNcPaint();
    afx_msg UINT OnNcHitTest(CPoint pt);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nHitTest, CPoint pt);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnSysColorChange();
	afx_msg void OnSysCommand(UINT nID, LONG lParam);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg LRESULT OnGetData(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetMoveSize(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetTrackSize(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDkNcLButtonDown(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDropMenu(WPARAM wParam, LPARAM lParam);
    
    DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CASBar)
};

extern UINT DSM_BARSIZECHANGING;
// This message will be sent whenever the toolbar button size has just changed
// WPARAM: 0: small bars
//         1: large bars
// LPARAM: result of _getpid() Only act on this message if your pid is the same as that
//                    passed in this message
// The LPARAM needs to contain a CWinApp pointer because floating toolbars/other are top-level windows,
// so we have to broadcast the DSM_BARSIZECHANGING message to all top-level windows. When the broadcast
// arrives, we validate the pid to avoid size changes emanating from other simultaneously]
// executing devstudio instances. martynl 03May96

#endif  // __BARDOCKX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barprxy.cpp ===
#include "stdafx.h"

#include "barprxy.h"

#include "barglob.h"
#include "commapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// For Orion, the data storage format is going to have to be radically different. It will
// to accomodates menus and toolbars, including items such as  toolbar buttons, dropdown menus, 
// textual buttons, as well as everything that was supported in 4.0. I guess that we might also 
// like to support migration of toolbars, though given that we've changed the IDs of all the 
// commands, this could be difficult.

// The original version 4.0 code always emitted data blocks that were an exact multiple 
// of 3 WORDs long (x%3 always == 0). [This calculation excludes the size word stored before
// the block, which is not included in the transmitted value] We can use this fact to identify 
// ourselves (and future versions) in an extensible way compatible with the 4.0 scheme by 
// never writing blocks whose length%3 is 1. To make things somewhat simpler for future 
// upgrade schemes, I am going to add a version word to the front of the data block.

// At this point, code to migrate v4x toolbars is not being implemented, but the opening is here
// to add migration code simply by detecting the size of the output data.

// The original (v4x) format was:
// size	  - size of the block in bytes, excluding the size word
// repeat  
//   nID    - command id
//   nStyle - type of toolbar button
//   wExtra - only used for width of sizeable hwnd controls
// end repeat

// The Orion format is under development, and will be amended as more features are added.
// The current version is:
// size         - size of the block, in bytes, excluding the size word
// version word - always cBarDataVersion50
// count    - number of buttons on the bar
// offset to start of string table (*1) from start of version word, in words
// offset to start of bitmap table (*2) from start of version word, in words
// offset to start of addin/macro table (*3) from start of version word, in words
// repeat
//   nID    - command id or menu id - 0 implies separator, or addin info
//   nStyle - type of toolbar button
//   wExtra - used for width of sizeable hwnd controls
//			           textLabel table index of textual controls
// end repeat
// *1
// string table (ordered as they appear in the bar)
// repeat
//   string in wide character form
// end repeat
// *2
// DIB table (ordered as they appear in the bar)
// repeat
//   WORD: dib data size
//   DIB data
// end repeat
// *3
// addin info table
// repeat
//   WORD: id of package responsible for command
//   WORD: addin info size
//   addin info
// end repeat
// 00 padding to ensure block size criteria listed above

// FUTURE: Perhaps consider using MFC serialisation for this in next major version. We just
// extended the same storage format when moving from v4 to v5; this allowed us to easily
// play version detection tricks with the size of blocks, for example. But clearly, this kind of
// pointer/access code is neither very reliable nor very readable; probably next time round
// we'll need to replace it.

// martynl 10May96, revised 25Jun96

// These formats were used in some earlier checked in code
const WORD cBarDataVersionPre50a=1; // before DIB saving, and re-org
const WORD cBarDataVersionPre50b=2; // before TBBS_GLYPH
const WORD cBarDataVersionPre50c=3; // before addins and macros
const WORD cBarDataVersionPre50d=4; // before TBBS_CUSTOMTEXT
// The current format
const WORD cBarDataVersion50=5;
const WORD cBarDataVersionCurrent=cBarDataVersion50;

// CASBar:SetData
// The SetData function transfers data from the hglobal to the bar, by decoding it. It's used
// for loading. Note that loading of toolbars is a 2 phase process with this and DynSetButtons
BOOL CToolBarProxy::SetData(HGLOBAL hglob)
{
	BOOL bSomeDeleted=FALSE;	// true if something was deleted during loading
	BOOL bSomeAdded=FALSE;		// true if something was loaded

	// empty toolbar, to ensure that what goes
	// in here is not confused
	Empty();
	
	WORD FAR* lpWord = (WORD FAR*) ::GlobalLock(hglob); // this is the offset into the decoded data
	
	// extract size of decoded data
	WORD wSize	= *lpWord++;

	// real block starts here
	WORD FAR* lpBase = lpWord;
	WORD nVersion = *lpWord++;

	// ensure it's a VC 5 toolbar
	ASSERT(((wSize/sizeof(WORD)) % 3)!=0);
	if(nVersion != cBarDataVersionCurrent || ((wSize/sizeof(WORD)) % 3)==0)
	{
		// V4 migration code would go here, if we were motivated.
		return FALSE;
	}

	int nCount = *lpWord++;

	// extract pointers to middle of table for bitmaps, strings, and ICommandProvider stuff
	WORD FAR* lpString= lpBase+(*lpWord++);
	int nString=0;
	WORD FAR* lpBitmap= lpBase+(*lpWord++);
	WORD FAR* lpExternal= lpBase+(*lpWord++);
	
	ASSERT((lpString-lpBase)<=wSize);
	ASSERT((lpBitmap-lpBase)<=wSize);
	ASSERT((lpExternal-lpBase)<=wSize);

	BatchBegin(nCount);

    for (int iButton = 0; iButton < nCount; iButton++)
    {
		int nID = *lpWord++;
		int nStyle = *lpWord++;
		int nExtra = *lpWord++;
		CString text;
		HBITMAP hbmGlyph=NULL;
		if(nStyle & TBBS_CUSTOMTEXT)
		{
			text=((LPCTSTR)lpString);
			lpString=(WORD*)(((LPCTSTR)lpString)+text.GetLength()+1);
		}
		if(nStyle & TBBS_CUSTOMBITMAP)
		{
			WORD wBmpSize=*lpBitmap++;
			hbmGlyph=GLOBAL_DATA::LoadSysColorBitmap((LPBITMAPINFOHEADER)lpBitmap);
			lpBitmap=(LPWORD)(((LPBYTE)lpBitmap)+wBmpSize);
		}
		if(	nID==0 &&						// not a regular command 
			(nStyle & TBBS_SEPARATOR)==0)	// not a separator
		{
			// need to get ICommandProvider to decode data
			WORD wPackage=*lpExternal++;
			ASSERT(wPackage>0);

			if(wPackage>0)
			{
				WORD wDataSize=*lpExternal++;
				// find the package for this command
				CPackage *pPackage=theApp.GetPackage(wPackage);
				if(pPackage!=NULL)
				{
					
					ICommandProvider *pCP=pPackage->GetCommandProvider();

					if(pCP!=NULL)
					{
						// decode the saved data into a command id
						nID=pCP->LoadCommand(lpExternal, wDataSize);
						if(nID==0)
						{
							bSomeDeleted=TRUE;
							nStyle=TBBS_INVISIBLE;
						}

						pCP->Release();
					}
					else
					{
						// package is refusing to provide ICP interface, which it should do since data was saved that way
						ASSERT(FALSE);
						bSomeDeleted=TRUE;
						nID=0;
						nStyle=TBBS_INVISIBLE;
					}
				}
				else
				{
					bSomeDeleted=TRUE;
					nID=0;
					nStyle=TBBS_INVISIBLE;
				}

				// skip the data
				lpExternal=(LPWORD)(((LPBYTE)lpExternal)+wDataSize);
			}
			else
			{
				// if the package was 0, this is proabably a corrupted data stream, so quit
				break;
			}

		}

		if(nID!=0)
		{
			bSomeAdded=TRUE;
		}
		
		BatchAdd(iButton, nID, nStyle, nExtra, hbmGlyph, text);
    }

	BatchEnd();

	// At this point, all of the custom bitmaps have glyphs in the extra data. Some of these
	// should be transferred to the well and destroyed later on.

	ASSERT(lpString-lpBase<=wSize);
	ASSERT(lpBitmap-lpBase<=wSize);
	ASSERT(lpExternal-lpBase<=wSize);

	// ignore any potential padding
	ASSERT(lpWord-lpBase<=wSize);

	::GlobalUnlock(hglob);

	if(!bSomeAdded && bSomeDeleted)
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

// CASBar::GetData
// This is for saving the bar to the registry. It's quite memory intensive, unfortunately, 
// as each custom bar glyph must be converted to a DIB.
HGLOBAL CToolBarProxy::GetData()
{
	if (GetCount() == 0)
		return NULL;

	// We need to create the dib we're going to save from the custom bitmaps in the bar. Sadly, 
	// Since GetDIBits can only subsegment by scanlines, it isn't possible to act on a toolbar image well
	// and cut out the middle step and go straight from bitmaps within the toolbar image well and DIBs.
	// Instead we have to start by acquiring an individual button glyph to ensure that we have one
	// ddb for each custom button

	HGLOBAL *rgDibs=NULL;

	rgDibs=new HGLOBAL[GetCount()];
	ASSERT(rgDibs);

	for(int iButton=0; iButton < GetCount(); ++iButton) 
	{
		UINT nStyle;
		int iImage;
		UINT nID;

		GetButtonInfo(iButton, nID, nStyle, iImage);

		rgDibs[iButton]=NULL;

		if((nStyle & TBBS_CUSTOMBITMAP)!=0)
		{
			HBITMAP hbmSave=CreateSingleBitmap(iButton);

			rgDibs[iButton]=GLOBAL_DATA::SaveSysColorBitmap(hbmSave);

			ASSERT(GlobalSize(rgDibs[iButton])<USHRT_MAX);

			DestroySingleBitmap(iButton,hbmSave);
		}
	}

	// calculate size of block
	DWORD dwSize;						// start out by calculating size in a dword, so
										// we can spot overflows.
	dwSize=5*sizeof(WORD);				// version and count, plus 3 offsets
	DWORD dwButtonSize=GetCount()*sizeof(WORD)*3;	// the actual buttons
	dwSize+=dwButtonSize;

	// size of all the textual button labels
	BITMAP bmpData;

	DWORD dwStringSize=0;
	DWORD dwDIBSize=0;
	DWORD dwExternalSize=0;
	for(iButton=0; iButton < GetCount(); ++iButton)
	{
		UINT nStyle;
		int iImage;
		UINT nID;

		GetButtonInfo(iButton, nID, nStyle, iImage);

		if(nStyle & TBBS_CUSTOMTEXT)
		{
			dwStringSize+=(GetButtonText(iButton).GetLength()+1)*sizeof(TCHAR);
		}

		if(nStyle & TBBS_CUSTOMBITMAP)
		{
			// size of the following info
			dwDIBSize+=sizeof(WORD);

			// work out size of bits
			ASSERT(rgDibs[iButton]!=NULL);

			dwDIBSize+=GlobalSize(rgDibs[iButton]);
		}

		// if it's not a separator, it might have information of its own to save
		if((nStyle & TBBS_SEPARATOR)==0)
		{
			CTE *pCTE=theCmdCache.GetCommandEntry(nID);

			// find the package
			CPackage *pPackage=NULL;

			if(	pCTE &&
				pCTE->GetFirstPack() &&
				(pPackage=pCTE->GetFirstPack()->GetPackage())!=NULL)
			{
				// now get the appropriate interface
				ICommandProvider *pCP=pPackage->GetCommandProvider();
				if(pCP)
				{
					WORD wExternalSize=pCP->SaveCommand((WORD)nID, NULL);
					
					// always word align external blocks
					if(wExternalSize & 1)
					{
						wExternalSize+=1;
					}

					if(wExternalSize>0)
					{
						dwExternalSize+=sizeof(WORD); // package id
						dwExternalSize+=sizeof(WORD); // size of info
						dwExternalSize+=wExternalSize;
					}

					pCP->Release();
				}
			}
		}
	}
	// word align after strings
	if(dwStringSize & 1)
	{
		dwStringSize++;
	}

	WORD wStringOffset=(WORD)((dwSize)/sizeof(WORD));
	WORD wBitmapOffset=(WORD)((dwSize+dwStringSize)/sizeof(WORD));
	WORD wExternalOffset=(WORD)((dwSize+dwStringSize+dwDIBSize)/sizeof(WORD));

	dwSize+=dwStringSize+dwDIBSize+dwExternalSize;

	// ensure size is a multiple of WORD
	if(dwSize%2 == 1)
	{
		dwSize+=1;
	}
	
	// ensure the size couldn't be the size of a version 4.0 block
	if(((dwSize/sizeof(WORD)) % 3)==0)
	{
		dwSize+=sizeof(WORD);
	}

	if(dwSize>USHRT_MAX)
	{
		// Ugh! More than 64k of data expected.

		// clean up all the spare DIBs
		for (int iButton = 0; iButton < GetCount(); iButton++)
		{
			if(rgDibs[iButton]!=NULL)
			{
				GlobalFree(rgDibs[iButton]);
			}
		}
		delete rgDibs;

		return NULL;
	}

	WORD wSize=(WORD)dwSize;

	HGLOBAL hglob = ::GlobalAlloc(GMEM_SHARE, wSize + sizeof(WORD));
	WORD FAR* lpWord = (WORD FAR*) ::GlobalLock(hglob);
	
	*lpWord++ = wSize;
	LPWORD lpBase=lpWord;
	*lpWord++ = cBarDataVersionCurrent;
	*lpWord++ = (WORD)GetCount();

	*lpWord++ = wStringOffset;	
	WORD FAR *lpString = lpBase+wStringOffset; // where to store the offset to string
	*lpWord++ = wBitmapOffset;	
	WORD FAR *lpBitmap = lpBase+wBitmapOffset; // where to store the offset to bitmap
	*lpWord++ = wExternalOffset;	
	WORD FAR *lpExternal = lpBase+wExternalOffset; // where to store the offset to bitmap

	// write basic button data
    for (iButton = 0; iButton < GetCount(); iButton++)
    {
		UINT nStyle;
		int iImage;
		UINT nID;

		GetButtonInfo(iButton, nID, nStyle, iImage);

		// if it's not a separator, it might have information of its own to save
		if((nStyle & TBBS_SEPARATOR)==0)
		{
			CTE *pCTE=theCmdCache.GetCommandEntry(nID);

			// find the package
			CPackage *pPackage=NULL;

			if(	pCTE &&
				pCTE->GetFirstPack() &&
				(pPackage=pCTE->GetFirstPack()->GetPackage())!=NULL)
			{
				// now get the appropriate interface
				ICommandProvider *pCP=pPackage->GetCommandProvider();
				if(pCP)
				{
					// write external data past header stuff
					WORD wExternalSize=pCP->SaveCommand((WORD)nID, lpExternal+2);
					
					// always word align external blocks
					if(wExternalSize & 1)
					{
						wExternalSize+=1;
					}

					if(wExternalSize>0)
					{
						// write external data header
						*lpExternal++=(WORD)pPackage->PackageID();
						*lpExternal++=wExternalSize;
						lpExternal=(LPWORD)(((LPBYTE)lpExternal)+wExternalSize);

						nID=0;
					}

					pCP->Release();
				}
			}
		}

		*lpWord++ = (WORD) nID;
		// Never save invisible style
		*lpWord++ = (WORD) (nStyle & ~TBBS_INVISIBLE);

		WORD wExtra = 0; // extra is non-zero for windows, where it contains width
    	if (nStyle & TBBS_HWND)
    	{
    		CRect rect;
    		::GetWindowRect(GetButtonControl(iButton), rect);
		
    		wExtra = (WORD) rect.Width();
    	}
		*lpWord++ = wExtra;

		// save strings for each textual button
		if(nStyle & TBBS_CUSTOMTEXT)
		{
			_tcscpy((LPTSTR)lpString,GetButtonText(iButton));
			// nasty casts- advance word pointer in bytes
			lpString=(WORD*)(((LPCTSTR)lpString)+(GetButtonText(iButton).GetLength()+1));
		}

		// save all the DIBs.
		if(nStyle & TBBS_CUSTOMBITMAP)
		{
			ASSERT(rgDibs[iButton]!=NULL);

			*lpBitmap++=(WORD)GlobalSize(rgDibs[iButton]);

			memcpy(lpBitmap, rgDibs[iButton], GlobalSize(rgDibs[iButton]));

			lpBitmap=(LPWORD)(((LPBYTE)lpBitmap)+GlobalSize(rgDibs[iButton]));

			GlobalFree(rgDibs[iButton]);
		}

    }

	delete rgDibs;
	
	ASSERT(((LPBYTE)lpWord)-((LPBYTE)lpBase)<=wSize);
	ASSERT(((LPBYTE)lpString)-((LPBYTE)lpBase)<=wSize);
	ASSERT(((LPBYTE)lpBitmap)-((LPBYTE)lpBase)<=wSize);
	ASSERT(((LPBYTE)lpExternal)-((LPBYTE)lpBase)<=wSize);

	// pad with 0s
	while(((LPBYTE)lpExternal)-((LPBYTE)lpBase)<wSize)
	{
		*lpExternal++=0;
	}
	
	::GlobalUnlock(hglob);

	return hglob;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barglob.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct GLOBAL_DATA
{
	// system metrics
	int cxBorder2, cyBorder2;

	// device metrics for screen
	int cxPixelsPerInch, cyPixelsPerInch;

	// button glyph sizes
	CSize csSmallButtonGlyph;
	CSize csLargeButtonGlyph;
	// button enclosure sizes
	CSize csSmallButton;
	CSize csLargeButton;

	// small icon size (includes caption bar)
	CSize csSmallIcon;
	// right end of caption bar button sizes
	CSize csCaptionButton;
	// gap between restore button and close button (horz and vertical orientations)
	int cxPreCloseGap;
	int cyPreCloseGap;
	int cxPostCloseGap;
	int cyPostCloseGap;
	int cxPreMinimizeGap;
	int cyPreMinimizeGap;

	int tmDoubleClick;
	int cxDoubleClick;
	int cyDoubleClick;

	// solid brushes with convenient gray colors and system colors
	HBRUSH hbrLtGray, hbrDkGray;
	HBRUSH hbrBtnHilite, hbrBtnFace, hbrBtnShadow;
	HBRUSH hbrWindowFrame;
	HPEN hpenBtnHilite, hpenBtnShadow, hpenBtnText;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clr3dDkShadow, clrBtnHilite;
	COLORREF clrBtnText, clrGrayText, clrWindowFrame, clrMenu;

	// special GDI objects allocated on demand
	HFONT   hStatusFont;
	HFONT   hToolTipsFont;
	HFONT   hButtonVerticalFont;
	HFONT	hButtonVerticalFontLarge;

	// auxiliary toolbar bitmaps
	HBITMAP hbmMenuArrow;
	HBITMAP hbmMenuArrowDisabled;
	HBITMAP hbmMenuArrowVertical;
	HBITMAP hbmMenuArrowVerticalDisabled;

	// other system information
	UINT    nWinVer;			// Major.Minor version numbers
	BOOL	bWin32s;			// TRUE if Win32s (or Windows 95)
	BOOL    bWin4;				// TRUE if Windows 4.0
	BOOL    bNotWin4;			// TRUE if not Windows 4.0
	BOOL    bSmCaption;			// TRUE if WS_EX_SMCAPTION is supported
	BOOL	bWin31; 			// TRUE if actually Win32s on Windows 3.1
	int		nMenuShowDelay;		// delay for menus in milliseconds (SPI_MENUSHOWDELAY)

// Implementation
	GLOBAL_DATA();
	~GLOBAL_DATA();
	void UpdateSysColors();
	void UpdateSysMetrics();

	// MenuTextOut -
	// This function does all of the text drawing for CmdBar menus and buttons.
	// Its advantage over ExtTextOut is that it draws shadowed disabled text and
	// it underlines characters after the & character. The reason that we
	// ExtTextOut instead of DrawText is that buttons in vertically dock toolbars
	// require a vertical font which DrawText doesn't support.

	enum eMenuTextOut
	{
		// This are bit flags.
		e_mtoLeftAlign = 1,		// Align with the left edge
		e_mtoCenterAlign = 2,		// Center horizontally.
		e_mtoRightAlign = 4,
		e_mtoVertical = 8,			// Set if text is vertical for docking toolbars
		e_mtoDisabled = 16			// Set if the text is gray.
	};


	void MenuTextOut(CDC* pDC, 
					 const CRect* pRect,	// Bounding rectangle
					 const CString& text, 
					 UINT eFlags = e_mtoLeftAlign) ;


	// this routine is used to draw the 'embossed' disabled text used in menus and
	// buttons under Win95 and NT4. Windows doesn't export a routine that does this,
	// and there are several special cases to be accounted for, including mono monitors
	// the case when the menu and 3d colours are different, and handling for NT3.51.

	// This routine draws using the currently selected font at the point specified, using 
	// TA_TOP | TA_CENTRE
	
	// martynl 2ndApr96

//	void DrawDisabledText(CDC *pDC, CPoint ptPos, const CString &text, 
//						  eDrawDisabledTextFlags eFlags = e_Default,
//						  const CRect* pRect = NULL );
	// DER - 7 Jun 96 Revamped for menus
	// Now uses TA_TOP | TA_LEFT
	void DisabledTextOut(	CDC *pDC, 
							const CRect* pRect,
							const CString &text,
							UINT eFlags) ;


	// Draws text using ExtTextOut, but will underline strings with accelerators.
	// Used by DrawDisabledText which requires ExtTextOut for vertical text.
//	BOOL UnderlineTextOut(CDC* pdc, int x, int y, BOOL bVertical, 
//						  LPCTSTR str) ;//const CString& str);

	void UnderlineTextOut(CDC* pdc, 
						   const CRect* pRect,
						   LPCTSTR str, 
						   UINT eFlags) ;

	// Find the size of the text not counting the accelerator characters.
	CSize GetTextExtentNoAmpersands(CDC* pdc, const CString& str ) const;
	static TCHAR ExtractAccelerator(LPCTSTR item);
	static int StripAmpersands(TCHAR* pstart, int len);

	// duplicates the given bitmap (segment)
	static HBITMAP DuplicateBitmap(CWnd *pWnd, HBITMAP hbmBitmap, CSize size=CSize(0,0), CPoint offset=CPoint(0,0));
	// scales one bitmap into another
	static BOOL ScaleBitmap(CWnd *pWnd, HBITMAP dest, CSize destSize, CPoint destOffset, const HBITMAP src, CSize srcSize);
	// use when the dc is already prepared
	static BOOL ScaleBitmap(HDC hdcDest, CSize destSize, CPoint destOffset, const HBITMAP src, CSize srcSize);
	// pastes a clipboard glyph into an image well
	static void PasteGlyph(CWnd *pWnd, HBITMAP hbmWell, int nIndex, CSize sizeImage);

	// accessor functions for load-on-demand items
	HFONT GetButtonFont(BOOL bLarge);
	HFONT GetButtonVerticalFont(BOOL bLarge);

	static HBITMAP LoadSysColorBitmap(UINT id);
	HBITMAP GetMenuArrow(void);
	HBITMAP GetMenuArrowDisabled(void);
	HBITMAP GetMenuArrowVertical(void);
	HBITMAP GetMenuArrowVerticalDisabled(void);

	// gets the bold/nonbold menu font pointer
	CFont *GetMenuFont(BOOL bDefault);
	CFont *GetMenuVerticalFont();
	int GetMenuTextHeight(void);
	int GetMenuVerticalHeight(void);
	BOOL GetLargeMenuButtons(void);
	// flushes the menu fonts during update
	void FlushMenuFonts(void);

	// Bitmap and DIB utility functions
	static WORD GLOBAL_DATA::DibNumColors(VOID FAR * pv); // Pointer to the bitmap info header structure
	static WORD GLOBAL_DATA::PaletteSize(VOID FAR * pv);  // Pointer to the bitmap info header structure
	static HANDLE GLOBAL_DATA::SaveSysColorBitmap(HBITMAP hbmSrc);
	static HANDLE GLOBAL_DATA::CreateLogicalDib(	HBITMAP hbm,        // DDB to copy
											WORD biBits,        // New DIB: bit count: 8, 4, or 0
											HPALETTE hpal);      // New DIB: palette
	static HBITMAP GLOBAL_DATA::LoadSysColorBitmap(LPBITMAPINFOHEADER lpBitmap);

	static BOOL CanChooseImageOnly(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage);
	static BOOL CanChooseTextOnly(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage);
	static BOOL CanChooseImageText(APPEARANCEOPTION aoText, APPEARANCEOPTION aoImage);

private:
	CFont *	pFontMenuText;				// font used to draw menu items. In dire emergencies, this might be a ptr to font_normal
	BOOL    bDeleteMenuText;
	CFont *	pFontMenuVertical;				// font used to draw vertical menu bars. In dire emergencies, this might be a ptr to something else
	BOOL    bDeleteMenuVertical;
	CFont *	pFontMenuBold;				// font used to draw bold menu items. In dire emergencies, this might be a ptr to font_large
	BOOL    bDeleteMenuBold;
	int		nMenuTextHeight;			// height of pFontMenuText
	int		nMenuVerticalHeight;		// height of pFontMenuVertical
	BOOL	bLargeMenuButtons;			// toolbar buttons in menus are large 

};

extern GLOBAL_DATA globalData;

// Note: afxData.cxBorder and afxData.cyBorder aren't used anymore
#define CX_BORDER   1
#define CY_BORDER   1

// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))

BOOL AFXAPI AfxCustomLogFont(UINT nIDS, LOGFONT* pLogFont);
void AFXAPI AfxDeleteObject(HGDIOBJ* pObject);

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\btnctl.h ===
// btnctl.h : List box that allows dragging of toolbar buttons from it
/////////////////////////////////////////////////////////////////////////////

#ifndef __BTNCTL_H__
#define __BTNCTL_H__

class CToolCustomizer;

/////////////////////////////////////////////////////////////////////////////
// CButtonDragListBox control

class CButtonDragListBox : public CListBox
{
// Construction
public:
	CButtonDragListBox();

// Implementation
public:
	virtual ~CButtonDragListBox();

	enum SPECIALITEM
	{
		cNextFreeMenu=-1
	};

	BOOL	Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);
	
	// Generated message map functions
protected:
	//{{AFX_MSG(CButtonDragListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CButtonDragListBox)
};

#endif // __BTNCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\btnextra.cpp ===
#include "stdafx.h"
#include "btnextra.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void TBBUTTON_EXTRA::Create(HWND theControl, CString *theLabel, HBITMAP theCustom)
{
	hwndControl=theControl;
	if (theLabel != NULL)
		strLabel = *theLabel;
	hbmGlyph=theCustom;
	nLabelSize=CSize(0,0);
};

void TBBUTTON_EXTRA::Copy(TBBUTTON_EXTRA *src)
{ 
	AssertValid(); 

	SetControl(src->GetControl());
	SetLabel(src->GetLabel());
	SetGlyph(src->GetGlyph());
	SetLabelSize(CSize(0,0)); // don't copy this - may well be different in new context
};

void TBBUTTON_EXTRA::Destroy()
{
	AssertValid(); 

	if(hwndControl!=NULL)
	{
		::DestroyWindow(hwndControl);
		hwndControl=NULL;
	}
	strLabel.Empty();
	if(hbmGlyph!=NULL)
	{
		::DeleteObject(hbmGlyph);
		hbmGlyph=NULL;
	}
}

#ifdef _DEBUG
void TBBUTTON_EXTRA::AssertValid() const
{
	ASSERT(this!=NULL);

	ASSERT(hwndControl==NULL || IsWindow(hwndControl));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\btnextra.h ===
#ifndef btnextra_h
#define btnextra_h

struct TBBUTTON_EXTRA
{
	TBBUTTON_EXTRA() : hwndControl(NULL), hbmGlyph(NULL)
		{ }
#ifdef _DEBUG
	void AssertValid() const;
#else
	inline void AssertValid() const { };
#endif

	inline const HWND GetControl(void) const { AssertValid(); return hwndControl; };
	inline const CString& GetLabel(void) const { AssertValid(); return strLabel; };
	inline const HBITMAP GetGlyph(void) const { AssertValid(); return hbmGlyph; };
	inline BOOL HasLabel() { return !strLabel.IsEmpty(); }
	inline CSize GetLabelSize(void) const { AssertValid(); return nLabelSize; };

	inline HWND GetControl(void) { AssertValid(); return hwndControl; };
	inline CString& GetLabel(void) { AssertValid(); return strLabel; };
	inline HBITMAP GetGlyph(void) { AssertValid(); return hbmGlyph; };
	inline CSize GetLabelSize(void) { AssertValid(); return nLabelSize; };

	inline BOOL IsUsed(void) const { AssertValid(); return hwndControl!=NULL || !strLabel.IsEmpty() || hbmGlyph!=NULL; };

	inline void SetControl(HWND theControl) { AssertValid(); hwndControl=theControl; };
	inline void SetLabel(const CString& theLabel) { AssertValid(); strLabel = theLabel; nLabelSize=0; };
	inline void SetGlyph(HBITMAP theGlyph) { AssertValid(); hbmGlyph=theGlyph; };
	inline void SetLabelSize(CSize theLabelSize) { AssertValid(); nLabelSize = theLabelSize; };

	// we don't use a constructor in this class, as we expect to be able to manipulate it like
	// an ordinary C data structure (so it can be copied using memcpy, for example). And we are
	// going to use a standard memory array for efficiency purposes, rather than a CObArray, so 
	// all manipulation functions must be simple
	void Create(HWND theControl=NULL, CString* theLabel=NULL, HBITMAP theCustom=NULL);
	void Copy(TBBUTTON_EXTRA *src);
	// This deletes any items contained within the extra data. Only use if you're happy
	// for the extra data to completely go away.
	void Destroy();

private:
	HWND hwndControl; // the control used for window buttons (TBBS_HWND)
	CString strLabel; // the text used for menu and textual buttons
	HBITMAP hbmGlyph; // If this glyph is present, then it is the glyph that should be saved
					  // to disk, and is of the other size than the glyph currently in the well
	CSize nLabelSize; // this contains the pixel size of the label. It is updated by internal CCustomBar functions
					  // when they measure the string for the first time. If this value is positive, it is the 
					  // size of a label within a horizontal button. If it is negative, it is the negation of the 
					  // size within a vertical button
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bwizdlg.cpp ===
// bwizdlg.cpp : implementation file
//

#include "stdafx.h"
#include "bwizdlg.h"
#include "shell.h"	// szKeyRoot && szCompanyName strings(initexit.cpp)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// local constants
enum tag_IMAGE_INDEXES
{
   IMAGE_BUILDER=0,
   IMAGE_CATEGORY,
   NUM_IMAGES
};

static LPCTSTR s_szCLSID            = _T("CLSID");
static LPCTSTR s_szValueMetaCATID   = _T("META CATID");
static LPCTSTR s_szSubKeyMetaCATID  = _T("Type");
static LPCTSTR s_szSlash			= _T("\\");

CBWizEnumItem::CBWizEnumItem(LPCTSTR szCLSID, LPCTSTR szDesc)
{
	m_strCLSID		= szCLSID;
	m_strDesc		= szDesc;
}

CBWizEnumItem::CBWizEnumItem()
{
	m_strCLSID		= _T("");
	m_strDesc		= _T("");
}


/////////////////////////////////////////////////////////////////////////////
//
// locally scoped functions
//
static BOOL GetCategoryDescription(LPCTSTR szCategory, CString* pstrDescription)
{
   //validate params
   ASSERT(NULL != szCategory && NULL != pstrDescription);
   if(NULL == szCategory || NULL == pstrDescription)
      return FALSE;

   // Open HKEY_CLASSES_ROOT\Component Categories\Category
   CRegLite regCategory;
   CString  strKey;
   strKey =  CBuilderWizardManager::szSysCompCatKey;
   strKey += s_szSlash;
   strKey += szCategory;
   if(!regCategory.Open(HKEY_CLASSES_ROOT, strKey))
      return FALSE;

   // get the description based on LCID
   strKey.Empty();
   strKey.Format(TEXT("%X"), GetThreadLocale());
   if(!regCategory.GetValue(strKey, pstrDescription))
   {
      // Get US version
      strKey.Empty();
      strKey.Format(TEXT("%X"), MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT));
      if(!regCategory.GetValue(strKey, pstrDescription))
         return FALSE;
   }
   ASSERT(!pstrDescription->IsEmpty());
   return (!pstrDescription->IsEmpty());
}

static BOOL GetCLSIDDescription(LPCTSTR szCLSID, CString* pstrDescription)
{
   //validate params
   ASSERT(NULL != szCLSID && NULL != pstrDescription);
   if(NULL == szCLSID || NULL == pstrDescription)
      return FALSE;

   // Open HKEY_CLASSES_ROOT\CSLID\{clsid}
   CRegLite regCategory;
   CString  strKey;
   strKey = s_szCLSID;
   strKey += s_szSlash;
   strKey += szCLSID;
   if(!regCategory.Open(HKEY_CLASSES_ROOT, strKey))
      return FALSE;

   // read in "" value
   if(!regCategory.GetValue(TEXT(""), pstrDescription))
   {
      //REVIEW(cgomes): Get US Version if Foreign Version failed!!
      return FALSE;
   }
   //cleanup
   ASSERT(!pstrDescription->IsEmpty());
   return (!pstrDescription->IsEmpty());
}

static HICON GetDefaultIcon(LPCTSTR szCLSID)
{
	//validate params
	ASSERT(NULL != szCLSID);
	if(NULL == szCLSID)
		return FALSE;
	
	// Now extract the Icon 
	CString strKey = _T("CLSID\\");
	strKey += szCLSID;
	strKey += _T("\\DefaultIcon");
	// Open Default Icon Key
	HKEY hKey;
	if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, strKey, 0, KEY_READ, &hKey))
		return NULL;
								
	// Alloc mem for icon path, and read it in
	DWORD 	dwLength = MAX_PATH;
	DWORD	dwType   = REG_SZ;
	CString strIcon;
	LPTSTR 	pszIcon  = strIcon.GetBuffer(dwLength);
	DWORD 	regErr   = ::RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE)pszIcon, &dwLength);
	::RegCloseKey(hKey);
	hKey = NULL;
	if(regErr != ERROR_SUCCESS)
		return NULL;
	ASSERT(REG_SZ == dwType);
	ASSERT(dwLength);

	// Get Icon Index
	TCHAR *pch = _tcsrchr(pszIcon, _T(','));
	int nOffset = 0;
	if(pch)
	{
		pch[0] = _T('\0');
		nOffset = _ttoi(&pch[1]);
	}
	// Get small (16x16) icon
	HICON hIcon = NULL;
	::ExtractIconEx(pszIcon, nOffset, NULL, &hIcon, 1);
	ASSERT(hIcon != NULL);
	return hIcon;
}	

inline BOOL IsMetaCATID(CRegLite* pReg)
{
   ASSERT(NULL != pReg);
   return pReg->IsValueEqual(s_szSubKeyMetaCATID, s_szValueMetaCATID);
}

//UNDONE$: Move this func to bwizmgr.cpp
extern BOOL IsMetaCATID(HKEY hCATID)
{
   ASSERT(NULL != hCATID);
   if(NULL == hCATID)
      return FALSE;

   CRegLite regCATID;
   if(regCATID.SetHKEY(hCATID))
      return IsMetaCATID(&regCATID);

   return FALSE;
}

static BOOL IsCategory(LPCTSTR szCategory)
{
	ASSERT(NULL != szCategory);

	// Open HKEY_CLASSES_ROOT\Component Categories\Category
	CRegLite regCategory;
	CString  strKey;
	strKey =  CBuilderWizardManager::szSysCompCatKey;
	strKey += s_szSlash;
	strKey += szCategory;
	return regCategory.Open(HKEY_CLASSES_ROOT, strKey);
}


/////////////////////////////////////////////////////////////////////////////
//
// CRegLite implementation
//
CRegLite::CRegLite()
{
   m_hKey             = NULL;
   m_cbSubKeys        = 0;
   m_cbMaxSubKeyName  = 0;
   m_cbMaxClassName   = 0;
   m_cbValues         = 0;
   m_cbMaxValueName   = 0;
   m_cbMaxValueData   = 0;
   m_fFreeKey         = FALSE;
}

CRegLite::~CRegLite()
{
   if(m_fFreeKey && NULL != m_hKey)
      Close();
   m_hKey             = NULL;
   m_cbSubKeys        = 0;
   m_cbMaxSubKeyName  = 0;
   m_cbMaxClassName   = 0;
   m_cbValues         = 0;
   m_cbMaxValueName   = 0;
   m_cbMaxValueData   = 0;
}

BOOL  CRegLite::InitData()
{
   ASSERT(NULL != m_hKey);
   if(ERROR_SUCCESS != ::RegQueryInfoKey(m_hKey, NULL, NULL, NULL,
                           &m_cbSubKeys, &m_cbMaxSubKeyName,
                           &m_cbMaxClassName, &m_cbValues,
                           &m_cbMaxValueName, &m_cbMaxValueData, NULL, NULL))
   {
      ASSERT(FALSE);
      Close();
      return FALSE;
   }
   return TRUE;
}

BOOL  CRegLite::Open(HKEY hParent, LPCTSTR szSubKey)
{
   // validate params
   ASSERT(NULL != hParent && NULL != szSubKey);
   if(NULL == hParent || NULL == szSubKey)
      return FALSE;

   // close existing key, if any
   if(m_hKey)
      Close();

   if(ERROR_SUCCESS != ::RegOpenKeyEx(hParent, szSubKey, 0, KEY_READ, &m_hKey))
      return FALSE;
   ASSERT(NULL != m_hKey);

   // set flag to free the key
   m_fFreeKey = TRUE;

   // Init Reg Class
   return InitData();
}

void CRegLite::Close()
{
   // free the key only if flag is set, and key is valid
   if(m_fFreeKey && NULL != m_hKey)
      ::CloseHandle(m_hKey);

   m_hKey      = NULL;
   m_fFreeKey  = FALSE;
}

BOOL CRegLite::SetHKEY(HKEY hKey)
{
   //validate params
   ASSERT(NULL != hKey);
   if(NULL == hKey)
      return FALSE;

   // close existing key, if any
   ASSERT(NULL == m_hKey);
   if(NULL != m_hKey)
      Close();

   // Init Reg Class
   m_hKey = hKey;
   m_fFreeKey = FALSE; // Clear Flag: DONT FREE the KEY
   return InitData();
}

BOOL CRegLite::GetValue(LPCTSTR szSubKey, CString* pstrData)
{
   // validate params
   ASSERT(NULL != szSubKey && NULL != pstrData);
   if(NULL == szSubKey || NULL == pstrData)
      return FALSE;

   // check key
   ASSERT(NULL != m_hKey);
   if(NULL == m_hKey)
      return FALSE;

   // calc size & alloc buffer for data
   DWORD cbData = m_cbMaxValueData + sizeof(TCHAR);
   BYTE* pbData = new BYTE[ cbData ];

   //read value
   DWORD dwType = REG_SZ;
   if(ERROR_SUCCESS != ::RegQueryValueEx(m_hKey, szSubKey, NULL, &dwType,
                                            pbData, &cbData))
   {
      delete [] pbData;
      return FALSE;
   }
   //return data
   ASSERT((cbData <= m_cbMaxValueData + sizeof(TCHAR)) && dwType == REG_SZ);
   *pstrData = (LPTSTR) pbData;
   //cleanup
   delete []pbData;
   return TRUE;
}

BOOL CRegLite::IsValueEqual(LPCTSTR szSubKey, LPCTSTR szValue)
{
   ASSERT(NULL != szSubKey || NULL != szValue);
   if(NULL == szSubKey || NULL == szValue)
      return FALSE;

   // get the data to compare with
   CString strData;
   if(!GetValue(szSubKey, &strData))
      return FALSE;

   // return result of Comparing Data and value
   return (!strData.CompareNoCase(szValue));
}

/////////////////////////////////////////////////////////////////////////////
// CTreeLite implementation

CTreeLite::CTreeLite()
{
   m_hWnd         = NULL;
   m_cbMaxImages  = 0;
   m_fInitialized = FALSE;
}

CTreeLite::~CTreeLite()
{
   m_hWnd         = NULL;
   m_cbMaxImages  = 0;
   if(m_fInitialized)
      m_iml.DeleteImageList();
}

BOOL CTreeLite::SetTreeCtrl(HWND hwndDlg, int nIDDlgItem)
{
   ASSERT(NULL != hwndDlg);
   if(NULL == hwndDlg)
      return FALSE;
   
   // get hwnd of TreeCtrl   
   m_hWnd = ::GetDlgItem(hwndDlg, nIDDlgItem);
   ASSERT(NULL != m_hWnd);
   if(NULL == m_hWnd)
      return FALSE;
   
   // create image list
   if(!m_iml.Create(::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON), 
                   TRUE, m_cbMaxImages, 0))
   {
      ASSERT(!TEXT("ImageList Create Failed"));
      m_hWnd = NULL;
      return FALSE;
   }
 
   // imagelist for tree ctrl
   TreeView_SetImageList(m_hWnd, m_iml.GetSafeHandle(), TVSIL_NORMAL);
 
   m_fInitialized = TRUE;
   return TRUE;
}

BOOL CTreeLite::AddIconImage(UINT uiResource)
{
	//LoadIcon does not require DestroyIcon in Win32
	//Load icon to be added to image list
	HICON hIcon = AfxGetApp()->LoadIcon(uiResource);
	ASSERT(NULL != hIcon);
	if(NULL == hIcon)
		return FALSE;
	//Add icon to image list	
	return (-1 != m_iml.Add(hIcon));
}

int CTreeLite::AddIconImage(HICON hIcon)
{
	ASSERT(NULL != hIcon);
	if(NULL == hIcon)
		return -1;
	//Add icon to image list	
	return m_iml.Add(hIcon);
}


int CTreeLite::GetImageCount()
{
   // validation
   ASSERT(m_fInitialized);
   if(m_fInitialized)
      return m_iml.GetImageCount();
   return 0;   
}

HTREEITEM CTreeLite::GetFirstVisible()
{
   // validation
   ASSERT(m_fInitialized);
   if(!m_fInitialized)
      return NULL;
      
   return TreeView_GetFirstVisible(m_hWnd);
}

HTREEITEM CTreeLite::GetNextVisible(HTREEITEM hti)
{
   // validation
   ASSERT(m_fInitialized && NULL != hti);
   if(!m_fInitialized || NULL == hti)
      return NULL;
   
   return TreeView_GetNextVisible(m_hWnd, hti);
}

LPARAM CTreeLite::GetItemData(HTREEITEM hti)
{
   // validation
   ASSERT(m_fInitialized && NULL != hti);
   if(!m_fInitialized || NULL == hti)
      return NULL;
      
   TV_ITEM  tvi;
   tvi.mask    = TVIF_PARAM;
   tvi.hItem   = hti;
   if(TreeView_GetItem(m_hWnd, &tvi))
      return tvi.lParam;
   return NULL;   
}

void CTreeLite::SelectItem(HTREEITEM hti)
{
   // validation
   ASSERT(m_fInitialized);
   if(m_fInitialized)
      TreeView_SelectItem(m_hWnd, hti);
}

HTREEITEM CTreeLite::GetRoot()
{
   // validation
   ASSERT(m_fInitialized);
   if(!m_fInitialized)
      return FALSE;
   
   return TreeView_GetRoot(m_hWnd);
}

HTREEITEM CTreeLite::GetSelectedItem()
{
   // validation
   ASSERT(m_fInitialized);
   if(!m_fInitialized)
      return FALSE;
   
   return TreeView_GetSelection(m_hWnd);
}

HTREEITEM CTreeLite::InsertItem(TV_INSERTSTRUCT* ptvis)
{
   // validation
   ASSERT(m_fInitialized);
   if(!m_fInitialized)
      return FALSE;

   return TreeView_InsertItem(m_hWnd, ptvis);
}

inline BOOL CTreeLite::Expand(HTREEITEM hti)
{
   // validation
   ASSERT(m_fInitialized && NULL != hti);
   if(!m_fInitialized || NULL == hti)
      return NULL;
   
   return TreeView_Expand(m_hWnd, hti, TVE_EXPAND);
}

/////////////////////////////////////////////////////////////////////////////
// CBldWizSelectDlg dialog

CBldWizSelectDlg::CBldWizSelectDlg(CWnd* pParent /*=NULL*/)
   : C3dDialog(CBldWizSelectDlg::IDD, pParent)
{
   //{{AFX_DATA_INIT(CBldWizSelectDlg)
   //}}AFX_DATA_INIT
   // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
   m_clsidSel  = CLSID_NULL;
   m_cBuilders = 0;
}

CBldWizSelectDlg::~CBldWizSelectDlg()
{
   return;
}

BOOL CBldWizSelectDlg::SetCATID(HKEY hKey)
{ 
   ASSERT(NULL != hKey);
   if(NULL == hKey)
      return FALSE;
   return m_regCATID.SetHKEY(hKey);
}

BOOL CBldWizSelectDlg::InitTreeCtrl(void)
{
   // Init TreeLite and add images
   m_tree.SetMaxImages(NUM_IMAGES);
   if(m_tree.SetTreeCtrl(m_hWnd, IDC_BWIZ_TREE) &&
      // IDI_BUILDER == IMAGE_BUILDER == 0 == First Image
      m_tree.AddIconImage(IDI_BUILDER) &&
      // IDI_CATEGORY == IMAGE_CATEGORY == 1 == Second Image
      m_tree.AddIconImage(IDI_CATEGORY))
   {
      ASSERT(NUM_IMAGES == m_tree.GetImageCount());
      return TRUE;
   }
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CBldWizSelectDlg message map

BEGIN_MESSAGE_MAP(CBldWizSelectDlg, C3dDialog)
   //{{AFX_MSG_MAP(CBldWizSelectDlg)
   ON_NOTIFY(TVN_SELCHANGED, IDC_BWIZ_TREE, OnSelchangedSeltree)
   ON_NOTIFY(NM_DBLCLK, IDC_BWIZ_TREE, OnDblclkSeltree)
   ON_NOTIFY(TVN_DELETEITEM, IDC_BWIZ_TREE, OnDeleteItemSeltree)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CBldWizSelectDlg message handlers

BOOL CBldWizSelectDlg::OnInitDialog()
{
	C3dDialog::OnInitDialog();

	///////////////////////////////////
	// must build this key ourselves.  we can not use theApp.GetRegistryKeyName()
	// as this builds a key that takes into account the /i switch.  since these
	// settings are in HKLM and /i is an HKCU setting, we would end up with 
	// a bogus HKLM path.
	// CString strDevCompCat = GetRegistryKeyName();
	// strDevCompCat += s_szSlash;
	// strDevCompCat += CBuilderWizardManager::szSysCompCatKey;
	CString strDevCompCat;
	strDevCompCat =  g_szKeyRoot;
	strDevCompCat += s_szSlash;
	strDevCompCat += g_szCompanyName;
	strDevCompCat += s_szSlash;
	strDevCompCat += theApp.GetExeString(DefaultRegKeyName);
	strDevCompCat += s_szSlash;
	strDevCompCat += CBuilderWizardManager::szSysCompCatKey;
	
	if(!m_regDevCompCat.Open(HKEY_LOCAL_MACHINE, strDevCompCat) || !InitTreeCtrl())
	{
		ASSERT(!_T("m_regDevCompCat.Open(HKEY_LOCAL_MACHINE, strDevCompCat)"));
		::AfxMessageBox(IDS_MISSINGWIZARD);
		EndDialog(-1);
		return TRUE;
	}

	// Add the items to the TreeCtrl   
	// Add Meta Category will do the right thing for Cateories and Meta Categories
	AddMetaCategory(&m_regCATID);

	//check if any builders added
	// If no builders being displayed then cancel the dialog
	if (0 == m_cBuilders)
	{
#if defined _DEBUG
		::AfxMessageBox(_T("CBldWizSelectDlg::OnInitDialog(No Builders found in Category)"));
#endif
		::AfxMessageBox(IDS_MISSINGWIZARD);
		EndDialog(-1);
		return TRUE;
	}

	// Select Root Item
	m_tree.SelectItem(m_tree.GetRoot());
   
	return TRUE;
}

void CBldWizSelectDlg::OnOK()
{
   LPTSTR      szCLSID;
   HTREEITEM   hItem = m_tree.GetSelectedItem();
   ASSERT(NULL != hItem);

   //get string CLSID from lParam, and convert to CLSID
   USES_CONVERSION;
   if(NULL != hItem && (szCLSID = (LPTSTR)m_tree.GetItemData(hItem)))
      ::CLSIDFromString(T2OLE(szCLSID), &m_clsidSel);

   //cleanup
   C3dDialog::OnOK();
}

void CBldWizSelectDlg::OnDblclkSeltree(NMHDR* pNMHDR, LRESULT* pResult)
{
	// validate parameters
	ASSERT(NULL != pNMHDR && NULL != pResult);
	if(NULL == pNMHDR || NULL == pResult)
		return;
	*pResult = 0; // allow expansion for Catid double click

	HTREEITEM hti = m_tree.GetSelectedItem();
	ASSERT(hti != NULL);
	if(hti == NULL)
		return;
		
	// Check if double clicked on a builder	
	if(m_tree.GetItemData(hti))
	{
		*pResult = 1; // dis-allow expansion
		// Simulate btnOK Click
		OnOK();
	}
}

void CBldWizSelectDlg::OnSelchangedSeltree(NMHDR* pNMHDR, LRESULT* pResult)
{
   // validate parameters
   ASSERT(NULL != pNMHDR && NULL != pResult);
   if(NULL == pNMHDR || NULL == pResult)
      return;
   *pResult = 0;
   
   // Enable OK button only when selecting a builder
   NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   ASSERT(NULL != pNMTreeView->itemNew.hItem);
   ::EnableWindow(::GetDlgItem(m_hWnd, IDOK), pNMTreeView->itemNew.hItem && 
                        m_tree.GetItemData(pNMTreeView->itemNew.hItem));
}

void CBldWizSelectDlg::OnDeleteItemSeltree(NMHDR* pNMHDR, LRESULT* pResult)
{
   // validate parameters
   ASSERT(NULL != pNMHDR && NULL != pResult);
   if(NULL == pNMHDR || NULL == pResult)
      return;
   *pResult = 0;
   
   // Enable OK button only when selecting a builder
   NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   ASSERT(NULL != pNMTreeView->itemOld.hItem || NULL != pNMTreeView->itemOld.lParam);
   if(pNMTreeView->itemOld.hItem && pNMTreeView->itemOld.lParam)
   {
      delete (LPTSTR)pNMTreeView->itemOld.lParam;
#if defined _DEBUG
      // decrecment # of builders, this should be 0 when finally done
      --m_cBuilders;
#endif
   }
}

HTREEITEM CBldWizSelectDlg::DisplayBuilder
(
   LPCTSTR        szCLSID,
   HTREEITEM      hParent
)
{
	ASSERT(NULL != szCLSID);

	CString strDescription;
	if(!GetCLSIDDescription(szCLSID, &strDescription))
	{
		TRACE("GetCLSIDDescription(%s) failed", szCLSID);
		return NULL;
	}
	
	// Get Default Icon & Add it to ImageList
	int  	nImageIndex = IMAGE_BUILDER;
	HICON	hIcon = GetDefaultIcon(szCLSID);
	if(hIcon != NULL)
	{
		// Add icon to ImageList for Treeview
		nImageIndex = m_tree.AddIconImage(hIcon);
		ASSERT(nImageIndex != -1);
		if(nImageIndex == -1)
			// Failed to add image, so set to Builder
			nImageIndex =  IMAGE_BUILDER;
	}
	
	// Taking advantage of the Default Behavior for Images.
	// By default item's image is the first image in the list
	// Our first image is IDI_BUILDER.
	TV_INSERTSTRUCT tvis;
	tvis.hParent		= hParent;
	tvis.hInsertAfter	= TVI_LAST;
	tvis.item.mask		= TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
	tvis.item.pszText	= (LPTSTR)(LPCTSTR)strDescription;
	tvis.item.cchTextMax = strDescription.GetLength();
	tvis.item.lParam 	= (LPARAM)_tcsdup(szCLSID); // To be freed on Dialog exit
	tvis.item.iImage	= nImageIndex;
	tvis.item.iSelectedImage = nImageIndex;
	ASSERT(NULL != tvis.item.lParam);
	if(NULL == tvis.item.lParam)
		// out of memory
		return NULL;

	// Insert the Builder into dialog
	HTREEITEM hti = m_tree.InsertItem(&tvis);
	if(hti != NULL)
		//increment # of builders
		m_cBuilders++;

	return hti;
}

HTREEITEM CBldWizSelectDlg::DisplayCategory
(
	LPCTSTR		  szCategory,
	HTREEITEM		hParent
)
{
	ASSERT(szCategory != NULL);
	if(szCategory == NULL)
		return NULL;

	CString strDescription;
	if(!GetCategoryDescription(szCategory, &strDescription))
	{
		TRACE("GetCategoryDescription(%s) failed", szCategory);
		return NULL;
	}

	TV_INSERTSTRUCT tvis;
	tvis.hParent			= hParent;
	tvis.hInsertAfter	 = TVI_LAST;
	tvis.item.mask		 = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
	tvis.item.pszText	 = (LPTSTR)(LPCTSTR)strDescription;
	tvis.item.cchTextMax = strDescription.GetLength();
	tvis.item.iImage			= IMAGE_CATEGORY;
	tvis.item.iSelectedImage = IMAGE_CATEGORY;
	tvis.item.lParam	  = NULL;
	return m_tree.InsertItem(&tvis);
}

BOOL CBldWizSelectDlg::AddCategory(CRegLite* pReg, HTREEITEM htiParent /*=TV_ROOT*/)
{
	ASSERT(pReg != NULL);
	if(pReg == NULL || pReg->GetCbMaxSubKeyName() == 0)
		return FALSE;

	DWORD       nUnused;
	TCHAR*      pszSubKeyName = new TCHAR[ pReg->GetCbMaxSubKeyName()+1 ];
	DWORD       cSubKeys = pReg->GetCSubKeys();
	ASSERT(cSubKeys);

	for(DWORD nCnt = 0; nCnt < cSubKeys; ++nCnt)
	{
		nUnused = pReg->GetCbMaxSubKeyName();
		// if we can't enum the key, or we got back the
		// default component key, don't do anything
		if(ERROR_SUCCESS != ::RegEnumKeyEx(pReg->GetHandle(), nCnt, pszSubKeyName,
		                                   &nUnused, NULL, NULL, NULL, NULL))
			continue;

		// skip Default Component
		if(!lstrcmp(pszSubKeyName, _T("Default Component")))
			continue;
		 
		// Display the builder
		DisplayBuilder(pszSubKeyName, htiParent);
	} // for

	//cleanup
	delete [] pszSubKeyName;
	return TRUE;
}

BOOL CBldWizSelectDlg::AddMetaCategory(CRegLite* pReg, HTREEITEM htiParent /*=TV_ROOT*/)
{
	ASSERT(pReg != NULL);
	if(pReg == NULL)
		return FALSE;

	DWORD       nUnused;
	DWORD       cSubKeys = pReg->GetCSubKeys();
	TCHAR*      pszSubKeyName = new TCHAR[ pReg->GetCbMaxSubKeyName()+1 ];
	HTREEITEM   hti;
	CRegLite    regCATID;

	//REVIEW(cgomes): Check for loop in nested CATID
	for(DWORD nCnt = 0; nCnt < cSubKeys; ++nCnt)
	{
		nUnused = pReg->GetCbMaxSubKeyName();
		// if we can't enum the key, or we got back the
		// default component key, don't do anything
		if(ERROR_SUCCESS != ::RegEnumKeyEx(pReg->GetHandle(), nCnt, pszSubKeyName,
		                                  &nUnused, NULL, NULL, NULL, NULL))
			continue;
		
		// open the sub key within the current META Category
		if(!regCATID.Open(pReg->GetHandle(), pszSubKeyName))
			continue;
			
		if(IsCategory(pszSubKeyName))
		{
			// Display Category
			hti = DisplayCategory(pszSubKeyName, htiParent);
			if(hti == NULL)
				continue;
		}
		else
		{
			// Found builder so display it
			DisplayBuilder(pszSubKeyName, htiParent);
			// Builder is a leaf, so go to next sub key
			continue;
		}
		
		// Display contents of category.
		// Add Meta Category will do the right thing for Cateories and Meta Categories
		AddMetaCategory(&regCATID, hti);

		//expand category   
		m_tree.Expand(hti);
   } // for

   delete [] pszSubKeyName;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\btnctl.cpp ===
// btnctl.cpp : List control for dragging a button
//

#include "stdafx.h"
#include "btnctl.h"
#include "bardockx.h"
#include "prxycust.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CButtonDragListBox
//
// An almost-normal listbox which allows toolbar buttons to be dragged from it

IMPLEMENT_DYNAMIC(CButtonDragListBox, CListBox)

CButtonDragListBox::CButtonDragListBox()
{
}

CButtonDragListBox::~CButtonDragListBox()
{
}

BOOL CButtonDragListBox::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd,
	UINT nID)
{
	if (!CListBox::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	return TRUE;
}

BEGIN_MESSAGE_MAP(CButtonDragListBox, CListBox)
	//{{AFX_MSG_MAP(CButtonDragListBox)
	ON_WM_LBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CButtonDragListBox message handlers

void CButtonDragListBox::OnLButtonDown(UINT nFlags, CPoint point)
{
	CListBox::OnLButtonDown(nFlags, point);

	int nSel=GetCurSel();
	if(nSel!=LB_ERR)
	{
		// this is the command id
		int data=GetItemData(nSel);

		ASSERT(CASBar::s_pCustomizer);

		if (CASBar::s_pCustomizer != NULL)
		{
			// ensure that the list box gets an lbutton up message
			SendMessage(WM_LBUTTONUP, nFlags, MAKELPARAM(point.x, point.y));

			// it's a menu
			if(data==cNextFreeMenu)
			{
				data=theCmdCache.GetNextFreeMenu();
			}

			// do the drag
			CPoint ptScreen=point;
			ClientToScreen(&point);
			theApp.DragCommandButton(ptScreen, data);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\barprxy.h ===
// barprxy.h
// The abstract base class for menu and toolbar proxies

#ifndef barprxy_h
#define barprxy_h

#define TBB_NIL         UINT(-1)

#define TBBS_HWND 0x04
#define TBBS_SIZABLE 0x08
#define TBBS_ENABLEWND 0x10

// When this flag is set, the button is drawn as a textual string. The string will be
// stored in the button extra data for that button. It will be drawn vertically
// if and only if the bar is in a docked, vertical situation. This follows the 
// conventions of current releases of Office 97. martynl 21Mar96
#define TBBS_TEXTUAL 0x20

// When this flag is set, the button is drawn using a custom bitmap. The bitmap will be 
// stored in the image well as usual. However, a second bitmap may be stored inside the
// TBBUTTON_EXTRA structure. In this case, the extra bitmap is the one that should be
// saved, and is in the other size with respect to the image well. If there is no bitmap
// inside the button extra structure, this implies that the bitmap in the well is the one to
// be saved and loaded.
// martynl 15Apr96
#define TBBS_CUSTOMBITMAP 0x40

// When this flag is set, the button is a menu. When pressed, it drops down the
// menu identified by the command id. Menus can have any kind of button. Mmenus will have a
// drop down arrow beside them, unless they are in the main menu bar.
// martynl 22Apr96
#define TBBS_MENU 0x80

// Paint this button "out," closer to the user.
#ifndef TBBS_EXTRUDED
#define TBBS_EXTRUDED 0x100
#endif

// When this flag is set, a button is drawn with a toolbar glyph. Most buttons will have this
// flag set, with the exception of buttons which are purely textual. TBBS_GLYPH is also set for hwnd
// buttons, unless their vertically docked view is text only. So TBBS_GLYPH can also be used to 
// indicate whether a space for the glyph has been reserved in the well. martynl 07Jun96
#define TBBS_GLYPH 0x200

// This flag causes a button to be invisible, unpressable, etc, etc, except in customisation mode
#define TBBS_INVISIBLE 0x400

// This flag is true when the text in a textual button is custom
#define TBBS_CUSTOMTEXT 0x800

enum GAP {
	gapNil,
	gapBefore,
	gapAfter,
	gapReplace };

enum BITMAPSOURCE
{
	cBitmapSourcePackage=0,    // revert to its default (package-supplied) bitmap
	cBitmapSourceCustom=1,     // use supplied custom glyph
	cBitmapSourceClipboard=2   // copy from clipboard
};

// this is used to describe what appearances a button can take
enum APPEARANCEOPTION
{
	cAppearanceCompulsory=0,
	cAppearanceOptional=1,
	cAppearanceForbidden=2
};

enum APPEARANCE {
	cAppearanceImageOnly=0, // these must stay in sync with the custom button dialog resource
	cAppearanceTextOnly=1,
	cAppearanceImageText=2
};

///////////////////////////////////////////////////////////////////////////////
// CToolBarProxy
// This class is the interface to a custom bar, either a CCustomBar, or a CBMenuPopup.
class CToolBarProxy
{
public:
	static CToolBarProxy* GetBarProxy(CObject* pBar);

// Proxy interface:
public:
	// Use these to work with the underlying "real" objects.
	virtual CWnd* GetWindow() = 0;
	void* GetRealObject()
		{ return this == NULL ? NULL : _GetRealObject(); }

	// "Bar" states.
    virtual BOOL IsInDialog() = 0;
	virtual UINT GetExpansionConstraint(const CRect &expand, ORIENTATION *orBar=NULL) = 0;
	virtual int GetCount() const = 0;
	virtual DWORD GetBarStyle() const = 0;
	virtual const CSize GetButtonSize() const = 0;
	virtual const CSize GetImageSize() const = 0;
	virtual HBITMAP GetImageWell(int nIndex) = 0;
	virtual int GetImageIndex(int nIndex) const = 0;
	// TRUE if this bar is using large buttons
	virtual BOOL HasLargeButtons() const=0;

	// Interact with items states.
	virtual UINT GetButtonStyle(int nIndex) const = 0;
	virtual BOOL IsStaticItem(int nIndex) = 0;
	virtual BOOL IsGapItem(int nIndex) = 0;
	virtual const CString& GetButtonText(int nIndex) const = 0;
	virtual HWND GetButtonControl(int nIndex) const = 0;
	virtual HBITMAP GetButtonImage(int nIndex) const = 0;
	virtual int GetButtonCmdID(int nIndex) = 0;
	virtual void SetButtonControl(int nIndex, HWND hControl) = 0;
	virtual void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const = 0;
	virtual void GetButtonInfoEx(int nIndex, HWND& hControl, CString& rText, HBITMAP& hImage) const = 0;
	virtual BOOL HasExInfo(int nIndex) const = 0;
	// call this when the button has been modified to mark the bar dirty and possibly redraw (if bSized==TRUE)
	virtual void ButtonModified(int nIndex, BOOL bSized)=0;
	// Removes a separator before a button
	virtual void RemoveSeparator(int iButton)=0;
	// Inserts a separator before a button
	virtual void InsertSeparator(int iButton)=0;
	// returns true if the item is a control, and is currently visible
	virtual BOOL IsVisibleControl(int iButton)=0;
	// returns if the specified button can be shown with text
	virtual APPEARANCEOPTION CanText(int iButton)=0;
	// returns if the specified button can be shown with a glyph
	virtual APPEARANCEOPTION CanGlyph(int iButton)=0;
	// returns any limitations on the appearance of a given button style 
	virtual APPEARANCEOPTION CanText(UINT nStyle)=0;
	// returns any limitations on the appearance of a given button style
	virtual APPEARANCEOPTION CanGlyph(UINT nStyle)=0;
	// returns the appearance of a button
	virtual APPEARANCE GetAppearance(int iButton)=0;
	// returns the default appearance of a button
	virtual APPEARANCE GetAppearance()=0;
	// returns the appearance of a button of a given type when placed in this kind of container. If these display components
	// are not available, the custom button dialog will appear
	virtual APPEARANCE GetInitialAppearance(UINT nStyle)=0;
	// allocates or returns an individual glyph bitmap for a given button
	virtual HBITMAP CreateSingleBitmap(int iButton)=0;
	// always call this function if the one above returns non-null. Do not delete hbmSingle yourself, since it
	// may still be in use elsewhere
	virtual void DestroySingleBitmap(int iButton, HBITMAP hbmSingle)=0;
	
	// Operations
	virtual int InsertButton(int nIndex, TRANSFER_TBBUTTON& trans, BOOL bReplace, GAP gap) = 0;
	virtual void DeleteButton(int nIndex, BOOL bMoving = FALSE) = 0;
    virtual void RecalcLayout(UINT nHTSize = HTRIGHT) = 0;
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const = 0;
	// For a given point, returns the insert-after button for drag purposes.
	virtual int IndexFromPoint(const CPoint& pt, CRect *pButtonRect=NULL) const = 0;
	// Returns the index of the button hit, or -1 if none was hit. Does not return the HT_ codes used in cbmenu
	virtual int HitTest(CPoint point) const=0;
	virtual CToolBarProxy* NewBar(UINT nID, const CPoint& pt) = 0;
	virtual void GetButtonTransferInfo(int nIndex, DWORD& dwData, TRANSDATA_CALLBACK* lplpDataCallback) const = 0;
	virtual BOOL CanChooseAppearance() = 0;
	virtual BOOL CanPasteImage() = 0;
	virtual BOOL CanResetImage() = 0;
	virtual void PasteButtonImage() = 0;
	virtual void ResetButtonImage() = 0;
	virtual ORIENTATION GetOrient() const = 0;
	// adds text to the button
	virtual void AddText(int nIndex)=0; // default menu text
	virtual void AddText(int nIndex, const CString &text, BOOL bCustom)=0;
	// add or replace the bitmap of a button.
	virtual void AddBitmap(int nIndex, BITMAPSOURCE bsSource=cBitmapSourcePackage, HBITMAP hbmCustom=NULL)=0;
	// remove the label from a glyph+label button
	virtual void RemoveText(int nIndex)=0;
	// remove the glyph from a glyph+label button
	virtual void RemoveBitmap(int nIndex)=0;
	// remove all items from the bar
	virtual void Empty(void)=0;
	// expand a bar item if the being dragged command item is capable of being inserted into it
	virtual BOOL ExpandDestination(int nCmdIDSrc, int nIndexDest)=0;
	// returns the next visible item after the specified one. nIndex==-1 gets the first visible item
	virtual int FindNextVisibleItem(int nIndex, BOOL bForward)=0;

	// Batching operations for use during load and similar broad scope additive operations
	virtual void BatchBegin(int nCount=0)=0;
	virtual void BatchAdd(int nIndex, int nID, UINT nStyle, int nExtra, HBITMAP hGlyph, const CString &name)=0;
	virtual void BatchEnd()=0;

	// Notifications
	virtual void OnSelChange(int nIndex) = 0;
	virtual void OnDeleteSelection() = 0;
	virtual void OnBarActivate() = 0;
	virtual void OnButtonSize() = 0;
	virtual void OnButtonMove(int nIndex) = 0;

	// functions for reading and writing menus and toolbars
	BOOL SetData(HGLOBAL hglob);
	HGLOBAL GetData();
protected:
	virtual void* _GetRealObject() = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bwizdlg.h ===
// bwizdlg.h : header file
//
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CBWizEnumItem
class CBWizEnumItem
{
public:
	CBWizEnumItem(LPCTSTR szCLSID, LPCTSTR szDesc);
	CBWizEnumItem();

	CString m_strCLSID;
	CString m_strDesc;
};


/////////////////////////////////////////////////////////////////////////////
// Registry class
class CRegLite
{
private:
   HKEY  m_hKey;
   DWORD m_cbSubKeys;         // number of sub keys
   DWORD m_cbMaxSubKeyName;   // length of longest sub key name
   DWORD m_cbMaxClassName;    // length of longest class name
   DWORD m_cbValues;          // number of value entries
   DWORD m_cbMaxValueName;    // lenght of longest value name
   DWORD m_cbMaxValueData;    // lenght of longest value data
   BOOL  m_fFreeKey;          // Should I free the key on close?
   
public:
   CRegLite();
   ~CRegLite();

public:   
   BOOL     Open(HKEY hParent, LPCTSTR szSubKey);
   BOOL     GetValue(LPCTSTR szSubKey, CString* pstrData);
   BOOL     IsValueEqual(LPCTSTR szSubKey, LPCTSTR szValue);
   BOOL     SetHKEY(HKEY hKey);

   HKEY     GetHandle()          { return m_hKey; }; // close only if used SetHKEY
   DWORD    GetCSubKeys()        { return m_cbSubKeys; };
   DWORD    GetCbMaxSubKeyName() { return m_cbMaxSubKeyName + sizeof(TCHAR); };
   DWORD    GetCbMaxClassName()  { return m_cbMaxClassName + sizeof(TCHAR); };
   DWORD    GetCValues()         { return m_cbValues + sizeof(TCHAR); };
   DWORD    GetCbMaxValueName()  { return m_cbMaxValueName + sizeof(TCHAR); };
   DWORD    GetCbMaxValueData()  { return m_cbMaxValueData + sizeof(TCHAR); };

public:
   void     Close();
   
private:
   BOOL  InitData();
};

/////////////////////////////////////////////////////////////////////////////
// CTreeCtrl replacement class
//
class CTreeLite
{
private:
   HWND        m_hWnd;
   int         m_cbMaxImages;
   BOOL        m_fInitialized;
   CImageList  m_iml;
   
public:
   CTreeLite();
   ~CTreeLite();

public:   
   void  SetMaxImages(int cbImages) { m_cbMaxImages = cbImages; };
   BOOL  SetTreeCtrl(HWND hwndDlg, int iChildWindowID);
   BOOL  AddIconImage(UINT uiResource);
	int   AddIconImage(HICON hIcon);

public:   
   inline int        GetImageCount();
   inline HWND       GetHandle() { return m_hWnd; };
   inline HTREEITEM  GetFirstVisible();
   inline HTREEITEM  GetNextVisible(HTREEITEM hti);
   inline LPARAM     GetItemData(HTREEITEM hti);
   inline void       SelectItem(HTREEITEM hti);
   inline HTREEITEM  GetRoot();
   inline HTREEITEM  GetSelectedItem();
   inline HTREEITEM  InsertItem(TV_INSERTSTRUCT* tvis);
   inline BOOL       Expand(HTREEITEM hti);
};

/////////////////////////////////////////////////////////////////////////////
// CBldWizSelectDlg dialog

class CBldWizSelectDlg : public C3dDialog
{
// Construction
public:
   CBldWizSelectDlg(CWnd* pParent = NULL);   // standard constructor
   ~CBldWizSelectDlg();

// Dialog Data
   //{{AFX_DATA(CBldWizSelectDlg)
   enum { IDD = IDD_BWIZ_ENUM };
   //}}AFX_DATA

   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CBldWizSelectDlg)
   //not using
   //}}AFX_VIRTUAL

// Implementation
protected:

   // Generated message map functions
   //{{AFX_MSG(CBldWizSelectDlg)
   virtual BOOL OnInitDialog();
   virtual void OnOK();
   afx_msg void OnDblclkSeltree(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnDeleteItemSeltree(NMHDR* pNMHDR, LRESULT* pResult);
   afx_msg void OnSelchangedSeltree(NMHDR* pNMHDR, LRESULT* pResult);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

private:
   BOOL        m_fInitialized;   // Indicates if Dialog initialized properly
   CRegLite    m_regCATID;       // reg for CATID
   CRegLite    m_regDevCompCat;  // reg for Developer Hive
   int         m_cBuilders;      // # of builders
   CTreeLite   m_tree;
   
public:
   CLSID       m_clsidSel;       // Selected Builder's CLSID
   BOOL        SetCATID(HKEY hKey);

private:
   BOOL        InitTreeCtrl();
   BOOL        AddCategory(CRegLite* pReg, HTREEITEM htiParent=NULL);
   BOOL        AddMetaCategory(CRegLite* pReg, HTREEITEM htiParent=NULL);
   HTREEITEM   DisplayBuilder(LPCTSTR szCLSID, HTREEITEM hParent);
   HTREEITEM   DisplayCategory(LPCTSTR szCategory, HTREEITEM hParent);
};

//UNDONE$: Move this func to bwizmgr.cpp
extern BOOL IsMetaCATID(HKEY hCATID);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bwizmgr.h ===
/////////////////////////////////////////////////////////////////////////////
//	BWIZMGR.H
//		Defines the IBuilderWizardManager object 

#ifndef __BWIZMGR_H__
#define __BWIZMGR_H__

#include <ocdesign.h>
#include "ipcmpctr.h"

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

///////////////////////////////////////////////////////////////////////////////
// CBuilderWizardManager
//
class CBuilderWizardManager : public CCmdTarget
{
	DECLARE_DYNAMIC(CBuilderWizardManager);

public:
	CBuilderWizardManager();
	virtual ~CBuilderWizardManager();

protected:
	BOOL DoesDevCategoryExist(LPCTSTR szCategory, HKEY *pKeyOut = NULL);

#if _DEBUG
// enusure that the system compcat registry entries
// have been properly setup
	BOOL DoesSysCategoryExist(LPCTSTR szCategory);
#endif

	BOOL GetDefaultCompCatCLSID(HKEY hCATIDKey, CLSID *pclsidBuilder);
	BOOL GetCompCatCLSID(HKEY hCATIDKey, 
					DWORD nKeyNumber, CLSID *pclsidBuilder);

        
// Interface Maps   
protected:
	// ITrackSelection
	BEGIN_INTERFACE_PART(BuilderWizardManager, IBuilderWizardManager)
		INIT_INTERFACE_PART(CBuilderWizardManager, BuilderWizardManager)
        STDMETHOD(DoesBuilderExist)(REFGUID rguidBuilder);
        STDMETHOD(MapObjectToBuilderCLSID)(REFCLSID rclsidObject, 
					DWORD dwPromptOpt, HWND hwndOwner, 
					CLSID *pclsidBuilder);
        STDMETHOD(MapBuilderCATIDToCLSID)(REFGUID rguidBuilder, 
					DWORD dwPromptOpt, HWND hwndOwner, 
					CLSID *pclsidBuilder);
		STDMETHOD(GetBuilder)(REFGUID rguidBuilder, DWORD grfGetOpt, 
					HWND hwndPromptOwner, IDispatch **ppdispApp,
					HWND *pwndBuilderOwner, REFIID riidBuilder, 
					IUnknown **ppunkBuilder);
		STDMETHOD(EnableModeless)(BOOL fEnable);
	END_INTERFACE_PART(BuilderWizardManager)

	DECLARE_INTERFACE_MAP()

public:
	static TCHAR *szSysCompCatKey;
};

///////////////////////////////////////////////////////////////////////////////
// CIPCompBuilderWizardManager
//
class CIPCompBuilderWizardManager : public CCmdTarget
{
	DECLARE_DYNAMIC(CIPCompBuilderWizardManager);

public:
	CIPCompBuilderWizardManager(CIPCompContainerItem *pItem);
	virtual ~CIPCompBuilderWizardManager();

// Interface Maps   
protected:
	// ITrackSelection
	BEGIN_INTERFACE_PART(IPCompBuilderWizardManager, IBuilderWizardManager)
		INIT_INTERFACE_PART(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
        STDMETHOD(DoesBuilderExist)(REFGUID rguidBuilder);
        STDMETHOD(MapObjectToBuilderCLSID)(REFCLSID rclsidObject, 
					DWORD dwPromptOpt, HWND hwndOwner, 
					CLSID *pclsidBuilder);
        STDMETHOD(MapBuilderCATIDToCLSID)(REFGUID rguidBuilder, 
					DWORD dwPromptOpt, HWND hwndOwner, 
					CLSID *pclsidBuilder);
		STDMETHOD(GetBuilder)(REFGUID rguidBuilder, DWORD grfGetOpt, 
					HWND hwndPromptOwner, IDispatch **ppdispApp,
					HWND *pwndBuilderOwner, REFIID riidBuilder,
					IUnknown **ppunkBuilder);
		STDMETHOD(EnableModeless)(BOOL fEnable);
	END_INTERFACE_PART(IPCompBuilderWizardManager)

	DECLARE_INTERFACE_MAP()

protected:
	COleRef<IBuilderWizardManager>	 m_srpBuilderWizardManager;
	CIPCompContainerItem			*m_pContainerItem;
};

#ifdef _DEBUG
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#undef AFX_DATA
#define AFX_DATA NEAR

#endif		// __BWIZMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cbitem.cpp ===
#include "stdafx.h"
#include "shlmenu.h"

#include "barglob.h"
#include "shlbar.h"

#include <winuser.h> // Required to get menu font with NONCLIENTMETRICS 
//OEMRESOURCE must be defined in stdafx.h to get OBM_* bitmaps.

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Statics
//
CBitmap CBMenuItem::s_bmpCheckMark;
CSize CBMenuItem::s_sizeCheckMark ;

CBitmap CBMenuItem::s_bmpArrow ;
CSize CBMenuItem::s_sizeArrow ;
CSize CBMenuItem::s_sizeCmdGlyph;

//
//
//
const int c_iSeparatorHeight = 8 ;

//
//
//
void CBMenuItem::Release()
{
   delete this;
}


//
//
//
CBMenuItem::CBMenuItem()
:  m_bSelected(FALSE),
   m_bChecked(FALSE),
   m_bGrayed(FALSE),
   m_bTransient(FALSE),
   m_bDefault(FALSE),
   m_pMenuWnd(NULL),
   m_nCmdID(0),
   m_iItemType(MIT_Unknown),
   m_pMenuPopup(NULL),
   m_bExpanded(FALSE),
   m_bVisible(TRUE),
   m_hbmCmdGlyph(NULL), 
   m_hbmOriginalGlyph(NULL), 
   m_bCustomGlyph(FALSE),
   m_bCustomText(FALSE),
   m_bNeedToCalculateSizes(TRUE),
   m_bTextModified(FALSE),
   m_pCTE(NULL)
{

   for (int i = 0 ; i < c_iNumFields ; i++)
   {
      m_rectFields[i].SetRectEmpty() ;
   }

   Updated(TRUE) ;
}


//
//
//
CBMenuItem::~CBMenuItem()
{
      if (m_pMenuPopup != NULL)
      {
         ASSERT(m_iItemType == MIT_Popup) ;
		 if(m_pMenuPopup &&
			 !m_pMenuPopup->IsDropDown())
		 {
			delete m_pMenuPopup ;
		 }
      }

      if (m_hbmCmdGlyph != NULL)
      {
		  ::DeleteObject(m_hbmCmdGlyph);
      }

      if (m_hbmOriginalGlyph != NULL)
      {
		  ::DeleteObject(m_hbmOriginalGlyph);
      }
}


//
// Sync -	Forces a recalc of the size of the item.
//			Required because the cmd gylphs may have changed sizes.
//			
//
void CBMenuItem::Sync()
{

	  //
	  // TODO: These lines are in three places. Collapse.
      if ((m_iItemType == MIT_Separator) || //Separator
      (!m_bVisible || m_strName.IsEmpty()))
	  {
		  //Sizes are not recalculated if this item is a separator, or there
		  // isn't a name.
		  return ;
	  }


	 // Recalc the size.
	  CalcSizes(NULL) ;

	  // Get the bitmap glyph again.
	  UpdateGlyph() ;
}

// helper function during creation
// This routine assumes that hbmSource can be usurped by us, unless bMustCopy is true
void CBMenuItem::SetGlyph(HBITMAP hbmSource, int nIndex, BOOL bMustCopy, BOOL bCustom)
{
	CSize sizeCmdBitmap = CCustomBar::GetDefaultBitmapSize(globalData.GetLargeMenuButtons());

	BOOL bScale=FALSE;

	m_bCustomGlyph=bCustom;

	// altho bmpData is only inited inside this if, we assert later on to ensure no bad usage.
	BITMAP bmpData;

	// FUTURE: Could use GLOBAL_DATA::DuplicateBitmapSegment
	if(hbmSource)
	{
		::GetObject(hbmSource, sizeof(BITMAP), &bmpData);

		if(	sizeCmdBitmap.cy!=bmpData.bmHeight)
		{
			bScale=TRUE;
		}
	}

	// Delete the bitmap if it already exists.
	if (m_hbmCmdGlyph != NULL)
	{
		::DeleteObject(m_hbmCmdGlyph);
	}

	if(!bScale && !bMustCopy)
	{
		m_hbmCmdGlyph=hbmSource;
	}
	else
	{
		ASSERT(hbmSource);
		// need to either copy or scale
		CClientDC dc(AfxGetMainWnd() /*Window not yet created pMenuWnd*/) ;
		CDC dcSrc ;                // Set up the source bitmap/dc.
		dcSrc.CreateCompatibleDC(&dc) ;
		CBitmap* pbmpSrc = CBitmap::FromHandle(hbmSource);
		CBitmap* pOldBmpSrc = (CBitmap*)dcSrc.SelectObject(pbmpSrc) ;

		CDC dcDest ;            // Set up the dest bitmap/dc.
		dcDest.CreateCompatibleDC(&dc) ;

		if(bScale)
		{
			// Delete the bitmap if it already exists.
			if (m_hbmOriginalGlyph != NULL)
			{
				::DeleteObject(m_hbmOriginalGlyph);
			}

			if(!bMustCopy)
			{
				m_hbmOriginalGlyph=hbmSource;
			}
			else
			{
				// duplicate hbmSource
				m_hbmOriginalGlyph=GLOBAL_DATA::DuplicateBitmap(AfxGetMainWnd(), hbmSource);
			}
		}
		
		// Create a new bitmap.
		m_hbmCmdGlyph=::CreateBitmap(sizeCmdBitmap.cx, 
								sizeCmdBitmap.cy,
								dc.GetDeviceCaps(PLANES),
								dc.GetDeviceCaps(BITSPIXEL), NULL);
		CBitmap* pOldBmpDest = (CBitmap*)dcDest.SelectObject(CBitmap::FromHandle(m_hbmCmdGlyph)) ;

		if(bScale)
		{
			GLOBAL_DATA::ScaleBitmap(dcDest, sizeCmdBitmap, CPoint(sizeCmdBitmap.cx*nIndex, 0), hbmSource,  CSize(bmpData.bmWidth, bmpData.bmHeight));
		}
		else
		{
			// Blt to destination
			dcDest.BitBlt(0, 0, sizeCmdBitmap.cx, sizeCmdBitmap.cy,
						  &dcSrc, sizeCmdBitmap.cx * nIndex, 0, SRCCOPY);
		}

		// Cleanup.
		dcSrc.SelectObject(pOldBmpSrc) ;
		dcDest.SelectObject(pOldBmpDest);
	}
}

//
//
//
void CBMenuItem::UpdateGlyph()
{
	// MSL: Don't try to get glyph if it's a submenu, or if the glyph isn't system provided
	if(m_nCmdID!=0 && !m_bCustomGlyph)
	{
		int nGlyph;
		HBITMAP hbmWell;

		if(theApp.GetCommandBitmap(m_nCmdID, &hbmWell, &nGlyph, globalData.GetLargeMenuButtons(), m_pCTE))
		{
			SetGlyph(hbmWell, nGlyph, TRUE, FALSE);
		}
		else
		{
			// remove the glyph. Should never happen, but maybe the package changed its mind?
			SetGlyph(NULL, 0, FALSE, FALSE);
		}
	}
}

// removed cached sizes
void CBMenuItem::FlushSizeCache()
{
	s_sizeCmdGlyph=CSize(0,0);
	if (s_bmpCheckMark.m_hObject != NULL)
	{
		s_bmpCheckMark.DeleteObject();
	}
	if (s_bmpArrow.m_hObject != NULL)
	{
		s_bmpArrow.DeleteObject();
	}
}
// and recalculate them
void CBMenuItem::EnsureSizeCache()
{
   // Cache the checkmark bitmap
   BITMAP bm ;
   if (s_bmpCheckMark.m_hObject == NULL)
   {
      VERIFY(s_bmpCheckMark.LoadOEMBitmap(OBM_CHECK)) ;
      VERIFY(s_bmpCheckMark.GetObject(sizeof(BITMAP),(void*)&bm)) ;
      s_sizeCheckMark.cx = bm.bmWidth;
      s_sizeCheckMark.cy = bm.bmHeight;
   }
   ASSERT_VALID(&s_bmpCheckMark) ;

   if (s_bmpArrow.m_hObject == NULL)
   {
      VERIFY(s_bmpArrow.LoadOEMBitmap(OBM_MNARROW)) ;
      VERIFY(s_bmpArrow.GetObject(sizeof(BITMAP),(void*)&bm)) ;
      s_sizeArrow.cx = bm.bmWidth;
      s_sizeArrow.cy = bm.bmHeight;
   }
   ASSERT_VALID(&s_bmpArrow);

   if(s_sizeCmdGlyph.cx==0)
   {
	   s_sizeCmdGlyph=CCustomBar::GetDefaultBitmapSize(globalData.GetLargeMenuButtons());
	   // two for the 3d effect, plus one for pressing offset
	   s_sizeCmdGlyph.cx+=3;
	   s_sizeCmdGlyph.cy+=3;
   }
}

// Creation
//
//
//
BOOL CBMenuItem::Create(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName)
{
   ASSERT(pMenuWnd) ;
   ASSERT_VALID(pMenuWnd) ;
  // ASSERT(nCmdID != 0) ;

   // cache command table entry pointer
   if(nCmdID!=0)
   {
	   m_pCTE=theCmdCache.GetCommandEntry(nCmdID);
   }

   ParseOutAccelerator(strName) ;

   m_nCmdID = nCmdID ;
   m_pMenuWnd = pMenuWnd ;
   m_iItemType = MIT_Command ;

   // Get the glyph for this command
   UpdateGlyph() ;

   EnsureSizeCache();

   // copy transient flag from menu, or from command table
   m_bTransient=(CBMenuPopup::s_bCreateTransients || (m_pCTE && (m_pCTE->flags & CT_DYNAMIC)!=0));

   return TRUE ;
}

//
// Create a Popup
//
BOOL CBMenuItem::CreatePopup(CBMenuPopup* pMenuWnd, 
                        CBMenuPopup* pMenuPopup, 
                        CString strName)
{
   if (Create(pMenuWnd, (UINT)NULL, strName))
   {
      m_iItemType = MIT_Popup ;
      m_pMenuPopup = pMenuPopup ;
      return TRUE ;
   }
   return FALSE ;

}

//
// Create a Popup
//
BOOL CBMenuItem::CreatePopup(CBMenuPopup* pMenuWnd, 
                        UINT nCmdID, 
                        CString strName)
{
   if (Create(pMenuWnd, nCmdID, strName))
   {
      m_iItemType = MIT_Popup ;
      m_pMenuPopup = NULL ;
      return TRUE ;
   }
   return FALSE ;

}

// Creation for a menu item whose type is determined by the global command table
// This routine assumes that hbmCustom can be usurped by us
BOOL CBMenuItem::CreateDynamic(CBMenuPopup* pMenuWnd, UINT nCmdID, CString strName,  BOOL bShowGlyph, HBITMAP hbmCustom)
{
	m_pCTE=theCmdCache.GetCommandEntry(nCmdID);
	
	// If the caller didn't provide a name, use the one in the command table. Menu entries have to have a name.
	if(	strName.IsEmpty() &&
		m_pCTE)
	{
		LPCTSTR pText=NULL;
		theCmdCache.GetCommandString(nCmdID, STRING_MENUTEXT, &pText);
		strName=pText;
	}

	if(	m_pCTE &&
		m_pCTE->flags & CT_MENU)
	{
		if(!CreatePopup(pMenuWnd, nCmdID, strName))
		{
			return FALSE;
		}
	}
	else
	{
		if(!Create(pMenuWnd, nCmdID, strName))
		{
			return FALSE;
		}
	}
	if(!bShowGlyph)
	{
		// Delete the bitmap if it already exists.
		if (m_hbmCmdGlyph != NULL)
		{
			::DeleteObject(m_hbmCmdGlyph);
		}
	}
	else
	{
		if(hbmCustom)
		{
			SetGlyph(hbmCustom, 0,FALSE, TRUE);
		}
	}
	return TRUE;
}

//
//
//
BOOL CBMenuItem::CreateSeparator()
{
   m_iItemType = MIT_Separator ; 
   return TRUE ;
}


//
// Attributes
//
//
//

void CBMenuItem::GetWidths(CDC* pdc, /*out*/ int** pWidths)
{
   if ((m_iItemType == MIT_Separator) || //Separator
       (!m_bVisible || m_strName.IsEmpty()))
   {	  
	   // TODO : Optomize this out.
      for (int i = 0 ; i < c_iNumFields ; i++)
      {
         m_iFieldWidths[i] = 0 ;
      }
   }
   else if (m_bNeedToCalculateSizes)
   {
	 CalcSizes(pdc) ;
   }
   *pWidths = m_iFieldWidths;
}

int CBMenuItem::GetHeight(CDC* pdc)
{
	if(!m_bVisible)
	{
		m_iHeight=0;
	}
	else if (m_iItemType == MIT_Separator)
	{
		m_iHeight = c_iSeparatorHeight ; //::GetSystemMetrics(SM_CYMENU) ; 
	}
	else if (m_strName.IsEmpty())
	{
		m_iHeight=0;
	}
	else if (m_bNeedToCalculateSizes)
	{
		CalcSizes(pdc) ;
	}
	return m_iHeight ;
}

//
// CalcSizes - Internal function used to cache the sizes of everything.
//
// If you do not have a CDC* pass NULL and CalcSizes will get its own DC.
//
void CBMenuItem::CalcSizes(CDC* pdc) 
{
	// In most cases, there will not be a window around
	// when we call this function. However, we still need a DC.
	// First, check to see if we do have a window. If not, use
	// the MainWnd.

	BOOL bDeleteDC = FALSE ;
	if (pdc == NULL)
	{
		CWnd* pWnd;
		if (m_pMenuWnd->GetSafeHwnd() == NULL)
		{
			pWnd = AfxGetMainWnd() ;
		}
		else
		{
			pWnd = m_pMenuWnd ;
		}
		pdc = new CClientDC(pWnd) ;
		bDeleteDC = TRUE ;
	}

   //
   // Calculate the size required by the menu string and the accelerator string.
   //
	
	// Select the Correct Font.
	CFont *pFont=globalData.GetMenuFont(m_bDefault);

  CFont* pOldFont = (CFont*)pdc->SelectObject(pFont) ;
  ASSERT(pOldFont) ;
  ASSERT_VALID(pOldFont) ;

  // Get the bounding box for the text by using DrawText.
  CRect rectName ;
  rectName.SetRectEmpty() ;
  pdc->DrawText( m_strName, &rectName, DT_EXTERNALLEADING | DT_CALCRECT | DT_LEFT | DT_EXPANDTABS | DT_SINGLELINE /*| DT_VCENTER*/);

  ASSERT(!rectName.IsRectEmpty()) ;
  ASSERT(!rectName.IsRectNull()) ;

  // Get the bounding box for the Accelerator.
  CRect rectAccel ;
  rectAccel.SetRectEmpty() ;
  if (!m_strAccel.IsEmpty())
  {
      pdc->DrawText( m_strAccel, &rectAccel, DT_EXTERNALLEADING | DT_CALCRECT | DT_LEFT | DT_EXPANDTABS | DT_SINGLELINE /*| DT_VCENTER*/);
      ASSERT(!rectAccel.IsRectEmpty()) ;
      ASSERT(!rectAccel.IsRectNull()) ;
  }

  // Cleanup
  if (pOldFont) pdc->SelectObject(pOldFont) ;


  //
  // We now have all the information we need to calculate the widths.
  //

   // Width for e_FieldAll
   m_iFieldWidths[e_FieldAll] = c_iFieldWidthUnknown ;

   // Width for e_FieldButton
   m_iFieldWidths[e_FieldButton] = s_sizeCmdGlyph.cx+1; // add one here, so that there's a 1 pixel gap between the 3d line and the blue area.

   // Width for the e_FieldName - Command Name
   m_iFieldWidths[e_FieldName] = rectName.Width() ;

   // Width for the e_FieldAccel 
   m_iFieldWidths[e_FieldAccel] = rectAccel.Width() ;


   // Width for e_FieldArrow - allow it to center in a broader area.
   m_iFieldWidths[e_FieldArrow] = s_sizeArrow.cx*2;

   // Width for e_FieldGap which is the widht of widest char.
  TEXTMETRIC tm ;
  pdc->GetOutputTextMetrics(&tm);
  m_iFieldWidths[e_FieldGap] = tm.tmMaxCharWidth;

  //
  // Now do the height
  //
  m_iHeight = ::GetSystemMetrics(SM_CYMENU) ;
  m_iHeight = max(m_iHeight, max(s_sizeCheckMark.cy,s_sizeArrow.cy)) ;
  m_iHeight = max(m_iHeight, max(s_sizeCmdGlyph.cy, rectName.Height())) ; // TODO: Vertical padding

  // Mark that we do not have to calculated the sizes now.
  m_bNeedToCalculateSizes = FALSE ;

  if (bDeleteDC)
  {
	  delete pdc ;
  }
}

//
// Operation
//
//
//
extern BOOL DrawButtonGlyph(CDC* pDC,
							int x, int y,
							CPoint ptOffset,
							int iImage,
							UINT nStyle,
							const SIZE& sizeButton,
							const SIZE& sizeImage,
							HDC hdcGlyphs,
							HDC hdcMono);
extern void CreateCmdBarButtonMask(int iImage,
								   CPoint ptOffset,
								   BOOL bHilite,
								   BOOL bShadow,
								   const SIZE& sizeButton,
								   const SIZE& sizeImage,
								   HDC hdcGlyphs,
								   HDC hdcMono);

void CBMenuItem::Draw(CDC* pdc, CRect rectFields[c_iNumFields]) 
{
	ASSERT_VALID(pdc) ;
	if (rectFields != NULL)
	{
		// DrawText Might Modify pRect...so save it.
		// Also need it for HitTest
		for(int i = 0 ; i < c_iNumFields ; i++)
		{
			m_rectFields[i] = rectFields[i];
		}
	}
	
	// Don't draw if its not visible.
	if(!m_bVisible || m_rectFields[e_FieldAll].IsRectEmpty() || m_rectFields[e_FieldAll].IsRectNull())
	{
		return;
	}
	
	// Separators are drawn with a different function.
	if (m_iItemType == MIT_Separator)
	{
		DrawSeparator(pdc, &m_rectFields[e_FieldAll]) ;
		return ;
	}
	
	
	// 
	COLORREF oldTextColor;
	// Normal and gray items have the same background color.
	COLORREF oldBkColor = pdc->SetBkColor(globalData.clrBtnFace);
	
	// grayed items can be drawn selected because the keyboard interface allows it.
	if (m_bSelected )
	{
		// The menu item is not drawn selected when it is gray.
		oldBkColor = pdc->SetBkColor(::GetSysColor(COLOR_HIGHLIGHT)) ;
		if(m_bGrayed)
		{
			oldTextColor = pdc->SetTextColor(::GetSysColor(COLOR_INACTIVECAPTIONTEXT)) ; // !!! reconsider? 
		}
		else
		{
			oldTextColor = pdc->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT)) ;
		}
	}
	else
	{
		// Normal items have black text. Grayed items don't
		oldTextColor = pdc->SetTextColor(globalData.clrBtnText) ;
	}
	
	//
	// Handle whole rectangle.
	//
	
	// Paint everything except the button area.
	CRect rectRightFields(m_rectFields[e_FieldAll]);
	rectRightFields.left += m_rectFields[e_FieldButton].Width();
	pdc->ExtTextOut(0,0,ETO_OPAQUE, &rectRightFields, NULL, 0, NULL) ;

	//
	// Paint the Text.
	//
	
	// Select the Font appropriate to the type of item
	CFont *pFont=globalData.GetMenuFont(m_bDefault);

	CFont* pOldFont = (CFont*)pdc->SelectObject(pFont) ;
	ASSERT_VALID(pOldFont) ;
	
	// Create a rectangle where text is painted.
	CRect rectText(m_rectFields[e_FieldName]);
	CRect rectAccel(m_rectFields[e_FieldAccel]);
	
	//   int iOldBkMode = pdc->SetBkMode(TRANSPARENT) ;
	
	UINT MenuTextFlags = GLOBAL_DATA::e_mtoLeftAlign ;
	if (m_bGrayed && !m_bSelected)
	{
		MenuTextFlags |= GLOBAL_DATA::e_mtoDisabled ;
	}
	
	// Comand Text
	globalData.MenuTextOut(pdc, &rectText, m_strName, MenuTextFlags) ;
	
	// Accelerator Text
	globalData.MenuTextOut(pdc, &rectAccel, m_strAccel, 
							MenuTextFlags | GLOBAL_DATA::e_mtoRightAlign) ;
	
	//
	// Setup for blting various bitmaps.
	//
	
	// Set up a memory DC
	CDC dcMem;
	dcMem.CreateCompatibleDC(pdc) ;
	CDC dcMono ;
	dcMono.CreateCompatibleDC(pdc);
	
	// Create an alias for m_rectFields[e_FieldButton];
	CRect* pRectButton = &m_rectFields[e_FieldButton] ;
	
	CBitmap bmMono;
	bmMono.CreateBitmap(pRectButton->Width(), pRectButton->Height() , 1, 1, NULL);
	CBitmap* pOldMonoBm = static_cast<CBitmap*>(dcMono.SelectObject(&bmMono));
	
	// Arrow for the popup...
	if (m_iItemType == MIT_Popup)
	{
		// Draw the Arrow
		CBitmap* pOldBitmap = (CBitmap*)dcMem.SelectObject(&s_bmpArrow) ;
		
		CRect rectArrow(m_rectFields[e_FieldArrow]);
		
		int left = rectArrow.left + (rectArrow.Width()-s_sizeArrow.cx)/2 ;
		int top  = rectArrow.top + (rectArrow.Height()-s_sizeArrow.cy)/2 ; //Center Bitmap

		if (m_bGrayed && !m_bSelected)
		{
			// Draw the arrow diabled with a shadow.
			DrawButtonGlyph(pdc, left, top,
							CPoint(0,0), 0, TBBS_DISABLED, 
							pRectButton->Size(), s_sizeArrow, 
							dcMem.m_hDC, dcMono.m_hDC);
		}
		else
		{
			// Put down the arrow...
			pdc->BitBlt(left, top, 										
						s_sizeArrow.cx, s_sizeArrow.cy, 
						&dcMem, 0, 0, SRCCOPY) ;

		}
		// Cleanup
		dcMem.SelectObject(pOldBitmap) ;
	}
	
	// Paint the background for the glyph area.
	pdc->FillSolidRect(&m_rectFields[e_FieldButton], globalData.clrBtnFace);
	
	// Draw the cmd glyph
	if (m_hbmCmdGlyph != NULL)
	{
		CRect rectGlyph=*pRectButton;

		// if it's taller than the width of the glyph, make it square
		if(rectGlyph.Height() > s_sizeCmdGlyph.cy)
		{
			rectGlyph.OffsetRect(0,(m_iHeight-s_sizeCmdGlyph.cy)/2);

			rectGlyph.bottom-=m_iHeight-s_sizeCmdGlyph.cy;
		}

		CBitmap* pOldBitmap = (CBitmap*)dcMem.SelectObject(CBitmap::FromHandle(m_hbmCmdGlyph)) ;
		
		if (m_bChecked ||
			(m_bSelected && !m_bGrayed))
		{
			COLORREF clrTopLeft;
			COLORREF clrBotRight;

			if(!m_bChecked)
			{
				// raised if unchecked
				clrTopLeft=globalData.clrBtnHilite;
				clrBotRight=globalData.clrBtnShadow;
			}
			else
			{
				// depressed if checked
				clrBotRight=globalData.clrBtnHilite;
				clrTopLeft=globalData.clrBtnShadow;
			}

			// We do not raise the bitmap if it is disabled.
			pdc->Draw3dRect(rectGlyph.left, rectGlyph.top,
							rectGlyph.Width(), rectGlyph.Height(),
							clrTopLeft, clrBotRight);
		}
		
		UINT nStyle=0;
		CPoint ptOffset(0,0);
		if(m_bGrayed) 
		{	
			nStyle |= TBBS_DISABLED;
		}
		
		if(m_bChecked) 
		{
			nStyle |= TBBS_CHECKED;
			if(m_bSelected)
			{
				nStyle|=TBBS_EXTRUDED;
			}
			ptOffset.x=1;
			ptOffset.y=1;
		}
		
		DrawButtonGlyph(pdc,	rectGlyph.left + 1, rectGlyph.top + 1, 
								ptOffset, 0, nStyle, rectGlyph.Size(),s_sizeCmdGlyph, dcMem.m_hDC, dcMono.m_hDC);
		
		dcMem.SelectObject(pOldBitmap) ;
	}
	else if (m_bChecked)
	{
		// Draw the CheckMark
		CBitmap* pOldBitmap = (CBitmap*)dcMem.SelectObject(&s_bmpCheckMark) ;
		CRect rcCheck(	pRectButton->left + (pRectButton->Width() - s_sizeCheckMark.cx) / 2 - 1,
						pRectButton->top + (pRectButton->Height() - s_sizeCheckMark.cy) / 2 - 1,
						0, 0);
		rcCheck.right = rcCheck.left + s_sizeCheckMark.cx + 2;
		rcCheck.bottom = rcCheck.top + s_sizeCheckMark.cy + 2;
		
		// Draw the border.
		pdc->Draw3dRect(rcCheck, globalData.clrBtnShadow, globalData.clrBtnHilite);
		rcCheck.InflateRect(-1, -1);
		
		if (!m_bSelected)
		{
			COLORREF crTxt = pdc->SetTextColor(globalData.clrBtnHilite);
			COLORREF crBk = pdc->SetBkColor(globalData.clrBtnFace);
			pdc->FillRect(rcCheck, CDC::GetHalftoneBrush());
			
			pdc->SetTextColor(crTxt);
			pdc->SetBkColor(crBk);
		}
		
		COLORREF crTxt = pdc->SetTextColor(RGB(0,0,0));
		COLORREF crBk = pdc->SetBkColor(RGB(255,255,255));
		
		// This works because the original bitmap is mono.
		pdc->BitBlt(rcCheck.left, rcCheck.top, s_sizeCheckMark.cx, s_sizeCheckMark.cy, &dcMem, 0, 0, SRCAND) ; 
		
		pdc->SetTextColor(crTxt);
		pdc->SetBkColor(crBk);
		
		dcMem.SelectObject(pOldBitmap) ;
	}
	else
	{
		if(m_bSelected)
		{
			pdc->FillSolidRect(pRectButton, ::GetSysColor(COLOR_HIGHLIGHT));
		}
	}
	
	// Cleanup 
	if (pOldFont) pdc->SelectObject(pOldFont) ;
	
	pdc->SetBkColor(oldBkColor);
	if (!m_bGrayed)
	{
		pdc->SetTextColor(oldTextColor) ;
	}
	if (pOldMonoBm)
		dcMono.SelectObject(pOldMonoBm);
}


//
//
//
//
//
//
void CBMenuItem::DrawSeparator(CDC* pdc, const CRect* pRect) 
{
   // Fill Rectangle
   pdc->FillSolidRect(pRect->left, pRect->top, pRect->Width()+1, pRect->Height()+1, globalData.clrBtnFace) ; // Does not fill right/bottom edge.

   // Dark Line on Top
   int y = pRect->top + pRect->Height()/2 ;
   pdc->FillSolidRect(pRect->left+2, y, pRect->Width()-4+1, 1, globalData.clrBtnShadow) ;
   // Hilite on bottom
   y++;
   pdc->FillSolidRect(pRect->left+2, y, pRect->Width()-4+1, 1, globalData.clrBtnHilite) ;
}
 

//
// Tests whether a given item is hit, given a scroll offset
//
BOOL CBMenuItem::HitTest(CPoint pt, int)
{
   return m_rectFields[e_FieldAll].PtInRect(pt);
}

//
//
//
UINT CBMenuItem::Click()
{
   if (m_iItemType == MIT_Separator)
   {
      return 0 ;
   }

   if (m_bGrayed)
      return 0;

   if (m_iItemType == MIT_Command)
   {
      if (m_nCmdID != 0)
      {
		   // send command
		   return m_nCmdID;
      }
   }
   /*
   else (m_iItemType == MIT_Popup)
   {
   }
   */
   return 0 ;
}

//
//
//
void CBMenuItem::Check(BOOL bChecked)
{
   ASSERT( m_iItemType != MIT_Separator) ;
   m_bChecked = bChecked;
}

///
//
//
UINT CBMenuItem::Enable(BOOL bEnable)
{ 
   UINT uResult = m_bGrayed ? MF_GRAYED : MF_ENABLED ;
   m_bGrayed = !bEnable;
   return uResult ;
}

//
//
//
BOOL CBMenuItem::Show(BOOL bShow)
{ 
   BOOL bResult = m_bVisible ;
   m_bVisible = bShow;
   return bResult ;
}

//
//
//
void CBMenuItem::SetText(LPCTSTR lpszText) 
{
   ASSERT( lpszText != NULL) ;
   if (lpszText != NULL)
   {
      // Separate the Accerlerator from the command name.
      ParseOutAccelerator(lpszText) ;

	  // Recalc the size.
	  CalcSizes(NULL) ;
	}
}

//
// This modifies the accelerator, and optionally recalcs. Normally this is called when
// the menus are being rebuilt during change of focus, in which case recalc is done at the end
// in one go.
//
void CBMenuItem::SetAccelerator(LPCTSTR lpszAccel, BOOL bRecalc) 
{
	if (lpszAccel != NULL)
	{
		m_strAccel = lpszAccel;
	}
	else
	{
		m_strAccel.Empty();
	}

	if(bRecalc)
	{
		// Recalc the size.
		CalcSizes(NULL);
	}
}

//
//
//
CBMenuPopup* CBMenuItem::Expand(BOOL bExpand) 
{
	if (m_iItemType != MIT_Popup)
	  return NULL ;

	if (m_bGrayed)
	  return NULL ;

	m_bExpanded = bExpand;
	if (m_bExpanded) 
	{
		// rectFields is only initialsed after a menu has been painted. So we must paint before we expand!
		if(m_pMenuWnd &&
			!m_pMenuWnd->IsPainted())
		{
			// do any pending update now
			m_pMenuWnd->UpdateWindow();
		}

		CPoint pt(m_rectFields[e_FieldAll].right, m_rectFields[e_FieldAll].top) ;
		m_pMenuWnd->ClientToScreen(&pt) ;
		if(m_pMenuPopup==NULL)
		{
			m_pMenuPopup=theCmdCache.GetMenu(m_nCmdID);
		}

		if(m_pMenuPopup)
		{	
			// submenu should avoid its parent item
			// Bug m_pMenuPopup->m_rectAvoid=m_rectFields[e_FieldAll];

			m_pMenuPopup->Create(m_pMenuWnd, pt, TRUE, &m_rectFields[e_FieldAll]) ;
			CBMenuPopup *pParent=(CBMenuPopup *)m_pMenuWnd;
			m_pMenuPopup->m_bDropDown=pParent->m_bDropDown;
		}
		return m_pMenuPopup;
	}
	else
	{
		if(m_pMenuPopup)
		{
			m_pMenuPopup->DestroyWindow() ; 

			// depointer if required.
			if(	m_pCTE &&
				m_pCTE->flags & CT_MENU)
			{
				m_pMenuPopup=NULL;
			}
		}
		return NULL ;
	}
}

BOOL CBMenuItem::ModifyItem(UINT nNewCmdID,
                           LPCTSTR lpszNewItem, 
                           CBMenuPopup* pNewPopup, 
                           int iNewItemType)
{
   if (iNewItemType != MIT_Unknown)
   {
      for (int i = 0 ; i < c_iNumFields ; i++)
      {
         m_rectFields[e_FieldAll].SetRectEmpty() ;
      }

      // Change basic type of menu item:
      switch (iNewItemType)
      {
      case MIT_Separator:
         {
            ASSERT(m_iItemType != MIT_Separator) ;
            m_strName.Empty() ;
            m_bSelected = FALSE ;
            m_nCmdID = 0 ;
            m_bChecked = FALSE ;
            m_bGrayed = FALSE ;
            m_bExpanded = FALSE ;
            if (m_pMenuPopup != NULL)
            {
               ASSERT(m_iItemType == MIT_Popup) ;
               delete m_pMenuPopup ;
            }
            m_iItemType = MIT_Separator;
         }
         break;
      case MIT_Popup:
         {
            ASSERT(m_iItemType != MIT_Popup) ;
            ASSERT(m_pMenuPopup == NULL) ;
            m_nCmdID = 0 ;
            //?? m_bChecked = FALSE ;
            m_bSelected = FALSE ; // This could cause problems...
            m_bExpanded = FALSE;
            // Wait for next section: m_pMenuPopup = pNewPopup ;
            m_iItemType = MIT_Popup;
         }
         break;
      case MIT_Command:
         {
            ASSERT(m_iItemType != MIT_Command) ;
            m_nCmdID = 0 ;
            m_bChecked = FALSE ;
            m_bGrayed = FALSE ;
            m_bExpanded = FALSE ;
            if (m_pMenuPopup != NULL)
            {
               ASSERT(m_iItemType == MIT_Popup) ;
               delete m_pMenuPopup ;
            }
            m_iItemType = MIT_Command;
         }
         break;
      default:
         ASSERT(0);
         return FALSE;
      }
   }

   //
   // Now make changes to the type itself.
   // Keep in mind that the above case falls through.
   //
   switch (m_iItemType)
   {
   case MIT_Separator:
      {
         // Ignore the following:
         // nNewCmdID
         // lpszNewItem
         // pSubPopup
      }
      break;
   case MIT_Popup:
      {
         if (pNewPopup != NULL)
         {
            if (m_pMenuPopup != NULL)
            {
               delete m_pMenuPopup ;
            }
            m_pMenuPopup = pNewPopup ;
            m_bExpanded = FALSE ;
         }

		 SetText(lpszNewItem) ;
         // Ignore the following:
         // nNewCmdID
      }
      break;
   case MIT_Command:
      {
         if (nNewCmdID != 0)
         {
            m_nCmdID = nNewCmdID ;
         }

		 SetText(lpszNewItem) ;
         // Ignore the following:
         // pSubPopup
      }
      break;
   default:
      ASSERT(0);
      return FALSE ;
   }

   return TRUE ;
}

//
// ParseOutAccelerator 
//
// This function removes the accerator from the menu string.
// I was going to change the code so that the accerator was not added,
// However, That wouldn't handle CmdUIUpdate functions updating the text.
//

void CBMenuItem::ParseOutAccelerator(CString strWhole)
{
  int index = strWhole.Find(L'\t') ;
	
  if (index < 0)
  {
	  m_strName = strWhole ;
  }
  else
  {
	  m_strName = strWhole.Left(index) ;
	  m_strAccel = strWhole.Mid(index+1) ;
  }

};

//
// Posts a WM_MENUSELECT message so that the menu will show the status bar
// text.
//
// This function implements only a subset of the proper WM_MENUSELCT code.
// It never sets the following flags:
//			MF_OWNERDRAW
//			MF_SYSMENU
//			MF_BITMAP
//			MF_HILITE
//			MF_DISABLED
//
// This menu also doesn't send out the handle to the popup.
//
void CBMenuItem::Select(BOOL bSelect)
{

	m_bSelected = bSelect;

	if (bSelect)
	{
		// Only send a menu select if we are selecting the menu.

		UINT flags = 0 ;	
		if (m_bChecked)
		{
			flags |= MF_DISABLED ;
		}

		if (m_bGrayed)
		{
			flags |= MF_GRAYED ;
		}

		if (m_iItemType == MIT_Popup)
		{
			flags |= MF_POPUP ;
		}

		// Send a WM_MENUSELECT command to the main window. This message results
		// in the menu prompt displaying in the status bar. Notice the NULL
		// for the last parameter. This is only needed if this menu is the
		// system menu.
		AfxGetMainWnd()->SendMessage(WM_MENUSELECT, MAKELONG(m_nCmdID, flags), NULL) ;
	}
}

void CBMenuItem::SetDefault(BOOL bDefault)
{ 
	if(m_iItemType==MIT_Command)
	{
		// flush cache
		m_bNeedToCalculateSizes=TRUE; 
		m_bDefault=bDefault; 

		if(m_pMenuWnd)
		{
			// recalc whole of menu. Could be extraneous, but probably not since this is primarily used in context menu.
			m_pMenuWnd->CalcMenuSize();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\bwizmgr.cpp ===
#include "stdafx.h"

#include <ocdesign.h>
#include <shldocs_.h>

#include "bwizmgr.h"
#include "bwizdlg.h"
#include "utilauto.h"		// for app's automation object
#include "shell.h"			// szKeyRoot && szCompanyName strings(initexit.cpp)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CBuilderWizardManager, CCmdTarget)

BEGIN_INTERFACE_MAP(CBuilderWizardManager, CCmdTarget)
	INTERFACE_PART(CBuilderWizardManager, IID_IBuilderWizardManager, BuilderWizardManager)
END_INTERFACE_MAP()

// static strings
TCHAR *CBuilderWizardManager::szSysCompCatKey = 
		_T("Component Categories");

static LPCTSTR s_szSlash		= _T("\\");


///////////////////////////////////////////////////////////////////////////////
// CBuilderWizardManager
//
CBuilderWizardManager::CBuilderWizardManager()
{
}

CBuilderWizardManager::~CBuilderWizardManager()
{
}

BOOL CBuilderWizardManager::DoesDevCategoryExist(
	LPCTSTR szCategory, HKEY *pKeyOut /* = NULL*/)
{
	ASSERT(NULL != szCategory);
	if(NULL == szCategory)
		return FALSE;

	if(NULL != pKeyOut)
		*pKeyOut = NULL;
	
	HKEY hKey = NULL;
	///////////////////////////////////
	// must build this key ourselves.  we can not use theApp.GetRegistryKeyName()
	// as this builds a key that takes into account the /i switch.  since these
	// settings are in HKLM and /i is an HKCU setting, we would end up with 
	// a bogus HKLM path.
	CString strKey;
	strKey =  g_szKeyRoot; 
	strKey += s_szSlash;
	strKey += g_szCompanyName;
	strKey += s_szSlash;
	strKey += theApp.GetExeString(DefaultRegKeyName);
	strKey += s_szSlash;
	strKey += szSysCompCatKey;
	strKey += s_szSlash;
	strKey += szCategory;
	if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
		strKey, 0, KEY_READ, &hKey))
	{
		TRACE("DoesDevCatExist failed- Could not open reg key\n");
		return FALSE;
	}

	ASSERT(NULL != hKey);
	if(NULL != pKeyOut)
		*pKeyOut = hKey;
	else
		::CloseHandle(hKey);
	return TRUE;
}

#if _DEBUG
// enusure that the system compcat registry entries
// have been properly setup
BOOL CBuilderWizardManager::DoesSysCategoryExist(LPCTSTR szCategory)
{
	ASSERT(NULL != szCategory);
	if(NULL == szCategory)
		return FALSE;

	HKEY hKey = NULL;
	CString strKey;

	strKey = szSysCompCatKey;
	strKey += s_szSlash;
	strKey += szCategory;
	if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, 
		strKey, 0, KEY_READ, &hKey))
	{
		TRACE("DoesSysCatExist failed- Could not open reg key\n");
		return FALSE;
	}

	ASSERT(NULL != hKey);
	::CloseHandle(hKey);
	return TRUE;
}
#endif

BOOL CBuilderWizardManager::GetDefaultCompCatCLSID(
	HKEY hCATIDKey, 
	CLSID *pclsidBuilder)
{
	USES_CONVERSION;

	ASSERT(NULL != hCATIDKey);
	ASSERT(NULL != pclsidBuilder);
	if(NULL == hCATIDKey)
		return FALSE;

	HKEY hSubKey;
	CString strKey;
	//strKey.LoadString(
	strKey = _T("Default Component\\CLSID");
	if(ERROR_SUCCESS != ::RegOpenKeyEx(hCATIDKey, strKey, 0, KEY_READ, &hSubKey))
		return FALSE;

	DWORD nType;
	DWORD cbData = 0;
	// get the size of the string
	if(ERROR_SUCCESS != ::RegQueryValueEx(hSubKey, 
		NULL, NULL, &nType, NULL, &cbData))
	{
		TRACE("GetDefaultCompCatCLSID failed to get size of the RegValue\n");
		::CloseHandle(hSubKey);	
		return FALSE;
	}
	ASSERT(REG_SZ == nType);

	// grab some heap and get the value
	cbData += sizeof(TCHAR);
	TCHAR *pValue = new TCHAR[cbData];
	if(ERROR_SUCCESS != ::RegQueryValueEx(hSubKey, NULL, NULL, 
		&nType, (LPBYTE)pValue, &cbData))
	{
		TRACE("GetDefaultCompCatCLSID failed to get Registry Value\n");
		delete [] pValue;
		::CloseHandle(hSubKey);	
		return FALSE;
	}
	// convert the string to a clsid
	HRESULT hr = ::CLSIDFromString(T2OLE(pValue), pclsidBuilder);
	delete [] pValue;
	pValue = NULL;
	::CloseHandle(hSubKey);	
	hSubKey = NULL;
	return SUCCEEDED(hr);
}

BOOL CBuilderWizardManager::GetCompCatCLSID(
	HKEY hCATIDKey, 
	DWORD nKeyNumber, 
	CLSID *pclsidBuilder)
{
	ASSERT(NULL != hCATIDKey);
	ASSERT(NULL != pclsidBuilder);
	if(NULL == hCATIDKey)
		return FALSE;

	USES_CONVERSION;

	DWORD cSubKeys = 0;
	DWORD cbMaxSubKeyLen = 0;
	HRESULT hr;
	if(ERROR_SUCCESS == ::RegQueryInfoKey(hCATIDKey, NULL, NULL, NULL, 
			&cSubKeys, &cbMaxSubKeyLen,	NULL, NULL, NULL, NULL, NULL, NULL))
	{
		HKEY hSubKey;
		CBWizEnumItem *pItem = NULL;
		TCHAR *pszSubKeyName = new TCHAR[++cbMaxSubKeyLen];

		// if we can't enum the key, or we got back the 
		// default component key, we're in error
		if(ERROR_SUCCESS != ::RegEnumKeyEx(hCATIDKey, nKeyNumber, 
			pszSubKeyName, &cbMaxSubKeyLen, NULL, NULL, NULL, NULL) ||
			!lstrcmp(pszSubKeyName, _T("Default Component")))
		{
#if defined _DEBUG
			CString strDebug;
			strDebug.Format(_T("GetCompCatCLSID Error(%s!= Default Component\r\n"), pszSubKeyName);
			::AfxMessageBox(strDebug);
#endif
			hr = S_FALSE;
		}
		else
			hr = ::CLSIDFromString(T2OLE(pszSubKeyName), pclsidBuilder);
		delete [] pszSubKeyName;
	}	
	return (hr == S_OK ? TRUE : FALSE);
}

STDMETHODIMP CBuilderWizardManager::XBuilderWizardManager::DoesBuilderExist(
	REFGUID rguidBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	ASSERT_VALID(pThis);

	USES_CONVERSION;

	// validate parameters
	ASSERT(CLSID_NULL != rguidBuilder);
	if(CLSID_NULL == rguidBuilder)
		return E_INVALIDARG;

	// give the package a shot a providing the builder
	if(S_OK == theApp.DoesIntrinsicBuilderExist(rguidBuilder))
		return S_OK;

	// convert the object's clsid to a string
	LPOLESTR szGUID = NULL;
	::StringFromCLSID(rguidBuilder, &szGUID);
	CString strGUID = OLE2T(szGUID);
	AfxFreeTaskMem(szGUID);
	szGUID = NULL;

	if(pThis->DoesDevCategoryExist(strGUID))
		return S_OK;

	// build the key string
	CString strCLSIDKey = _T("CLSID\\");
	strCLSIDKey += strGUID;
	strCLSIDKey += _T("\\Implemented Categories");
	// look for this under classes root and see
	// if it implements any compcats.  get the
	// compcats is implements and see if they
	// exist under our dev key

	HKEY hCLSIDKey;
	if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, 
		strCLSIDKey, 0, KEY_READ, &hCLSIDKey))
		return S_FALSE;

	// figure out how may categories this key implements
	DWORD cSubKeys = 0;
	DWORD cbMaxSubKeyLen = 0;
	if(ERROR_SUCCESS != ::RegQueryInfoKey(hCLSIDKey, NULL, 
		NULL, NULL, &cSubKeys, &cbMaxSubKeyLen,	NULL, 
		NULL, NULL, NULL, NULL, NULL))
	{
		TRACE("DoesBuilderExist: key does not implement any cateogories\n");
		::CloseHandle(hCLSIDKey);
		return S_FALSE;
	}

	// walk each key and look to see if its supported 
	// under out dev key
	DWORD nUnused;
	TCHAR *pszSubKeyName = new TCHAR[++cbMaxSubKeyLen];
	HRESULT hr = S_FALSE;
	for(DWORD nCnt = 0; nCnt < cSubKeys; ++nCnt)
	{
		nUnused = cbMaxSubKeyLen;
		// if we can't enum the key, don't do anything
		if(ERROR_SUCCESS != ::RegEnumKeyEx(hCLSIDKey, nCnt, pszSubKeyName, 
			&nUnused, NULL, NULL, NULL, NULL))
		{
			ASSERT(!_T("Could not Enum Key"));
			continue;
		}

		if(pThis->DoesDevCategoryExist(pszSubKeyName))
		{
			hr = S_OK;
			break;
		}
	}
	delete [] pszSubKeyName;
	::CloseHandle(hCLSIDKey);	
	return hr;
}

STDMETHODIMP CBuilderWizardManager::XBuilderWizardManager::MapObjectToBuilderCLSID(
	REFCLSID rclsidObject, 
	DWORD dwPromptOpt,
	HWND hwndOwner, 
	CLSID *pclsidBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	ASSERT_VALID(pThis);

	USES_CONVERSION;

	// validate parameters
	ASSERT(CLSID_NULL != rclsidObject);
	ASSERT(NULL != pclsidBuilder);
	ASSERT(BLDPROMPTOPT_PROMPTIFMULTIPLE == dwPromptOpt ||
			BLDPROMPTOPT_PROMPTALWAYS == dwPromptOpt ||
			BLDPROMPTOPT_PROMPTNEVER == dwPromptOpt);

	if(CLSID_NULL == rclsidObject || 
		NULL == pclsidBuilder || 
		(BLDPROMPTOPT_PROMPTIFMULTIPLE != dwPromptOpt &&
		BLDPROMPTOPT_PROMPTALWAYS != dwPromptOpt &&
		BLDPROMPTOPT_PROMPTNEVER != dwPromptOpt))
		return E_INVALIDARG;

	// if there's a possibility of prompting
	// make sure the hwndOwner is valid
	if(BLDPROMPTOPT_PROMPTNEVER != dwPromptOpt 
		&& !::IsWindow(hwndOwner))
	{
		hwndOwner = AfxGetMainWnd()->GetSafeHwnd();
	}

	// convert the object's clsid to a string
	LPOLESTR szCLSID = NULL;
	::StringFromCLSID(rclsidObject, &szCLSID);
	CString strCLSID = OLE2T(szCLSID);
	AfxFreeTaskMem(szCLSID);
	szCLSID = NULL;

	// build the full clsid key
	HKEY hCLSIDKey = NULL;
	CString strCLSIDKey = _T("CLSID\\");;
	strCLSIDKey += strCLSID;
	strCLSIDKey += _T("\\ObjectBuilderWizard");

	if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_CLASSES_ROOT, 
		strCLSIDKey, 0, KEY_READ, &hCLSIDKey))
	{
		TRACE("Failed to Open HKEY_CLASSES_ROOT\\{clsid}\\ObjectBuilderWizard\n");
		return REGDB_E_KEYMISSING;
	}

	DWORD nType;
	DWORD cbData = 0;
	// get the size of the string
	if(ERROR_SUCCESS != ::RegQueryValueEx(hCLSIDKey, 
		NULL, NULL, &nType, NULL, &cbData))
	{
		TRACE("RegQueryValueEx for size of Reg Data failed\n");
		::CloseHandle(hCLSIDKey);	
		return REGDB_E_READREGDB;
	}
	ASSERT(REG_SZ == nType);

	// grab some heap and get the value
	cbData += sizeof(TCHAR);
	TCHAR *pValue = new TCHAR[cbData];
	if(ERROR_SUCCESS != ::RegQueryValueEx(hCLSIDKey, 
		NULL, NULL, &nType, (LPBYTE)pValue, &cbData))
	{
		TRACE("RegQueryValueEx for Reg Data failed\n");
		delete [] pValue;
		::CloseHandle(hCLSIDKey);	
		return REGDB_E_READREGDB;
	}
	// convert the string to a clsid
	GUID guidBuilder;
	HRESULT hr = ::CLSIDFromString(T2OLE(pValue), &guidBuilder);

	if(SUCCEEDED(hr))
	{
		// OK to reuse the CString again
		strCLSIDKey = _T("CLSID\\");
		strCLSIDKey += T2OLE(pValue);

		// optimize for the case when the control has a specific
		// CLSID as its builder and is not using a CATID
		HKEY hNotUsed = NULL;
		if(ERROR_SUCCESS == ::RegOpenKeyEx(HKEY_CLASSES_ROOT, 
								strCLSIDKey, 0, KEY_READ, &hNotUsed))
		{
			// the control has a CLSID registered as its builder
			// no need to treat it as a CATID, lets return it
			// and get out of here
			*pclsidBuilder = guidBuilder;
			::CloseHandle(hNotUsed);
			hr = S_OK;
		}
		else
			hr = MapBuilderCATIDToCLSID(guidBuilder, dwPromptOpt, 
										hwndOwner, pclsidBuilder);
	}

	::CloseHandle(hCLSIDKey);
	delete [] pValue;
	pValue = NULL;
	return hr;
}

STDMETHODIMP CBuilderWizardManager::XBuilderWizardManager::MapBuilderCATIDToCLSID(
	REFGUID rguidBuilder, 
	DWORD dwPromptOpt,
	HWND hwndOwner, 
	CLSID *pclsidBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	ASSERT_VALID(pThis);

	USES_CONVERSION;

	// validate parameters
	ASSERT(CLSID_NULL != rguidBuilder);
	ASSERT(NULL != pclsidBuilder);
	ASSERT(BLDPROMPTOPT_PROMPTIFMULTIPLE == dwPromptOpt ||
			BLDPROMPTOPT_PROMPTALWAYS == dwPromptOpt ||
			BLDPROMPTOPT_PROMPTNEVER == dwPromptOpt);

	*pclsidBuilder = CLSID_NULL;
	if(CLSID_NULL == rguidBuilder || 
		NULL == pclsidBuilder || 
		(BLDPROMPTOPT_PROMPTIFMULTIPLE != dwPromptOpt &&
		BLDPROMPTOPT_PROMPTALWAYS != dwPromptOpt &&
		BLDPROMPTOPT_PROMPTNEVER != dwPromptOpt))
		return E_INVALIDARG;

	// if there's a possibility of prompting
	// make sure the hwndOwner is valid
	if(BLDPROMPTOPT_PROMPTNEVER != dwPromptOpt && !::IsWindow(hwndOwner))
		hwndOwner = AfxGetMainWnd()->GetSafeHwnd();

	// convert the catid to a string
	HKEY hDevRootCompCatKey = NULL;
	LPOLESTR szCATID = NULL;
	::StringFromCLSID(rguidBuilder, &szCATID);
	CString strCATID = OLE2T(szCATID);
	AfxFreeTaskMem(szCATID);
	szCATID = NULL;
	HKEY hCATIDKey = NULL;

	///////////////////////////////////
	// must build this key ourselves.  we can not use theApp.GetRegistryKeyName()
	// as this builds a key that takes into account the /i switch.  since these
	// settings are in HKLM and /i is an HKCU setting, we would end up with 
	// a bogus HKLM path.
	CString strKey;
	strKey =  g_szKeyRoot;
	strKey += s_szSlash;
	strKey += g_szCompanyName;
	strKey += s_szSlash;
	strKey += theApp.GetExeString(DefaultRegKeyName);
	strKey += s_szSlash;
	strKey += szSysCompCatKey;

	// see if our compcat key exists
	if(ERROR_SUCCESS != ::RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
							strKey, 0, KEY_READ, &hDevRootCompCatKey) ||
#if _DEBUG
// enusure that the system compcat registry entries
// have been properly setup
		!pThis->DoesSysCategoryExist(strCATID) ||
#endif
		// ensure that CATID exists in developer hive
		!pThis->DoesDevCategoryExist(strCATID, &hCATIDKey))
	{
		TRACE0("DoesDevCategoryExist Failed\n");
		if(hDevRootCompCatKey)
			::CloseHandle(hDevRootCompCatKey);
		return REGDB_E_KEYMISSING;
	}
	::CloseHandle(hDevRootCompCatKey);	
	
	// More Parameter validation: on Meta CATID
	BOOL fMetaCATID;
	if((fMetaCATID = IsMetaCATID(hCATIDKey)) && 
		(BLDPROMPTOPT_PROMPTNEVER == dwPromptOpt))
	{
		//Need PROMPTING on a Meta CATID
		::CloseHandle(hCATIDKey);
		return E_INVALIDARG;
	}
	
	// figure out how may sub keys this catid has
	// skipped if MetaCATID
	DWORD cSubKeys = 0;
	if(!fMetaCATID && 
		ERROR_SUCCESS != ::RegQueryInfoKey(hCATIDKey, NULL, 
									NULL, NULL, &cSubKeys, NULL, NULL, NULL, 
									NULL, NULL, NULL, NULL))
	{
		TRACE("RegQueryInfoKey for # of sub keys failed\n");
		::CloseHandle(hCATIDKey);
		return REGDB_E_READREGDB;
	}

	HRESULT hr = S_OK;
	// never prompt, grab the default
	// skipped if METACATID
	if(!fMetaCATID && (BLDPROMPTOPT_PROMPTNEVER == dwPromptOpt || 
		(1 == cSubKeys && BLDPROMPTOPT_PROMPTALWAYS != dwPromptOpt)))
	{
		// if we have more than one subkey, see if we
		// have a default
		if(cSubKeys > 1)
		{
			pThis->GetDefaultCompCatCLSID(hCATIDKey, pclsidBuilder);
		}

		// either we only have 1 subkey or have multiple but no
		// default has been defined
		if(CLSID_NULL == *pclsidBuilder &&
			!pThis->GetCompCatCLSID(hCATIDKey, 0, pclsidBuilder))
		{
			// we don't have a clsid
			*pclsidBuilder = CLSID_NULL;	
			hr = REGDB_E_KEYMISSING;
		}
	}
	else 
	{
		// if we have a prompt if multipe case, see if we have a default
		// key set, if so , we take this and give no dlg ui
		// skipped if MetaCATID
		if(!fMetaCATID && BLDPROMPTOPT_PROMPTIFMULTIPLE == dwPromptOpt)
		{
			pThis->GetDefaultCompCatCLSID(hCATIDKey, pclsidBuilder);
		}

		// either promp always or we didn't have a default
		// or we have a MetaCATID 
		if(fMetaCATID || CLSID_NULL == *pclsidBuilder)
		{
			CWnd wnd;		// for modal dialog happiness
			CWnd* pWnd = CWnd::FromHandlePermanent(hwndOwner);
			if(NULL == pWnd)
			{
				wnd.Attach(hwndOwner);
				pWnd = &wnd;
			}
			// prompt with the enumerations dialog
			CBldWizSelectDlg dlg(pWnd);
			if(dlg.SetCATID(hCATIDKey) && IDOK == dlg.DoModal() &&
					CLSID_NULL != dlg.m_clsidSel)
			{
				//get select builder's clsid
				*pclsidBuilder = dlg.m_clsidSel;
			}
			else
				// User canceled the dialog so return S_FALSE
				hr = S_FALSE;
			// IStudio bug # 5808
			// force the window that parented the dialog to repaint itself now.
			pWnd->UpdateWindow();
				
			if(pWnd == &wnd)
				wnd.Detach();
		}
		else
			hr = S_OK;		// we got the default
	}
	::CloseHandle(hCATIDKey);
	return hr;
}

STDMETHODIMP CBuilderWizardManager::XBuilderWizardManager::GetBuilder(
	REFGUID rguidBuilder, 
	DWORD grfGetOpt, 
	HWND hwndPromptOwner, 
	IDispatch **ppdispApp,
	HWND *pwndBuilderOwner, 
	REFIID riidBuilder,
	IUnknown **ppunkBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	ASSERT_VALID(pThis);

	ASSERT(CLSID_NULL != rguidBuilder);
	ASSERT(NULL != ppunkBuilder);
	if(CLSID_NULL == rguidBuilder ||
		NULL == ppunkBuilder)
		return E_INVALIDARG;

	if(NULL != ppdispApp)
		*ppdispApp = NULL;
	if(NULL != pwndBuilderOwner)
		*pwndBuilderOwner = NULL;
	*ppunkBuilder = NULL;

	GUID guidPrivateBuilder;
	// we are being asked to map the GUID
	if((grfGetOpt & BLDGETOPT_FAUTOMAPGUID))
	{
		DWORD dwMapFlag = BLDPROMPTOPT_PROMPTNEVER;
		// we've been asked to perform the mapping
		if(grfGetOpt & BLDGETOPT_FAUTOMAPENABLEPROMPT)
		{
			// make sure we have a valid hwnd
			if(!::IsWindow(hwndPromptOwner))
				hwndPromptOwner = AfxGetMainWnd()->GetSafeHwnd();

			// determime if its a prompt always
			// or a prompt if multiple
			if(grfGetOpt & BLDGETOPT_FAUTOMAPPROMPTALWAYS)
				dwMapFlag = BLDPROMPTOPT_PROMPTALWAYS;
			else
				dwMapFlag = BLDPROMPTOPT_PROMPTIFMULTIPLE;
		}

		// Call MapBuilder to get the guid of the builder.
		// If MapBuilder returns S_FALSE, then user has canceled the operation.
		// If MapBuilder returns an error without Prompting then we will check 
		// for an instrinsic builder.  If MapBuilder fails with prompting then 
		// there is no reason to continue.
		HRESULT hr = MapBuilderCATIDToCLSID(rguidBuilder, dwMapFlag, 
										hwndPromptOwner, &guidPrivateBuilder);
		// Check for canceled 
		if(hr == S_FALSE)
			// User has cancelled GetBuilder, so return S_FALSE
			return S_FALSE;
			
		// Check for map failure
		if(FAILED(hr))
		{
			if(grfGetOpt & BLDGETOPT_FAUTOMAPENABLEPROMPT)
				// Map Failed, with the PROMPT flag, so dont continue
				return hr;
			else
				// Map Failed, without the PROMPT flag.
				// Check if rguidBuilder is a builder, or it is an
				// intrisinic builder.
				guidPrivateBuilder = rguidBuilder;
		}
	}
	else
		guidPrivateBuilder = rguidBuilder;
	HRESULT hr = ::CoCreateInstance(guidPrivateBuilder, NULL, 
					CLSCTX_INPROC_SERVER, riidBuilder, 
					(void**)ppunkBuilder);

	// if we've failed, give the packages a shot
	if(FAILED(hr) && !(grfGetOpt & BLDGETOPT_FNOINTRINSICS))
	{
#if defined _DEBUG
		HRESULT hrIntrinsic = theApp.GetIntrinsicBuilder(rguidBuilder, grfGetOpt, 
													hwndPromptOwner, ppdispApp,
													pwndBuilderOwner, riidBuilder, 
													ppunkBuilder);
		// Display both error messages
		if(FAILED(hrIntrinsic))
		{
			USES_CONVERSION;
			// convert the object's clsid to a string
			LPOLESTR	 pszBuilder;
			LPOLESTR	 pszPrivateBuilder;
			::StringFromCLSID(rguidBuilder, &pszBuilder);
			::StringFromCLSID(guidPrivateBuilder, &pszPrivateBuilder);
			CString strDebug;
			strDebug.Format(_T("GetBuilder Failed\r\n")\
								 _T("rguidBuilder(%s)\r\n")\
								 _T("rguidPrivateBuilder(%s)\r\n")\
								 _T("GetIntrinsicBuilder()=%08X\r\n")\
								 _T("CoCreateInstance()=%08X)"), 
								 OLE2T(pszBuilder), OLE2T(pszPrivateBuilder), 
								 hrIntrinsic, hr);
			::AfxFreeTaskMem(pszBuilder);
			::AfxFreeTaskMem(pszPrivateBuilder);
			::AfxMessageBox(strDebug);
		}
		return hrIntrinsic;
#else	
		// see if this is an intrinsic builder
		// offered up by one of the loaded packages
		return theApp.GetIntrinsicBuilder(rguidBuilder, grfGetOpt, 
								hwndPromptOwner, ppdispApp,
								pwndBuilderOwner, riidBuilder, 
								ppunkBuilder);
#endif								
	}
	else
	{
		if(NULL != pwndBuilderOwner)
		{
			// fix IStudio bug# 4782
			// can't assume that hwndPromptOwner is valid
			if(::IsWindow(hwndPromptOwner))
				*pwndBuilderOwner = hwndPromptOwner;
			else
				*pwndBuilderOwner = AfxGetMainWnd()->GetSafeHwnd();
			ASSERT(NULL != *pwndBuilderOwner && ::IsWindow(*pwndBuilderOwner));
		}


		// give them the app object if they want it
		if(NULL != ppdispApp)
		{
			COleRef<IDispatch> srpDisp;
			ASSERT(NULL != theApp.m_pAutoApp);
			HRESULT hr = theApp.m_pAutoApp->ExternalQueryInterface(
											&IID_IDispatch, (void**)&srpDisp);
			ASSERT(SUCCEEDED(hr));
			*ppdispApp = srpDisp.Disown();
		}
		return hr;
	}
}

STDMETHODIMP CBuilderWizardManager::XBuilderWizardManager::EnableModeless(
	BOOL fEnable)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	ASSERT_VALID(pThis);

	// Disabling the main frame window will manage modality with
	// the component manager.
	AfxGetMainWnd()->EnableWindow(fEnable);
	return NOERROR;	
}

STDMETHODIMP_(ULONG) CBuilderWizardManager::XBuilderWizardManager::AddRef()
{
	// Delegate to our exported AddRef.

	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CBuilderWizardManager::XBuilderWizardManager::Release()
{
	// Delegate to our exported Release.

	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CBuilderWizardManager::XBuilderWizardManager::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.

	METHOD_PROLOGUE_EX(CBuilderWizardManager, BuilderWizardManager)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}



IMPLEMENT_DYNAMIC(CIPCompBuilderWizardManager, CCmdTarget)

BEGIN_INTERFACE_MAP(CIPCompBuilderWizardManager, CCmdTarget)
	INTERFACE_PART(CIPCompBuilderWizardManager, 
					IID_IBuilderWizardManager, IPCompBuilderWizardManager)
END_INTERFACE_MAP()

///////////////////////////////////////////////////////////////////////////////
// CIPCompBuilderWizardManager
//
CIPCompBuilderWizardManager::CIPCompBuilderWizardManager(
	CIPCompContainerItem *pItem)
{
	ASSERT(NULL != pItem);
	m_pContainerItem = pItem;
}

CIPCompBuilderWizardManager::~CIPCompBuilderWizardManager()
{
	ASSERT(0 == m_dwRef);
	m_pContainerItem = NULL;
}


STDMETHODIMP CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::DoesBuilderExist(
	REFGUID rguidBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	ASSERT_VALID(pThis);

	// validate parameters
	ASSERT(CLSID_NULL != rguidBuilder);
	if(CLSID_NULL == rguidBuilder)
		return E_INVALIDARG;

	ASSERT(NULL != pThis->m_pContainerItem);
	CIPCompDoc *pDoc = pThis->m_pContainerItem->GetDocument();
	ASSERT(NULL != pDoc && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)));

	HRESULT hr = pDoc->DoesBuilderExist(rguidBuilder);
	if(FAILED(hr))
	{
		ASSERT(pThis->m_srpBuilderWizardManager != NULL);
		return pThis->m_srpBuilderWizardManager->DoesBuilderExist(rguidBuilder);
	}
	return hr;
}

STDMETHODIMP CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::MapObjectToBuilderCLSID(
	REFCLSID rclsidObject, 
	DWORD dwPromptOpt,
	HWND hwndOwner, 
	CLSID *pclsidBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	ASSERT_VALID(pThis);

	ASSERT(CLSID_NULL != rclsidObject);
	if(CLSID_NULL == rclsidObject)
		return E_INVALIDARG;

	ASSERT(pThis->m_srpBuilderWizardManager != NULL);
	return pThis->m_srpBuilderWizardManager->MapObjectToBuilderCLSID(rclsidObject, 
							dwPromptOpt, hwndOwner,	pclsidBuilder);
}

STDMETHODIMP CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::MapBuilderCATIDToCLSID(
	REFGUID rguidBuilder, 
	DWORD dwPromptOpt,
	HWND hwndOwner, 
	CLSID *pclsidBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	ASSERT_VALID(pThis);

	ASSERT(CLSID_NULL != rguidBuilder);
	if(CLSID_NULL == rguidBuilder)
		return E_INVALIDARG;

	ASSERT(pThis->m_srpBuilderWizardManager != NULL);
	return pThis->m_srpBuilderWizardManager->MapBuilderCATIDToCLSID(rguidBuilder, 
						dwPromptOpt, hwndOwner,	pclsidBuilder);
}

STDMETHODIMP CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::GetBuilder(
	REFGUID rguidBuilder, 
	DWORD grfGetOpt, 
	HWND hwndPromptOwner, 
	IDispatch **ppdispApp,
	HWND *pwndBuilderOwner, 
	REFIID riidBuilder,
	IUnknown **ppunkBuilder)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	ASSERT_VALID(pThis);

	ASSERT(CLSID_NULL != rguidBuilder);
	ASSERT(NULL != ppunkBuilder);
	if(CLSID_NULL == rguidBuilder || NULL == ppunkBuilder)
		return E_INVALIDARG;

	// the app's implementation should never 
	// get called with this bit set
	ASSERT(!(grfGetOpt & BLDGETOPT_FOBJECTBUILDER));
	ASSERT(NULL != pThis->m_pContainerItem);
	CIPCompDoc *pDoc = pThis->m_pContainerItem->GetDocument();
	ASSERT(NULL != pDoc && pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)));

	HRESULT hr = pDoc->GetBuilder(rguidBuilder, grfGetOpt, 
							hwndPromptOwner, ppdispApp, 
							pwndBuilderOwner, riidBuilder, 
							ppunkBuilder);

	if(FAILED(hr))
	{
		ASSERT(pThis->m_srpBuilderWizardManager != NULL);
		return pThis->m_srpBuilderWizardManager->GetBuilder(rguidBuilder, 
						grfGetOpt, hwndPromptOwner, ppdispApp, 
						pwndBuilderOwner, riidBuilder, ppunkBuilder);
	}
	return hr;
}

STDMETHODIMP CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::EnableModeless(
	BOOL fEnable)
{
	// pass this off to our container class
	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	ASSERT_VALID(pThis);

	ASSERT(pThis->m_srpBuilderWizardManager != NULL);
	pThis->m_srpBuilderWizardManager->EnableModeless(fEnable);
	return NOERROR;	
}



STDMETHODIMP_(ULONG) CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::AddRef()
{
	// Delegate to our exported AddRef.

	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::Release()
{
	// Delegate to our exported Release.

	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CIPCompBuilderWizardManager::XIPCompBuilderWizardManager::QueryInterface(
	REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.

	METHOD_PROLOGUE_EX(CIPCompBuilderWizardManager, IPCompBuilderWizardManager)

	if(IID_IBuilderWizardManager == iid && 
		pThis->m_srpBuilderWizardManager == NULL)
	{
		HRESULT hr = theApp.GetService(SID_SBuilderWizardManager, 
							IID_IBuilderWizardManager, 
							(void**)&(pThis->m_srpBuilderWizardManager));
		ASSERT(SUCCEEDED(hr));
	}
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cbmenu.cpp ===
// MenuPopup.cpp : implementation file
//

#include "stdafx.h"
#include "shlmenu.h"

#include "barglob.h"

#include "afxpriv.h" //WM_IDLEUPDATECMDUI
#include <tchar.h> // For command moving to a menu...
#include "barcust.h"
#include "menuprxy.h"
#include "bardockx.h"
#include "prxycust.h"
#include "resource.h"
#include "shell.h"

// [multimon] 7 mar 97 - der
#include "mmonitor.h"
#include "math.h"

extern HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);
static void MdiRefreshMenu() ;

static const int c_iBorderSize = 4 ;
static const int c_iArraySize = 20 ;
static const int c_iArrayGrow = 20 ;
// width and height of an empty menu
static const int c_iEmptyWidth = 100;
static const int c_iEmptyHeight = 16;
static const int c_iNoItem = -1 ;
static const int c_iButtonTextGap = 2 ;
static const int c_cyScrollAreaHeight=16;
static const int c_nInitialScrollDelay=300;
static const int c_nScrollDelay=100;

// timer ids for auto menus. All of these are arbitrary values.
static const int c_iExpandTimerID=0xEAE1E;
static const int c_iContractTimerID=0xC0ACE1E;
static const int c_iScrollDownTimerID=0x5C011d01;
static const int c_iScrollUpTimerID=0x5C0111e1;

BOOL CBMenuPopup::s_bLastWasKey=FALSE;
BOOL CBMenuPopup::s_bSuppressedMouseMove=FALSE;

// bitmaps used for scrolling menus
CBitmap CBMenuPopup::s_bmpScrollDown;
CBitmap CBMenuPopup::s_bmpScrollUp;
CSize CBMenuPopup::s_sizeScroll;

BOOL CBMenuPopup::s_bCreateTransients=FALSE;

int CBMenuPopup::s_nLastSystemClick=0;
CPoint CBMenuPopup::s_ptLastSystemClick(0,0);

CPoint CBMenuPopup::s_ptLastMove(0,0);

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#undef new
#endif

extern UINT DSM_TESTMENU;

IMPLEMENT_DYNAMIC(CBMenuPopup, CWnd)

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// Dfine this to one to trace on Cmdui handlers that are in the slowest 10% of the range
// See barcust.cpp for an explanation of this #define
#ifdef _DEBUG
#define FIND_SLOW_CMDUI 0
#else
#define FIND_SLOW_CMDUI 0
#endif

/////////////////////////////////////////////////////////////////////////////
// CForwardMouseMessage
//
// It is used when the user clicks outside of the menu bar area.
//

class CForwardMouseMessage
{
public:
	//
	// Constructor
	//
	CForwardMouseMessage(const MSG* pmsg);

	//
	// Member function
	//
	void Send(HWND hWndHadCapture) ;

	// Member variables.
	UINT m_message ;
	WPARAM m_wParam ;
	POINT m_pt;

#ifdef _DEBUG
	BOOL m_bSent ;
#endif

};

//
// Constructor
//
CForwardMouseMessage::CForwardMouseMessage(const MSG* pmsg)
{
	// Save the imnportant parts of the message.
	m_message       = pmsg->message ;
	m_wParam        = pmsg->wParam ;

	// This class only works if the message is WM_LBUTTONDOWN or WM_RBUTTONDOWN. or double click
	ASSERT((m_message == WM_LBUTTONDOWN) || (m_message == WM_LBUTTONDBLCLK) || (m_message == WM_RBUTTONDOWN)) ;

	// The window in the message will be gone when we forward the message.
	// Therefore we need to convert the point from client to screen coordinates here.
	// NOTE: We have to cast to short because these values are signed!!!
	m_pt.x = (short)LOWORD(pmsg->lParam);  // horizontal position of cursor 
	m_pt.y = (short)HIWORD(pmsg->lParam);  // vertical position of cursor 

	VERIFY(::ClientToScreen(pmsg->hwnd, &m_pt)) ;

#ifdef _DEBUG
	m_bSent = FALSE ;
#endif
}

//
// Forward the message on.
//
void CForwardMouseMessage::Send(HWND hWndHadCapture)
{
	ASSERT(!m_bSent) ;

	// Do not first try to send the message to the window which had the capture,
	// because this doesn't work correctly with the dialog editor.

	// Get the window corresponding to the point where the mouse was pressed 
	// and send the message to it.
	CWnd *pWndDestination = CWnd::WindowFromPoint(m_pt) ;                                

	if (pWndDestination == NULL)
	{
		// We don't have a window to send to, so lets get out of here.
		TRACE0("CmdBars: No window to forward messages.");
		return ;
	}

	// We need to adjust the mouse point into client coordinates for 
	// the window we are forwarding to. We also need to determine if this is a non-client
	// message
	CRect rectClient;
	pWndDestination->GetClientRect(&rectClient);
	pWndDestination->ClientToScreen(&rectClient);

	if(!rectClient.PtInRect(m_pt))
	{
		// It must be a nonclient message
		switch(m_message)
		{
			case WM_LBUTTONDOWN:
				m_message=WM_NCLBUTTONDOWN;
				break;
			case WM_RBUTTONDOWN:
				m_message=WM_NCRBUTTONDOWN;
				break;
			case WM_LBUTTONDBLCLK:
				m_message=WM_NCLBUTTONDBLCLK;
				break;
		}

		// don't convert coords, because NC messages expect screen coords

		// get the NC hittest code
		LPARAM lParam = MAKELPARAM(m_pt.x, m_pt.y) ;
		m_wParam=pWndDestination->SendMessage(WM_NCHITTEST, 0, lParam);
	}
	else
	{
		pWndDestination->ScreenToClient(&m_pt);
	}

	// Now, let's forward the message
	LPARAM lParam = MAKELPARAM(m_pt.x, m_pt.y) ;
	pWndDestination->SendMessage(m_message, m_wParam, lParam) ;
}

/////////////////////////////////////////////////////////////////////////////
// CBMenuPopup

CBMenuPopup::CBMenuPopup()
:
   m_nMaxIndex(0),
   m_bDropDown(FALSE),
   m_bDirty(FALSE),
   m_pWndMenuBar(NULL),
   m_nCurrentTimer(0),
   m_pForwardMsg(NULL),
   m_pProxy(NULL),
   m_bAutoEnable(TRUE),
   m_bPassBackCancel(FALSE)
{
	// Initialize the Array
   m_MenuItems.SetSize(c_iArraySize, c_iArrayGrow) ;

   // Initialize all of the other stuff.
   Initialize() ;

   // Get the current size of the large toolbar buttons
   m_bLargeToolbar = globalData.GetLargeMenuButtons();

   // Initialize the widths to zero.
   m_iHeight = c_iBorderSize*2;
   for (int i = 0 ; i < c_iNumFields ; i++)
   {
	 m_iFieldWidths[i] = 0 ;
   }
   AllocateProxy();
}

CBMenuPopup::~CBMenuPopup()
{
	ASSERT(m_nCurrentTimer==0);

	DeleteAll();

	FreeProxy();

	if(m_pForwardMsg)
	{
		delete m_pForwardMsg;
		m_pForwardMsg=NULL;
	}
}

void CBMenuPopup::DeleteAll()
{
   for(int i = 0 ; i < m_nMaxIndex  ; i++)
   {
      CBMenuItem* pItem = m_MenuItems[i] ;

      pItem->Release() ;
   }
   m_MenuItems.RemoveAll();
   m_nMaxIndex = 0;

}

//The popups for the main menus are created once and then 
// exist for the life of the product. Therefore, reset stuff, at
// on trackpopup...
void CBMenuPopup::Initialize()
{
	m_nSelectedMenuItem = c_iNoItem;
	m_nExpandedMenuItem = c_iNoItem;
	m_nExpandDeferredItem= c_iNoItem;
	m_pParentWnd = NULL ;
	m_pChildPopup = NULL ;
	m_bSubPopup = FALSE ;
	m_bContinueModal = TRUE ;
	m_bPainted=FALSE;
	m_nPostCmdID = 0 ;
	m_bReturnCmdID=FALSE;
	m_bControl = FALSE ;
	m_rectAvoid  = CRect(0,0,0,0) ;
	m_bScrolling=FALSE;                             
	m_bHasTopScroll=FALSE;                  
	m_bHasBottomScroll=FALSE;
	m_nTopIndex=0;                  
	m_cyTopOffset=0;
	if (m_pForwardMsg != NULL)
	{
		delete m_pForwardMsg;
		m_pForwardMsg = NULL;
	}
	m_nFlags = 0;
	m_bBarFocus=FALSE;
	s_bLastWasKey=FALSE;
	s_bSuppressedMouseMove=FALSE;
	EndDefer();

	// The follow items are not reset.
	// m_rectScreen.SetRectEmpty(); 
	// m_sizeDesired = CSize(0,0) ;
	// m_bLargeToolbar = theApp.m_bLargeToolBars; //VerifySize handles in Display.
}

BEGIN_MESSAGE_MAP(CBMenuPopup, CWnd)
	//{{AFX_MSG_MAP(CBMenuPopup)
	ON_WM_ERASEBKGND()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_SYSKEYDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_KEYUP()
	ON_WM_PAINT()
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_TIMER()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
	
	ON_REGISTERED_MESSAGE(DSM_TESTMENU, OnTestMenu)

END_MESSAGE_MAP()

///////////////////////////////////////////////////////////
//
//
//
UINT CBMenuPopup::TrackDropDownMenu(int x, int y, 
									CWnd* pWnd, 
									LPCRECT lpRect /*= 0 */, 
									CRect rectAvoid, 
									CWnd* pWndMenuBar, /*= NULL */
									BOOL bSelectFirstItem, /*=FALSE*/
									BOOL *pbBarFocus,
									BOOL bReturnCmd
									)
{
	m_pWndMenuBar = pWndMenuBar ;
	m_bDropDown = TRUE;

	UINT nFlags=TPM_LEFTALIGN | TPM_LEFTBUTTON;
	if(bReturnCmd)
	{
		nFlags|=TPM_RETURNCMD;
	}

	UINT nCmd=TrackMenu(nFlags, x, y, pWnd, lpRect , rectAvoid, bSelectFirstItem) ;
	if(pbBarFocus)
	{
		*pbBarFocus=m_bBarFocus;
	}
	return nCmd;
}

///////////////////////////////////////////////////////////
//
//
//
UINT CBMenuPopup::TrackPopupMenu( UINT nFlags, int x, int y, 
				CWnd* pWnd, LPCRECT lpRect /*= 0 */)
{
	m_pWndMenuBar = NULL ; 
	m_bDropDown = FALSE ;
	return TrackMenu(nFlags, x, y, pWnd, lpRect) ;
}

// This function was duplicated and renamed rather than overloaded, 
// because of the default paramater and the
// potential for unwanted promotions from LPRECT to CRect.
UINT CBMenuPopup::TrackPopupMenuEx( UINT nFlags, int x, int y, 
				CWnd* pWnd, CRect rectAvoid, LPCRECT lpRect /*= 0 */)
{
	m_pWndMenuBar = NULL ; 
	m_bDropDown = FALSE ;
	return TrackMenu(nFlags, x, y, pWnd, lpRect, rectAvoid) ;
}

//
//
//
UINT CBMenuPopup::TrackMenu(UINT nFlags, int x, int y, 
							CWnd* pWnd, LPCRECT lpRect /*= 0 */, CRect rectAvoid,
							BOOL bSelectFirstItem /*=FALSE*/)
{
#if _DER
   if (!(nFlags & TPM_RIGHTALIGN))
      TRACE0("TPM_RIGHTALIGN ignored.\r\n") ;
   if (!(nFlags & TPM_RIGHTBUTTON))
      TRACE0("TPM_RIGHTBUTTON ignored\r\n") ;
   if (lpRect != 0)
      TRACE("lpRect ignored.\r\n") ;
#endif

   // Reset everything!
   Initialize() ;

   if(nFlags & TPM_RETURNCMD)
   {
		m_bReturnCmdID=TRUE;
   }

   // Set up the new stuff.
   m_pParentWnd = pWnd ; // Set Parent Windows for DoModal
   m_rectAvoid=rectAvoid;

	m_bSelectFirstItem=bSelectFirstItem;
	if (bSelectFirstItem)
	{
		s_bLastWasKey=TRUE;
	}

   if (!IsCustomizing())
   {
		DoModal(x, y);
   }
   else
   {
		Create(m_pParentWnd, CPoint(x,y));
   }

   return m_bReturnCmdID ? m_nPostCmdID : FALSE;
}

//
// Field Helpers
//


/////////////////////////////////////////////////////////////////////////////
// CBMenuPopup Virtual Overrides

LRESULT CBMenuPopup::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
   //TRACE("CBMenuPopup::OnUpdateCmdUI\r\n") ;
 //  CCmdTarget::OnUpdateCmdUI(pTarget, bDisableIfNoHndler) ;
   return 0L ;
}

/////////////////////////////////////////////////////////////////////////////
// CBMenuPopup Members

//
//
//
CBMenuItem* CBMenuPopup::GetMenuItem(int index)
{
   ASSERT( index >= 0) ;
   ASSERT( index < m_nMaxIndex) ;
   return m_MenuItems[index] ;
}


//
// Inserts an item before the menu at the index.
// If the index is negative, the item is appended to the end.
// 
void CBMenuPopup::AddMenuItem(int index, CBMenuItem* pMenuItem)
{
	// Add menu item to list.
   ASSERT( pMenuItem != NULL) ;

   if (index < 0)
   {
      m_MenuItems.SetAtGrow(m_nMaxIndex++, pMenuItem) ;
   }
   else
   {
      m_MenuItems.InsertAt(index, pMenuItem) ;
      m_nMaxIndex++ ;
   }
   m_nVisibleItems++;

   AdjustMenuSize(pMenuItem) ;

   // Menu has changed.
   ChangedByOnUpdate(TRUE) ;
}
///////////////////////////////////////////////////////////
//
// HitTest -	Determine which item on the menu contains
//				point pt. If will return HT_MISSED if there
//				the point isn't in any menu item. The point
//				may still be in the menu (ie scrolling area).
//		
//				See PtInMenu.
//
int CBMenuPopup::HitTest(CPoint pt)
{
	// first ensure we are inside menu
	CRect rectItems;
	GetItemsRect(&rectItems);
	if(!rectItems.PtInRect(pt))
	{
		return HT_MISSED;
	}
	
	// OPTIMIZATION Start with current index and ++ and -- first.   
	if ((m_nSelectedMenuItem != c_iNoItem) && 
		(m_MenuItems[m_nSelectedMenuItem]->HitTest(pt, 0)))
	{
		return HT_HITSELECTEDITEM ;
	}
	
	for(int i = 0 ; i < m_nMaxIndex ; i++)
	{
		if (i == m_nSelectedMenuItem) 
		{
			continue ;
		}

		// get offset rect for the item
		CRect rectItem=GetMenuItem(i)->m_rectFields[e_FieldAll];

		if(     rectItem.top>rectItems.top &&           // inside items region
			rectItem.bottom<rectItems.bottom &&     // inside items region
			rectItem.PtInRect(pt))
		{
			ASSERT(m_MenuItems[i]->HitTest(pt, 0));
			return i;
		}
	}

	return HT_MISSED ;
}

///////////////////////////////////////////////////////////
//
// PtInMenus -	This function checks to see if the point
//				is in any submenu or the menu bar. It uses
//				the client area.
//
//				This version is not recusive.
//
BOOL CBMenuPopup::PtInMenus(CPoint point)
{
#if 1
	// Mouse is relative to client area, convert to screen coords.
	CPoint ptScreen(point) ;
	ClientToScreen(&ptScreen);

	CRect rectMenu;
	// Check to see if the button was pressed in the menubar.
	if (m_pWndMenuBar != NULL && m_pWndMenuBar->GetSafeHwnd() != NULL)
	{
		// Get the menu bar's client rectangle
		m_pWndMenuBar->GetClientRect(&rectMenu) ;

		// Convet to screen coordinates
		m_pWndMenuBar->ClientToScreen(&rectMenu) ;
		if (rectMenu.PtInRect(ptScreen))
		{
			return TRUE ;
		}
	}

	// Now check to see if the point is in any of the subpopups.
	CBMenuPopup* pNextChildPopup = this ;
	while(pNextChildPopup != NULL)
	{
		if (pNextChildPopup->GetSafeHwnd() != NULL)
		{
			pNextChildPopup->GetWindowRect(&rectMenu) ;
			if (rectMenu.PtInRect(ptScreen))
			{
				return TRUE ;
			}
		}
		pNextChildPopup = pNextChildPopup->m_pChildPopup ;
	}
	return FALSE ;

#else
	HWND hWnd = ::WindowFromPoint(pt) ;
	if (hWnd == NULL)
	{
		return FALSE ;
	}

	// Check to see if the button was pressed in the menubar.
	if (m_pWndMenuBar != NULL && m_pWndMenuBar->GetSafeHwnd() == hWnd)
	{
		return TRUE ;
	}

	// Now check to see if the point is in any of the subpopups.
	CBMenuPopup* pNextChildPopup = this ;
	while(pNextChildPopup != NULL)
	{
		if (pNextChildPopup->GetSafeHwnd() == hWnd)
		{
			// We have found the window.
			return TRUE ;
		}
		pNextChildPopup = pNextChildPopup->m_pChildPopup ;
	}
	return FALSE ;
#endif
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::CalcMenuSize()
{
	// Zero cached widths.
	m_iHeight = c_iBorderSize*2;
	for (int i = 0 ; i < c_iNumFields ; i++)
	{
		m_iFieldWidths[i] = 0 ;
	}

	// Calc new widths.
	for(i = 0 ; i < m_nMaxIndex ; i++)
	{
		CBMenuItem* pItem = m_MenuItems[i] ;
		AdjustMenuSize(pItem) ;
	}

	// If there are no items, this might have just come about. 
	if(m_nMaxIndex==0)
	{
		// Resize the window
		if (m_hWnd != NULL)
			SetWindowPos(NULL, 0, 0, GetWidth(), GetWindowHeight(), SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE);
	}

}

//
// Checks to see if the toolbar button size has changed.
// If it has, it recalcs the size.
//
void CBMenuPopup::VerifyMenuSize(BOOL bAlways)
{
	if (m_bLargeToolbar != globalData.GetLargeMenuButtons() ||
		bAlways)
	{
		// We menus are now draw for the new size.
		m_bLargeToolbar = globalData.GetLargeMenuButtons();

		// Zero cached widths.
		m_iHeight = c_iBorderSize*2;
		for (int i = 0 ; i < c_iNumFields ; i++)
		{
			m_iFieldWidths[i] = 0 ;
		}


		// Recalc the new sizes for the menu.
		for(i = 0 ; i < m_nMaxIndex ; i++)
		{
			CBMenuItem* pItem = m_MenuItems[i] ;
			pItem->Sync() ; // Force the item to change its size and glyph
			AdjustMenuSize(pItem) ;
		}
	}
}

// MergeMenu
// Merge menu pSection into this menu at nPosition according to nFlags
// [paulde]
//
BOOL CBMenuPopup::MergeMenu(UINT nPosition, UINT nFlags, CBMenuPopup* pSection)
{
	// Get the index of the menu to insert before.
	int index = -1 ;
	if (nFlags & MF_BYPOSITION)
	{
		index = (int)nPosition ;
		if (index >= m_nMaxIndex)
			return FALSE ;
	}
	else
	{
		//BYCOMMAND
		index = GetMenuIndexForCommand(nPosition) ;
		if (index < 0) return FALSE ;
	}

	// insert elements
	pSection->m_MenuItems.SetSize(pSection->m_nMaxIndex); // set size so we don't insert empty items
	m_MenuItems.InsertAt(index, &pSection->m_MenuItems);  // copy pointers from pSection's
	m_nMaxIndex += pSection->m_nMaxIndex;
	m_nVisibleItems+=pSection->m_nMaxIndex;
    // remove all the entries from the source so we don't delete them twice
	pSection->m_MenuItems.RemoveAll();
	pSection->m_nMaxIndex = 0;

	// delete adjacent separators
	for (int i = m_nMaxIndex - 1; i > 0; i--)
	{
		if (CBMenuItem::MIT_Separator == m_MenuItems[i-1]->m_iItemType &&
			CBMenuItem::MIT_Separator == m_MenuItems[i  ]->m_iItemType)
		{
			DeleteMenu(MF_BYPOSITION, i);
		}
	}

	// recalculate size
	CalcMenuSize();

	// Menu has changed.
	ChangedByOnUpdate(TRUE) ;

	return TRUE;
}

//
//
//
//
void CBMenuPopup::AdjustMenuSize(CBMenuItem* pItem)
{
	// In most cases, there will not be a window around
	// when we call this function. However, we still need a DC.
	// First, check to see if we do have a window. If not, use
	// the MainWnd.

	CWnd* pWnd = NULL ;
	if (m_hWnd == NULL)
	{
		pWnd = AfxGetMainWnd() ;
	}
	else
	{
		pWnd = this ;
	}
	CClientDC dc(pWnd) ;

	// Get the widths from the item
	int* ItemWidths;
	pItem->GetWidths(&dc, &ItemWidths) ;

	// Only Name and Accel are variable. Optimization Possible.
	m_iFieldWidths[e_FieldButton] = max(m_iFieldWidths[e_FieldButton], ItemWidths[e_FieldButton]) ;
	m_iFieldWidths[e_FieldName] = max(m_iFieldWidths[e_FieldName], ItemWidths[e_FieldName]) ;
	m_iFieldWidths[e_FieldAccel] = max(m_iFieldWidths[e_FieldAccel], ItemWidths[e_FieldAccel]) ;
	m_iFieldWidths[e_FieldArrow] = max(m_iFieldWidths[e_FieldArrow], ItemWidths[e_FieldArrow]) ;
	m_iFieldWidths[e_FieldGap] = max(m_iFieldWidths[e_FieldGap], ItemWidths[e_FieldGap]) ;

#ifndef _FIELD_ALIGN_ACCEL_
	// Add the name and accel field together so we don't align
	int iNameAccelWidth = ItemWidths[e_FieldName] + ItemWidths[e_FieldAccel] ;
	if (ItemWidths[e_FieldAccel] > 0 ) 
	{
		// Add in the gap if there is an accelerator
		iNameAccelWidth += ItemWidths[e_FieldGap];
	} 	
	m_iFieldWidths[e_FieldNameAccel] = max(m_iFieldWidths[e_FieldNameAccel], iNameAccelWidth);
#endif


	// Get the height from the item
	m_iHeight += pItem->GetHeight(&dc) ;

	// Resize the window
	if (m_hWnd != NULL)
	{
		SetWindowPos(NULL, 0, 0, GetWidth(), GetWindowHeight(), SWP_NOZORDER|SWP_NOACTIVATE|SWP_NOMOVE);
		Invalidate();
	 }
}

//
//
//
int CBMenuPopup::GetMenuIndexForCommand(UINT nCmdId) const
{
   for (int i = 0 ; i < m_nMaxIndex ; i++)
   {
      if (m_MenuItems[i]->GetCmdID() == nCmdId)
      {
	 return i ;
      }
   }

   return -1 ;
}
///////////////////////////////////////////////////////////////////
//
// CMenu Similation Functions
//
BOOL CBMenuPopup::CreateMenu() 
{
	return TRUE;
}

BOOL CBMenuPopup::CreatePopupMenu(CWnd* pParentWnd) 
{
	/* Todo, determine popup status at display time! */
	//m_pParentWnd = pParentWnd ;
	//m_bSubPopup = TRUE  ;
	return TRUE;
}


BOOL CBMenuPopup::InsertMenu( UINT nPosition, 
			      UINT nFlags, 
			      UINT nIDNewItem /*= 0*/, 
			      LPCTSTR lpszNewItem /*= NULL*/,
			      CBMenuPopup* pSubPopup /*= NULL*/, 
				  BOOL bTransient /*=FALSE */) 
{
   // Get the index of the menu to insert before.
   int index ;
   if (nFlags & MF_BYPOSITION)
   {
		index = (int)nPosition ;
		if(index==m_nMaxIndex)
		{
		   index=-1;
		}

		if ((index >= m_nMaxIndex) || (index < -1))
		{
			return FALSE ;
		}
	  
	  // A -1 index means append menu. AddMenuItem handles appending.
   }
   else
   {
      //BYCOMMAND
      index = GetMenuIndexForCommand(nPosition) ;
      if (index < 0) return FALSE ;
   }

   // Build the menu items that we are inserting.

   ASSERT(!(nFlags & MF_OWNERDRAW)) ;
   if (nFlags & MF_OWNERDRAW) return FALSE ;
   ASSERT(!(nFlags & MF_BITMAP));
   if (nFlags & MF_BITMAP) return FALSE ;
   ASSERT(!(nFlags & MF_MENUBARBREAK));
   if (nFlags & MF_MENUBARBREAK) return FALSE ;
   ASSERT(!(nFlags & MF_MENUBREAK)) ;
   if (nFlags & MF_MENUBREAK) return FALSE ;

   // Menu has changed.
   // Not required - called by AddMenu... ChangedByOnUpdate(TRUE) ;

   BOOL bSeparator = FALSE ;
   BOOL bResult = FALSE ;
   CBMenuItem* pItem = new CBMenuItem;

   // If the item is a command that's really a menu, get its menu pointer
   CTE *pCTE=theCmdCache.GetCommandEntry(nIDNewItem);
   if(pCTE &&
	   (pCTE->flags & CT_MENU)!=0)
   {
	   //it's really a menu
	   pSubPopup=NULL;

	   nFlags |=MF_POPUP;
   }

   if (MF_SEPARATOR & nFlags)
   {
      bResult = pItem->CreateSeparator() ;
      bSeparator = TRUE ;
   }
   else
	{
	   CString strMenuItem;
	   if(lpszNewItem==NULL)
	   {
			theCmdCache.GetCommandString(nIDNewItem, STRING_MENUTEXT, &lpszNewItem);
			// must be copied
			strMenuItem = lpszNewItem;

			// get the accelerator for this item
			CString strKey;
			if (GetCmdKeyString(nIDNewItem, strKey))
			{
				strMenuItem += CString(_T("\t")) + strKey;
			}

			lpszNewItem=strMenuItem;
	   }

	   if (MF_POPUP & nFlags)
	   {
			ASSERT(lpszNewItem != 0) ;
			// 'real' menu commands are deferred, so that pSubPopup is null till it's needed
			ASSERT(pSubPopup != NULL ||
				(pCTE!=NULL && pCTE->flags & CT_MENU)) ;

			if(pSubPopup)
			{
				bResult = pItem->CreatePopup(this, pSubPopup, lpszNewItem) ;
			}
			else
			{
				bResult = pItem->CreatePopup(this, nIDNewItem, lpszNewItem) ;
			}
	   }
	   else 
	   {
		  // Assume its a string...MF_STRING == 0x0 ;
		  ASSERT(nIDNewItem != 0) ;
		  ASSERT(lpszNewItem != 0) ;
		  bResult = pItem->Create(this, nIDNewItem, lpszNewItem) ;
	   }
   }

   // Insert the menu item.
   if (bResult)
   {
	   if ((MF_CHECKED & nFlags) && !bSeparator)
	   {
		   pItem->Check(TRUE) ;
	   }
	   
	   if ((MF_GRAYED & nFlags) && !bSeparator)
	   {
		   pItem->Enable(FALSE) ;
	   }
	   
	   AddMenuItem(index,pItem) ; // Append to the end.
	   
	   // If the insert asked us to make it transient do so, otherwise, item will take default
	   if(bTransient)
	   {
		   pItem->m_bTransient=TRUE;
	   }
   }
   else
   {
	   // Cleanup...
	   delete pItem ;
   }
   return bResult ;
}

//
//
//
BOOL CBMenuPopup::AppendMenu(  UINT nFlags, 
			      UINT nIDNewItem /*= 0*/, 
			      LPCTSTR lpszNewItem /*= NULL*/,
			      CBMenuPopup* pSubPopup /*= NULL*/)
{
   return InsertMenu((UINT)-1, 
		     nFlags | MF_BYPOSITION,
		     nIDNewItem,
		     lpszNewItem,
		     pSubPopup); 
}

//
//
//
BOOL CBMenuPopup::ModifyMenu( UINT nPosition, 
			      UINT nFlags, 
			      UINT nIDNewItem /*= 0*/, 
			      LPCTSTR lpszNewItem /*= NULL*/,
			      CBMenuPopup* pSubPopup /*= NULL*/) 
{
   // DER WARNING: Only handles ModifyMenu in src/TextView.cpp

   // Get the index of the menu to modify.
   int index = -1 ;
   if (nFlags & MF_BYPOSITION)
   {
      index = (int)nPosition ;
      if (index >= m_nMaxIndex)
	 return FALSE ;
   }
   else
   {
      //BYCOMMAND
      index = GetMenuIndexForCommand(nPosition) ;
      if (index < 0) return FALSE ;
   }

   // Here's some of the things we can't handle

   ASSERT(!(nFlags & MF_OWNERDRAW)) ;
   if (nFlags & MF_OWNERDRAW) return FALSE ;
   ASSERT(!(nFlags & MF_BITMAP));
   if (nFlags & MF_BITMAP) return FALSE ;
   ASSERT(!(nFlags & MF_MENUBARBREAK));
   if (nFlags & MF_MENUBARBREAK) return FALSE ;
   ASSERT(!(nFlags & MF_MENUBREAK)) ;
   if (nFlags & MF_MENUBREAK) return FALSE ;

   int iNewItemType =  CBMenuItem::MIT_Unknown;
   if ((MF_SEPARATOR & nFlags) 
      && (m_MenuItems[index]->GetItemType() != CBMenuItem::MIT_Separator))
   {
      iNewItemType = CBMenuItem::MIT_Separator;
   }
   else if ((MF_POPUP & nFlags)
	    && (m_MenuItems[index]->GetItemType() != CBMenuItem::MIT_Popup))
   {
      iNewItemType = CBMenuItem::MIT_Popup ;
   }
   else if (m_MenuItems[index]->GetItemType() != CBMenuItem::MIT_Command)
   {
      iNewItemType = CBMenuItem::MIT_Command;
   }

   BOOL bResult = FALSE ;
   bResult = m_MenuItems[index]->ModifyItem(nIDNewItem, lpszNewItem, pSubPopup, iNewItemType);

   // Insert the menu item.
   if (bResult)
   {
      BOOL bSeparator = (m_MenuItems[index]->GetItemType() == CBMenuItem::MIT_Separator) ;
      if ((MF_CHECKED & nFlags) && !bSeparator)
      {
	 m_MenuItems[index]->Check(TRUE) ;
      }

      if ((MF_GRAYED & nFlags) && !bSeparator)
      {
	 m_MenuItems[index]->Enable(FALSE) ;
      }

      // Recalculate the size of the menu.
      CalcMenuSize() ;
   }
   return bResult ;

}

//
//
//
BOOL CBMenuPopup::DeleteMenu(UINT nPosition, UINT nFlags)
{
   int index = -1 ;
   if (nFlags & MF_BYPOSITION)
   {
      index = (int)nPosition ;
      if (index >= m_nMaxIndex)
	 return FALSE ;
   }
   else
   {
      //BYCOMMAND
      index = GetMenuIndexForCommand(nPosition) ;
      if (index < 0) 
	 return FALSE ;
   }

   CBMenuItem* pItem = m_MenuItems[index] ;
   if(  pItem->m_bVisible &&
		pItem->GetItemType()!=CBMenuItem::MIT_Separator) // separators don't count to the visible count anyway
   {
	   --m_nVisibleItems;
   }
   pItem->Release() ;
   m_MenuItems.RemoveAt(index) ;
   m_nMaxIndex-- ;
   CalcMenuSize() ;

   // Menu has changed.
   ChangedByOnUpdate(TRUE) ;

   return TRUE ;
}

//
//
//
int CBMenuPopup::GetMenuString(UINT nIDItem, 
		  CString& rString, 
		  UINT nFlags) const
{
   int index = -1 ;
   if (nFlags & MF_BYPOSITION)
   {
      index = (int)nIDItem ;
      if (index >= m_nMaxIndex)
	 return 0;
   }
   else
   {
      //BYCOMMAND
      index = GetMenuIndexForCommand(nIDItem) ;
      if (index < 0) 
	 return 0 ;
   }

   rString = m_MenuItems[index]->GetName();
   return rString.GetLength() ;
}

//
//
//

CBMenuPopup* CBMenuPopup::GetSubMenu(int nPos) const
{
   if (nPos < 0 || nPos >= m_nMaxIndex) 
      return NULL;

   if (m_MenuItems[nPos]->GetItemType() != CBMenuItem::MIT_Popup)
   {
      return NULL ;
   }

   return m_MenuItems[nPos]->GetPopup();
}

//
// Doesn't fully act like a Windows menu. Doesn't navigate popups...
// Doesn't do disabled.
//
UINT CBMenuPopup::EnableMenuItem(UINT nIDItem, UINT nFlags)
{
#if _DEBUG
	// Dale, you're a liar. This trace statement didn't correspond to your code. This is typical of 
	// your slipshod attitude. :( In fact, you fell over the crafty Windows people, who defined 
	// MF_ENABLED as 0. Nice people, eh?
   if (nFlags & MF_DISABLED)
      TRACE0("CBMenuPopup::EnableMenuItem doesn't do disable...graying instead.\r\n") ;
#endif

   int index = -1 ;
   if (nFlags & MF_BYPOSITION)
   {
      index = (int)nIDItem ;
      if (index >= m_nMaxIndex)
	 return (UINT)-1;
   }
   else
   {
      //BYCOMMAND
      index = GetMenuIndexForCommand(nIDItem) ;
      if (index < 0) 
	 return (UINT)-1 ;
   }

   return m_MenuItems[index]->Enable((nFlags & MF_DISABLED) ? FALSE : TRUE) ;

}

//
// Doesn't fully act like a Windows menu. Doesn't navigate popups...
// Doesn't do disabled.
//
// nShow is a boolean, possibly or-ed with MF_BYPOSITION
UINT CBMenuPopup::ShowMenuItem(UINT nIDItem, UINT nShow)
{
   int index = -1 ;
   if (nShow & MF_BYPOSITION)
   {
	   nShow &=~MF_BYPOSITION;
      index = (int)nIDItem ;
      if (index >= m_nMaxIndex)
	 return (UINT)-1;
   }
   else
   {
      //BYCOMMAND
      index = GetMenuIndexForCommand(nIDItem) ;
      if (index < 0) 
	 return (UINT)-1 ;
   }

   UINT nResult=m_MenuItems[index]->Show(nShow);

   CalcMenuSize();

   return nResult;
}

//
//
//
UINT CBMenuPopup::GetMenuItemID(int nPos)
{       
	ASSERT(nPos >= 0) ;
	ASSERT(nPos < m_nMaxIndex) ;

	switch(m_MenuItems[nPos]->GetItemType())
	{
	case CBMenuItem::MIT_Separator:
		return 0 ;
	case CBMenuItem::MIT_Popup:
		return -1;
	case CBMenuItem::MIT_Command:
		return m_MenuItems[nPos]->GetCmdID() ;
	default:
		ASSERT(0) ;
		return 0 ;
	}

}


///////////////////////////////////////////////////////////////////
//!!!!!!!!!!!!!!!!!!!!!!!!
// class private to this file
BOOL CBMenuPopup::IsCBMenuCmdUI(CCmdUI* pCmdUI)
{
   return (pCmdUI->m_pOther != NULL && 
	   (CBMenuPopup*)pCmdUI->m_pOther->IsKindOf(RUNTIME_CLASS(CBMenuPopup)) ) ;
}


class CBMenuItemCmdUI : public CCmdUI
{
public:
   virtual void Enable(BOOL bOn) ;
   virtual void SetCheck(int nCheck) ;
   virtual void SetText(LPCTSTR lpszText) ;
   virtual void SetRadio(BOOL bOn = TRUE) ;
};

void CBMenuItemCmdUI::Enable(BOOL bOn)
{
   CBMenuPopup* pMenu = (CBMenuPopup*)m_pOther ;
   ASSERT(pMenu->IsKindOf(RUNTIME_CLASS(CBMenuPopup))) ;
   pMenu->GetMenuItem(m_nIndex)->Enable(bOn) ;

   m_bEnableChanged=TRUE;
}

void CBMenuItemCmdUI::SetCheck(int nCheck)
{
   CBMenuPopup* pMenu = (CBMenuPopup*)m_pOther ;
   ASSERT(pMenu->IsKindOf(RUNTIME_CLASS(CBMenuPopup))) ;
   pMenu->GetMenuItem(m_nIndex)->Check(nCheck != 0 ) ; //DER: Indeterminate
}

void CBMenuItemCmdUI::SetText(LPCTSTR lpszText)
{
	// Get pointer to popup menu.
   CBMenuPopup* pMenu = (CBMenuPopup*)m_pOther ;
   ASSERT(pMenu->IsKindOf(RUNTIME_CLASS(CBMenuPopup))) ;

   // Get pointer to menu item and set the text.
   CBMenuItem* pMenuItem = pMenu->GetMenuItem(m_nIndex);
   pMenuItem->SetText(lpszText) ;
   pMenuItem->SetTextModified(TRUE);

   // Adjust the size of the menu for the new text.
   pMenu->CalcMenuSize() ;
}

void CBMenuItemCmdUI::SetRadio(int nCheck)
{
   //DER DO: Should use a dot.
   CBMenuPopup* pMenu = (CBMenuPopup*)m_pOther ;
   ASSERT(pMenu->IsKindOf(RUNTIME_CLASS(CBMenuPopup))) ;
   pMenu->GetMenuItem(m_nIndex)->Check(nCheck != 0 ) ; 
}


//!!!!!!!!!!!!!!!!!!!!!!!!
/////////////////////////////////////////////////////////////////////////////

//
//
//
//static int g_iCount = 0 ;

void CBMenuPopup::InitMenuPopup()
{
#if FIND_SLOW_CMDUI
	UINT nMaxCmdUI=1;
#endif

	//
	//
	// The following code was modified from CMainFrame::OnInitMenuPopup
	//
	//
	if (m_bDropDown)
	{
		MainFrameInitMenuPopup();
	}

	// OnCommandUpdate menu handlers can insert or delete menus. The 
	// code needs to handle this. First, we mark all menus as not having
	// been updated:
	for (int i = 0 ; i < m_nMaxIndex ; i++)
	{
		m_MenuItems[i]->Updated(FALSE) ;
	}
	// Also mark the menu as unchanged:
	ChangedByOnUpdate(FALSE) ;

	//
	//
	// The following code was stolen from MFC's CFrame::OnInitMenuPopup
	//
	//
   CBMenuItemCmdUI state ;
   state.m_pMenu = NULL ;
   state.m_pSubMenu = NULL ;
   state.m_nIndex = 0 ;
   state.m_nIndexMax = m_nMaxIndex ;

	state.m_pOther =  this ;
	state.m_nIndex = 0 ;

	// all items created during this period are transient
	s_bCreateTransients=TRUE;

	BOOL bFinished=FALSE;
	
	// Update each item, but only those that have not already been updated
	while (!bFinished && state.m_nIndex < state.m_nIndexMax)
	{
		CBMenuItem* pItem = m_MenuItems[state.m_nIndex] ;
		state.m_nID = pItem->GetCmdID() ;
		if ((state.m_nID == 0) || (pItem->Updated()) || (!pItem->IsVisible()))
		{
			state.m_nIndex++ ;
			continue ;
		}

		if (!IsCustomizing())
		{
			BOOL bAutoEnable = FALSE;
			
			if(m_bAutoEnable)
			{
				CWnd* pParentWnd = m_pParentWnd;
				while (pParentWnd != NULL)
				{
					if (pParentWnd->IsFrameWnd())
					{
						bAutoEnable = static_cast<CFrameWnd*>(pParentWnd)->m_bAutoMenuEnable;
						break;
					}
					pParentWnd = pParentWnd->GetParent();
				}
			}

			// Mark that the current menu item has been updated.
			pItem->Updated(TRUE) ;

#if FIND_SLOW_CMDUI
			int nTick=::GetTickCount();
#endif

			// Update Item
			state.DoUpdate(AfxGetMainWnd(), bAutoEnable && state.m_nID < 0xF000);

#if FIND_SLOW_CMDUI
			int nNewTick=::GetTickCount();

			UINT nDiffTick=nNewTick-nTick;

			// Trace if it's in the slowest 10%
			if((double) nDiffTick > (double) nMaxCmdUI * 0.9)
			{
				TRACE2("cbmenu@InitMenuPopup: Cmd %d took %d ticks.\n\r", state.m_nID, nDiffTick);
			}

			if(nDiffTick>nMaxCmdUI)
			{
				nMaxCmdUI=nDiffTick;
			}
#endif

			// adjust for menu deletions and additions
			// DoUpdate may change m_nMaxIndex...

			if (ChangedByOnUpdate())
			{
				// The menu has been changed by the on update command.
				// Start at the beginning of the menu and find the first item
				// which has not been updated. Inserted items are treated as updated.

				// Also mark the menu as unchanged:
				ChangedByOnUpdate(FALSE) ;

				int i = 0 ;

				while ((i < m_nMaxIndex) && m_MenuItems[i]->Updated())
				{
					i++ ;
				}

				if (i == m_nMaxIndex)
				{
					// We have done all items, so quit.
					bFinished=TRUE;
					break;
				}

				// i is the next item we should do.
				// Re-adjust the menu items...
				state.m_nIndex = i ;
				state.m_nIndexMax = m_nMaxIndex;
				

				// We don't need to increment the menu item, so..
				continue ;
			}
	   }
		else
		{
			// If the item is transient, then is should be disabled, as transients can't be dragged around.
			if(pItem->m_bTransient)
			{
				state.Enable(FALSE);
			}
			else
			{
				state.Enable(TRUE);
			}
		}

		// On to the next menu item
		state.m_nIndex++ ;
	}   

	// go back to creating normal menu items
	s_bCreateTransients=FALSE;
}

//
// CTestUI
//
// A miniature CCmdUI class which is used to determine whether a
// given submenu should be enabled or disabled (i.e. whether there
// are any enabled commands on the submenu).
//
// DER - 6 Jun 96 This class was copied from CMainFrame to do exactly what it is doing
// here. 
//
class CTestUI2 : public CCmdUI
{
public:
	CTestUI2()
	: m_bEnabled(FALSE)
	{}

	virtual void Enable(BOOL bEnabled = TRUE)
	{
		m_bEnabled = m_bEnabled || bEnabled;
	}

	virtual void SetCheck(int nCheck = 1) // 0, 1 or 2 (indeterminate)
	{}   

	virtual void SetRadio(BOOL bOn = TRUE)
	{}

	virtual void SetText(LPCSTR lpszText)
	{
		m_bEnabled = TRUE;
	}

	BOOL m_bEnabled;
};


//
//
// The following code was modified from CMainFrame::OnInitMenuPopup
//
//

void CBMenuPopup::MainFrameInitMenuPopup()
{
#if 0
   // If this is a system menu, do the default thing.  In order to
   // determine whether it's a SysMenu, however, we also have to check
   // the id of the first item, since maximized MDI child windows will
   // not have bSysMenu set for their system menus.
   // (-1 for menuitem means sub popup) -bm
   int nItem = pPopupMenu->GetMenuItemID(0);
   if (bSysMenu || (nItem != -1 && nItem > 0xf000 && nItem < 0xff00))
   {
      pPopupMenu->EnableMenuItem(SC_CLOSE,
	 !IsCustomizing() ? MF_ENABLED : MF_GRAYED);

      if (IsFullScreen())
      {
	 pPopupMenu->EnableMenuItem(SC_MAXIMIZE, MF_GRAYED);
	 pPopupMenu->EnableMenuItem(SC_MOVE, MF_GRAYED);
	 pPopupMenu->EnableMenuItem(SC_SIZE, MF_GRAYED);
      }
      else
	 ;  // Let the system enable/disable it.

      return;
   }
#endif ;


	// Cycle through all the items.  If it is a submenu, it should
	// be enabled only if it contains at least one enabled menu item.
	// Use the CTestUI class (derived from CCmdUI) to determine this.
	CWnd* pWnd = CWnd::FromHandle(theApp.GetActiveView());

	// also determine if this is the Window menu
	// and if the MDI window list is on the menu

	BOOL bWndMenu = FALSE;
	BOOL bMDIList = FALSE;

	for (int iItem = 0 ; iItem < GetMenuItemCount(); iItem++)
	{
		// This code kind of mixes CMenu style interaction with direct CBMenuItem access.
		CBMenuItem* pMenuItem = m_MenuItems[iItem] ;
		// -1 is a submenu
		if (pMenuItem->GetItemType() == CBMenuItem::MIT_Popup)
		{
			CBMenuPopup* pSubMenu = pMenuItem->GetPopup();
			if(pSubMenu)
			{
				CTestUI2 testUI;
				for (UINT i = 0 ; i < pSubMenu->GetMenuItemCount() ; i++)
				{
					testUI.m_nID = pSubMenu->GetMenuItemID(i);
					if (testUI.m_nID != ID_SEPARATOR)
					{
						if (pWnd != NULL)
							pWnd->OnCmdMsg(testUI.m_nID, CN_UPDATE_COMMAND_UI, (void*)&testUI, NULL);
						if (!testUI.m_bEnabled)
							this->OnCmdMsg(testUI.m_nID, CN_UPDATE_COMMAND_UI, (void*)&testUI, NULL);
					} //if
				} //for

				if (testUI.m_bEnabled)
					EnableMenuItem(iItem, MF_BYPOSITION | MF_ENABLED);
				else
					EnableMenuItem(iItem, MF_BYPOSITION | MF_GRAYED);
			}
			else
			{
				EnableMenuItem(iItem, MF_BYPOSITION | MF_ENABLED);
			}

		} // IF 

		// Get the command ID of the current menu item.
		int nID = m_MenuItems[iItem]->GetCmdID() ; //pPopupMenu->GetMenuItemID(iItem);
		// is this the Windows menu?
		// use ID_WINDOW_CASCADE to determine this
		if (nID == ID_WINDOW_CASCADE)
		{
			bWndMenu = TRUE;
		}
		// is the MDI window list on the menu?
		// 0xff00 is the ID of the first MDI child window menu item
		if (nID == 0xff00)
		{
			bMDIList = TRUE;
		}
	} // for

	// if this is the Window menu, remove More Windows...
	if (bWndMenu)
	{
		// (More Windows... )
		DeleteMenu(ID_WINDOW_LIST_DOCS, MF_BYCOMMAND);

		// only add a separator if there's no MDI window list
		// and a separator hasn't already been added
#if 0
		// !!! Review - needs to be fixed.
		if (!bMDIList && (m_MenuItems[GetMenuItemCount()- 1]->GetItemType() != CBMenuItem::MIT_Separator))
		{
			AppendMenu(MF_SEPARATOR);
		}
#endif

		// add the Doc List menu item to the end of the menu
		LPCTSTR lpszCommand;
		theCmdCache.GetCommandString(ID_WINDOW_LIST_DOCS, STRING_MENUTEXT,
		&lpszCommand);
		CString strMenuItem = lpszCommand;

		// get the accelerator for this item
		CString strKey;
		if (GetCmdKeyString(ID_WINDOW_LIST_DOCS, strKey))
		{
			strMenuItem += CString(_T("\t")) + strKey;
		}
		// add the menu item to the menu
		AppendMenu(MF_ENABLED, ID_WINDOW_LIST_DOCS, strMenuItem);

	
	/*
	Refresh the windows menu. 
	
	My first solution was to implement WM_MDIREFRESHMENU. However, the
	windows menu will get updated about THREE times whenever a window
	is added or removed. Two times is the same as v5. However, I would have
	had to add the third time below is not normal. The problem is that the
	first two times would have been wrong most of the time. Only the last
	one would be correct. Therefore, I skip MDIREFRESHMENU and do the
	right thing once. Anyway, here is the reason that this
	extra WM_MDIREFRESHMENU is sent. 

	Each MDI child window has an ID. This id starts at 0xFF00 and happens
	to be the same ID as the menu associated with it. When an MDI Child 
	Window is deleted, Windows decrements the ID of all MDI child windows 
	with an ID greater than the window being deleted. The window being deleted
	has its id changed to 0xFF00 + #ChildWindows. An internal count of the
	number of child windows is decremented.

	Windows then sends an WM_MDIREFESHMENU message. The code inside of windows
	using the internal count. However, I couldn't find anyway to get the internal 
	count of the number of child windows. If you use GetWindow or EnumWindows,
	you get all of the windows, since the pointers of the windows have not
	changed at this point.

	Btw, WM_MDIREFRESHMENU results into a call to the same internal windows
	function that WM_SETMENU does. 
	*/
	//CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	//ASSERT_KINDOF(CMainFrame, pMainFrame);
	//::SendMessage(pMainFrame->m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
	MdiRefreshMenu() ;

   }

   // Default processing to send UPDATE_COMMAND_UI messages.
   //CMDIFrameWnd::OnInitMenuPopup(pPopupMenu, 0, bSysMenu);
}

//
//
//
void MdiRefreshMenu()
{
	// don't refresh it if the window menu hasn't been created
	CBMenuPopup* pWindowsMenu = theCmdCache.GetMenu(IDM_MENU_WINDOW) ;
	
	if (pWindowsMenu == NULL)
	{
		return ;
	}
	
	// [multimon] 7 mar 97 - der - NOT TESTED
	//int cxScreen = ::GetSystemMetrics(SM_CXSCREEN);
	HWND hwnd = pWindowsMenu->m_hWnd ;
	if (hwnd == NULL)
	{
		hwnd = pWindowsMenu->GetParent()->m_hWnd ;
	}
	ASSERT(hwnd != NULL) ;
	int cxScreen = ::multiGetCXMetrics(hwnd) ;
	
	TEXTMETRIC tm;

	// determine maximum size of menu item we're willing to create
	{
		CDC dc;               
		dc.CreateCompatibleDC(NULL);

		// select the menu font
		CFont *pOldFont=dc.SelectObject(globalData.GetMenuFont(FALSE));

		dc.GetTextMetrics(&tm);

		// ensure that zero wasn't returned for some reason
		if(tm.tmAveCharWidth==0)
		{
			// arbitrary
			tm.tmAveCharWidth=15;
		}

		// clean up context
		dc.SelectObject(pOldFont);
	}

	// menu should be allowed to hold enough characters to fill half the screen
	int nMaxDisplayLength=(cxScreen/2)/tm.tmAveCharWidth;

	// small max len implies large fonts/small screen. Allow item to almost fill screen (90% fill)
	if(nMaxDisplayLength<10)
	{
		nMaxDisplayLength=(((double)cxScreen)*0.9)/(double)tm.tmAveCharWidth;

		ASSERT(nMaxDisplayLength>1);
	}

	// If we don't delete anything, insert at the end.
	UINT indexInsertBefore = (UINT)-1 ;  

	// Delete all of the windows currently listed in the menu.
	UINT index = 0 ;

	while(index < pWindowsMenu->GetMenuItemCount()) 
	{
		UINT id = pWindowsMenu->GetMenuItemID(index) ;
		if (id >= IDM_WINDOWS_BASE && id <= IDM_WINDOWS_LAST)
		{
			pWindowsMenu->DeleteMenu(index, MF_BYPOSITION) ;
			indexInsertBefore = index ;

			// We have just deleted an item from the array.
			// So don't increment the counter.
			continue ;
		}
		else if (id == ID_WINDOW_LIST_DOCS)
		{
			// We always want to insert before the Windows... menu item 
			// if it exists.
			indexInsertBefore = index ;
		}
		// Increment the count only if we haven't deleted something.
		index++ ;
	}

	// Get the list of windows. 
	// This code originated in COpenDocsDlg (opendocs.h|cpp)

	// iterate through all MDI windows except: FILTER_DEBUG | FILTER_PROJECT
	int nFilter = FILTER_PROJECT;
	CPartFrame* pMDIChild = theApp.MDITypedGetActive(nFilter, theApp.m_bWindowMenuSorted);

	// If there's not already a separator before the list of windows, add one
	CBMenuItem *pPrevItem=NULL;
	if(indexInsertBefore==-1)
	{
		int nItem=pWindowsMenu->GetMenuItemCount()-1;
		if(nItem>0)
		{
			pPrevItem=pWindowsMenu->GetMenuItem(nItem);
		}
	}
	else
	{
		pPrevItem=pWindowsMenu->GetMenuItem(indexInsertBefore-1);
	}

	if(pPrevItem->GetItemType()!=CBMenuItem::MIT_Separator)
	{
		pWindowsMenu->InsertMenu(   indexInsertBefore++, 
									MF_BYPOSITION | MF_SEPARATOR) ;
	}


	CString buf ;
	CString strTitle ;
	int iMenuId = IDM_WINDOWS_BASE;
	while (pMDIChild != NULL && iMenuId < IDM_WINDOWS_BASE+theApp.m_nWindowMenuItems)
	{
		// Get the name of this window.
		pMDIChild->GetWindowText(strTitle);
		if(strTitle.GetLength()> nMaxDisplayLength)
		{
			strTitle=strTitle.Left(nMaxDisplayLength)+" ...";
		}

		if(iMenuId - IDM_WINDOWS_BASE + 1<10)
		{
			buf.Format("&%d %s", (iMenuId - IDM_WINDOWS_BASE + 1)%10, strTitle);
		}
		else if (iMenuId - IDM_WINDOWS_BASE + 1==10)
		{
			buf.Format("1&0 %s", strTitle);
		}
		else
		{
			buf.Format("%s", strTitle);
		}

		pWindowsMenu->InsertMenu(   indexInsertBefore++, 
									MF_BYPOSITION | MF_STRING | MF_ENABLED,
									iMenuId++,
									buf, 
									NULL,
									TRUE); // menu item is a transient
		// get the next MDI window
		pMDIChild = theApp.MDITypedGetNext(pMDIChild, nFilter, theApp.m_bWindowMenuSorted);
	}
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::ShowSubPopup(int nItem)
{
	EndDefer();
	HideSubPopup();
	m_pChildPopup = m_MenuItems[nItem]->Expand(TRUE) ;
	m_nExpandedMenuItem=nItem;
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::HideSubPopup()
{
	EndDefer();
	if (m_nExpandedMenuItem != c_iNoItem)
	{
		m_pChildPopup = m_MenuItems[m_nExpandedMenuItem]->Expand(FALSE);
		m_nExpandedMenuItem=c_iNoItem;
	}
}

///////////////////////////////////////////////////////////
//
// finds the next visible item after the one specified
//
int CBMenuPopup::FindNextVisibleItem(int nIndex, BOOL bForward)
{
	int nNextVisible=-1;
	int iItem=nIndex;
	int nOffset=1;

	// determine direction
	if(!bForward)
	{
		nOffset=-1;
	}

	iItem+=nOffset;

	// iterate over menu
	while(  iItem>=0 &&
			iItem<m_nMaxIndex &&    // iterate all items
			nNextVisible==-1)               // until we find the answer
	{
		if(     m_MenuItems[iItem]->m_bVisible!=FALSE &&                                                        // visible item
			m_MenuItems[iItem]->GetItemType() != CBMenuItem::MIT_Separator) // that's not a separator
		{
			nNextVisible=iItem;
		}
		else
		{
			iItem+=nOffset;
		}
	}

	// check if we overran
	if(     iItem>=m_nMaxIndex ||
		iItem<0)
	{
		iItem=-1;
	}

	return iItem;
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::GetItemsRect(CRect *pRectItems)
{
	ASSERT(pRectItems);

	GetClientRect(pRectItems);

	// calculate top and bottom of the visible region
	if(m_bHasTopScroll)
	{
		pRectItems->top+=c_cyScrollAreaHeight;
	}
	if(m_bHasBottomScroll)
	{
		pRectItems->bottom-=c_cyScrollAreaHeight;
	}
}

///////////////////////////////////////////////////////////
//
// This is the easier one. User has caused the menu to be scrolled down, so we do so.
//
void CBMenuPopup::ScrollMenu(BOOL bForward, BOOL bEnd)
{
	ASSERT(m_bScrolling);

	// stop any pending scrolls or submenus
	EndDefer();
	// remove any existing submenus
	HideSubPopup();

	int cyOldTopOffset=m_cyTopOffset;

	// get the rectangle containing the items
	CRect rectOldItems;
	GetItemsRect(&rectOldItems);

	// handle case where we're showing the top item currently, so need to add the scroll arrow at the top
	if(!m_bHasTopScroll && bForward)
	{
		// when there's no top scroll, we should be at the top
		ASSERT(m_cyTopOffset==0);

		// add scroll arrow
		m_bHasTopScroll=TRUE;
		m_cyTopOffset+=c_cyScrollAreaHeight;

		// When we add the scroll arrow, we obscure the first item. Scrolling forward would leave us drawing the second item
		// right under the scroll arrow. But that would leave the user having not scrolled at all, just added an arrow. So we
		// do an extra scroll here
		int m_nOldTopIndex=m_nTopIndex;
		m_nTopIndex=FindNextVisibleItem(m_nTopIndex, bForward);

		// move the top index up to accomodate the new row
		m_cyTopOffset-=(m_MenuItems[m_nTopIndex]->m_rectFields[e_FieldAll].top - 
						m_MenuItems[m_nOldTopIndex]->m_rectFields[e_FieldAll].top);
	}

	if(!m_bHasBottomScroll & !bForward)
	{
		m_bHasBottomScroll=TRUE;

		// When we add the scroll arrow, we obscure the first item. Scrolling forward would leave us drawing the second item
		// right under the scroll arrow. But that would leave the user having not scrolled at all, just added an arrow. So we
		// do an extra scroll here
		int m_nOldTopIndex=m_nTopIndex;
		m_nTopIndex=FindNextVisibleItem(m_nTopIndex, bForward);

		// move the top index up to accomodate the new row
		m_cyTopOffset-=(m_MenuItems[m_nTopIndex]->m_rectFields[e_FieldAll].top - 
						m_MenuItems[m_nOldTopIndex]->m_rectFields[e_FieldAll].top);
	}

	BOOL bFinished=FALSE;

	do
	{
		// check if we've hit the end of the menu
		if(bForward)
		{
			if(GetHeight()+m_cyTopOffset < GetWindowHeight())
			{
				m_bHasBottomScroll=FALSE;
				bFinished=TRUE;
			}
		}
		else
		{
			if(m_nTopIndex==0)
			{
				m_cyTopOffset=0;
				m_nTopIndex=0;
				m_bHasTopScroll=FALSE;
				bFinished=TRUE;
			}
		}

		if(!bFinished)
		{
			// move to next visible item
			int m_nOldTopIndex=m_nTopIndex;
			m_nTopIndex=FindNextVisibleItem(m_nTopIndex, bForward);

			// move the top index up to accomodate the new row
			m_cyTopOffset-=(m_MenuItems[m_nTopIndex]->m_rectFields[e_FieldAll].top - 
							m_MenuItems[m_nOldTopIndex]->m_rectFields[e_FieldAll].top);

			if(!bEnd)
			{
				bFinished=TRUE;

				// check if we've hit the end of the menu
				if(bForward)
				{
					if(GetHeight()+m_cyTopOffset < GetWindowHeight())
					{
						m_bHasBottomScroll=FALSE;
					}
				}
				else
				{
					if(m_nTopIndex==0)
					{
						m_cyTopOffset=0;
						m_nTopIndex=0;
						m_bHasTopScroll=FALSE;
					}
				}
			}
		}
	} while(!bFinished);

	// redraw the whole menu REVIEW: Optimize.
	Invalidate();
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::ScrollMenuDown()
{
	ScrollMenu(TRUE, FALSE);
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::ScrollMenuUp()
{
	ScrollMenu(FALSE, FALSE);
}

///////////////////////////////////////////////////////////
//
// to first item at top
//
void CBMenuPopup::ScrollMenuTop()
{
	ScrollMenu(FALSE, TRUE);
}

///////////////////////////////////////////////////////////
//
// to last item at bottom
//
void CBMenuPopup::ScrollMenuBottom()
{
	ScrollMenu(TRUE, TRUE);
}

///////////////////////////////////////////////////////////
//
// make selected menu item scroll into view
// should only have to move by one, cos this is in response to an up or down key
//
void CBMenuPopup::EnsureSelectionScrolled()
{
	if(m_bScrolling && m_nSelectedMenuItem!=c_iNoItem)
	{
		if(m_nSelectedMenuItem<m_nTopIndex)
		{
			ScrollMenuUp();
		}
		else
		{
			if(m_nSelectedMenuItem>0)
			{
				CRect rectItems;
				GetItemsRect(&rectItems);
				int nPreviousItem=FindNextVisibleItem(m_nSelectedMenuItem, FALSE);
				CRect rectSelected=GetItemRect(m_nSelectedMenuItem);
				CRect rectPrevious=GetItemRect(nPreviousItem);
				int nError=rectSelected.top-rectPrevious.bottom;
				rectSelected.bottom-=nError;
				if(rectSelected.bottom>rectItems.bottom)
				{
					ScrollMenuDown();
				}
			}
		}
	}
}


///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::DeferShowSubPopup(int nItem)
{
	EndDefer();
	m_nCurrentTimer=SetTimer(c_iExpandTimerID,globalData.nMenuShowDelay,NULL);
	if(!m_nCurrentTimer)
	{
		ShowSubPopup(nItem);
	}
	else
	{
		m_nExpandDeferredItem=nItem;
	}
}

void CBMenuPopup::DeferHideSubPopup()
{
	EndDefer();
	m_nCurrentTimer=SetTimer(c_iContractTimerID,globalData.nMenuShowDelay,NULL);
	if(!m_nCurrentTimer)
	{
		HideSubPopup();
	}
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::DeferScrollMenuDown(BOOL bInitial)
{
	if(m_nCurrentTimer!=c_iScrollDownTimerID)
	{
		EndDefer();
		m_nCurrentTimer=SetTimer(c_iScrollDownTimerID,bInitial? c_nInitialScrollDelay : c_nScrollDelay,NULL);
		if(!m_nCurrentTimer)
		{
			// REVIEW: Need to delay somehow. Yuk!
			ScrollMenuDown();
		}
	}
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::DeferScrollMenuUp(BOOL bInitial)
{
	if(m_nCurrentTimer!=c_iScrollUpTimerID)
	{
		EndDefer();
		m_nCurrentTimer=SetTimer(c_iScrollUpTimerID,bInitial? c_nInitialScrollDelay : c_nScrollDelay,NULL);
		if(!m_nCurrentTimer)
		{
			// REVIEW: Need to delay somehow. Yuk!
			ScrollMenuUp();
		}
	}
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::EndScrollDefer(void)
{
	if(     m_nCurrentTimer==c_iScrollUpTimerID || 
		m_nCurrentTimer==c_iScrollDownTimerID)
	{
		// clever compiler could drop thru here...
		EndDefer();
	}
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::EndDefer(void)
{
	if(m_nCurrentTimer!=0)
	{
		KillTimer(m_nCurrentTimer);
		m_nCurrentTimer=0;
	}
}


///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::ForwardEndKey()
{
	if (m_nSelectedMenuItem != c_iNoItem)
	{
		m_MenuItems[m_nSelectedMenuItem]->Select(FALSE);

		// invalidate old item and
		InvalidateItem(m_nSelectedMenuItem);
	}

	if(m_bScrolling)
	{
		ScrollMenuBottom();
	}

	int nNextMenuItem = m_nMaxIndex-1; // ok to select disabled

	m_MenuItems[nNextMenuItem]->Select(TRUE);
	// change item and invalidate that
	m_nSelectedMenuItem = nNextMenuItem ;
	InvalidateItem(m_nSelectedMenuItem);
	UpdateWindow();
}

///////////////////////////////////////////////////////////
//
//
//
void CBMenuPopup::ForwardHomeKey()
{
   int nNextMenuItem = 0 ; // ok to select disabled

   if (m_nSelectedMenuItem != c_iNoItem)
   {
		m_MenuItems[m_nSelectedMenuItem]->Select(FALSE) ;
		InvalidateItem(m_nSelectedMenuItem);
   }

	if(m_bScrolling)
	{
		ScrollMenuTop();
	}

   m_MenuItems[nNextMenuItem]->Select(TRUE);

   // change item and invalidate that
   m_nSelectedMenuItem = nNextMenuItem ;
   InvalidateItem(m_nSelectedMenuItem);
   UpdateWindow();
}

//
//
//
void CBMenuPopup::ForwardDownKey()
{
	// Precondition
	if (m_nVisibleItems == 0)
	{
		return ;
	}

   int nNextMenuItem = m_nSelectedMenuItem + 1 ; // Okay, if no item selected.
   if (nNextMenuItem == m_nMaxIndex)
   {
      nNextMenuItem = 0 ;
	}

   while (m_MenuItems[nNextMenuItem]->GetItemType() == CBMenuItem::MIT_Separator ||
	      m_MenuItems[nNextMenuItem]->m_bVisible==FALSE)
   {
      nNextMenuItem++ ;
//      if (nNextMenuItem == m_nSelectedMenuItem)
//         return ; // In case all menu items are separators. 
		  // However, separators cannot be selected...

     if (nNextMenuItem == m_nMaxIndex)
	  {
	 nNextMenuItem = 0 ;
	  }
   }

   m_MenuItems[nNextMenuItem]->Select(TRUE);
   if (m_nSelectedMenuItem != c_iNoItem)
   {
      m_MenuItems[m_nSelectedMenuItem]->Select(FALSE) ;
   }
   // invalidate old item and
   if(m_nSelectedMenuItem!=c_iNoItem)
   {
		InvalidateItem(m_nSelectedMenuItem);
   }

	// change item and invalidate that
	m_nSelectedMenuItem = nNextMenuItem;
	// make sure that the selected menu item is scrolled onto the screen
	EnsureSelectionScrolled();

	InvalidateItem(m_nSelectedMenuItem);
	UpdateWindow();

}
//
//
//
void CBMenuPopup::ForwardUpKey()
{
	// Precondition
	if (m_nVisibleItems == 0)
	{
		return ;
	}

	int nNextMenuItem = m_nSelectedMenuItem - 1 ; // Okay, if no item selected.
	if (nNextMenuItem < 0)
	{
		nNextMenuItem = m_nMaxIndex - 1 ;
	}

   while (m_MenuItems[nNextMenuItem]->GetItemType() == CBMenuItem::MIT_Separator ||
	      m_MenuItems[nNextMenuItem]->m_bVisible==FALSE)
   {
      nNextMenuItem-- ;
      if (nNextMenuItem < 0)
      {
	 nNextMenuItem = m_nMaxIndex - 1 ;
      }
   }

   m_MenuItems[nNextMenuItem]->Select(TRUE);
   if (m_nSelectedMenuItem != c_iNoItem)
   {
      m_MenuItems[m_nSelectedMenuItem]->Select(FALSE) ;
	   InvalidateItem(m_nSelectedMenuItem);
   }

   m_nSelectedMenuItem = nNextMenuItem ;

	// make sure that the selected menu item is scrolled onto the screen
	EnsureSelectionScrolled();

   InvalidateItem(m_nSelectedMenuItem);
   UpdateWindow();
}
//
//
//
BOOL CBMenuPopup::ForwardRightKey()
{
	BOOL bPassToBar=FALSE;
	if(m_nSelectedMenuItem!=c_iNoItem)
	{
		int itemType = m_MenuItems[m_nSelectedMenuItem]->GetItemType();
		// Selected Item Should never be a separator.
		ASSERT(itemType != CBMenuItem::MIT_Separator) ; 

		if (itemType == CBMenuItem::MIT_Command)
		{
			// move to next item on menu bar, if such exists
			bPassToBar=TRUE;
		}
		else if (itemType == CBMenuItem::MIT_Popup)
		{
			if (!m_MenuItems[m_nSelectedMenuItem]->m_bGrayed)
			{
				InvalidateItem(m_nSelectedMenuItem);
				UpdateWindow();
				ShowSubPopup(m_nSelectedMenuItem);
			}
			else
			{
				// If the menu item is not enabled, pass it on to the menu bar as if its a command.
				bPassToBar=TRUE ;
			}
		}
	}
	else
	{
		// nothing is selected, and we got the right key. Someone is probably trying to move to 
		// this submenu having expose it with the mouse.
		ForwardDownKey();
	}

	return bPassToBar;
}

//
// CBMenuPopup - 
//    Returns the command to run. Pass command to Done, if its non-zero.
//
UINT CBMenuPopup::ForwardReturnKey()
{
	// might be called when no item is selected
	if(m_nSelectedMenuItem!=c_iNoItem)
	{
	   int itemType = m_MenuItems[m_nSelectedMenuItem]->GetItemType() ;
	   ASSERT(itemType != CBMenuItem::MIT_Separator) ;

	   if (itemType == CBMenuItem::MIT_Command)
	   {
		  return m_MenuItems[m_nSelectedMenuItem]->Click();
	   }
	   else if (itemType == CBMenuItem::MIT_Popup)
	   {
		   if(m_nExpandedMenuItem!=c_iNoItem)
		   {
			   HideSubPopup();
		   }
		   else
		   {
			   ShowSubPopup(m_nSelectedMenuItem);
		   }

			InvalidateItem(m_nSelectedMenuItem);
			UpdateWindow();
	   }
	}
	return 0;
}

//
// This function handles moving from one menu item to
// the next by typing the first letter.
//
//
UINT CBMenuPopup::ForwardCharKeyDown(TCHAR keychar, BOOL *pbUseCmd)
{
   UINT nCmdID = 0;
   ASSERT(pbUseCmd);
   *pbUseCmd=FALSE;
   int iNewSelection=-1;

   // Code here was copied from barcust.cpp; no way for these two to share code, as yet.

	// this is the case where we need to scan for accelerators - nasty, because we
	// have to scan for all that menu related crap, and we have to be sure that it'll 
	// work right on J systems, etc.

	// davidga tells me (martynl) that accelerators can only ever be sbcs, even in an
	// mbcs environment, which makes things somewhat simpler

	// we scan the menu for one full iteration, taking note of the number of times
	// we meet this accelerator, the first time we meet it, and the first time
	// we meet it when iButton is greater than the current iButton. If there is 
	// exactly one instance of this accelerator, then we drop it down. If there is
	// more than one, then we move to the next one after the current position,
	// wrapping around if appropriate.

	// martynl 24May96, and 27 Jun 96

	int iFirstFind=-1;  // first one (nearest start of bar)
	int iNextFind=-1;   // first one after current item (can be same as iFirstFind)
	int nFinds=0;       // total number of finds
	int nDisabledFinds=0; // number of finds which were disabled

	// Map numpad presses to normal presses
	if(LOBYTE(keychar)>=VK_NUMPAD0 && LOBYTE(keychar)<=VK_NUMPAD9)
	{
		// VK_0 === '0' etc
		keychar=HIBYTE(keychar)+LOBYTE(keychar)-VK_NUMPAD0+'0'; 
	}

	// this loop will terminate early once iNextFind is found - any button
	// after that would never get selected this tiem anyway
	for(int iButton=0; iButton<m_nMaxIndex && (iNextFind==-1 || nFinds<2); ++iButton)
	{
		if(m_MenuItems[iButton]->m_bVisible)
		{
			CString strLabel = m_MenuItems[iButton]->GetName() ;
			if (!strLabel.IsEmpty())
			{
				TCHAR chAccel=GLOBAL_DATA::ExtractAccelerator(strLabel);
				
				if(chAccel!=0)
				{
					if(tolower(chAccel)==tolower(LOBYTE(keychar)))
					{
						 if(m_MenuItems[iButton]->m_bGrayed)
						 {
							 ++nDisabledFinds;
						 }
						 else
						 {
							// same key - this is one
							++nFinds;

							if(iFirstFind==-1)
							{
								iFirstFind=iButton;
							}

							if(iNextFind==-1 &&
								iButton> m_nSelectedMenuItem)
							{
								iNextFind=iButton;
							}
						 }
					}
				}
			}
		}
	}

	// now know how many matches
	if(nFinds>0)
	{
		ASSERT(iFirstFind!=-1);
		// some matches, some action
		if(nFinds==1)
		{
			if(m_MenuItems[iFirstFind]->GetItemType()!=CBMenuItem::MIT_Popup)
			{
				// if it's a command, do it
				nCmdID = m_MenuItems[iFirstFind]->GetCmdID();
				*pbUseCmd=TRUE;
			}
			else
			{
				// if it's a submenu, show it
				ShowSubPopup(iFirstFind);
			}
			iNewSelection=iFirstFind;

		}
		else
		{
			// if there's one just after us, go for that
			if(iNextFind!=-1)
			{
				iNewSelection=iNextFind;
			}
			else
			{
				// otherwise, wrap around. 

				// Because we found more than one valid possibility, and because
				// iNextFind is -1, there must
				// be one other selection before iNextFind.
				iNewSelection=iFirstFind;
			}
		}
	}
	else
	{
		// if we hit a disabled item, we close the menu
		if(nDisabledFinds>0)
		{
			nCmdID=0;
			*pbUseCmd=TRUE;
		}
	}

	if(iNewSelection!=-1)
	{
		m_MenuItems[iNewSelection]->Select(TRUE);
		if (m_nSelectedMenuItem != c_iNoItem)
		{
			m_MenuItems[m_nSelectedMenuItem]->Select(FALSE) ;
			InvalidateItem(m_nSelectedMenuItem);
		}
		m_nSelectedMenuItem = iNewSelection;

		// make sure that the selected menu item is scrolled onto the screen
		EnsureSelectionScrolled();

		InvalidateItem(m_nSelectedMenuItem);
		UpdateWindow();
	}

	return nCmdID;
}


//
//
//
CBMenuPopup* CBMenuPopup::FindLastChild()
{
	CBMenuPopup* pLastChild = this;      
	while (pLastChild->m_pChildPopup != NULL)
	{
		pLastChild = pLastChild->m_pChildPopup ;
	}
	return pLastChild ;
}


//
//
//
CBMenuPopup* CBMenuPopup::FindNextToLastChild()
{
	CBMenuPopup* pLastChild = this;      
	CBMenuPopup* pNextToLastChild = this ;
	while (pLastChild->m_pChildPopup != NULL)
	{
		pNextToLastChild = pLastChild ;
		pLastChild = pLastChild->m_pChildPopup ;
	}
	return pNextToLastChild ;
}
///////////////////////////////////////////////////////////////////////////////
//
//					Modal Message Loop Section
//
BOOL CBMenuPopup::ContinueModal()
{
	return m_bContinueModal ;
}

/////////////////////////////////////////////////////////////////////////////
//
//	DoModel
//
// DoModal is copied from CPropertySheet, but HEAVILY modified.
//
void CBMenuPopup::DoModal(int x, int y) 
{
	ASSERT_VALID(this);
	ASSERT(m_hWnd == NULL);

	// no menu, no dice
	if(m_nMaxIndex==0)
	{
		return ;
	}

	// MSL - now allows reinit
	m_bContinueModal=TRUE;

	// find parent HWND
	ASSERT(m_pParentWnd != NULL) ;

	HWND hParentWnd = _SushiGetSafeOwner(m_pParentWnd);

	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
	{
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);
	}

	// Hide caret
	CWnd *pWndFocus=GetFocus();
	if(pWndFocus)
	{
		pWndFocus->HideCaret();
	}

	if (!Create(m_pParentWnd, CPoint(x,y)) )
	{
		return ;
	}

	// disable the IME inside the menu
	imeEnableIME( NULL, FALSE );

	// setup for modal loop and creation
	SetCapture() ;

	// Get/Set Cursor
	HCURSOR hCursor = ::GetCursor() ;
	::SetCursor(::LoadCursor(NULL, IDC_ARROW));

	// Signal that we are entering the menu loop.
	AfxGetMainWnd()->SendMessage(WM_ENTERMENULOOP, !m_bDropDown, 0) ;

	// Signal that we are opening a popup menu.
	AfxGetMainWnd()->SendMessage(WM_MENUSELECT, MAKELONG(0, MF_POPUP), NULL) ;

	// If from keyboard, select the first item
	if(m_bSelectFirstItem)
	{
		SelectFirstItem();
	}

	// Pump the messages.
	MessageLoop();

	::SetCursor(hCursor);

	// hide the window before enabling parent window, etc.
	if (m_hWnd != NULL)
	{
		SetWindowPos(NULL, 0, 0, 0, 0, SWP_HIDEWINDOW|
			SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
	}
	if(GetCapture()==this)
	{
		::ReleaseCapture();
	}

	// cleanup
	DestroyWindow();

	// Signal that we are closing the menu. 
	// Sub popups don't send this message. 
	AfxGetMainWnd()->SendMessage(WM_MENUSELECT, MAKELONG(0, 0xFFFF), NULL) ;

	// Signal that we are done with the modal loop.
	AfxGetMainWnd()->SendMessage(WM_EXITMENULOOP, !m_bDropDown, 0) ;

	// Send the command.
	if(m_nPostCmdID != 0 && !m_bReturnCmdID)
	{
		// Only send the command if 
		//   1) It is NOT 0. 
		//   2) The caller wants it sent and doesn't want the command choosen.
		MyPlaySound("MenuCommand", NULL, SND_ASYNC | SND_NODEFAULT) ;
		m_pParentWnd->PostMessage(WM_COMMAND, m_nPostCmdID);
	}

	// enable the IME 
	imeEnableIME( NULL, TRUE );

	// reshow the caret
	if(pWndFocus)
	{
		pWndFocus->ShowCaret();
	}

	// We may have clicked outside of the menu and we need to forward the mouse
	// down message to the window with the point in it. 
	// We will do this regardless of the state of m_nPostCmdID or m_bReturndCmdId.
	// If we have a forward message, we should forward it...
	if (m_pForwardMsg != NULL)
	{
		ASSERT(m_nPostCmdID == 0) ;

		// Forward the mouse down or other messages on to the application.
		m_pForwardMsg->Send(hWndCapture) ;

		delete m_pForwardMsg ;
		m_pForwardMsg = NULL ;
	}

	return;
}

void CBMenuPopup::Done(UINT nCmdID /*= NULL*/) 
{
	ASSERT(!m_bSubPopup) ; 
	m_nPostCmdID = nCmdID; 
	m_bContinueModal = FALSE;

	if (IsCustomizing())
	{
		DestroyWindow();
	}

	if(m_pChildPopup)
	{
		HideSubPopup();
	}

	if (m_pWndMenuBar != NULL)
	{
		// nasty !!! temp fix. Tell the menu bar to give up on tracking
		CCustomBar *pBar=(CCustomBar *)m_pWndMenuBar;

		pBar->MenuDone();
	}
}


///////////////////////////////////////////////////////////
//
//	MessageLoops - This is the popup menu/menu bar's message pump
//
void CBMenuPopup::MessageLoop()
{
	MSG msg;
	MSG* pMsg = &msg ;

	ASSERT(::IsWindow(m_hWnd)); // window must be created
	ASSERT(!IsCustomizing());
	ASSERT_VALID(this);

	HWND hWndParent = ::GetParent(m_hWnd);
	BOOL bSendEnterIdle = TRUE ;

	while(ContinueModal())
	{
		//
		// Part 1: If there are no messages then wait.
		//

		// Peek at the message. Do Not remove it.
		if (!::PeekMessage(pMsg, NULL, NULL, NULL, PM_NOREMOVE))
		{
			if (bSendEnterIdle)
			{
				// There are no messages. Do idle processing.
				if (hWndParent != NULL)
				{
					::SendMessage(hWndParent, WM_ENTERIDLE, MSGF_MENU, (LPARAM)m_hWnd);
					bSendEnterIdle = FALSE ;
				}
			}
			else
			{
				// Wait until there is a message in the queue
				bSendEnterIdle = TRUE ; 
				WaitMessage() ;
			}

			// Restart the loop.
			continue ;
		}

		//
		// Part 2: Check for certain messages WITHOUT REMOVING them from the queue.
		//

		switch(pMsg->message)
		{
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		//case WM_NCLBUTTONDOWN:
		//case WM_NCRBUTTONDOWN:
			// Check to see if the point is in the menu. If is is we continue as normal.
			// If it is not in the window, we get out of here without eating the message.
			// Windows should then send the message to the correct window.
			{
				CPoint pt((DWORD)pMsg->lParam);
				if (!PtInMenus(pt))
				{
					Done() ; // Kind of funny that we are done, but continuing :-)
					continue ;
				}
			}
			break;

		case WM_QUIT:
			Done();		
			continue ;
			break ;
		};

		//
		// Part 3: Remove and process the message. If the message is a keyboard key, steal
		//			it because we do not have the focus.
		//

		// Make sure that we pull off the same message we peeked at above.
		::PeekMessage(pMsg, NULL, pMsg->message, pMsg->message, PM_REMOVE) ;

		// Let's steal the keyboard messages.
		switch(pMsg->message)
		{
		case WM_KEYDOWN:
			OnKeyDown(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam)) ; //AfxSig_vwww
			break ;
		case WM_SYSKEYDOWN:
			OnSysKeyDown(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam)) ; //AfxSig_vwww
			break ;
		case WM_SYSKEYUP:
			// Munch Munch
			break ;
		case WM_KEYUP:
			OnKeyUp(pMsg->wParam, LOWORD(pMsg->lParam), HIWORD(pMsg->lParam)) ; //AfxSig_vwww
			break ;
		case WM_SYSCHAR:
		case WM_CHAR:
			TRACE0("CBMenuPopup::MessageLoop: Why are we getting char's?\r\n") ;
			// Munch Munch
			break ;
		case WM_SYSDEADCHAR:
		case WM_DEADCHAR:
			//{REVIEW} Is is okay to eat These chars? or should the be translated?
			TRACE0("CBMenuPopup::MessageLoop: We are eating dead chars?\r\n") ;
			// Munch Munch
			break ;
		case WM_KICKIDLE:
			// Munch Munch
			break ;
		default:
			::TranslateMessage(pMsg);
			::DispatchMessage(pMsg);
			break ;
		}
	}

    // Throw in an extra peek here when we exit the menu loop to ensure that the input queue
    // for this thread gets unlocked if there is no more input left for him.
    ::PeekMessage(pMsg, NULL, WM_MOUSEMOVE, WM_MOUSEMOVE, PM_NOREMOVE);

	return ;
}


/////////////////////////////////////////////////////////////////////////////
// 
//						CBMenuPopup message handlers
//
/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
BOOL CBMenuPopup::Create(CWnd* pParentWnd, POINT pt, BOOL bSubPopup /*= FALSE*/, CRect* prectAvoid /*=NULL*/) 
{
	if (pParentWnd != NULL)
		ASSERT_VALID(pParentWnd);   // must have a parent

	// If this is a SubPopup, then reset all of the variables.
	// Non-subpopups are initialized in TrackPopupMenu.
	if (bSubPopup)
	{
		Initialize() ;
	}

	// Set the avoid rectangle.
	if (prectAvoid != NULL)
	{
		m_rectAvoid = *prectAvoid ;
	}

	// Set up members
	m_pParentWnd = pParentWnd ;
	m_bSubPopup = bSubPopup ;

   VerifyMenuSize(FALSE);
   InitMenuPopup() ;

	// Adjust x,y so menu will fit on screen.
   	/* [multimon] 7 mar 97 - der
	The menu avoidance code was modified for the 5x product to support 
	multiple monitors. Instead of using 0 - cxScreen & 0 - cyScreen for
	the screen boundaries, we use the rectMonitor string. Therefore,
	rectMonitor.top replaced 0 and rectmonitor.bottom replaced cyScreen in
	most cases.

	Note, that we do not use:
		::GetMonitorRect(m_pParentWnd->GetSafeHwnd(), &rectMonitor, TRUE) ;
	because this does not really give us control over which monitor things
	are going to appear on. The monitor corresponding to a window is the 
	monitor which contains most of that window. So, just move a window so
	that a little more than half is on one monitor and suddenly that becomes
	the primary monitor. It is better to use a point.
	*/
	CRect rectMonitor ;
	::multiMonitorRectFromPoint(pt, &rectMonitor, c_fWork) ;

	// [multimon] 7 mar 97 - der
	//int cxScreen = ::GetSystemMetrics(SM_CXSCREEN) ;
	//int cyScreen = ::GetSystemMetrics(SM_CYSCREEN) ;

	//NOTE that c?Screen is always positive.
	int cxScreen = abs(rectMonitor.Width()) ;
	int cyScreen = abs(rectMonitor.Height()) ;


   // Did this bit get complicated, or what? :) :)
   CPoint ptCenterSource=m_rectAvoid.CenterPoint();

   BOOL bXBeforeCenter=pt.x<ptCenterSource.x;
   BOOL bYBeforeCenter=pt.y<ptCenterSource.y;

   if(m_rectAvoid.Width()!=0 || m_rectAvoid.Height()!=0)
   {
	   // True if we've already detected and resolved an X direction problem
	   BOOL bXMoved=FALSE;
	   // True if we've already detected and resolved a Y direction problem
	   BOOL bYMoved=FALSE;

	   // Rect which we will skip to overlap - the 2 pixels is the amount of overlap we will tolerate in silence.
	   CRect rectRealAvoid=m_rectAvoid;
	   rectRealAvoid.top+=2;
	   rectRealAvoid.bottom-=2;
	   rectRealAvoid.left+=2;
	   rectRealAvoid.right-=2;

	   // Before we start moving the menu, we should ensure that it has enough theoretical vertical space.

	   // if the menu is currently below the button, rather than to its right
	   if(bXBeforeCenter)
	   {
		   // if the menu won't fit above or below the avoid area, then we need to move it diagonally
		   if(  pt.y+GetHeight() > rectMonitor.bottom &&                  // check below
				pt.y-m_rectAvoid.Height()-GetHeight() < rectMonitor.top) // check above
		   {
			   pt.x+=m_rectAvoid.Width();
			   pt.y-=m_rectAvoid.Height();

			   bXBeforeCenter=FALSE;
		   }
	   }

	   // We want first to attempt to move the button in the direction that will cause it to cross its
	   // center point forward (i.e. down or right); then we handle the other case. The reason for this is that
	   // moving the menu backwards across its center point involves the menu dislocating further, and makes it
	   // hard for the user to continue their expected drag.

	   // There are up to four passes of this loop
	   // 0: Checks and moves in the nice-move direction (described above)
	   // 1: Checks and moves in the not nice move direction
	   // 2: If the above have failed, try to move again in the same direction as 0
	   // 3: If the above have failed, try to move again in the same direction as 1
	   for(int i=0; i<4; ++i)
	   {
		   if((bXBeforeCenter && (i==0 || i==2)) ||
			  (!bXBeforeCenter && (i==1 || i==3)))
		   {
			   // We only move if we haven't moved and we're either in a bad position or at a stage of the game where we're desperate.
				if (!bXMoved &&
					(pt.x + GetWidth() > rectMonitor.right || i>1))
				{
					//Menu too wide. Put pt on the left side.
					pt.x -= GetWidth();

					if(bXBeforeCenter)
					{
						pt.x += m_rectAvoid.Width();
					}
					else
					{
						pt.x -= m_rectAvoid.Width();
					}
					bXMoved=TRUE;
					// MSL ASSERT( pt.x >= 0) ; //Menu too wide for screen!
				}
		   }
		   else
		   {
			   // We only move if we haven't moved and we're either in a bad position or at a stage of the game where we're desperate.
				if (!bYMoved &&
					(pt.y + GetHeight() > rectMonitor.bottom || i>1))
				{
					// Menu too tall for position.
					pt.y -= GetHeight();
					if(bYBeforeCenter)
					{
						pt.y += m_rectAvoid.Height();
					}
					else
					{
						pt.y -= m_rectAvoid.Height();
					}
					bYMoved=TRUE;
					// MSL ASSERT(pt.y >= 0 ) ; // Put in scrolling arrow...
				}
		   }

		   CRect rectTest;

		   // After we've done the initial adjustments, we only continue looping if we've got an intersection between
		   // the avoidance rectangle and the menu rectangle. Because the menu will probably want to slightly overlap
		   // the button that drops it, we 
		   if(i>=1 &&
			   !rectTest.IntersectRect(rectRealAvoid, CRect(pt.x, pt.y, pt.x+GetWidth(), pt.y+GetHeight())))
		   {
			   //we're done - the menu is in place
			   break;
		   }
	   }
	}


   // If the menu is now positioned off screen
	if( (pt.y < rectMonitor.top) || (pt.y+GetHeight() > rectMonitor.bottom))  // is off screen
	{
		if(GetHeight() < cyScreen)                                        // might fit vertically
		{
			if(pt.y < rectMonitor.top)
			{
				pt.y = rectMonitor.top;
			}
			else
			{
				pt.y=rectMonitor.bottom-GetHeight();
			}
			// don't need to check avoid rectangle because, in this case, we can be sure that we won't overlap it. If we would have
			// we would have made the diagonal move before the loop.
		}
		else
		{
			// too tall for the screen, just make sure the top is visible
			pt.y = rectMonitor.top;

			m_bScrolling=TRUE;
			m_bHasBottomScroll=TRUE;
		}
	}

	// [multimon] - 7 mar 97 - der	
	// If the menu is now positioned off screen
	if((pt.x < rectMonitor.left) || (pt.x + GetWidth() > rectMonitor.right) )  // is off screen
	{
		if(GetWidth() < cxScreen)                                         // might fit vertically
		{
			if(pt.x < rectMonitor.left)
			{
				pt.x = rectMonitor.left;
			}
			else
			{
				pt.x = rectMonitor.right - GetWidth();
			}
			// don't need to check avoid rectangle because, in this case, we can be sure that we won't overlap it. If we would have
			// we would have made the diagonal move before the loop.
		}
		else
		{
			// too wide for the screen, just make sure the left is visible
			pt.x = rectMonitor.left ;
		}
	}

	int nStyle=CS_SAVEBITS ;
	
	LPCTSTR szWndClass = AfxRegisterWndClass( nStyle ,LoadCursor(NULL, IDC_ARROW),
		(HBRUSH)(COLOR_BTNFACE + 1), NULL);
	
	DWORD dwStyle = WS_POPUP ; 
	DWORD dwExStyle=0;
	if(!IsCustomizing())
	{
		dwExStyle|= WS_EX_TOPMOST ; 
	}
	
	if (!CWnd::CreateEx(dwExStyle, szWndClass, NULL, dwStyle, 
		pt.x, pt.y, 
		GetWidth(), GetWindowHeight(),
		pParentWnd->GetSafeHwnd(),// Try again m_bSubPopup ? pParentWnd->GetSafeHwnd() : NULL, // BUG 1270
		NULL))
	{
		return FALSE;
	}

	MyPlaySound("MenuPopup", NULL, SND_ASYNC | SND_NODEFAULT) ;

	// To get the focusing set correctly, we should not activate the new
	// window. The window with the current focus, should not lose that focus.
	// We will get the keyboard by stealing the messages in MessageLoop.
	::SetWindowPos(GetSafeHwnd(), HWND_TOP, 
					pt.x, pt.y, 0, 0,
					SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

	return TRUE ;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	Don't Erase Background
//
BOOL CBMenuPopup::OnEraseBkgnd(CDC* pDC) 
{
   return TRUE ;
	//return CWnd::OnEraseBkgnd(pDC);
}

/////////////////////////////////////////////////////////////////////////////
// 
//	MouseMove
//
void CBMenuPopup::OnMouseMove(UINT nFlags, CPoint point) 
{
	CPoint ptScreen=point;
	ClientToScreen(&ptScreen);
	int nXMove=ptScreen.x-s_ptLastMove.x;
	int nYMove=ptScreen.y-s_ptLastMove.y;

	if(nXMove>=-2 && nXMove<=2 && nYMove>=-2 && nYMove<=2)
	{
		// NOTE: don't update s_ptLastMove here, otherwise slow movement wouldn't register
		return;
	}
	else
	{
		s_ptLastMove=ptScreen;
	}

	DoMouseMove(nFlags, point); 
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::SelectExpanded(void)
{
	if(m_nExpandedMenuItem!=c_iNoItem)
	{
		EndDefer();

		if(m_nSelectedMenuItem!=m_nExpandedMenuItem)
		{
			if(m_nSelectedMenuItem!=c_iNoItem)
			{
				m_MenuItems[m_nSelectedMenuItem]->Select(FALSE) ;
				InvalidateItem(m_nSelectedMenuItem);
			}
			m_nSelectedMenuItem=m_nExpandedMenuItem;
			m_MenuItems[m_nSelectedMenuItem]->Select(TRUE) ;
			InvalidateItem(m_nSelectedMenuItem);
			UpdateWindow();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::DoScroll(CPoint point, BOOL bInitial)
{
	if(m_bScrolling)
	{
		BOOL bDeferred=FALSE;
		CRect rectClient;
		GetClientRect(&rectClient);

		// if we're in the menu
		if(     point.x>rectClient.left && 
			point.x< rectClient.right)
		{
			// are we in the top part
			if(m_bHasTopScroll)
			{
				if(point.y<c_cyScrollAreaHeight)
				{
					DeferScrollMenuUp(bInitial);
					bDeferred=TRUE;
				}
			}

			// of in the bottom
			if(m_bHasBottomScroll)
			{
				if(point.y > rectClient.bottom-c_cyScrollAreaHeight)
				{
					DeferScrollMenuDown(bInitial);
					bDeferred=TRUE;
				}
			}
		}
		
		if(!bDeferred)
		{
			// if we move out of the scroll area, don't defer any more
			EndScrollDefer();
		}
	}

}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
int CBMenuPopup::DoMouseMove(UINT nFlags, CPoint point)
{
	// Suppress the very first move that arrives at a menu, since it will spuriously deflect keyboard control
	if(s_bLastWasKey && !s_bSuppressedMouseMove)
	{
		s_bSuppressedMouseMove=TRUE;
		return cMoveHandled;
	}

	DoScroll(point, TRUE);

	// dropdown's don't track in customization mode
	if(!IsCustomizing())
	{
		if (m_pChildPopup != NULL)
		{
			// Give child popup a chance to handle mouse
			CPoint ptChild(point) ;
			ClientToScreen(&ptChild) ;
			m_pChildPopup->ScreenToClient(&ptChild) ;

			int rv=m_pChildPopup->DoMouseMove(nFlags, ptChild);
			if(rv & cMoveSelectExpanded)
			{
				SelectExpanded();
			}
			if(rv & cMoveHandled)
			{
				// Child handled the mouse move message.
				return rv;
			}
		}
	
		int nMenuIndexHit = HitTest(point) ;

	   // We hit the currently selected item. 
	   if (HT_HITSELECTEDITEM == nMenuIndexHit )
	   {
		  return cMoveHandled + cMoveSelectExpanded ; // Signal done.
	   }
	
		// If we have hit an item, and it is a separator, return that we are done.   
		if ((nMenuIndexHit >=0) && 
		  (m_MenuItems[nMenuIndexHit]->GetItemType() == CBMenuItem::MIT_Separator))
		{
			s_bLastWasKey=FALSE;
			return cMoveHandled + cMoveSelectExpanded ;
		}
	
		//
		// Unselect selected item if it's outside and we're the lowest level menu, or we've hit something in ourselves
		//
		if (m_nSelectedMenuItem != c_iNoItem &&
		   ((!s_bLastWasKey && m_pChildPopup==NULL) || nMenuIndexHit>=0))
		{
			m_MenuItems[m_nSelectedMenuItem]->Select(FALSE);

			if (CBMenuItem::MIT_Popup == m_MenuItems[m_nSelectedMenuItem]->GetItemType())
			{
				// if we've just moved off of the expanded item, defer hiding it for a short while
				if(m_nExpandedMenuItem==m_nSelectedMenuItem)
				{
					DeferHideSubPopup();
				}
			}

			InvalidateItem(m_nSelectedMenuItem);
			m_nSelectedMenuItem = c_iNoItem;
		}

	   // If we have missed, we want the current item unselected.
	   if (HT_MISSED == nMenuIndexHit)
	   {
			// Mouse is not on a menu item. 
			if (m_pWndMenuBar != NULL)
			{
			   // We have been dropped down by a "menu bar".
			   // Therefore, we will forward the mouse message to the menubar.

			   // Covert mouse to client coordinates of the menubar.
				CPoint ptMenuBar(point) ;
				ClientToScreen(&ptMenuBar) ;
				m_pWndMenuBar ->ScreenToClient(&ptMenuBar);
				m_pWndMenuBar->SendMessage(WM_MOUSEMOVE, (WPARAM)nFlags, MAKELPARAM(ptMenuBar.x, ptMenuBar.y));

				CRect rectMenuBar;
				m_pWndMenuBar->GetClientRect(&rectMenuBar);

				if(rectMenuBar.PtInRect(ptMenuBar))
				{
					s_bLastWasKey=FALSE;
				}
				// The menubar is in control of our life in response to this message.
			}
			UpdateWindow();
			// if it's in the child, select expanded
			// if we're in a submenu, then ensure the right items are selected in parents
			CRect rectClient;
			GetClientRect(rectClient);
			if(rectClient.PtInRect(point))
			{
				s_bLastWasKey=FALSE;
				return cMoveHandled + cMoveSelectExpanded ;
			}
			else
			{
				if(s_bLastWasKey)
				{
					return cMoveHandled;
				}
				else
				{
					return cMoveUnhandled;
				}
			}
		}
	
	   //
	   // Catch any error codes.
	   //
	   ASSERT(nMenuIndexHit >= 0) ;

	   if (CBMenuItem::MIT_Command == 
			m_MenuItems[nMenuIndexHit]->GetItemType()) // don't move to greyed items with mouse
	   {
		  m_MenuItems[nMenuIndexHit]->Select(TRUE);
		  m_nSelectedMenuItem = nMenuIndexHit;

		  DeferHideSubPopup();
		  InvalidateItem(m_nSelectedMenuItem);
		  UpdateWindow();
		  return cMoveHandled + cMoveSelectExpanded ;
	   }
		
	   if (CBMenuItem::MIT_Popup
				== m_MenuItems[nMenuIndexHit]->GetItemType())
	   {
		  m_MenuItems[nMenuIndexHit]->Select(TRUE);
      
		  DeferShowSubPopup(nMenuIndexHit);
		 if(m_nSelectedMenuItem!=-1)
		 {
			InvalidateItem(m_nSelectedMenuItem);
		 }
	   
		  m_nSelectedMenuItem = nMenuIndexHit ;
		  InvalidateItem(m_nSelectedMenuItem);
		  UpdateWindow();
		  return cMoveHandled + cMoveSelectExpanded ;
	   }

	   UpdateWindow();
		CRect rectClient;
		GetClientRect(rectClient);
		if(rectClient.PtInRect(point))
		{
			return cMoveHandled + cMoveSelectExpanded ;
		}
		else
		{
			return cMoveUnhandled;
		}
	}
	return cMoveUnhandled;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::OnLButtonDown(UINT nFlags, CPoint point) 
{
	//[REVIEW] Move the double click checking into MessageLoop?

	// translate to double click if appropriate
	if(s_nLastSystemClick!=0 &&
		m_bPassBackCancel)
	{
		CPoint ptScreen=point;
		ClientToScreen(&ptScreen);
		if(GetMessageTime()-s_nLastSystemClick < globalData.tmDoubleClick &&
			(abs(ptScreen.x-s_ptLastSystemClick.x) < globalData.cxDoubleClick) &&
			(abs(ptScreen.y-s_ptLastSystemClick.y) < globalData.cyDoubleClick))
		{
			// it's not in our bar, so forward the message
			if(m_pForwardMsg)
			{
				delete m_pForwardMsg;
				m_pForwardMsg=NULL;
			}

			m_pForwardMsg = new CForwardMouseMessage(GetCurrentMessage());
			m_pForwardMsg->m_message=WM_LBUTTONDBLCLK;
			ClearSystemClick();
			Done();
			return;
		}
	}

	ClearSystemClick();

	DoLButtonDown(nFlags, point) ;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
BOOL CBMenuPopup::DoLButtonDown(UINT nFlags, CPoint point) 
{
	// First update position.
	DoMouseMove(nFlags, point);
	
	if (IsCustomizing())
	{
		int nIndex = HitTest(point);
		if (nIndex != HT_MISSED)
		{
			if (nIndex == HT_HITSELECTEDITEM)
				nIndex = m_nSelectedMenuItem;
			
			if ((nIndex >=0) && 
				(m_MenuItems[nIndex]->GetItemType() == CBMenuItem::MIT_Separator))
			{
				return FALSE;
			}
			else
			{
				BOOL bExpand=TRUE; // true if we should expand if a drag doesn't happen

				// close any existing subpopup
				if(m_nExpandedMenuItem!=c_iNoItem)
				{
					if(nIndex==m_nExpandedMenuItem)
					{
						// don't expand if we just closed it.
						bExpand=FALSE;
					}

					// deselect the item
					m_MenuItems[m_nExpandedMenuItem]->Select(FALSE);

					HideSubPopup();
				}

				if(m_nSelectedMenuItem!=c_iNoItem)
				{
					// deselect the item
					m_MenuItems[m_nSelectedMenuItem]->Select(FALSE);
					InvalidateItem(m_nSelectedMenuItem);
					UpdateWindow();
					m_nSelectedMenuItem=c_iNoItem;
				}

				// do the move, if appropriate
				ClientToScreen(&point);

				// actually ignored, since menus are never deleted
				BOOL bDeletePending;

				// transient items can't be moved around or selected
				if(!m_MenuItems[nIndex]->m_bTransient)
				{
					CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;
					if(!pCustomizer->DoButtonMove(point, GetProxy(), nIndex, &bDeletePending))
					{
						// if no move happened, we'll try to expand a subpopup if there is one
						if(bExpand &&
							m_MenuItems[nIndex]->GetItemType()==CBMenuItem::MIT_Popup)
						{
							m_MenuItems[nIndex]->Select(TRUE);
      
							m_nSelectedMenuItem = nIndex;
							InvalidateItem(m_nSelectedMenuItem);
							UpdateWindow();

							ShowSubPopup(nIndex);
						}
					}
				}
			}
			return TRUE;
		}
	}
	
	// [TODO] This no longer needs to be recusive.
	if (m_pChildPopup != NULL)
	{
		// Give child popup a chance to handle mouse
		CPoint ptChild(point) ;
		ClientToScreen(&ptChild) ;
		m_pChildPopup->ScreenToClient(&ptChild) ;
		if (m_pChildPopup->DoLButtonDown(nFlags, ptChild))
		{
	 // Point is in a child .
			return TRUE ;
		}
	}
   
	// Button not pressed in child, is it pressed in us?
	CRect rcClient;
	GetClientRect(rcClient);
	if (!rcClient.PtInRect(point))
	{
		if (!m_bSubPopup)
		{
			// MessageLoop should handle clicks outside of our
			// menu. Therefore, we should never get here.
			// The above message is not true, click on a menu dropdown move mouse click on another...ASSERT(0) ;
			TRACE0("*****NOT ON MENU FORWARDING MESSAGE.*****\r\n") ;

			// The main popup is in charge of the lifetime.

			// We have pressed the mouse button outside of our window.
			// We need to quit, but we also need to forward the mouse
			// message on down the chain.

			// First, was the mouse captured, before we started:

			// If the click outside us was in our menu bar, then we don't pass the message on, but just cancel ourselves
			CPoint ptScreen;
			ClientToScreen(&point);
			if( m_pWndMenuBar==NULL ||
				CWnd::WindowFromPoint(point)!=m_pWndMenuBar)
			{
				// it's not in our bar, so forward the message
				if(m_pForwardMsg)
				{
					delete m_pForwardMsg;
					m_pForwardMsg=NULL;
				}

				m_pForwardMsg = new CForwardMouseMessage(GetCurrentMessage()) ;
			}
			Done();
		}
		return FALSE ;
	}

	return TRUE ;
	//CWnd::OnLButtonDown(nFlags, point);
}


/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
void CBMenuPopup::OnLButtonUp(UINT nFlags, CPoint point) 
{
   UINT nCmdID = DoLButtonUp(nFlags, point) ;
   if (nCmdID)
      Done(nCmdID) ;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
UINT CBMenuPopup::DoLButtonUp(UINT nFlags, CPoint point) 
{
	// First update position.
	DoMouseMove(nFlags, point);

	if (m_pChildPopup != NULL)
	{
		// Give child popup a chance to handle mouse
		CPoint ptChild(point) ;
		ClientToScreen(&ptChild) ;
		m_pChildPopup->ScreenToClient(&ptChild) ;
		UINT nCmdID = m_pChildPopup->DoLButtonUp(nFlags, ptChild);

		if (nCmdID != 0)
		{
			// Child handled the mouse move message.
			return nCmdID ;
		}
	}

	if (HitTest(point) == HT_HITSELECTEDITEM)
	{
		return m_MenuItems[m_nSelectedMenuItem]->Click();
	}

	return 0 ;
	//CWnd::OnLButtonUp(nFlags, point);
}


/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
void CBMenuPopup::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	KeyDown(nChar, nRepCnt, nFlags);
}

/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
void CBMenuPopup::KeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// don't handle any keyboard input in menus during customization
	if(IsCustomizing())
	{
		return;
	}

	s_bLastWasKey=TRUE;

	ASSERT( !m_bSubPopup ) ;
	//[NoSelect 1st] ASSERT() ;

	CBMenuPopup* pChild ;

	//DER DO: Internationalization

	// Only if its a popup.
	TCHAR tChar = (TCHAR)nChar ;
	if ((tChar >= '0') && (tChar <= '9') ||
		(tChar >= 'A') && (tChar <= 'Z') ||
		(tChar >= VK_NUMPAD0) && (tChar <= VK_NUMPAD9))
	{

		if (m_bControl)
		{
			::MessageBeep(0);
			return ;
		}

		 pChild  = FindLastChild() ;
		 BOOL bUseCmd;
		 UINT nCmdID = pChild->ForwardCharKeyDown(tChar, &bUseCmd) ;
		 if (bUseCmd)
		 {
			Done(nCmdID) ;
		 }
	}

   switch (nChar)
   {
   case VK_HOME:
      pChild = FindLastChild() ;
      pChild->ForwardHomeKey() ;
      break;
   case VK_END:
      pChild = FindLastChild() ;
      pChild->ForwardEndKey() ;
      break;
   case VK_DOWN:
      pChild = FindLastChild() ;
      pChild->ForwardDownKey() ;
      break;
   case VK_UP:
      pChild = FindLastChild() ;
      pChild->ForwardUpKey() ;
      break;
   case VK_RIGHT:
      if (m_nSelectedMenuItem != c_iNoItem) //[NoSelect 1st]
      {
			// might be trying to pull out submenu
			pChild = FindLastChild() ;
			if(pChild->ForwardRightKey())
			{
				// Move to next item on the main menu bar if we are a drop down.
				if (m_pWndMenuBar != NULL)
				{
						// We have been dropped down by a "menu bar".
						// Therefore, we will forward the mouse message to the menubar.

						m_pWndMenuBar->SendMessage(WM_KEYDOWN, (WPARAM)VK_RIGHT, NULL); // !!! review: WHat if the bar is vertically docked - how will it respond to this?
						// The menu bar is now in control of our destiny.
				}
			}
      }
	  else
	  {
		  // just forward it to the menu bar
		   if ((m_pWndMenuBar != NULL))         //with no subpopup's?
		   {
			   m_pWndMenuBar->SendMessage(WM_KEYDOWN, (WPARAM)nChar, NULL) ;
		   }
	  }
      break;
   case VK_LEFT:
	  // The user has pressed the left arrow. If we are a drop down menu,
	   // we need to go to the next menu item, if there are no subpopups.
	   if ((m_pWndMenuBar != NULL) &&       // Are we a drop down?
		   (m_pChildPopup == NULL))             //with no subpopup's?
	   {
		   // Send the left key to the menu bar.
		   m_pWndMenuBar->SendMessage(WM_KEYDOWN, (WPARAM)nChar, NULL) ;
	   }
	   else 
	   {

			 pChild = FindNextToLastChild() ;
			 pChild->HideSubPopup() ;
	   }
      break;
   case VK_RETURN:
      {            
	 // If nothing is selected, exit the menu.
	 if (m_nSelectedMenuItem == c_iNoItem) //[NoSelect 1st]
	 {
		  Done(0) ;
	 }
	 else
	 {
	    pChild = FindLastChild() ;
	    UINT nCmdID = pChild->ForwardReturnKey();
	    if (nCmdID)
	    {
	       Done(nCmdID) ;
	    }
	 }
      }
      break;
   case VK_CONTROL:
      m_bControl = TRUE ;
      break ;
   case VK_ESCAPE:
		if (m_pChildPopup == NULL)
		{
			if(m_pWndMenuBar)
			{
				m_bBarFocus=TRUE;
			}
			Done(0);
		}
	    else
		{
		   // If there are subpopups, ESC should close the youngest one.
		   // Find the next to last subpopup.
		   pChild = FindNextToLastChild() ;
		   pChild->HideSubPopup() ;
		}
		break;

   case VK_MENU:
		Done(0); 
		break;
   default:
	CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
   }
}

/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
void CBMenuPopup::OnSetFocus(CWnd* pOldWnd) 
{
	if (!m_bSubPopup || IsCustomizing())
	{
		CWnd::OnSetFocus(pOldWnd);
	}
	else
	{
		if(pOldWnd)
		{
			pOldWnd->SetFocus();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
void CBMenuPopup::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if(IsCustomizing())
	{
		return;
	}

	if (nChar==VK_MENU ||
		(!m_bDropDown && nFlags & (1<<13)))
	{
		// This is an ALT key combination.
		// Get out of here.
		Done(0);
	}
	else
	{
		KeyDown(nChar, nRepCnt, nFlags);
	}
}

/////////////////////////////////////////////////////////////////////////////
// 
//	Create the Menu Popup
//
void CBMenuPopup::OnRButtonDown(UINT nFlags, CPoint point) 
{
	if (IsCustomizing())
	{
		int nIndex = HitTest(point);
		if (nIndex != HT_MISSED)
		{
			if (nIndex == HT_HITSELECTEDITEM)
				nIndex = m_nSelectedMenuItem;

		   if ((nIndex >=0) && 
			  (m_MenuItems[nIndex]->GetItemType() == CBMenuItem::MIT_Separator))
		   {
			  return;
		   }
		   else
		   {
				CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;
				pCustomizer->SetSelection(GetProxy(), nIndex);

				ClientToScreen(&point);
				pCustomizer->DisplayButtonMenu(nFlags, point);
		   }
		}
	}
	else
	{
		DoLButtonDown(nFlags, point) ;
	}
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::OnRButtonUp(UINT nFlags, CPoint point) 
{
   UINT nCmdID = DoLButtonUp(nFlags, point) ;
   if (nCmdID)
      Done(nCmdID) ;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
   switch (nChar)
   {
   case VK_CONTROL:
      m_bControl = FALSE ;
      break ;   
   default:
	   CWnd::OnKeyUp(nChar, nRepCnt, nFlags);
   }
}

#ifdef _DEBUG
void CBMenuPopup::AssertValid() const
{
	CWnd::AssertValid();

	// TODO
}

void CBMenuPopup::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);

	dc << "Items: " << m_nMaxIndex;
	if(m_nMaxIndex>0)
	{
		CBMenuItem *pItem=(CBMenuItem *)(m_MenuItems[m_nMaxIndex-1]);
		dc << "First item: " << pItem->m_strName;
	}
}
#endif

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::SelectFirstItem()
{
	// Precondition
	if(m_nVisibleItems==0)
	{
		return;
	}

	// Select the first selectable item...
	if (m_nSelectedMenuItem == c_iNoItem)
	{
		int i = 0 ;
		while(m_MenuItems[i]->GetItemType() == CBMenuItem::MIT_Separator ||             // don't select separators
				!m_MenuItems[i]->IsVisible())                                                                   // and don't select invisible items
		{
			i++ ;
			if (i >= m_nMaxIndex) return ; // No selectable items...
		}
		m_nSelectedMenuItem = i;
		m_MenuItems[i]->Select(TRUE) ;
	}
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::PostNcDestroy()
{
	// Deselect the currently selected menu item.
	if (m_nSelectedMenuItem != c_iNoItem)
	{
		m_MenuItems[m_nSelectedMenuItem]->Select(FALSE) ;
	}

	// Does Nothing
	CWnd::PostNcDestroy() ;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
void CBMenuPopup::OnPaint()
{
	m_bPainted=TRUE;

	CPaintDC dc(this);
   
   // Calculate the required dimensions of the popup.
   CRect rectClientArea;
   GetClientRect(rectClientArea);

   // rectClientArea should be relative to 0,0.
   ASSERT((rectClientArea.top == 0) && (rectClientArea.left == 0)) ;

   // Use button colors for menu.
   dc.FillSolidRect(rectClientArea, globalData.clrBtnFace) ; // Does not fill right/bottom edge.

   // Draw Highlights
   // Places border inside rectangle... 
	dc.FillSolidRect( rectClientArea.left+1, rectClientArea.top+1,
		     rectClientArea.Width()-2, 1, globalData.clrBtnHilite);
	dc.FillSolidRect( rectClientArea.left+1, rectClientArea.top+1,
		     1, rectClientArea.Height() - 2, globalData.clrBtnHilite);
	dc.FillSolidRect( rectClientArea.right-2, rectClientArea.top+1,
		     1, rectClientArea.Height() - 1, globalData.clrBtnShadow);
	dc.FillSolidRect( rectClientArea.left+1, rectClientArea.bottom-2, 
		     rectClientArea.Width()-1, 1, globalData.clrBtnShadow);
	dc.FillSolidRect( rectClientArea.right-1, rectClientArea.top,
		     1, rectClientArea.Height()+1, globalData.clr3dDkShadow);
	dc.FillSolidRect( rectClientArea.left, rectClientArea.bottom-1,
		     rectClientArea.Width()+1, 1, globalData.clr3dDkShadow);

	// determine the drawing area
	CRect rectItems;
	GetItemsRect(&rectItems);

	// draw any scrolling details
	if(m_bScrolling)
	{
		// load bitmaps if required
		if(s_bmpScrollDown.m_hObject == NULL)
		{
			HBITMAP hbmScrollDown=GLOBAL_DATA::LoadSysColorBitmap(IDB_MENUSCROLLDOWN);
			ASSERT(hbmScrollDown);
			s_bmpScrollDown.Attach(hbmScrollDown);
		}

		if(s_bmpScrollUp.m_hObject == NULL)
		{
			HBITMAP hbmScrollUp=GLOBAL_DATA::LoadSysColorBitmap(IDB_MENUSCROLLUP);
			ASSERT(hbmScrollUp);
			s_bmpScrollUp.Attach(hbmScrollUp);
		}

		BITMAP bm;

		VERIFY(s_bmpScrollDown.GetObject(sizeof(BITMAP),(void*)&bm)) ;
		s_sizeScroll.cx = bm.bmWidth;
		s_sizeScroll.cy = bm.bmHeight;

		// draw
		CDC dcArrow;
		dcArrow.CreateCompatibleDC( &dc );

		if(m_bHasTopScroll)
		{
			// determine position
			CRect rectTop(0,0,GetWidth(), c_cyScrollAreaHeight);
			CPoint ptCenter=rectTop.CenterPoint();

			// draw it
			CBitmap *pOldBitmap = dcArrow.SelectObject(&s_bmpScrollUp);
			dc.BitBlt(ptCenter.x-s_sizeScroll.cx/2, ptCenter.y-s_sizeScroll.cy/2, s_sizeScroll.cx,s_sizeScroll.cy, &dcArrow, 0, 0, SRCCOPY);

			dcArrow.SelectObject( pOldBitmap );
		}
		if(m_bHasBottomScroll)
		{
			// determine position
			CRect rectBottom(0 ,GetWindowHeight()-c_cyScrollAreaHeight, GetWidth(), GetWindowHeight());
			CPoint ptCenter=rectBottom.CenterPoint();

			// draw it
			CBitmap *pOldBitmap = dcArrow.SelectObject(&s_bmpScrollDown);
			dc.BitBlt(ptCenter.x-s_sizeScroll.cx/2, ptCenter.y-s_sizeScroll.cy/2, s_sizeScroll.cx,s_sizeScroll.cy, &dcArrow, 0, 0, SRCCOPY);

			dcArrow.SelectObject( pOldBitmap );
		}
	}

	// Build a rect for each item.

	// Initialize Temp variables
	int left =  rectClientArea.left+c_iBorderSize ;
	int right = rectClientArea.right-c_iBorderSize ; 
	int bottom = 0;
	int nFirstIndex=m_nTopIndex;

	int top =   rectItems.top+c_iBorderSize ;

   // Build Rectangles
   CRect rectFields[c_iNumFields] ;

   rectFields[e_FieldAll].left = left ;   // Rectangle around whole item.
   rectFields[e_FieldAll].top = top ; 
   rectFields[e_FieldAll].right = right ;
   rectFields[e_FieldAll].bottom = bottom ;

   right = left + m_iFieldWidths[e_FieldButton] ; // right boundary is width of item.
   rectFields[e_FieldButton].left = left ;
   rectFields[e_FieldButton].top = top ;
   rectFields[e_FieldButton].right = right ;
   rectFields[e_FieldButton].bottom = 0;

#ifdef  _FIELD_ALIGN_ACCEL_   
   left = right + m_iFieldWidths[e_FieldGap];     // add gap to last right boundary.
   right = left + m_iFieldWidths[e_FieldName] ;   // right boundary is now moved over by filed width.
   rectFields[e_FieldName].left  = left ;
   rectFields[e_FieldName].top   = top ;
   rectFields[e_FieldName].right = right ;
   rectFields[e_FieldName].bottom= 0;

   left = right + m_iFieldWidths[e_FieldGap];
   right = left + m_iFieldWidths[e_FieldAccel] ;
   rectFields[e_FieldAccel].left  = left ;
   rectFields[e_FieldAccel].top   = top ;
   rectFields[e_FieldAccel].right = right ;
   rectFields[e_FieldAccel].bottom= 0 ;
#else
   // Don't align the accelerators
   left = right + c_iButtonTextGap ;                                    // add gap to last right boundary.
   right = left + m_iFieldWidths[e_FieldNameAccel] ;   // right boundary is now moved over by filed width.
   rectFields[e_FieldName].left  = left ;
   rectFields[e_FieldName].top   = top ;
   rectFields[e_FieldName].right = right ;
   rectFields[e_FieldName].bottom= 0;

   rectFields[e_FieldAccel].left  = left ;
   rectFields[e_FieldAccel].top   = top ;
   rectFields[e_FieldAccel].right = right ;
   rectFields[e_FieldAccel].bottom= 0 ;
#endif

   left = right + c_iButtonTextGap ;
   right = left + m_iFieldWidths[e_FieldArrow] ;
   rectFields[e_FieldArrow].left  = left ;
   rectFields[e_FieldArrow].top   = top ;
   rectFields[e_FieldArrow].right = right ;
   rectFields[e_FieldArrow].bottom= 0 ;

   // Draw the menu items.
   for(int i = nFirstIndex ; i < m_nMaxIndex  && rectFields[e_FieldAll].bottom < rectItems.bottom; i++)
   {
	   CBMenuItem* pItem = m_MenuItems[i] ;
	   int iItemHeight = pItem->GetHeight(&dc) ;

	   // Adjust height if needed.
	   if (iItemHeight  != rectFields[e_FieldName].Height())
	   {
		   rectFields[e_FieldAll].bottom = rectFields[e_FieldAll].top + iItemHeight ;
		   rectFields[e_FieldButton].bottom = rectFields[e_FieldButton].top + iItemHeight ;
		   rectFields[e_FieldName].bottom = rectFields[e_FieldName].top + iItemHeight ;
		   rectFields[e_FieldAccel].bottom = rectFields[e_FieldAccel].top + iItemHeight ;
		   rectFields[e_FieldArrow].bottom = rectFields[e_FieldArrow].top + iItemHeight ;
	   }
	   
	   // Draw
	   pItem->Draw(&dc, rectFields) ;
	   
	   // Move rects down one menu item.
	   rectFields[e_FieldAll].OffsetRect(0, iItemHeight) ;
	   rectFields[e_FieldButton].OffsetRect(0, iItemHeight)  ;
	   rectFields[e_FieldName].OffsetRect(0, iItemHeight) ;   
	   rectFields[e_FieldAccel].OffsetRect(0, iItemHeight);  
	   rectFields[e_FieldArrow].OffsetRect(0, iItemHeight);  
   }

	// draw customizer selection if appropriate
	CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;

	if (IsCustomizing() &&
		pCustomizer->m_pSelectBar->GetRealObject() == this)
	{
		COLORREF crBk = dc.SetBkColor(RGB(0xFF, 0xFF, 0xFF));
		COLORREF crFG = dc.SetTextColor(RGB(0, 0, 0));

		pCustomizer->DrawSelection(&dc);

		dc.SetBkColor(crBk);
		dc.SetTextColor(crFG);
	}

}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
HGLOBAL CBMenuPopup::GetData()
{
	HGLOBAL hData=GetProxy()->GetData();

	return hData;
}

/////////////////////////////////////////////////////////////////////////////
// 
//	
//
BOOL CBMenuPopup::SetData(HGLOBAL hglob)
{
	BOOL bFound=GetProxy()->SetData(hglob);

	return bFound;
}

//////////////////////////////////////////////////////////////////////////
//
//OLD_MENU Support using the old windows menu for accessibility reasons
//
//
namespace Menu
{
	enum eMenuMode
	{
		e_CmdBarMode = 1,
		e_OleBarMode = 2
	};

	static UINT s_MenuMode = e_CmdBarMode ;

	void UseHMENU(BOOL bUseOldWindowsMenu)
	{
		if (bUseOldWindowsMenu)
		{
			s_MenuMode &=~e_CmdBarMode ;
		}
		else
		{
			s_MenuMode |= e_CmdBarMode;
		}
		// Other functions will (possibly) set the e_OleMode flag...
	};

	void UseOLE(BOOL bStart)
	{
		if(bStart)
		{
			s_MenuMode |= e_OleBarMode;
		}
		else
		{
			s_MenuMode &= ~e_OleBarMode;
		}
	}

	BOOL IsInCmdBarMode() 
	{
		return (s_MenuMode & e_CmdBarMode)!=0 ; // any other bits set imply regular menus
	}

	BOOL IsShowingCmdBars() 
	{
		return s_MenuMode == e_CmdBarMode ; // any other bits set imply regular menus
	}

	void UpdateMode(BOOL bUpdateNow)
	{
		CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();

		if(IsShowingCmdBars())
		{
			POSITION pos;
			if(     pFrame &&
				pFrame->m_pManager)
			{
				CDockWorker* pDocker = pFrame->m_pManager->WorkerFromID(MAKEDOCKID(PACKAGE_SUSHI,IDTB_MENUBAR), &pos);

				CASBar* pBar = (CASBar*) pDocker->m_pWnd;
				if (pBar != NULL &&
					pBar->m_nCount==0)
				{
					CPackage* pGrp = theApp.GetPackage(pDocker->m_nIDPackage);
					if (pGrp == NULL)
						return;
					
					HGLOBAL hglob = pGrp->GetToolbarData(LOWORD(pDocker->m_nIDWnd));

					if (hglob != NULL)
					{
						TOOLBARINIT FAR* lptbi = (TOOLBARINIT*) ::GlobalLock(hglob);
						UINT FAR* lpIDArray = (UINT FAR*) (lptbi + 1);

						pBar->DynSetButtons(lpIDArray, lptbi->nIDCount);
						pBar->RecalcLayout();
						
						::GlobalUnlock(hglob);
						::GlobalFree(hglob);
					}
				}
			}
		}
		DkUpdateAvailableWnds(bUpdateNow);
		if(IsShowingCmdBars())
		{
			// HACK ALERT!
			// when setting the menu bar to NULL, we risk loosing the sys menus gadgets
			// so let's make sure that the window is not maxed before switching 
			// menu bars
			BOOL bMaxed;
			CWnd *pParentWnd = NULL;
			CMDIChildWnd *pChildTop = pFrame->MDIGetActive(&bMaxed);
			if(pChildTop)
				pParentWnd = pChildTop->GetParent();

			if(bMaxed)
			{
				if(pParentWnd)
					pParentWnd->SetRedraw(FALSE);
				if(pChildTop)
					pChildTop->MDIRestore();
			}

			pFrame->SetMenu(NULL);

			if(bMaxed)
			{
				if(pChildTop)
					pChildTop->MDIMaximize();
				if(pParentWnd)
					pParentWnd->SetRedraw(TRUE);
			}
		}
		pFrame->RebuildMenus();
	}
};

BOOL CBMenuPopup::ContainsMenu(int nCmdID)
{
	// returns true if the specified command id is contained within this menu or one of its subs
	BOOL bFound=FALSE;
	for(int i = 0 ; i < m_nMaxIndex  && !bFound; i++)
	{
		CBMenuItem* pItem = m_MenuItems[i] ;

		if(pItem->GetItemType()==CBMenuItem::MIT_Popup)
		{
			ASSERT(pItem->GetCmdID()!=0);
			
			if(pItem->GetCmdID()==nCmdID)
			{
				bFound=TRUE;
			}
			else
			{
				CBMenuPopup *pSub=theCmdCache.GetMenu(pItem->GetCmdID());
				ASSERT(pSub);
				bFound=pSub->ContainsMenu(pItem->GetCmdID());
			}
		}
	}
	return bFound;
}

CTypedPtrList<CObList, CBMenuPopup *> CBMenuPopup::s_listMenus;

int CBMenuPopup::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
	int rv;
	if((rv=CWnd::OnCreate(lpCreateStruct))==0)
	{
		s_listMenus.AddTail(this);

	}
	return rv;
}

void CBMenuPopup::AllocateProxy(void)
{
	ASSERT(m_pProxy==NULL);

	m_pProxy = new CMenuPopupProxy;
	m_pProxy->AttachMenu(this);
}

void CBMenuPopup::OnDestroy( )
{
	EndDefer();

	// deselect inside this menu.
	if(	CASBar::s_pCustomizer &&
		CASBar::s_pCustomizer->m_pSelectBar !=NULL &&
		CASBar::s_pCustomizer->m_pSelectBar ->GetWindow()==this)
	{
		CASBar::s_pCustomizer->SetSelection(NULL,0);
	}

	
	POSITION pos=s_listMenus.Find(this);

	ASSERT(pos);
	if(pos)
	{
		// delete it
		s_listMenus.RemoveAt(pos);
	}

	CWnd::OnDestroy();
}

void CBMenuPopup::FreeProxy(void)
{
	if(m_pProxy)
	{
		delete m_pProxy;
		m_pProxy=NULL;
	}
}

LRESULT CBMenuPopup::OnTestMenu(WPARAM wParam, LPARAM lParam)
{
	CMainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();
	
	return pFrame->SendMessage(DSM_TESTMENU, wParam,lParam);
}

void CBMenuPopup::OnTimer(UINT nIDEvent)
{
	switch(nIDEvent)
	{
		case c_iExpandTimerID:
			ASSERT(m_nExpandDeferredItem!=c_iNoItem);
			ShowSubPopup(m_nExpandDeferredItem);
			break;

		case c_iContractTimerID:
			HideSubPopup();
			break;

		case c_iScrollDownTimerID:
			ScrollMenuDown();
			DoScroll(GetCurrentMessage()->pt, FALSE);
			break;

		case c_iScrollUpTimerID:
			ScrollMenuUp();
			DoScroll(GetCurrentMessage()->pt, FALSE);
			break;

		default:
			ASSERT(FALSE);
			return;
	}
	// don't need to kill the timers here, as the Show/Hide funcs always kill them
}

void CBMenuPopup::RemoveCommandReferences(UINT id)
{
	// remove any reference to this command id
	for(int i=0; i<m_nMaxIndex; ++i)
	{
		CBMenuItem* pItem = m_MenuItems[i];

		if(pItem &&
			pItem->GetCmdID()==id)
		{
			// REVIEW: Separators need to be handled
			DeleteMenu(i, MF_BYPOSITION);
		}
	}
}

CMenuPopupProxy* CBMenuPopup::GetProxy()
{
	ASSERT(m_pProxy);
	return m_pProxy;
}

int CBMenuPopup::GetHeight()
{
	if(m_nVisibleItems==0)
	{
		return c_iEmptyHeight;
	}
	else
	{
		return m_iHeight;
	}
}

int CBMenuPopup::GetWindowHeight()
{
	int nHeight=GetHeight();

	// [multimon] 7 mar 97 - der
	// Its possible that the window has not been created when
	// we call this function. Therefore, we use the parent window.
	// BUGBUG: Could the parent window be on the wrong monitor?
	int cyScreen = ::multiGetCYMetrics(m_hWnd != NULL ? m_hWnd : m_pParentWnd->GetSafeHwnd()) ;

	if(nHeight<=cyScreen)
	{
		return nHeight;
	}
	else
	{
		return cyScreen;
	}
}

int CBMenuPopup::GetWidth()
{
	if(m_nVisibleItems==0)
	{
		return c_iEmptyWidth;
	}
	else
	{
	#ifdef  _FIELD_ALIGN_ACCEL_   
		return m_iFieldWidths[e_FieldButton] + m_iFieldWidths[e_FieldName] + m_iFieldWidths[e_FieldAccel] +
			m_iFieldWidths[e_FieldArrow] + m_iFieldWidths[e_FieldGap]*3/2; //The separation is 1/2 char width.
	#else
		return m_iFieldWidths[e_FieldButton] + m_iFieldWidths[e_FieldNameAccel] +
			m_iFieldWidths[e_FieldArrow] + c_iButtonTextGap*2; 
					  // The separation for the gap between the the name and the accelerator has already been added.
	#endif
	}
}

afx_msg void CBMenuPopup::OnKillFocus(CWnd *pNew)
{
	CToolCustomizer* pCustomizer = CASBar::s_pCustomizer;
	if (!IsCustomizing())
	{
		// when the app loses focus, we must finish
		if(pNew!=this && !IsChild(pNew) && pNew==NULL || !pNew->IsKindOf(RUNTIME_CLASS(CBMenuPopup)))
		{
			if(m_bSubPopup)
			{
				// let the parent finish
				if(GetParent())
				{
					GetParent()->SendMessage(WM_KILLFOCUS, (WPARAM)(pNew->GetSafeHwnd()), NULL);
				}
			}
			else
			{
				// don't call done if it's already been called
				if(m_bContinueModal)
				{
					Done(0);
				}
			}
		}
	}
}

void CBMenuPopup::InvalidateItem(int nIndex)
{
	InvalidateRect(GetItemRect(nIndex), FALSE);
}

CRect CBMenuPopup::GetItemRect(int nIndex)
{
	CRect rectItems;
	GetItemsRect(&rectItems);

	CRect rectItem=GetMenuItem(nIndex)->m_rectFields[e_FieldAll];

	if(rectItem.top>rectItems.top && rectItem.bottom<rectItems.bottom)
	{
		return rectItem;
	}
	else
	{
		return CRect(0,0,0,0);
	}
}

// Right now, during customization, all menus are being customized apart from the right button context menu.
BOOL CBMenuPopup::IsCustomizing(void)
{
	return CASBar::s_pCustomizer!=NULL &&   // are we customizing
			(m_bDropDown ||                                 // is this a top level dropdown
			m_bSubPopup);                                   // or a submenu on a dropdown
}

// searches for this command in this menu and all submenus
BOOL CBMenuPopup::ContainsMenu(UINT nId)
{
	// iterate over the whole menu
	for(int i = 0 ; i < m_nMaxIndex  ; i++)
	{
		CBMenuItem* pItem = m_MenuItems[i] ;
		
		// look for submenus
		if(pItem->GetItemType()==CBMenuItem::MIT_Popup)
		{
			// if this is the thing we're looking for, that's it
			if(pItem->GetCmdID()==nId)
			{
				return TRUE;
			}
			else
			{
				// if this contains the thing we're looking for, that's it too
				CBMenuPopup *pSubPopup=theCmdCache.GetMenu(pItem->GetCmdID());
				if(pSubPopup)
				{
					if(pSubPopup->ContainsMenu(nId))
					{
						return TRUE;
					}
				}
			}
		}
	}
	return FALSE;
}

// implements specific menu cancelling for bars
void CBMenuPopup::HideInvalidMenuDestination(UINT nId)
{
	if(m_nExpandedMenuItem!=c_iNoItem)
	{
		CBMenuItem *pItem=m_MenuItems[m_nExpandedMenuItem];

		ASSERT(pItem);

		if(pItem->GetCmdID()==nId)
		{
			HideSubPopup();
		}
		else
		{
			CBMenuPopup *pMenuTest=theCmdCache.GetMenu(nId);
			if(pMenuTest->ContainsMenu(nId))
			{
				HideSubPopup();
			}
			else
			{
				if(m_pChildPopup)
				{
					m_pChildPopup->HideInvalidMenuDestination(nId);
				}
			}
		}
	}
}

// Flushes all cached menu size information
void CBMenuPopup::FlushSizeCache()
{
	VerifyMenuSize(TRUE);
}

// Call when a click could not be a system double click part 1
void CBMenuPopup::ClearSystemClick(void)
{
	s_nLastSystemClick=0;
	s_ptLastSystemClick.x=s_ptLastSystemClick.y=0;
}

void CBMenuPopup::SetSystemClick(int nTime, CPoint pt)
{
	s_nLastSystemClick=nTime;
	s_ptLastSystemClick=pt;
}

CFont *CBMenuPopup::GetMenuFont(BOOL bDefault)
{
	return globalData.GetMenuFont(bDefault);
}

void CBMenuPopup::SysColorChange(void)
{
	// update all glyphs
	// Flush the size caches on all of the menus and items
	POSITION pos=theCmdCache.GetFirstMenuPosition();
	CBMenuPopup *pMenu;
	UINT nIDMenu;

	while(pos!=NULL)
	{
		theCmdCache.GetNextMenu(pos, nIDMenu, pMenu);

		if(pMenu)
		{
			CBMenuItem *pItem=NULL;

			for(int i=0; i < pMenu->GetMenuItemCount(); ++i)
			{
				pItem=pMenu->m_MenuItems[i];
				if(pItem)
				{
					pItem->UpdateGlyph();
				}
			}
		}
	}

	// update stock bitmaps
	s_bmpScrollUp.DeleteObject();
	s_bmpScrollDown.DeleteObject();

	CBMenuItem::FlushSizeCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cbverb.cpp ===
/*****************************************************************
This file implements the OLE Verb menu for Command bars. Insert
a dialog into your application. Right click in the dialog. Select
Insert ActiveX Control... Insert a control. Right click on the control.
You should see a context menu for handling the control. 

  Some controls will put up a subpopup, others will not.

All of this code was borrowed from the standard OLE UI Dll. This code
was found on \\savik\cairo. The slm project is ole2ui32. The code in this
file borrows from the following files:
	ole2ui.h
	ole2ui.cpp
	olestd.cpp
	utility.cpp
	utility.h
	ole2ui.rc
	common.h

The main change to the code was to make it compatible with Command Bars.
	* Loading resource strings dyanmically instead of caching them.
	* Using MFC functions such as AfxLoadString

The really funny thing is that they took a bunch of functions out of MFC,
converted them to C++ and used them. I'm converting these funcitons back
to C++...


****************************************************************/

#include <stdafx.h>

#include <objbase.h>

#ifndef STRICT
#define STRICT
#endif

#include "resource.h"
#include <stdarg.h>

// From common.h

 // Maximum length of Object menu
#define OLEUI_OBJECTMENUMAX         256

// Maximim length of a path in BYTEs
#define MAX_PATH_SIZE               (MAX_PATH*sizeof(TCHAR))

////////////////////////////////////////////////////////
//
// From Utility.
//
//

/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
        LPMALLOC pmalloc;

        if (pmem == NULL)
                return;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
				ASSERT(0) ;
                return;
        }
        if (1 == pmalloc->DidAlloc(pmem))
        {
            pmalloc->Free(pmem);
        }
        pmalloc->Release();
}


/*
 * OleUIAddVerbMenu
 *
 * Purpose:
 *  Add the Verb menu for the specified object to the given menu.  If the
 *  object has one verb, we directly add the verb to the given menu.  If
 *  the object has multiple verbs we create a cascading sub-menu.
 *
 * Parameters:
 *  lpObj           LPOLEOBJECT pointing to the selected object.  If this
 *                  is NULL, then we create a default disabled menu item.
 *
 *  lpszShortType   LPTSTR with short type name (AuxName==2) corresponding
 *                  to the lpOleObj. if the string is NOT known, then NULL
 *                  may be passed. if NULL is passed, then
 *                  IOleObject::GetUserType will be called to retrieve it.
 *                  if the caller has the string handy, then it is faster
 *                  to pass it in.
 *
 *  hMenu           HMENU in which to make modifications.
 *
 *  uPos            Position of the menu item
 *
 *  uIDVerbMin      UINT ID value at which to start the verbs.
 *                      verb_0 = wIDMVerbMin + verb_0
 *                      verb_1 = wIDMVerbMin + verb_1
 *                      verb_2 = wIDMVerbMin + verb_2
 *                      etc.
 *  uIDVerbMax      UINT maximum ID value allowed for object verbs.
 *                     if uIDVerbMax==0 then any ID value is allowed
 *
 *  bAddConvert     BOOL specifying whether or not to add a "Convert" item
 *                  to the bottom of the menu (with a separator).
 *
 *  idConvert       UINT ID value to use for the Convert menu item, if
 *                  bAddConvert is TRUE.
 *
 * *****NOTE -- I do not return a menu pointer!*****
 *  lphMenu         HMENU FAR * of the cascading verb menu if it's created.
 *                  If there is only one verb, this will be filled with NULL.
 *
 *
 * Return Value:
 *  BOOL            TRUE if lpObj was valid and we added at least one verb
 *                  to the menu.  FALSE if lpObj was NULL and we created
 *                  a disabled default menu item
 */

STDAPI_(BOOL) CmdBarOleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
        LPCTSTR lpszShortType,
        CBMenuPopup* pMenu, UINT uPos,
        UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert)
        //CBMenuPopup** ppSubMenu)
{
        LPENUMOLEVERB       lpEnumOleVerb = NULL;
        OLEVERB             oleverb;
		CString strShortTypeName = lpszShortType ;
		CString				strVerbName;
        HRESULT             hrErr;
        BOOL                fStatus;
        BOOL                fIsLink = FALSE;
        BOOL                fResult = TRUE;
        BOOL                fAddConvertItem = FALSE;
        int                 cVerbs = 0;
        UINT                uFlags = MF_BYPOSITION;
        
		CString				strBuffer ;

        // Set fAddConvertItem flag
        if (bAddConvert & (idConvert != 0))
                fAddConvertItem = TRUE;

		// Create the Popup Menu here.
		CBMenuPopup* pSubMenu = new CBMenuPopup ;
		//@ pSubMenu->Create(pMenu, TRUE) ; // FIX
		pSubMenu->CreatePopupMenu(pMenu) ;

        // Delete whatever menu may happen to be here already.
        //DeleteMenu(hMenu, uPos, uFlags); 
		pMenu->DeleteMenu(uPos,uFlags) ;

        if ((!lpOleObj) || IsBadReadPtr(lpOleObj, sizeof (IOleObject)))
                goto AVMError;

        if (strShortTypeName.IsEmpty())
        {
                // get the Short form of the user type name for the menu
				TRACE0("IOleObject::GetUserType called\r\n");

                LPOLESTR wszShortTypeName = NULL;
                hrErr = lpOleObj->GetUserType(
                                USERCLASSTYPE_SHORT,
                                &wszShortTypeName);
				strShortTypeName = wszShortTypeName ;
                if (NULL != wszShortTypeName)
                {
                    OleStdFree(wszShortTypeName);
                }

                if (NOERROR != hrErr)
				{
                        TRACE("IOleObject::GetUserType returned %x.\r\n", hrErr);
						return hrErr ;
				}
        }

        // check if the object is a link
        IUnknown* pIOleLink;
        hrErr = lpOleObj->QueryInterface(IID_IOleLink,(void**)&pIOleLink);
        if (SUCCEEDED(hrErr))
        {
			pIOleLink->Release();
            fIsLink = TRUE;
        }
		else
		{
			fIsLink = FALSE;
		}


        // Get the verb enumerator from the OLE object
        TRACE0("IOleObject::EnumVerbs called\r\n");
        hrErr = lpOleObj->EnumVerbs(
                        (LPENUMOLEVERB FAR*)&lpEnumOleVerb
        );

        if (NOERROR != hrErr)
		{
                TRACE("IOleObject::EnumVerbs returned %x.\r\n", hrErr);
				return hrErr ;
		}

        // loop through all verbs
        while (lpEnumOleVerb != NULL)
        {
                hrErr = lpEnumOleVerb->Next(
                                1,
                                (LPOLEVERB)&oleverb,
                                NULL
                );
                if (NOERROR != hrErr)
                        break;              // DONE! no more verbs

                /* OLE2NOTE: negative verb numbers and verbs that do not
                **    indicate ONCONTAINERMENU should NOT be put on the verb menu
                */
                if (oleverb.lVerb < 0 ||
                                ! (oleverb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU))
                {
                        /* OLE2NOTE: we must still free the verb name string */
                        if (oleverb.lpszVerbName)
                                OleStdFree(oleverb.lpszVerbName);
                        continue;
                }

				strVerbName = oleverb.lpszVerbName ;
                if (oleverb.lpszVerbName)
                   OleStdFree(oleverb.lpszVerbName);

                if ( 0 == uIDVerbMax ||
                        (uIDVerbMax >= uIDVerbMin+(UINT)oleverb.lVerb) )
                {
                        fStatus = pSubMenu->InsertMenu(
                                        (UINT)-1,
                                        MF_BYPOSITION | (UINT)oleverb.fuFlags,
                                        uIDVerbMin+(UINT)oleverb.lVerb,
                                        strVerbName);
                        if (! fStatus)
                                goto AVMError;

                        cVerbs++;
                }
        }

        // Add the separator and "Convert" menu item.
        if (fAddConvertItem)
        {
			static TCHAR szConvert[OLEUI_OBJECTMENUMAX];
			VERIFY(::AfxLoadString(IDS_OLE2UICONVERT,szConvert, OLEUI_OBJECTMENUMAX)) ;
            
                if (0 == cVerbs)
                {
                        uIDVerbMin = idConvert;
                        // if object has no verbs, then use "Convert" as the obj's verb
						strVerbName = szConvert ;
						LPTSTR lpsz = strVerbName.GetBuffer(strVerbName.GetLength()) ;

                        // remove "..." from "Convert..." string; it will be added later
                        if (lpsz)
                        {
                                while(*lpsz && *lpsz != '.')
                                        lpsz = CharNext(lpsz);
                                *lpsz = '\0';
                        }
						strVerbName.ReleaseBuffer() ;

                }

                if (cVerbs > 0)
                {
                        fStatus = pSubMenu->InsertMenu((UINT)-1,
                                                MF_BYPOSITION | MF_SEPARATOR,
                                                (UINT)0,
                                                (LPCTSTR)NULL);
                        if (! fStatus)
                                goto AVMError;
                }

                /* add convert menu */
                fStatus = pSubMenu->InsertMenu((UINT)-1,
                                        MF_BYPOSITION,
                                        idConvert,
                                        (LPCTSTR)szConvert);
                if (! fStatus)
                        goto AVMError;

                cVerbs++;
        }


        /*
         * Build the appropriate menu based on the number of verbs found
         *
         */
        if (cVerbs == 0)
        {
                // there are NO verbs (not even Convert...). set the menu to be
                // "<short type> &Object/Link" and gray it out.
      			AfxFormatString1(strBuffer,
                        (fIsLink ? IDS_OLE2UIEDITLINKCMD_NVERB : IDS_OLE2UIEDITOBJECTCMD_NVERB),
                        strShortTypeName /*May be empty...*/);

                uFlags |= MF_GRAYED;

                fResult = FALSE;
				
				// Single menu item. So delete the SubPopup
				delete pSubMenu ;
				pSubMenu = NULL ;

        }
        else if (cVerbs == 1)
        {
                //One verb without Convert, one item.
				UINT ids = (fIsLink ? IDS_OLE2UIEDITLINKCMD_1VERB : IDS_OLE2UIEDITOBJECTCMD_1VERB);

                // strip ampersands from lpszVerbName to ensure that
                // the right character is used as the menu key
                LPTSTR pchIn;
                LPTSTR pchOut;
                pchIn = pchOut = strVerbName.GetBuffer(strVerbName.GetLength());
                while (*pchIn)
                {
                    while (*pchIn && '&' == *pchIn)
                    {
                        pchIn++;
                    }
                    *pchOut = *pchIn;
                    pchOut++;
                    pchIn++;
                }
                *pchOut = 0;
				strVerbName.ReleaseBuffer() ;

                AfxFormatString2(strBuffer, ids, strVerbName, strShortTypeName);

                // if only "verb" is "Convert..." then append the ellipses
                if (fAddConvertItem)
				{

                    strBuffer += TEXT("...");
				}

				delete pSubMenu ;
				pSubMenu = NULL ;
        }
        else
        {

                //Multiple verbs or one verb with Convert, add the cascading menu
                AfxFormatString1(strBuffer, 
                        (fIsLink ? IDS_OLE2UIEDITLINKCMD_NVERB: IDS_OLE2UIEDITOBJECTCMD_NVERB),
						strShortTypeName); //lpszShortTypeName ? lpszShortTypeName : TEXT(""))

                uFlags |= MF_ENABLED | MF_POPUP;

				// We are going to add a subpopup so make the cmd id zero.
				uIDVerbMin = 0 ; 

        }

        if (!pMenu->InsertMenu(uPos, uFlags, uIDVerbMin, strBuffer,pSubMenu)) 
        {
AVMError:
				// No object command.				

				// Load the string.
				CString strNoObjectCmd ;
				strNoObjectCmd.LoadString(IDS_OLE2UIEDITNOOBJCMD);
				ASSERT(!strNoObjectCmd.IsEmpty());

				// Put it in the menu.
                pMenu->InsertMenu(uPos, MF_GRAYED | uFlags,	
                        uIDVerbMin, strNoObjectCmd);
                fResult = FALSE;

			// If there has been an error, we delete the submenu.
			// If there isn't an error, it is owned by pMenu and it is
			// pMenu's job to delete it.
			if (pSubMenu != NULL)
			{
				delete pSubMenu;
				pSubMenu = NULL ;
			}
        }

        if (lpEnumOleVerb)
                lpEnumOleVerb->Release();

		// Do not delete pSubMenu here.
        return fResult;
}

////////////////////////////////////////////////////////
//
//
//	Copied from MFC
//
//

/////////////////////////////////////////////////////////////////////////////////////////
// 
//  Support for adding OLE Verbs into CmdBars...
//

void CmdBarOleSetEditMenu(COleClientItem* pItem, CBMenuPopup* pMenu,
	UINT iMenuItem, UINT nIDVerbMin, UINT nIDVerbMax, UINT nIDConvert) 
{
	if (pItem != NULL)
		ASSERT_VALID(pItem);

	// Notice that my version of OleUIAddVerMenu is NOT the same as the
	// real version. This version does not return the sub popup menu.
	
	if (!CmdBarOleUIAddVerbMenu(pItem != NULL ? pItem->m_lpObject : NULL,
		NULL, pMenu, iMenuItem,
		nIDVerbMin, nIDVerbMax, nIDConvert != 0, nIDConvert))
	{
		CString szBuffer;
		pMenu->GetMenuString(iMenuItem, szBuffer, MF_BYPOSITION);
		pMenu->DeleteMenu(iMenuItem, MF_BYPOSITION);
		pMenu->InsertMenu(
			iMenuItem, MF_BYPOSITION|MF_STRING|MF_GRAYED|MF_DISABLED,
			nIDVerbMin, szBuffer);
	}
}

//
//
// Add OLE Object Verbs to a menu.
//
void CPartDoc::OnUpdateObjectVerbMenu(CCmdUI* pCmdUI)
{
	// Get a pointer to the menu. Cast to a CmdBar menu.
	CBMenuPopup* pCBMenu = (CBMenuPopup*)pCmdUI->m_pOther ;
	
	// Now check to see if its really a command bar menu.
	if (!CBMenuPopup::IsCBMenuCmdUI(pCmdUI) || 
		pCBMenu->IsSubPopup())
	{
		// This is either NOT a command bar, or its a SubPopup.
		// Therefore, let MFC do the work for us.
		COleDocument::OnUpdateObjectVerbMenu(pCmdUI) ;
		return ;
	}

	// We are updating a wonderous Command Bar. Therefore, we have
	// to do all the work ouselves.


	// All of this code was cut and pasted from MFC and then hacked up
	// until it worked.

	// check for single selection
	COleClientItem* pItem = GetPrimarySelectedItem(GetRoutingView());
	if (pItem == NULL || pItem->GetType() == OT_STATIC)
	{
		// no selection, or is 'static' item
		pCmdUI->Enable(FALSE);

		//return ; // This will put in the <OLE OBJECTS VERBS GO HERE>> Message.
	}

	// only include Convert... if there is a handler for ID_OLE_EDIT_CONVERT
	UINT nConvertID = ID_OLE_EDIT_CONVERT;
	AFX_CMDHANDLERINFO info;
	if (!OnCmdMsg(ID_OLE_EDIT_CONVERT, CN_COMMAND, NULL, &info))
	{
		nConvertID = 0;
	}

	// update the menu
	CmdBarOleSetEditMenu(GetPrimarySelectedItem(GetRoutingView()),
		pCBMenu, pCmdUI->m_nIndex,
		ID_OLE_VERB_FIRST, ID_OLE_VERB_LAST, nConvertID);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\checklis.cpp ===
// checklis.cpp : implementation file
//

#include "stdafx.h"
#include "utilctrl.h"
#include "resource.h"

#define OBM_CHECKBOXES      32759 // stolen from windows.h

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheckList
                              
CBitmap CCheckList::c_checkBitmap;
CSize CCheckList::c_checkSize;


CCheckList::CCheckList()
{
	m_cyItem = 0;
	m_cyText = 0;
}

BOOL CCheckList::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	 return CListBox::Create(dwStyle | LBS_OWNERDRAWFIXED | LBS_HASSTRINGS, 
	 	rect, pParentWnd, nID);
}

BEGIN_MESSAGE_MAP(CCheckList, CListBox)
	//{{AFX_MSG_MAP(CCheckList)
	ON_WM_LBUTTONDOWN()
	ON_WM_KEYDOWN()
	ON_WM_CREATE()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_SETFONT, OnSetFont)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheckList message handlers

int CCheckList::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CListBox::OnCreate(lpCreateStruct) == -1)
		return -1;

	ResetItemHeight();
	return 0;
}

LRESULT CCheckList::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	Default();
	ResetItemHeight();
	return 0;
}

void CCheckList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	ASSERT(m_cyItem > 0); // Must be set at create or subclass time
	
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CRect rect;
	rect.left = lpDrawItemStruct->rcItem.left + c_checkSize.cx + 2;
	rect.top = lpDrawItemStruct->rcItem.top;
	rect.right = lpDrawItemStruct->rcItem.right;
	rect.bottom = lpDrawItemStruct->rcItem.bottom;
	
	if (lpDrawItemStruct->itemID >= 0 &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) != 0)
	{
		BOOL fDisabled = !IsWindowEnabled();

		COLORREF newTextColor = fDisabled ? RGB(0x80, 0x80, 0x80) : GetSysColor(COLOR_WINDOWTEXT);	// light gray
		COLORREF oldTextColor = pDC->SetTextColor(newTextColor);

		COLORREF newBkColor = GetSysColor(COLOR_WINDOW);
		COLORREF oldBkColor = pDC->SetBkColor(newBkColor);

		if (newTextColor == newBkColor)
			newTextColor = RGB(0xC0, 0xC0, 0xC0);	// dark gray
		
		CDC bitmapDC;
		if (bitmapDC.CreateCompatibleDC(pDC))
		{
			int nCheck = GetCheck(lpDrawItemStruct->itemID);
			CBitmap* pOldBitmap = bitmapDC.SelectObject(&c_checkBitmap);
			
			int xSrc, ySrc, xDest, yDest;
			if (theApp.m_bWin4)
			{
				xSrc = c_checkSize.cx * nCheck;
				ySrc = 0;
				xDest = 1;
				yDest = 0;
			}
			else
			{
				xSrc = c_checkSize.cx * (nCheck == 2 ? 1 : nCheck);
				ySrc = c_checkSize.cy * (nCheck == 2 ? 2 : 0);
				xDest = 1;
				yDest = 1;
			}
			
			pDC->BitBlt(lpDrawItemStruct->rcItem.left + xDest, 
				rect.top + yDest + max(0, (m_cyItem - c_checkSize.cy) / 2), 
				c_checkSize.cx, c_checkSize.cy, 
				&bitmapDC, xSrc, ySrc, SRCCOPY);
			bitmapDC.SelectObject(pOldBitmap);
		}
		
		if (!fDisabled && ((lpDrawItemStruct->itemState & ODS_SELECTED) != 0))
		{
			pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}

		CString strText; 
//		GetText(lpDrawItemStruct->itemID, strText);
		GetDisplayText(lpDrawItemStruct->itemID, pDC, rect, strText);
		ItemStringOut (pDC, strText, rect);
		
		pDC->SetTextColor(oldTextColor);
		pDC->SetBkColor(oldBkColor);
	}
	
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
		pDC->DrawFocusRect(rect);
}

//virtual
void CCheckList::GetDisplayText(int index, CDC *pDC, const CRect&, CString& strOut)
{
	GetText(index, strOut);
}

void CCheckList::ItemStringOut (CDC * pDC, const CString& strOut, const CRect&  rect)
{
	pDC->ExtTextOut(rect.left, rect.top + max(0, (m_cyItem - m_cyText) / 2), 
			ETO_OPAQUE, rect, strOut, strOut.GetLength(), NULL);
}


void CCheckList::OnLButtonDown(UINT nFlags, CPoint point)
{
	SetFocus();
	
	if (point.x < c_checkSize.cx && point.y < m_cyItem * (GetCount() - GetTopIndex()))
	{
		// Cheap button functionality: we toggle on the button down.  This is
		// less cool than tracking the mouse like a real checkbox, but if
		// WinWord can get away with this, so can we!

		int nItem = GetTopIndex() + point.y / m_cyItem;
	
		if ((GetStyle() & LBS_EXTENDEDSEL) != 0 && GetSel(nItem))
		{
			int nSelCount = GetSelCount();
			ASSERT(nSelCount > 0);

			INT* pSelItems = new INT [nSelCount];
			GetSelItems(nSelCount, pSelItems);

			int nCheck = GetCheck(nItem);
			nCheck = (nCheck + 1) % 2; // can't go back to tri-state!

			for (int i = 0; i < nSelCount; i += 1)
			{
				SetCheck(pSelItems[i], nCheck);
				InvalidateCheck(pSelItems[i]);
			}

			delete [] pSelItems;
		}
		else 
		{

			SetCheck(nItem, (GetCheck(nItem) + 1) % (IsTriState(nItem) ? 3 : 2));
			InvalidateCheck(nItem);
		}

		// Inform of check
		CWnd*	pParent = GetParent();
		ASSERT_VALID(pParent);
		pParent->PostMessage(WM_COMMAND,
			MAKEWPARAM(GetDlgCtrlID(), CLN_CHKCHANGE),
			(LPARAM)m_hWnd);

		return;
	}
	
	CListBox::OnLButtonDown(nFlags, point);
}

void CCheckList::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if (point.x < c_checkSize.cx)
	{
		// Double and single clicks act the same on the check box!
		OnLButtonDown(nFlags, point);
		return;
	}
	
	CListBox::OnLButtonDblClk(nFlags, point);
}

void CCheckList::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_SPACE)
	{
		int		nCurSel = GetCurSel();
		CWnd*	pParent = GetParent();
		ASSERT_VALID(pParent);

		if ((GetStyle() & LBS_EXTENDEDSEL) != 0)
		{
			int nSelCount = GetSelCount();
			if (nSelCount == 0)
				return;
			
			INT* pSelItems = new INT [nSelCount];
			GetSelItems(nSelCount, pSelItems);
			
			int nCheck = GetCheck(nCurSel);
			nCheck = (nCheck + 1) % 2; // can't go back to tri-state!
			
			for (int i = 0; i < nSelCount; i += 1)
			{
				SetCheck(pSelItems[i], nCheck);
				InvalidateCheck(pSelItems[i]);
			}
			
			delete [] pSelItems;
			return;
		}
		else if ((GetStyle() & LBS_MULTIPLESEL) != 0)
		{
			// For multi-sel listbox's, we cycle through the four possible
			// state combinations on each space key.
			
			int w = ((GetSel(nCurSel) ? 1 : 0) |		// toggle selection
					 ((GetCheck(nCurSel) + 1) % (IsTriState(nCurSel) ? 3 : 2) << 1))
					 + 1;
			SetSel(nCurSel, (w & 1) != 0);
			SetCheck(nCurSel, (w & 6) >> 1);
			InvalidateCheck(nCurSel);

			// Inform of check
			pParent->PostMessage(WM_COMMAND,
				MAKEWPARAM(GetDlgCtrlID(), CLN_CHKCHANGE),
				(LPARAM)m_hWnd);
			return;
		}
		else if (nCurSel != LB_ERR)
		{
			// If there is a selection, the space bar toggles that check,
			// all other keys are the same as a standard listbox.
			
			SetCheck(nCurSel, (GetCheck(nCurSel) + 1) % (IsTriState(nCurSel) ? 3 : 2));
			InvalidateCheck(nCurSel);

			// Inform of check
			pParent->PostMessage(WM_COMMAND,
				MAKEWPARAM(GetDlgCtrlID(), CLN_CHKCHANGE),
				(LPARAM)m_hWnd);
			return;
		}
	}
	
	CListBox::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CCheckList::InvalidateCheck(int nItem)
{
	CRect rect;
	GetItemRect(nItem, rect);
	rect.right = rect.left + c_checkSize.cx;
	InvalidateRect(rect, FALSE);
}

BOOL CCheckList::SubclassDlgItem(UINT nID, CWnd* pParent)
{
	if (!CWnd::SubclassDlgItem(nID, pParent))
		return FALSE;
	
	ASSERT((GetStyle() & (LBS_OWNERDRAWVARIABLE | LBS_HASSTRINGS)) == 
		(LBS_OWNERDRAWVARIABLE | LBS_HASSTRINGS) ||
	(GetStyle() & (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS)) == 
		(LBS_OWNERDRAWFIXED | LBS_HASSTRINGS));
	
	ResetItemHeight();
	
	return TRUE;
}

void CCheckList::MeasureItem(LPMEASUREITEMSTRUCT lpmis)
{
	ResetItemHeight();
	lpmis->itemHeight = m_cyItem;
	lpmis->itemWidth  = (UINT)-1;
}

void CCheckList::ResetItemHeight()
{
	if (c_checkBitmap.m_hObject == NULL)
	{
		if (theApp.m_bWin4)
		{
			VERIFY(c_checkBitmap.LoadBitmap(IDB_CHECKLISTBOXES));
			BITMAP bitmap;
			c_checkBitmap.GetObject(sizeof (BITMAP), &bitmap);
			c_checkSize.cx = bitmap.bmWidth / 3;
			c_checkSize.cy = bitmap.bmHeight;
		}
		else
		{
			VERIFY(c_checkBitmap.LoadOEMBitmap(OBM_CHECKBOXES));
			BITMAP bitmap;
			c_checkBitmap.GetObject(sizeof (BITMAP), &bitmap);
			c_checkSize.cx = bitmap.bmWidth / 4;
			c_checkSize.cy = bitmap.bmHeight / 3;
		}
	}
	
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(GetFont());
	TEXTMETRIC tm;
	VERIFY (dc.GetTextMetrics ( &tm ));
	m_cyText = tm.tmHeight;
	m_cyItem = max(c_checkSize.cy + 1, m_cyText);
	dc.SelectObject(pOldFont);
	SetItemHeight(0, m_cyItem);
}

void CCheckList::SetCheck(int nItem, int nCheck)
{
	VERIFY(SetItemData(nItem, nCheck) != LB_ERR);
	InvalidateCheck(nItem);
}

int CCheckList::GetCheck(int nItem)
{
	return GetItemData(nItem) != 0 ? 1 : 0;
}

////////////////////////////////////////////////////////////////////////////
// CPropCheckList -- a check list that can store property values

void CPropCheckList::OnPropChanged(UINT nIDProp)
{
	int iitem = 0, icount = GetCount();
	while (iitem < icount)
	{
		if (nIDProp == (GetItemData(iitem) >> 1))
			InvalidateCheck(iitem);

		iitem++;
	}
}

BOOL CPropCheckList ::IsTriState(int iitem)
{
	return FALSE;
	// Tri-state not supported until we have a better UI
	// to show undeterminate state for other dialog controls
	// eg. editboxes and listboxes
	// return (GetItemData(iitem) & 1) != 0;
}

void CPropCheckList::SetCheck(int iitem, int nval)
{
	UINT nProp = (UINT) (GetItemData(iitem) >> 1);

	ASSERT (nval != 2);
	// check or un-check
	m_pSlob->SetIntProp(nProp, nval);
}

int CPropCheckList::GetCheck(int iitem)
{
	UINT nProp = (UINT) (GetItemData(iitem) >> 1);

	int val = 0;
	if (m_pSlob->GetIntProp(nProp, val) == ambiguous)
	{
		SetItemData(iitem, (nProp << 1) + 1);	// set to a tri-state check
		return 2;	// indeterminate state
	}

	// checked or unchecked
	return val ? 1 : 0;
}

int CPropCheckList::AddItem(const char * szId, UINT nIDProp)
{
	int iitem = AddString((LPCSTR)szId);

	DWORD dwData = nIDProp << 1;
	// make sure we didn't drop bits!
	ASSERT(dwData >> 1 == (DWORD)nIDProp);

	if (iitem != CB_ERR) (void) SetItemData(iitem, dwData);
	return iitem;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cbpopup.cpp ===
// CBpopup.cpp : CBmenu replacement for Sushi popup menu support
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// popup menus

CBContextPopupMenu::CBContextPopupMenu()
{
//der 30 may 96 - TODO Remove next line
	m_pListSubMenus = NULL;
	m_idgPrev = 0;
	m_bPopup = FALSE;
	m_nPopupPos = 0;
}

CBContextPopupMenu::~CBContextPopupMenu()
{
	/* der 30 may 96 -	
	if (m_pListSubMenus != NULL)
	{
		POSITION	pos = m_pListSubMenus->GetHeadPosition();

		while (pos != NULL)
			delete m_pListSubMenus->GetNext(pos);

		delete m_pListSubMenus;
	}
	*/

	//DER Not Needed...DestroyMenu();
}

void CBContextPopupMenu::Create(POPDESC* ppop /*=NULL*/)
{
   //DER - Removed because it tries to call ::CreatePopupMenu
   // CreatePopupMenu();

	if (ppop == NULL)
		return;

	UINT nID, nIDLast = POP_SEPARATOR;
	for (int i = 0; (nID = ppop->rgmtm[i].id) != POP_NIL; i++)
	{
		BOOL bAdded=FALSE;
		if (nID == POP_SEPARATOR)
		{
			// No double separators, or separators at end of popup.
			if (nIDLast != POP_SEPARATOR && ppop->rgmtm[i + 1].id != POP_NIL)
			{
				bAdded=AppendMenu(MF_SEPARATOR);
			}
		}
		else
		{
			CString str;
			if (ppop->rgmtm[i].idString != POP_IDS_NIL)
				VERIFY(str.LoadString(ppop->rgmtm[i].idString));

			bAdded=AddItem(nID, str.IsEmpty() ? NULL : (LPCTSTR) str);
		}

		if(bAdded)
		{
			nIDLast = nID;
		}
	}
	m_bPopup = FALSE;
}

CBContextPopupMenu* CBContextPopupMenu::CreateNewSubPopup(CBContextPopupMenu* pParent)
{
	ASSERT(pParent != NULL);

	CBContextPopupMenu* pSubMenu = new CBContextPopupMenu;

	//pSubMenu->Create();
	// No longer needed pSubMenu->CreatePopupMenu(pParent) ;

	/* Der - 30 May As far as I can tell, this isn't used.
	if (pParent->m_pListSubMenus == NULL)
		pParent->m_pListSubMenus = new CObList;

	pParent->m_pListSubMenus->AddTail(pSubMenu);
	*/

	return pSubMenu;
}

BOOL CBContextPopupMenu::AddItem(UINT id, LPCTSTR lpszText)
{
	if (lpszText == NULL)
	{
		CTE *pCTE = theCmdCache.GetCommandEntry(id);

		if (NULL == pCTE)
			return FALSE;

		if ((pCTE->flags & CT_NOUI) != 0)
			return FALSE;	// Hidden menuitem.

		theCmdCache.GetCommandString(id, STRING_MENUTEXT, &lpszText, NULL, pCTE);
	}

   if ((lpszText == NULL) || ( _tcslen(lpszText) == 0))
   {
//#ifdef _DEBUG
         static TCHAR badCmdTable[] = "-PlaceHolder-" ;
         lpszText = badCmdTable ;
//#else
//         return ;
//#endif
      }

	LPTSTR buf = new TCHAR [_tcslen(lpszText) + 1];

	// strip out any trailing tab and keyboard shortcut.

	LPTSTR pchDest = buf; 
	while (*lpszText != _T('\0') && *lpszText != _T('\t'))
	{
		if (*lpszText)
		{
			_tccpy(pchDest, lpszText);
			pchDest = _tcsinc(pchDest);
			lpszText = _tcsinc(lpszText);
		}
	}
	*pchDest = _T('\0');

	BOOL bAdded=AppendMenu(MF_ENABLED, id, buf);

	delete [] buf;

	return bAdded;
}

void CBContextPopupMenu::AddSubMenu(CBContextPopupMenu* pSubMenu, LPCTSTR lpszText)
{
	//DER AppendMenu(MF_POPUP, (UINT)pSubMenu->m_hMenu, lpszText);
   //Note CBMenumPopup uses 4th parm for menu pointer...
   AppendMenu(MF_POPUP, (UINT)0, lpszText, pSubMenu);
}

UINT CBContextPopupMenu::TrackPopup(UINT flags, int x, int y, CWnd* pOwner)
{
	// if using popups from menu resource,
	if (m_bPopup)
	{
      ASSERT(0) ; // CMenuPopup can't do this yet.
      TRACE0("CBContextPoupMenu:TrackPopup -- GetSubMenu NA\r\n") ;
      return FALSE ;
		//CMenu * pmenu = GetSubMenu(m_nPopupPos);
		//ASSERT(pmenu != NULL);
		//return pmenu->TrackPopupMenu(flags, x, y, pOwner);
	}
	else
		return TrackPopupMenu(flags, x, y, pOwner);
}

UINT CBContextPopupMenu::TrackPopup(UINT flags, int x, int y, CWnd* pOwner, CRect rectAvoid)
{
	// if using popups from menu resource,
	if (m_bPopup)
	{
      ASSERT(0) ; // CMenuPopup can't do this yet.
      TRACE0("CBContextPoupMenu:TrackPopup -- GetSubMenu NA\r\n") ;
      return FALSE ;
		//CMenu * pmenu = GetSubMenu(m_nPopupPos);
		//ASSERT(pmenu != NULL);
		//return pmenu->TrackPopupMenu(flags, x, y, pOwner);
	}
	else
		return TrackPopupMenuEx(flags, x, y, pOwner, rectAvoid);
}

#if 0
BOOL CBContextPopupMenu::LoadMenu(UINT nID)
{
	if (CMenu::LoadMenu(nID))
	{
		m_bPopup = TRUE;
		SetPos(0);
	}
	else 
	{
		m_bPopup = FALSE;
		m_nPopupPos = 0;
	}
	return m_bPopup;
}

void CBContextPopupMenu::SetPos( int nPopupPos )
{
	ASSERT(m_bPopup == TRUE);
	ASSERT(GetSubMenu(nPopupPos)!=NULL);
	m_nPopupPos = nPopupPos;
}

#endif

void CBShowContextPopupMenu(POPDESC* ppop, CPoint pt, CWnd* pWnd /*= NULL*/)
{
   CWnd* pWndCommand = pWnd ;
   if (pWndCommand == NULL)
   {
      //CMainFrame* pWndCommand = (CMainFrame*) AfxGetMainWnd();
      pWndCommand = (CWnd*) AfxGetMainWnd();
      ASSERT_VALID(pWndCommand);
   }

	CBContextPopupMenu menuPopup;
	menuPopup.Create(ppop);

	menuPopup.TrackPopup(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
		pt.x, pt.y, pWndCommand);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cmdcache.h ===
/////////////////////////////////////////////////////////////////////////////
//	CMDCACHE.H

#ifndef __CMDCACHE_H__
#define __CMDCACHE_H__

class CPack;
class CASBar;
class CDockManager;
class CMainGroup;
class CBMenuPopup;
class CCmdGroup;

struct POPDESC;

/////////////////////////////////////////////////////////////////////////////
//	class CToolGroup

class CToolGroup
{
// Construction
public:
	CToolGroup();

// Operations
public:
	void AddGroup(int nGroup);
	void Fill(POPDESC* ppop,UINT nId=0);

	LPCTSTR GetCommandName(UINT nCmdID);

	CASBar* CreateCASBar(CWnd* pParent, CDockManager* pManager);
	// when bForButtons is true, this will omit any command
	// which cannot be bound to a toolbar button
	void FillCommandList(CListBox *pList, BOOL bForButtons=FALSE);

// Attributes
public:
	CPtrArray m_aCmds;
	CString m_strGroup;
	// ID of the menu bar menu which caused this toolgroup to exist
	UINT m_nId;
	// Number of commands in the group, currently unused.
	int m_nCmds;
};

/////////////////////////////////////////////////////////////////////////////
//	class CAppToolGroups

class CAppToolGroups
{
public:
	static CAppToolGroups* s_pAppToolGroups;

	static CAppToolGroups* GetAppToolGroups(BOOL bShowWaitCursor = FALSE);
	static void ReleaseAppToolGroups();

// Construction
public:
	CAppToolGroups();
	~CAppToolGroups();

// Operations
public:
	//REVIEW: Support for a dirty command cache
	BOOL ScanCommandCache();

	void GetCommandName(UINT nCmdID, CString& str);

	void FillGroupList(CComboBox *pList);
	void FillCommandList(UINT nGroup, CListBox *pList);
	void CreateCustomizeToolbars(CWnd* pParent, CDockManager* pManager, CObArray* pToolbars, CStringArray *pTitles, CWordArray *aIds);
	CToolGroup* GroupFromCommandName(LPCTSTR szCmdName);

// Attributes
public:
	//REVIEW: Support for a dirty command cache
	WORD m_wSyncID;

	UINT m_nUsage;
	int m_nGroups;

	// total number of commands in all groups
	int m_nCmds; 
	CToolGroup* m_rgGroups;
};

/////////////////////////////////////////////////////////////////////////////
//	class CCmdCache

struct CTE
{
	WORD id;
	WORD group;
	WORD flags;
	WORD glyph;
	LPCTSTR szCommand;

	BOOL IsActive(void);

	// Access the pack stored in the CTE. For internal use only
	CPack *GetPack(void) { return pPack; };
	void SetPack(CPack *thePack) { pPack=thePack; };

	// Gets the pack, adjusted for which pack is active, and resolving sharing issues
	CPack *GetActivePack(void);

	// returns true if the specified pack is in the list
	BOOL FindPack(CPack *);

	// returns true if the specified pack is in the list
	BOOL FindPackage(CPackage *);

	// Gets any real pack, resolving sharing issues
	CPack *GetFirstPack(void);

private:
	CPack* pPack;
};

inline LPCTSTR ShellGetNextString(LPCTSTR szCommand, UINT iString)
{	while (iString--) szCommand += lstrlen(szCommand) + 1;
	return szCommand; }

class CCmdCache
{
public:
	CCmdCache();
	~CCmdCache();

	BOOL AddCommandResource(CPack* pPack, LPCTSTR lpCmdTableID, BOOL bSearch=FALSE);
	BOOL AddCommand(WORD id, WORD group, WORD flags, WORD glyph,
					CPack* pPack, LPCTSTR szCommand, int nCmdLength);
	// Packages should use this to remove commands that are being permanently removed from the system.
	// UI elements related to the command will be irretrievably removed from the UI. If pPack is not
	// the owner of the command, then the command will not be removed. This stops most commands being removed
	// erroneously by confused packages. 
	BOOL RemoveCommand(WORD id, CPack* pPack);

	CTE* GetCommandEntry(UINT nID);
	void ReplaceCommandString(UINT nID, UINT iString, LPCTSTR szNewSubString);
	BOOL GetCommandString(UINT nID, UINT iString, LPCTSTR* pszString, WORD *pflags = NULL, CTE* pCTE = NULL);
	BOOL GetCommandID(LPCTSTR szCommand, UINT* pnID);

	// retrieves the CBMenu structure for a given menu command id
	CBMenuPopup *GetMenu(UINT nIDMenu);
	// sets or replaces the existing version of a menu (not for general use
	void SetMenu(UINT nIDMenu, CBMenuPopup *pMenu);
	// iteration through menus
	POSITION GetFirstMenuPosition() { return m_pMenus->GetStartPosition(); };
	void GetNextMenu(POSITION &rNextPosition, UINT &nIDMenu, CBMenuPopup *&rpMenu) { m_pMenus->GetNextAssoc(rNextPosition, nIDMenu, rpMenu); };

	HMENU GetOleMenu();

	void ProcessCommands(CMainGroup* pMainGroup, BOOL bRestrict=TRUE, BOOL bOLE=FALSE, BOOL bMenuOnly=TRUE);
	void AddPopToGroup(POPDESC* ppop, CCmdGroup* pGroup);
	void FillMenuList(CListBox *pList);
	void FillNewMenuList(CListBox *pList);
	void FillAllCommandsList(CListBox *pList, BOOL bKeyboard=FALSE);
	void FillDeletedCommandsList(CListBox *pList);
	int GetNextFreeMenu(void);
	void FlushMenuSizes(void);

	// These two are for shared commands only.
	// Gets the pack, adjusted for which pack is active, and resolving sharing issues
	CPack *GetActivePack(UINT id);
	// Gets any real pack, resolving sharing issues
	CPack *GetFirstPack(UINT id);
	// Finds if a pack is in the list
	BOOL FindPack(UINT id, CPack *pFindPack);
	// Finds if a pack belonging to the package is in the list
	BOOL FindPackage(UINT id, CPackage *pFindPackage);

	// call at shutdown to save all of the menus
	void CCmdCache::SaveMenus();

#ifdef _DEBUG
	void PrintCommandTable();
#endif

	//REVIEW: Support for a dirty command cache
	WORD m_wSyncID;

protected:
	const BYTE* ParseCommand(const BYTE* pb, int nLen,
		CPack* pPack, CTE& cte, BOOL *bSuppress);

protected:
	enum {
		SHELL_COMMAND_BASE = 0x8000,

		SHELL_COMMAND_BLOCKSIZE = 0x1000,
	};

	int m_cBlocks;
	int m_cCommands;
	CTE* m_rgCommands;
	CWordArray m_rgMenuCommands;	// this is an array of indexes into m_rgCommands, and contains all menu commands.
	HGLOBAL m_prgKnownPackages;	// the array of known packages, in registry form, preceded by size word. Each package
								// id is in a DWORD

	HANDLE m_hStringHeap;

	CMap<UINT, UINT, CBMenuPopup *, CBMenuPopup *&> *m_pMenus;
	
	// To support shared commands, we need to map from a command id to a CPtrArray of CPacks
	CMap<UINT, UINT, CTypedPtrArray<CObArray, CPack *> *, CTypedPtrArray<CObArray, CPack*> *&> *m_pSharedCommands;

	friend class CTheApp;
	friend class CMainFrame;
	friend class CToolGroup;

};

extern CCmdCache theCmdCache;

#endif	// __CMDCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cmdcache.cpp ===
/////////////////////////////////////////////////////////////////////////////
//	CMDCACHE.CPP

/* We now allow commands to be  shared between two packets. Only packet commands can be shared. Each packet has a command 
table entry for the commandand as the packet. When the packet command table is loaded, we check each command to see if it
is a duplicate of an existing command. If it is, we 'merge' the two command table entries by setting them to PACKET_SHARED
and adding them to a map of shared commands.

In the debug build, we ensure that the commands have identical flags, bitmaps, etc, in both packages; in release, we ignore
such problems.

Advantages of this solution:
Shell does not have to grow for commands to be shared
All packet commands can be shared, even after ship
No coupling between those sharing commands
Only one command table entry per command, still
No major design changes late in the dev cycle

Disadvantages of this solution:
Searching for duplicates at load time may be a speed issue. If so, we will need to add a CMap of commands, which isn't a bad
idea anyway.
Command tables in different packages must be kept in sync

Other solutions considered:
Client packages 'subscribe' to commands at init time. This would be faster, but creates a coupling between packages or requires 
us to move commands into the shell.
We could simply allow multiple command table entries to exist for a single command ID, and switch the order of packet command 
tables through use of sublists. This is actually a pretty strong idea, but would destabilise things too much for this stage,
in my opinion. Plus, we'd have to closely examine the lifetime of CTEs at all stages, and we'd be prone to bad packages with
aberrant shared command flags.

martynl, 15 Aug 96
*/

#include "stdafx.h"
#include "cmdcache.h"
#include "shlmenu.h"
#include "bardockx.h"
#include "btnctl.h"
#include "toolexpt.h"
#include "prjapi.h"
#include "resource.h"
#include "barglob.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern HMENU GetCommandMenu(BOOL bOleIPMenu);

CString g_strCmdDynamic;  // global holder for dynamic command string (must not be held, but immediately copied)

// Implementation helper class - CSharedPack is the CPack of shared commands

class CSharedPacket : public CPacket
{
public:
	CSharedPacket() : CPacket(NULL, PACKET_SHARED) {};
};

static CSharedPacket s_sharedPack;

/////////////////////////////////////////////////////////////////////////////
//	class CCmdCache

CCmdCache theCmdCache;	// Single command cache global.

CCmdCache::CCmdCache()
{
	m_cBlocks = 0;
	m_cCommands = 0;
	m_rgCommands = NULL;

	m_hStringHeap = HeapCreate(0, 4096, 0);

	m_pMenus=NULL;
	m_pSharedCommands=NULL;
	m_prgKnownPackages=NULL;

	//REVIEW: Support for a dirty command cache
	m_wSyncID = 1;
}

CCmdCache::~CCmdCache()
{
	if (m_rgCommands != NULL)
		free(m_rgCommands);

	if(m_prgKnownPackages!=NULL)
	{
		GlobalFree(m_prgKnownPackages);
		m_prgKnownPackages=NULL;
	}

	VERIFY(HeapDestroy(m_hStringHeap));

	if(m_pMenus!=NULL)
	{
		// delete all of the menu structures
		CBMenuPopup *pMenu=NULL;
		UINT nIDMenu;
		POSITION pos=m_pMenus->GetStartPosition();

		// first delete the objects
		while(pos)
		{
			m_pMenus->GetNextAssoc(pos, nIDMenu,pMenu);
			if(pMenu)
			{
				pMenu->DestroyWindow();
				delete pMenu;
			}
		}

		// then unmap them
		m_pMenus->RemoveAll();

		// can now lose the map itself
		delete m_pMenus;
		m_pMenus=NULL;
	}

	if(m_pSharedCommands!=NULL)
	{
		// delete all of the CPtrArrays
		CTypedPtrArray<CObArray, CPack*> *pPackets;
		UINT nIDCommand;
		POSITION pos=m_pSharedCommands->GetStartPosition();

		// first delete the objects
		while(pos)
		{
			m_pSharedCommands->GetNextAssoc(pos, nIDCommand,pPackets);
			if(pPackets)
			{
				delete pPackets;
			}
		}

		// then unmap them
		m_pSharedCommands->RemoveAll();

		// can now lose the map itself
		delete m_pSharedCommands;
		m_pSharedCommands=NULL;
	}
}

CBMenuPopup *CCmdCache::GetMenu(UINT nIDMenu)
{
	if(m_pMenus!=NULL)
	{
		CBMenuPopup *pMenu=NULL;
		
		if(m_pMenus->Lookup(nIDMenu, pMenu))
		{
			return pMenu;
		}
	}
	return NULL;
}

	// sets or replaces the existing version of a menu (not for general use
void CCmdCache::SetMenu(UINT nIDMenu, CBMenuPopup *pMenu)
{
	if(m_pMenus==NULL)
	{
		// the magic number 5 is the grow by size for the table; low because this
		// will do all of its growing at one time.
		m_pMenus=new CMap<UINT, UINT, CBMenuPopup *, CBMenuPopup *&>(5);
		// 70 should provide enough room for growth - the current product has 25 menus,
		// and the number should be 20% higher than that. We should probably increase this
		// as we get more package partners
		m_pMenus->InitHashTable(70);
	}
	else
	{
		// consider deleting this element
		CBMenuPopup *pOldMenu=GetMenu(nIDMenu);
		if(pOldMenu!=NULL)
		{
			pOldMenu->DestroyWindow();
			delete pOldMenu;
			m_pMenus->RemoveKey(nIDMenu);
		}
	}

	// now add the new one
	m_pMenus->SetAt(nIDMenu, pMenu);
}

static const BYTE* ParseWord(const BYTE* pb, int nLen, WORD& w)
{
	if(nLen < sizeof(WORD))
		return NULL;
	w = *(WORD*)pb;
	return pb + sizeof(WORD);
}

const BYTE* CCmdCache::ParseCommand(const BYTE* pb, int nLen,
	CPack* pPack, CTE& cte,
	BOOL *pbSuppress				// TRUE if the command was suppressed, and should not be included in the command table
	)
{
	ASSERT(pbSuppress!=NULL);
	*pbSuppress=FALSE;
	BOOL bShared=FALSE;

	const BYTE* pbEnd = pb + nLen;
	WORD w;

	if( (pb = ParseWord(pb, pbEnd - pb, w)) == NULL )		// ID
		return NULL;
	cte.id = w;
	if( (pb = ParseWord(pb, pbEnd - pb, w)) == NULL )		// Group ID
		return NULL;
	cte.group = w;
	if( (pb = ParseWord(pb, pbEnd - pb, w)) == NULL )		// Flags
		return NULL;
	cte.flags = w;
	if( (pb = ParseWord(pb, pbEnd - pb, w)) == NULL )		// Glyph
		return NULL;
	cte.glyph = (int)(short)w;

	// At this point, we can discover whether the command is a duplicate of one provided by another
	// package
	CTE *pOtherCTE=GetCommandEntry(cte.id);
	if(pOtherCTE)
	{
		// This command has been loaded before
		if(	pOtherCTE->GetPack()!=NULL &&
			pPack!=NULL)
		{
			UINT nOldPacketID=pOtherCTE->GetPack()->PacketID();
			UINT nNewPacketID=pPack->PacketID();

			if(	nOldPacketID!=PACKET_NIL &&
				nNewPacketID!=PACKET_NIL)
			{
				// At this point, we are going to share the command. If this is a debug build, we're also going to
				// make sure that the command has the same properties as its co-sharer.

				// If either of these fail, it means that one of the sharers has a bad command table entry.
				ASSERT(cte.group==pOtherCTE->group);
				ASSERT(cte.flags==pOtherCTE->flags);
				// The two glyph indices need not be the same, but they must either both be -1 or neither
				ASSERT(	((cte.glyph==-1) ^ (pOtherCTE->glyph==-1))==0);
				bShared=TRUE;

				// Some flags are not permitted on shared commands, because these flags need to ask a package for information
				// even when there is no, or another, active packet
				if(cte.flags & 	(CT_HWND | CT_HWNDSIZE | CT_HWNDENABLE | CT_MENU | CT_DYNAMIC_CMD_STRING))
				{
					// can's share this, guv.
					ASSERT(FALSE);
				}

				// Two possibilities here. Either the command is already shared (PACKET_SHARED), or it need to be
				// made into a shared one.

				if(nOldPacketID!=PACKET_SHARED)
				{
					// allocate the command map, if we've not already done that
					if(m_pSharedCommands==NULL)
					{
						// the magic number 5 is the grow by size for the table; low because this
						// will do all of its growing at one time.
						m_pSharedCommands=new CMap<UINT, UINT, CTypedPtrArray<CObArray, CPack*> *, CTypedPtrArray<CObArray, CPack*> *&>(5);
						// 100 should provide enough room for growth - the current product has an unknown number of 
						// shared commands and the number should be 20% higher than that. We should probably modify 
						// this near ship time.
						m_pSharedCommands->InitHashTable(50);
					}

					// ensure that we don't already have an association for this command
					CTypedPtrArray<CObArray, CPack*> *pPackets=NULL;
					ASSERT(!m_pSharedCommands->Lookup(cte.id, pPackets));

					// create the array of packets
					pPackets=new CTypedPtrArray<CObArray, CPack*>;

					// initial size is 2 so that we can accomodate the existing and the new packet
					pPackets->SetSize(2);

					// fill array
					pPackets->SetAt(0, pOtherCTE->GetPack());
					pPackets->SetAt(1, pPack);

					// map array
					m_pSharedCommands->SetAt(cte.id, pPackets);

					pOtherCTE->SetPack(&s_sharedPack);
				}
				else
				{
					// ensure that we do already have an association for this command
					CTypedPtrArray<CObArray, CPack*> *pPackets=NULL;
					VERIFY(m_pSharedCommands->Lookup(cte.id, pPackets));

					// add this packet to the set
					pPackets->Add(pPack);
				}
				
				// suppress this one because it got merged with the other one
				*pbSuppress=TRUE;

				// Should always be shared by now.
				ASSERT(pOtherCTE->GetPack()->PacketID()==PACKET_SHARED);
			}
			else
			{
				// someone tried to share a global command. You can't do that, and there's no need anyway.
				ASSERT(FALSE);
				*pbSuppress=TRUE;
			}
		}
		else
		{
			// Someone has attempted to share a command where one of the two has no pPack. This is not allowed
			ASSERT(FALSE);
			*pbSuppress=TRUE;
		}
	}

	// always parse rest of command, even if we are suppressing
	if( (pb = ParseWord(pb, pbEnd - pb, w)) == NULL )		// String length
		return NULL;
	if (w > pbEnd - pb)
		return NULL;

	// only allocate space for strings if we are not suppressing
	if(!*pbSuppress)
	{
		cte.SetPack(pPack);
		LPTSTR szCommand = (LPTSTR) HeapAlloc(m_hStringHeap, 0, w);
		memcpy(szCommand, pb, w);
		cte.szCommand = szCommand;
	}

	if(!*pbSuppress)
	{
		// if the commands were shared, then in debug we want to ensure the strings were the same
		if(bShared)
		{
			ASSERT(memcmp(pOtherCTE->szCommand, pb, w)==0);

			TRACE2("CCmdCache::ParseCommand: Sharing command %s (%d)\n\r", cte.szCommand, cte.id);
		}
		else
		{
#ifdef _DEBUG

// Because the database can't generate good command table entries, we're removing some of the assertions
// until after 5.0 ships
#if 0
#define BCASSERT(x) ASSERT(x)
#else
#define BCASSERT(x)
#endif

			// This is the first time of loading for a command. So we're going to do some validation on what 
			// command strings it should have
			ASSERT(STRING_COMMAND+1==STRING_MENUTEXT);
			ASSERT(STRING_MENUTEXT+1==STRING_PROMPT);
			ASSERT(STRING_PROMPT+1==STRING_TIP);

			LPCTSTR lpszString=cte.szCommand;
			BOOL bHasCommand=strlen(lpszString)>0;
			lpszString=ShellGetNextString(lpszString, STRING_MENUTEXT-STRING_COMMAND);
			BOOL bHasMenuText=strlen(lpszString)>0;
			lpszString=ShellGetNextString(lpszString, STRING_PROMPT-STRING_MENUTEXT);
			BOOL bHasPrompt=strlen(lpszString)>0;
			lpszString=ShellGetNextString(lpszString, STRING_TIP-STRING_PROMPT);
			BOOL bHasTip=strlen(lpszString)>0;

			// No other command can have the same name
			if(bHasCommand)
			{
				UINT nID;
				BOOL bAlreadyExists=GetCommandID(cte.szCommand, &nID);
				if(bAlreadyExists)
				{
					TRACE2("CCmdCache::ParseCommand: Duplicate command name in command table entry %s (%x)\n\r", cte.szCommand, cte.id);
				}
				ASSERT(!bAlreadyExists);
			}

			// validate unwanted flag combinations
			if(cte.flags & CT_NOKEY)
			{
				if((cte.flags & (CT_NOMENU | CT_QUERYMENU | CT_DYNAMIC))==0)
				{
					TRACE2("CCmdCache::ParseCommand: Non DYNAMIC Menu command with NOKEY flag is nonsensical %s (%x)\n\r", cte.szCommand, cte.id);
				}
				ASSERT((cte.flags & (CT_NOMENU | CT_QUERYMENU | CT_DYNAMIC))!=0);
			}
			
			if(cte.flags & CT_MENU)
			{
				if(!bHasCommand || !bHasMenuText || !bHasPrompt || bHasTip)
				{
					TRACE2("CCmdCache::ParseCommand: Bad menu command table entry %s (%x)\n\r", cte.szCommand, cte.id);
				}
				// menus are a special case. They require a command, menu text, and prompt, and should not have a tip (waste of space)
				ASSERT(bHasCommand);
				ASSERT(bHasMenuText);
				ASSERT(bHasPrompt);
				BCASSERT(!bHasTip);
			}
			else if(cte.flags & CT_HWND)
			{
				if(!bHasPrompt || !bHasTip)
				{
					TRACE2("CCmdCache::ParseCommand: Bad window command table entry %s (%x)\n\r", cte.szCommand, cte.id);
				}
				// hwnds are a special case. All we know is that they have to have a tip and prompt
				ASSERT(bHasPrompt);
				ASSERT(bHasTip);
			}
			else
			{
				if(cte.flags & CT_NOKEY)
				{
					if(bHasTip)
					{
						TRACE2("CCmdCache::ParseCommand: Bad NOKEY command table entry %s (%x)\n\r", cte.szCommand, cte.id);
					}
					// NOKEY, NOBUTTON commands shouldn't have a tip (waste of space)
					BCASSERT(!bHasTip);

					if(bHasCommand)
					{
						TRACE2("CCmdCache::ParseCommand: Questionable NOKEY command table entry (probably shouldn't have a command name) %s (%x)\n\r", cte.szCommand, cte.id);
					}

					// can have other two. This is probably a context menu command
				}
				else
				{
					if(cte.flags & CT_NOBUTTON)
					{
						if(!bHasCommand || !bHasMenuText || !bHasPrompt)
						{
							TRACE2("CCmdCache::ParseCommand: Bad NOBUTTON command table entry %s (%x)\n\r", cte.szCommand, cte.id);
						}
						
						// must have everything; can have tip to allow substitution
						ASSERT(bHasCommand);
						ASSERT(bHasMenuText);
						ASSERT(bHasPrompt);
					}
					else
					{
						if(!bHasTip || !bHasCommand || !bHasMenuText || !bHasPrompt)
						{
							TRACE2("CCmdCache::ParseCommand: Bad normal command table entry %s (%x)\n\r", cte.szCommand, cte.id);
						}
						
						// must have everything, except the tip, which is unneeded
						ASSERT(bHasTip);
						ASSERT(bHasCommand);
						ASSERT(bHasMenuText);
						ASSERT(bHasPrompt);
					}
				}
			}
#endif
		}
	}

	return (pb + w);
}

BOOL CCmdCache::AddCommandResource(CPack* pPack, LPCTSTR lpCmdTableID, BOOL bSearch /*=FALSE*/)
{
	HINSTANCE hInstance;
	if(!bSearch)
	{
		hInstance = pPack->HInstance();
	}
	else
	{
		hInstance= AfxFindResourceHandle(lpCmdTableID, _T("COMMAND_TABLE"));
		ASSERT(hInstance!=NULL);
	}

	HRSRC hRsrc = FindResource(hInstance, lpCmdTableID, _T("COMMAND_TABLE"));
	if (hRsrc == NULL)
	{
		ASSERT(FALSE);
		return FALSE;
	}
	HGLOBAL hGlobal = LoadResource(hInstance, hRsrc);
	ASSERT(hGlobal != NULL);
	const BYTE* pb = (const BYTE*)LockResource(hGlobal);
	ASSERT(pb != NULL);
	int nLen = (int)SizeofResource(hInstance, hRsrc);
	ASSERT(nLen > 0);

	const BYTE* pbEnd = pb + nLen;

	// verify that this is a known data format
	WORD wVersion;
	if( (pb = ParseWord(pb, pbEnd - pb, wVersion)) == NULL )
		return FALSE;
	ASSERT(wVersion == 0x1);		// this code only reads data format #1

	int nDataMax = m_cBlocks * SHELL_COMMAND_BLOCKSIZE;
	int nDataNext = (m_cCommands + 1) * sizeof(CTE);
	int cCommandsStart = m_cCommands;

	do
	{
		if (nDataNext > nDataMax)
		{
			m_cBlocks++;
			nDataMax += SHELL_COMMAND_BLOCKSIZE;
			if (m_rgCommands == NULL)
				m_rgCommands = (CTE*) malloc(nDataMax);
			else
				m_rgCommands = (CTE*) realloc(m_rgCommands, nDataMax);
		}

		BOOL bSuppress=FALSE;
			
		pb = ParseCommand(pb, pbEnd - pb, pPack, m_rgCommands[m_cCommands], &bSuppress);
		if (pb != NULL && !bSuppress)
		{
			if(m_rgCommands[m_cCommands].flags & CT_MENU)
			{
				// cache the indexes of all menu commands into a separate array, to enable
				// RebuildMenus to perform acceptably fast
				m_rgMenuCommands.SetAtGrow(m_rgMenuCommands.GetSize(), (WORD)m_cCommands);
			}
			m_cCommands++;
			nDataNext += sizeof(CTE);
		}
	}
	while (pb != NULL);

	return TRUE;
}

BOOL CCmdCache::AddCommand(WORD id, WORD group, WORD flags, WORD glyph,
							CPack* pPack, LPCTSTR szCommand, int nCmdLength)
{
	// can't have two commands with the same id.
	ASSERT(GetCommandEntry(id)==NULL);

	if (m_rgCommands == NULL)
		return FALSE;		// Currently this only works if commands already exist

	// Increase array size if necessary

	int nSize = m_cBlocks * SHELL_COMMAND_BLOCKSIZE;
	m_cCommands++;
	int nRequiredSize = m_cCommands * sizeof(CTE);

	if (nRequiredSize > nSize)
	{
		m_cBlocks++;
		m_rgCommands = (CTE*) realloc(m_rgCommands, nSize + SHELL_COMMAND_BLOCKSIZE);
	}

	// This is the CTE we'll fill in
	CTE* pCte = &(m_rgCommands[m_cCommands-1]);

	pCte->id = id;
	pCte->group = group;
	pCte->flags = flags;
	pCte->glyph = glyph;
	pCte->SetPack(pPack);

	LPTSTR szCopiedCommand = (LPTSTR) HeapAlloc(m_hStringHeap, 0, nCmdLength);
	memcpy(szCopiedCommand, szCommand, nCmdLength);
	pCte->szCommand = szCopiedCommand;

	m_wSyncID++;

	return TRUE;
}

// Packages should use this to remove commands that are being permanently removed from the system.
// UI elements related to the command will be irretrievably removed from the UI. If pPack is not
// the owner of the command, then the command will not be removed. This stops most commands being removed
// erroneously by confused packages. 
BOOL CCmdCache::RemoveCommand(WORD id, CPack* pPack)
{
	// validate whether this pack is allowed to delete this
	CTE *pCTE=GetCommandEntry(id);
	if(pCTE==NULL)
	{
		return FALSE;
	}
	if(pCTE->GetPack()!=pPack)
	{
		return FALSE;
	}

	// Remove the command from all bars
	CASBar::RemoveAllCommandReferences(id);

	// Remove the command from all menus
	if(Menu::IsInCmdBarMode())
	{
		CBMenuPopup *pMenu=NULL;
		UINT nIDMenu;
		POSITION pos=m_pMenus->GetStartPosition();

		// first delete the objects
		while(pos)
		{
			m_pMenus->GetNextAssoc(pos, nIDMenu,pMenu);
			if(pMenu)
			{
				pMenu->RemoveCommandReferences(id);
			}
		}

	}
	else
	{
		CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();
		pFrame->RebuildMenus();
	}

	// work out how much to shift down
	int nTableIndexAfter=(pCTE+1)-m_rgCommands;
	int nEntriesToMove=m_cCommands-nTableIndexAfter;
	size_t nBytesToMove=sizeof(CTE)*nEntriesToMove;

	// use memmove to copy down rest of command table
	memmove(pCTE, pCTE+1, nBytesToMove);

	--m_cCommands;

	m_wSyncID++;

	return TRUE;
}

CTE* CCmdCache::GetCommandEntry(UINT nID)
{
	for (int i = 0; i < m_cCommands; i++)
	{
		if (m_rgCommands[i].id == (WORD) nID)
			return &m_rgCommands[i];
	}

	return NULL;
}

void CCmdCache::ReplaceCommandString(UINT nID, UINT iString, LPCTSTR szNewString)
{
	// Doesn't support changing the name of the command itself
	ASSERT(iString != STRING_COMMAND);
	ASSERT(iString <= STRING_MAX_INDEX);

	CTE* pCTE = GetCommandEntry(nID);
	if (pCTE == NULL)
	{
		ASSERT(FALSE);		// command not found
		return;
	}

	// How big is the new command string?
	LPCTSTR szSubStringToReplace = ShellGetNextString(pCTE->szCommand, iString);
	LPCTSTR szNextSubString = ShellGetNextString(szSubStringToReplace, 1);
	LPCTSTR szEndString = ShellGetNextString(szNextSubString, STRING_MAX_INDEX-iString);
	int nPreLength = szSubStringToReplace - pCTE->szCommand;	// stuff before replaced substring
	int nNewSubLength = _tcslen(szNewString) + 1;				// new substring
	int nPostLength = szEndString - szNextSubString;			// stuff after replaced substring
	int nLength = nPreLength + nNewSubLength + nPostLength;

	// Fill in the new command string
	LPTSTR szNewCmdString = (LPTSTR) HeapAlloc(m_hStringHeap, 0, nLength);
	//		Copy stuff before new sub string
	memcpy(szNewCmdString, pCTE->szCommand, nPreLength);
	//		Copy new substring
	memcpy(szNewCmdString + nPreLength, szNewString, nNewSubLength);
	//		Copy stuff after new substring
	memcpy(szNewCmdString + nPreLength + nNewSubLength, szNextSubString, nPostLength);

	// Out w/ the old, in w/ the new	
	HeapFree(m_hStringHeap, 0, (void*) pCTE->szCommand);
	pCTE->szCommand = szNewCmdString;
	m_wSyncID++;
}

// IMPORTANT NOTE: with the advent of dynamic command strings, we can no longer
// rely on the cmd table to hold the string data. A dynamic command string will
// return a bstr, which we convert to a CString in the SINGLE global string g_strCmdDynamic.

// What this means is that the caller of this function cannot simply hold onto the string
// this function returns, but must copy it immediately. Since virtually all callers did
// this already, this is no additional burden. If we decide we need to be able to hold
// strings we can revisit this, and pass back a bstr and a flag, but currently (7/96)
// this is not needed bobz

BOOL CCmdCache::GetCommandString(UINT nID, UINT iString, LPCTSTR* pszString, WORD *pflags /* = NULL */, CTE* pCTE /* = NULL */)
{
	if (pCTE == NULL)
	{
		pCTE = GetCommandEntry(nID);
		if (pCTE == NULL)
			return FALSE;
	}

	if (pflags != NULL)
		*pflags = pCTE->flags;

	// Note: (bobz) since macros use command names, we disallow changing the
	// command name (STRING_COMMAND) itself; otherwise macros would not work consistently

	if (pCTE->flags & CT_DYNAMIC_CMD_STRING && (iString != STRING_COMMAND)) // special handling for dynamic strings
	{
		ASSERT(pCTE->GetPack() != NULL);
		CPackage *pPackage = pCTE->GetPack()->GetPackage();
		ASSERT(pPackage != NULL);
		BSTR bstr;
		bstr = pPackage->GetDynamicCmdString(nID, iString);
		if (bstr != NULL)
		{
			g_strCmdDynamic = bstr;	  // only 1 cstring. Caller must not hold
			::SysFreeString(bstr);
			*pszString = (LPCTSTR)g_strCmdDynamic;
			return TRUE; // else fall through
		}
	}

	*pszString = ShellGetNextString(pCTE->szCommand, iString);
	return TRUE;
}

BOOL CCmdCache::GetCommandID(LPCTSTR szCommand, UINT* pnID)
{
	for (int i = 0; i < m_cCommands; i++)
	{
		if (_tcscmp(m_rgCommands[i].szCommand, szCommand) == 0)
		{
			*pnID = m_rgCommands[i].id;
			return TRUE;
		}
	}

	return FALSE;
}

HMENU CCmdCache::GetOleMenu()
{
	return GetCommandMenu(TRUE);
}

// Fill a list box (pList) with each of the possible available menus, except for empty ones
void CCmdCache::FillMenuList(CListBox *pList)
{
	// search all the menus in the command table for any menus in the specified group, and add them
	for (int i = 0; i < m_rgMenuCommands.GetSize() ; i++)
	{
		ASSERT(m_rgMenuCommands[i]<theCmdCache.m_cCommands);

		CTE *pCTE = &m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

		ASSERT(pCTE);
		ASSERT(pCTE->flags & CT_MENU);

		CBMenuPopup *pMenu=theCmdCache.GetMenu(pCTE->id);
		if(	pMenu &&
			pMenu->GetCount()>0)
		{
			LPCTSTR pszMenu;
			VERIFY(GetCommandString(pCTE->id, STRING_MENUTEXT, &pszMenu));

			// remove the ampersands
			CString menuName=pszMenu;
			int nMenuNameLen=menuName.GetLength();
			LPTSTR pszMenuName=menuName.GetBuffer(nMenuNameLen+1); // plus 1 because getlength doesn't include terminator
			GLOBAL_DATA::StripAmpersands(pszMenuName, nMenuNameLen);
			menuName.ReleaseBuffer(-1);

			// add it to the list
			int index=pList->AddString(menuName);
			ASSERT(index!=LB_ERR);
			pList->SetItemData(index, pCTE->id);
		}
	}
}

// Fill a list box (pList) with the first empty custom menu ones
void CCmdCache::FillNewMenuList(CListBox *pList)
{
	if(GetNextFreeMenu()>0)
	{
		CString newMenu;
		newMenu.LoadString(IDS_NEWMENU);
		int index=pList->AddString(newMenu);

		ASSERT(index!=LB_ERR);

		pList->SetItemData(index, CButtonDragListBox::cNextFreeMenu);
	}
}

int CCmdCache::GetNextFreeMenu(void)
{
	// search all the menus in the command table for any menus in the specified group, and add them
	for (int i = 0; i < m_rgMenuCommands.GetSize() ; i++)
	{
		ASSERT(m_rgMenuCommands[i]<theCmdCache.m_cCommands);

		CTE *pCTE = &m_rgCommands[theCmdCache.m_rgMenuCommands[i]];

		ASSERT(pCTE);
		ASSERT(pCTE->flags & CT_MENU);

		if(	pCTE->id>=IDM_CUSTOMMENU_BASE && 
			pCTE->id<=IDM_CUSTOMMENU_LAST)
		{
			CBMenuPopup *pMenu=theCmdCache.GetMenu(pCTE->id);
			if(	pMenu &&
				pMenu->GetCount()==0)
			{
				return pCTE->id;
			}
		}
	}

	return 0;
}

#ifdef _DEBUG
void CCmdCache::PrintCommandTable()
{
	CDC dc;
	CDC dcBitmap;
	
//	CWaitCursor waitCursor;
	
	char szDevice [256];
	GetProfileString("Windows", "device", "", szDevice, sizeof (szDevice));
	if (szDevice[0] == 0)
	{
		AfxMessageBox("No printer selected.", MB_OK | MB_ICONEXCLAMATION);
		return;
	}
	
	char szDesc [128];
	char szDriver [32];
	char szPort [32];
	if (sscanf(szDevice, "%[^,],%[^,],%[^,]", szDesc, szDriver, szPort) != 3)
	{
		AfxMessageBox(CString(szDevice) + "\n\nInvalid printer description.", 
			MB_OK | MB_ICONEXCLAMATION);
		return;
	}
	
	if (!dc.CreateDC(szDriver, szDesc, szPort, NULL))
	{
		AfxMessageBox("Cannot open printer.", MB_OK | MB_ICONEXCLAMATION);
		return;
	}
	
	int nPageWidth = dc.GetDeviceCaps(HORZRES);
	int nPageHeight = dc.GetDeviceCaps(VERTRES);
	int nXPelsPerInchPrinter = dc.GetDeviceCaps(LOGPIXELSX);
	int nYPelsPerInchPrinter = dc.GetDeviceCaps(LOGPIXELSY);

	CFont font;
	font.CreateFont(MulDiv(8, nYPelsPerInchPrinter, 72), 0, 0, 0, 
		FW_NORMAL, FALSE, FALSE, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, 
		CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, 
		"Arial");
	dc.SelectObject(&font);

	dc.StartDoc("Commands");

	////
	
	dcBitmap.CreateCompatibleDC(NULL);
	int nXPelsPerInchScreen = dcBitmap.GetDeviceCaps(LOGPIXELSX);
	int nYPelsPerInchScreen = dcBitmap.GetDeviceCaps(LOGPIXELSY);
	
	BOOL bInPage = FALSE;
	int y;

	for (int i = 0; i < m_cCommands; i += 1)
	{
		if (!bInPage)
		{
			dc.StartPage();
			bInPage = TRUE;

			y = nYPelsPerInchPrinter;
		}

		CTE* pCTE = &m_rgCommands[i];
		
		int x = nXPelsPerInchPrinter;
		
		HBITMAP hbmWell;
		int iGlyph;
		CSize sizeImage=CCustomBar::GetDefaultBitmapSize(theApp.m_bLargeToolBars);

		if(theApp.GetCommandBitmap(pCTE->id, &hbmWell, &iGlyph, theApp.m_bLargeToolBars, pCTE))
		{
			CBitmap* pToolbarBitmap = CBitmap::FromHandle(hbmWell);
			
			CBitmap* pOldBitmap = dcBitmap.SelectObject(pToolbarBitmap);
			
			dc.StretchBlt(x, y, 
				sizeImage.cx * nXPelsPerInchPrinter / nXPelsPerInchScreen, 
				sizeImage.cy * nYPelsPerInchPrinter / nYPelsPerInchScreen, 
				&dcBitmap, iGlyph * sizeImage.cx, 0, sizeImage.cx, sizeImage.cy, SRCCOPY);
			
			dcBitmap.SelectObject(pOldBitmap);
		}
		
		x += sizeImage.cx * nXPelsPerInchPrinter / nXPelsPerInchScreen;
		x += nXPelsPerInchPrinter / 8;
		
		CString str;
		str = pCTE->szCommand;
		dc.TextOut(x, y, str);
		int cyText = dc.GetTextExtent(str, str.GetLength()).cy;
		x += 2 * nXPelsPerInchPrinter;
		
		str = ShellGetNextString(pCTE->szCommand, STRING_TIP);
		int nTipIndex = str.Find('\n');
		if (nTipIndex != -1)
			str = str.Left(nTipIndex);
		dc.TextOut(x, y, str);
	
		y += max(sizeImage.cy * nYPelsPerInchPrinter / nYPelsPerInchScreen, cyText);

		if (y + max(sizeImage.cy * nYPelsPerInchPrinter / nYPelsPerInchScreen, cyText) >= nPageHeight - nYPelsPerInchPrinter)
		{
			dc.EndPage();
			bInPage = FALSE;
		}
	}
	
	if (bInPage)
		dc.EndPage();
	
	dc.EndDoc();
}
#endif

#define AVERAGE_COMMAND_NAME_LENGTH 20

void CCmdCache::FillAllCommandsList(CListBox* pList, BOOL bKeyboard /*=FALSE*/)
{
	// always too much space, but most commands make it into the list, so not too much. And this speeds
	// things up a lot.
	pList->InitStorage(theCmdCache.m_cCommands, AVERAGE_COMMAND_NAME_LENGTH*theCmdCache.m_cCommands);

	// iterate the whole command cache
	for (int i = 0; i < m_cCommands; i++)
	{
		CTE* pCTE = &m_rgCommands[i];

		if(!bKeyboard)
		{
			// if it's not for the keyboard dialog, suppress non-button commands
			if (pCTE->flags & CT_NOBUTTON)
			{
				continue;
			}
		}

		// Suppress general nogo commands
		if ((pCTE->flags & (CT_NOUI|CT_NOKEY)) == 0)
		{
			// don't add menus which currently have no items
			if(pCTE->flags & CT_MENU)
			{
				CBMenuPopup * pMenu=theCmdCache.GetMenu(pCTE->id);
				if(pMenu==NULL)
				{
					continue;
				}
				else
				{
					// don't show menu in list if it has no items. Do show it if no items are visible
					if(pMenu->GetMenuItemCount()==0)
					{
						// The menu is empty, but might be present in one of the toolbars

						// TRUE if we found it somewhere in the UI
						BOOL bFound=FALSE;
						int barIndex=0;
						// cycle thru visible toolbars
						while(barIndex<CASBar::s_aUsage.GetSize()) {
							CASBar *pBar=(CASBar *)(CASBar::s_aUsage[barIndex]);
						
							ASSERT(pBar!=NULL);

							if(pBar->FindButton(pCTE->id))
							{
								bFound=TRUE;
							}

							++barIndex;
						}

						// not in any bar implies don't add to list
						if(!bFound)
						{
							continue;
						}
					}
				}
			}

			LPCTSTR lpszCmdName = pCTE->szCommand;
			int index = pList->AddString(lpszCmdName);
			if(index!=LB_ERR)
			{
				pList->SetItemData(index, (DWORD) pCTE->id);
			}
		}
	}
}

// The deleted commands list contains all commands which are no longer present on the menu or toolbar they started
// out on. We do this by comparing the menus and bars with what would happen to them if we reset them.
void CCmdCache::FillDeletedCommandsList(CListBox* pList)
{
	// Iterate all menus, then all bars
	CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();

	pList->SetRedraw(FALSE);
	pFrame->FillDeletedMenuItemList(pList);

	// now fill up all the toolbars; easier to do this because we can ask about each toolbar in from the owning package

	// find all the toolbars
	CObArray aToolWorkers;
	pFrame->m_pManager->ArrayOfType(dtEdit, &aToolWorkers, TRUE, TRUE);

	CString str;
	int nBars = aToolWorkers.GetSize();
	CDockWorker* pDocker;
	
	for (int iBar = 0; iBar < nBars; iBar++)
	{
		pDocker = (CDockWorker*) aToolWorkers.GetAt(iBar);

		if (pDocker->IsAvailable())
		{
			// no default exists for these
			if (LOWORD(pDocker->m_nIDWnd) < IDTB_SHELL_BASE)
				continue;
			
			// only can find missing for bars which have default.
			if (pDocker->m_nIDPackage != PACKAGE_SUSHI ||
				LOWORD(pDocker->m_nIDWnd) < IDTB_CUSTOM_BASE)
			{
				// get the bar associated with the docker
				CASBar* pBar = (CASBar*) pDocker->m_pWnd;

				// If the bar is null it must still be default, as custombars are always loaded. So we only need to look for
				// deleted buttons in non-null bars
				if (pBar != NULL)
				{
					CPackage* pGrp = theApp.GetPackage(pDocker->m_nIDPackage);

					// Shouldn't ever happen.
					if (pGrp == NULL)
						continue;
					
					HGLOBAL hglob = pGrp->GetToolbarData(LOWORD(pDocker->m_nIDWnd));

					if (hglob != NULL)
					{
						TOOLBARINIT FAR* lptbi = (TOOLBARINIT*) ::GlobalLock(hglob);
						UINT FAR* lpIDArray = (UINT FAR*) (lptbi + 1);

						// lpIDarray are the buttons we should put into the bar, so we now compare the bar with those ids

						// This algorithm is substantially similar to the one for menus. 
						// Now we have to compare the bar with the default comamnd ids. We iterate over the default ids, searching 
						// for each command in the current bar. Since the current bar has probably not changed much, we start looking 
						// for the next command/ just after where we found the previous one. This will tend to mean that the whole 
						// comparison isn't too slow.

						// This is the item we start looking at in the current bar
						int iInitialCurrentItem=0;

						// count of items in both places
						int nCurrentItems=pBar->GetCount();
						int nDefaultItems=lptbi->nIDCount;

						// iterate over default menu
						for(int iDefaultItem=0; iDefaultItem<nDefaultItems; ++iDefaultItem)
						{
							UINT nDefaultId=lpIDArray[iDefaultItem];

							// if it's not a separator or in some other way dud.
							if(nDefaultId!=0)
							{
								// iterate over current menu
								int iCurrentItem=iInitialCurrentItem;

								BOOL bFound=FALSE;


								if(nCurrentItems > 0)
								{
									do
									{
										UINT nCurrentId=pBar->GetItemID(iCurrentItem);

										// if it's the same as the one in the default menu, we just found it.
										if(nCurrentId==nDefaultId)
										{
											bFound=TRUE;
										}

										// move to next item to check; wrap around, since we don't always start at 0.
										++iCurrentItem;
										if(iCurrentItem>=nCurrentItems)
										{
											iCurrentItem=0;
										}

										// if we just found it, then the current index value is the value to start at next time.
										if(bFound)
										{
											iInitialCurrentItem=iCurrentItem;
										}
									}
									while(!bFound && iCurrentItem!=iInitialCurrentItem);
								}
								// add the missing command to the list box
								if(!bFound)
								{
									// get the command table entry for the missing command from the menu, which caches it.
									CTE *pCTEMissing=GetCommandEntry(nDefaultId);
									
									// if the command is currently in one of the loaded packages
									if(pCTEMissing)
									{
										// Add the command to the list box, if it's not already in there
										LPCTSTR lpszCmdName = pCTEMissing->szCommand;
										int nOldIndex=pList->FindStringExact(0, lpszCmdName);
										if(nOldIndex==LB_ERR)
										{
											int index = pList->AddString(lpszCmdName);
											if(index!=LB_ERR)
											{
												pList->SetItemData(index, (DWORD) pCTEMissing->id);
											}
										}
									}
								}
							}
						}

						::GlobalUnlock(hglob);
						::GlobalFree(hglob);
					}
				}
			}
		}
	}
	


	pList->SetRedraw(TRUE);
	pList->InvalidateRect(NULL);
}

// To determine whether the given command is active given the current packet situation
// NOTE: This funciton has many exit points.
BOOL CTE::IsActive(void)
{
	UINT nPacketID = pPack->PacketID();

	// If it's an unpacketed command, it's active
	if (nPacketID != PACKET_NIL)
	{
		// Otherwise, we need to check the command's packet against the active one.
		CPack *pActivePack = theApp.m_pActivePacket;

		// If there's no active packet, all packet commands are hidden
		if (pActivePack == NULL)
		{
			return FALSE;
		}

		if(nPacketID==PACKET_SHARED)
		{
			if(GetActivePack()!=NULL)
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
		else
		{
			// If the packet isn't shared, then it's a case of simple comparison
			if(pActivePack != pPack)
			{
				return FALSE;
			}
		}
	}
	return TRUE;
}

BOOL CTE::FindPackage(CPackage *pFindPackage)
{
	UINT nPacketID = pPack->PacketID();

	if(nPacketID!=PACKET_SHARED)
	{
		UINT nPackageID = pPack->GetPackage()->PackageID();

		return pFindPackage->PackageID()==nPackageID;
	}
	else
	{
		return theCmdCache.FindPackage(id, pFindPackage);
	}
}

// Finds if a pack is in the list
BOOL CCmdCache::FindPackage(UINT id, CPackage *pFindPackage)
{
	// For shared packets we must iterate over the whole packet array
	CTypedPtrArray<CObArray, CPack*> *pPackets=NULL;

	if(m_pSharedCommands)
	{
		// If this fails, the shared command isn't in the table, which probably implies failure during command table load
		VERIFY(m_pSharedCommands->Lookup(id, pPackets));

		// If this fails, we probably added something bad to the shared table.
		ASSERT(pPackets);

		UINT nFindID=pFindPackage->PackageID();

		// Search for the pack among the shared ones.
		for(int i=0;i<pPackets->GetSize(); ++i)
		{
			UINT nPackageID = (*pPackets)[i]->GetPackage()->PackageID();

			if(nPackageID==nFindID)
			{
				return TRUE;
			}
		}
		return FALSE;
	}
	else
	{
		// shouldn't be able to have shared commands but no map
		ASSERT(FALSE);
		return FALSE;
	}
}

BOOL CTE::FindPack(CPack *pFindPack)
{
	UINT nPacketID = pPack->PacketID();

	if(nPacketID!=PACKET_SHARED)
	{
		return pFindPack->PacketID()==nPacketID;
	}
	else
	{
		return theCmdCache.FindPack(id, pFindPack);
	}
}

// Finds if a pack is in the list
BOOL CCmdCache::FindPack(UINT id, CPack *pFindPack)
{
	// For shared packets we must iterate over the whole packet array
	CTypedPtrArray<CObArray, CPack*> *pPackets=NULL;

	if(m_pSharedCommands)
	{
		// If this fails, the shared command isn't in the table, which probably implies failure during command table load
		VERIFY(m_pSharedCommands->Lookup(id, pPackets));

		// If this fails, we probably added something bad to the shared table.
		ASSERT(pPackets);

		// Search for the pack among the shared ones.
		for(int i=0;i<pPackets->GetSize(); ++i)
		{
			if((*pPackets)[i]==pFindPack)
			{
				return TRUE;
			}
		}
		return FALSE;
	}
	else
	{
		// shouldn't be able to have shared commands but no map
		ASSERT(FALSE);
		return FALSE;
	}
}

// Gets the pack, adjusted for which pack is active, and resolving sharing issues
CPack *CTE::GetActivePack(void)
{
	UINT nPacketID = pPack->PacketID();

	if(nPacketID!=PACKET_SHARED)
	{
		return pPack;
	}
	else
	{
		return theCmdCache.GetActivePack(id);
	}
}

CPack *CCmdCache::GetActivePack(UINT id)
{
	if(FindPack(id,theApp.m_pActivePacket))
	{
		return theApp.m_pActivePacket;
	}
	else
	{
		return NULL;
	}
}

// Gets any real pack, resolving sharing issues
CPack *CTE::GetFirstPack(void)
{
	UINT nPacketID = pPack->PacketID();

	if(nPacketID!=PACKET_SHARED)
	{
		return pPack;
	}
	else
	{
		return theCmdCache.GetFirstPack(id);
	}
}

CPack *CCmdCache::GetFirstPack(UINT id)
{
	// For shared packets we must iterate over the whole packet array
	CTypedPtrArray<CObArray, CPack*> *pPackets=NULL;

	if(m_pSharedCommands)
	{
		// If this fails, the shared command isn't in the table, which probably implies failure during command table load
		VERIFY(m_pSharedCommands->Lookup(id, pPackets));

		// If this fails, we probably added something bad to the shared table.
		ASSERT(pPackets);

		// table should never exist with no entries.
		ASSERT(pPackets->GetSize()>0);
		return (*pPackets)[0];
	}
	else
	{
		// shouldn't be able to have shared commands but no map
		ASSERT(FALSE);
		return NULL;
	}
}

void CCmdCache::FlushMenuSizes(void)
{
	// removed cached sizes
	CBMenuItem::FlushSizeCache();
	// and recalculate them
	CBMenuItem::EnsureSizeCache();

	if(m_pMenus)
	{
		// Flush the size caches on all of the menus and items
		POSITION pos=GetFirstMenuPosition();
		CBMenuPopup *pMenu;
		UINT nIDMenu;

		while(pos!=NULL)
		{
			GetNextMenu(pos, nIDMenu, pMenu);

			if(pMenu)
			{
				pMenu->FlushSizeCache();
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cmdtable.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	CMDTABLE.CPP
//

#include "stdafx.h"
#include "bardockx.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void RemoveAccel(CString& strMenu);

/////////////////////////////////////////////////////////////////////////////
//	CToolGroup class

CToolGroup::CToolGroup()
{
	m_nCmds = 0;
	m_nId=0;
	// OPTIMIZE: Initial size and grow values
	m_aCmds.SetSize(250, 50);
}

void CToolGroup::AddGroup(int nGroup)
{
	// first do commands, so everything in one group is together
	for (int i = 0; i < theCmdCache.m_cCommands; i++)
	{
		CTE* pCTE = &theCmdCache.m_rgCommands[i];

		if ((pCTE->flags & CT_NOUI) == 0 && pCTE->group == nGroup)
		{
			if((pCTE->flags & CT_MENU)==0)
			{
				// add for non-menus
				m_aCmds.SetAtGrow(m_nCmds++, pCTE);
			}
		}
	}

	// then do groups contained on submenus
	for (i = 0; i < theCmdCache.m_cCommands; i++)
	{
		CTE* pCTE = &theCmdCache.m_rgCommands[i];

		if ((pCTE->flags & CT_NOUI) == 0 && pCTE->group == nGroup)
		{
			if(pCTE->flags & CT_MENU)
			{
				// menus can't be shared
				ASSERT(pCTE->GetPack()->PacketID()!=PACKET_SHARED);

				// recurse for submenus
				if(	pCTE->GetPack() &&
					pCTE->GetPack()->GetPackage()) 
				{
					POPDESC *ppop=pCTE->GetPack()->GetPackage()->GetMenuDescriptor(pCTE->id);
					if(ppop)
					{
						Fill(ppop);
					}
				}

			}
		}
	}
}

void CToolGroup::Fill(POPDESC* ppop, UINT nId)
{
	// if this is a top level call (and not a recursion), set up the group's id
	if(nId!=0)
	{
		m_nId=nId;
	}

	if (m_strGroup.IsEmpty())
	{
		LPCTSTR pszCmd;
		VERIFY(theCmdCache.GetCommandString(ppop->cmdID, STRING_MENUTEXT, &pszCmd));
		m_strGroup=pszCmd;
		RemoveAccel(m_strGroup);
	}

	MTM* pmtm = &ppop->rgmtm[0];
	UINT idLast = 0;

	while (pmtm->id != POP_NIL)
	{
		// Add commands from this group.
		if (pmtm->id != idLast && pmtm->idString == POP_IDS_NIL)
		{
			AddGroup((int) pmtm->id);
			idLast = pmtm->id;
		}

		pmtm++;
	}
}

LPCTSTR CToolGroup::GetCommandName( UINT nCmdID )
{
	for (int i = 0; i < m_nCmds; i++)
	{
		if ((UINT) ((CTE *)m_aCmds[i])->id == nCmdID)
			return ((CTE *)m_aCmds[i])->szCommand;
	}

	return NULL;
}

// Arbitrary number, but you wouldn't be able to see this many buttons
// in the customize dialog anyway.
#define MAX_BUTTONS 256

CASBar* CToolGroup::CreateCASBar(CWnd* pParent, CDockManager* pManager)
{
	TOOLBARINIT tbi;
	UINT aToolIDs[MAX_BUTTONS];
	CTE* pCTE;

	tbi.nIDWnd = MAKEDOCKID(PACKAGE_SUSHI,0);
	tbi.nIDCount = 0;

	int nOldGroup = ((CTE *) m_aCmds[0])->group;
	for (int i = 0; i < m_nCmds && tbi.nIDCount < MAX_BUTTONS - 1; i++)
	{
		pCTE = (CTE*) m_aCmds[i];
		if (theApp.HasCommandBitmap(pCTE->id))
		{
			if (pCTE->group != nOldGroup &&
				(nOldGroup & 1)==0) // lo bit set means no separator
			{
				nOldGroup = pCTE->group;
				aToolIDs[tbi.nIDCount++] = ID_SEPARATOR;
			}

			aToolIDs[tbi.nIDCount++] = (UINT) pCTE->id;
		}
	}

	// No empty toolbars.
	if (tbi.nIDCount == 0)
		return NULL;

	CASBar *pBar = new CASBar;
	if (pBar->Create(pParent, pManager, WS_VSCROLL , &tbi, aToolIDs, NULL))
	{
		pBar->m_dwStyle &= ~(CBRS_TOOLTIPS | CBRS_FLYBY);
		pBar->EnableToolTips(FALSE);
	}

	return pBar;
}	

void CToolGroup::FillCommandList(CListBox *pList, BOOL bForButtons)
{
	LPCTSTR lpszCmdName;

	for (int i = 0; i < m_nCmds; i++)
	{
		lpszCmdName = ((CTE*) m_aCmds[i])->szCommand;
		if (lpszCmdName && lstrlen(lpszCmdName) &&
			!(((CTE*) m_aCmds[i])->flags & CT_NOKEY))
		{
			if(!bForButtons ||
			   (((CTE*) m_aCmds[i])->flags & CT_NOBUTTON)==0)
			{
				int index = pList->AddString(lpszCmdName);
				pList->SetItemData(index, (DWORD) ((CTE*) m_aCmds[i])->id);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
//	CAppToolGroups class

// We  only want one  of these at a time.
CAppToolGroups* CAppToolGroups::s_pAppToolGroups = NULL;

CAppToolGroups* CAppToolGroups::GetAppToolGroups(BOOL bShowWaitCursor /* = FALSE */)
{
	if (s_pAppToolGroups == NULL)
	{
		if (bShowWaitCursor)
			AfxGetApp()->BeginWaitCursor();

		s_pAppToolGroups = new CAppToolGroups;

		if (bShowWaitCursor)
			AfxGetApp()->EndWaitCursor();
	}

	s_pAppToolGroups->m_nUsage++;

	return s_pAppToolGroups;
}

void CAppToolGroups::ReleaseAppToolGroups()
{
	if (s_pAppToolGroups != NULL && --s_pAppToolGroups->m_nUsage == 0)
	{
		delete s_pAppToolGroups;
		s_pAppToolGroups = NULL;
	}
}

CAppToolGroups::CAppToolGroups()
{
	m_nUsage = 0;
	m_nCmds=0;

	//REVIEW: Support for a dirty command cache
	m_wSyncID = 0;
	m_rgGroups = NULL;
	ScanCommandCache();
}

CAppToolGroups::~CAppToolGroups()
{
	delete [] m_rgGroups;
}

void CAppToolGroups::GetCommandName(UINT nCmdID, CString& strName)
{
	LPCTSTR lpszName;

	if(theCmdCache.GetCommandString(nCmdID, STRING_COMMAND, &lpszName))
	{
		strName = lpszName;
		if(strName.GetLength()>0)
		{
			return;
		}
	}

	VERIFY(strName.LoadString(IDS_UNNAMED));
}

void CAppToolGroups::FillGroupList(CComboBox *pList)
{
	for (int i = 0; i < m_nGroups; i++)
	{
		if (m_rgGroups[i].m_nCmds == 0)
			continue;

		int index = pList->AddString(m_rgGroups[i].m_strGroup);
		pList->SetItemData(index, i);
	}
}

void CAppToolGroups::FillCommandList(UINT nGroup, CListBox *pList )
{
	m_rgGroups[nGroup].FillCommandList(pList);
}

// Fills an array with one toolbar for each category that has more than 0 commands.
// If the category indicates it is textual, then NULL is added to the array
void CAppToolGroups::CreateCustomizeToolbars(	CWnd* pParent,	
												CDockManager* pManager, 
												CObArray* pToolbars,	// The bars, or null for text categories
												CStringArray *pTitles,	// The titles
												CWordArray *paIds)		// the ids of the groups
{
	ASSERT_VALID(pToolbars);
	ASSERT_VALID(pParent);
	ASSERT(pToolbars->GetSize() == 0);
	
	CASBar *pBar;
	for (int i = 0; i < m_nGroups; i++)
	{
		if (m_rgGroups[i].m_nCmds == 0)
			continue;

		if(m_rgGroups[i].m_nId!=0)
		{
			CTE *pCTE=theCmdCache.GetCommandEntry(m_rgGroups[i].m_nId);
			if(	pCTE &&
				pCTE->GetPack())
			{
				CPackage *pPackage=pCTE->GetPack()->GetPackage();
				if(pPackage)
				{
					if(pPackage->IsCategoryTextual(m_rgGroups[i].m_nId))
					{
						pToolbars->Add(NULL);
						pTitles->Add(m_rgGroups[i].m_strGroup);
						paIds->Add((WORD)m_rgGroups[i].m_nId);
						continue;
					}
				}
			}
		}

		if ((pBar = m_rgGroups[i].CreateCASBar(pParent, pManager)) != NULL)
		{
			pToolbars->Add(pBar);
			pTitles->Add(m_rgGroups[i].m_strGroup);
			paIds->Add((WORD)m_rgGroups[i].m_nId);
		}
	}
}


// This is called by the commands and keyboard tabs of the customize dialog
//  when they're displayed by Tools.Macro.  The dialogs need to prime themselves
//  with the command name passed to them from Tools.Macro, and need to
//  find the group containing that command (currently it'll always
//  be the Macros category).
CToolGroup* CAppToolGroups::GroupFromCommandName(LPCTSTR szCmdName)
{
	// Search through all the groups until we can find this command
	UINT nIDCmd;
	if (!theCmdCache.GetCommandID(szCmdName, &nIDCmd))
		return NULL;

	CTE* pCTE = theCmdCache.GetCommandEntry(nIDCmd);
	for (int i=0; i < m_nGroups; i++)
	{
		CToolGroup* pToolGroup = &(m_rgGroups[i]);
		LPCTSTR szCurrCmdName = pToolGroup->GetCommandName(nIDCmd);
		if (szCurrCmdName == NULL)
			continue;

		if (_tcscmp(szCmdName, szCurrCmdName))
		{
			// Found a name for this command, but it didn't
			//  match szCmdName.  That's really weird.
			return NULL;
		}

		return pToolGroup;
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//	Utility functions

void RemoveAccel(CString& strMenu)
{
	int i = strMenu.Find('&');
	if (i == -1)
		return;
	
	if (i == 0)
		strMenu = strMenu.Right(strMenu.GetLength() - i - 1);
	else if (i == strMenu.GetLength() - 1)
		strMenu = strMenu.Left(i);
	else
	{
		// International code handles both "R&eplace..." and "<text>(&E)..."
		LPCTSTR lpchSrc;
		LPTSTR lpchDest = strMenu.GetBuffer(strMenu.GetLength() + 1) + i;
		lpchDest = _tcsdec(strMenu, lpchDest);
		if (*lpchDest == _T('('))
		{
			lpchSrc = lpchDest;
			while (*lpchSrc != _T(')') && *lpchSrc != _T('\0'))
				lpchSrc = _tcsinc(lpchSrc);
			if (*lpchSrc != _T('\0'))
				lpchSrc = _tcsinc(lpchSrc);
		}
		else
		{
			lpchDest = _tcsinc(lpchDest);
			lpchSrc = lpchDest + 1;
		}
		_tcscpy(lpchDest, lpchSrc);
		strMenu.ReleaseBuffer();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\cmduiena.h ===
#ifndef cmduiena_h
#define cmduiena_h

// This class is designed to trap the enable status of a particular command
// It is used by the custom keyboard map and an OLE automation handler
// to check whether custom commands are available,

class CCmdUIEnable : public CCmdUI
{
public:
	CCmdUIEnable()
	{
		m_bEnabled = FALSE;
	}

	void Enable(BOOL bOn)
	{
		m_bEnabled = bOn;
		m_bEnableChanged = TRUE;
	}

	void SetCheck(int nCheck)
	{
	}

	void SetRadio(BOOL bOn)
	{
	}

	void SetText(LPCSTR lpszText)
	{
	}

	BOOL m_bEnabled;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\custbtn.h ===
#ifndef __CUSTBTN_H__
#define __CUSTBTN_H__

// This dialog appears when the user selects 'button appearance' from the toolbar button popup menu 
// that is available when the toolbar customize dialog is up

// The user can either choose how the button will appear, - image, text, or both, and can specify the image and text
// If the text includes an ampersand, that will become the buttons 'hot' key.

// The dialog returns IDOK if the user presses the assign button. In this case:
// If m_buttonText is not empty, then the user selected 'text button' and the new string for
//         the button is contained in m_buttonText
// Otherwise, m_buttonImage contains the id of the (fake) command whose bitmap is to be stolen by
//         the button.

#include "resource.h"


class CDockManager;
class CChoiceBar;

class CCustomButtonDlg : public C3dDialog
{
public:
// Construction
	CCustomButtonDlg(CString buttonName, CString buttonText, APPEARANCE at, CDockManager *m_pManager, APPEARANCEOPTION aoCanText, APPEARANCEOPTION aoCanImage, HBITMAP hbmCurrent=NULL, int nIndexCurrent=-1, CWnd* pParent = NULL);
	virtual ~CCustomButtonDlg();

// Dialog Data
	//{{AFX_DATA(CCustomButtonDlg)
	enum { IDD = IDD_CUSTOMBUTTON };
	CStatic	m_tools;
	CString	m_buttonName;				// The name of the button (e.g. DebugGo)
	CString	m_buttonText;				// The text drawn on the button
	APPEARANCE m_aAppearance;
	//}}AFX_DATA
	// If m_buttonText is empty on return, this contains the bitmap to be used for the custom button
	HBITMAP m_hbmCustomGlyph;
	APPEARANCEOPTION m_aoCanImage;
	APPEARANCEOPTION m_aoCanText;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCustomButtonDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HWND m_hWndNextClip;				// next window in the clipboard chain
	CDockManager *m_pManager;
	CChoiceBar *m_pButtonSource;		// the bar with all the potential custom buttons
	int m_nOldSelection;
	BOOL m_bLarge;

	HBITMAP m_hbmCurrent;				// BITMAP containing the current glyph, or NULL
	int m_nIndexCurrent;				// index of the current glyph, or -1

	// Generated message map functions
	//{{AFX_MSG(CCustomButtonDlg)
	afx_msg void OnImageEdit();
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeButtonText();
	afx_msg void OnDestroy();
	afx_msg void OnChangeCbChain( HWND hWndRemove, HWND hWndAfter );
	afx_msg void OnDrawClipboard( );
	afx_msg void OnImagePaste();
	afx_msg void OnImageReset();
	afx_msg void OnImageOnly();
	afx_msg void OnImageText();
	afx_msg void OnTextOnly();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// update the enable status of the assign button (IDOK)
	// nIndex is the index of the currently selected toolbar button
	void UpdateControls();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\customiz.h ===
#ifndef customiz_h
#define customiz_h

// The tools.customize.commands and tools.customize.keyboard tabs derive
//  from this, so that they can be called from Tools.Macro and be primed
//  with the selected macro.
interface IAut1Misc;		// Defined in ide\pkgs\include\aut1api_.h
class CCommandTab : public CDlgTab
{
protected:
	DECLARE_DYNAMIC(CCommandTab);
	CString m_strInitialCommand;
	static IAut1Misc* m_pAut1Misc;

// Construction
public:
	virtual ~CCommandTab();
	CCommandTab(UINT nIDTemplate, UINT nIDCaption)
		: CDlgTab(nIDTemplate, nIDCaption) { ASSERT(m_pAut1Misc == NULL); }
	CCommandTab(LPCSTR lpszTemplateName, UINT nIDCaption)
		: CDlgTab(lpszTemplateName, nIDCaption) { ASSERT(m_pAut1Misc == NULL); }

// Operations
public:
	// This is called before the tab is created.  Then, when the tab
	//  is created, it will select the command szCmd and select
	//  the containing category.  This category is currently always
	//  Macros, as this is used to implement the shortcut to assigning
	//  macros to keystrokes/commandbars from the Tools.Macro dialog.
	void SelectCommand(LPCTSTR szCmd) { m_strInitialCommand = szCmd; }

protected:
	// Called by derived classes to reload macros when their tab is displayed.
	void ReloadMacros();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\customiz.cpp ===
#include "stdafx.h"

#include "shell.h"
#include "bardlgs.h"
#include "keycust.h"
#include "workspc.h"
#include "toolcust.h"
#include "fcdialog.h"
#include <aut1api_.h>
#include <aut1gui_.h>
#include "customiz.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

class COptDlg : public CTabbedDialog
{
public:
	COptDlg(UINT nIDCaption, OPTDLG_TYPE type, UINT iSelectTab = -1, DLGPOSITION pos=POS_APPCENTER);
	~COptDlg();
	virtual void PostNcDestroy();
	// Make this public so CTheApp can access the command tabs to prime them
	//  with a command to auto-select (when launched from Tools.Macro)
	CDlgTab* GetTab(int nTab) { return CTabbedDialog::GetTab(nTab); }

	BOOL m_bModeless;
};

////////////////////////////////////////////////////////////////////////////

void CVshellPackage::OnCustomize()
{
	theApp.DoCustomizeDialog();
}

void CVshellPackage::OnToolbarCustomize()
{
	COptDlg* pDlg = new COptDlg(IDS_CUSTOMIZE, customize, 0, COptDlg::POS_AVOIDBARS);
	if (pDlg->GetTabCount() > 0)
	{
		AfxGetApp()->m_pMainWnd->EnableWindow(FALSE);
		pDlg->m_bModeless = TRUE;
		
		// ToolsCustomize is an asynchronous command.  The handler returns
		//  to the main message pump BEFORE the dialog is dismissed.  Inform
		//  the shell of this, so that automation calls to 
		//  Application::ExecuteCommand will wait until this dialog is dismissed
		//  before continuing.
		theApp.BeginAsyncCmd();

		pDlg->Create(); // self-deleting dialog
	}
}

void CVshellPackage::OnOptions()
{
	theApp.DoOptionsDialog();
}

void CTheApp::DoOptionsDialog(UINT nIDCaption /* = 0 */)
{
	COptDlg dlg(IDS_OPTIONS, options);

	if (dlg.GetTabCount() <= 0)
		return;

	// Caller may select a specific page by passing the string ID of the
	// page's caption string.  (We don't use m_nOrder because it's not
	// guaranteed to be unique)
	if (nIDCaption != 0)
	{
		CString strCaption;
		strCaption.LoadString(nIDCaption);
		ASSERT(!strCaption.IsEmpty());

		dlg.SelectTab(strCaption, TRUE);
	}

	dlg.DoModal();	// not self-deleting.
}

void CTheApp::DoCustomizeDialog(UINT nIDPageCaption /* = 0*/, 
								LPCTSTR szMacroName /*= NULL*/)
{
	COptDlg* pDlg = new COptDlg(IDS_CUSTOMIZE, customize, -1, COptDlg::POS_AVOIDBARS);
	if (pDlg->GetTabCount() > 0)
	{
		AfxGetApp()->m_pMainWnd->EnableWindow(FALSE);
		pDlg->m_bModeless = TRUE;

		// Caller may select a specific page by passing the string ID of the
		// page's caption string.  (We don't use m_nOrder because it's not
		// guaranteed to be unique)
		if (nIDPageCaption != 0)
		{
			CString strCaption;
			strCaption.LoadString(nIDPageCaption);
			ASSERT(!strCaption.IsEmpty());

			// If we're passed a command and the tab is primeable, then
			//  prime it with that command.  (This is done from Tools.Macro
			//  when the user wants to tie a selected macro to a
			//  toolbar or keystroke.)
			pDlg->SelectTab(strCaption, TRUE);
			int nTab = pDlg->GetCurrentTab();
			CDlgTab* pTab = pDlg->GetTab(nTab);
			if (szMacroName != NULL &&
				pTab->IsKindOf(RUNTIME_CLASS(CCommandTab)))
			{
				((CCommandTab*) pTab)->SelectCommand(szMacroName);
			}
		}

		// ToolsCustomize is an asynchronous command.  The handler returns
		//  to the main message pump BEFORE the dialog is dismissed.  Inform
		//  the shell of this, so that automation calls to 
		//  Application::ExecuteCommand will wait until this dialog is dismissed
		//  before continuing.
		theApp.BeginAsyncCmd();

		pDlg->Create(); // self-deleting dialog
	}
}

////////////////////////////////////////////////////////////////////////////

COptDlg::COptDlg(UINT nIDCaption, OPTDLG_TYPE type, UINT iSelectTab /*=-1*/, DLGPOSITION dlgpos)
	: CTabbedDialog(nIDCaption, NULL, iSelectTab,
	                type == options ? commitOnOk : commitOnTheFly, dlgpos)
{
	POSITION pos = theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
		pPackage->AddOptDlgPages(this, type);
	}
	
	m_bModeless = FALSE;
}

COptDlg::~COptDlg()
{
}

void COptDlg::PostNcDestroy()
{
	if (m_bModeless)
	{
		AfxGetApp()->m_pMainWnd->EnableWindow(TRUE);
		AfxGetApp()->m_pMainWnd->SetFocus();
		delete this;

		// Now that the dialog is dismissed, tell the shell that this
		//  asynchronous command is comleted, so that if this was called
		//  via Application::ExecuteCommand, then ExecuteCommand can now
		//  return to its caller (e.g., a VBS macro).
		theApp.EndAsyncCmd();
	}
}

////////////////////////////////////////////////////////////////////////////
// CCommandTab mini-class

IMPLEMENT_DYNAMIC(CCommandTab, CDlgTab)

// Shared between the Commands and the Keyboard tabs of Tools.Customize.
//  Caches pointer to devaut1's IAut1Misc.  Created when the first tab
//  needs it, and released when the first tab is destroyed.
IAut1Misc* CCommandTab::m_pAut1Misc = NULL;

CCommandTab::~CCommandTab()
{
	if (m_pAut1Misc != NULL)
	{
		m_pAut1Misc->Release();
		m_pAut1Misc = NULL;
	}
}

void CCommandTab::ReloadMacros()
{
	if (m_pAut1Misc == NULL)
	{
		if (FAILED(theApp.FindInterface(IID_IAut1Misc, (LPVOID*) &m_pAut1Misc))
			|| m_pAut1Misc == NULL)
		{
			m_pAut1Misc = NULL;
			return;
		}
	}

	if(m_pAut1Misc)
	{
		m_pAut1Misc->ReloadMacros();
	}
}

////////////////////////////////////////////////////////////////////////////

void CVshellPackage::AddOptDlgPages(class CTabbedDialog* pOptDlg, OPTDLG_TYPE type)
{
	CMainFrame* pFrame = (CMainFrame*)theApp.m_pMainWnd;

	switch (type)
	{
	case customize:
		{
			if (theApp.IsUIElementEnabled(UieToolbarCustomize))
			{
				pOptDlg->AddTab(new CCustomDialog(pFrame->m_pManager, pFrame));
			}
			// for the moment, this one is always enabled, because the toolbars dialog was always enabled
			{
				CMainFrame* pFrame = (CMainFrame*) AfxGetMainWnd();

				// Self deleting dialog.
				pOptDlg->AddTab(new CToolbarDialog(pFrame->m_pManager, pFrame));
			}
			if (theApp.IsUIElementEnabled(UieToolsCustomize))
				pOptDlg->AddTab(new CCustomizeToolsDialog());
			if (theApp.IsUIElementEnabled(UieKeyCustomize))
				pOptDlg->AddTab(new CKeyCustDlg(NULL, NUM_ACC_RES_TABLES));
			break;
		}
		
	case options:
		{
			if (theApp.IsUIElementEnabled(UieWorkspaceOptions))
				pOptDlg->AddTab(new CWorkspaceDlg(pFrame->m_pManager, pFrame));
			if (theApp.IsUIElementEnabled(UieFormatOptions))
				pOptDlg->AddTab(new CFontColorDlg(pFrame));
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\custbtn.cpp ===
// custbtn.cpp : implementation file
//

#include "stdafx.h"
#include "vshell.h"
#include "custbtn.h"
#include "dockman.h"
#include "ids.h"
#include "barchoic.h"
#include "barglob.h"
#include "bardockx.h"
#include "prxycust.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCustomButtonDlg dialog

// This dialog is used to select a button image or a button name to be applied to a toolbar
// button.
CCustomButtonDlg::CCustomButtonDlg(CString buttonName, CString buttonText, APPEARANCE aAppearance, CDockManager *pManager, APPEARANCEOPTION aoCanText , APPEARANCEOPTION aoCanImage, HBITMAP hbmCurrent, int nIndexCurrent, CWnd* pParent /*=NULL*/) :
	C3dDialog(CCustomButtonDlg::IDD, pParent),
	m_aoCanImage(aoCanImage),
	m_aoCanText(aoCanText),
	m_hbmCustomGlyph(NULL),
	m_pButtonSource(NULL),
	m_pManager(pManager),
	m_nOldSelection(0),
	m_hbmCurrent(hbmCurrent),
	m_nIndexCurrent(nIndexCurrent)
{
	//{{AFX_DATA_INIT(CCustomButtonDlg)
	m_buttonName = buttonName;
	m_buttonText = buttonText;
	m_aAppearance = aAppearance;
	//}}AFX_DATA_INIT

	// It's possible for some of the above to start out in conflict - for example, the command could
	// be a menu (image only not allowed) being dragged onto a toolbar (image only the default)

	// something must be not forbidden, otherwise we shouldn't be in this dialog
	ASSERT(m_aoCanText!=cAppearanceForbidden || m_aoCanImage!=cAppearanceForbidden); 

	// fix up initial appearance to be consistent with options
	if(!GLOBAL_DATA::CanChooseImageText(m_aoCanText, m_aoCanImage))
	{
		if(m_aAppearance==cAppearanceImageText)
		{
			m_aAppearance=cAppearanceTextOnly;
		}
	}

	if(!GLOBAL_DATA::CanChooseTextOnly(m_aoCanText, m_aoCanImage))
	{
		if(m_aAppearance==cAppearanceTextOnly)
		{
			m_aAppearance=cAppearanceImageOnly;
		}
	}

	if(!GLOBAL_DATA::CanChooseImageOnly(m_aoCanText, m_aoCanImage))
	{
		if(m_aAppearance==cAppearanceImageOnly)
		{
			m_aAppearance=cAppearanceTextOnly;
		}
	}
}

CCustomButtonDlg::~CCustomButtonDlg()
{
}

// We use DDV_MaxChars here to limit the size of a toolbar button string. I can't see any
// sensible way to choose a limit, but it's clear that things could get unpleasant if the button
// were a lot larger than the screen, or if so many characters were entered that the registry
// data got unpleasantly long. So I choose 80, arbitrarily. This is less than 1 screen width,
// and less than the size of the data for 1 custom bitmap. Word chooses 256, which seems even 
// more unpleasant, and allows wierd buttons for small screens. martynl 4Apr96
void CCustomButtonDlg::DoDataExchange(CDataExchange* pDX)
{
	ASSERT(sizeof(int)==sizeof(APPEARANCE));
	int appearance=(int)m_aAppearance;

	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCustomButtonDlg)
	DDX_Control(pDX, IDC_TOOLS, m_tools);
	DDX_Text(pDX, IDC_BUTTON_NAME, m_buttonName);
	DDX_Text(pDX, IDC_BUTTON_TEXT, m_buttonText);
	DDV_MaxChars(pDX, m_buttonText, 80);
	DDX_Radio(pDX, IDC_IMAGEONLY, appearance);
	//}}AFX_DATA_MAP

	m_aAppearance=(APPEARANCE)appearance;
}

BEGIN_MESSAGE_MAP(CCustomButtonDlg, C3dDialog)
	//{{AFX_MSG_MAP(CCustomButtonDlg)
	ON_EN_CHANGE(IDC_BUTTON_TEXT, OnChangeButtonText)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_IMAGE_PASTE, OnImagePaste)
	ON_BN_CLICKED(IDC_IMAGE_RESET, OnImageReset)
	ON_BN_CLICKED(IDC_IMAGEONLY, OnImageOnly)
	ON_BN_CLICKED(IDC_IMAGETEXT, OnImageText)
	ON_BN_CLICKED(IDC_TEXTONLY, OnTextOnly)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCustomButtonDlg message handlers
void CCustomButtonDlg::OnOK() 
{
	UpdateData(TRUE);

	// which button is selected?
	CToolCustomizer *pCustomizer=m_pButtonSource->GetCustomizer();

	CSize size=CCustomBar::GetDefaultBitmapSize(theApp.m_bLargeToolBars);

	if(m_aAppearance != cAppearanceTextOnly)
	{
		// duplicate the custom bitmap
		m_hbmCustomGlyph=GLOBAL_DATA::DuplicateBitmap(m_pButtonSource,
								m_pButtonSource->GetImageWell(), 
								size, CPoint(size.cx * (pCustomizer->m_nSelectIndex), 0));
	}
	else
	{
		m_hbmCustomGlyph=NULL;
	}

	C3dDialog::OnOK();
	delete pCustomizer;
	delete m_pButtonSource;
	m_pButtonSource=NULL;
}

void CCustomButtonDlg::OnCancel() 
{
	CToolCustomizer *pCustomizer=m_pButtonSource->GetCustomizer();
	pCustomizer->SetSelection(NULL,0);

	delete pCustomizer;
	delete m_pButtonSource;
	m_pButtonSource=NULL;

	C3dDialog::OnCancel();
}

#pragma optimize("", off)
BOOL CCustomButtonDlg::OnInitDialog() 
{
	C3dDialog::OnInitDialog();

	// get size of small button glyphs
	CSize customSize=CCustomBar::GetDefaultBitmapSize(theApp.m_bLargeToolBars);

	// These assertions would fail if the bitmap wasn't present in the resource file
	HINSTANCE hInstance = AfxFindResourceHandle(MAKEINTRESOURCE(theApp.m_bLargeToolBars ? IDB_CUSTOMGLYPHSLARGE : IDB_CUSTOMGLYPHS), RT_BITMAP);
	ASSERT( hInstance != NULL );
	HRSRC hRsrc = ::FindResource(hInstance,	MAKEINTRESOURCE(theApp.m_bLargeToolBars ? IDB_CUSTOMGLYPHSLARGE : IDB_CUSTOMGLYPHS), RT_BITMAP);
	HBITMAP hbmCustomWell=AfxLoadSysColorBitmap(hInstance, hRsrc);

	ASSERT(hbmCustomWell!=NULL);

	BITMAP bmpCustom;

	// This should only fail if GDI is in confusion
	VERIFY(GetObject(hbmCustomWell, sizeof(BITMAP), &bmpCustom));

	// Check height of bitmap
	ASSERT(bmpCustom.bmHeight==customSize.cy);

	// Check no slack at end of bitmap
	ASSERT((bmpCustom.bmWidth % customSize.cx)==0);

	// Count glyphs
	int nGlyphs=bmpCustom.bmWidth / customSize.cx;

	CRect rectTools;
	m_tools.GetWindowRect(rectTools);
	ScreenToClient(rectTools);
	
	m_pButtonSource = new CChoiceBar;
	if (!m_pButtonSource->Create(WS_VSCROLL , rectTools, this, 0))
	{
		MessageBeep(0);
		OnCancel();
		return FALSE;
	}

	int iButton=0;

	// Insert the buttons
	{
		TRANSFER_TBBUTTON trans(ID_APP_ABOUT);
		for (int i = 0; i < nGlyphs ; i++)
		{
			m_pButtonSource->InsertButton(iButton++,trans, FALSE, gapNil);
		}
	}

	// inhibit dragging
	m_pButtonSource->m_dwStyle = (m_pButtonSource->m_dwStyle | CTBRS_NODRAG) & ~(CBRS_TOOLTIPS | CBRS_FLYBY);
	m_pButtonSource->EnableToolTips(FALSE);

	// setup correct glyphs
	m_pButtonSource->SetBitmap(hbmCustomWell);

	// Now insert the current glyph at the start, if it's extant
	if(m_hbmCurrent!=NULL && m_nIndexCurrent!=-1)
	{
		TRANSFER_TBBUTTON trans(ID_APP_ABOUT, m_hbmCurrent, m_nIndexCurrent, theApp.m_bLargeToolBars);
		m_pButtonSource->InsertButton(0, trans, FALSE, gapNil);
	}

	// layout bar
	m_pButtonSource->SetParent(this);
	m_pButtonSource->RecalcLayout();
	m_pButtonSource->SetWindowPos(	&wndTop, rectTools.left, rectTools.top, rectTools.Width(), 
									rectTools.Height(), SWP_NOACTIVATE);

	// give it a customizer
	m_pButtonSource->SetCustomizer(new CToolCustomizer(((CMainFrame*) AfxGetMainWnd())->m_pManager,	NULL, m_pButtonSource->m_aUsage, FALSE));

	// if relevant, set up scroll bar info
	SCROLLINFO si;

	si.cbSize=sizeof(SCROLLINFO);
	si.fMask=SIF_POS | SIF_RANGE;
	si.nMin=si.nMax=0;
	si.nPos=0;
	si.nTrackPos=0;

	CSize statSize=rectTools.Size();
	statSize.cx-=::GetSystemMetrics(SM_CXVSCROLL);
	CSize barFit=m_pButtonSource->GetSize(HTRIGHT, statSize);

	if(rectTools.Size().cy < barFit.cy) {
		// scroll bar will be required
		si.nMax=barFit.cy-rectTools.Size().cy;
	}
	m_pButtonSource->SetScrollInfo(SB_VERT,&si);

	// show the toolbar
	m_pButtonSource->ShowWindow(SW_SHOWNOACTIVATE);
	
	// set up reset button correctly
	BOOL bEnable=FALSE;

	// get the customizer for the source button
	CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;
	if(	pCustomizer->m_pSelectBar!=NULL)
	{
		bEnable=pCustomizer->m_pSelectBar->CanResetImage();
	}

	CButton *pReset=(CButton *)GetDlgItem(IDC_IMAGE_RESET);
	ASSERT(pReset!=NULL);
	pReset->EnableWindow(bEnable);
	
	// select the first button to start with
	m_pButtonSource->GetCustomizer()->SetSelection(m_pButtonSource->GetProxy(),0);

	// add ourselves to the clipboard chain
	m_hWndNextClip=SetClipboardViewer();
	
	// something must be not forbidden, otherwise we shouldn't be in this dialog
	ASSERT(m_aoCanText!=cAppearanceForbidden || m_aoCanImage!=cAppearanceForbidden); 

	// disable relevant choice buttons, depending on appearance options
	if(!GLOBAL_DATA::CanChooseImageText(m_aoCanText, m_aoCanImage))
	{
		CButton *pImageText=(CButton *)GetDlgItem(IDC_IMAGETEXT);
		ASSERT(pImageText!=NULL);
		pImageText->EnableWindow(FALSE);
	}

	if(!GLOBAL_DATA::CanChooseTextOnly(m_aoCanText, m_aoCanImage))
	{
		CButton *pTextOnly=(CButton *)GetDlgItem(IDC_TEXTONLY);
		ASSERT(pTextOnly!=NULL);
		pTextOnly->EnableWindow(FALSE);
	}

	if(!GLOBAL_DATA::CanChooseImageOnly(m_aoCanText, m_aoCanImage))
	{
		// must be not image - can't be both
		CButton *pImageOnly=(CButton *)GetDlgItem(IDC_IMAGEONLY);
		ASSERT(pImageOnly!=NULL);
		pImageOnly->EnableWindow(FALSE);
	}

	// ensure that the assign button is correctly enabled
	UpdateControls();

	// ensure that the paste button is updated correctly
	OnDrawClipboard();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
#pragma optimize("", on)

void CCustomButtonDlg::UpdateControls()
{
	UpdateData();

	BOOL bBarEnabled=TRUE;
	BOOL bTextEnabled=TRUE;
	BOOL bBarWasEnabled=FALSE;

	if(	m_aoCanImage==cAppearanceForbidden ||
		(m_aoCanImage==cAppearanceOptional && m_aAppearance==cAppearanceTextOnly))
	{
		bBarEnabled=FALSE;
	}

	if(	m_aoCanText==cAppearanceForbidden ||
		(m_aoCanText==cAppearanceOptional && m_aAppearance==cAppearanceImageOnly))
	{
		bTextEnabled=FALSE;
	}

	bBarWasEnabled=m_pButtonSource->IsWindowEnabled();

	if(bBarWasEnabled!=bBarEnabled)
	{
		// enable bar and group as appropriate
		m_pButtonSource->EnableWindow(bBarEnabled);

		if(!bBarEnabled)
		{
			m_nOldSelection=m_pButtonSource->GetCustomizer()->m_nSelectIndex;
			m_pButtonSource->GetCustomizer()->SetSelection(NULL,0);

			// Iterate over bar, making all of the buttons TBBS_DISABLED
			int nButtons=m_pButtonSource->GetCount();
			for(int iButton=0;iButton<nButtons;++iButton)
			{
				m_pButtonSource->SetButtonStyle(iButton, m_pButtonSource->GetButtonStyle(iButton)|TBBS_DISABLED);
			}
			m_pButtonSource->Invalidate();
		}
		else
		{
			m_pButtonSource->GetCustomizer()->SetSelection(m_pButtonSource->GetProxy(),m_nOldSelection);

			// Iterate over bar, making all of the buttons enabled
			int nButtons=m_pButtonSource->GetCount();
			for(int iButton=0;iButton<nButtons;++iButton)
			{
				m_pButtonSource->SetButtonStyle(iButton, m_pButtonSource->GetButtonStyle(iButton)&(~TBBS_DISABLED));
			}
			m_pButtonSource->Invalidate();
		}
	}

	CWnd *pButtonGroup=GetDlgItem(IDC_IMAGES_GROUP);
	ASSERT(pButtonGroup!=NULL);
	pButtonGroup->EnableWindow(bBarEnabled);

	// sort out text input
	CWnd *pTextPrompt=GetDlgItem(IDC_BUTTON_TEXT_PROMPT);
	ASSERT(pTextPrompt!=NULL);
	pTextPrompt->EnableWindow(bTextEnabled);

	CWnd *pText=GetDlgItem(IDC_BUTTON_TEXT);
	ASSERT(pText!=NULL);
	pText->EnableWindow(bTextEnabled);

	// get the controls we need
	CButton *pAssign=(CButton *)GetDlgItem(IDOK);
	ASSERT(pAssign!=NULL);

	if(pText!=NULL && pAssign!=NULL) 
	{
		// enable if it's not empty, or we don't care about text
		BOOL bAssignEnabled=!m_buttonText.IsEmpty() ||
							!bTextEnabled;

		pAssign->EnableWindow(bAssignEnabled);

		// ensure that the default button isn't disabled
		DWORD def=GetDefID();
		if(HIWORD(def)==DC_HASDEFID)
		{
			if(!bAssignEnabled)
			{
				if(LOWORD(def)==IDOK)
				{
					SetDefID(IDCANCEL);
				}
			}
			else
			{
				if(LOWORD(def)==IDCANCEL)
				{
					SetDefID(IDOK);
				}
			}
		}

	}
}

void CCustomButtonDlg::OnChangeButtonText() 
{
	UpdateControls();
}

void CCustomButtonDlg::OnDestroy() 
{
	C3dDialog::OnDestroy();

	// remove ourselves from the clipboard chain
	ChangeClipboardChain(m_hWndNextClip);
}

void CCustomButtonDlg::OnChangeCbChain( HWND hWndRemove, HWND hWndAfter )
{
	if(hWndRemove==m_hWndNextClip)
	{
		m_hWndNextClip=hWndAfter;
	}
	else
	{
		if(m_hWndNextClip!=NULL)
		{
			::SendMessage(m_hWndNextClip,WM_CHANGECBCHAIN, (WPARAM)hWndRemove, (LPARAM)hWndAfter);
		}
	}
}

void CCustomButtonDlg::OnDrawClipboard( )
{
	BOOL bEnable=FALSE;
	int nOurSelection; // index of selection inside this dialog

	CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;

	// update the paste button as appropriate
	if(	pCustomizer->m_pSelectBar!=NULL)
	{
		bEnable=pCustomizer->m_pSelectBar->CanPasteImage();
	}

	CButton *pPaste=(CButton *)GetDlgItem(IDC_IMAGE_PASTE);
	ASSERT(pPaste!=NULL);
	pPaste->EnableWindow(bEnable);
}

void CCustomButtonDlg::OnImagePaste() 
{
	OnCancel();

	CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;
	if(pCustomizer->m_pSelectBar!=NULL)
	{
		ASSERT(pCustomizer->m_pSelectBar->CanPasteImage());
		pCustomizer->m_pSelectBar->PasteButtonImage();
	}
}

void CCustomButtonDlg::OnImageReset() 
{
	OnCancel();

	CToolCustomizer *pCustomizer=CASBar::s_pCustomizer;
	if(pCustomizer->m_pSelectBar!=NULL)
	{
		pCustomizer->m_pSelectBar->ResetButtonImage();
	}
}

void CCustomButtonDlg::OnImageOnly() 
{
	UpdateControls();
}

void CCustomButtonDlg::OnImageText() 
{
	UpdateControls();
}

void CCustomButtonDlg::OnTextOnly() 
{
	UpdateControls();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\custprxy.cpp ===
#include "stdafx.h"

#include "custprxy.h"

#include "barglob.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// CCustomBarProxy
// This class implements the bar proxy on top of a CCustomBar.
void CCustomBarProxy::AttachBar(CCustomBar* pBar)
	{ m_pBar = pBar; }
CWnd* CCustomBarProxy::GetWindow()
	{ return m_pBar; }
void CCustomBarProxy::OnSelChange(int nIndex)
	{ m_pBar->OnSelChange(nIndex); }
BOOL CCustomBarProxy::IsInDialog()
	{ return m_pBar->IsInDialog(); }
BOOL CCustomBarProxy::IsStaticItem(int nIndex)
	{ return m_pBar->IsStaticItem(nIndex); }
BOOL CCustomBarProxy::IsGapItem(int nIndex)
	{ return m_pBar->IsGap(nIndex); }
void CCustomBarProxy::OnDeleteSelection()
	{ m_pBar->OnDeleteSelection(); }
void CCustomBarProxy::DeleteButton(int nIndex, BOOL bMoving /*= FALSE*/)
	{ m_pBar->DeleteButton(nIndex, bMoving); }
int CCustomBarProxy::InsertButton(int nIndex, TRANSFER_TBBUTTON& trans, BOOL bReplace, GAP gap)
	{ return m_pBar->InsertButton(nIndex, trans, bReplace, gap); }
void CCustomBarProxy::RecalcLayout(UINT nHTSize /*= HTRIGHT*/)
	{ m_pBar->RecalcLayout(nHTSize); }
void CCustomBarProxy::GetItemRect(int nIndex, LPRECT lpRect) const
	{ m_pBar->GetItemRect(nIndex, lpRect, GetOrient()); }
UINT CCustomBarProxy::GetButtonStyle(int nIndex) const
	{ return m_pBar->GetButtonStyle(nIndex); }
void CCustomBarProxy::GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const
	{ m_pBar->GetButtonInfo(nIndex, nID, nStyle, iImage); }
UINT CCustomBarProxy::GetExpansionConstraint(const CRect &expand, ORIENTATION *orBar /*= NULL*/)
	{ return m_pBar->GetExpansionConstraint(expand, orBar); }
const CSize CCustomBarProxy::GetButtonSize() const
	{ return m_pBar->m_sizeButton; }
const CSize CCustomBarProxy::GetImageSize() const
	{ return m_pBar->m_sizeImage; }
int CCustomBarProxy::GetCount() const
	{ return m_pBar->m_nCount; }
DWORD CCustomBarProxy::GetBarStyle() const
	{ return m_pBar->GetBarStyle(); }
int CCustomBarProxy::IndexFromPoint(const CPoint& pt, CRect *pButtonRect) const
	{ return m_pBar->IndexFromPoint(pt, pButtonRect); }

int CCustomBarProxy::HitTest(CPoint point) const
{
	return m_pBar->HitTest(point);
}

CToolBarProxy* CCustomBarProxy::NewBar(UINT nID, const CPoint& pt)
{ 
	CCustomBar *pBar=m_pBar->NewBar(nID, pt);

	if(pBar) 
	{
		return pBar->GetProxy();
	}
	else
	{
		return NULL;
	}
}

void CCustomBarProxy::OnBarActivate()
	{ m_pBar->OnBarActivate(); }
void CCustomBarProxy::OnButtonSize()
	{ m_pBar->OnButtonSize(); }
void CCustomBarProxy::OnButtonMove(int nIndex)
	{ if (GetButtonStyle(nIndex) & TBBS_MENU) m_pBar->ExpandItem(nIndex, FALSE); }
void CCustomBarProxy::GetButtonTransferInfo(int nIndex, DWORD& dwData, TRANSDATA_CALLBACK* lplpDataCallback) const
	{ m_pBar->GetButtonTransferInfo(nIndex, dwData, lplpDataCallback); }
HBITMAP CCustomBarProxy::GetImageWell(int nIndex)
	{ return m_pBar->m_hbmImageWell; }
int CCustomBarProxy::GetImageIndex(int nIndex) const
	{ return m_pBar->_GetButtonPtr(nIndex)->iImage; }
BOOL CCustomBarProxy::CanChooseAppearance()
	{ return m_pBar->CanChooseAppearance(); }
BOOL CCustomBarProxy::CanResetImage()
	{ return m_pBar->CanResetImage(); }
BOOL CCustomBarProxy::CanPasteImage()
	{ return m_pBar->CanPasteImage(); }
void CCustomBarProxy::PasteButtonImage()
	{ m_pBar->PasteButtonImage(); }
void CCustomBarProxy::ResetButtonImage()
	{ m_pBar->ResetButtonImage(); }
void* CCustomBarProxy::_GetRealObject()
	{ return m_pBar; }
const CString& CCustomBarProxy::GetButtonText(int nIndex) const
	{ if (!HasExInfo(nIndex)) return afxEmptyString; return m_pBar->GetButtonExtra(nIndex)->GetLabel(); }
HWND CCustomBarProxy::GetButtonControl(int nIndex) const
	{ if (!HasExInfo(nIndex)) return NULL; return m_pBar->GetButtonExtra(nIndex)->GetControl(); }
HBITMAP CCustomBarProxy::GetButtonImage(int nIndex) const
	{ if (!HasExInfo(nIndex)) return NULL; return m_pBar->GetButtonExtra(nIndex)->GetGlyph(); }
void CCustomBarProxy::SetButtonControl(int nIndex, HWND hControl)
	{ m_pBar->EditButtonExtra(nIndex)->SetControl(hControl); }
void CCustomBarProxy::GetButtonInfoEx(int nIndex, HWND& hControl, CString& rText, HBITMAP& hImage) const
	{ ASSERT(HasExInfo(nIndex)); hControl = GetButtonControl(nIndex); rText = GetButtonText(nIndex); hImage = GetButtonImage(nIndex); }
BOOL CCustomBarProxy::HasExInfo(int nIndex) const
	{ return m_pBar->HasButtonExtra(); }
ORIENTATION CCustomBarProxy::GetOrient() const
	{ return m_pBar->GetOrient(); }
// adds text to the button
void CCustomBarProxy::AddText(int nIndex) // default menu text
{
	m_pBar->AddText(nIndex);
}

void CCustomBarProxy::AddText(int nIndex, const CString &text, BOOL bCustom)
{
	m_pBar->AddText(nIndex, text, bCustom);
}

void CCustomBarProxy::AddBitmap(int nIndex, BITMAPSOURCE bsSource, HBITMAP hbmCustom)
{
	m_pBar->AddBitmap(nIndex, bsSource, hbmCustom);
}

// remove the label from a glyph+label button
void CCustomBarProxy::RemoveText(int nIndex)
{
	m_pBar->RemoveText(nIndex);
}

// remove the glyph from a glyph+label button
void CCustomBarProxy::RemoveBitmap(int nIndex)
{
	m_pBar->RemoveBitmap(nIndex);
}

// call this when the button has been modified to mark the bar dirty and possibly redraw (if bSized==TRUE)
void CCustomBarProxy::ButtonModified(int nIndex, BOOL bSized)
{
	m_pBar->ButtonModified(nIndex, bSized);
}

// Removes a separator before a button
void CCustomBarProxy::RemoveSeparator(int iButton)
{
	m_pBar->RemoveSeparator(iButton);
}

// Inserts a separator before a button
void CCustomBarProxy::InsertSeparator(int iButton)
{
	m_pBar->InsertSeparator(iButton);
}

// returns true if the item is a control, and is currently visible
BOOL CCustomBarProxy::IsVisibleControl(int iButton)
{
	return m_pBar->IsVisibleControl(iButton);
}

// returns if the specified button can be shown with text
APPEARANCEOPTION CCustomBarProxy::CanText(int iButton)
{
	UINT nStyle=GetButtonStyle(iButton);

	if(	(nStyle & (TBBS_SEPARATOR)!=0) ||
		IsVisibleControl(iButton))
	{
		return cAppearanceForbidden;
	}
	else
	{
		if(nStyle & TBBS_MENU)
		{
			return cAppearanceCompulsory;
		}
		else
		{
			return cAppearanceOptional;
		}
	}
}

// returns if the specified button can be shown with a glyph
APPEARANCEOPTION CCustomBarProxy::CanGlyph(int iButton)
{
	return CanGlyph(GetButtonStyle(iButton));
}

// returns any limitations on the appearance of a given button style 
APPEARANCEOPTION CCustomBarProxy::CanText(UINT nStyle)
{
	if(	(nStyle & (TBBS_SEPARATOR|TBBS_HWND)!=0))
	{
		return cAppearanceForbidden;
	}
	else
	{
		if(nStyle & TBBS_MENU)
		{
			return cAppearanceCompulsory;
		}
		else
		{
			return cAppearanceOptional;
		}
	}
}

// returns any limitations on the appearance of a given button style
APPEARANCEOPTION CCustomBarProxy::CanGlyph(UINT nStyle)
{
	if(	(nStyle & (TBBS_SEPARATOR|TBBS_MENU|TBBS_HWND)!=0))
	{
		return cAppearanceForbidden;
	}
	else
	{
		return cAppearanceOptional;
	}
}

// returns the appearance of a button
APPEARANCE CCustomBarProxy::GetAppearance(int iButton)
{
	UINT nStyle=GetButtonStyle(iButton);
	if(nStyle & TBBS_GLYPH)
	{
		if(nStyle & TBBS_TEXTUAL)
		{
			return cAppearanceImageText;
		}
		else
		{
			return cAppearanceImageOnly;
		}
	}
	else
	{
		return cAppearanceTextOnly;
	}
}

// returns the default appearance of a button
APPEARANCE CCustomBarProxy::GetAppearance()
{
	return cAppearanceImageOnly;
}

// returns the appearance of a button of a given type when placed in this kind of container. If these display components
// are not available, the custom button dialog will appear
APPEARANCE CCustomBarProxy::GetInitialAppearance(UINT nStyle)
{
	if(nStyle & TBBS_MENU)
	{
		return cAppearanceTextOnly;
	}
	else
	{
		return cAppearanceImageOnly;
	}
}

int CCustomBarProxy::GetButtonCmdID(int nIndex) 
{
	return m_pBar->_GetButtonPtr(nIndex)->nID;
}

void CCustomBarProxy::Empty(void) 
{
	m_pBar->Empty();
}

void CCustomBarProxy::BatchBegin(int nCount)
{
	m_pBar->m_nCount=nCount;
	if (nCount > 0)
		m_pBar->m_pData = calloc(nCount, sizeof(AFX_TBBUTTON));
}

void CCustomBarProxy::BatchAdd(int iButton, int nID, UINT nStyle, int nExtra, HBITMAP hbmGlyph, const CString &text)
{
	AFX_TBBUTTON *pTBB=m_pBar->_GetButtonPtr(iButton);

	pTBB->nID = nID;
	pTBB->nStyle = nStyle;
	pTBB->iImage = nExtra;
	if(pTBB->nStyle & TBBS_CUSTOMTEXT)
	{
		ASSERT(!text.IsEmpty());
		m_pBar->EditButtonExtra(iButton)->SetLabel(text);
	}
	if(pTBB->nStyle & TBBS_CUSTOMBITMAP)
	{
		ASSERT(hbmGlyph!=NULL);
		m_pBar->EditButtonExtra(iButton)->SetGlyph(hbmGlyph);
	}

}

void CCustomBarProxy::BatchEnd()
{
	// do nothing
}

// allocates or returns an individual glyph bitmap for a given button
HBITMAP CCustomBarProxy::CreateSingleBitmap(int iButton)
{
	AFX_TBBUTTON *pTBB=m_pBar->_GetButtonPtr(iButton);

	ASSERT(pTBB->nStyle & TBBS_CUSTOMBITMAP);

	if(!m_pBar->HasButtonExtra() ||
		m_pBar->GetButtonExtra(iButton)->GetGlyph()==NULL)
	{
		// create it, because the master copy is in the well
		return GLOBAL_DATA::DuplicateBitmap(m_pBar, m_pBar->m_hbmImageWell, m_pBar->m_sizeImage, CPoint(pTBB->iImage *m_pBar->m_sizeImage.cx, 0));
	}
	else
	{
		// return the one we already have
		return m_pBar->GetButtonExtra(iButton)->GetGlyph();
	}
}

// always call this function if the one above returns non-null. Do not delete hbmSingle yourself, since it
// may still be in use elsewhere
void CCustomBarProxy::DestroySingleBitmap(int iButton, HBITMAP hbmSingle)
{
	// now we need to decide whether the bitmap was synthesised above, or whether it wasn't
	BITMAP bmpData;
	::GetObject(hbmSingle, sizeof(BITMAP), &bmpData);

	// if the bitmap is the same size as the glyphs in the current bar, then 
	// it was just temporarily created and can be deleted
	if(	bmpData.bmWidth == m_pBar->m_sizeImage.cx &&
		bmpData.bmHeight == m_pBar->m_sizeImage.cy)
	{
		::DeleteObject(hbmSingle);
	}
}

BOOL CCustomBarProxy::ExpandDestination(int nCmdIDSrc, int nIndexDest)
{
	// can't expand out of range
	if(nIndexDest<0 || nIndexDest>=m_pBar->m_nCount)
	{
		return FALSE;
	}

	AFX_TBBUTTON *pTBB=m_pBar->_GetButtonPtr(nIndexDest);
	if((pTBB-> nStyle & TBBS_MENU)==0)
	{
		// can't expand non-menus
		return FALSE;
	}

	if(pTBB->nID==nCmdIDSrc)
	{
		return FALSE;
	}

	CBMenuPopup *pMenu=theCmdCache.GetMenu(pTBB->nID);
	if(	pMenu->m_hWnd!=NULL &&
		pMenu->IsWindowVisible())
	{
		// already expanded
		return FALSE;
	}

	if(nCmdIDSrc)
	{
		CBMenuPopup *pMenuSrc=theCmdCache.GetMenu(nCmdIDSrc);

		ASSERT(pMenuSrc!=NULL);
		
		if(pMenuSrc->ContainsMenu(pTBB->nID))
		{
			return FALSE;
		}
	}

	// now expand the item
	m_pBar->ExpandItem(nIndexDest, TRUE);

	// wait for menu to open
	// REVIEW: Maybe able to ditch this if we can think of something better
	do
	{
		theApp.PumpMessage();
	}
	while(!pMenu->IsPainted());

	return TRUE;
}

// returns the next visible item after the specified one. nIndex==-1 gets the first visible item
int CCustomBarProxy::FindNextVisibleItem(int nIndex, BOOL bForward)
{
	return m_pBar->FindNextVisibleItem(nIndex, bForward);
}

// TRUE if this bar is using large buttons
BOOL CCustomBarProxy::HasLargeButtons() const
{
	return theApp.m_bLargeToolBars;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dlgbase.cpp ===
//////////////////////////////////////////////////////////////////////////////
//      DLGBASE.CPP
//              Implementation for Sushi dialog base classes.
//

#include "stdafx.h"

#include "shell.h"
#include "dlgs.h"
#include "about.h"
#include "resource.h"

#include "shell.hid" // 26 Jun 96 - The combobox and the listbox need help ids for the
						// Chooser need help ids.

#include <prjapi.h>
#include <prjguid.h>
#include "toolexpt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);
extern UINT DSM_TESTMENU; 

///////////////////////////////////////////////////////////////////////////////
//      C3dDialog
//
C3dDialog::C3dDialog(LPCSTR lpszTemplateName, CWnd* pParentWnd)
    : CDialog(lpszTemplateName, FromHandle(_SushiGetSafeOwner(pParentWnd)))
{
}

C3dDialog::C3dDialog(UINT nTemplateID, CWnd* pParentWnd)
    : CDialog(nTemplateID, FromHandle(_SushiGetSafeOwner(pParentWnd)))
{
}

void C3dDialog::OnContextMenu(CWnd* pWnd, CPoint pt) 
{
	DoHelpContextMenu(this, m_nIDHelp, pt);
}

BOOL C3dDialog::OnHelpInfo(HELPINFO* pInfo) 
{
	return DoHelpInfo(this, m_nIDHelp, pInfo);
}

LRESULT C3dDialog::OnTestMenu(WPARAM wParam, LPARAM lParam)
{
	CMainFrame *pFrame=(CMainFrame*)AfxGetMainWnd();
	
	return pFrame->SendMessage(DSM_TESTMENU, wParam,lParam);
}

int WideStrLen(WCHAR* pwch)
{
	int nLen = 0;
	while (*pwch != 0)
	{
		pwch += 1;
		nLen += 1;
	}
	
	return nLen;
}


//++PATCH_CONTEXT_HELP
//  Borrow DLGTEMPLATEEX from AFXIMPL.H
#pragma pack(push, 1)
typedef struct
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATEEX;
#pragma pack(pop)

inline static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
{
	return ((DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
}

// BUGBUG:
// Res editor applies WS_EX_CONTEXTHELP for Context Help
// Ok for Win95, but NT 3,51 wants DS_CONTEXTHELP
//
static void PatchContextHelpStyle(HGLOBAL hTemplate)
{
	DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)GlobalLock(hTemplate);
	if (IsDialogEx(pTemplate))
	{
		if (((DLGTEMPLATEEX*)pTemplate)->exStyle & WS_EX_CONTEXTHELP)
			((DLGTEMPLATEEX*)pTemplate)->style |= DS_CONTEXTHELP;
	}
	else
	{
		if (pTemplate->dwExtendedStyle & WS_EX_CONTEXTHELP)
			pTemplate->style |= DS_CONTEXTHELP;
	}
	GlobalUnlock(hTemplate);
}
//--PATCH_CONTEXT_HELP

void SetStdFont(C3dDialogTemplate & dt)
{
	extern void GetStdFontInfo(int iType, CString& strFace, int& ptSize);

	CString strFace;
	int ptSize;
	GetStdFontInfo(font_Bold, strFace, ptSize);

	dt.SetFont(strFace, (WORD)ptSize);
}

int C3dDialog::DoModal()
{
	C3dDialogTemplate dt;
	LPCTSTR lpOldDialogTemplate = m_lpszTemplateName;
	if (dt.Load(m_lpszTemplateName))
	{
		SetStdFont(dt);
		m_lpszTemplateName = NULL;
		m_hDialogTemplate = NULL;
		PatchContextHelpStyle(dt.GetTemplate()); // REVIEW: (see note on function def. above)
		InitModalIndirect(dt.GetTemplate());
	}

	PreModalWindow();
	int nRet = CDialog::DoModal();
	PostModalWindow();
	
	m_lpszTemplateName = lpOldDialogTemplate;
	return nRet;
}

BOOL C3dDialog::Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd)
{
	C3dDialogTemplate dt;
	if (dt.Load(lpszTemplateName))
	{
		PatchContextHelpStyle(dt.GetTemplate()); // REVIEW: (see note on function def. above)
		SetStdFont(dt);
	}
	
	return CDialog::CreateIndirect(dt.GetTemplate(), pParentWnd);
}


BEGIN_MESSAGE_MAP(C3dDialog, CDialog)
    ON_COMMAND(IDOK, OnRobustOK)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
END_MESSAGE_MAP()

void C3dDialog::OnRobustOK()
{
#if 0   // FUTURE: Handle low memory.
    if (thePackage.CheckForEmergency())
    {
	SendMessage(WM_COMMAND, IDCANCEL);
	return;
    }
#endif

    OnOK(); // ok to call "real" OnOK
}

///////////////////////////////////////////////////////////////////////////////
//      C3dDialogBar
//

IMPLEMENT_DYNAMIC(C3dDialogBar, CDialogBar)

C3dDialogBar::C3dDialogBar()
{
	m_nDockableID = 0;
}

BOOL C3dDialogBar::Create(CWnd* pParentWnd, LPCTSTR lpszTemplateName, UINT nStyle, UINT nID)
{
	C3dDialogTemplate dt;
	if (dt.Load(lpszTemplateName))
		SetStdFont(dt);

	nStyle |= (CBRS_TOOLTIPS | CBRS_FLYBY);
	
	if (!CreateIndirect(dt.GetTemplate(), pParentWnd, nStyle, nID))
		return FALSE;

	return ExecuteDlgInit(lpszTemplateName);
}

BOOL C3dDialogBar::CreateIndirect(const void *lpDialogTemplate, CWnd* pParentWnd, UINT nStyle, UINT nID)
{
	ASSERT(pParentWnd != NULL);
	ASSERT(lpDialogTemplate != NULL);

	// allow chance to modify styles
	m_dwStyle = nStyle;
	CREATESTRUCT cs;        // This is only used for a call to PreCreateWindow().
	memset(&cs, 0, sizeof(cs));
	cs.lpszClass = NULL;
	cs.style = (DWORD)nStyle | WS_CHILD;
	cs.hMenu = (HMENU)nID;
	cs.hInstance = AfxGetInstanceHandle();
	cs.hwndParent = pParentWnd->GetSafeHwnd();
	if (!PreCreateWindow(cs))
		return FALSE;

	// create a modeless dialog
	AfxHookWindowCreate(this);
	HWND hWnd = ::CreateDialogIndirect(AfxGetInstanceHandle(),
		(LPCDLGTEMPLATE)lpDialogTemplate, pParentWnd->GetSafeHwnd(), NULL);
	if (!AfxUnhookWindowCreate())
		PostNcDestroy();        // cleanup if Create fails too soon

	if (hWnd == NULL)
		return FALSE;
	ASSERT(hWnd == m_hWnd);

	// dialog template MUST specify that the dialog
	//      is an invisible child window
	SetDlgCtrlID(nID);
	CRect rect;
	GetWindowRect(&rect);
	m_sizeDefault = rect.Size();    // set fixed size

	// force WS_CLIPSIBLINGS
	ModifyStyle(0, WS_CLIPSIBLINGS);

	// Make sure we get parent notifications from our children.
	for (CWnd* pWnd = GetTopWindow(); pWnd != NULL;
			pWnd = pWnd->GetWindow(GW_HWNDNEXT))
		pWnd->ModifyStyleEx(WS_EX_NOPARENTNOTIFY, 0);

	// allow CTL3D32.DLL to subclass the dialog and its controls
	// REVEIW_MFC: we shouldn't have to explicitly enable 3d controls!
//      if (!theApp.m_bWin4)
//              SubclassDlg3d();
		
	// force the size to zero - resizing bar will occur later
	SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER|SWP_NOACTIVATE|SWP_SHOWWINDOW);

	return TRUE;
}

void C3dDialogBar::RecalcBarLayout(DOCKPOS dp, BOOL bForceCenter /*=FALSE*/)
{
	ASSERT(m_nDockableID);

	DWORD dwStyleOld = GetBarStyle();

	m_sizeDefault.cy = CY_TOOLBAR;

	if (theApp.m_bWin4)
	{
		if (dp != dpMDI)
			SetBarStyle(dwStyleOld & ~CBRS_BORDER_TOP);
		else
		{
			m_sizeDefault.cy += CY_BORDER * 2;
			SetBarStyle(dwStyleOld | CBRS_BORDER_TOP);
		}
	}

	if (bForceCenter || dwStyleOld != GetBarStyle())
		VertCenterControls();
}

void C3dDialogBar::VertCenterControls(int cySize /*=0*/)
{
	if (cySize == 0)
	{
		cySize = m_sizeDefault.cy;

		DWORD dwStyle = GetBarStyle();

		int cyBorder = CY_BORDER;
		if (dwStyle & CBRS_BORDER_3D)
			cyBorder = CY_BORDER * 2;

		if (dwStyle & CBRS_BORDER_TOP)
			cySize += cyBorder;
		if (dwStyle & CBRS_BORDER_BOTTOM)
			cySize -= cyBorder;
	}
	
	// Count the controls.
	int nControls = 0;
	for (HWND hwnd = ::GetTopWindow(m_hWnd); hwnd != NULL;
			hwnd = ::GetWindow(hwnd, GW_HWNDNEXT))
		nControls++;

	CRect rect;

	HDWP hdwp = ::BeginDeferWindowPos(nControls);
	for (hwnd = ::GetTopWindow(m_hWnd); hwnd != NULL;
			hwnd = ::GetWindow(hwnd, GW_HWNDNEXT))
	{
		::GetWindowRect(hwnd, rect);
		ScreenToClient(rect);

		hdwp = ::DeferWindowPos(hdwp, hwnd, NULL,
			rect.left, (cySize - rect.Height()) / 2, 0, 0,
			SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
	}
	::EndDeferWindowPos(hdwp);
}

BEGIN_MESSAGE_MAP(C3dDialogBar, CDialogBar)
    ON_WM_NCHITTEST()
END_MESSAGE_MAP()

BOOL C3dDialogBar::PreTranslateSysKey(MSG* pMsg)
{
	ASSERT(pMsg->message == WM_SYSKEYDOWN);

	if ((GetStyle() & WS_VISIBLE) == 0 || IsChild(GetFocus()))
		return FALSE;

	for (CWnd* pWnd = GetTopWindow(); pWnd != NULL;
		pWnd = pWnd->GetWindow(GW_HWNDNEXT))
	{
		WORD nCode = (WORD)(DWORD)pWnd->SendMessage(WM_GETDLGCODE);

		if ((nCode & DLGC_STATIC) || (nCode & DLGC_BUTTON))
		{
			CString strText;
			pWnd->GetWindowText(strText);
			if (FindAccel(strText, pMsg))
			{
				if (nCode & DLGC_STATIC)
				{
					CWnd* pWndNext = pWnd->GetWindow(GW_HWNDNEXT);
					if (pWndNext != NULL && pWndNext->IsWindowEnabled())
					{
						pWndNext->SetFocus();
						if (pWndNext->SendMessage(WM_GETDLGCODE) & DLGC_HASSETSEL)
							pWndNext->SendMessage(EM_SETSEL, 0, -1);
					}
				}
				else if (pWnd->IsWindowEnabled())
				{
					pWnd->SendMessage(WM_LBUTTONDOWN);      // Click on button.
					pWnd->SendMessage(WM_LBUTTONUP);
				}
				return TRUE;
			}
		}
	}

	return FALSE;
}

LRESULT C3dDialogBar::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	// Filter window docking messages
	LRESULT lResult;
	if (m_nDockableID != 0 &&
			DkPreHandleMessage(m_hWnd, message, wParam, lParam, &lResult))
		return lResult;

	return CDialogBar::WindowProc(message, wParam, lParam);
}

//      C3dDialogBar::OnNcHitTest
//      All non-control area is HTCAPTION for dock moving.

UINT C3dDialogBar::OnNcHitTest(CPoint pt)
{
	if (m_nDockableID != 0 && DkWGetDock(m_nDockableID) != dpMDI)
	{
		for (CWnd* pWnd = GetTopWindow(); pWnd != NULL;
			pWnd = pWnd->GetWindow(GW_HWNDNEXT))
		{
			if (pWnd->IsWindowVisible() &&
				pWnd->SendMessage(WM_NCHITTEST, 0,
					MAKELPARAM(pt.x, pt.y)) != HTNOWHERE &&
				((WORD)(DWORD)pWnd->SendMessage(WM_GETDLGCODE) &
					DLGC_STATIC) == 0)
			{
				return HTCLIENT;
			}
		}

		return HTCAPTION;
	}

    return CDialogBar::OnNcHitTest(pt);
}

BOOL FindAccel(LPCTSTR lpstr, MSG *pMsg)
{
	ASSERT(pMsg->message == WM_SYSKEYDOWN);

	UINT nKey = MapVirtualKey(pMsg->wParam, 2);
	if ((int) nKey <= 0)    // Check for Zero or high bit.
		return FALSE;

	CString strAccel = _T('&');
	strAccel += (TCHAR) LOWORD(nKey);
	strAccel.MakeUpper();

	CString strCtl = lpstr;
	strCtl.MakeUpper();
	return (strCtl.Find(strAccel) != -1);
}

///////////////////////////////////////////////////////////////////////////////
//      C3dBitmapButton
//              Derrived class of CBitmapButton for our dialog bars.

C3dBitmapButton::C3dBitmapButton()
{
	m_bToggle = FALSE;
}

// Autoload will load the bitmap resources based on the text of
//  the button
// Using suffices "U", "D", "F" and "X" for up/down/focus/disabled
// and extra suffix to support Chicago.
BOOL C3dBitmapButton::AutoLoad(UINT nID, CWnd* pParent,
	BOOL bToggle /*=FALSE*/, LPCRECT lpRect /*=NULL*/)
{
	// first attach the CBitmapButton to the dialog control
	if (!SubclassDlgItem(nID, pParent))
		return FALSE;

	m_bToggle = bToggle;

	DrawBitmaps(bToggle, lpRect);

	// we need at least the primary
	if (m_bitmap.m_hObject == NULL)
		return FALSE;

	// size to content
	SizeToContent();
	return TRUE;
}

BOOL C3dBitmapButton::DrawBitmaps(BOOL bToggle, LPCRECT lpRect)
{
	// delete old bitmaps (if present)
	m_bitmap.DeleteObject();
	m_bitmapSel.DeleteObject();
	m_bitmapFocus.DeleteObject();
	m_bitmapDisabled.DeleteObject();

	CString strText;
	GetWindowText(strText);
	ASSERT(!strText.IsEmpty());             // must provide a title

	HBITMAP hbm, hbmButton;
	UINT nStyle = TBBS_BUTTON;
	CBitmap* pbmGlyph = NULL;
	LPCTSTR lpszText = NULL;

	if (strText.Find(_T('&')) != -1)        // Text button?
		lpszText = strText;
	else
	{
		LoadBitmaps(strText + _T("U"), strText + _T("D"),
		  NULL, strText + _T("X"));
		
		pbmGlyph = &m_bitmap;
	}

	hbmButton = CreateButtonBitmap(nStyle, lpRect, pbmGlyph, lpszText);
	if (hbmButton == NULL)
	{
		TRACE0("Failed to create bitmap for normal image.\n");
		goto failed;   // need this one image
	}

	nStyle |= (bToggle ? TBBS_CHECKED : TBBS_PRESSED);
	if (m_bitmapSel.m_hObject != NULL)
		pbmGlyph = &m_bitmapSel;
	
	hbm = CreateButtonBitmap(nStyle, lpRect, pbmGlyph, lpszText);
	if (hbm != NULL)
	{
		m_bitmapSel.DeleteObject();
		m_bitmapSel.Attach(hbm);
	}

	m_bitmap.DeleteObject();        // delete the glyph.
	m_bitmap.Attach(hbmButton);

	if (m_bitmapDisabled.m_hObject != NULL)
	{
		pbmGlyph = &m_bitmapDisabled;

		hbm = CreateButtonBitmap(TBBS_BUTTON, lpRect, pbmGlyph);
		if (hbm != NULL)
		{
			m_bitmapDisabled.DeleteObject();
			m_bitmapDisabled.Attach(hbm);
		}
	}

	return TRUE;

failed:
	// delete bitmaps (if present)
	m_bitmap.DeleteObject();
	m_bitmapSel.DeleteObject();
	m_bitmapFocus.DeleteObject();
	m_bitmapDisabled.DeleteObject();

	return FALSE;   
}

HBITMAP C3dBitmapButton::CreateButtonBitmap(UINT nStyle,  LPCRECT lpRect,
		CBitmap* pbmGlyph /*= NULL*/, LPCTSTR lpszText /*= NULL*/)
{
	return ::CreateButtonBitmap(this, nStyle, lpRect, pbmGlyph, lpszText);
}


void C3dBitmapButton::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CBitmapButton::DrawItem(lpDIS);

	if (GetState() & 4)
	{
		UINT nID = lpDIS->CtlID;
		CString strRes, strPrompt;
		if (nID != 0 && (!strRes.LoadString(nID) ||
				!AfxExtractSubString(strPrompt, strRes, 0)))
			TRACE1("No String for ID = 0x%x.\n", nID);

		SetPrompt(strPrompt);
	}
}

BEGIN_MESSAGE_MAP(C3dBitmapButton, CBitmapButton)
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_SYSCOLORCHANGE()
END_MESSAGE_MAP()

void C3dBitmapButton::OnLButtonDblClk(UINT nFlags, CPoint pt)
{
	// we're getting bogus double click messages for the button class
	// that don't have special meaning (this is because we are subclassing
	// the windows BUTTON class).  We turn these into regular WM_LBUTTONDOWN
	//
	SendMessage(WM_LBUTTONDOWN, (WPARAM)nFlags, (LPARAM)MAKELONG(pt.x, pt.y));
}

void C3dBitmapButton::OnLButtonUp(UINT n1, CPoint pt)
{
	// do default processing for this message...
	CBitmapButton::OnLButtonUp(n1, pt);

	// the above call could destroy this window
	// put focus back in parent at some level
	if (CWnd::FromHandlePermanent(m_hWnd) == this && ::GetFocus() == m_hWnd)
	{
		CFrameWnd* pFrame = GetParentFrame();
		ASSERT(pFrame != NULL);

		HWND hwndFocus = NULL, hwndView = theApp.GetActiveView();
		CWnd* pWndParent = this;
		if (hwndView != NULL)
		{
			do
			{
				pWndParent = pWndParent->GetParent();
				ASSERT(pWndParent != NULL);

				if (::IsChild(pWndParent->m_hWnd, hwndView))
				{
					hwndFocus = hwndView;
					break;
				}
				else if (pWndParent->IsKindOf(RUNTIME_CLASS(CDialog))) // REVIEW: bobz - expensive?
				{
					hwndFocus = pWndParent->m_hWnd;
					break;
				}
			}
			while (pWndParent != pFrame);
		}
		else // hwndView NULL, but in a dialog
		{
			pWndParent = pWndParent->GetParent();
			ASSERT(pWndParent != NULL);

			if (pWndParent->IsKindOf(RUNTIME_CLASS(CDialog)))
			{
				hwndFocus = pWndParent->m_hWnd;
			}

		}

		if (hwndFocus == NULL)
			hwndFocus = pFrame->m_hWnd;
		if (hwndFocus != NULL)
			::SetFocus(hwndFocus);
	}

	SetPrompt();    // Clear the prompt.
}

void C3dBitmapButton::OnSysColorChange()
{
	CRect rect;
	GetWindowRect(rect);
	DrawBitmaps(m_bToggle, rect);

	Invalidate(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
//      C3dFileDialog
//
DWORD MungeFlags( DWORD dwFlags )
{
	if( dwFlags & OFN_ENABLETEMPLATE )
		dwFlags = (dwFlags & ~OFN_ENABLETEMPLATE) | OFN_ENABLETEMPLATEHANDLE;

	return dwFlags;
}

C3dFileDialog::C3dFileDialog(BOOL bOpenFileDialog, LPCSTR lpszDefExt,
    LPCSTR lpszFileName, DWORD dwFlags, LPCSTR lpszFilter, CWnd* pParentWnd,
    UINT nHelpID, UINT nExplorerDlg)
: CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, MungeFlags( dwFlags ),
    lpszFilter, FromHandle(_SushiGetSafeOwner(pParentWnd)))
{
	m_dirCurBefore.CreateFromCurrent();
	if( bOpenFileDialog )
		m_ofn.Flags |= OFN_PATHMUSTEXIST;

	if (nHelpID)
		SetHelpID(nHelpID);

	m_iddWinNT = nHelpID;
	m_iddWin95 = nExplorerDlg;      // -1 means no explorer dialog
	m_bMultiSelectOnNT = FALSE;
	m_bSccEnabled = FALSE;

	m_psaFileNames = NULL;
}

C3dFileDialog::~C3dFileDialog()
{
	if (m_dirCurBefore != m_dirCurAfter)
	{
		// If the dialog was closed with Cancel, the current directory
		// was restored to "Before".  Here we make sure that "After"
		// is current.
		m_dirCurAfter.MakeCurrent();

		// Notify everyone that the current directory was changed.
		((CMainFrame*) theApp.m_pMainWnd)->OnDirChange();
	}
}

int C3dFileDialog::DoModal()
{
	if( theApp.m_bWin4 && (m_iddWin95 != (UINT)-1) )
	{
		if ((m_bSccEnabled) && (m_iddWin95==0))
		{
			m_iddWin95 = IDD_CHICAGO_WRKSPCOPEN;
		}

		if( m_iddWin95 != 0x0 )
		{
			m_ofn.lpTemplateName = MAKEINTRESOURCE(m_iddWin95);
			m_ofn.Flags |= OFN_ENABLETEMPLATEHANDLE;
		}
		else
		{
			m_ofn.lpTemplateName = NULL;
			m_ofn.Flags &= ~OFN_ENABLETEMPLATEHANDLE;
		}

		m_ofn.Flags |= OFN_EXPLORER;
		m_bMultiSelectOnNT = FALSE;
	}
	else
	{
		if( m_iddWinNT != 0x0 )
		{
			m_ofn.lpTemplateName = MAKEINTRESOURCE(m_iddWinNT);
			m_ofn.Flags |= OFN_ENABLETEMPLATEHANDLE;
		}
		else
		{
			m_ofn.lpTemplateName = NULL;
			m_ofn.Flags &= ~OFN_ENABLETEMPLATEHANDLE;
		}

		m_ofn.Flags &= ~OFN_EXPLORER;
		if( m_ofn.Flags & OFN_ALLOWMULTISELECT )
		{
			m_bMultiSelectOnNT = TRUE;
			m_ofn.Flags &= ~OFN_ALLOWMULTISELECT;
		}
		else
			m_bMultiSelectOnNT = FALSE;
	}

	m_ofn.Flags &= ~OFN_SHOWHELP;

	C3dDialogTemplate dt;
	PreModalWindow();
	
	// Munge the dialogs font
	if (m_ofn.Flags & OFN_ENABLETEMPLATEHANDLE)
	{
		VERIFY( dt.Load( m_ofn.lpTemplateName ) );
		SetStdFont(dt);
		m_ofn.hInstance = (HINSTANCE) dt.GetTemplate();
	}

	int nRet = CFileDialog::DoModal();

	// Note: We used to try to do our own case sensitive default extension
	// handling for saving, but since COMMDLG strips off any period typed by
	// the user, we ended up adding default extension even when not wanted
	// (Bug 12492). If the user wants a case specific extension then they
	// will just have to type it.  Also doing it here allows saving to an
	// open file, since we check for that case in OnFileNameOK().
	
	PostModalWindow();

	if( (nRet == -1) && (m_ofn.Flags & OFN_EXPLORER)
		&& (CommDlgExtendedError() == 0x2) )            // initialization failure
	{
		ASSERT( m_iddWin95 != (UINT)-1 );
		m_iddWin95 = (UINT)-1;          // explorer dialog doesn't work on this operating system

		return DoModal();                       // try again (recursive call will now use NT dialog)
	}
	else if( m_bMultiSelectOnNT )
	{               // return things to the way we found them
		m_ofn.Flags |= OFN_ALLOWMULTISELECT;
	}

	return nRet;
}

BOOL C3dFileDialog::OnInitDialog()
{
	ModifyStyle(0, DS_CONTEXTHELP);
	ModifyStyleEx(0, WS_EX_CONTEXTHELP);

	CWnd* pScc = GetDlgItem(IDC_SCC);
	if (pScc != NULL)
	{
		// Conditionally provide Source Control button
		LPSOURCECONTROLSTATUS pInterface;
		if (SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)))
		{
			LPSOURCECONTROL pSccManager;
			VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
			BOOL bScc = ((m_bSccEnabled) && (pInterface->IsSccInstalled() == S_OK) && (pSccManager->CanBrowse() == S_OK) && (pSccManager->CanSync() == S_OK));
			pInterface->Release();
			pSccManager->Release();
			ASSERT( pScc != NULL );
			if (IsExplorer())
			{
				CWnd * pSep = GetDlgItem(IDC_SCC_SEPARATOR);
				ASSERT( pSep != NULL );
				CWnd * pTxt = GetDlgItem(IDC_SCC_HELPERTEXT);
				ASSERT( pTxt != NULL );

				if (bScc)
				{
					// position button directly under OK button -- right-justified
					CRect rcOK, rcScc, rcSep, rcTxt, rcLB;
					pScc->GetWindowRect(&rcScc);
		
					CWnd * pOK = GetParent()->GetDlgItem(IDOK);
					ASSERT(pOK != NULL);
					pOK->GetWindowRect(&rcOK);

					pSep->GetWindowRect(&rcSep);
					pTxt->GetWindowRect(&rcTxt);

					CWnd * pLB = GetParent()->GetDlgItem(lst1);
					ASSERT(pLB != NULL);
					pLB->GetWindowRect(&rcLB);

					int offset = rcOK.right - rcScc.right;
					rcScc.left += offset;
					rcScc.right += offset;

					rcSep.right = rcOK.right;
					rcSep.left = rcLB.left;

					rcTxt.right = rcScc.left - 8; // leave a slight gap
					rcTxt.left = rcLB.left;

					ScreenToClient(&rcScc);
					pScc->MoveWindow(&rcScc);

					ScreenToClient(&rcSep);
					pSep->MoveWindow(&rcSep);

					ScreenToClient(&rcTxt);
					pTxt->MoveWindow(&rcTxt);
				}

				pSep->EnableWindow(bScc);
				pSep->ShowWindow(bScc ? SW_SHOWNA : SW_HIDE);

				pTxt->EnableWindow(bScc);
				pTxt->ShowWindow(bScc ? SW_SHOWNA : SW_HIDE);
			}
			pScc->EnableWindow(bScc);
			pScc->ShowWindow(bScc ? SW_SHOWNA : SW_HIDE);
		}
		else
		{
			pScc->EnableWindow(FALSE);
			pScc->ShowWindow(SW_HIDE);
		}
	}

	return CFileDialog::OnInitDialog();
}

void C3dFileDialog::OnScc()
{
	// ASSERT(m_bSccEnabled);
	COleRef<ISourceControlStatus> pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
	ASSERT(pInterface->IsSccInstalled() == S_OK);

	CWnd* pDirName = IsExplorer() ? GetParent()->GetDlgItem(stc1)
		: GetDlgItem(stc1);
	ASSERT( pDirName != NULL );
	CString strDirName;
	CString strProjName;
	CString strProjPath;
	pDirName->GetWindowText(strDirName);
	CWnd* pFileName = IsExplorer() ? GetParent()->GetDlgItem(edt1) : GetDlgItem(edt1);
	ASSERT(pFileName != NULL);
	LPSOURCECONTROL pSccManager;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
	if (SUCCEEDED(pSccManager->GetProject(strProjName, strDirName, strProjPath, FALSE)))
	{

	//	CString strFileName;
	//	pFileName->GetWindowText(strFileName);

		pFileName->SetRedraw(FALSE);
		// set directory where the dialog should now be pointing
		pFileName->SetWindowText(strDirName);

		// force an update of file list box contents (press OK)
		CWnd *pOK = (IsExplorer() ? GetParent()->GetDlgItem(IDOK) : GetDlgItem(IDOK));
		ASSERT(pOK != NULL);
		GotoDlgCtrl(pOK);
		pOK->SendMessage(WM_LBUTTONDOWN, 0, 0);
		pOK->SendMessage(WM_LBUTTONUP, 0, 0);

		CPath pathProj;
		pathProj.Create(strProjPath);

		// REVIEW [patbr]: we should set the filter to that which contains
		// the extension of the file that was passed back in strProjPath...

		if (IsExplorer())
		{
			// get the listview and select the project name
			CWnd *pListViewParent = GetParent()->GetDlgItem(lst2);
			CListCtrl *pListCtrl = (CListCtrl *)pListViewParent->GetDescendantWindow(0x01);

			LV_FINDINFO lvfi;
			lvfi.flags = LVFI_STRING;
			lvfi.psz = pathProj.GetFileName();
			lvfi.lParam = NULL;
			int nIndex = pListCtrl->FindItem(&lvfi);
			if (nIndex != -1)
			{
				LV_ITEM lvItem;
				lvItem.iItem = nIndex;
				lvItem.iSubItem = 0;
				lvItem.mask = LVIF_STATE;
				lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
				lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
				pListCtrl->SetItem(&lvItem);
				pListCtrl->SetFocus();
			}
		}

		// set content of file name edit field to project name
		pFileName->SetWindowText(pathProj.GetFileName());
		pFileName->SetRedraw(TRUE);
	}

	if (pInterface->IsSccInstalled() != S_OK) {
// if there are problems upon pushing the scc button (such as sourcesafe4 installed),
// then subsequent pushes shouldn't work. kind of freaky ui..will probably need to improve.
		CWnd* pScc = GetDlgItem(IDC_SCC);
		ASSERT( pScc != NULL );
		pScc->EnableWindow(FALSE);
		pScc->ShowWindow(SW_SHOWNA);
	
		CWnd * pSep = GetDlgItem(IDC_SCC_SEPARATOR);
		ASSERT( pSep != NULL );
		pSep->EnableWindow(FALSE);
		pSep->ShowWindow(SW_SHOWNA);

		CWnd * pTxt = GetDlgItem(IDC_SCC_HELPERTEXT);
		ASSERT( pTxt != NULL );
		pTxt->EnableWindow(FALSE);
		pTxt->ShowWindow(SW_SHOWNA);
	}
	pSccManager->Release();
}

LPCTSTR C3dFileDialog::GetFilterExtension(int n)
{
	LPCTSTR pch = m_ofn.lpstrFilter;

	if( pch == NULL )
		return NULL;

	for( int i = 0; *pch ; i++ )
	{
		while( *pch++ )         // skip listbox string
			;
		if( i == n )
			return pch;
		while( *pch++ )         // skip extension string
			;
	}

	return NULL;
}

// Call this function to 
void C3dFileDialog::ApplyDefaultExtension(void)
{
	CWnd* pName = GetDlgItem(edt1);
	CString strName;
	pName->GetWindowText(strName);

	char acDrive[_MAX_DRIVE];
	char acDir[_MAX_DIR];
	char acName[_MAX_FNAME];
	char acExt[_MAX_EXT];
	_splitpath(strName,acDrive, acDir, acName, acExt);

	if( (*acExt == '\0') &&
		(m_ofn.lpstrDefExt != NULL) )
	{
		strName = acDrive;
		strName += acDir;
		strName += acName;
		ASSERT( _tcschr(m_ofn.lpstrDefExt, '.') == NULL );
		strName += '.';
		strName += m_ofn.lpstrDefExt;
		pName->SetWindowText(strName);
	}
}

BEGIN_MESSAGE_MAP(C3dFileDialog, CFileDialog)
	ON_EN_KILLFOCUS(edt1, OnNameKillFocus)
	ON_LBN_SELCHANGE(lst1, OnFileListSelChange)
    ON_COMMAND(IDOK, OnRobustOK)
	ON_BN_CLICKED(IDC_SCC, OnScc)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
END_MESSAGE_MAP()

void C3dFileDialog::OnContextMenu(CWnd* pWnd, CPoint pt) 
{
	DoHelpContextMenu(this, m_nIDHelp, pt);
}

BOOL C3dFileDialog::OnHelpInfo(HELPINFO* pInfo) 
{
	return DoHelpInfo(this, m_nIDHelp, pInfo);
}

void C3dFileDialog::UpdateType(LPCTSTR lpszName /*=NULL*/)
{
	CComboBox* pTypeCombo = (CComboBox*)(IsExplorer() ? 
		GetParent()->GetDlgItem(cmb1) : GetDlgItem(cmb1));
	int nCurSel = pTypeCombo->GetCurSel();

	CString strExt, strFilter, strTmp;
	
	if (lpszName != NULL)
		strExt = lpszName;
	else
	{
		CEdit* pNameEdit = (CEdit*)(IsExplorer() ? 
			GetParent()->GetDlgItem(edt1) : GetDlgItem(edt1));
		pNameEdit->GetWindowText(strExt);
	}

	BOOL bExpr = (strExt.FindOneOf(_TEXT("*?")) != -1);

	strExt.MakeLower();
	if (strExt.Find(_T(';')) == -1)
		strExt = GetExtension(strExt);

	// Just return if no extension. (Empty or ".")
	if (strExt.GetLength() < 2)
		return;

	if (strExt.Find(_T(';')) == -1)
	{
		strTmp = _TEXT("*");
		strTmp += strExt;
		strExt = strTmp;
	}

	// Bracket the search string with ";" to insure valid find results.
	strTmp = _TEXT(";");
	strTmp += strExt;
	strTmp += _TEXT(";");
	strExt = strTmp;

	LPCTSTR pch = m_ofn.lpstrFilter;
	int nIndex = 0, nSel = LB_ERR;
	int nLen = INT_MAX;

	for (;;)
	{
		// Skip listbox string
		while (*pch++ != _T('\0'))
			;

		if (*pch == _T('\0'))
			break;

		// Bracket the filter string with ";" to insure valid find results.
		strFilter = _TEXT(";");
		strFilter += pch;
		strFilter += _TEXT(";");
		if (strFilter.Find(strExt) != -1)
		{
			if (!bExpr && nIndex == nCurSel)
			{
				// Not expression, and extension in current type selection.
				nSel = nIndex;
				break;
			}

			int nNewLen = _tcslen(pch);
			if (nNewLen < nLen)
			{
				// Select shortest extension list containing this string.
				nLen = nNewLen;
				nSel = nIndex;
			}
		}

		// Skip the extension list
		while (*pch++ != _T('\0'))
			;

		nIndex++;
	}

	if (nSel != LB_ERR)
	{
		pTypeCombo->SetCurSel(nSel);
		m_ofn.nFilterIndex = nSel + 1;
	}
}

void C3dFileDialog::SetOkButtonText(UINT ids)
{
	CString strOK;
	strOK.LoadString(ids);
	if( IsExplorer() )
	{
		ASSERT( GetParent() != NULL );
		GetParent()->SendMessage(CDM_SETCONTROLTEXT, IDOK, (LPARAM)(const char*)strOK);
	}
//      else
//              SetDlgItemText(IDOK, strOK);    // this isn't really NT standard -- we could just not do anything here
}

void C3dFileDialog::OnNameKillFocus()
{
	if (m_ofn.lpstrFilter != NULL)
		UpdateType();
	Default();
}

void C3dFileDialog::OnRobustOK()
{
#if 0
    if (thePackage.CheckForEmergency())
    {
	SendMessage(WM_COMMAND, IDCANCEL);
	return;
    }
#endif
	
    OnOK(); // ok to call "real" OnOK
}

/* OnFileListSelChange
 *      In order for the the multi-selection on NT hack to work, the contents of
 *      the edit control must reflect the selection in the list box, or else
 *      the list box selection is ignored.  Unfortunately, when an item is
 *      deselected, it still shows up in the edit control, which causes the exact
 *      opposite of the desired effect.
 */
void C3dFileDialog::OnFileListSelChange()
{
	Default();              // first let CommDlg do its thing

	if( !m_bMultiSelectOnNT )
		return;

	CListBox* pList = (CListBox*)GetDlgItem(lst1);
	ASSERT( pList != NULL );

	int nCurSel = pList->GetCurSel();

	CString strEdit;
	if( pList->GetSel(nCurSel) > 0 )        // user selected new item
		pList->GetText(nCurSel, strEdit);
	else
	{
		// user DE-selected an item, so don't let CommDlg put that filename
		// in the edit field
		int nCount = pList->GetCount();
		while( --nCount >= 0 )
		{
			if( pList->GetSel(nCount) > 0 )
				break;
		}
		if( nCount < 0 )
			strEdit.Empty();
		else
			pList->GetText(nCount, strEdit);
	}

	SetDlgItemText(edt1, strEdit);
}

void C3dFileDialog::OnOK()
{
	m_dirCurAfter.CreateFromCurrent();

    CFileDialog::OnOK();   // Do this first, or we get saved index problem.
}

// COMMDLG saves the current directory when the dialog starts up.  If the user
// exits with Cancel, that directory is restored.  Since we want the user's
// directory changes to be kept, we save the CWD here, let COMMDLG do its thing,
// then restore the user's choice in the destructor.
// 
void C3dFileDialog::OnCancel()
{
	m_dirCurAfter.CreateFromCurrent();

    CFileDialog::OnCancel(); 
}

#if 0
void C3dFileDialog::OnLBSelChangedNotify (UINT nIDBox, UINT iCurSel, UINT nCode)
{
	if (nIDBox == lst1)
	{
	}
	CFileDialog::OnLBSelChangedNotify (nIDBox, iCurSel, nCode);
}
#endif

// COMMDLG calls back here after OK is pressed but before the dialog
// is closed.  This gives you a chance to reject the user's input.
//
//      In addition to checking the filename(s), we also add a file extension
//      if the user did not specify one and one is called for.
//
//      Since the user may have selected more than one file, we reject the input 
//      if any of the files does not exist.
BOOL C3dFileDialog::OnFileNameOK()
{
	if (!m_bOpenFileDialog)
	{
		// because OnKillFocus may never get called do it here
		if (m_ofn.lpstrFilter != NULL)
			UpdateType();
		return CFileDialog::OnFileNameOK();
	}

	// work-around for win bug [fabriced]
	CButton *pChk = (CButton *)(IsExplorer() ? 
						GetParent()->GetDlgItem(chx1) :	GetDlgItem(chx1));
	if(pChk && pChk->GetCheck())
		m_ofn.Flags |= OFN_READONLY;

	int nLength = 0;
	CString strText = GetFileName();
	nLength = strText.GetLength();

	CDir dir;
	VERIFY(dir.CreateFromCurrent());
	nLength += dir.GetLength() + _MAX_EXT + 3;	// add room for extension, backslash, trailing double NULL

	LPSTR lpstrFileT = m_ofn.lpstrFile;
	int nMaxFileT = m_ofn.nMaxFile;

	LPSTR lpstrFile = (LPSTR)malloc(nLength);
	memset(lpstrFile, 0, nLength);
	m_ofn.lpstrFile = lpstrFile;
	m_ofn.nMaxFile = (DWORD)nLength;

	if (strText.Find("\" \"") >= 0)
	{
		// we have multiple filenames selected or entered by the user
		_tcscpy(m_ofn.lpstrFile, (const TCHAR *)dir);
		int nOffset = dir.GetLength() + 1;
		m_ofn.lpstrFileTitle = m_ofn.lpstrFile + nOffset;
		m_ofn.nFileOffset = (WORD)nOffset;
		int nStart, nEnd;
		while ((nStart = strText.Find("\"")) != -1)
		{
			strText = strText.Right(strText.GetLength() - nStart - 1);
			nEnd = strText.Find("\"");
			CString strName = strText.Left(nEnd);
			_tcscpy(m_ofn.lpstrFile + nOffset, strName);
			strText = strText.Right(strText.GetLength() - nEnd - 1);
			nOffset += nEnd + 1;
		}
	}
	else
	{
		// single filename selected or entered--commdlg has
		// the right path and we don't have to do anything to it
		_tcscpy(m_ofn.lpstrFile, lpstrFileT);
		m_ofn.nMaxFile = nMaxFileT;
	}

	// fill in m_psaFileNames with the multiple filenames
	if( m_psaFileNames != NULL )
	{
		m_psaFileNames->RemoveAll();
		if( !m_bMultiSelectOnNT )
		{
			POSITION pos = GetStartPosition();
			while( pos != NULL )
				m_psaFileNames->Add(GetNextPathName(pos));
		}
		else
			UpdateMultiSelectOnNT();
	}
	else
	{
		ASSERT((m_ofn.Flags & OFN_ALLOWMULTISELECT) == 0);      // we need the StringArray to handle multiselection issues
	}

	// Do better than commdlg 'default extension'
	CString strFileName;
	int nFiles = (m_psaFileNames == NULL) ? 1 : m_psaFileNames->GetSize();
	for( int iFile = 0; iFile < nFiles; iFile++ )
	{
		if(m_psaFileNames == NULL)
			strFileName = GetPathName();
		else
			strFileName = m_psaFileNames->GetAt(iFile);

		CString strFileTemp = strFileName;
		// don't do MakeUpper on the original file name--this mangles MBCS characters
		strFileTemp.MakeUpper();
		int nIndex;
		// check for indications that this is a UNC or URL path name and adjust if necessary
		if ((nIndex = strFileTemp.Find("\\\\\\")) != -1)
		{
			strFileName = strFileName.Right(strFileName.GetLength() - nIndex - 1);
		}
		else if ((nIndex = strFileTemp.Find("FILE:")) != -1)
		{
			strFileName = strFileName.Right(strFileName.GetLength() - nIndex);
		}
		else if ((nIndex = strFileTemp.Find("HTTP:")) != -1)
		{
			strFileName = strFileName.Right(strFileName.GetLength() - nIndex);
		}

		if (FileExists(strFileName))
			continue;

		CString strExt = GetExtension(strFileName);
		if (strExt.IsEmpty())
		{
			CComboBox* pComboBox = (CComboBox*)GetDlgItem(cmb1);
			if( IsExplorer() )
			{
				ASSERT( pComboBox == NULL );
				pComboBox = (CComboBox*)GetParent()->GetDlgItem(cmb1);
			}
			ASSERT( pComboBox != NULL );
			int nSel = pComboBox->GetCurSel();
			if (nSel >= 0)
			{
				LPCSTR lpsz = m_ofn.lpstrFilter;
				while (lpsz[0] != 0 && nSel--)
				{
					lpsz += lstrlen(lpsz)+1;    // skip past display text
					ASSERT(lpsz[0] != 0);
					lpsz += lstrlen(lpsz)+1;    // skip past *.ext info
				}
				if (lpsz[0])
				{
					lpsz += lstrlen(lpsz)+1;    // skip past display text
					ASSERT(lpsz[0] == '*');
					ASSERT(lpsz[1] == '.');
					ASSERT(lpsz[2] != '\0');
					do
					{
						CString strTestName = strFileName;
						_TCHAR ext[_MAX_EXT];
						int i = 0;

						while (*++lpsz != '\0' && *lpsz != ';')
							ext[i++] = *lpsz;
						ext[i] = '\0';

						strTestName += ext;

						// Check for existence.
						if (FileExists(strTestName))
						{
							// Update the file name
							// Note that FOR::CE() assumes no dot.
							if( m_psaFileNames == NULL )
								strncpy(lpstrFileT, strTestName, m_ofn.nMaxFile);
							else
								m_psaFileNames->SetAt(iFile, strTestName);
							goto NextFile;
						}

					} while (*lpsz++ != '\0');
				}
			}
		}

		// "File does not exist"
		ErrorBox(ERR_File_NoExist, m_ofn.lpstrFile);
		free(lpstrFile);
		m_ofn.lpstrFile = lpstrFileT;
		m_ofn.nMaxFile = nMaxFileT;
		return TRUE;    // don't allow dialog to close

	NextFile: ;
	}

	free(lpstrFile);
	m_ofn.lpstrFile = lpstrFileT;
	m_ofn.nMaxFile = nMaxFileT;
	return FALSE;
}

void C3dFileDialog::UpdateMultiSelectOnNT(void)
{
	ASSERT( m_psaFileNames != NULL );
	ASSERT( m_bMultiSelectOnNT );
	
	// Because NT is a pain in the butt about long file names and 
	// multiple selection circumvent the CommDlg behavior, and do it 
	// ourselves by querying the listbox.  Note that the CommDlg 
	// behavior of only having the first file show up in the edit 
	// control will remain.  We take advantage of that to get a full path.
	POSITION pos = GetStartPosition();
	CString strFile = GetNextPathName(pos);
	char acDrive[_MAX_DRIVE];
	char acPath[_MAX_DIR];
	_splitpath(strFile, acDrive, acPath, NULL, NULL);
	CString strPath = acDrive;
	strPath += acPath;

	CString strEdit;
	GetDlgItemText(edt1, strEdit);
	BOOL bEditInList = strEdit.IsEmpty();   // if empty, then we're fine
	
	CListBox* pList = (CListBox*)GetDlgItem(lst1);
	ASSERT( pList != NULL );
	int nCount = pList->GetCount();
	while( --nCount >= 0 )
	{
		if( pList->GetSel(nCount) > 0 )
		{
			pList->GetText(nCount, strFile);
			if( strFile.CompareNoCase(strEdit) == 0 )
				bEditInList = TRUE;
			m_psaFileNames->Add(strPath + strFile);
		}
	}

	// if the filename in the edit field doesn't match any of the
	// ones selected in the listbox, then the edit field overrules.
	if( !bEditInList )
	{
		m_psaFileNames->RemoveAll();
		POSITION pos = GetStartPosition();
		while( pos != NULL )
			m_psaFileNames->Add(GetNextPathName(pos));
	}
}

BOOL C3dFileDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
	HWND hWndCtrl = (HWND)lParam;

	if (hWndCtrl != NULL)
	{
		// control notification
		if (!::IsWindow(hWndCtrl)) // work around COMDLG32 bug
			return FALSE;
	}

	return CFileDialog::OnCommand(wParam, lParam);
}

POSITION C3dFileDialog::GetFullFileStartPosition()
{
	return NULL;
}

CString C3dFileDialog::GetNextFullFileName(POSITION pos)
{
	static CString strPath;
	return strPath;
}

//      AppendFilterSuffix
//              Utility function for building file dialog filters.

void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	const CString& strFilterName, BOOL bSetDefExt)
{
	if (!strFilterName.IsEmpty())
	{
		// add to filter
		filter += strFilterName;
		ASSERT(!filter.IsEmpty());  // must have a file type name
		filter += (TCHAR)_T('\0');       // next string please

		// the filter name should be of the form "<Files string> (<Filter>)"
		// e.g. - "Source Files (*.c;*.cpp;*.cxx)"

		int nOpenParen = strFilterName.Find('(');
		int nCloseParen = strFilterName.Find(')');
		if( nOpenParen == -1 || nCloseParen == -1 )
			filter += _T("*.*");    // Bogus filter name.
		else
		{
			CString str = strFilterName.Mid(nOpenParen + 1,
				nCloseParen - nOpenParen - 1);

			// prepend * to each extension, if it isn't already there
			CString strStar;
			for( int n = 0; n < str.GetLength(); n++ )
			{
				if( str[n] == '.' )
					if( (n == 0) || (str[n - 1] != '*') )
						strStar += '*';
				strStar += str[n];
			}

			filter += strStar;
			if( bSetDefExt )
			{
				int nSemi = strStar.Find(';');
				if( nSemi >= 0 )
					strStar = strStar.Left(nSemi);
				static char acExt[_MAX_EXT];
				_splitpath(strStar, NULL, NULL, NULL, acExt);
				if( *acExt == '\0' || _tcschr(acExt, '*') != NULL || _tcschr(acExt, '?') != NULL )
					ofn.lpstrDefExt = NULL;
				else
				{
					ASSERT( *acExt == '.' );
					ofn.lpstrDefExt = acExt + 1;
				}
			}
		}

		filter += (TCHAR)_T('\0');       // next string please
		ofn.nMaxCustFilter++;
	}
}

void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	UINT idFilter, BOOL bSetDefExt /*= FALSE*/)
{
	CString strFilter;
	VERIFY(strFilter.LoadString(idFilter));

	AppendFilterSuffix(filter, ofn, strFilter, bSetDefExt);
}

/////////////////////////////////////////////////////////////////////////////

//Slightly friendlier names for the common dialog items.
#define DIRLIST         lst2
#define EDITFILE        edt1
#define DIRPATH         stc1
#define DRIVECOMBO      cmb2

CDirChooser* CDirChooser::pCurrentChooser = NULL;

extern HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);

CDirChooser::CDirChooser(LPCTSTR lpszOpenDir, LPCTSTR lpszTitle, LPCTSTR lpszPrompt, UINT nDlgID)
{
	if (nDlgID == 0)
		nDlgID = IDD_OPENDIR;

	m_dwHelpContext = IDD_DIR_PICKER;

	if (lpszTitle == NULL || *lpszTitle == _T('\0'))
		m_strTitle.LoadString(IDS_DEFAULTCHOOSERTITLE);
	else
		m_strTitle = lpszTitle;

	if (lpszPrompt == NULL || *lpszPrompt == _T('\0'))
		m_strPrompt.LoadString(IDS_DEFAULTCHOOSERPROMPT);
	else
		m_strPrompt = lpszPrompt;

	*m_szFileName = '\0';

	if (lpszOpenDir != NULL)
	{
		ASSERT(*lpszOpenDir != _T('\0'));
		::SetCurrentDirectory(lpszOpenDir);
		m_strCurDir = lpszOpenDir;
	}
	else
	{
		::GetCurrentDirectory(_MAX_PATH, m_strCurDir.GetBuffer(_MAX_PATH));
		m_strCurDir.ReleaseBuffer();
	}

	m_ofn.lStructSize               = sizeof(OPENFILENAME);
	m_ofn.hwndOwner                 = _SushiGetSafeOwner(NULL);
	m_ofn.hInstance                 = GetResourceHandle();
	m_ofn.lpstrFilter               = NULL;
	m_ofn.lpstrCustomFilter = NULL;
	m_ofn.nMaxCustFilter    = 0L;
	m_ofn.nFilterIndex              = 0;
	m_ofn.lpstrFile                 = m_szFileName;
	m_ofn.nMaxFile                  = sizeof(m_szFileName);
	m_ofn.lpstrFileTitle    = NULL;
	m_ofn.nMaxFileTitle             = 0;
	m_ofn.lpstrInitialDir   = NULL;
	m_ofn.lpstrTitle                = NULL;
	m_ofn.Flags                             = OFN_ENABLEHOOK | OFN_ENABLETEMPLATEHANDLE;
	m_ofn.nFileOffset               = 0;
	m_ofn.nFileExtension    = 0;
	m_ofn.lpstrDefExt               = NULL;
	m_ofn.lCustData                 = 0;
	m_ofn.lpfnHook                  = DirOpenHookProc;
	m_ofn.lpTemplateName    = MAKEINTRESOURCE(nDlgID);

	m_bMustExist = TRUE;
}

int CDirChooser::DoModal()
{
	// Only one chooser active at a time.
	ASSERT(pCurrentChooser == NULL);
	if (pCurrentChooser != NULL)
		return 0;

	{
		int fRet;

		pCurrentChooser = this;

		PreModalWindow();
		// allow OLE servers to disable themselves, usually called in CDialog::PreModal
		AfxGetApp()->EnableModeless(FALSE);
		
		C3dDialogTemplate dt;

		VERIFY( dt.Load( m_ofn.lpTemplateName ) );
		SetStdFont(dt);
		m_ofn.hInstance = (HINSTANCE) dt.GetTemplate();

		fRet = GetOpenFileName(&m_ofn);

	#ifdef DEBUGGING
		if (fRet == 0)
		{
			CommDlgExtendedError();
		}
	#endif

		AfxGetApp()->EnableModeless(TRUE);
		// Reset the dockmgr state since the dialog is now gone
		PostModalWindow();

		// Tell sushi the directory has changed, so title bars can be updated
		((CMainFrame*) theApp.m_pMainWnd)->OnDirChange();

		pCurrentChooser = NULL;

		return fRet;
	}
}

void CDirChooser::SetMustExist(BOOL bMustExist)
{
	m_bMustExist = bMustExist;
}

CString CDirChooser::GetPathName() const
{
	return m_strCurDir;
}

// Default semantics for dialog dismissal
// Can display text in hStatus
BOOL CDirChooser::fDismissOpenDir(const LPCSTR szNew, HWND)
{
	BOOL fReturn;
	fReturn = (m_strCurDir.Collate( szNew) == 0);   // Can close if selected twice
	m_strCurDir = szNew;
	return fReturn;
}

// FUTURE: rewrite all of this to use message maps instead of this hook stuff.
#define WM_DIRCHOOSERDIRCHNG (WM_USER + 1941)

// Hook for commdlg Open dialog box.
UINT APIENTRY CDirChooser::DirOpenHookProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static DWORD     dwMsgSelCh;
	char            szEditPath[_MAX_PATH];

	switch (msg)
	{
		// 26 Jun 96 - Set the context help for lst2 and cmb2
		// WM_HELP and WM_CONTEXTMENU handle the context help for the lst2 and cmb2 dialog items.
		case WM_HELP:
			{
				// F10 and Context help.

				// Handle the context help ourselves.
				// Create a CWnd for the dialog box.
				CWnd DlgWnd;
				DlgWnd.Attach(hDlg);

				// Call the context help helper functions in help.cpp.
				BOOL bResult = ::DoHelpInfo(&DlgWnd, pCurrentChooser->m_dwHelpContext, reinterpret_cast<HELPINFO*>(lParam));                              

				// Detach the window and return .
				DlgWnd.Detach() ;
				return bResult ;
			}
			break ;
		case WM_CONTEXTMENU:
			{
				// Right mouse button help.

				// Handle the context help ourselves.
				// Create a CWnd for the dialog box.
				CWnd DlgWnd;
				DlgWnd.Attach(hDlg) ;

				// Get Mouse coordinates
				CPoint pt(LOWORD(lParam),HIWORD(lParam)); 

				// Call the context help helper functions in help.cpp.
				::DoHelpContextMenu(&DlgWnd, pCurrentChooser->m_dwHelpContext, pt);
					
				// Detach the window and return .
				DlgWnd.Detach() ;
				return 1;
			}
			break ;
		case WM_INITDIALOG:
			dwMsgSelCh = ::RegisterMessage(LBSELCHSTRING);
			
			// Set the edit box prompt.             
			::SetWindowText(::GetDlgItem(hDlg, IDC_DIRPROMPT), pCurrentChooser->m_strPrompt);

			// Set the directory string from the current directory
			::SetWindowText(::GetDlgItem(hDlg, IDC_DIRNAME), pCurrentChooser->m_strCurDir);

			// Set the window title, the m_ofn entry for this doesn't seem to work
			::SetWindowText(hDlg, pCurrentChooser->m_strTitle);

			// During restart this dialog may be brought up, and NOT in the foreground.
			// Fix for: Dolphin #3390
			SetForegroundWindow( hDlg );

			// 26 Jun 96 - Set the context help for lst2 and cmb2
			::SetWindowContextHelpId(::GetDlgItem(hDlg, DIRLIST), HIDC_OPENDIR_DIRECTORIES) ;
			::SetWindowContextHelpId(::GetDlgItem(hDlg, DRIVECOMBO), HIDC_OPENDIR_DRIVES) ;

			if (theApp.m_bWin95 && pCurrentChooser->m_strCurDir.Find("\\\\") == 0)
			{
				CWaitCursor wc;

				CString strReset = pCurrentChooser->m_strCurDir;
				// on Win95, the tree will not be initialized for a UNC directory. we
				// force a couple of directory changes to make it initialize (gross!).
				HWND hwndEdit = ::GetDlgItem(hDlg, IDC_DIRNAME);

				::SetFocus(hwndEdit);
				// we want to change to a valid directory and back to force the update.
				if (GetDriveType("C:\\") == DRIVE_FIXED)
				{
					// most machines have C: as a fixed disk, so use that.
					::SetWindowText(hwndEdit, "C:\\");
				}
				else
				{
					// machines without C: as a fixed disk have A: fixed (NEC machines).
					::SetWindowText(hwndEdit, "A:\\");
				}
				pCurrentChooser->m_strCurDir.Empty();
				::SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDOK, IDC_DIRNAME), (LPARAM)hwndEdit);

				::SetFocus(hwndEdit);
				::SetWindowText(hwndEdit, strReset);
				pCurrentChooser->m_strCurDir.Empty();
				::SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDOK, IDC_DIRNAME), (LPARAM)hwndEdit);
			}

			return TRUE;

		case WM_COMMAND:
			switch (LOWORD(wParam))
			{
				case ID_HELP:
					theApp.HelpOnApplication(pCurrentChooser->m_dwHelpContext);
					break;
				case IDOK:
				{
					HWND hwndFocus = ::GetFocus();
					HWND hwndEdit = ::GetDlgItem(hDlg, IDC_DIRNAME);
					HWND hwndOK = ::GetDlgItem(hDlg, IDOK);
					HWND hwndList = ::GetDlgItem(hDlg, DIRLIST);

					if (hwndFocus == hwndList)
					{
						if (theApp.m_bWin95)
						{
							// on Win95, directory changes from a UNC root are not
							// reflected in the directory editbox unless we do this.
							::PostMessage(hDlg, WM_DIRCHOOSERDIRCHNG, 0, 0);
						}
						return 0;       // call the default handler
					}

					if( (hwndFocus != hwndEdit) && (hwndFocus != hwndOK) )
						return 0;       // call the default handler

					CWaitCursor wc;

					::GetCurrentDirectory(sizeof(szEditPath), szEditPath);
					CString strCurDir = szEditPath;

					// Find the path entered by the user
					::GetWindowText(hwndEdit, szEditPath, sizeof(szEditPath));

					// set the current directory to whatever the user typed
					// if they typed a non-existent directory, back up until we 
					// find one that exists
					CString strEdit = szEditPath;
					BOOL bDirExists = TRUE;
					int nBack = -1;
					while( !strEdit.IsEmpty() && !::SetCurrentDirectory(strEdit) )
					{
						bDirExists = FALSE;
						nBack = strEdit.ReverseFind('\\');
						if( nBack < 0 )
							break;
						strEdit = strEdit.Left(nBack);
						if( (nBack == 2) && isalpha(strEdit[0]) && (strEdit[1] == ':') )
						{
							strEdit += '\\';        // change "c:" to "c:\"
							nBack = 3;
							if( !::SetCurrentDirectory(strEdit) )
								nBack = 0;
							break;          // if we don't break here, we're libel to get into an endless loop
						}
					}
					if( bDirExists )
					{
						// directory does exist, and is now the current one
						::GetCurrentDirectory(sizeof(szEditPath), szEditPath);
						strEdit = szEditPath;
					}
					else if( nBack > 0 ) 
					{
						// directory doesn't exist, but a parent directory does
						// generate full name based off of confirmed parent directory
						strEdit = szEditPath + nBack;
						::GetCurrentDirectory(sizeof(szEditPath), szEditPath);
						strEdit = szEditPath + strEdit;

						// The attempt to find a partial directory has changed
						// the current directory.  Change it back.
						::SetCurrentDirectory(strCurDir);
					}
					else
					{
						// directory doesn't exist at all, so just complain about it
						strEdit = szEditPath;
					}

					// The virtual fDismissOpenDir function is called here to check if we can
					// dismiss from this directory.
					if (pCurrentChooser->fDismissOpenDir(strEdit, ::GetDlgItem (hDlg, IDC_OPENDIR_STATUS)))
					{
						::PostMessage(hDlg, WM_COMMAND, IDABORT, IDOK);
					}
					else
					{
						::SetWindowText(::GetDlgItem(hDlg, EDITFILE), strEdit);
						::SetWindowText(::GetDlgItem(hDlg, IDC_DIRNAME), strEdit);
						::PostMessage(::GetDlgItem(hDlg, IDC_DIRNAME), EM_SETSEL, 0,-1);

						if( !bDirExists )
						{
							if( pCurrentChooser->m_bMustExist )
							{
								CString str;
								::MsgBox(Error, ::MsgText(str, ERR_Change_Directory, strEdit));
								pCurrentChooser->m_strCurDir = "";
							}

							return 1; // Don't call the default handler.
						}
					}
					break;
				}
				case DIRLIST:
					if (HIWORD(wParam) == LBN_DBLCLK)
					{
						if (theApp.m_bWin95)
						{
							// on Win95, directory changes from a UNC root are not
							// reflected in the directory editbox unless we do this.
							::PostMessage(hDlg, WM_DIRCHOOSERDIRCHNG, 0, 0);
						}
						return 0;       // call the default handler
					}
					break;
			}
			break;

		case WM_COMMANDHELP:
			theApp.HelpOnApplication(pCurrentChooser->m_dwHelpContext);
			::SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
			return TRUE;

		case WM_DIRCHOOSERDIRCHNG:
		{
		//	TRACE0("CDirChooserDlg received WM_DIRCHOOSERDIRCHNG message.\n");
			CString strActualDir;
			strActualDir.Empty();
			int nIndex = ::SendMessage(::GetDlgItem(hDlg, DIRLIST), LB_GETCURSEL, 0, 0);
			for (int i = 0; i <= nIndex; i++)
			{
				TCHAR szDirName[_MAX_PATH];
				::SendMessage(::GetDlgItem(hDlg, DIRLIST), LB_GETTEXT, i, (LPARAM)(LPCTSTR)szDirName);
				if (!strActualDir.IsEmpty())
					strActualDir += "\\";
				strActualDir += szDirName;
			}

			if (strActualDir.Find("\\\\") == 0)
			{
				// changing the editbox is only necessary if the path is UNC.
				::SetWindowText(::GetDlgItem(hDlg, IDC_DIRNAME), strActualDir);
				::SendMessage(::GetDlgItem(hDlg, IDC_DIRNAME), EM_SETSEL, 0,-1);

				if (pCurrentChooser->fDismissOpenDir(strActualDir, ::GetDlgItem(hDlg, IDC_OPENDIR_STATUS)))
					::PostMessage(hDlg, WM_COMMAND, IDABORT, IDOK);
			}
			return TRUE;
		}

		default:
			if ( (msg = dwMsgSelCh) && 
				 ( (LOWORD(wParam) == DIRLIST) || (LOWORD(wParam) == DRIVECOMBO) ) && 
				 (HIWORD(lParam) == CD_LBSELCHANGE) )
			// Check that selection change is from Drive or Directory list to avoid
			// Calls to the fDismissOpenDir due to the (hidden) file list box.
			{
				// LBSELCH message  to the Directory list or drive combo
				::GetCurrentDirectory(sizeof(szEditPath), szEditPath);
				::SetWindowText(::GetDlgItem(hDlg, IDC_DIRNAME), szEditPath);
				::SetWindowText(::GetDlgItem(hDlg, EDITFILE), szEditPath);
				::SendMessage(::GetDlgItem(hDlg, IDC_DIRNAME), EM_SETSEL, 0,-1);
				
				// There is a bogusness in CommDlg, that when a user hits 
				// enter twice in a row, the second CD_LBSELCHANGE message 
				// claims to come from the DRIVECOMBO (which is also the
				// everywhere-else bin).  This works around that.
				BOOL bDirList = (LOWORD(wParam) == DIRLIST) ||
					(::GetFocus() == ::GetDlgItem(hDlg, DIRLIST));

				// The virtual fDismissOpenDir function is called here to check if we can dismiss
				// only call if the change came from the directory list
				if ( bDirList && pCurrentChooser->fDismissOpenDir(szEditPath, ::GetDlgItem (hDlg, IDC_OPENDIR_STATUS) ))
				{
					::PostMessage(hDlg, WM_COMMAND, IDABORT, IDOK);
				}
			}
			break;
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////

CFileFindDlg::CFileFindDlg(LPCTSTR lpszFileToFind, LPCTSTR lpszOpenDir,
		LPCTSTR lpszTitle, LPCTSTR lpszPrompt)
	: CDirChooser(lpszOpenDir, lpszTitle, lpszPrompt)
{
	m_strFileToFind = lpszFileToFind;
	m_dwHelpContext = IDD_DIR_FINDFILE;
	m_pfnValidator = NULL;
}

void CFileFindDlg::SetValidator(LPFNFILEFINDVALIDATOR pfnValidator, LONG lparam) {
	
	m_pfnValidator = pfnValidator;
	m_lValidatorParam = lparam;
}

// fDismissOpenDir returns TRUE if the dialog can be dismissed:
//              szNew is the path when OK is hit or the directory list box selection
//              is chosen.
// Sometimes posts a message in the hStatus.
// This function *must* update m_strCurDir to be a copy of szNew.
BOOL CFileFindDlg::fDismissOpenDir(const LPCSTR szNew, HWND hStatus)
{
// There's been some amount of disagreement over the best UI here.
// Some people think we should check each directory we land in, to see if the
// file we want is there, and then return immediately.
// Others think that we should act like CommDlg, and if the user changes
// directories, they may just be navigating somewhere, so make them enter twice.
// Removing the #if 0 code here would do the latter.
#if 0
	// the user must always select a directory twice, to say they mean it.
	if( !CDirChooser::fDismissOpenDir(szNew) )
		return FALSE;

	// only then do me verify that the file is really there.
#endif

	CDir    dir;
	CPath   path;
	BOOL	 fFound;

	m_strCurDir = szNew;
	
	if ((fFound = dir.CreateFromString(szNew) &&
		path.CreateFromDirAndFilename(dir, m_strFileToFind) &&
		path.ExistsOnDisk())) {

		m_strStatusMessage.Empty();

	} else {

		// Not found, so we let the user know.
		m_strStatusMessage.LoadString (IDS_OPENDIR_STATUS_NOFILE);
	}

	if (fFound && m_pfnValidator) {
		fFound = (*m_pfnValidator) (szNew, m_strFileToFind, m_lValidatorParam);
		if (!fFound) {
			m_strStatusMessage.LoadString (IDS_OPENDIR_STATUS_WRONGFILE);
		}
	}
	
	if (!::SetWindowText (hStatus, m_strStatusMessage)) {
		DWORD dw = GetLastError();
	}
	return fFound;
}



///////////////////////////////////////////////////////////////////////////////
//      Modal window utility functions

BOOL fProjectWindowLocked = FALSE;
LPPROJECTWORKSPACEWINDOW pProject = NULL;
int nLevels = 0;

void PreModalWindow()
{
	// Destroy the splash screen before showing modal window.
	ShowSplashScreen(FALSE);

    // Hide sprites so they paint correctly when dialog goes away.
    CSlobWnd* pWnd = GetActiveSlobWnd();
    if (pWnd != NULL)
	pWnd->ObscureSprites(TRUE);

	CDockWorker::LockWorker();

	if (nLevels == 0)
	{
		theApp.FindInterface(IID_IProjectWorkspaceWindow, (LPVOID FAR *)&pProject);

		// DevStudio 96 BUG #5645
		// The output window change close while the printing dialog is up
		// when we switch from Debug to non-Debug causing an access violation.
		// Lock the dock state so the windows don't change.
		CMainFrame* pFrame = (CMainFrame*)theApp.m_pMainWnd ;
		ASSERT(pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));
		pFrame->LockDockState(TRUE);
	}


	nLevels++;

	if (pProject != NULL)
	{
		if (pProject->IsWindowLocked() == S_OK)
		{
			pProject->PreModalWindow();
			fProjectWindowLocked = TRUE;
		}
	}
}

void PostModalWindow()
{
	// DevStudio 96 BUG #5645
	// The output window change close while the printing dialog is up
	// when we switch from Debug to non-Debug causing an access violation.
	// Lock the dock state so the windows don't change.
	if (nLevels == 1) 
	{
		CMainFrame* pFrame = (CMainFrame*)theApp.m_pMainWnd ;
		ASSERT(pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMainFrame)));
		pFrame->LockDockState(FALSE);
	}

	// If we came from a floating palette, then we need to restore focus.
	CDockWorker* pDocker = CDockWorker::s_pActiveDocker;
	if (pDocker != NULL && pDocker->GetDock() == dpNil)
		pDocker->m_pWnd->SetFocus();

	nLevels--;

	if (pProject != NULL)
	{
		if (fProjectWindowLocked == TRUE)
		{
			pProject->PostModalWindow();
			fProjectWindowLocked = FALSE;
		}

		if (nLevels == 0)
		{
			pProject->Release();
			pProject = NULL;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\custprxy.h ===
#ifndef _custprxy_h
#define _custprxy_h

#include "barprxy.h"

class CCustomBar;

///////////////////////////////////////////////////////////////////////////////
// CCustomBarProxy
// This class implements the bar proxy on top of a CCustomBar.
class CCustomBarProxy : public CToolBarProxy
{
public:
	// Attach the proxy to a CCustomBar.
	void AttachBar(CCustomBar* pBar);

// CToolBarProxy methods.

	// Use these to work with the underlying "real" objects.
	virtual CWnd* GetWindow();

	// "Bar" states.
    virtual BOOL IsInDialog();
	virtual UINT GetExpansionConstraint(const CRect &expand, ORIENTATION *orBar=NULL);
	virtual int GetCount() const;
	virtual DWORD GetBarStyle() const;
	virtual const CSize GetButtonSize() const;
	virtual const CSize GetImageSize() const;
	virtual HBITMAP GetImageWell(int nIndex);
	virtual int GetImageIndex(int nIndex) const;
	// TRUE if this bar is using large buttons
	virtual BOOL HasLargeButtons() const;

	// Interact with items states.
	virtual UINT GetButtonStyle(int nIndex) const;
	virtual BOOL IsStaticItem(int nIndex);
	virtual BOOL IsGapItem(int nIndex);
	virtual const CString& GetButtonText(int nIndex) const;
	virtual HWND GetButtonControl(int nIndex) const;
	virtual HBITMAP GetButtonImage(int nIndex) const;
	virtual void SetButtonControl(int nIndex, HWND hControl);
	virtual void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	virtual void GetButtonInfoEx(int nIndex, HWND& hControl, CString& rText, HBITMAP& hImage) const;
	virtual int GetButtonCmdID(int nIndex);
	virtual BOOL HasExInfo(int nIndex) const;
	// call this when the button has been modified to mark the bar dirty and possibly redraw (if bSized==TRUE)
	virtual void ButtonModified(int nIndex, BOOL bSized);
	// Removes a separator before a button
	virtual void RemoveSeparator(int iButton);
	// Inserts a separator before a button
	virtual void InsertSeparator(int iButton);
	// returns true if the item is a control, and is currently visible
	virtual BOOL IsVisibleControl(int iButton);
	// returns if the specified button can be shown with text
	virtual APPEARANCEOPTION CanText(int iButton);
	// returns if the specified button can be shown with a glyph
	virtual APPEARANCEOPTION CanGlyph(int iButton);
	// returns any limitations on the appearance of a given button style 
	virtual APPEARANCEOPTION CanText(UINT nStyle);
	// returns any limitations on the appearance of a given button style
	virtual APPEARANCEOPTION CanGlyph(UINT nStyle);
	// returns the appearance of a button
	virtual APPEARANCE GetAppearance(int iButton);
	// returns the default appearance of a button
	virtual APPEARANCE GetAppearance();
	// returns the appearance of a button of a given type when placed in this kind of container. If these display components
	// are not available, the custom button dialog will appear
	virtual APPEARANCE GetInitialAppearance(UINT nStyle);
	// allocates or returns an individual glyph bitmap for a given button
	virtual HBITMAP CreateSingleBitmap(int iButton);
	// always call this function if the one above returns non-null. Do not delete hbmSingle yourself, since it
	// may still be in use elsewhere
	virtual void DestroySingleBitmap(int iButton, HBITMAP hbmSingle);
	virtual BOOL ExpandDestination(int nCmdIDSrc, int nIndexDest);

	// Operations
	virtual int InsertButton(int nIndex, TRANSFER_TBBUTTON& trans, BOOL bReplace, GAP gap);
	virtual void DeleteButton(int nIndex, BOOL bMoving = FALSE);
    virtual void RecalcLayout(UINT nHTSize = HTRIGHT);
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const;
	virtual int IndexFromPoint(const CPoint& pt, CRect *pButtonRect=NULL) const;
	virtual int HitTest(CPoint point) const;
	virtual CToolBarProxy* NewBar(UINT nID, const CPoint& rect);
	virtual void GetButtonTransferInfo(int nIndex, DWORD& dwData, TRANSDATA_CALLBACK* lplpDataCallback) const;
	virtual BOOL CanChooseAppearance();
	virtual BOOL CanPasteImage();
	virtual BOOL CanResetImage();
	virtual void PasteButtonImage();
	virtual void ResetButtonImage();
	virtual ORIENTATION GetOrient() const;
	// adds text to the button
	void AddText(int nIndex); // default menu text
	void AddText(int nIndex, const CString &text, BOOL bCustom);
	// add or replace the bitmap of a button.
	void AddBitmap(int nIndex, BITMAPSOURCE bsSource=cBitmapSourcePackage, HBITMAP hbmCustom=NULL);
	// remove the label from a glyph+label button
	void RemoveText(int nIndex);
	// remove the glyph from a glyph+label button
	void RemoveBitmap(int nIndex);
	// remove all items from the bar
	virtual void Empty(void);
	// returns the next visible item after the specified one. nIndex==-1 gets the first visible item
	virtual int FindNextVisibleItem(int nIndex, BOOL bForward);

	virtual void BatchBegin(int nCount=0);
	virtual void BatchAdd(int nIndex, int nID, UINT nStyle, int nExtra, HBITMAP hGlyph, const CString &name);
	virtual void BatchEnd();

	// Notifications
	virtual void OnSelChange(int nIndex);
	virtual void OnDeleteSelection();
	virtual void OnBarActivate();
	virtual void OnButtonSize();
	virtual void OnButtonMove(int nIndex);

protected:
	virtual void* _GetRealObject();

private:
	CCustomBar* m_pBar;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dllinit.cpp ===
#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

HINSTANCE GetResourceHandle()
{
	return extensionDLL.hModule;
}

extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DisableThreadLibraryCalls(hInstance);

		// NOTE: global/static constructors have already been called!
		// Extension DLL one-time initialization - do not allocate memory here,
		//   use the TRACE or ASSERT macros or call MessageBox
		if (!AfxInitExtensionModule(extensionDLL, hInstance))
			return 0;

		// This adds our DLL to the MFC maintained list of "AFX
		// Extension DLLs" which is used by serialization functions
		// and resource loading...  This will be deleted by MFC in
		// the AfxTermExtensionModule function.
		new CDynLinkLibrary(extensionDLL);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		// Terminate the library before destructors are called
		AfxTermExtensionModule(extensionDLL);
	}

	return TRUE;   // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dockman.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  DOCKMAN.CPP
//      Contains most of the general dock managenment code for a CFrameWnd,
//      implemented in two classes: CDockWorker, and CDockManager.
//      See also DOCKWNDS, and DOCKAPI.
///////////////////////////////////////////////////////////////////////////////

// Implementation of embedded toolbars. Because we don't have time to implement a full-blown embedded toolbar,
// we're making an embedded toolbar a pseudo-docking window.

#include "stdafx.h"

#include "shell.h"
#include "resource.h"
#include "dockman.h"
#include "barbdr.h"
#include "bardockx.h"
#include "bardlgs.h"
#include "about.h"
#include "prxycust.h"

//[multimon] 11 mar 97 - der
#include "mmonitor.h"

IMPLEMENT_SERIAL(CDockWorker, CObject, 1);
IMPLEMENT_SERIAL(CDockManager, CObject, 1)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Worker messages

UINT DMM_CHILDSETFOCUS = RegisterMessage("DockManChildSetFocus");
UINT DMM_CHILDKILLFOCUS = RegisterMessage("DockManChildKillFocus");
UINT DMM_NCLBUTTONDOWN = RegisterMessage("DockManNcLButtonDown");
UINT DMM_NCLBUTTONDBLCLK = RegisterMessage("DockManNcLButtonDblClk");

// Value of s_nInsertTolerance when insertion is allowed/disallowed
static const int s_cnAllowInsert=4;
static const int s_cnDisallowInsert=0;

// current insert tolerance
int CDockWorker::s_nInsertTolerance=s_cnDisallowInsert;


///////////////////////////////////////////////////////////////////////////////
//  CDockWorker
//      The dock worker is the odject that does most of the work for
//      a dockable HWND.  All DMM_* eventually end up here, and most of
//      docking information for a dockable HWND is stored in this object.
//

static int DkCompareIDs(UINT nID1, UINT nID2)
{
	if (LOWORD(nID1) > LOWORD(nID2))
		return 1;
	else if (LOWORD(nID1) < LOWORD(nID2))
		return -1;
	else if (HIWORD(nID1) > HIWORD(nID2))
		return 1;
	else if (HIWORD(nID1) < HIWORD(nID2))
		return -1;

	return 0;
}

CWnd* g_pActivePopup = NULL;

// Really sizes (point for compatibility with MINMAXINFO).
CPoint CDockWorker::GetDefMin(void)
{
	return CPoint(g_mt.cxToolCapButton+g_mt.cxToolCapBorder, g_mt.cyToolCapButton+g_mt.cyToolCapBorder);
}

CPoint CDockWorker::s_ptDefMax(500, 500);

LPCSTR CDockWorker::s_lpszLayoutSection = NULL;

BOOL CDockWorker::s_bLockDocker = FALSE;
CDockWorker* CDockWorker::s_pActiveDocker = NULL;

//	CDockWorker::CDockWorker
//		Construction.  For deserialization.

CDockWorker::CDockWorker()
{
	m_bAvailable = FALSE;
	m_bMDIBound = FALSE;
	m_bLoading = TRUE;
	m_pWnd = NULL;
	m_hglobInit = NULL;
	m_pDeskPlace = NULL;
	m_pDockPlace = NULL;
	m_pDockSerial = NULL;
}

#ifdef _DEBUG
static void DebugCheckDockID(UINT nID, DOCKTYPE dt)
{
	// Make sure things are in the right ranges.
	WORD wPkg = HIWORD(nID);
	WORD wID = LOWORD(nID);

	// Note: we have a few historical hacks for the project and edit toolbars.
	if ((wPkg == PACKAGE_SUSHI && wID != 0x75FF) ||
		(wPkg == PACKAGE_VPROJ && wID == IDTB_PROJECT))
	{
		if (dt == dtToolbar || dt == dtEmbeddedToolbar)
			ASSERT(wID >= IDTB_CUSTOM_BASE ||
				(wID >= IDTB_SHELL_BASE && wID <= IDTB_SHELL_MAX));
		else if (dt == dtEdit)
			ASSERT(wID >= IDDW_SHELL_BASE && wID <= IDDW_SHELL_MAX);
		else
			ASSERT((wID >= IDDW_SHELL_BASE && wID <= IDDW_SHELL_MAX) ||
				(wID >= IDTB_SHELL_BASE && wID <= IDTB_SHELL_MAX));
	}
	else
	{
		if (dt == dtToolbar || dt == dtEmbeddedToolbar)
			ASSERT(wID >= IDTB_PACKAGE_BASE && wID <= IDTB_PACKAGE_MAX);
		else if (dt == dtEdit) 
			ASSERT(wID >= IDDW_PACKAGE_BASE && wID <= IDDW_PACKAGE_MAX);
		else
			ASSERT((wID >= IDTB_PACKAGE_BASE && wID <= IDTB_PACKAGE_MAX) ||
				(wID >= IDDW_PACKAGE_BASE && wID <= IDDW_PACKAGE_MAX));
	}
}
#endif

//	CDockWorker::Serialize
//		Load/Save of dock worker to disk.

void CDockWorker::Serialize(CArchive& ar)
{
	DWORD fwInit;

	if (ar.IsStoring())
	{
		BOOL bTempMDIInfo = FALSE, bTempDockInfo = FALSE;
		if (m_pWnd != NULL)
		{
			if (m_bMDIBound)
			{
				if (IsVisible())
				{
					bTempMDIInfo = TRUE;
					SaveMDIPos();
				}
			}
			else if (m_dp == dpNil || m_dp==dpEmbedded)
			{
				SaveFloatPos();
			}
			else if (IsVisible())
			{
				bTempDockInfo = TRUE;
				SaveDockPos(FALSE);	// Absolute position.
				SaveDockPos(TRUE);	// Relative position.
			}
		}

		fwInit = m_bCanHorz ? INIT_CANHORZ : 0;
		fwInit |= m_bCanVert ? INIT_CANVERT : 0;
		fwInit |= m_bPosition ? INIT_POSITION : 0;
		fwInit |= (m_bVisible && m_dp!=dpEmbedded) ? INIT_VISIBLE : 0;
		fwInit |= m_bTranspose ? INIT_TRANSPOSE_SIZE : 0;
		fwInit |= m_bAsk ? INIT_ASKAVAILABLE : 0;
		fwInit |= m_bLastAvailable ? INIT_LASTAVAILABLE : 0;
		fwInit |= m_bDestroyOnHide ? 0 : INIT_NODESTROY;
		fwInit |= m_bAvailable ? INIT_AVAILABLE : 0;
		fwInit |= m_bMDIBound ? INIT_MDI : 0;
		fwInit |= (m_pDeskPlace != NULL) ? INIT_DESKPLACE : 0;
		fwInit |= (m_pDockPlace != NULL) ? INIT_DOCKPLACE : 0;
		fwInit |= (m_pDockSerial != NULL) ? INIT_DOCKSERIAL : 0;
		fwInit |= m_bHost ? INIT_HOST : 0;

		ar << m_strTitle <<	fwInit << (WORD) m_dtWnd << (WORD) m_dp
			<< (WORD) m_nIDPackage << (WORD) m_nIDPacket
			<< (WORD) m_nIDWnd << m_rectFloat << m_sizeLastStretch << m_nIDAssociate;

		if (m_pDockSerial != NULL)
		{
			ar.Write(m_pDockSerial, sizeof(DOCKPLACEMENT));
			delete m_pDockSerial;
			m_pDockSerial = NULL;
		}

		if (m_pDockPlace != NULL)
		{
			ar.Write(m_pDockPlace, sizeof(DOCKPLACEMENT));
			if (bTempDockInfo)
			{
				delete m_pDockPlace;
				m_pDockPlace = NULL;
			}
		}

		if (m_pDeskPlace != NULL)
		{
			ar.Write(m_pDeskPlace, sizeof(DESKPLACEMENT));
			if (bTempMDIInfo)
			{
				delete m_pDeskPlace;
				m_pDeskPlace = NULL;
			}
		}
	}
	else
	{
		WORD wdt, wdp, wIDGroup, wIDPart, wIDWnd;

		ar >> m_strTitle >>	fwInit >> wdt >> wdp
			>> wIDGroup >> wIDPart >> wIDWnd
			>> m_rectFloat >> m_sizeLastStretch >> m_nIDAssociate;

		m_dtWnd = (DOCKTYPE) wdt;
		m_dp = (DOCKPOS) wdp;

		// REVIEW(BrendanX): Remove this the next time we redo default layouts.
		if (wIDGroup == PACKAGE_SUSHI && wIDWnd == 0x75FF)
			wIDGroup = PACKAGE_VCPP;

		m_nIDPackage = wIDGroup;
		m_nIDPacket = wIDPart;
		m_nIDWnd = MAKEDOCKID(wIDGroup, wIDWnd);

		m_bCanHorz = ((fwInit & INIT_CANHORZ) != 0);
		m_bCanVert = ((fwInit & INIT_CANVERT) != 0);
		m_bPosition = ((fwInit & INIT_POSITION) != 0);
		m_bVisible = ((fwInit & INIT_VISIBLE) != 0);
		m_bTranspose = ((fwInit & INIT_TRANSPOSE_SIZE) != 0);
		m_bAsk = ((fwInit & INIT_ASKAVAILABLE) != 0);
		m_bLastAvailable = ((fwInit & INIT_LASTAVAILABLE) != 0);
		m_bDestroyOnHide = ((fwInit & INIT_NODESTROY) == 0);
		m_bAvailable = m_bAsk ? ((fwInit & INIT_AVAILABLE) != 0) : TRUE;
		m_bMDIBound = ((fwInit & INIT_MDI) != 0);
		m_bHost=((fwInit & INIT_HOST) != 0);

		if ((fwInit & INIT_DOCKSERIAL) != 0)
		{
			m_pDockSerial = new DOCKPLACEMENT;
			ar.Read(m_pDockSerial, sizeof(DOCKPLACEMENT));
		}

		if ((fwInit & INIT_DOCKPLACE) != 0)
		{
			m_pDockPlace = new DOCKPLACEMENT;
			ar.Read(m_pDockPlace, sizeof(DOCKPLACEMENT));
		}

		if ((fwInit & INIT_DESKPLACE) != 0)
		{
			m_pDeskPlace = new DESKPLACEMENT;
			ar.Read(m_pDeskPlace, sizeof(DESKPLACEMENT));
		}

#ifdef _DEBUG
		DebugCheckDockID(m_nIDWnd, m_dtWnd);
#endif
	}
}

//	CDockWorker::CDockWorker
//		Construction.  Initialized with DOCKINIT, and not from disk.

CDockWorker::CDockWorker(DOCKINIT FAR* lpdi)
{
	ASSERT(lpdi != NULL);
	ASSERT(HIWORD(lpdi->nIDPackage) == 0);
	ASSERT(HIWORD(lpdi->nIDWnd) == 0);

	m_strTitle = lpdi->szCaption;

    if (!(m_bPosition = (lpdi->fInit & INIT_POSITION) != 0))
		m_rectFloat = lpdi->rectFloat;
	if ((lpdi->fInit & INIT_STRETCHSIZE) != 0)
		m_sizeLastStretch = lpdi->sizeStretch;
	else
	{
		m_sizeLastStretch.cx = DEFAULT_STRETCH_WIDTH;
		m_sizeLastStretch.cy = DEFAULT_STRETCH_HEIGHT;
	}

    m_bCanHorz = (lpdi->fInit & INIT_CANHORZ) != 0;
    m_bCanVert = (lpdi->fInit & INIT_CANVERT) != 0;
	m_bMDIBound = (lpdi->fInit & INIT_MDI) != 0;
    m_bVisible = (lpdi->fInit & INIT_VISIBLE) != 0;
	m_bTranspose = (lpdi->fInit & INIT_TRANSPOSE_SIZE) != 0;
	m_bAsk = (lpdi->fInit & INIT_ASKAVAILABLE) != 0;
	// INIT_AVAILABLE  was previously unimplemented for inital usage, for some reason
	m_bAvailable = (!m_bAsk) || ((lpdi->fInit & INIT_AVAILABLE) != 0);
	m_bLastAvailable = (lpdi->fInit & INIT_LASTAVAILABLE) != 0;
	m_bDestroyOnHide = (lpdi->fInit & INIT_NODESTROY) == 0;
    m_bLoading = FALSE;
    m_dtWnd = lpdi->dt;
    m_dp = lpdi->dpInit;
    m_nIDPackage = lpdi->nIDPackage;
	m_nIDPacket = lpdi->nIDPacket;
    m_nIDWnd = MAKEDOCKID(lpdi->nIDPackage, lpdi->nIDWnd);
    m_pWnd = NULL;
	m_hglobInit = NULL;
	m_pDeskPlace = NULL;
	m_pDockPlace = NULL;
	m_pDockSerial = NULL;
	m_bHost=FALSE;
	m_nIDAssociate=0;

#ifdef _DEBUG
	DebugCheckDockID(m_nIDWnd, m_dtWnd);
#endif
}

//	CDockWorker::Reset
//		If a Package registers a DockWorker that we have not yet
//		created, we should trust it for some of the data.

void CDockWorker::Reset(DOCKINIT FAR* lpdi)
{
	ASSERT(lpdi != NULL);

	m_strTitle = lpdi->szCaption;
    m_bCanHorz = (lpdi->fInit & INIT_CANHORZ) != 0;
    m_bCanVert = (lpdi->fInit & INIT_CANVERT) != 0;
	m_bAsk = (lpdi->fInit & INIT_ASKAVAILABLE) != 0;
	m_bLastAvailable = (lpdi->fInit & INIT_LASTAVAILABLE) != 0;
	m_bDestroyOnHide = (lpdi->fInit & INIT_NODESTROY) == 0;
    m_dtWnd = lpdi->dt;
    m_nIDPackage = lpdi->nIDPackage;
	m_nIDPacket = lpdi->nIDPacket;
    m_nIDWnd = MAKEDOCKID(lpdi->nIDPackage, lpdi->nIDWnd);

	if (m_hglobInit != NULL)
	{
		::GlobalFree(m_hglobInit);
		m_hglobInit = NULL;
	}
}

//	CDockWorker::Reset
//		Used during CDockManager::Create to update workers in the new
//		manager with information from the old.

void CDockWorker::Reset(CDockWorker* pDockerOld)
{
	ASSERT_VALID(pDockerOld);

	// MDI state is transfered across managers, but if the state is changing
	// we do not want to take dock position information to be taken literally
	// during creation.  A lot may have changed since we last had valid info
	// for the dock.
	//
	DOCKPOS dp = pDockerOld->GetDock();

	// If we were embedded, we still are.
	if(dp==dpEmbedded)
	{
		m_dp=dpEmbedded;
	}

	if (m_bMDIBound != pDockerOld->m_bMDIBound)
	{
		m_bLoading = FALSE;
		m_bMDIBound = pDockerOld->m_bMDIBound;
	}

	// MDI windows and embedded bars do not change visibility during a layout switch
	if (m_bMDIBound || dp==dpEmbedded)
		m_bVisible = pDockerOld->m_bVisible;

	if (dp == dpNil || (dp == dpMDI && pDockerOld->IsVisible()))
	{
		// Note: Doing a DeparentWindow here for docked windows
		//       would be expensive.

		if (dp == GetDock())
			pDockerOld->DeparentWindow(NULL, m_pManager);
		else
			pDockerOld->DeparentWindow(m_pManager->GetDock(dpHide));
	}

	m_strTitle = pDockerOld->m_strTitle;	// Don't change text across layouts.
//	m_sizeLastStretch = pDockerOld->m_sizeLastStretch;
	m_rectFloat = pDockerOld->m_rectFloat;

	ASSERT(m_pWnd == NULL);	// Otherwise we leak.
	m_pWnd = pDockerOld->m_pWnd;
	pDockerOld->m_pWnd = NULL;
	ASSERT(m_hglobInit == NULL);	// Otherwise we leak.
	m_hglobInit = pDockerOld->m_hglobInit;
	pDockerOld->m_hglobInit = NULL;

	delete m_pDeskPlace;
	m_pDeskPlace = pDockerOld->m_pDeskPlace;
	pDockerOld->m_pDeskPlace = NULL;

	if (CDockWorker::s_pActiveDocker == pDockerOld)
		CDockWorker::s_pActiveDocker = this;
}

//	CDockWorker::PreTransfer
//		Called for workers during a manager change when a worker with
//		the same ID does not exist in new manager.

void CDockWorker::PreTransfer(CDockManager* pManagerNew)
{
	DOCKPOS dp = GetDock();
	if (dp == dpNil || (dp == dpMDI && IsVisible()))
		DeparentWindow(NULL, pManagerNew);

	// Dock placement info is manager specific.
	delete m_pDockPlace;
	m_pDockPlace = NULL;
	delete m_pDockSerial;
	m_pDockSerial = NULL;

	// Default for new dockables in full screen mode is to be hidden.
	if (DkGetDockState() & MASK_FULLSCREEN)
		m_bVisible = FALSE;
}

//	CDockWorker::Create
//		Makes sure we have a window for the dock worker, and correctly places
//		it within the docks.

BOOL CDockWorker::Create(CDockManager* pManager, CWnd* pOwner /*=NULL*/,
	BOOL bForceVisible /*=FALSE*/)
{
	ASSERT(pManager != NULL);
    m_pManager = pManager;
    m_bVisible = m_bVisible || bForceVisible;

	// If we are already have window in a floating or MDI window,
	// then we are done.
	CWnd* pParent;
	if (m_pWnd != NULL && (pParent = m_pWnd->GetParent()) != NULL)
	{
		if(	m_dp==dpEmbedded)
		{
			return TRUE;
		}

		if (pParent->IsKindOf(RUNTIME_CLASS(CPaletteWnd)))
			return TRUE;

		if (pParent->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
		{
			// MDI windows don't get hidden.
			if (!IsVisible())
				DeparentWindow();
			return TRUE;
		}
	}

    if (m_pWnd == NULL)
    	m_pWnd = pOwner;

    if (m_pWnd == NULL)
    {
    	ASSERT(m_nIDWnd);
    	HWND hwnd = GetPackageWindow();

    	if (hwnd == NULL)
    	{
    		// Window gets hidden status, so it won't get messages.
			m_bVisible = FALSE;

			if (m_bLoading && !m_bMDIBound && m_dp != dpNil)
			{
				// Get rid of absolute dock placement information.  It is
				// only valid for the first creat call.
				//
				delete m_pDockSerial;
				m_pDockSerial = NULL;
			}

    		return FALSE;
    	}

    	m_pWnd = CWnd::FromHandlePermanent(hwnd);
    	ASSERT(m_pWnd != NULL);	// Must be a CWnd.
    }

    ASSERT((UINT) LOWORD(m_nIDWnd) == (UINT) m_pWnd->GetDlgCtrlID());

    CDockWnd* pDock = m_pManager->GetDock(dpHide);
    if (pDock == NULL || m_pWnd->SetParent(pDock) == NULL)
    	return FALSE;

    // Try to follow the init request for this window, but don't worry
    // about failure; we still have a valid worker.
	if (m_bMDIBound)
	{
		if (IsVisible())
			DeskWnd();
	}
	else if (m_dp == dpEmbedded)
	{
        CRect rect;
        GetFloatRect(rect);
		CWnd *pParent=m_pWnd->GetParent();

		FloatWnd(rect);
		DeparentWindow(pParent, NULL);
	}
    else if (m_dp == dpNil)
    {
        CRect rect;
        GetFloatRect(rect);
        FloatWnd(rect);
    }
    else if (IsVisible())
    {
    	if ((m_pWnd->GetStyle() & WS_VISIBLE) == 0)
    		m_pWnd->ShowWindow(SW_SHOWNOACTIVATE);

		DockWnd(NULL, !m_bLoading);
    }

	EndLoad();

	// if we already have focus, then set the active docker)
	if(CWnd::GetFocus()==m_pWnd && m_pWnd!=NULL)
	{
		s_pActiveDocker=this;
	}

    return TRUE;
}

CDockWorker::~CDockWorker()
{
	// Destroy the window if one exists.
	if (m_pWnd != NULL)
		DestroyWindow(FALSE);

	// Free init data.
	if (m_hglobInit != NULL)
		::GlobalFree(m_hglobInit);

	delete m_pDeskPlace;	// Okay to delete NULL.
	delete m_pDockPlace;
	delete m_pDockSerial;
}

HWND CDockWorker::GetPackageWindow()
{
	if (m_pWnd != NULL)
		return m_pWnd->m_hWnd;

	HWND hwnd = NULL;

	CPackage* pGrp = theApp.GetPackage(m_nIDPackage);
	if (pGrp == NULL)
		return NULL;

	switch (m_dtWnd)
	{
	case dtHwnd:
		hwnd = pGrp->GetDockableWindow(LOWORD(m_nIDWnd), m_hglobInit);
		break;

	case dtEmbeddedToolbar:
	case dtToolbar:
		//BLOCK:
		{
			// This code is now complicated by the possibility that we might try to load a 
			// toolbar from disk and fail. Because we are changing the data format, this is
			// a likely contingency, at least until we write (hypothetical) toolbar migration
			// code. 
			// For this reason, if a loaded toolbar fails, we'll try to construct a default
			// toolbar instead. martynl 27Mar96
			BOOL bFinished=FALSE;
			BOOL bLoadFailed=FALSE;

			while(!bFinished)
			{
				TOOLBARINIT tbi;
				HGLOBAL hglob = NULL;
				// if we've failed a load, then hide the hglobinit
				HGLOBAL hglobInitMasked=bLoadFailed ? NULL : m_hglobInit;

				if (hglobInitMasked == NULL)
				{
					hglob = pGrp->GetToolbarData(LOWORD(m_nIDWnd));
					if(hglob==NULL)
					{
						bFinished=TRUE;
					}
				}

				if (hglob != NULL || hglobInitMasked != NULL)
				{
					TOOLBARINIT FAR* lptbi = &tbi;
					UINT FAR* lpIDArray = NULL;

					if (hglob != NULL) {
						lptbi = (TOOLBARINIT FAR*) ::GlobalLock(hglob);
						lpIDArray = (UINT FAR*) (lptbi + 1);
					}
					
					/* Toolbars are now storing their full m_nIDWnd, to allow them to know their 
					own package id. 
					To avoid confusing the packages, CPackage::GetToolbarData (called above)
					is still sent a window id stripped of its package id (above). However, we 
					modify the hglob that it returns so that the TOOLBARINIT structure contains
					the	full m_nIDWnd. So the lptbi->nIDWnd field is initialised the same way,
					whether or not there is an available hglob. martynl 05Mar96
					*/
					lptbi->nIDWnd = m_nIDWnd;

					CASBar* pBar = new CASBar;
					if (!pBar->Create(NULL, m_pManager, WS_BORDER, lptbi,
							lpIDArray, hglobInitMasked))
					{
						// Don't delete pBar here, because Create is a self-delete-on-fail function
						pBar=NULL;

						// if load already failed, then now we have to give up
						if(bLoadFailed)
						{
							return NULL;
						}
						else
						{
							bLoadFailed=TRUE;
						}
					}
					else
					{
						bFinished=TRUE;
					}

					hwnd = pBar->GetSafeHwnd();

					if (hglob != NULL)
					{
						::GlobalUnlock(hglob);
						::GlobalFree(hglob);
					}
				}
			}
		}
		break;

	case dtBorder:
	case dtEdit:
		hwnd = pGrp->GetDockableWindow(LOWORD(m_nIDWnd), m_hglobInit);

		if (hwnd != NULL)
		{
			CBorderBar* pBar = new CBorderBar;
			DWORD dwStyle = 0xF & ::GetWindowLong((HWND) hwnd, GWL_STYLE);
			if (!pBar->Create(NULL, m_pManager, dwStyle, hwnd, m_nIDWnd))
			{
				delete pBar;
				return NULL;
			}

			hwnd = pBar->GetSafeHwnd();
		}
		break;

	default:
		ASSERT(FALSE);
		break;
	}

	// If window was created successfully, then get rid of init data.
	if (hwnd != NULL && m_hglobInit != NULL)
	{
		::GlobalFree(m_hglobInit);
		m_hglobInit = NULL;
	}

	return hwnd;
}

static char BASED_CODE szWorkerKey[] = "Window%x";

void CDockWorker::LoadData()
{
	ASSERT(s_lpszLayoutSection != NULL);

	CString strKey;
	wsprintf(strKey.GetBuffer(sizeof(szWorkerKey) + 10), szWorkerKey, m_nIDWnd);
	strKey.ReleaseBuffer();

	m_hglobInit = GetRegData(s_lpszLayoutSection, strKey, NULL);
}

void CDockWorker::SaveData()
{
	ASSERT(s_lpszLayoutSection != NULL);

	if (m_pWnd != NULL)
	{
		ASSERT(m_hglobInit == NULL);	// Otherwise we leak.
		m_hglobInit = (HGLOBAL) m_pWnd->SendMessage(DWM_GETDATA);
	}

	CString strKey;
	wsprintf(strKey.GetBuffer(sizeof(szWorkerKey) + 10), szWorkerKey, m_nIDWnd);
	strKey.ReleaseBuffer();

	if (m_hglobInit != NULL)
	{
		WriteRegData(s_lpszLayoutSection, strKey, m_hglobInit);
	}
	else
	{
		// erase any previous saved version of this window
		DeleteRegData(s_lpszLayoutSection, strKey);
	}

	// If we have a window, this data is only useful for the save.
	if (m_pWnd != NULL && m_hglobInit != NULL)
	{
		::GlobalFree(m_hglobInit);
		m_hglobInit = NULL;
	}
}

//  CDockWorker::OnMessage
//      Distibution point for DMM_*'s.

LONG CDockWorker::OnMessage(UINT message, LPARAM lParam)
{
	// Can't use a switch, because these are not constants.
	if (message == DMM_CHILDSETFOCUS)
	{
		OnChildSetFocus(CWnd::FromHandle((HWND) lParam));
    	return 0L;
	}
	else if (message == DMM_CHILDKILLFOCUS)
	{
		OnChildKillFocus(CWnd::FromHandle((HWND) lParam));
    	return 0L;
	}
    if (message == DMM_NCLBUTTONDOWN)
	{
		HGLOBAL hglob = (HGLOBAL) lParam;
		MOUSESTRUCT FAR* pmst = (MOUSESTRUCT FAR*) ::GlobalLock(hglob);
		LONG lResult = OnNcLButtonDown(pmst->nHitTest, pmst->pt);
		::GlobalUnlock(hglob);

		return lResult;
    }
    else if (message == DMM_NCLBUTTONDBLCLK)
	{
		HGLOBAL hglob = (HGLOBAL) lParam;
		MOUSESTRUCT FAR* pmst = (MOUSESTRUCT FAR*) ::GlobalLock(hglob);
		LONG lResult = OnNcLButtonDblClk(pmst->nHitTest, pmst->pt);
		::GlobalUnlock(hglob);

		return lResult;
    }
	else
	{
        ASSERT(FALSE);  // No other messages.
    }

    return 0L;
}

void CDockWorker::OnChildSetFocus(CWnd* pWndLoseFocus)
{
	if (s_pActiveDocker!=this ||			// activation may have happened early
		(m_pWnd != pWndLoseFocus && !m_pWnd->IsChild(pWndLoseFocus)))
		OnWindowActivate(TRUE, pWndLoseFocus);
}

void CDockWorker::OnChildKillFocus(CWnd* pWndGetFocus)
{
	if (m_pWnd != pWndGetFocus && !m_pWnd->IsChild(pWndGetFocus))
		OnWindowActivate(FALSE, pWndGetFocus);
}

// return true if window is of the type that should lock the doc window
BOOL CDockWorker::FWndLockWorker(CWnd* pWndOther)
{
	BOOL fRet = FALSE;

	if (pWndOther != NULL)
		{
		if (pWndOther == GetPropertyBrowser())
			fRet = TRUE;
		else if (pWndOther->IsKindOf(RUNTIME_CLASS(CGoToDialog)))
			fRet = TRUE;
		}
	return fRet;
}

void CDockWorker::OnWindowActivate(BOOL bActive, CWnd* pOtherWnd)
{
	ASSERT(m_pWnd != NULL);

	CMDIChildWnd* pFrame;
	CPartView* pView = NULL;

	// Only dtEdit types have Packets.
	if (m_dtWnd != dtEdit)
		return;
	else if	(CDockWorker::s_bLockDocker)
	{
		if (bActive)
			CDockWorker::s_bLockDocker = FALSE;

		if (s_pActiveDocker == this)
			return;

		// Warning:  If this happens unexplained, it should be considered, a bug.
		// Known cases when this happens:
		//		(1)	Clicking on floating dockable to activate the app,
		//			after deactivation with another dockable window focused.
		//
		ASSERT(bActive);
		TRACE2("CDockWorker::OnWindowActivate '%s' with locked worker '%s'.\n",
			(const char*) m_strTitle, s_pActiveDocker == NULL ?
			"" : (const char*) s_pActiveDocker->m_strTitle);

		if (s_pActiveDocker != NULL)
			s_pActiveDocker->OnWindowActivate(!bActive, m_pWnd);
	}
	else
	{
		// Handle the view activation.  This is pretty ugly, because
		// we have to take into account times when the view of a CMDIChildWnd
		// should be getting the message, but the MDI wnd will not get a
		// WM_MDIACTIVATE.
		//
		CWnd *pParent;
		while (pOtherWnd != NULL && !FWndLockWorker(pOtherWnd))
		{
			pParent = pOtherWnd->GetParent();
			if (pParent != NULL &&
				(pParent->IsKindOf(RUNTIME_CLASS(CDockWnd)) ||
				pParent->IsKindOf(RUNTIME_CLASS(CPaletteWnd))))
				break;

			pOtherWnd = pParent;
		}

		CDockWorker* pDocker = m_pManager->WorkerFromWindow(pOtherWnd);

		// If the OtherWnd is in a docking view, then it will be handled
		// in its own WindowActivate call.
		//
		if (pDocker == NULL || pDocker->m_dtWnd != dtEdit)
		{
			// Otherwise if the OtherWnd is not associated with a
			// dockable window, or we are being activated, then we
			// will need to notify the active MDI child.
			//
			if (bActive || pOtherWnd == NULL ||
				(pDocker == NULL && !FWndLockWorker(pOtherWnd)))
			{
				pFrame = ((CMDIFrameWnd*) theApp.m_pMainWnd)->MDIGetActive();
				if (pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
					pView = (CPartView*) pFrame->GetActiveView();
				ASSERT(pView == NULL || pView->IsKindOf(RUNTIME_CLASS(CPartView)));
			}
			// This window is being deactivated to give focus to another
			// dockable window (probably the Find Combo), so lock this as the
			// active worker.  (To allow us to find in dtEdit windows.)
			// Also lock for property page.
			else
			{
				LockWorker();
				return;
			}
		}
	}

	CPartView* pViewDock = GetView();
	ASSERT_VALID(pViewDock);

	if (bActive)
	{
		s_pActiveDocker = this;

		theApp.ActivatePacket(pViewDock->GetPacket());

		if (pView != NULL)
			pView->OnActivateView(FALSE, pView, pView);
	}
	else
	{
		s_pActiveDocker = NULL;

		// If there is no MDI child, we just deactivate the packet,
		// otherwise we update the menu to the new MDI child.
		//
		if (pView == NULL)
		{
			theApp.DeactivatePacket();
			theApp.m_theAppSlob.SetSlobProp(P_CurrentSlob, NULL);
		}
		else
		{
			ASSERT(pFrame != NULL);
			pFrame->OnUpdateFrameMenu(TRUE, pFrame, NULL);

			// Force update of available windows. This fixes a problem
			// when there is a switch from the Dialog editor (MDI) to the output
			// window (docking) to a regular text window (MDI): the last switch
			// would not update the toolbars and avail wnds because the packet
			// for the output window is the same as the packet for the MDI text Wnds.
			DkUpdateAvailableWnds(FALSE);
		}

		// Focus change will cause the necessary OnActivateView() for
		// MDI windows.
	}

	// s_pActiveDocker must be reset before we call OnActivateView for the
	// docking view, so that theApp.GetActiveView() can be used to test
	// active state.
	//
	pViewDock->OnActivateView(bActive, pViewDock, pViewDock);
}

//	CDockWorker::OnNcLButtonDown
//		Distribution point for the NcLButtonDown handling, to either size
//		or move, and returns FALSE on the HT's we don't handle.

BOOL CDockWorker::OnNcLButtonDown(UINT nHitTest, CPoint pt)
{
	switch(nHitTest)
	{
	case HTCAPTION:
		DoMove(pt);
		return TRUE;

	case HTLEFT:
	case HTTOP:
	case HTTOPLEFT:
	case HTTOPRIGHT:
	case HTRIGHT:
	case HTBOTTOM:
	case HTBOTTOMLEFT:
	case HTBOTTOMRIGHT:
		DoSize(pt, nHitTest);
		return TRUE;
	}

	return FALSE;
}

//	CDockWorker::OnNcLButtonDblClk
//		Toggles float on a HTCAPTION, and returns FALSE for other HT's.

BOOL CDockWorker::OnNcLButtonDblClk(UINT nHitTest, CPoint pt)
{
	if (nHitTest == HTCAPTION)
	{
		ToggleFloat();
		return TRUE;
	}

	return FALSE;
}

//  CDockWorker::ToggleFloat
//      Handles switching a dockable window between floating and docked
//      states.

void CDockWorker::ToggleFloat()
{
	ASSERT(m_pWnd != NULL);

    if (m_dp != dpNil)
    {
    	CRect rect;
    	GetFloatRect(rect);
        FloatWnd(rect);
    }
    else
    {
		DockWnd();
    }
}

//  CDockWorker::FloatWnd
//      Given a rect, creates a new palette around the rect, and sets this
//      as the parent of the dock worker's window.  Also handles removing
//      the window from its current DockWnd.

BOOL CDockWorker::FloatWnd(const CRect& rect)
{
	ASSERT(m_pWnd != NULL);

	DeparentWindow();

    m_dp = dpNil;

    CFrameWnd* pFrame = m_pWnd->GetParentFrame();
    ASSERT(pFrame != NULL);

	CRect rectCreate = rect;	// Make sure titlebar will be visible.
	CPaletteWnd::GetPaletteRect(rectCreate);
	//[multimon] 11 mar 97 - der : ForceRectBelowTop modified for MultiMon.
	::ForceRectBelowTop(rectCreate);

	CPaletteWnd::GetChildRect(rectCreate);

    CPaletteWnd* pPalette = new CPaletteWnd(m_pManager);

	BOOL bHasClose=(LOWORD(m_nIDWnd) != IDTB_MENUBAR) || IS_STATE_FULLSCREEN(DkGetDockState());

    if (!pPalette->Create(NULL, m_strTitle, m_pWnd, pFrame, rectCreate, m_nIDWnd, bHasClose))
    {
        delete pPalette;
        return FALSE;
    }

	// SetParent does not change ActiveWindow, so we need to make sure we
	// maintain Active->IsChild(Focus)
	//
	CWnd* pWndFocus = CWnd::GetFocus();
	if (pWndFocus != NULL && pPalette->IsChild(pWndFocus) &&
		pPalette != CWnd::GetActiveWindow())
	{
		pPalette->SetActiveWindow();
	}

    if (IsVisible() && m_pManager->IsVisible())
    {
    	pPalette->ShowWindow(SW_SHOWNOACTIVATE);
    	pPalette->UpdateWindow();
    }

    return TRUE;
}

BOOL CDockWorker::DockWnd(DOCKPLACEMENT* pDockPlace /*=NULL*/,
	BOOL bRelative /*=TRUE*/)
{
	ASSERT(m_pWnd != NULL);

	// This is a workaround for a dud-registry loading problem. Where the dud registry data comes
	// from is another question...
	if(!bRelative)
	{
		if(m_dp==dpNil || m_pDockSerial==NULL)
		{
			bRelative=TRUE;
		}
	}

	ASSERT(bRelative || (m_dp != dpNil && m_pDockSerial != NULL));

	BOOL bFloating = (m_dp == dpNil);

	DOCKPOS dpTmp = m_dp;
	if (bRelative && pDockPlace != NULL)
		dpTmp = pDockPlace->dp;
	if (dpTmp == dpNil)
	{
		if (m_pDockPlace != NULL)
			dpTmp = m_pDockPlace->dp;
		else if (m_bCanHorz)
	    	dpTmp = dpTop;
	    else if (m_bCanVert)
	    	dpTmp = dpLeft;
	    else
		{
			ASSERT(FALSE);
			return FALSE;
		}
	}
	ASSERT(dpTmp != dpNil);

    CDockWnd* pDock = m_pManager->GetDock(dpTmp);
    if (pDock == NULL)
		return FALSE;

	CSize size;
	DOCKPOS dpInitSize = (dpTmp == dpLeft || dpTmp == dpRight) ?
		dpVertInit : dpHorzInit;
	if (m_bTranspose)
		dpInitSize = (dpInitSize == dpVertInit) ? dpHorzInit : dpVertInit;

	if (bRelative)
	{
		// Hack: set m_dp so we will get the focus back when the frame
		// gets the WM_ACTIVATE caused by RemovePalette.
		//
		m_dp = dpTmp;

		if (bFloating)
		{
			// Can't use DeparentWindow because we have already changed m_dp.
	        SaveFloatPos();
	        CPaletteWnd* pPalette = (CPaletteWnd*) m_pWnd->GetParent();
			ASSERT(pPalette != NULL &&
				pPalette->IsKindOf(RUNTIME_CLASS(CPaletteWnd)));
	        m_pManager->RemovePalette(pPalette);
		}

		if (pDockPlace != NULL)
			pDock->AddWnd(m_pWnd, &pDockPlace->rectAbsolute);
		else if (m_pDockPlace != NULL)
		{
			// Make sure the size is current, and add the window.
			size.cx = m_pDockPlace->drRelative.cAlong;
			size.cy = m_pDockPlace->drRelative.cAcross;
			DockTranspose(m_dp, &size);
			size = GetMoveSize(dpInitSize, size);
			DockTranspose(m_dp, &size);
			m_pDockPlace->drRelative.cAlong = size.cx;
			m_pDockPlace->drRelative.cAcross = size.cy;

			pDock->AddWnd(m_pWnd, &m_pDockPlace->drRelative);
		}
		else
		{
		    size = GetMoveSize(dpInitSize, GetFloatSize());
	    	pDock->AddWnd(m_pWnd, size);
		}

		// SetParent does not change ActiveWindow, so we need to make sure we
		// maintain Active->IsChild(Focus)
		//
		CWnd* pWndFocus = CWnd::GetFocus();
		CWnd* pFrame = AfxGetApp()->m_pMainWnd;
		if (pWndFocus != NULL && pFrame->IsChild(pWndFocus) &&
			 pFrame != CWnd::GetActiveWindow())
		{
			pFrame->SetActiveWindow();
		}

	}
	else
	{
		ASSERT(m_dp == dpTmp);

		CRect rect = m_pDockSerial->rectAbsolute;
		size = GetMoveSize(dpInitSize, rect.Size());

		m_pWnd->SetParent(pDock);
		m_pWnd->SetWindowPos(NULL,
			rect.left, rect.top, size.cx, size.cy,
			SWP_NOACTIVATE | SWP_NOZORDER);

		delete m_pDockSerial;
		m_pDockSerial = NULL;
	}

	delete m_pDockPlace;
	m_pDockPlace = NULL;

	return TRUE;
}

//	CDockWorker::ToggleMDIState
//		Toggles the current MDI state, insuring that the docked view
//		remains active.

void CDockWorker::ToggleMDIState()
{
	HWND hwndSaveActiveView = theApp.GetActiveView();
	SetMDIState(!m_bMDIBound);
	if (hwndSaveActiveView != theApp.GetActiveView())
		theApp.SetActiveView(hwndSaveActiveView);
}

//	CDockWorker::SetMDIState
//		This is the interface for toggling windows between MDI and docking
//		views.

void CDockWorker::SetMDIState(BOOL bMDIBound)
{
	if (m_dtWnd != dtEdit ||
		(bMDIBound && m_bMDIBound) ||
		(!bMDIBound && !m_bMDIBound))
		return;

	if (!IsVisible())
	{
		m_bMDIBound = bMDIBound;
		return;
	}

	if (bMDIBound)
	{
		if (!DeskWnd())
			return;
		m_bMDIBound = TRUE;
	}
	else
	{
		DeparentWindow();
		m_bMDIBound = FALSE;
		Create(m_pManager);
	}
}

//	CDockWorker::DeskWnd
//      Given a rect, creates a new MDI child, and sets this
//      as the parent of the dock worker's window.  Also handles removing
//      the window from its current Parent.

BOOL CDockWorker::DeskWnd(const CRect& rect /*=CFrameWnd::rectDefault*/)
{
	ASSERT(m_pWnd != NULL);

	DeparentWindow();

	m_bMDIBound = TRUE;

	ASSERT(m_dtWnd == dtEdit);
	CMDIFrameWnd* pFrame = (CMDIFrameWnd*) AfxGetApp()->m_pMainWnd;
    ASSERT(pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CMDIFrameWnd)));

    CMDIChildDock* pMDIWnd = new CMDIChildDock(m_pManager);

	CPackage* pGrp = theApp.GetPackage(m_nIDPackage);
	ASSERT(pGrp != NULL);

    if (!pMDIWnd->Create(AfxRegisterWndClass(0, NULL, NULL,
    										 pGrp->GetDockableIcon(LOWORD(m_nIDWnd))),
    					 m_strTitle, m_pWnd, pFrame, rect))
    {
        delete pMDIWnd;
        return FALSE;
    }

	// SetParent does not change ActiveWindow, so we need to make sure we
	// maintain Active->IsChild(Focus)
	//
	CWnd* pWndFocus = CWnd::GetFocus();
	if (pWndFocus != NULL && pFrame->IsChild(pWndFocus) &&
		 pFrame != CWnd::GetActiveWindow())
	{
		pFrame->SetActiveWindow();
	}

	if (m_pDeskPlace != NULL)
	{
		m_pDeskPlace->place.length = sizeof(WINDOWPLACEMENT);	// Fix for NT bug.
		m_pDeskPlace->place.showCmd = SW_HIDE;
		pMDIWnd->SetWindowPlacement(&m_pDeskPlace->place);
		delete m_pDeskPlace;
		m_pDeskPlace = NULL;
	}

	ASSERT_VALID(GetView()) ; // Get that its okay before we dereference.
	CPartTemplate* pTemplate = GetView()->GetDocTemplate();
	if (pTemplate == NULL)
		pMDIWnd->InitialUpdateFrame(NULL, TRUE);
	else
		pTemplate->InitialUpdateFrame(pMDIWnd, NULL);

	// Make sure this doesn't stay the active worker.  MDI windows do not
	// get worker activation.
	//
	if (s_pActiveDocker == this)
	{
		s_pActiveDocker = NULL;
		s_bLockDocker = FALSE;
	}

    return TRUE;
}

//	CDockWorker::DeparentWindow
//		Removes the dockable window from its current parent, setting the
//		parent to the hidden dock, and destroying the old parent if
//		necessary.

void CDockWorker::DeparentWindow(CWnd* pWndNewParent /*=NULL*/,
	CDockManager* pManagerNew /*=NULL*/)
{
	if (m_pWnd == NULL)
		return;

	if (pWndNewParent == NULL)
		pWndNewParent = m_pManager->GetDock(dpHide);

	CWnd* pWndParent = m_pWnd->GetParent();
	if (pWndParent == pWndNewParent)
		return;

	ASSERT_VALID(pWndParent);

	if (pWndParent->IsKindOf(RUNTIME_CLASS(CMDIChildDock)))
	{
		ASSERT(m_dtWnd == dtEdit);

		if (pManagerNew == NULL)
			SaveMDIPos();

        m_pManager->RemoveMDIChild((CMDIChildDock*) pWndParent,
			pWndNewParent, pManagerNew);
	}
    else if (pWndParent->IsKindOf(RUNTIME_CLASS(CPaletteWnd)))
	{
		if (pManagerNew == NULL)
			SaveFloatPos();

        m_pManager->RemovePalette((CPaletteWnd*) pWndParent,
			pWndNewParent, pManagerNew);
	}
	else if (pManagerNew == NULL)
    {
		// We don't do this if we are swtiching managers, because it would
		// really expensive with all the layout recalc'ing.

		if(m_dp!=dpEmbedded)
		{
			SaveDockPos();

			CDockWnd* pDock = m_pManager->GetDock(m_dp);
			ASSERT(pDock != NULL);	// The dock exists, so this should work.
			pDock->RemoveWnd(m_pWnd, pWndNewParent);
		}
    }
}

void CDockWorker::SetText(const CString& str)
{
	m_strTitle = str;

	if ((IsVisible() && m_bMDIBound) || (m_pWnd != NULL && m_dp == dpNil))
	{
		ASSERT(m_pWnd != NULL);
		m_pWnd->GetParent()->SetWindowText(str);
	}
}

//	CDockWorker::GetView
//		Gets the CPartView associated with a dtEdit docking view.

CPartView* CDockWorker::GetView() const
{
	if (!m_pWnd || m_dtWnd != dtEdit)
		return NULL;

	// Orion 96 Bug 15325 - GetDescendantWindow is finding an IV window with the id E900
	// which happens to be AFX_IDW_PANE_FIRST. Replaced with another function which 
	// returns the first window with an ID which is also a CPartView.
	CPartView* pView = GetFirstChildWindowWithID(m_pWnd->m_hWnd, AFX_IDW_PANE_FIRST);
	if (pView == NULL)
	{
		pView = GetFirstChildWindowWithID(m_pWnd->m_hWnd, LOWORD(m_nIDWnd));
	}
	ASSERT(pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)));
	return pView;
}

//	CDockWorker::ActivateView
//		Activates a worker's view.

void CDockWorker::ActivateView()
{
	if (m_dtWnd != dtEdit)
		return;

	if (!IsVisible())
		ShowWindow(TRUE);
	else
	{
		CView* pView = GetView();
		if (pView->GetSafeHwnd() != NULL)
			theApp.SetActiveView(pView->GetSafeHwnd());
	}
}

//	CDockWorker::ShowWindow
//		Dockable window version of ShowWindow.  Takes care of hiding the
//		the palette if window is floating, or re-calc'ing layout if it
//		was docked.

void CDockWorker::ShowWindow(BOOL bShow)
{
	// This and creation should be the only places we handle visibility.
	BOOL bVisible = IsVisible();

	// if it's embedded, this is it's creation call
	if(m_dp==dpEmbedded && bShow && (m_pWnd==NULL || m_pWnd->IsWindowVisible()==FALSE))
	{
		bVisible=FALSE;
	}

	if ((bShow && bVisible) || (!bShow && !bVisible))
	{
		if(m_dp==dpEmbedded)
		{
			m_bVisible=bShow;
		}
		return;
	}

	BOOL bCustomize = (CASBar::s_pCustomizer != NULL &&
		CASBar::s_pCustomizer->m_pDialog != NULL);

	if (bShow)
	{
		// May need to create window.  Creation of hidden windows is defered.
		if (m_pWnd == NULL && !Create(m_pManager))
			return;

		// Make sure we refuse input in customize mode.
		if (bCustomize)
    		m_pWnd->SendMessage(DWM_ENABLECHILD, FALSE);
		else if (m_dtWnd == dtEdit)
		{
			CPartView* pView = GetView();
			ASSERT_VALID(pView);
			theApp.SetActiveView(pView->m_hWnd);
		}

		if (m_bMDIBound)
		{
			DeskWnd();
		}
		else if (m_dp != dpNil && m_dp != dpEmbedded)
		{
			DockWnd();
		}
		else
		{
			CPaletteWnd* pPalette = (CPaletteWnd*) m_pWnd->GetParent();
			if (!pPalette->IsKindOf(RUNTIME_CLASS(CPaletteWnd)))
			{
				CRect rect;
				GetFloatRect(rect);
				FloatWnd(rect);
				
				pPalette = (CPaletteWnd*) m_pWnd->GetParent();
			}

			ASSERT(pPalette->IsKindOf(RUNTIME_CLASS(CPaletteWnd)));

			// Make sure we appear on screen.
			CRect rectPalette;
			pPalette->GetWindowRect(rectPalette);
			ForceRectOnScreen(rectPalette);

			pPalette->ActivateNoFocus();
			pPalette->SetWindowPos(NULL, rectPalette.left, rectPalette.top,
				rectPalette.Width(), rectPalette.Height(),
				SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);
			pPalette->UpdateWindow();
		}

		// Window owner may have asked to show a window before we reach
		// UpdateAvailable().  In order to avoid having this code execute
		// twice in this event, we assume m_bAvailable to be true.

		m_bAvailable = TRUE;

#ifdef _DEBUG
		if (m_bAsk)
		{
			// Make sure the window really is available.
			CPackage* pGrp = theApp.GetPackage(m_nIDPackage);
			ASSERT(pGrp == NULL || pGrp->AskAvailable(LOWORD(m_nIDWnd)));
		}
#endif
	}
	else
	{
		// Safeguard against nasty crashes, if by some quirk we get in
		// a state we should really never be in.  But let's be safe.
		//
		if (m_pWnd == NULL)
		{
			m_bVisible = FALSE;
			return;
		}

		ASSERT(m_pWnd->m_hWnd != NULL);

		if (m_bMDIBound)
		{
			if (!m_bDestroyOnHide)
				DeparentWindow();
		}
		else if (m_dp == dpEmbedded)
		{
			m_pWnd->ShowWindow(SW_HIDE);
		}
		else if (m_dp != dpNil)
		{
			DeparentWindow();
		}
		else
		{
			CWnd* pPalette = m_pWnd->GetParent();
			ASSERT(pPalette->IsKindOf(RUNTIME_CLASS(CPaletteWnd)));
			pPalette->ShowWindow(SW_HIDE);
			pPalette->UpdateWindow();
		}

		// If we had the focus, make sure we don't keep it.
		CWnd* pWnd = CWnd::GetFocus();
		if (m_pWnd == pWnd || m_pWnd->IsChild(pWnd))
			m_pManager->m_pFrame->SetFocus();

		if (s_pActiveDocker == this)
		{
			// Focus handling for this window is broken in some way, really.
			// The above SetFocus should have deactivated this window.

			// Apparently a longer explanation of this is in order, due to the
			// number of questions this generates.  Do not even think about
			// removing this assert; it has found a ton of bugs.

			// The above SetFocus() will cause Windows to send two important
			// messages:
			// (1) WM_KILLFOCUS to the dockable window child that has the focus.
			//     If you are calling DkPreHandleMessage for this child,
			//     s_pActiveDocker will be set to NULL in CDockWorker::OnWindowActivate.
			// (2) WM_SETFOCUS to the main frame.  If your window has no bugs,
			//     s_pActiveDocker will still be NULL, and the normal focus routing
			//     will occur.

			// Thus far 2 types of bugs have caused this assert to fire:
			// (1) The dockable child window with the focus does not call
			//     DkPreHandleMessage.
			// (2) Some hidden sub-function has the side-effect of setting the
			//     focus back to the dockable window of one of its children.
			//     To catch the culprit, set a breakpoint on CDockWorker::OnChildSetFocus,
			//     and watch how it gets called during the hide.

			ASSERT(FALSE);
			s_pActiveDocker = NULL;
		}

		// Destroy dtEdit windows, since they have more overhead, but
		// only destroy them when they have m_bDestroyOnHide set.
		if (m_dtWnd == dtEdit && m_bDestroyOnHide)
			DestroyWindow();
	}

	m_bVisible = (bShow != 0);	// Bit bool.

	// Are we in customize mode?
	if (bCustomize)
	{
		// If we have a CToolbar dialog, update the checklist.
		if (CASBar::s_pCustomizer->m_pDialog->
			IsKindOf(RUNTIME_CLASS(CToolbarDialog)))
		{
			((CToolbarDialog*) CASBar::s_pCustomizer->m_pDialog)->
				UpdateCheck(m_nIDWnd);
		}
	}

	// Notify the window of the change.  This is where windows that want to
	// unregister themselves when closed should call DkUnregister, since
	// unregistering will cause this worker to be deleted.
	//
	// Warning: Do not add code to this function below this call, or you may
	// crash accessing a deleted this pointer.

	if (m_pWnd != NULL)
		m_pWnd->SendMessage(DWM_SHOWWINDOW, m_bVisible);
}

void CDockWorker::DestroyWindow(BOOL bInitData /*=TRUE*/)
{
	if (m_pWnd == NULL)
		return;

	// cache it here in case it gets corrupted during destruction
	DOCKPOS dp=m_dp;

	if (bInitData)
	{
		ASSERT(m_hglobInit == NULL);	// Otherwise we leak.
		m_hglobInit = (HGLOBAL) m_pWnd->SendMessage(DWM_GETDATA);
	}

	// Make sure we don't stay the active worker.
	if (s_pActiveDocker == this)
	{
		s_bLockDocker = FALSE;
		s_pActiveDocker->OnWindowActivate(FALSE, m_pManager->m_pFrame);

		CWnd* pWndFocus = CWnd::GetFocus();
		if (m_pWnd == pWndFocus || m_pWnd->IsChild(pWndFocus))
			m_pManager->m_pFrame->SetFocus();
	}

	CWnd* pParent = m_pWnd->GetParent();
	if (pParent != NULL && !pParent->IsKindOf(RUNTIME_CLASS(CDockWnd)))
		DeparentWindow();

	if(dp!=dpEmbedded)
	{
		m_pWnd->DestroyWindow();	// Must be auto-deleting.
		m_pWnd = NULL;
	}
	else
	{
		// embeddee will do it.
	}
}

//	CDockWorker::UpdateAvailable
//		Updates the m_bAvailable bool, and hide/shows the window if appropriate.
//		The bool is used to allow us to hide unavailable windows in one loop,
//		end then show available ones after.

void CDockWorker::UpdateAvailable(BOOL bShow)
{
	if(m_dp==dpEmbedded)
	{
		// let the host do the talking
		return;
	}

	BOOL bAvailable = FALSE;
	if(m_bAsk)
	{
		CPackage* pGrp = theApp.GetPackage(m_nIDPackage);
		if (pGrp == NULL)
			return;

		bAvailable = m_pManager->IsVisible() &&
			pGrp->AskAvailable(LOWORD(m_nIDWnd));
	}
	else bAvailable = m_pManager->IsVisible();

	if(bAvailable && m_pManager->IsInDocObjectMode())
	{
		switch(m_nIDWnd)
		{
			case MAKEDOCKID(PACKAGE_PRJSYS, IDDW_PROJECT):
			case MAKEDOCKID(PACKAGE_PRJSYS, IDDW_GLOBAL):
			case MAKEDOCKID(PACKAGE_IV,IDDW_IV):
				bAvailable = TRUE;
				break;
			default:
				bAvailable = FALSE;
		}
	}
	BOOL bVisible = m_bVisible;	// May change in ShowWindow.

	if ((bShow && bAvailable) || (!bShow && !bAvailable))
	{
		ShowWindow(bAvailable && bVisible);

		if(bAvailable && bVisible && m_nIDWnd==MAKEDOCKID(PACKAGE_SUSHI, IDTB_MENUBAR))
		{
			CMainFrame *pFrame=(CMainFrame *)AfxGetMainWnd();
			pFrame->RebuildMenus();
		}

		m_bAvailable = bAvailable;
		m_bVisible = bVisible;	// May have been changed.
	}
}

//	CDockWorker::DoSize
//		Snap sizing for floating windows.

void CDockWorker::DoSize(CPoint pt, UINT nHitTest)
{
	ASSERT(m_pWnd != NULL);
	ASSERT(m_dp == dpNil);

    CRect rect;

    if (!TrackSize(pt, nHitTest, rect))
        return;

	Move(m_dp, rect);
}

//	CDockWorker::TrackSize
//		Tracks cursor movement in snap sizing operation, displaying tracker.

BOOL CDockWorker::TrackSize(CPoint ptStart, UINT nHitTest, CRect& rectFinal)
{
	// No tracking when we aren't really visible.  Might end up
	// tracking for during OLE activation.
	if (m_dp != dpNil || !m_pManager->IsVisible())
		return FALSE;

    BOOL bCancel = FALSE;

    CRect rect, rectOld, rectWnd;
    CRect rectBound(g_mt.cxFrame, g_mt.cyFrame,
    	::GetSystemMetrics(SM_CXSCREEN) - g_mt.cxFrame,
    	::GetSystemMetrics(SM_CYSCREEN) - g_mt.cyFrame);
    CPoint pt, ptOld;

#if 1
    CLockDC dc(NULL);
#else
	CClientDC dc(NULL);
#endif

    MINMAXINFO mmi;
	mmi.ptMaxTrackSize = s_ptDefMax;
    mmi.ptMinTrackSize = CDockWorker::GetDefMin();

    m_pWnd->GetWindowRect(rectWnd);
    rect = rectWnd;

    m_pWnd->SendMessage(WM_GETMINMAXINFO, 0, (LPARAM) (LPVOID) &mmi);

    ptOld = pt = ptStart;

    // Loop while the mouse is down.
    CWnd* pWndTrack = CWnd::GetFocus();	// So we stay the active window.
    if (pWndTrack == NULL)
	{
		// Try to get a valid focused window.
		m_pManager->m_pFrame->SetFocus();
		if ((pWndTrack = CWnd::GetFocus()) == NULL)
			return FALSE;
	}


    pWndTrack->SetCapture();

    // Turn on the drag rectangle.
    rectOld = rect;
    DrawTrackRect(&dc, m_dp, &rect);

    while (!PollForMouseChange(pt, FALSE, bCancel))
    {
        if (pt == ptOld)
        	continue;

        switch (nHitTest)
        {
    	case HTTOP:
    	case HTTOPLEFT:
    	case HTTOPRIGHT:
    		rect.top = rectWnd.top + pt.y - ptStart.y;
    		rect.top = rect.bottom -
    			min(max(rect.Height(), mmi.ptMinTrackSize.y),
    				mmi.ptMaxTrackSize.y);
    		break;

    	case HTBOTTOM:
    	case HTBOTTOMLEFT:
    	case HTBOTTOMRIGHT:
    		rect.bottom = rectWnd.bottom + pt.y - ptStart.y;
    		rect.bottom = rect.top +
    			min(max(rect.Height(), mmi.ptMinTrackSize.y),
    				mmi.ptMaxTrackSize.y);
    		break;
        }

        switch (nHitTest)
        {
    	case HTLEFT:
    	case HTTOPLEFT:
    	case HTBOTTOMLEFT:
    		rect.left = rectWnd.left + pt.x - ptStart.x;
    		rect.left = rect.right -
    			min(max(rect.Width(), mmi.ptMinTrackSize.x),
    				mmi.ptMaxTrackSize.x);
    		break;

    	case HTRIGHT:
    	case HTTOPRIGHT:
    	case HTBOTTOMRIGHT:
    		rect.right = rectWnd.right + pt.x - ptStart.x;
    		rect.right = rect.left +
    			min(max(rect.Width(), mmi.ptMinTrackSize.x),
    				mmi.ptMaxTrackSize.x);
    		break;
		}

		// Give the window a chance to update this rectangle
		// for snapping drag.
		if (m_pWnd->GetStyle() & (DWS_SIZABLE | DWS_8SIZABLE))
		{
			CSize size = GetTrackSize(nHitTest, rect.Size());

#ifdef _DEBUG
			if (size.cx > mmi.ptMaxTrackSize.x ||
				size.cy > mmi.ptMaxTrackSize.y ||
				size.cx < mmi.ptMinTrackSize.x ||
				size.cy < mmi.ptMinTrackSize.y)
			{
				TRACE0("Warning: Returned track size outside min/max bounds.\n	Using last rect.\n");
			}
#endif

			size.cx = min(max(size.cx, mmi.ptMinTrackSize.x),
				mmi.ptMaxTrackSize.x);
			size.cy = min(max(size.cy, mmi.ptMinTrackSize.y),
				mmi.ptMaxTrackSize.y);

			// Adjust, anchored to a point that is not changing.
			switch (nHitTest)
			{
	    	case HTTOP:
	    	case HTTOPLEFT:
			case HTLEFT:
				rect.left = rect.right - size.cx;
				rect.top = rect.bottom - size.cy;
				break;

	    	case HTBOTTOM:
	    	case HTBOTTOMRIGHT:
			case HTRIGHT:
				rect.right = rect.left + size.cx;
				rect.bottom = rect.top + size.cy;
				break;

	    	case HTTOPRIGHT:
				rect.right = rect.left + size.cx;
				rect.top = rect.bottom - size.cy;
				break;

	    	case HTBOTTOMLEFT:
				rect.left = rect.right - size.cx;
				rect.bottom = rect.top + size.cy;
				break;
			}

			if (rect.left > rectBound.right || rect.top > rectBound.bottom ||
				rect.right < rectBound.left || rect.bottom < rectBound.top)
			{
				rect = rectOld;
			}
		}

		ptOld = pt;

        if (rect != rectOld)
        {
        	DrawTrackRect(&dc, m_dp, &rect, TRUE, m_dp, &rectOld, TRUE);
        	rectOld = rect;
        }
    } // while

    // Turn off drag rectangle.
    DrawTrackRect(&dc, m_dp, &rect);
    ::ReleaseCapture();

    if (bCancel || rect == rectWnd)
        return FALSE;

    rectFinal = rect;

    return TRUE;
}

//  CDockWorker::DoMove
//      Given a point in screen coordinates of the location of the mouse down
//      that initiated the move.  Handles the dragging, and all necessary
//      dock changing to complete a move on a dockable window.

void CDockWorker::DoMove(CPoint pt)
{
	ASSERT(m_pWnd != NULL);

    DOCKPOS dp;
    CRect rect;

	// Give the user a hint about pressing the Ctrl key.
    SetPrompt(IDS_NODOCK_WINDOW, TRUE);

    // Drag the window while mouse is down.
    if (TrackMove(pt, dp, rect))
    	Move(dp, rect);

    SetPrompt();
}

//	CDockWorker::Move
//		Called both for the DoMove UI, as well as for DkMoveWindow moves a
//		window within the docking model.

void CDockWorker::Move(DOCKPOS dp, CRect& rect)
{
	ASSERT(m_pWnd != NULL);
	ASSERT(dp != dpHide);

	// an Embedded bar will be controlled by its parent
	if(dp==dpEmbedded)
	{
		m_dp=dp;
		return;
	}

    if ((IsVisible() || m_dp == dpNil) && (dp == dpCurrent || dp == m_dp))
    {
    	CRect rectWnd;
    	m_pWnd->GetWindowRect(rectWnd);
    	if (rect == rectWnd)
    		return;

        if (m_dp == dpNil)
        {
			rectWnd = rect;
        	CPaletteWnd::GetPaletteRect(rectWnd);
			//[multimon] 11 mar 97 - der : ForceRectBelowTop modified for MultiMon.
			::ForceRectBelowTop(rectWnd); 

        	ASSERT(m_pWnd->GetParent() != NULL);
            m_pWnd->GetParent()->MoveWindow(rectWnd);
        }
        else if(m_dp==dpEmbedded)
		{
			m_pWnd->Invalidate();
			// do nothing
		}
		else // moved within dock
        {
            CDockWnd* pDock = m_pManager->GetDock(m_dp);
            pDock->MoveWnd(m_pWnd, rect);
        }
    }
    else if (dp == dpCurrent)
    {
    	// Just size the window, but leave it hidden.
    	m_pWnd->SetWindowPos(NULL, 0, 0, rect.Width(), rect.Height(),
    		SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
    }
    else    // dp is changing
    {
        if (dp == dpNil || dp == dpEmbedded)
            FloatWnd(rect);
        else    // need to dock the window.
        {
            if (m_dp != dpNil && IsVisible()) // was docked before
            {
	            CDockWnd* pDock;
				CRect rectDock, rectDockOld;

                pDock = m_pManager->GetDock(m_dp);
				pDock->GetWindowRect(rectDockOld);

                pDock->RemoveWnd(m_pWnd, m_pManager->GetDock(dpHide));

				pDock->GetWindowRect(rectDock);

				// Compensate for possible shift of docks.
				if (m_dp == dpTop && (dp == dpLeft || dp == dpRight))
					rect.OffsetRect(0, rectDock.Height() - rectDockOld.Height());
            }

			DOCKPLACEMENT place;
			place.dp = dp;
			place.rectAbsolute = rect;

			DockWnd(&place);
            m_bVisible = TRUE;
        }
    }
}

//  CDockWorker::TrackMove
//      Handles dragging of dockable window during a move operation.  Given,
//      the start point in screen coordinates, returns true if user didn't
//      cancel the drag, as well as a final DOCKPOS, and window rect.

BOOL CDockWorker::TrackMove(CPoint pt, DOCKPOS& dpFinal, CRect& rectFinal)
{
	// No tracking when we aren't really visible.  Might end up
	// tracking for during OLE activation.
	if (!m_pManager->IsVisible())
		return FALSE;

    BOOL bWasOutside;
    BOOL bCancel = FALSE;

	// Stretchy window variables.
	BOOL bStretchy = (m_pWnd->GetStyle() & DWS_STRETCHY) != 0;
	SHELL_DRAGINFO drag;
	SHELL_DRAGINFO* pDrag = (bStretchy && m_dp != dpNil ? &drag : NULL);
	CRect rectDraw, rectDrawOld;

	BOOL bGotRect, bGotNewRect, bNewRect = FALSE;
    BOOL bControl, bControlOld, bShift, bShiftOld;
    CRect rect, rectOld;
	CRect rectHorz, rectVert;
    DOCKPOS dp, dpOld;
    CPoint ptOld;

    CSize sizeHorz, sizeVert, sizeFloat;
    CRect rectTDock, rectLDock, rectBDock, rectRDock;
    CRect rectClient, rectDesk;

#if 1
	CLockDC dc(NULL);
#else
	CClientDC dc(NULL);
#endif

    m_pManager->GetDeskRects(rectDesk, rectClient);

    dp = m_dp;

	// Update size variables used in tracking move.
	if (dp == dpNil)
		SaveFloatPos();
	else
		SaveStretchSize();

    m_pWnd->GetWindowRect(rect);

    sizeHorz = GetMoveSize(dpTop, GetFloatSize());
    sizeVert = GetMoveSize(dpLeft, GetFloatSize());

    if (bStretchy && dp != dpNil)
    {
		CDockWnd* pDock = m_pManager->GetDock(dp);

		drag.dp = dp;
		VERIFY(!pDock->IsInsert(rect, &drag.iRow, FALSE));

    	if (m_dp == dpLeft || m_dp == dpRight)
		{
			drag.cAlongRow = rect.Height();
    		drag.cAlongOther = sizeVert.cy;
		}
    	else if (m_dp == dpTop || m_dp == dpBottom)
		{
			drag.cAlongRow = rect.Width();
    		drag.cAlongOther = sizeHorz.cx;
		}
    }

    if (dp == dpNil)
    {
    	ASSERT(m_pWnd->GetParent() != NULL);
        m_pWnd->GetParent()->GetWindowRect(rect);
        sizeFloat = rect.Size();
    }
    else
    {
    	CRect rectFloat;
    	GetFloatRect(rectFloat);
    	CPaletteWnd::GetPaletteRect(rectFloat);
    	sizeFloat = rectFloat.Size();
    }

#if 0
    // Make sure the initial drag rect matches the size for the DOCKPOS,
    // important for STRETCHY windows.
    //
    if (dp == dpTop || dp == dpBottom)
    {
        rect.right = rect.left + sizeHorz.cx;
        rect.bottom = rect.top + sizeHorz.cy;
    }
    else if (dp == dpLeft || dp == dpRight)
    {
        rect.right = rect.left + sizeVert.cx;
        rect.bottom = rect.top + sizeVert.cy;
    }
#endif

    // Calculate the snapping rects.
    if (m_bCanHorz)
    {
//		CSize sizeBar((sizeHorz.cx - g_mt.cxFrame) / 2, sizeHorz.cy - g_mt.cyFrame);
		CSize sizeBar(0, sizeHorz.cy - g_mt.cyFrame);
        rectTDock.SetRect(rectClient.left - sizeBar.cx, rectClient.top - sizeBar.cy,
            rectClient.right + sizeBar.cx, rectDesk.top + sizeBar.cy);
        rectBDock.SetRect(rectClient.left - sizeBar.cx, rectDesk.bottom - sizeBar.cy,
            rectClient.right + sizeBar.cx, rectClient.bottom + sizeBar.cy);
    }

    if (m_bCanVert)
    {
//		CSize sizeBar(sizeVert.cx - g_mt.cxFrame, (sizeVert.cy - g_mt.cyFrame) / 2);
		CSize sizeBar(sizeVert.cx - g_mt.cxFrame, 0);

		// Orion 96 Bug 17212 - The size of the docking areas was changed so that the
		// user couldn't get a floating window into a position where it could not be moved.
        rectLDock.SetRect(rectClient.left /*- sizeBar.cx*/, rectDesk.top - sizeBar.cy,
            rectDesk.left + sizeBar.cx, rectDesk.bottom + sizeBar.cy);
        rectRDock.SetRect(rectDesk.right - sizeBar.cx, rectDesk.top - sizeBar.cy,
            rectClient.right + sizeBar.cx - g_mt.cxFrame, rectDesk.bottom + sizeBar.cy);
    }

    // Loop while the mouse is down.
    CWnd* pWndTrack = CWnd::GetFocus();	// So we stay the active window.
    if (pWndTrack == NULL)
	{
		// Try to get a valid focused window.
		m_pManager->m_pFrame->SetFocus();
		if ((pWndTrack = CWnd::GetFocus()) == NULL)
			return FALSE;
	}

    pWndTrack->SetCapture();
    ptOld = pt;
    bControlOld = FALSE;
	bShiftOld = FALSE;

    // Turn on the drag rectangle.
    DrawTrackRect(&dc, dp, &rect, FALSE);

	rectDrawOld = rect;	// Save for stretchy windows.

    while (!PollForMouseChange(pt, FALSE, bCancel))
    {
        bControl = (GetAsyncKeyState(VK_CONTROL) & 0x8000) != 0;
		bShift = dp != dpNil && !bStretchy &&
			(GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0;

        if (pt == ptOld && bControl == bControlOld && bShift == bShiftOld)
        	continue;

        dpOld = dp;
        rectOld = rect;

        rect.OffsetRect(pt.x - ptOld.x, pt.y - ptOld.y);

        // Find out which dock position we are in.
        if (bControl)
            dp = dpNil;
        else
        {
        	// Bellow tests cursor and rect locations to determine the
        	// dock we are over, if any.  If the window could be in more
        	// than one dock, the dock with the center line closest to
        	// the center line of the window rect gets it.

            bWasOutside = !rectClient.PtInRect(ptOld);

			CRect rectTrack, rectTmp;
			CPoint ptMid((rect.left + rect.right) / 2,
					     (rect.top + rect.bottom) / 2);
			int nMinDelta = INT_MAX;
			int nCurDelta;

            dp = dpNil;
			bGotNewRect = FALSE;

            if (m_bCanHorz)
            {
				if(bShift && !m_bCanVert)
				{
					bShift=FALSE;
				}

                if (rect.top < rectDesk.top &&
                    rect.bottom > rectClient.top &&
                    rectTDock.PtInRect(pt))
                {
					rectTmp = rect;
					bGotRect = GetTrackRect(rectTmp, rectOld, pt,
						bShift ? sizeVert : sizeHorz, dpTop, dpOld,	bWasOutside,
						rectDesk, rectClient, bShift != bShiftOld, pDrag);

					if (rectTmp.left < rectClient.right &&
						rectTmp.right > rectClient.left)
					{
	                	nMinDelta = abs((rectTmp.top + rectTmp.bottom) / 2 -
	                		(rectTDock.top + rectTDock.bottom) / 2);
	                    dp = dpTop;
						rectTrack = rectTmp;
						bGotNewRect = bGotRect;
					}
                }
                else if (rect.bottom > rectDesk.bottom &&
                    rect.top < rectClient.bottom &&
                    rectBDock.PtInRect(pt))
                {
					rectTmp = rect;
					bGotRect = GetTrackRect(rectTmp, rectOld, pt,
						bShift ? sizeVert : sizeHorz, dpBottom, dpOld, bWasOutside,
						rectDesk, rectClient, bShift != bShiftOld, pDrag);

					if (rectTmp.left < rectClient.right &&
						rectTmp.right > rectClient.left)
					{
	                	nMinDelta = abs((rectTmp.top + rectTmp.bottom) / 2 -
	                		(rectBDock.top + rectBDock.bottom) / 2);
                        dp = dpBottom;
						rectTrack = rectTmp;
						bGotNewRect = bGotRect;
					}
				}
            }

            if (m_bCanVert)
            {
				if(bShift && !m_bCanHorz)
				{
					bShift=FALSE;
				}

                if (rect.left < rectDesk.left &&
                    rect.right > rectClient.left &&
                    rectLDock.PtInRect(pt))
                {
					rectTmp = rect;
					bGotRect = GetTrackRect(rectTmp, rectOld, pt,
						bShift ? sizeHorz : sizeVert, dpLeft, dpOld, bWasOutside,
						rectDesk, rectClient, bShift != bShiftOld, pDrag);

					if (rectTmp.top < rectDesk.bottom &&
						rectTmp.bottom > rectDesk.top)
					{
	                	nCurDelta = abs((rectTmp.left + rectTmp.right) / 2 -
	                		(rectLDock.left + rectLDock.right) / 2);

						if (dp == dpNil || nCurDelta < nMinDelta)
						{
	                        dp = dpLeft;
							rectTrack = rectTmp;
							bGotNewRect = bGotRect;
	                    }
					}
				}
                else if (rect.right > rectDesk.right &&
                    rect.left < rectClient.right &&
                    rectRDock.PtInRect(pt))
                {
					rectTmp = rect;
					bGotRect = GetTrackRect(rectTmp, rectOld, pt,
						bShift ? sizeHorz : sizeVert, dpRight, dpOld, bWasOutside,
						rectDesk, rectClient, bShift != bShiftOld, pDrag);

					if (rectTmp.top < rectDesk.bottom &&
						rectTmp.bottom > rectDesk.top)
					{
	                	nCurDelta = abs((rectTmp.left + rectTmp.right) / 2 -
	                		(rectRDock.left + rectRDock.right) / 2);

						if (dp == dpNil || nCurDelta < nMinDelta)
						{
	                        dp = dpRight;
							rectTrack = rectTmp;
							bGotNewRect = bGotRect;
						}
					}
				}
            }

			if (dp != dpNil)
				rect = rectTrack;
        }	// if(bControl)

        if (dp == dpNil)
		{
			GetTrackRect(rect, rectOld, pt, sizeFloat, dp, dpOld,
				bWasOutside, rectDesk, rectClient);

			// No new rect, so that dragging a transposed window to a floating
			// position will not cause the transpose bool to be cleared.
			//
			bGotNewRect = FALSE;
		}

		bNewRect = bNewRect || bGotNewRect;

		if (!bStretchy)
        	DrawTrackRect(&dc, dp, &rect, FALSE, dpOld, &rectOld, FALSE);
		else
		{
			rectDraw = rect;

			if (dp != dpNil)
			{
				BOOL bInsert = !m_pManager->HasDock(dp);

				if (!bInsert)
				{
					CDockWnd* pDock = m_pManager->GetDock(dp);
					bInsert = pDock->IsInsert(rect, NULL, FALSE);
				}

				if (dp == dpLeft || dp == dpRight)
				{
					if (bInsert || rectDraw.Height() >= rectDesk.Height())
					{
						rectDraw.top = rectDesk.top;
						rectDraw.bottom = rectDesk.bottom;
					}
				}
				else if (dp == dpTop || dp == dpBottom)
				{
					if (bInsert || rectDraw.Width() >= rectClient.Width())
					{
						rectDraw.left = rectClient.left;
						rectDraw.right = rectClient.right;
					}
				}
			}

	        DrawTrackRect(&dc, dp, &rectDraw, FALSE, dpOld, &rectDrawOld, FALSE);
			rectDrawOld = rectDraw;
		}

        ptOld = pt;
        bControlOld = bControl;
		bShiftOld = bShift;
    } // while

    // Turn of drag rectangle.
    DrawTrackRect(&dc, dp, bStretchy ? &rectDrawOld : &rect, FALSE);
    ::ReleaseCapture();

    if (bCancel)
        return FALSE;
    else
    {
        dpFinal = dp;
        if (dp == dpNil)
        	CPaletteWnd::GetChildRect(rect);
        rectFinal = rect;
		if (bNewRect)
			m_bTranspose = bShift;
        return TRUE;
    }
}

//	CDockWorker::GetTrackRect
//		Returns TRUE if a new rect was calculated, and FALSE otherwise.

BOOL CDockWorker::GetTrackRect(CRect& rect, const CRect& rectOld, CPoint pt,
	CSize size, DOCKPOS dp,	DOCKPOS dpOld, BOOL bWasOutside,
	const CRect& rectDesk, const CRect& rectClient,
	BOOL bForce /*=FALSE*/, SHELL_DRAGINFO* pDrag /*=NULL*/)
{
	if (!bForce && dp == dpOld && (pDrag == NULL || pDrag->dp != dp))
		return FALSE;

	if (pDrag != NULL && pDrag->dp == dp)
	{
		// If we are within the starting dock, we want to change the size
		// along the row dependant on whether we are in the starting row.
		// If we do not keep the size the same in the starting row, the window
		// will resize on NCLButtonDown in the caption.

		int iRow;
		CSize sizeCurrent = rect.Size();
		CDockWnd* pDock = m_pManager->GetDock(dp);

		DockTranspose(dp, &sizeCurrent);
		if (!pDock->IsInsert(rect, &iRow, FALSE) && iRow == pDrag->iRow)
			sizeCurrent.cx = pDrag->cAlongRow;
		else
			sizeCurrent.cx = pDrag->cAlongOther;
		DockTranspose(dp, &sizeCurrent);

		rect.right = rect.left + sizeCurrent.cx;
		rect.bottom = rect.top + sizeCurrent.cy;
	}

	if (bForce || dp != dpOld)
	{
	    switch (dp)
	    {
	    case dpNil:
	    default:
	        ASSERT(dp == dpNil);
	        rect.bottom = rect.top + size.cy;
	        rect.right = rect.left + size.cx;
	        if ((dpOld == dpTop && rect.top < rectClient.top) ||
	            (dpOld == dpBottom && rect.top < rectClient.bottom))
	        {
	            ASSERT(m_bCanHorz);
	            rect.bottom = rectOld.bottom;
	            rect.top = rect.bottom - size.cy;
	        }
	        else if ((dpOld == dpLeft && rect.left < rectClient.left) ||
	            (dpOld == dpRight && rect.left < rectClient.right))
	        {
	            ASSERT(m_bCanVert);
	            rect.right = rectOld.right;
	            rect.left = rect.right - size.cx;
	        }
	        break;

	    case dpTop:
	    case dpBottom:
	        if (bWasOutside == (dp == dpTop))
	            rect.top = rect.bottom - size.cy;
	        else
	            rect.bottom = rect.top + size.cy;

	        rect.right = rect.left + size.cx;

	        if (pt.y < rect.top)
	        {
	            rect.top = pt.y - g_mt.cyFrame;
	            rect.bottom = rect.top + size.cy;
	        }
	        if (pt.y > rect.bottom)
	        {
	            rect.bottom = pt.y + g_mt.cyFrame;
	            rect.top = rect.bottom - size.cy;
	        }
	        break;

	    case dpLeft:
	    case dpRight:
	        if (bWasOutside == (dp == dpLeft))
	            rect.left = rect.right - size.cx;
	        else
	            rect.right = rect.left + size.cx;

	        rect.bottom = rect.top + size.cy;

	        if (pt.x < rect.left)
	        {
	            rect.left = pt.x - g_mt.cxFrame;
	            rect.right = rect.left + size.cx;
	        }
	        if (pt.x > rect.right)
	        {
	            rect.right = pt.x + g_mt.cxFrame;
	            rect.left = rect.right - size.cx;
	        }
	        break;
	    } // switch (dp)
	}

    if (pt.x < rect.left || pt.x > rect.right)
    {
        int cx = rect.Width();

        rect.left = pt.x - cx / 2;
        rect.right = rect.left + cx;
    }

    if (pt.y < rect.top || pt.y > rect.bottom)
    {
        int cy = rect.Height();

        rect.top = pt.y - cy / 2;
        rect.bottom = rect.top + cy;
    }

	return TRUE;
}

//  CDockWorker::DrawTrackRect
//      Given a DC, and one or two rect-DOCKPOS pair(s), inverts the
//      specified drag rect(s) (with width dependant on DOCKPOS).  Two
//      rects for minimal flicker.

void CDockWorker::DrawTrackRect(CDC* pdc,
	DOCKPOS dp, const CRect* prect, BOOL bChildRect /*=TRUE*/,
	DOCKPOS dpLast /*=dpNil*/, const CRect* prectLast /*=NULL*/,
	BOOL bChildRectLast /*=TRUE*/)
{
    CSize size(g_mt.cxBorder, g_mt.cyBorder);
    CSize sizeLast(g_mt.cxBorder, g_mt.cyBorder);
	CBrush *pbr;

	CBrush* pbrSolid = GetSysBrush(CMP_COLOR_HILITE);
	CBrush* pbrHalf = CDC::GetHalftoneBrush();
	if (pbrSolid == NULL || pbrHalf == NULL)
		return;

	pbr = pbrSolid;
    CRect rect = *prect;
    if (dp == dpNil)
    {
		pbr = pbrHalf;
    	if (bChildRect)
    		CPaletteWnd::GetPaletteRect(rect);

        size.cx = g_mt.cxFrame - g_mt.cxBorder;
        size.cy = g_mt.cyFrame - g_mt.cyBorder;
    }
	prect = &rect;

    CRect	rectLast;
	CBrush	*pbrLast = NULL;

    if (prectLast != NULL)
    {
		pbrLast = pbrSolid;
        rectLast = *prectLast;
        if (dpLast == dpNil)
        {
			pbrLast = pbrHalf;
	    	if (bChildRectLast)
	    		CPaletteWnd::GetPaletteRect(rectLast);

            sizeLast.cx = g_mt.cxFrame - g_mt.cxBorder;
            sizeLast.cy = g_mt.cyFrame - g_mt.cyBorder;
        }
		prectLast = &rectLast;
    }

	pdc->DrawDragRect(prect, size, prectLast, sizeLast, pbr, pbrLast);
}

//	CDockWorker::GetMoveSize
//		Calls the window for the dock snapping sizes.

CSize CDockWorker::GetMoveSize(DOCKPOS dp, CSize size)
{
	ASSERT(m_pWnd != NULL);

	if ((m_pWnd->GetStyle() & DWS_STRETCHY) != 0)
	{
		if (dp == dpLeft || dp == dpRight || dp == dpVertInit)
			size.cx = m_sizeLastStretch.cx;
		else if (dp == dpTop || dp == dpBottom || dp == dpHorzInit)
			size.cy = m_sizeLastStretch.cy;

		return size;
	}
	else
	{
		LONG lSize = m_pWnd->SendMessage(DWM_GETMOVESIZE, (UINT) dp,
			MAKELPARAM(size.cx, size.cy));

		if (lSize)
			return CSize((short) LOWORD(lSize), (short) HIWORD(lSize));
		else
			return size;
	}
}

//	CDockWorker::GetTrackSize
//		Calls the window for the sizing snap sizes.

CSize CDockWorker::GetTrackSize(UINT nHitTest, CSize size)
{
	ASSERT(m_pWnd != NULL);

	LONG lSize = m_pWnd->SendMessage(DWM_GETTRACKSIZE, nHitTest,
		MAKELPARAM(size.cx, size.cy));

	if (lSize)
		return CSize((short) LOWORD(lSize), (short) HIWORD(lSize));
	else
		return size;
}

//	CDockWorker::SaveStretchSize
//		Saves the current window size into m_sizeLastStretch.

void CDockWorker::SaveStretchSize()
{
	ASSERT(m_pWnd != NULL);
#ifdef _DEBUG
	CWnd* pWndParent = m_pWnd->GetParent();
 	ASSERT(pWndParent != NULL &&
		pWndParent->IsKindOf(RUNTIME_CLASS(CDockWnd)));
#endif

	CRect rect;
	m_pWnd->GetWindowRect(rect);
	if (m_dp == dpLeft || m_dp == dpRight)
		m_sizeLastStretch.cx = rect.Width();
	else if (m_dp == dpTop || m_dp == dpBottom)
		m_sizeLastStretch.cy = rect.Height();
}

//	CDockWorker::SaveFloatPos
//		Saves the current window position into the m_rectFloat.

void CDockWorker::SaveFloatPos()
{
	if (m_pWnd == NULL)
		return;

#ifdef _DEBUG
	if(m_dp!=dpEmbedded)
	{
		CWnd* pWndParent = m_pWnd->GetParent();
		ASSERT(pWndParent != NULL &&
			pWndParent->IsKindOf(RUNTIME_CLASS(CPaletteWnd)));
	}
#endif

	// Never save positions the leave us off screen.
    m_pWnd->GetWindowRect(m_rectFloat);
	if(m_dp!=dpEmbedded)
	{
		CPaletteWnd::GetPaletteRect(m_rectFloat);
		ForceRectOnScreen(m_rectFloat);
		CPaletteWnd::GetChildRect(m_rectFloat);
	}

    m_bPosition = FALSE;
}

//	CDockWorker::SaveMDIPos
//		Saves the current desk window position into m_pDeskPlace.

void CDockWorker::SaveMDIPos()
{
	// Do nothing if there is no window, or we already have place info.
	// Thus it is necessary to clear the old information before calling
	// this.

	if (m_pWnd == NULL)
		return;

	ASSERT(m_pDeskPlace == NULL);

	CMDIChildDock* pMDIChild = (CMDIChildDock*) m_pWnd->GetParent();
	ASSERT(pMDIChild != NULL &&
		pMDIChild->IsKindOf(RUNTIME_CLASS(CMDIChildDock)));

	m_pDeskPlace = new DESKPLACEMENT;
	m_pDeskPlace->place.length = sizeof(WINDOWPLACEMENT);
	pMDIChild->GetWindowPlacement(&m_pDeskPlace->place);
}

void CDockWorker::SaveDockPos(BOOL bRelative /*=TRUE*/)
{
	// Do nothing if there is no window, or we already have place info.
	// Thus it is necessary to clear the old information before calling
	// this.

	if (m_pWnd == NULL)
		return;

	SaveStretchSize();

	ASSERT((bRelative && m_pDockPlace == NULL) ||
		   (!bRelative && m_pDockSerial == NULL));	// otherwise we leak.

	CDockWnd* pDock = (CDockWnd*) m_pWnd->GetParent();
	ASSERT(pDock != NULL &&
		pDock->IsKindOf(RUNTIME_CLASS(CDockWnd)));

	if (bRelative)
	{
		m_pDockPlace = new DOCKPLACEMENT;
		m_pDockPlace->dp = m_dp;
		pDock->GetDockRestore(&m_pDockPlace->drRelative, m_pWnd);
	}
	else
	{
		m_pDockSerial = new DOCKPLACEMENT;
		m_pDockSerial->dp = dpNil;
		m_pWnd->GetWindowRect(&m_pDockSerial->rectAbsolute);
		pDock->ScreenToClient(&m_pDockSerial->rectAbsolute);
	}
}

//	CDockWorker::GetFloatSize
//		Returns the size in m_rectFloat, unless the window still has the
//		position bit set, in which case it uses the current size.

CSize CDockWorker::GetFloatSize()
{
	ASSERT(m_pWnd != NULL);

	if (!m_bPosition || !IsVisible())
		return m_rectFloat.Size();
	else
	{
		CRect rect;
		m_pWnd->GetWindowRect(rect);
		return rect.Size();
	}
}

//	CDockWorker::GetFloatRect
//		Returns the rect in m_rectFloat, unless the window still has the
//		position bit set, in which case it uses the current window rect.

void CDockWorker::GetFloatRect(CRect& rect)
{
	ASSERT(m_pWnd != NULL);

	if (m_bPosition)
	{
		if (IsVisible())
			m_pWnd->GetWindowRect(m_rectFloat);
		else
		{
			CRect rectDummy;
			m_pManager->GetDeskRects(m_rectFloat, rectDummy);
			m_rectFloat.OffsetRect(20, 20);	// Semi-random choice.
			// This thing had better be able to size itself!
		}
	}

	CSize size = GetMoveSize(dpNil, GetFloatSize());
	m_rectFloat.right = m_rectFloat.left + size.cx;
	m_rectFloat.bottom = m_rectFloat.top + size.cy;
	rect = m_rectFloat;
}

//	CDockWorker::GetMaxState

MAX_STATE CDockWorker::GetMaxState()
{
	DOCKPOS dp = GetDock();
	switch (dp)
	{
	case dpLeft:
	case dpRight:
	case dpTop:
	case dpBottom:
		//BLOCK:
		{
			CDockWnd* pDock = m_pManager->GetDock(dp);
			if (pDock != NULL)
			{
				ASSERT_VALID(m_pWnd);
				return pDock->GetMaxState(m_pWnd);
			}
		}
		break;
	}

	return stateDisabled;
}

//	CDockWorker::MaximizeRestore

void CDockWorker::MaximizeRestore()
{
	DOCKPOS dp = GetDock();
	switch (dp)
	{
	case dpLeft:
	case dpRight:
	case dpTop:
	case dpBottom:
		//BLOCK:
		{
			CDockWnd* pDock = m_pManager->GetDock(dp);
			if (pDock != NULL)
			{
				ASSERT_VALID(m_pWnd);
				pDock->MaximizeRestore(m_pWnd);
			}
		}
		break;
	}
}

void CDockWorker::Associate(BOOL bHost, UINT nID)
{
	m_bHost=bHost;
	m_nIDAssociate=nID;
}

///////////////////////////////////////////////////////////////////////////////
//  CDockManager
//      The dock manager is responsible for the overall dock management
//      associated with a CFrameWnd that requires docking services.  It
//      keeps track of all dockable windows associated with a frame, as
//      well as all floating palettes, and the docks.  The manager also
//      provides a forwarding point for messages between dockable windows
//      and their dock workers (mostly for external users of the docks).

//	CDockManager::Serialize
//		Load/Saves a dock manager to disk.

void CDockManager::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		m_listWorker.Serialize(ar);

	    for (int i = 0; i < dpCount - 1; i++)
	    {
    		ar << (DWORD) (LPVOID) m_rgpDock[i];

	    	if (m_rgpDock[i] != NULL)
	    		ar << m_rgpDock[i];
	    }
	}
	else
	{
		DWORD dw;

		m_listWorker.Serialize(ar);

	    for (int i = 0; i < dpCount - 1; i++)
	    {
	    	ar >> dw;
	    	m_rgpDock[i] = (CDockWnd*) (LPVOID) dw;

	    	if (m_rgpDock[i] != NULL)
	    		ar >> m_rgpDock[i];
	    }
	}
}

//  CDockManager::CDockManager
//		Construction.
//      Note: rect is not actually a rect, it specifies the  border on
//      each side of pFrame's client area, used by border windows other
//      than the CDockWnds (e.g. status bar).

CDockManager::CDockManager()
{
	m_pFrame = NULL;
	m_pView = NULL;
    m_bVisible = FALSE;
    m_bDelayedShow = FALSE;
	m_bInDocObjectMode = FALSE;
	m_bAvailableWndDirty = FALSE;

    for (int i = 0; i < dpCount; i++)
        m_rgpDock[i] = NULL;    // defer creation.

	m_mapCmdToWorker.InitHashTable(29);
}

//	CDockManager::~CDockManager
//		Destructor.  Removes all windows, and destroys all docks.

CDockManager::~CDockManager()
{
	ShowManager(FALSE);

	CObArray aWorkers;
	ArrayOfType(dtEmbeddedToolbar, &aWorkers, FALSE, FALSE);

	for(int i=0; i<aWorkers.GetSize(); ++i)
	{
		CDockWorker *pWorker=(CDockWorker*)aWorkers[i];
		POSITION pos;
		WorkerFromID(pWorker->m_nIDWnd, &pos);
		RemoveWorker(pWorker, pos);
	}

	while (!m_listWorker.IsEmpty())
	{
		RemoveWorker((CDockWorker*) m_listWorker.GetHead(),
			m_listWorker.GetHeadPosition());
	}

    ASSERT(m_listFloat.IsEmpty());
	ASSERT(m_listDesk.IsEmpty());

    for (i = 0; i < dpCount; i++)
        delete m_rgpDock[i];
}

//	CDockManager::Create
//		Initializes the dock manager for the information loaded from
//		deserialization, or let clients register defaults if we have
//		no workers.

BOOL CDockManager::Create(CFrameWnd* pFrame, CWnd* pView,
	CDockManager* pManagerOld /*=NULL*/)
{
	ASSERT(pFrame != NULL);
    m_pFrame = pFrame;
	m_pView = pView;

	// Make sure we are z-ordered below bottom-most CControlBar.
	const CWnd* pWndAfter = &CWnd::wndTop;
	for (CWnd* pWndNext = m_pFrame->GetTopWindow(); pWndNext != NULL;
		pWndNext = pWndNext->GetWindow(GW_HWNDNEXT))
	{
		if (pWndNext->IsKindOf(RUNTIME_CLASS(CControlBar)))
			pWndAfter = pWndNext;
	}

	// Create the docks.
    for (int i = 0; i < dpCount; i++)
    {
    	if (m_rgpDock[i] != NULL && m_rgpDock[i]->m_nRows > 0)
		{
    		if (m_rgpDock[i]->Create(m_pFrame, IDR_DOCKBASE + i, this))
			{
				m_rgpDock[i]->SetWindowPos(pWndAfter, 0, 0, 0, 0,
					SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
				pWndAfter = m_rgpDock[i];
			}
		}
    }

	POSITION pos1, pos2, posTmp;
	CDockWorker *pDocker1, *pDocker2;

	// If we are transfering from an existing manager, transfer any already
	// existing windows.

	if (pManagerOld == NULL)
	{
		// Get info from packages.
		HGLOBAL hglob;

		POSITION pos = theApp.m_packages.GetHeadPosition();
		while (pos != NULL)
		{
			CPackage* pGrp = (CPackage*)theApp.m_packages.GetNext(pos);
			if ((hglob = pGrp->GetDockInfo()) == NULL)
				continue;

			UINT FAR* lpnInfoCount = (UINT FAR*)GlobalLock(hglob);
			DOCKINIT FAR* lpdiArray = (DOCKINIT FAR*)(lpnInfoCount + 1);

			RegisterInfo(*lpnInfoCount, lpdiArray);

			GlobalUnlock(hglob);
			GlobalFree(hglob);
		}
	}
	else
	{
		pManagerOld->ShowManager(FALSE, updNoRecalc);

		// Transfer windows between managers, and make sure the new manager
		// has the same workers as the old manager.  User may have made custom
		// toolbar changes in the old manager.
		//
		pos1 = m_listWorker.GetHeadPosition();
		pos2 = pManagerOld->m_listWorker.GetHeadPosition();

		while (pos1 != NULL && pos2 != NULL)
		{
		    pDocker1 = (CDockWorker*) m_listWorker.GetAt(pos1);
		    pDocker2 = (CDockWorker*) pManagerOld->m_listWorker.GetAt(pos2);

        	pDocker1->SetManager(this);	// So DeparentWindow works.

		    if (DkCompareIDs(pDocker1->m_nIDWnd, pDocker2->m_nIDWnd) < 0)
		    {
				// Remove new worker with no match in current layout.
		    	posTmp = pos1;
		    	m_listWorker.GetNext(pos1);
		    	m_listWorker.RemoveAt(posTmp);
				delete pDocker1;
		    }
		    else
		    {
		    	if (pDocker1->m_nIDWnd != pDocker2->m_nIDWnd)
				{
					pDocker2->PreTransfer(this);
		    		m_listWorker.InsertBefore(pos1, pDocker2);
				}
				else
				{
					m_listWorker.GetNext(pos1);
					pDocker1->Reset(pDocker2);
			    	delete pDocker2;
			    }

		    	posTmp = pos2;
		    	pManagerOld->m_listWorker.GetNext(pos2);
		    	pManagerOld->m_listWorker.RemoveAt(posTmp);
		    }
		}

		// Remove remaining new workers with no match in the current layout.
		while (pos1 != NULL)
		{
	    	posTmp = pos1;
	    	delete m_listWorker.GetNext(pos1);
	    	m_listWorker.RemoveAt(posTmp);
		}

		// Add to new layout remaining workers in current layout with no match
		// in new layout.
		while (pos2 != NULL)
		{
	    	posTmp = pos2;
		    pDocker2 = (CDockWorker*) pManagerOld->m_listWorker.GetNext(pos2);

			pDocker2->PreTransfer(this);

	    	pManagerOld->m_listWorker.RemoveAt(posTmp);
	    	m_listWorker.AddTail(pDocker2);
	    }
	}

	// Now Create the visible dock workers to ensure their m_pWnds, and
	// position them.

	CObArray aWnd;
	CWordArray anShow;
	CWnd* pWndMDITop = ((CMainFrame*) m_pFrame)->MDIGetActive();
	CPartFrame::LockWorkspace(TRUE);

	pos1 = m_listWorker.GetHeadPosition();
    while (pos1 != NULL)
    {
        pDocker1 = (CDockWorker*) m_listWorker.GetAt(pos1);
		ASSERT(pDocker1 != NULL);

		// If this is our first manager, load data from the Reg DB.  Also,
		// remove any dockable windows whose packages no longer exist.
		if (pManagerOld == NULL)
		{
			if (theApp.GetPackage(pDocker1->m_nIDPackage) == NULL)
			{
				posTmp = pos1;
				delete m_listWorker.GetNext(pos1);
				m_listWorker.RemoveAt(posTmp);
				continue;
			}

			pDocker1->LoadData();
		}

		if (pDocker1->m_pWnd == NULL &&	pDocker1->m_hglobInit == NULL &&
			pDocker1->m_nIDPackage == PACKAGE_SUSHI &&
			LOWORD(pDocker1->m_nIDWnd) >= IDTB_CUSTOM_BASE)
		{
			// Remove non-existent custom toolbars.
	    	posTmp = pos1;
    		delete m_listWorker.GetNext(pos1);
	    	m_listWorker.RemoveAt(posTmp);
		}
        else
		{
			pDocker1->SetManager(this);	// Just to be sure this happens.

			if (!pDocker1->IsVisible() && pDocker1->m_pWnd != NULL &&
				pDocker1->m_dtWnd == dtEdit)
			{
				if (pDocker1->m_pWnd->GetParent() == pWndMDITop)
					pWndMDITop = NULL;

				if (pDocker1->IsDestroyOnHide())
				{
					pDocker1->DestroyWindow();
					ASSERT(pDocker1->m_pWnd == NULL);
				}
			}
			
			// If the window was available before, check again now to avoid window flash.
			if (pDocker1->IsVisible() && pDocker1->m_bAsk)
			{
				CPackage* pGrp = theApp.GetPackage(pDocker1->m_nIDPackage);
				if (pGrp != NULL)
					pDocker1->m_bAvailable = pGrp->AskAvailable(LOWORD(pDocker1->m_nIDWnd));
			}

			if (pDocker1->IsVisible() || pDocker1->m_pWnd != NULL)
			{
				WORD wShow = (pDocker1->m_pDeskPlace == NULL) ?
					 (WORD) -1 : (WORD) pDocker1->m_pDeskPlace->place.showCmd;

				if (pDocker1->Create(this) &&
					pDocker1->GetDock() == dpMDI &&	pDocker1->IsVisible())
				{
					aWnd.Add(pDocker1->m_pWnd);
					anShow.Add(wShow);
				}
			}

			pDocker1->EndLoad();

    		m_listWorker.GetNext(pos1);
		}
    }

	// Deal with MDI windows.
	CPartFrame::LockWorkspace(FALSE);

	ASSERT(anShow.GetSize() == aWnd.GetSize());
	int nCount = anShow.GetSize();
	if (nCount > 0)
	{
		((CMainFrame*) m_pFrame)->m_pWndMDIClient->ShowWindow(SW_HIDE);

		// Show the windows.
		CWnd* pMDIChild = NULL;

		for (i = 0; i < nCount; i++)
		{
			if (aWnd[i] == NULL || anShow[i] == (WORD) -1)
				continue;

			pMDIChild = ((CWnd*) aWnd[i])->GetParent();
			ASSERT(pMDIChild != NULL &&
				pMDIChild->IsKindOf(RUNTIME_CLASS(CMDIChildDock)));

			if (anShow[i] == SW_SHOWMAXIMIZED && !theApp.m_bMaximizeDoc)
				pMDIChild->ShowWindow(SW_SHOW);
			else
			{
				// DS96 #17641 [CFlaat]: need to override recorded placement in the maximization case as well as the non-maximization case!
				if (theApp.m_bMaximizeDoc)
					pMDIChild->ShowWindow(SW_SHOWMAXIMIZED);
				else
					pMDIChild->ShowWindow(anShow[i]);
			}
		}

		if (pWndMDITop != NULL)
			pWndMDITop->BringWindowToTop();
		else if (pMDIChild != NULL)
			pMDIChild->BringWindowToTop();

		((CMainFrame*) m_pFrame)->m_pWndMDIClient->ShowWindow(SW_SHOWNA);
	}

	// Make sure a window that was hidden by the switch does not
	// stay the active worker.
	pDocker1 = CDockWorker::s_pActiveDocker;
	if (pDocker1 != NULL && !pDocker1->IsVisible())
	{
		CDockWorker::s_bLockDocker = FALSE;
		CDockWorker::s_pActiveDocker->OnWindowActivate(FALSE, m_pFrame);

		// Set focus to the main frame only if we had the focus.
		CWnd* pWndFocus = CWnd::GetFocus();
		CWnd* pWndDocker = pDocker1->m_pWnd;
		if (pWndDocker == pWndFocus || pWndDocker->IsChild(pWndFocus))
			m_pFrame->SetFocus();

	}

	m_bAvailableWndDirty = TRUE;

	return TRUE;
}

void CDockManager::SaveWorkers()
{
	CDockWorker* pDocker;

    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        pDocker = (CDockWorker*) m_listWorker.GetNext(pos);
		pDocker->SaveData();
    }
}

//  CDockManager::GetDock
//      Given a DOCKPOS, returns a pointer the CDockWnd for that pos.  If the
//      CDockWnd does not yet exist it is created.

CDockWnd* CDockManager::GetDock(DOCKPOS dp)
{
	ASSERT(m_pFrame != NULL);
    ASSERT(dpFirst <= dp && dp < dpFirst + dpCount);
    int iDock = dp - dpFirst;

    if (m_rgpDock[iDock] == NULL)
        m_rgpDock[iDock] = new CDockWnd(dp);

	if (m_rgpDock[iDock]->m_hWnd == NULL)
	{
        if (!m_rgpDock[iDock]->Create(m_pFrame, IDR_DOCKBASE + iDock, this))
            return NULL;

		// Make sure we are z-ordered below bottom-most CControlBar.
		const CWnd* pWndAfter = &CWnd::wndTop;
		for (CWnd* pWndNext = m_pFrame->GetTopWindow(); pWndNext != NULL;
			pWndNext = pWndNext->GetWindow(GW_HWNDNEXT))
		{
			if (pWndNext->IsKindOf(RUNTIME_CLASS(CControlBar)))
				pWndAfter = pWndNext;
		}

        for (int i = 0; i < iDock; i++)
        {
            if (m_rgpDock[i]->GetSafeHwnd() != NULL)
				pWndAfter = m_rgpDock[i];
        }

		// place new dock in correct z-order.
		m_rgpDock[iDock]->SetWindowPos(pWndAfter, 0, 0, 0, 0,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);

        // position new dock
        if (dp != dpHide)
        {
	        m_pFrame->RecalcLayout();
	        if (!m_bVisible)
				m_rgpDock[iDock]->ShowWindow(SW_HIDE);	// Created visible for repositioning.
		}
    }

    return m_rgpDock[iDock];
}

//  CDockManager::GetDeskRects
//      For CDockWnd::TrackMove, this function returns two rectangles used
//      to calculate the snapping rects for dragging.

void CDockManager::GetDeskRects(CRect& rectDesk, CRect& rectClient)
{
    m_pView->GetWindowRect(rectDesk);

    rectClient = rectDesk;

    // displace client rect with any dockwnds
    CRect rect;
    if (m_rgpDock[dpLeft - dpFirst]->GetSafeHwnd() != NULL)
    {
        m_rgpDock[dpLeft - dpFirst]->GetWindowRect(rect);
        rectClient.left = rect.left + g_mt.cxBorder;
    }
    if (m_rgpDock[dpTop - dpFirst]->GetSafeHwnd() != NULL)
    {
        m_rgpDock[dpTop - dpFirst]->GetWindowRect(rect);
        rectClient.top = rect.top + g_mt.cxBorder;
    }
    if (m_rgpDock[dpRight - dpFirst]->GetSafeHwnd() != NULL)
    {
        m_rgpDock[dpRight - dpFirst]->GetWindowRect(rect);
        rectClient.right = rect.right - g_mt.cxBorder;
    }
    if (m_rgpDock[dpBottom - dpFirst]->GetSafeHwnd() != NULL)
    {
        m_rgpDock[dpBottom - dpFirst]->GetWindowRect(rect);
        rectClient.bottom = rect.bottom - g_mt.cxBorder;
    }
}

UINT CDockManager::GetCustomID()
{
	CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetTail();

	return max(IDTB_CUSTOM_BASE, LOWORD(pDocker->m_nIDWnd)) + 1;
}

//	CDockManager::RegisteInfo
//		Used for client to register a block of dock workers.

void CDockManager::RegisterInfo(UINT nInfoCount, DOCKINIT FAR* lpdi)
{
	for (UINT i = 0; i < nInfoCount; i++, lpdi++)
		RegisterWnd((CWnd*) NULL, lpdi);
}

CDockWorker* CDockManager::RegisterToolbar(DOCKINIT FAR* lpdi,
	TOOLBARINIT FAR* lptbi, UINT FAR* lpIDArray)
{
	ASSERT(lpdi != NULL && lptbi != NULL);

	CASBar* pBar = new CASBar;
	if (!pBar->Create(NULL, this, WS_BORDER, lptbi,
			lpIDArray, NULL, TRUE, lpdi))
	{
		delete pBar;
		return NULL;
	}

	return WorkerFromID(lpdi->nIDWnd);
}

CDockWorker* CDockManager::RegisterWnd(HWND hwnd, DOCKINIT FAR* lpdi)
{
	ASSERT(lpdi != NULL);

	CDockWorker* pDocker = NULL;
	DOCKTYPE dt = lpdi->dt;

	switch (dt)
	{
	case dtHwnd:
		return RegisterWnd(CWnd::FromHandlePermanent(hwnd), lpdi);

	case dtBorder:
	case dtEdit:
		if (hwnd == NULL)
			 return RegisterWnd((CWnd*) NULL, lpdi);
		else
		{
			CBorderBar* pBar = new CBorderBar;
			DWORD dwStyle = 0x0F & ::GetWindowLong(hwnd, GWL_STYLE);
			if (!pBar->Create(NULL, this, dwStyle, hwnd,
				MAKEDOCKID(lpdi->nIDPackage, lpdi->nIDWnd),
				TRUE, lpdi))
			{
				delete pBar;
				return NULL;
			}

			if (pDocker == NULL)
			{
				ASSERT(lpdi != NULL);
				pDocker = WorkerFromWindow(pBar);
			}
		}
		break;

	default:
		// Use other functions for other types.
		ASSERT(FALSE);
		break;
	}

    return pDocker;
}

//  CDockManager::RegisterWnd
//      For internal use (CWnd already created), creates a DockWorker
//      for the window, and returns a pointer.

CDockWorker* CDockManager::RegisterWnd(CWnd* pWnd, DOCKINIT FAR* lpdi)
{
	ASSERT(lpdi != NULL);

	POSITION pos;
	CDockWorker* pDocker = WorkerFromID(MAKEDOCKID(lpdi->nIDPackage,
		lpdi->nIDWnd), &pos);

	if ((lpdi->fInit & INIT_REMOVE) != 0)
	{
		if (pDocker != NULL)
			RemoveWorker(pDocker, pos);

		return NULL;
	}
	else if (pDocker == NULL)
	{
		ASSERT(lpdi != NULL);
		pDocker = new CDockWorker(lpdi);
	}
	else if (pDocker->m_pWnd == NULL)
	{
		pDocker->Reset(lpdi);
	}

	if (pDocker->m_pWnd != NULL)
		return pDocker;

	if (pWnd == NULL)
		pDocker->SetManager(this);
	else if (!pDocker->Create(this, pWnd, (lpdi->fInit & INIT_VISIBLE) != 0))
	{
		if (pos != NULL)
			m_listWorker.RemoveAt(pos);

		delete pDocker;
		return NULL;
	}

	if (pos == NULL)
		InsertWorker(pDocker);

    return pDocker;
}

//	CDockManager::InsertWorker
//		Inserts a worker into the list in sorted order.

void CDockManager::InsertWorker(CDockWorker* pDocker)
{
	CDockWorker* pDockerNext;
    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        pDockerNext = (CDockWorker*) m_listWorker.GetAt(pos);
        if (DkCompareIDs(pDockerNext->m_nIDWnd, pDocker->m_nIDWnd) > 0)
            break;

        m_listWorker.GetNext(pos);
    }

	if (pos == NULL)
		m_listWorker.AddTail(pDocker);
	else
		m_listWorker.InsertBefore(pos, pDocker);
}

//  CDockManager::RemoveWnd
//      Given window pointer, removes the window from the registered list,
//		destroying its dock worker.

void CDockManager::RemoveWnd(CWnd* pWnd)
{
    POSITION pos;
    CDockWorker* pDocker = WorkerFromWindow(pWnd, &pos);
    if (pDocker == NULL)
    {
    	TRACE0("Warning: Attemping to remove unregistered dockable window.\n");
    	return;
    }

    RemoveWorker(pDocker, pos);
}

//  CDockManager::RemoveWnd
//      Given window ID, removes the window from the registered list,
//		destroying its dock worker.

void CDockManager::RemoveWnd(UINT nID)
{
    POSITION pos;
    CDockWorker* pDocker = WorkerFromID(nID, &pos);
    if (pDocker == NULL)
    {
    	TRACE0("Warning: Attemping to remove unregistered dockable window.\n");
    	return;
    }

    RemoveWorker(pDocker, pos);
}

//	CDockManager::RemoveWorker
//		Given a pointer to a worker, and its position in the list, removes
//		the worker from the list, also handling destruction of the window,
//		and palette (if floating).

void CDockManager::RemoveWorker(CDockWorker* pDocker, POSITION pos)
{
	ASSERT_VALID(pDocker);

	if (CASBar::s_pCustomizer != NULL &&
		CASBar::s_pCustomizer->m_pDialog != NULL)
	{
		// If we have a CToolbar dialog, update the checklist.
		if (CASBar::s_pCustomizer->m_pDialog->
			IsKindOf(RUNTIME_CLASS(CToolbarDialog)))
		{
			ASSERT(pDocker->m_nIDPackage == PACKAGE_SUSHI &&
				LOWORD(pDocker->m_nIDWnd) >= IDTB_CUSTOM_BASE);
			((CToolbarDialog*) CASBar::s_pCustomizer->m_pDialog)->
				RemoveToolbar(pDocker);
		}
	}

    m_listWorker.RemoveAt(pos);

	if (m_bVisible)
		pDocker->ShowWindow(FALSE);

    delete pDocker;
}

// returns 0 if message is successfully processed, and -1 if not.
LONG CDockManager::WorkerMessage(UINT message, HWND hwnd, LPARAM lParam)
{
    ASSERT(hwnd != NULL);

    POSITION pos;
    CDockWorker* pDocker;
    CWnd* pWnd = CWnd::FromHandlePermanent(hwnd);

    if ((pDocker = WorkerFromWindow(pWnd, &pos)) == NULL)
    {
    	TRACE0("Warning: Unable to find worker to handle message.\n");
        return 0L;
    }

    return pDocker->OnMessage(message, lParam);
}

//  CDockManager::WorkerFromWindow
//      Given a window pointer, returns a pointer to the dock worker that
//      corresponds to the window, as well as the postition of the window in
//      the registration list.

CDockWorker* CDockManager::WorkerFromWindow(CWnd* pWnd,
	POSITION* posFinal /*=NULL*/)
{
	if (pWnd == NULL)
		return NULL;

    CDockWorker* pDocker;

    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        pDocker = (CDockWorker*) m_listWorker.GetAt(pos);
        if (pDocker->m_pWnd == pWnd)
            break;

        m_listWorker.GetNext(pos);
    }

    if (posFinal != NULL)
    	*posFinal = pos;

    return (pos == NULL) ? NULL : pDocker;
}

//  CDockManager::WorkerFromID
//      Given a window ID, returns a pointer to the dock worker that
//      corresponds to the window, as well as the postition of the window in
//      the registration list.

CDockWorker* CDockManager::WorkerFromID(UINT nID,
		POSITION* posFinal /*=NULL*/)
{
    CDockWorker* pDocker;

    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        pDocker = (CDockWorker*) m_listWorker.GetAt(pos);
        if (pDocker->m_nIDWnd == nID)
            break;

        m_listWorker.GetNext(pos);
    }

    if (posFinal != NULL)
    	*posFinal = pos;

    return (pos == NULL) ? NULL : pDocker;
}

//	CDockManager::ShowMenu
//		Shows the manager popup (with all available, registered windows)
//		at the specied point on the screen.

void CDockManager::ShowMenu(CPoint pt)
{
	CString str;

	CObArray aWorkers;
	ArrayOfType(dtEmbeddedToolbar, &aWorkers, TRUE, TRUE);

	int nWorkers = min(aWorkers.GetSize(),
		IDM_DOCKSHOW_LAST - IDM_DOCKSHOW_BASE + 1);

	if (nWorkers > 0)
	{
        CBMenuPopup menuPopup ;
		CDockWorker* pDocker;
		BOOL bSeparate = FALSE;

		for (int i = 0; i < nWorkers; i++)
		{
			pDocker = (CDockWorker*) aWorkers[i];
			if (pDocker->GetDock() == dpMDI)
				continue;

			// don't add the menu bar to the popup menu, unless we are in full screen mode
			if (LOWORD(((CDockWorker*) aWorkers[i])->m_nIDWnd) == IDTB_MENUBAR &&
				!IS_STATE_FULLSCREEN(DkGetDockState()))
				continue;

			// Separate windows from toolbars.
			if (LOWORD(((CDockWorker*) aWorkers[i])->m_nIDWnd) < IDTB_SHELL_BASE)
				bSeparate = TRUE;
			if (bSeparate && (LOWORD(((CDockWorker*) aWorkers[i])->m_nIDWnd) >= IDTB_SHELL_BASE))
			{
				menuPopup.AppendMenu(MF_SEPARATOR);
				bSeparate = FALSE;
			}

			pDocker->GetText(str);

			ASSERT(!str.IsEmpty());

			menuPopup.AppendMenu((pDocker->IsVisible() ? MF_CHECKED : MF_STRING),
				IDM_DOCKSHOW_BASE + i, str);
		}

		menuPopup.AppendMenu(MF_SEPARATOR);

		str.LoadString(IDS_POPUP_CUSTOMIZE);
		menuPopup.AppendMenu(CASBar::s_pCustomizer ? MF_GRAYED : MF_STRING,
			IDM_TOOLBAR_CUSTOMIZE, str);

		menuPopup.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
			pt.x, pt.y, m_pFrame, NULL);
	}
}

//	CDockManager::ArrayOfType
//		Given a DOCKTYPE, and a pointer to an existing ObArray, adds pointers
//		to all existing windows of the type to the array.

void CDockManager::ArrayOfType(DOCKTYPE dt, CObArray* paWorkers,
	BOOL bExclude /*=FALSE*/, BOOL bAvailable /*=FALSE*/, DOCKTYPE dtAnother /*=dtNil*/)
{
	if (bAvailable && m_bAvailableWndDirty)
		IdleUpdateAvailableWnds();

    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetNext(pos);
        if ((!bAvailable || pDocker->IsAvailable()) &&
        	(dt == dtNil ||
        	(!bExclude && (pDocker->m_dtWnd == dt || pDocker->m_dtWnd == dtAnother) ) ||
        	(bExclude && (pDocker->m_dtWnd != dt && pDocker->m_dtWnd != dtAnother))))
		{
    		paWorkers->Add(pDocker);
		}
    }
}

void CDockManager::MapCmdToWorker(UINT nCmd, UINT nIDWnd)
{
	CDockWorker* pDocker = WorkerFromID(nIDWnd);
	if (pDocker != NULL)
		m_mapCmdToWorker.SetAt((WORD) nCmd, pDocker);
}

void CDockManager::HandleWorkerCmd(UINT nCmd, BOOL bToggle,
	CCmdUI* pCmdUI /*=NULL*/)
{
	CDockWorker* pDocker;
	if (!m_mapCmdToWorker.Lookup((WORD)nCmd, (CObject*&)pDocker))
	{
		if (pCmdUI != NULL)
			pCmdUI->Enable(FALSE);
	}
	else if (pCmdUI != NULL)
	{
		if (bToggle)
			pCmdUI->SetCheck(pDocker->IsVisible());
		pCmdUI->Enable(pDocker->IsAvailable());
	}
	else if (bToggle)
		pDocker->ShowWindow(!pDocker->IsVisible());
	else
		pDocker->ActivateView();
}

//	CDockManager::AddMDIChild
//		Adds a MDI child pointer to the palette list.

void CDockManager::AddMDIChild(CMDIChildDock* pMDIWnd)
{
    m_listDesk.AddHead(pMDIWnd);
}

//  CDockManager::RemoveMDIChild
//      Removes the specified MDI child from the palette list, setting its
//      child's parent to the hidden dock. (Also deletes the palette)

void CDockManager::RemoveMDIChild(CMDIChildDock* pMDIWnd,
	CWnd* pWndNewParent /*=NULL*/, CDockManager* pManagerNew /*=NULL*/)
{
    POSITION pos = m_listDesk.GetHeadPosition();
    while (pos != NULL)
    {
        CMDIChildDock* pDeskItem = (CMDIChildDock*) m_listDesk.GetAt(pos);

        if (pMDIWnd == pDeskItem)
        {
			if (pManagerNew != NULL)
			{
				pMDIWnd->SetManager(pManagerNew);
				pManagerNew->AddMDIChild(pMDIWnd);
			}
			else
			{
				if (pWndNewParent == NULL)
	            	pWndNewParent = GetDock(dpHide);
	            pMDIWnd->ParentChild(pWndNewParent);

	            pMDIWnd->DestroyWindow();  // Auto-deleting.
			}

            m_listDesk.RemoveAt(pos);
            break;
        }

        m_listDesk.GetNext(pos);
    }
}

//	CDockManager::AddPalette
//		Adds a palette pointer to the palette list.

void CDockManager::AddPalette(CPaletteWnd* pPalette)
{
    m_listFloat.AddHead(pPalette);
}

//  CDockManager::RemovePalette
//      Removes the specified palette from the palette list, setting its
//      child's parent to the hidden dock. (Also deletes the palette)

void CDockManager::RemovePalette(CPaletteWnd* pPalette,
	CWnd* pWndNewParent /*=NULL*/, CDockManager* pManagerNew /*=NULL*/)
{
    POSITION pos = m_listFloat.GetHeadPosition();
    while (pos != NULL)
    {
        CPaletteWnd* pPalItem = (CPaletteWnd*) m_listFloat.GetAt(pos);

        if (pPalette == pPalItem)
        {
			if (pManagerNew != NULL)
			{
				pPalette->SetManager(pManagerNew);
				pManagerNew->AddPalette(pPalette);
			}
			else
			{
	        	pPalette->ShowWindow(SW_HIDE);
	            CWnd* pChild = pPalette->GetTopWindow();
	            ASSERT(pChild != NULL);

				if (pWndNewParent == NULL)
	            	pWndNewParent = GetDock(dpHide);
	            pChild->SetParent(pWndNewParent);

	            pPalette->DestroyWindow();  // Auto-deleting.
			}

            m_listFloat.RemoveAt(pos);
            break;
        }

        m_listFloat.GetNext(pos);
    }
}

//	CDockManager::ActivatePalettes
//		Activates/Deactivates all palette captions.

void CDockManager::ActivatePalettes(BOOL bActive)
{
    POSITION pos = m_listFloat.GetHeadPosition();
    while (pos != NULL)
    {
        CPaletteWnd* pPalette = (CPaletteWnd*) m_listFloat.GetNext(pos);
        pPalette->ActivateWindow(bActive);
    }
}

//	CDockManager::EnableManagerInput
//		Notifies all worker windows to disable children for toolbar customize
//		mode.

void CDockManager::EnableManagerInput(BOOL bEnable)
{
    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetNext(pos);

        if (pDocker->m_pWnd != NULL)
        	pDocker->m_pWnd->SendMessage(DWM_ENABLECHILD, bEnable);
    }
}

///////////////////////////////////////////////////////////
//
//	CDockManager::ShowManager
//		Hide/Show all manager windows -- palettes & docks.
//
// bForceUpdate -	Execute the function even if we don't
//					think is is needed
//
void CDockManager::ShowManager(BOOL bShow, UPDATE_SHOW update /*=updNow*/, BOOL bForceUpdate /*= FALSE*/)
{
	if (!bForceUpdate && // Bug 14790 --- CApplication::SetVisible needs to run this function even if the current value should be correct.
		((bShow && m_bVisible) || (!bShow && !m_bVisible)))
	{
		if (update == updDelay)
			m_bDelayedShow = FALSE;

		return;
	}
	else if (update == updDelay)
	{
		m_bDelayedShow = TRUE;
		return;
	}

	m_bVisible = bShow;

    for (int i = 0; i < dpCount - 1; i++)
    {
    	if (m_rgpDock[i]->GetSafeHwnd() != NULL)
        	m_rgpDock[i]->ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
    }

    if (update == updNow)
    {
		ASSERT(m_pFrame != NULL);

		if (!m_pFrame->IsWindowVisible() || m_pFrame->IsIconic())
		{
  			// User not watching. Recalc twice, since first recalc may
  			// cause row removal in OnWindowPosChanged.
			//
			m_pFrame->RecalcLayout();
			m_pFrame->RecalcLayout();
		}
    	else if (!bShow)
    	{
		    m_pFrame->RecalcLayout();
		    m_pFrame->UpdateWindow();
    	}
    	else
    	{
    		// Might involve resizing of stretchy windows, which we don't want
    		// the user to see.  Also we recalc twice, since first recalc may
			// cause row removal in OnWindowPosChanged.
			//
	    	m_pFrame->SetRedraw(FALSE);
		    m_pFrame->RecalcLayout();
			m_pFrame->RecalcLayout();
		    m_pFrame->SetRedraw(TRUE);
	        m_pFrame->RedrawWindow(NULL, NULL,
	            RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_UPDATENOW);

			// Sprites for active view won't be painted in the RedrawWindow.
			CSlobWnd* pWnd = GetActiveSlobWnd();
			if (pWnd != NULL)
				pWnd->ObscureSprites();	// Force a redraw.
	    }
	}

	// If the frame is iconic, do not show the palettes.  We will
	// need to do this when the window is restored.
	
	if (!m_pFrame->IsIconic() 
		&& !theApp.m_bRunInvisibly) // Bug 14790 --- We don't want the floating windows appearing if the app is automated.
	{
		//Orion Bug #
		ShowPalettes(bShow, bForceUpdate);
	}
}

///////////////////////////////////////////////////////////
//
//	ShowPalettes -	Hides or shows the floating versions
//					of the docking windows.
//
// bForceUpdate -	Execute the function even if we don't
//					think is is needed
//
void CDockManager::ShowPalettes(BOOL bShow, BOOL bForceUpdate /*= FALSE*/)
{
	if (!bForceUpdate && // Bug 14790 --- CApplication::SetVisible needs to run this function even if the current value should be correct.
		((m_bVisible && !bShow) || (!m_bVisible && bShow)))
	{
		return;
	}

	// Show/hide the palettes.
	const CWnd* pWndZOrder = &CWnd::wndTop;
	if (PwndSplashScreen() != NULL)
		pWndZOrder = PwndSplashScreen();

    POSITION pos = m_listWorker.GetHeadPosition();
    while (pos != NULL)
    {
        CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetNext(pos);
        if (pDocker->GetDock() == dpNil && pDocker->IsVisible())
        {
        	ASSERT(pDocker->m_pWnd != NULL);
        	ASSERT(pDocker->m_pWnd->GetParent() != NULL);

        	CWnd* pPalette = pDocker->m_pWnd->GetParent();
        	pPalette->SetWindowPos(pWndZOrder, 0, 0, 0, 0,
        		(bShow ? SWP_SHOWWINDOW : (SWP_HIDEWINDOW | SWP_NOZORDER)) |
        		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
	        pPalette->UpdateWindow();

			pWndZOrder = pPalette;
		}
    }
}

BOOL CDockManager::DocObjectMode(BOOL bShow)
{
	if(!bShow == !m_bInDocObjectMode)
		return bShow;

	m_bInDocObjectMode = bShow;
	m_bAvailableWndDirty = TRUE; //Force update.

	if(bShow)	// If we're switching to a Doc Object
		((CMainFrame *)AfxGetMainWnd())->SaveManager();	// Save the current layout
	return !bShow; // Return value of m_bInDocObjectMode before the call
}

//  CDockManager::IdleUpdate
//      Updates command UIs for floating windows.

void CDockManager::IdleUpdate()
{
    POSITION pos = m_listFloat.GetHeadPosition();
    while (pos != NULL)
    {
        ((CPaletteWnd*) m_listFloat.GetNext(pos))->
            SendMessageToDescendants(WM_IDLEUPDATECMDUI,
				(WPARAM)TRUE, 0, TRUE, TRUE);
    }
}

//	CDockManager::UpdateAvailableWnds
//		Called at beginning of idle loop to hide/show windows that have
//		changed availability.

void CDockManager::IdleUpdateAvailableWnds()
{

	// These tests are duplicated in CDockManager::NeedIdle, we have to make sure that
	// they remain in ssync so that the Idle loop processing can remain efficient
	if (m_pFrame == NULL || m_pFrame->IsIconic())
		return;

	if (m_bAvailableWndDirty)
	{
		CMainFrame *pFrame=((CMainFrame *)theApp.m_pMainWnd);

		BOOL bLocked=pFrame->m_bLockLayout;
		((CMainFrame *)theApp.m_pMainWnd)->LockLayout(TRUE);

		m_bAvailableWndDirty = FALSE;

		// Hide unavailable LastAvailable windows first.
	    POSITION pos = m_listWorker.GetHeadPosition();
	    while (pos != NULL)
	    {
	        CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetNext(pos);

			if (pDocker->IsLastAvailable())
	        	pDocker->UpdateAvailable(FALSE);
	    }

		// Hide all other unavailable windows first; then show available ones.
		for (int i = 0; i < 2; i++)
		{
		    pos = m_listWorker.GetHeadPosition();
		    while (pos != NULL)
		    {
		        CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetNext(pos);

				if (!pDocker->IsLastAvailable())
			        pDocker->UpdateAvailable(i);
		    }
		}

		// Show available LastAvailable windows last, and in reverse order.
	    pos = m_listWorker.GetTailPosition();
	    while (pos != NULL)
	    {
	        CDockWorker* pDocker = (CDockWorker*) m_listWorker.GetPrev(pos);

			if (pDocker->IsLastAvailable())
	        	pDocker->UpdateAvailable(TRUE);
	    }

		// restore lock status
		((CMainFrame *)theApp.m_pMainWnd)->LockLayout(bLocked);
		if(!bLocked)
		{
			// if we locked it, we must force the repaint
			((CMainFrame *)theApp.m_pMainWnd)->RecalcLayout();
		}

	}

	// These tests are duplicated in CDockManager::NeedIdle, we have to make sure that
	// they remain in ssync so that the Idle loop processing can remain efficient
	if (m_bDelayedShow)
	{
		m_bDelayedShow = FALSE;
		ShowManager(!m_bVisible);
	}
}

//  CDockManager::SysColorChange
//      Updates colors for floating windows.

void CDockManager::SysColorChange()
{
    POSITION pos = m_listFloat.GetHeadPosition();
    while (pos != NULL)
    {
        ((CPaletteWnd*) m_listFloat.GetNext(pos))->
			SendMessageToDescendants(WM_SYSCOLORCHANGE, 0, 0L, TRUE, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docauto.cpp ===
// docauto.cpp: OLE automation methods for CPartDoc class
//
#include "stdafx.h"
#include "errno.h"
#include <utilauto.h>

#include "autostat.h" // g_AutomationState - Internal automation code.

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Disable warning for the bool keyword which is needed for variants.
#pragma warning(disable: 4237) //bool

//
// Helper function.
//
BOOL frameBelongsToDoc(CFrameWnd* pFrame, CDocument* pDoc) ;

/////////////////////////////////////////////////////////////////////////////
// CPartDoc OLE automation methods

// Property queries
LPDISPATCH CPartDoc::GetParent()
{
  return GetApplication(); 
}

LPDISPATCH CPartDoc::GetApplication()
{
  return theApp.m_pAutoApp->GetIDispatch(TRUE);
}

BSTR CPartDoc::GetFullName()
{
	CString strResult(GetPathName()); // call MFC's CDocument member

	return strResult.AllocSysString();
}

//
//
//
BSTR CPartDoc::GetName()
{
  CString strResult;
  TCHAR ext[_MAX_EXT];
   
  _tsplitpath(  // use generic mapping to _splitpath or _wsplitpath
    GetPathName(), // full path from CDocument
    0, // drive
    0, // dir
    strResult.GetBuffer(_MAX_FNAME), // file title
    ext); // extension

  strResult.ReleaseBuffer();
  strResult += ext;

  return strResult.AllocSysString();
}

//
//
//
BSTR CPartDoc::GetPath()
{
  CString strResult;
  TCHAR drive[_MAX_DRIVE];
   
  _tsplitpath(  // use generic mapping to _splitpath or _wsplitpath
    GetPathName(), // full path from CDocument
    drive, // drive
    strResult.GetBuffer(_MAX_DIR), // dir
    0, // file title
    0); // extension

  strResult.ReleaseBuffer();

  ASSERT(strResult.GetLength() != 0) ;

  int newLength = strResult.GetLength() - 1; 
  if (strResult[newLength] == _T('\\'))
  {
	strResult = drive + strResult.Left(newLength); // remove the trailing backslash
  }
  else
  {
	  // No Trailing backslash so don't remove.
	strResult = drive + strResult;
  }

  return strResult.AllocSysString();
}

BOOL CPartDoc::GetSaved()
{
  return !IsModified(); // since "saved" & "modified" are opposite
}

void CPartDoc::SetSaved(BOOL bNewValue)
{
  SetModifiedFlag(!bNewValue); // since "saved" & "modified" are opposite
}

LPDISPATCH CPartDoc::NewWindow(void)
{
  // NOTE: this method may not be appropriate for all document types

	CMDIChildWnd* pActiveChild = static_cast<CMDIFrameWnd*>(theApp.m_pMainWnd)->MDIGetActive();

  if (pActiveChild)
	{
		CDocument *pDoc = pActiveChild->GetActiveDocument();

		if (static_cast<CDocument*>(this) != pDoc) // if a view on our document isn't currently active
			pActiveChild = 0; // don't send a 'pOther' param to CreateNewFrame
  }

	CDocTemplate* pTemplate = GetDocTemplate();
	ASSERT_VALID(pTemplate);
	CFrameWnd* pFrame = pTemplate->CreateNewFrame(this, pActiveChild);
	if (pFrame == NULL)
	{
		DsThrowShellOleDispatchException(DS_E_CANNOTCREATENEWWINDOW) ;
	}

	pTemplate->InitialUpdateFrame(pFrame, this);

	return static_cast<CPartFrame*>(pFrame)->GetAutomationObject(TRUE);
}

IDispatch* CPartDoc::ActiveWindow()
{
	// To get the most recently active window for
	// this document, we traverse all of the MDI children
	// checking to see if they below to this documnet.
	// The first one to do so should be the most recently active doc.

		// get a pointer to the main frame
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT_KINDOF(CMainFrame, pMainFrame);

		CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
		if (pMDIActiveChild == NULL)
		{
			return NULL ;
		}

		CPartFrame* pMDIChild = (CPartFrame *)pMDIActiveChild->GetWindow(GW_HWNDFIRST);
		while( pMDIChild != NULL )
		{
			if(!IsValidMDICycleMember(pMDIChild))
			{
				continue;
			}
		
			// Check to see if it belongs to the current document.
			if (frameBelongsToDoc(pMDIChild, this)) // see helper function aboves
			{
				// We found a window which belongs to us.
				return pMDIChild->GetAutomationObject(TRUE);
			}			
			pMDIChild = (CPartFrame *)pMDIChild->GetWindow(GW_HWNDNEXT);
		} // while
		return NULL ;
}

BOOL CPartDoc::ReadOnly()
{
	return (IsReadOnly() || IsReadOnlyOnDisk()) ;
}

// Methods

// Helper function which returns TRUE if the frame belongs to
// the document.
BOOL frameBelongsToDoc(CFrameWnd* pFrame, CDocument* pDoc)
{
	// Get the active view for this frame.
	CView* pActiveView = pFrame->GetActiveView() ;
	if (pActiveView != NULL)
	{
		// Get the document for the active window
		CDocument* pActiveDoc = pActiveView->GetDocument() ;
		if (pActiveDoc != NULL)
		{
			// Is the ActiveDocument the same as this document?
			return (pDoc == pActiveDoc) ;
		}
	}
	return FALSE ;
}

BOOL CPartDoc::GetActive() 
{
	// Get a pointer to the main frame
	CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
	ASSERT_KINDOF(CMainFrame, pMainFrame);

	// Get the active MDI window.
	CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
	if (pMDIActiveChild != NULL)
	{
		ASSERT_KINDOF(CPartFrame, pMDIActiveChild) ;
		return frameBelongsToDoc(pMDIActiveChild, this) ; // see above.
	}
	// We aren't the active document.
	return FALSE ;
}

void CPartDoc::SetActive(BOOL bNewValue) 
{
	if (bNewValue == GetActive())
	{
		// Don't change anything if the current state is okay.
		return ;
	}

	if (bNewValue)
	{
		// Activate this document.
		ActivateDoc() ;
	}
	else
	{
		// To deactivate the document, we need to activate another window.
		// get a pointer to the main frame
		CMainFrame* pMainFrame = (CMainFrame *)theApp.m_pMainWnd;
		ASSERT_KINDOF(CMainFrame, pMainFrame);
		
		// Get the currently active MDI window. This should belong to us,
		// because of the GetActive check above.
		CPartFrame* pMDIActiveChild = (CPartFrame*)pMainFrame->MDIGetActive();
		CPartFrame* pMDIChild = pMDIActiveChild;
		while( TRUE )
		{
			pMDIChild = (CPartFrame *)pMDIChild->GetWindow(GW_HWNDNEXT);
			if(pMDIChild == NULL) // we got to the end of the list
			{
				pMDIChild = (CPartFrame *)pMDIActiveChild->GetWindow(GW_HWNDFIRST);
			}

			if(pMDIChild == pMDIActiveChild) // we completed the loop
			{
				break;
			}

			if(!IsValidMDICycleMember(pMDIChild))
			{
				continue;
			}
		
			// Check to see if it belongs to the current document.
			if (!frameBelongsToDoc(pMDIChild, this)) // see helper function aboves
			{
				//Okay, activate the pMDIChild frame...
				pMDIChild->ActivateFrame();
				// we are done...
				break ;
			}			
		} // while
	} // else
}


DsSaveStatus CPartDoc::Close(const VARIANT FAR& vtLongSaveChanges)
{
	g_AutomationState.SaveChanges(vtLongSaveChanges);
	
	// Attempt to close the document
	//OnCloseDocument() ;
	OnFileClose() ;

	// Return if the save was canceled. (HandleError resets status.)
	DsSaveStatus status = g_AutomationState.SavePromptResult() ;		

	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;

	// Return if the save was canceled.
	return status ;		
}

DsSaveStatus CPartDoc::Save(const VARIANT FAR& vtFilename, const VARIANT FAR& vtBoolPrompt)
{
	// Get Filename paramter
	CString filename;
	::ConvertVariantToCString(/*in*/vtFilename, /*out*/filename, m_strPathName/*Default*/) ;
	
	// Set up the automation state.
	g_AutomationState.SetPromptState(vtBoolPrompt) ;

	// Attempt saving the file.
	BOOL bResult = DoSave(filename) ;

	// Return if the save was canceled.
	DsSaveStatus status = g_AutomationState.SavePromptResult() ;		
	
	// Handle errors caught by the automation state. Cleans up the state.
	g_AutomationState.HandleError() ;
	
	if (!bResult && status == dsSaveSucceeded)
	{
		// No error reported, but there is no document.
		TRACE0("Shell Automation Save: We should be reporting an error!") ;
		DsThrowShellOleDispatchException(DS_E_UNKNOWN) ;		
	}

	return status ;
}

IDispatch* CPartDoc::GetWindows()
{
	CAutoWindows *pAW = new CAutoWindows(this);
	return pAW->GetIDispatch(FALSE); // creation is an implicit AddRef

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dllapi.h ===
// dllapi.h
//

#ifndef __DLLAPI_H__
#define __DLLAPI_H__

#include <tchar.h>
#include <stdlib.h>
#include <windows.h>

// prototype struct for name->pfn mapping
struct MPSZPFN
{
	_TCHAR *szRoutine;
	FARPROC pfn;
};

#define DECLARE_DLLAPI(var, map, dll)	CDllApi var(#dll, g_mpszpfn##map)
#define BEGIN_MPSZPFN(var)				MPSZPFN g_mpszpfn##var[] = {
#define MPSZPFN_FCN(name)				{#name, 0},
#define END_MPSZPFN(var)				{0,0}};

class CDllApi
{
	CDllApi() { }				// private default ctor--have to use the real one below
	BOOL _fRoutinesOK;			// all routines loaded successfully
	UINT _cRoutines; 			// count of routines in list
	HINSTANCE _hInstance;		// handle to the dll
	MPSZPFN *_mpszpfn;			// mapping from name to pfn
	_TCHAR _szDll[_MAX_PATH];	// dll name

public:
	CDllApi(const _TCHAR *szDll, MPSZPFN *);
	~CDllApi();
	BOOL FLoaded() const { return _hInstance != 0; }
	BOOL FRoutinesLoaded () const { return _fRoutinesOK; }
	FARPROC operator() (UINT iRoutine) {return _mpszpfn[ iRoutine ].pfn; }
};

#endif	// __DLLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dockapi.cpp ===
///////////////////////////////////////////////////////////////////////////////
//  DOCKAPI.CPP
//      Implementation of message packing functions for dockable windows.
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "memory.h"
#include "dockman.h"
#include "barbdr.h"
#include "main.h"
#include "mainfrm.h"

//[multimon] - 18 mar 97 - der - 
// Macros for unpacking LPARAMs in the multimon world.
// These macros are defined in WINDOWSX.h.
#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)	((int)(short)LOWORD(lp))
#endif

#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)	((int)(short)HIWORD(lp))
#endif

#ifdef _WIN32
#define _fmemcpy memcpy
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// Registered messages.

UINT DWM_GETDATA = RegisterMessage(_TEXT("DockGetWindowData"));
UINT DWM_GETMOVESIZE = RegisterMessage(_TEXT("DockWndMoveSize"));
UINT DWM_GETTRACKSIZE = RegisterMessage(_TEXT("DockWndTrackSize"));
UINT DWM_ENABLECHILD = RegisterMessage(_TEXT("DockEnableChild"));
UINT DWM_SHOWWINDOW = RegisterMessage(_TEXT("DockShowWindow"));
UINT DWM_CLOSE = RegisterMessage(_TEXT("DockWndClose"));

static BOOL DkNcLButtonDown(HWND hwnd, UINT nHitTest, POINT pt);
static BOOL DkNcLButtonDblClk(HWND hwnd, UINT nHitTest, POINT pt);
static BOOL DkNcMouse(UINT message, HWND hwnd, UINT nHitTest, POINT pt);

//	DkInfoData
//		Packs an array of DOCKINIT structs into shared memory, with a prepended
//		count.  For return when a group UI is called with DCM_GETWINDOW
//		and wParam == 0.

HGLOBAL DkInfoData(UINT nInfoCount, DOCKINIT FAR* lpdiArray)
{
	// FUTURE: Stop using HGLOBALS for this.
	HGLOBAL hglob;
	UINT FAR* lpnSend;
	DOCKINIT FAR* lpdiArraySend;
	
	hglob = GlobalAlloc(GMEM_SHARE, 
		sizeof(UINT) + sizeof(DOCKINIT) * nInfoCount);
	lpnSend = (UINT FAR*) GlobalLock(hglob);
	lpdiArraySend = (DOCKINIT FAR*) (lpnSend + 1);
	
	*lpnSend = nInfoCount;
	_fmemcpy(lpdiArraySend, lpdiArray, sizeof(DOCKINIT) * nInfoCount);

    GlobalUnlock(hglob);
    
    return hglob;
}

//	DkToolbarData
//		Packs TOOLBARINIT and array of command IDs into shared memory.  For
//		return when group UI is called with DCM_GETTOOLBAR.

HGLOBAL DkToolbarData(const TOOLBARINIT* ptbi, const UINT FAR* lpIDArray)
{
	// FUTURE: Stop using HGLOBALS for this.
	HGLOBAL hglob;
	TOOLBARINIT FAR* lptbiSend;
	UINT FAR* lpIDArraySend;
	
	hglob = GlobalAlloc(GMEM_SHARE, 
		sizeof(TOOLBARINIT) + sizeof(UINT) * (ptbi->nIDCount));
	lptbiSend = (TOOLBARINIT FAR*) GlobalLock(hglob);
	lpIDArraySend = (UINT FAR*) (lptbiSend + 1);
	
	_fmemcpy(lptbiSend, ptbi, sizeof(TOOLBARINIT));
	if (ptbi->nIDCount)
		_fmemcpy(lpIDArraySend, lpIDArray, sizeof(UINT) * (ptbi->nIDCount));

    GlobalUnlock(hglob);
    
    return hglob;
}

//	DkRegisterWnd
//		Registers a window with the dock manager.
//		Use this when a runtime event makes a window necessary that has not been
//		registered at InitInstance time, using DkInfoData.

BOOL DkRegisterWnd(HWND hwnd, DOCKINIT* pdi)
{
	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;
	if (pManager == NULL) 
		return FALSE;

	return (pManager->RegisterWnd(hwnd, pdi) != NULL);
}

//	DkRegister
//		Registers a toolbar with the dock manager.
//		Use this when a runtime event makes a toolbar necessary that has not been
//		registered at InitInstance time, using DkInfoData.

BOOL DkRegisterToolbar(DOCKINIT* pdi, TOOLBARINIT* ptbi, UINT FAR* lpIDArray)
{
	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;
	if (pManager == NULL) 
		return FALSE;

	return (pManager->RegisterToolbar(pdi, ptbi, lpIDArray) != NULL);
}

//	DkPreHandleMessage
//		All windows that will appear as descendants of the dock windows should
//		call this function at the beginning of their WindowProc, and end
//		processing, returning the value in pResult, if the function returns
//		TRUE (The message has been handled).

BOOL DkPreHandleMessage(HWND hwnd, UINT message,
	UINT wParam, LPARAM lParam, LRESULT* pResult)
{
	POINT pt;

	*pResult = 0;
	
	switch (message)
	{
	default:
		if (message == DMM_CHILDSETFOCUS ||
			message == DMM_CHILDKILLFOCUS ||
			message == DMM_NCLBUTTONDOWN ||
			message == DMM_NCLBUTTONDBLCLK)
		{
			*pResult = SendMessage(GetParent(hwnd), message, (UINT) hwnd, lParam);
			return TRUE;
		}
		break;

	case WM_COMMAND:
		if (LOWORD(wParam) == ID_CANCEL)
		{
			// DevStudio96 RAID #11708 [patbr]:
			// if there are no MDI child windows open, we want to effectively
			// pass the cancel message on to the mainframe's <esc> handler...
			if (theApp.HasOpenDocument(FILTER_NONE))
				theApp.ReactivateView();
			else
				((CMainFrame *)theApp.m_pMainWnd)->OnCancel();

			*pResult = TRUE;
			return TRUE;
		}
		break;

	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_CHAR:
		if (wParam != VK_ESCAPE || (GetKeyState(VK_CONTROL) & ~1) != 0)
			break;

    // Fall through.
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
	case WM_SYSCHAR:
		SendMessage(GetParent(hwnd), message, wParam, lParam);
		return TRUE;

	case WM_SETFOCUS:
		// Just notify.  Don't handle.
		SendMessage(GetParent(hwnd), DMM_CHILDSETFOCUS, (WPARAM) hwnd, wParam);
		break;

	case WM_KILLFOCUS:
		// Just notify.  Don't handle.
		SendMessage(GetParent(hwnd), DMM_CHILDKILLFOCUS, (WPARAM) hwnd, wParam);
		break;

	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
#ifdef _WIN32
		//[multimon] - 18 Mar 97 - der - Use macro instead of LOWORD/HIWORD
		pt.x = GET_X_LPARAM(lParam);
		pt.y = GET_Y_LPARAM(lParam);
		ClientToScreen(hwnd, &pt);
		lParam = MAKELONG((short)pt.x, (short)pt.y);
#else
		ClientToScreen(hwnd, &MAKEPOINT(lParam));
#endif

	// Fall through.
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONUP:
		//BLOCK:
		{
			HWND hwndParent = GetParent(hwnd);

#ifdef _WIN32
			//[multimon] - 18 Mar 97 - der - Use macro instead of LOWORD/HIWORD
			pt.x = GET_X_LPARAM(lParam);
			pt.y = GET_Y_LPARAM(lParam);
			ScreenToClient(hwndParent, &pt);
			lParam = MAKELONG((short)pt.x, (short)pt.y);
#else
			ScreenToClient(hwndParent, &MAKEPOINT(lParam));
#endif
			HWND hwndCapture = GetCapture();
			if (hwndCapture != NULL && hwndCapture != hwnd)
				return FALSE;

			if (message == WM_NCRBUTTONDOWN) message = WM_RBUTTONDOWN;
			if (message == WM_NCRBUTTONUP)	 message = WM_RBUTTONUP;
			SendMessage(hwndParent, message, wParam, lParam);
		}
		return TRUE;
		
	case WM_LBUTTONDOWN:
		wParam = HTCLIENT;
#ifdef _WIN32
		//[multimon] - 18 Mar 97 - der - Use macro instead of LOWORD/HIWORD
		pt.x = GET_X_LPARAM(lParam);
		pt.y = GET_Y_LPARAM(lParam);
		ClientToScreen(hwnd, &pt);
		lParam = MAKELONG((short)pt.x, (short)pt.y);
#else
		ClientToScreen(hwnd, &MAKEPOINT(lParam));
#endif
	
	// Fall through.
	case WM_NCLBUTTONDOWN:
#ifdef _WIN32
		//[multimon] - 18 Mar 97 - der - Use macro instead of LOWORD/HIWORD
		pt.x = GET_X_LPARAM(lParam);
		pt.y = GET_Y_LPARAM(lParam);
#else
		pt = MAKEPOINT(lParam);
#endif
		return DkNcLButtonDown(hwnd, wParam, pt);
		
	case WM_LBUTTONDBLCLK:
		wParam = HTCLIENT;
#ifdef _WIN32
		//[multimon] - 18 Mar 97 - der - Use macro instead of LOWORD/HIWORD
		pt.x = GET_X_LPARAM(lParam);
		pt.y = GET_Y_LPARAM(lParam);
		ClientToScreen(hwnd, &pt);
		lParam = MAKELONG((short)pt.x, (short)pt.y);
#else
		ClientToScreen(hwnd, &MAKEPOINT(lParam));
#endif
	
	// Fall through.
	case WM_NCLBUTTONDBLCLK:
#ifdef _WIN32
		//[multimon] - 18 Mar 97 - der - Use macro instead of LOWORD/HIWORD
		pt.x = GET_X_LPARAM(lParam);
		pt.y = GET_Y_LPARAM(lParam);
#else
		pt = MAKEPOINT(lParam);
#endif
		return DkNcLButtonDblClk(hwnd, wParam, pt);
	}
	
	return FALSE;
}

//	DkNcLButtonDown
//		Used to translate a WM_NCLBUTTONDOWN into a dock manager message,
//		containing the HWND recipient of the message.

BOOL DkNcLButtonDown(HWND hwnd, UINT nHitTest, POINT pt)
{
    return DkNcMouse(DMM_NCLBUTTONDOWN, hwnd, nHitTest, pt);
}

//	DkNcLButtonDblClk
//		Used to translate a WM_NCLBUTTONDBLCLK into a dock manager message,
//		containing the HWND recipient of the message.

BOOL DkNcLButtonDblClk(HWND hwnd, UINT nHitTest, POINT pt)
{
    return DkNcMouse(DMM_NCLBUTTONDBLCLK, hwnd, nHitTest, pt);
}

//	DkNcMouse
//		Packs mouse message data into shared memory and sends message to
//		message to parent.  (Internal use only).

BOOL DkNcMouse(UINT message, HWND hwnd, UINT nHitTest, POINT pt)
{
    HWND hwndParent;
    HGLOBAL hglob;
    MOUSESTRUCT FAR* lpmst;
    LONG lResult;
    
    hwndParent = GetParent(hwnd);
    hglob = GlobalAlloc(GMEM_SHARE, sizeof(MOUSESTRUCT));
    lpmst = (MOUSESTRUCT FAR*) GlobalLock(hglob);
    
    lpmst->nHitTest = nHitTest;
    lpmst->pt = pt;

    lResult = SendMessage(hwndParent, message, (UINT) hwnd,
    	(LPARAM) (LPVOID) hglob);
    
    GlobalUnlock(hglob);
    GlobalFree(hglob);
    
    return (BOOL) lResult;
}

//	DkWGetDock
//		Returns the DOCKPOS of the window.

DOCKPOS DkWGetDock(UINT nID)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager != NULL) 
	{
		CDockWorker* pWorker = pManager->WorkerFromID(nID);
		if (pWorker != NULL)
			return pWorker->GetDock();
	}

	return dpHide;
}

//	DkWShowWindow
//		Tells the dock worker to show its window.

void DkWShowWindow(UINT nID, BOOL bShow)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL) 
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
	{
		pWorker->ShowWindow(bShow);
	}
}

//	DkWToggleMDIState
//		Toggles between MDI and docking view.

void DkWToggleMDIState(UINT nID)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL) 
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
		pWorker->ToggleMDIState();
}

//	DkWMoveWindow
//		Used to move a window within the dock model.  Use dpCurrent, if you
//		want to keep current dock (also allows window to stay hidden if it
//		is already).

void DkWMoveWindow(UINT nID, DOCKPOS dp, LPCRECT lpRect)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL) 
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
	{
		CRect rect(lpRect);
		pWorker->Move(dp, rect);
	}
}

//	DkWGetTitle
//		Returns the title of the worker

void DkWGetTitle(UINT nID, CString& str)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
		pWorker->GetText(str);
}

//	DkWSetTitle
//		Sets the worker's title.

void DkWSetTitle(UINT nID, const CString& str)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
		pWorker->SetText(str);
}

//	DkWRemove
//		Allows a group UI to remove a registered window for the dock
//		manager, if necessary.

void DkWRemove(UINT nID)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;
	if (pManager != NULL) 
		pManager->RemoveWnd(nID);
}

//	DkWGetMaxState
//		Get the maximize state of a stretchy docked window, for
//		drawing a maximize/restore button, and performing the correct
//		action when the user clicks on the button.

MAX_STATE DkWGetMaxState(UINT nID)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return stateDisabled;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker == NULL)
		return stateDisabled;

	return pWorker->GetMaxState();
}

//	DkWMaximizeRestore
//		Maximize or restore a stretchy docked window.

void DkWMaximizeRestore(UINT nID)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
		pWorker->MaximizeRestore();
}

void DkWMapDockingCmd(UINT nID, UINT nCmd)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	((CMainFrame*) AfxGetMainWnd())->MapDockingCmd(nID, nCmd);
}

void DkWHandleDockingCmd(UINT nCmd, BOOL bToggle, CCmdUI* pCmdUI /*=NULL*/)
{
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager != NULL) 
		pManager->HandleWorkerCmd(nCmd, bToggle, pCmdUI);
}

// embeddeds a given worked inside another window, by deparenting it.
HWND DkWEmbed(UINT nID, HWND hwndParent)
{
	ASSERT(HIWORD(nID) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return NULL;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	if (pWorker != NULL)
	{
		pWorker->ShowWindow(FALSE);
		pWorker->ShowWindow(TRUE);

		pWorker->Move(dpEmbedded, CRect(0,0,0,0));

		pWorker->DeparentWindow(CWnd::FromHandle(hwndParent), NULL);

		return pWorker->m_pWnd->GetSafeHwnd();
	}

	return NULL;
}

void DkWAssociate(UINT nID, UINT nIDHost)
{
	ASSERT(HIWORD(nID) != 0);		// Need package ID in HiWord. Use MAKEDOCKID macro.
	ASSERT(HIWORD(nIDHost) != 0);	// Need package ID in HiWord. Use MAKEDOCKID macro.
	CDockManager* pManager = ((CMainFrame*) AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return;

	CDockWorker* pWorker = pManager->WorkerFromID(nID);
	CDockWorker* pHostWorker = pManager->WorkerFromID(nIDHost);
	if (pWorker != NULL && pHostWorker !=NULL)
	{
		// set up associations
		pHostWorker->Associate(nID, TRUE);
		pWorker->Associate(pHostWorker->m_nIDWnd, FALSE);
	}
}

//	DkRecalcBorders
//		For dtBorder/dtEdit windows that have toolbars (like Locals and
//		Watch windows).  To make everything look symetric, border bars
//		need to change their borders when the toolbar is shown or hidden.

void DkRecalcBorders(CWnd* pWnd)
{
	CBorderBar* pBar = (CBorderBar*) pWnd->GetParent();
	if (pBar != NULL && pBar->IsKindOf(RUNTIME_CLASS(CBorderBar)))
		pBar->RecalcLayout();
}

//	DkGetDockState
//		Check current dock manager layout.

int DkGetDockState()
{
	return ((CMainFrame *)AfxGetMainWnd())->m_nManagerState;
}

//	DkSetDockState
//		Load a particular dock manager layout.

void DkSetDockState(int nState, int nMask /* =1 */)
{
	((CMainFrame *)AfxGetMainWnd())->SetDockState(nState, nMask);
}

void DkShowManager(BOOL bShow, UPDATE_SHOW update /*=updNow*/)
{
	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;
	if (pManager != NULL) 
		pManager->ShowManager(bShow, update);
	
}

BOOL DkDocObjectMode(BOOL bShow)
{
	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;
	if (pManager == NULL) 
		return FALSE;
	return pManager->DocObjectMode(bShow);
}

void DkUpdateAvailableWnds(BOOL bUpdateNow /*=FALSE*/)
{
	CDockManager* pManager = ((CMainFrame *)AfxGetMainWnd())->m_pManager;
	if (pManager == NULL)
		return;

	pManager->SetAvailableWndDirty();
	if (bUpdateNow)
		pManager->IdleUpdateAvailableWnds();
}

//	DkLockWorker
//		Keep the current worker active even though it may lose focus.

void DkLockWorker(BOOL bLock)
{
	CDockWorker::LockWorker(bLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dockman.h ===
///////////////////////////////////////////////////////////////////////////////
// DOCKMAN.H
//

#ifndef __DOCKMAN_H__
#define __DOCKMAN_H__

#ifndef __DOCKWNDS_H__
#include "dockwnds.h"
#endif

#define IDR_DOCKBASE 1000

// Layout version history
// 12: Shipped with 5.0 Beta1
// 13: Incremented when build minibar was renumbered
// 14: TBBS_CUSTOMTEXT
// 15: Incremented after beta 2 ssync, to ensure squashing of beta 2 created registries
// 16: Associate workers
#define LAYOUT_VERSION 16

class CDockManager;

///////////////////////////////////////////////////////////////////////////////
//  CDockWorker
//

#define DEFAULT_STRETCH_WIDTH 100
#define DEFAULT_STRETCH_HEIGHT 100

// struct for placing dockable windows in the docks.
struct DOCKPLACEMENT {
	DOCKPOS dp;	// == dpNil for serialization.
	union
	{
		RECT rectAbsolute;		// Absolute position for serialization.
		DOCKRESTORE drRelative;	// Relative position.
	};
};

// struct for placing docking views in MDI windows.
struct DESKPLACEMENT {
	int nZOrder;
	WINDOWPLACEMENT place;
};

// struct for stretchy dragging.
struct SHELL_DRAGINFO {
	DOCKPOS dp;
	int iRow;
	int cAlongRow;
	int cAlongOther;
};

class CDockWorker : public CObject
{
public:
	// returns the default minimum size, as a point
	static CPoint GetDefMin(void);
	static CPoint s_ptDefMax;

	static LPCSTR s_lpszLayoutSection;

	static CDockWorker* s_pActiveDocker;
	static BOOL s_bLockDocker;

	static void LockWorker(BOOL bLock = TRUE);
	static int GetInsertTolerance(void) { return s_nInsertTolerance; };
	static void SetInsertTolerance(int nInsertTolerance) { s_nInsertTolerance=nInsertTolerance; };

private:
	static int s_nInsertTolerance;

// Constructor.
public:
    CDockWorker(DOCKINIT FAR* lpInit);
    ~CDockWorker();

    BOOL Create(CDockManager* pManager, CWnd* pOwner = NULL,
    	BOOL bForceVisible = FALSE);
	void Reset(DOCKINIT FAR* lpInit);
	void Reset(CDockWorker* pDockerOld);
	void PreTransfer(CDockManager* pManager);
    void SetManager(CDockManager* pManager);	// For defering creation.

public:
	void LoadData();
	void SaveData();

    LONG OnMessage(UINT message, LPARAM lParam);

	void OnChildSetFocus(CWnd* pWndLoseFocus);
	void OnChildKillFocus(CWnd* pWndGetFocus);
	void OnWindowActivate(BOOL bActive, CWnd* pWndOther);
	BOOL OnNcLButtonDown(UINT nHitTest, CPoint pt);
	BOOL OnNcLButtonDblClk(UINT nHitTest, CPoint pt);
    void DoSize(CPoint pt, UINT nHitTest);
    void DoMove(CPoint pt);
    void ToggleFloat();
	void ToggleMDIState();
   	void ShowWindow(BOOL bShow);
	void ActivateView();
	void DestroyWindow(BOOL bInitData = TRUE);
	void Move(DOCKPOS dp, CRect& rect);
	// Associates the docker worker id with this dock worker. If bHost is false, nID is hosting this worker
	// if bHost is TRUE, this worker is hosting nID.
	void Associate(BOOL bHost, UINT nID);

	void SaveStretchSize();
    void SaveFloatPos();
	void SaveMDIPos();
    void SaveDockPos(BOOL bRelative = TRUE);

    BOOL IsVisible();
    BOOL IsAvailable();
	BOOL IsLastAvailable();
	BOOL IsDestroyOnHide();

    void UpdateAvailable(BOOL bShow);
    CSize GetMoveSize(DOCKPOS dp, CSize size);
    CSize GetTrackSize(UINT nHitTest, CSize size);
	BOOL GetTrackRect(CRect& rect, const CRect& rectOld, CPoint pt,
		CSize size, DOCKPOS dp,	DOCKPOS dpOld, BOOL bWasOutside,
		const CRect& rectDesk, const CRect& rectClient,
		BOOL bForce = FALSE, SHELL_DRAGINFO* pDrag = NULL);
	DOCKPOS GetDock();
	void SetDocks(DWORD fInit);
    void GetText(CString& str);
    void SetText(const CString& str);
	CPartView* GetView() const;
	void SetMDIState(BOOL bMDIBound);
	void EndLoad();

	void DeparentWindow(CWnd* pWndNewParent = NULL,
		CDockManager* pManagerNew = NULL);

	MAX_STATE GetMaxState();
	void MaximizeRestore();

protected:
	HWND GetPackageWindow();
    BOOL TrackSize(CPoint pt, UINT nHitTest, CRect& rectFinal);
    BOOL TrackMove(CPoint pt, DOCKPOS& dpFinal, CRect& rectFinal);
    void DrawTrackRect(CDC* pdc,
    	DOCKPOS dp1, const CRect* prect1, BOOL bChildRect1 = TRUE,
        DOCKPOS dp2 = dpNil, const CRect* prect2 = NULL,
        BOOL bChildRect2 = TRUE);

    BOOL FloatWnd(const CRect& rect);
	BOOL DockWnd(DOCKPLACEMENT* pDockPlace = NULL, BOOL bRelative = TRUE);
	BOOL DeskWnd(const CRect& rect = CFrameWnd::rectDefault);

    CSize GetFloatSize();
    void GetFloatRect(CRect& rect);
#if 0
    CPoint GetMaxSize();
    CPoint GetMinSize();
	void GetBoundaryRect(BOOL bLeft, CRect& rect);
#endif

	BOOL FWndLockWorker(CWnd* pWndOther);

//Serialization
    CDockWorker();
    virtual void Serialize(CArchive& ar);

    DECLARE_SERIAL(CDockWorker)

// Attributes
public:
	HGLOBAL m_hglobInit;
	DESKPLACEMENT* m_pDeskPlace;
	DOCKPLACEMENT* m_pDockPlace;	// Relative dock placement.
	DOCKPLACEMENT* m_pDockSerial;	// Absolute dock placement.
    CWnd* m_pWnd;
	UINT m_nIDWnd;
	UINT m_nIDCmd;
	UINT m_nIDPackage;
	UINT m_nIDPacket;
	UINT m_nIDAssociate;

    DOCKTYPE m_dtWnd;

protected:
	BOOL m_bCanHorz:1;
	BOOL m_bCanVert:1;
	BOOL m_bPosition:1;
	BOOL m_bAsk:1;
	BOOL m_bVisible:1;
	BOOL m_bAvailable:1;
	BOOL m_bMDIBound:1;
	BOOL m_bLoading:1;
	BOOL m_bLastAvailable:1;
	BOOL m_bDestroyOnHide:1;
	BOOL m_bTranspose:1;
	UINT m_bHost:1;					// TRUE if the docking window is hosting an embedded window

    DOCKPOS m_dp;
    CDockManager* m_pManager;
	CSize m_sizeLastStretch;
    CRect m_rectFloat;
    CString m_strTitle;

	friend class CDockManager;
};

inline void CDockWorker::LockWorker(BOOL bLock /*=TRUE*/)
{	if (s_pActiveDocker != NULL)
		s_bLockDocker = bLock; }

inline BOOL CDockWorker::IsVisible()
{	
	return m_bAvailable && m_bVisible; 
}


inline BOOL CDockWorker::IsAvailable()
{	return m_bAvailable; }
inline BOOL CDockWorker::IsLastAvailable()
{	return m_bLastAvailable; }
inline BOOL CDockWorker::IsDestroyOnHide()
{	return m_bDestroyOnHide; }
inline DOCKPOS CDockWorker::GetDock()
{	return m_bMDIBound ? dpMDI : m_dp; }
inline void CDockWorker::SetDocks(DWORD fInit)
{	m_bCanVert = (fInit & INIT_CANVERT) != 0;
	m_bCanHorz = (fInit & INIT_CANHORZ) != 0; }
inline void CDockWorker::GetText(CString& str)
{	str = m_strTitle; }
inline void CDockWorker::SetManager(CDockManager* pManager)
{	m_pManager = pManager; }
inline void CDockWorker::EndLoad()
{	delete m_pDockSerial;
	m_pDockSerial = NULL;
	m_bLoading = FALSE; }

//	Worker messages

extern UINT DMM_CHILDSETFOCUS;
extern UINT DMM_CHILDKILLFOCUS;
extern UINT DMM_NCLBUTTONDOWN;
extern UINT DMM_NCLBUTTONDBLCLK;

struct MOUSESTRUCT {
	UINT nHitTest;
	POINT pt;
};

/////////////////////////////////////////////////////////////////////////////
//  CDockManager
//

class CDockManager : public CObject
{
public:
    CDockManager();
    ~CDockManager();

    BOOL Create(CFrameWnd* pFrame, CWnd* pView,
    	CDockManager* pManagerOld = NULL);

    CDockWnd* GetDock(DOCKPOS dp);
	BOOL HasDock(DOCKPOS dp);
    void GetDeskRects(CRect& rectDesk, CRect& rectClient);
    UINT GetCustomID();

    void RegisterInfo(UINT nInfoCount, DOCKINIT FAR* lpdiArray);
	CDockWorker* RegisterToolbar(DOCKINIT FAR* lpdi,
		TOOLBARINIT FAR* lptbi, UINT FAR* lpIDArray);
    CDockWorker* RegisterWnd(HWND hwnd, DOCKINIT FAR* lpInit);
    CDockWorker* RegisterWnd(CWnd* pWnd, DOCKINIT FAR* lpInit);
    void RemoveWnd(CWnd* pWnd);
    void RemoveWnd(UINT nID);
    void RemoveWorker(CDockWorker* pDocker, POSITION pos);
    LONG WorkerMessage(UINT message, HWND hwnd, LPARAM lParam);

    void InsertWorker(CDockWorker* pDocker);
    CDockWorker* WorkerFromID(UINT nID, POSITION* posFinal = NULL);
    CDockWorker* WorkerFromWindow(CWnd* pWnd, POSITION* posFinal = NULL);
	CDockWorker* WorkerFromAutoType(LPCTSTR szAutoType);
    void ArrayOfType(DOCKTYPE dt, CObArray* paWorkers,
    	BOOL bExclude = FALSE, BOOL bAvailable = FALSE, DOCKTYPE dtAnother=dtNil);

	// Hide/Show command handling.
	void MapCmdToWorker(UINT nCmd, UINT nIDWnd);
	void HandleWorkerCmd(UINT nCmd, BOOL bToggle, CCmdUI* pCmdUI = NULL);

    void ShowMenu(CPoint pt);

    void SaveWorkers();

	void EnableManagerInput(BOOL bEnable);
    void ShowManager(BOOL bShow, UPDATE_SHOW update = updNow, BOOL bForceUpdate = FALSE);
	void ShowPalettes(BOOL bShow, BOOL bForceUpdate = FALSE);
	BOOL DocObjectMode(BOOL bShow);
    BOOL IsVisible();
	BOOL IsShowDelayed();
	BOOL IsInDocObjectMode();


// Palette & MDI child functions.
public:
	void AddMDIChild(CMDIChildDock* pWnd);
	void RemoveMDIChild(CMDIChildDock* pWnd,
		CWnd* pWndNewParent = NULL, CDockManager* pManagerNew = NULL);

    void AddPalette(CPaletteWnd* pWnd);
    void RemovePalette(CPaletteWnd* pWnd,
    	CWnd* pWndNewParent = NULL, CDockManager* pManagerNew = NULL);
    void ActivatePalettes(BOOL bActive);

	// This inline function is called by the Idle loop: it needs to remain
	// small and efficient!
	BOOL NeedIdle() {
			if (m_pFrame == NULL || m_pFrame->IsIconic())
				return TRUE;
			return (m_bAvailableWndDirty || m_bDelayedShow);
	}

    void IdleUpdate();
	void IdleUpdateAvailableWnds();
	void SetAvailableWndDirty();

	void SysColorChange();

//Serialization
protected:
    virtual void Serialize(CArchive& ar);

    DECLARE_SERIAL(CDockManager)

// Implementation.
public:
    CFrameWnd* m_pFrame;
	CWnd* m_pView;

protected:
	BOOL m_bVisible:1;
	BOOL m_bDelayedShow:1;
	BOOL m_bAvailableWndDirty:1;
	BOOL m_bInDocObjectMode:1;
    CObList m_listFloat;
	CObList m_listDesk;
    CObList m_listWorker;
    CDockWnd* m_rgpDock[dpCount];
	CMapWordToOb m_mapCmdToWorker;
};

inline BOOL CDockManager::IsVisible()
{	
	return m_bVisible != m_bDelayedShow;
}

inline BOOL CDockManager::IsShowDelayed()
{	return !m_bVisible && m_bDelayedShow;	}
inline BOOL CDockManager::HasDock(DOCKPOS dp)
{   ASSERT(dpFirst <= dp && dp < dpFirst + dpCount);
    return (m_rgpDock[dp - dpFirst] != NULL);	}
inline void CDockManager::SetAvailableWndDirty()
{	m_bAvailableWndDirty = TRUE; }
inline BOOL CDockManager::IsInDocObjectMode()
{	return m_bInDocObjectMode;	}


#endif  // __DOCKMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dockwnds.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	DOCKWNDS.CPP
//		This files contains the implementations for the two window classes
//		associated with the window docking architecture (CPaletteWnd, and
//		CDockWnd).
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "shell.h"
#include "about.h"
#include "dockwnds.h"
#include "dockman.h"
#include "bardockx.h"
#include "util.h"
#include "resource.h"

IMPLEMENT_SERIAL(CDockWnd, CWnd, 1)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static BOOL MDIKeyMessage(MSG* pMsg);

extern UINT WM_ISERROR;

// In version 4.x, INSERT_TOLERANCE was also 0. This stops one inserting rows in the middle
// of two dock rows. The original comment by insert tolerance was:

	// Must stay 0 for restoring to work.

// Here's an extract from some email from Brendan on this subject, when I
// asked about raising INSERT_TOLERANCE:
/* 
From: 	Martyn Lovell
To: 	Brendan X. MacLean

You will probably remember that there is a #defined value, INSERT_TOLERANCE, that controls when new rows are inserted. We're getting a lot of complaints that it's hard to insert a bar between two others; and indeed it is, because INSERT_TOLERANCE is 0. A comment in the code says:

#define INSERT_TOLERANCE 0	// Must stay 0 for restoring to work.

Restoring what? Could I perhaps force this value to 0 when restoring, but have it non-zero during normal interaction?

From: 	Brendan X. MacLean
To: 	Martyn Lovell

Take a look at how we restore windows to their correct rows after being hidden.  Each row is assigned an ID at creation time.  The ID is a long.  I don't exactly remember, but let's suppose the first row gets ID 0.  Then if I create a row above it, that row gets ID -1 and one below it gets ID 1.  We continue incrementing/decrementing ad infinitum, knowing that it would take an avid tester several lifetimes to blow out of a long.

When you hide a window, it remembers its row ID, and a relative position in that row.  When you show the window, if the row still exists, it will insert itself among the windows currently in the row (very important when hiding and showing the watch window in the default layout, since it shares a row with the variables window).  This aspect of rows will continue to work, even if you allow inserts.

However, what will break with the current algorithm is persitent row ordering.  Set-up 3 rows in a dock with one window in each.  Hide any window, and the show it again, and it will reappear in the same relative position.  The only way that you can absolutely guarantee this behavior is the current algorithm:  only add rows to the ends, so that comparison of row IDs can be used to determine relative position.

If people really, really want to have row inserts, which I didn't think were all that great without visual feedback that this was going to happen, here is how I would begin thinking about changing the algorithm:

(1) Raise the increment/decrement on the ends to 10 (or so).
(2) When inserting a row give it the average ID of its surrounding neighbors.

Problems:
This is way too simple, since it allows hidden rows to have their IDs taken.  Repro: Insert a new row.  Hide the window.  Insert another window in the same position.  Show the hidden window.  BUG:  It appears in the newly created row, not alone in a row of its own.
What happens when the surrounding rows have adjacent IDs?  The larger you make the row increment the less likely this is to ever happen, but you should to to stay above one tester lifetime to exhaust the ID space.

I would consider doing some sort of row usage ref counting thing, make the increment large enough, and live with poor ordering in the 0.1% case.

*/

#define INSERT_TOLERANCE CDockWorker::GetInsertTolerance()



///////////////////////////////////////////////////////////////////////////////
// OnCommandHelp helper

LRESULT CommandHelp(LPARAM lParam)
{
	if (theApp.CurrentPromptContext() != 0)
	{
		theApp.WinHelp(theApp.CurrentPromptContext());
		return TRUE;
	}
	if (lParam)
	{
		theApp.WinHelp(lParam);
		return TRUE;
	}
	else
	{
		// Handle case in which dockable has the focus.  We do not want to
		// catch this in CMainFrame, since that would require special testing
		// for cases in which a dialog was displayed.
		CPartView* pView = (CPartView*) CWnd::FromHandlePermanent(theApp.GetActiveView());
		if (pView && pView->IsKindOf(RUNTIME_CLASS(CPartView)))
		{
			CWnd * pWndFocus = CWnd::GetFocus();
			if ((pWndFocus == pView) || 
				pView->GetParentFrame()->IsChild(pWndFocus))
			{
				CString str;
				if (pView->GetHelpWord(str))
				{
					theApp.HelpOnKeyword(str);
					return TRUE;
				}
				lParam = pView->GetHelpID();
				if (lParam != 0)
				{
					theApp.HelpOnApplication(lParam,HELPTYPE_WINDOW);
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//	CPaletteWnd
//		The CPaletteWnd is the implementation for the palettes used in
//		docking for the floating state.  It is derived from CMiniFrameWnd.
//

// FUTURE : Use MFS_SYNCACTIVE
#define PWS_BASE (WS_CAPTION | WS_SYSMENU | WS_POPUP)

typedef RECT BORDERS;

static BORDERS borderPalette = {0,0,0,0};

void InitPaletteBorders()
{
	CRect rectWnd(0, 0, 100, 100);
	CRect rectClient;
	CMiniFrameWnd* pWndMini = new CMiniFrameWnd;

	if (!pWndMini->Create(NULL, NULL, PWS_BASE | MFS_THICKFRAME, rectWnd, NULL))
	{
		delete pWndMini;
		return;
	}

	pWndMini->GetWindowRect(rectWnd);
	pWndMini->GetClientRect(rectClient);
	pWndMini->ClientToScreen(rectClient);
	rectClient.InflateRect(::GetSystemMetrics(SM_CXBORDER),
		::GetSystemMetrics(SM_CYBORDER));

	borderPalette.left = rectClient.left - rectWnd.left;
	borderPalette.top = rectClient.top - rectWnd.top;
	borderPalette.right = rectWnd.right - rectClient.right;
	borderPalette.bottom = rectWnd.bottom - rectClient.bottom;

	pWndMini->DestroyWindow();	// Auto-deleting;
}

//	CPaletteWnd::GetPaletteRect
//		Given a reference to a rectangle, and (optionally) a pointer to a
//		window, expands the given rectangle (or the window rect) to return
//		a rectangle for a palette that could contain the given rectangle,
//		or window.

/*static*/ void CPaletteWnd::GetPaletteRect(CRect& rect, CWnd* pChild /*=NULL*/)
{
    if (pChild != NULL)
    {
        pChild->GetWindowRect(rect);
        ASSERT(!rect.IsRectEmpty());
    }

	rect.left -= borderPalette.left;
	rect.top -= borderPalette.top;
	rect.right += borderPalette.right;
	rect.bottom += borderPalette.bottom;
}

/*static*/ void CPaletteWnd::GetChildRect(CRect& rect)
{
	rect.left += borderPalette.left;
	rect.top += borderPalette.top;
	rect.right -= borderPalette.right;
	rect.bottom -= borderPalette.bottom;
}

//	CPaletteWnd::CPaletteWnd
//		Constructor; initializes a few variables.

CPaletteWnd::CPaletteWnd(CDockManager* pManager)
{
	ASSERT_VALID(pManager);
    m_pManager = pManager;
    m_hwndFocus = NULL;
}

//	CPaletteWnd::~CPaletteWnd
//		Destructor; destroys the window.

CPaletteWnd::~CPaletteWnd()
{
    DestroyWindow();
}

//	CPaletteWnd::Create
//		Two phase construction.  Creates a palette for the given child
//		window.	Note: rect is the rectangle of the child.

BOOL CPaletteWnd::Create(LPCSTR lpClassName, LPCSTR lpTitle, CWnd* pChild,
    CWnd* pParentWnd, CRect rect, UINT nID /*=0*/, BOOL bHasClose)
{
    DWORD dwStyle = PWS_BASE;
	DWORD dwChildStyle = pChild->GetStyle();

    if (dwChildStyle & DWS_STRETCHY)
    	dwStyle |= WS_THICKFRAME;
    else if (dwChildStyle & DWS_8SIZABLE)
    	dwStyle |= MFS_THICKFRAME;
	else
		dwStyle |= MFS_4THICKFRAME;

    if ((pChild->GetStyle() & (DWS_STRETCHY | DWS_SIZABLE | DWS_8SIZABLE)) == 0)
        dwStyle |= MFS_MOVEFRAME;

	dwStyle |= MFS_BLOCKSYSMENU;

    GetPaletteRect(rect);
	if (!CMiniFrameWnd::Create(NULL, lpTitle, dwStyle,
            rect, pParentWnd))
    {
        return FALSE;
    }

	if (theApp.m_bWin4)
	{
		// Chicago may want to show a system menu for this window, so let's
		// make sure it looks consistent with the rest of our app.

		CMenu* pMenu = GetSystemMenu(FALSE);
		if (pMenu != NULL)
		{
			CString str;
		    if ((dwChildStyle & DWS_STRETCHY) == 0)
				pMenu->DeleteMenu(SC_SIZE, MF_BYCOMMAND);
			else
			{
				str.LoadString(IDS_DOCKABLE_SIZE);
				pMenu->ModifyMenu(SC_SIZE, MF_BYCOMMAND | MF_STRING,
					SC_SIZE, str);
			}

			str.LoadString(IDS_DOCKABLE_MOVE);
			pMenu->ModifyMenu(SC_MOVE, MF_BYCOMMAND | MF_STRING,
				SC_MOVE, str);

			str.LoadString(IDS_DOCKABLE_CLOSE);
			pMenu->ModifyMenu(SC_CLOSE, MF_BYCOMMAND | MF_STRING,
				SC_CLOSE, str);

			if(!bHasClose)
			{
				pMenu->EnableMenuItem(SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);
			}

			pMenu->DeleteMenu(SC_MAXIMIZE, MF_BYCOMMAND);
			pMenu->DeleteMenu(SC_MINIMIZE, MF_BYCOMMAND);
			pMenu->DeleteMenu(SC_RESTORE, MF_BYCOMMAND);
		}
	}

    pChild->SetParent(this);

	// FUTURE : Use MFS_SYNCACTIVE
	ActivateWindow(TRUE);	// Show active caption color.

    CRect rectChild;
    GetClientRect(rectChild);
    rectChild.InflateRect(g_mt.cxBorder, g_mt.cyBorder);
    pChild->SetWindowPos(NULL, rectChild.left, rectChild.top,
        rectChild.Width(), rectChild.Height(),
        SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);

	ActivateNoFocus();

    m_pManager->AddPalette(this);

    return TRUE;
}

//	CPaletteWnd::ActivateWindow
//		Highlights or de-highlights the palette's caption.  Used instead of
//		normal activation/deactivation so that all palettes appear active while
//		the main frame is active.

void CPaletteWnd::ActivateWindow(BOOL bActive)
{
	// FUTURE : Use MFS_SYNCACTIVE
	SetWindowLong(m_hWnd, GWL_STYLE, GetStyle() | MFS_SYNCACTIVE);
	SendMessage(WM_NCACTIVATE, bActive);
}

void CPaletteWnd::ActivateNoFocus()
{
	// Make sure we come up on top, but not above a customize dialog,
	// or the splash screen.
	const CWnd* pWnd = &CWnd::wndTop;
#if 0
	if (PwndSplashScreen() != NULL)
	{
		pWnd = PwndSplashScreen();
	}
	else if (CASBar::s_pCustomizer != NULL &&
		CASBar::s_pCustomizer->m_pDialog != NULL)
	{
		pWnd = CASBar::s_pCustomizer->m_pDialog;
	}
#else
	HWND hWnd = m_pManager->m_pFrame->GetSafeHwnd();
	if (hWnd != NULL)
		hWnd = ::GetLastActivePopup(hWnd);
	CWnd* pWndPopup = FromHandle(hWnd);

	if (PwndSplashScreen() != NULL)
	{
		pWnd = PwndSplashScreen();
	}
	else if (pWndPopup != NULL && (pWndPopup->IsKindOf(RUNTIME_CLASS(CDialog)) ||
		pWndPopup->IsKindOf(RUNTIME_CLASS(CTabbedDialog))))
	{
		pWnd = pWndPopup;
	}
#endif

	SetWindowPos(pWnd, 0, 0, 0, 0,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
}

void CPaletteWnd::SaveFocus()
{
	// Don't save focus, if the palette contains the active view.
	HWND hwndView = theApp.GetActiveView();
	if (hwndView != NULL && ::IsChild(m_hWnd, hwndView))
		m_hwndFocus = NULL;
	else
		m_hwndFocus = ::GetFocus();

	if (m_hwndFocus != NULL && !::IsChild(m_hWnd, m_hwndFocus))
		m_hwndFocus = NULL;
}

void CPaletteWnd::RestoreFocus()
{
	CWnd* pChild;
	if (m_hwndFocus != NULL)
		::SetFocus(m_hwndFocus);
	else if ((pChild = GetTopWindow()) != NULL)
		pChild->SetFocus();
}

IMPLEMENT_DYNAMIC(CPaletteWnd, CMiniFrameWnd)

BEGIN_MESSAGE_MAP(CPaletteWnd, CMiniFrameWnd)
//{{AFX_MSG_MAP(CPaletteWnd)
    ON_WM_NCACTIVATE()
    ON_WM_NCLBUTTONDOWN()
    ON_WM_NCLBUTTONDBLCLK()
    ON_WM_CLOSE()
    ON_WM_SIZE()
	ON_WM_RBUTTONUP()
	ON_WM_NCRBUTTONUP()
	ON_WM_ACTIVATE()
	ON_WM_KEYDOWN()
	ON_WM_SYSCOMMAND()
	ON_WM_MOUSEACTIVATE()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString)
    ON_REGISTERED_MESSAGE(DMM_CHILDSETFOCUS, OnRouteMessage)
    ON_REGISTERED_MESSAGE(DMM_CHILDKILLFOCUS, OnRouteMessage)
    ON_REGISTERED_MESSAGE(DMM_NCLBUTTONDOWN, OnRouteMessage)
    ON_REGISTERED_MESSAGE(DMM_NCLBUTTONDBLCLK, OnRouteMessage)
	ON_REGISTERED_MESSAGE(DSM_BARSIZECHANGING, OnBarSizeChanging)
END_MESSAGE_MAP()

//	CPaletteWnd::PreTranslateMessage
//		Forward MDI keys to MDI.

BOOL CPaletteWnd::PreTranslateMessage(MSG* pMsg)
{
	if (MDIKeyMessage(pMsg))
		return TRUE;

	return CMiniFrameWnd::PreTranslateMessage(pMsg);
}

//	CPaletteWnd::OnRouteMessage
//		Used to route DMM_* messages to the worker for the HWND in wParam.

LRESULT CPaletteWnd::OnRouteMessage(WPARAM wParam, LPARAM lParam)
{
    return m_pManager->WorkerMessage(GetCurrentMessage()->message,
        (HWND) wParam, lParam);
}

LRESULT CPaletteWnd::OnCommandHelp(WPARAM, LPARAM lParam)
{
	return CommandHelp(lParam);
}

//	CPaletteWnd::OnCommand
//		Routes all commands except Help to the palette's owner (the frame).

BOOL CPaletteWnd::OnCommand(WPARAM wParam, LPARAM lParam)
{
    return !!GetParent()->SendMessage(WM_COMMAND, wParam, lParam);
}

//	CPaletteWnd::OnNcActivate
//		Override to prevent caption activation\deactivation.  Use
//		ActivateWindow() instead.

BOOL CPaletteWnd::OnNcActivate(BOOL bActive)
{
	// FUTURE : MFC: Use MFS_SYNCACTIVE
	if (GetStyle() & MFS_SYNCACTIVE)
	{
		SetWindowLong(m_hWnd, GWL_STYLE, GetStyle() & ~MFS_SYNCACTIVE);
		return CMiniFrameWnd::OnNcActivate(bActive);
	}

	return TRUE;
}

void CPaletteWnd::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized)
{
	if (nState == WA_INACTIVE)
		SaveFocus();

	// Do not restore focus, if we already have it.
	else if (!IsChild(GetFocus()))
	{
		CDockWorker* pDocker = m_pManager->WorkerFromWindow(GetTopWindow());
		if (pDocker != NULL && pDocker->m_dtWnd != dtEdit && pWndOther == NULL)
			m_pManager->m_pFrame->SetActiveWindow();
		else
			RestoreFocus();
	}
}

// ensure that everyone gets a chance to adapt to a change in toolbar size
LRESULT CPaletteWnd::OnBarSizeChanging(WPARAM wParam, LPARAM lParam)
{
	SendMessageToDescendants(DSM_BARSIZECHANGING, wParam, lParam, TRUE, FALSE); 

	return 0;
}

CDockWorker* CPaletteWnd::GetWorker() const
{
	return m_pManager->WorkerFromWindow(GetTopWindow());
}

//	CPaletteWnd::OnClose
//		Defers to dock manager to get rid of the window.

void CPaletteWnd::OnClose()
{
	CDockWorker* pDocker = GetWorker();
	ASSERT_VALID(pDocker);
	pDocker->ShowWindow(FALSE);
}

//	CPaletteWnd::OnNcLButtonDown
//		Route move and size handling to the child for processing by the
//		CDockWorker.

void CPaletteWnd::OnNcLButtonDown(UINT nHitTest, CPoint pt)
{
	extern void SushiCancelModes(HWND hWndRcvr);
	SushiCancelModes(m_hWnd);

	switch (nHitTest)
	{
    case HTBOTTOM:
    case HTTOP:
    case HTLEFT:
	case HTBOTTOMLEFT:
	case HTTOPLEFT:
    case HTRIGHT:
	case HTBOTTOMRIGHT:
	case HTTOPRIGHT:
    case HTCAPTION:
    	//BLOCK:
    	{
    		CWnd* pChild = GetTopWindow();
    		ASSERT(pChild != NULL);

    		if (nHitTest != HTCAPTION && (pChild->GetStyle() & DWS_STRETCHY) != 0)
    			break;

            pChild->SendMessage(WM_NCLBUTTONDOWN, nHitTest,
                MAKELONG(pt.x, pt.y));
        }
        return;
	}

	CMiniFrameWnd::OnNcLButtonDown(nHitTest, pt);
}

//	CPaletteWnd::OnNcLButtonDblClk
//		Double-click in the caption causes toggle between float and dock.
//		Let the child window/CDockWorker handle it.

void CPaletteWnd::OnNcLButtonDblClk(UINT nHitTest, CPoint pt)
{
    if (nHitTest != HTCAPTION)
		CMiniFrameWnd::OnNcLButtonDblClk(nHitTest, pt);
    else
    {
        CWnd* pChild = GetTopWindow();
        ASSERT(pChild != NULL);
        pChild->SendMessage(WM_NCLBUTTONDBLCLK, nHitTest, MAKELONG(pt.x, pt.y));
    }
}

void CPaletteWnd::OnNcRButtonUp(UINT nHitTest, CPoint point)
{
	if (theApp.m_bWin4)
	{
		// Don't show our menu when Win95 will show its menu.
		CWnd* pWnd = GetFocus();
		if ((pWnd == this || IsChild(pWnd)) && nHitTest == HTCAPTION)
		{
			CMiniFrameWnd::OnNcRButtonUp(nHitTest, point);
			return;
		}
	}

	ScreenToClient(&point);
	CPaletteWnd::OnRButtonUp(0, point);
}

void CPaletteWnd::OnRButtonUp(UINT nFlags, CPoint point)
{
	CMiniFrameWnd::OnRButtonUp(nFlags, point);

	ClientToScreen(&point);
	m_pManager->ShowMenu(point);
}

void CPaletteWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_ESCAPE)
		theApp.ReactivateView();

	CMiniFrameWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

//	CPaletteWnd::OnSize
//		Palette makes sure the child is sized to a perfect fit inside its
//		client area when it gets sized.

void CPaletteWnd::OnSize(UINT nType, int cx, int cy)
{
    if (nType == SIZE_RESTORED)
    {
        CRect rect;
        CWnd* pChild;

        GetClientRect(rect);
        rect.InflateRect(g_mt.cxBorder, g_mt.cyBorder);
        if ((pChild = GetTopWindow()) != NULL)
        {
            pChild->SetWindowPos(NULL, rect.left, rect.top,
                rect.Width(), rect.Height(), SWP_NOACTIVATE | SWP_NOZORDER);
        }
    }

	CMiniFrameWnd::OnSize(nType, cx, cy);
}

int CPaletteWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest,
	UINT message)
{
	if (theApp.m_hwndValidate != NULL &&
		::SendMessage(theApp.m_hwndValidate, WM_ISERROR, 0, 0L))
	{
		return MA_NOACTIVATEANDEAT;
	}

	int nReturn = MA_NOACTIVATE;
	CDockWorker* pDocker = m_pManager->WorkerFromWindow(GetTopWindow());
	if (pDocker != NULL && pDocker->m_dtWnd == dtEdit &&
			CASBar::s_pCustomizer == NULL)
		nReturn = MA_ACTIVATE;

	if (theApp.m_bDeactByOtherApp)
	{
		pDocker = CDockWorker::s_pActiveDocker;
		if (pDocker != NULL && pDocker->GetDock() == dpNil)
		{
			ASSERT(pDocker->m_pWnd != NULL);
			pDocker->m_pWnd->SetFocus();
		}
		else
		{
			m_pManager->m_pFrame->SetActiveWindow();
		}
	}

	ActivateNoFocus();
	UpdateWindow();

	return nReturn;
}

void CPaletteWnd::OnSysCommand(UINT nID, LPARAM lParam)
{
	switch (nID & 0xfff0)
	{
	case SC_CLOSE:
		if (lParam == 0L)
		{
			// User pressed Alt+F4. Forward so we close the whole App.
			CWnd* pParent = GetParent();
			ASSERT(pParent != NULL);

//	    	pParent->SetActiveWindow();
	        pParent->SendMessage(WM_SYSCOMMAND, nID, lParam);
//	        SetActiveWindow();	Crashes the application.
			return;
		}
		break;

	case SC_KEYMENU:
		if (lParam != 0L)
			CDockWorker::LockWorker();	// CMiniFrameWnd will forward to frame.
		break;
	}

	CMiniFrameWnd::OnSysCommand(nID, lParam);
}

LRESULT CPaletteWnd::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(m_pManager);

	m_nIDLastMessage = (UINT)wParam;    // new ID (or 0)
	m_nIDTracking = (UINT)wParam;       // so F1 on toolbar buttons work

	return m_pManager->m_pFrame->SendMessage(WM_SETMESSAGESTRING,
		wParam, lParam);
}

/////////////////////////////////////////////////////////////////////////////
// CDockWnd

#ifdef _DEBUG
extern BOOL bChicagoLookOnNT;
inline BOOL OnChicago() { return theApp.m_bWin4 || bChicagoLookOnNT; }
#else
inline BOOL OnChicago() { return theApp.m_bWin4; }
#endif

// static variables
//
HCURSOR CDockWnd::s_hcurVSize = NULL;
HCURSOR CDockWnd::s_hcurHSize = NULL;

CDockWnd::CDockWnd()
{
    if (s_hcurHSize == NULL)
    {
        VERIFY(s_hcurHSize = AfxLoadCursor(AFX_IDC_VSPLITBAR));
        VERIFY(s_hcurVSize = AfxLoadCursor(AFX_IDC_HSPLITBAR));
    }

    m_nAlong = 0;
	m_bInitialized = FALSE;
	m_bChicagoSizingHack = FALSE;
}

void CDockWnd::Serialize(CArchive& ar)
{
	int i;

	if (ar.IsStoring())
	{
		ar << (WORD) m_dp << (DWORD) m_nIDNext
			<< (DWORD) m_nIDPrev << (WORD) m_nRows;

		for (i = 0; i <= m_nRows; i++)
		{
			ar << (WORD) m_arRows[i].nStart
				<< (DWORD) m_arRows[i].nIDRow
				<< (WORD) m_arRows[i].bStretchy
				<< (WORD) m_arRows[i].bMaxy
				<< (WORD) m_arRows[i].bMenuBar
				;

			ASSERT(m_arRows[i].bInit);
			if (m_arRows[i].pWndMax == NULL)
				ar << (DWORD) 0;
			else
			{
				CDockWorker* pDocker = m_pManager->
					WorkerFromWindow(m_arRows[i].pWndMax);
				if (pDocker == NULL)
					ar << (DWORD) 0;
				else
				{
					ar << (DWORD) pDocker->m_nIDWnd;
				}
			}
		}
	}
	else
	{
		WORD w;
		DWORD dw;

		ar >> w >> dw;
		m_dp  = (DOCKPOS) w;
		m_nIDNext = (ULONG) dw;
		ar >> dw >> w;
		m_nIDPrev = (ULONG) dw;
		m_nRows = w;

		m_arRows = new ROWSTRUCT[m_nRows + 1];

		for (i = 0; i <= m_nRows; i++)
		{
			ar >> w >> dw;
			m_arRows[i].nStart = (signed short)w;
			m_arRows[i].nIDRow = (ULONG) dw;
			ar >> w;
			m_arRows[i].bStretchy = w;
			ar >> w;
			m_arRows[i].bMaxy = w;
			ar >> w;
			m_arRows[i].bMenuBar = w;
			ar >> dw;
			m_arRows[i].nIDMaxWindow = dw;
			m_arRows[i].bInit = (i == m_nRows);	// Mark sentinal row as initialized.
		    m_arRows[i].nSplitters = 0;
		    m_arRows[i].pnPositions = NULL;
		}
	}
}

//  CDockWnd::CDockWnd
//      Constructor, initializes statics if this is the first CDockWnd.

CDockWnd::CDockWnd(DOCKPOS dp)
{
    if (s_hcurHSize == NULL)
    {
        VERIFY(s_hcurHSize = AfxLoadCursor(AFX_IDC_VSPLITBAR));
        VERIFY(s_hcurVSize = AfxLoadCursor(AFX_IDC_HSPLITBAR));
    }

    m_dp = dp;
    m_nAlong = 0;
	m_bInitialized = FALSE;
	m_bChicagoSizingHack = FALSE;
	m_nIDNext = ULONG_MAX / 2;
	m_nIDPrev = m_nIDNext - 1;
    m_nRows = 0;

    m_arRows = new ROWSTRUCT[1];
	m_arRows[0].nStart = -g_mt.cyBorder;
	m_arRows[0].nIDRow = m_nIDNext++;
    m_arRows[0].bStretchy = FALSE;
    m_arRows[0].bMenuBar = FALSE;
    m_arRows[0].bMaxy = FALSE;
	m_arRows[0].bInit = TRUE;
    m_arRows[0].pWndMax = NULL;
    m_arRows[0].nSplitters = 0;
    m_arRows[0].pnPositions = NULL;
}

//	CDockWnd::~CDockWnd
//		Destructor; destroys window.

CDockWnd::~CDockWnd()
{
	for (int i = 0; i < m_nRows; i++)
		delete [] m_arRows[i].pnPositions;

	delete [] m_arRows;

    DestroyWindow();
}

BOOL CDockWnd::Create(CFrameWnd* pFrame, UINT nID, CDockManager* pManager)
{
    m_pManager = pManager;

    LONG dwStyle = WS_CHILD | WS_CLIPSIBLINGS;
	if (!OnChicago())
		dwStyle |= WS_BORDER | WS_CLIPCHILDREN;
    if (m_dp != dpHide && pManager->IsVisible())
    	dwStyle |= WS_VISIBLE;

	CSize size(::GetSystemMetrics(SM_CXSCREEN) + 5,
		::GetSystemMetrics(SM_CYSCREEN) + 5);	// +5 to assure that we get recalc'ed.
	DockTranspose(m_dp, &size);
	m_nAlong = size.cx;
	size.cy = 0;
	DockTranspose(m_dp, &size);

    CRect rect(CPoint(-1, -1), size);	// Sized during OnSizeParent.
//    rect.SetRectEmpty();	// Sized during OnSizeParent.
    return CWnd::Create(AfxRegisterWndClass(CS_DBLCLKS,
    						NULL,
    						OnChicago() ? NULL : (HBRUSH)(COLOR_BTNFACE + 1)),
		NULL, dwStyle, rect, pFrame, nID);
}

///////////////////////////////////////////////////////////////////////////////
//	Layout
//

//	CDockWnd::GetRowInfo
//		Creates a null terminated array of _DWI (Dock Window Info) structs
//		containing info for all the windows in a row, or in the whole dock
//		if the row is -1.

_DWI* CDockWnd::GetRowInfo(int iRow /*=-1*/)
{
    // Allocate the structure.
    int cWnds = 0;
    for (CWnd* pWnd = GetTopWindow(); pWnd != NULL;
    	pWnd = pWnd->GetWindow(GW_HWNDNEXT))
        cWnds++;	// Enough space for all windows.

    _DWI* rgdwi = new _DWI[cWnds + 1];  // pWnd == NULL terminated

    // Fill the structure.
    cWnds = 0;
    for (pWnd = GetTopWindow(); pWnd != NULL;
    	pWnd = pWnd->GetWindow(GW_HWNDNEXT))
    {
        GetDockInfo(&rgdwi[cWnds], pWnd);

        if (iRow == -1 || iRow == rgdwi[cWnds].iRow)
        	cWnds++;
    }

    rgdwi[cWnds].pWnd = NULL;

    if (iRow != -1)
    	SortRow(rgdwi, iRow);

    return rgdwi;
}

//  CDockWnd::BeginLayout
//      Returns a pointer to layout structure for defered layout.  This
//      allows for multiple repositionings of windows before we actually
//      need to tell Windows were to put the window.

_DWI* CDockWnd::BeginLayout()
{
    return GetRowInfo();
}

static void ValidateWndDeep(CWnd* pWnd)
{
	pWnd->ValidateRect(NULL);

	// Deep validation.
	for (CWnd* pWndChild = pWnd->GetTopWindow(); pWndChild != NULL;
			pWndChild = pWndChild->GetWindow(GW_HWNDNEXT))
		ValidateWndDeep(pWndChild);
}

// This hacky UpdateWindow() replacement, fixes a problem we had with
// async painting under Chicago.

static void ChicagoUpdateWindowHack(CWnd* pWnd)
{
	// Deep update, since hack in async paint code may cause childred to
	// be skipped.

	for (CWnd* pWndChild = pWnd->GetTopWindow(); pWndChild != NULL;
			pWndChild = pWndChild->GetWindow(GW_HWNDNEXT))
		ChicagoUpdateWindowHack(pWndChild);

	pWnd->UpdateWindow();
}

//  CDockWnd::EndLayout
//      Actually reposition the windows that have been moved in the layout
//      structure.  And deallocate the layout structure.

void CDockWnd::EndLayout(_DWI* rgdwi, BOOL bRecalc /*=TRUE*/)
{
    ASSERT(rgdwi != NULL);

	// Get the style before we hide the window.
    DWORD dwStyle = GetStyle();

    int nWnds = 0;
    for (_DWI* pdwi = rgdwi; pdwi->pWnd != NULL; pdwi++)
    	nWnds++;

    CRect rectWnd;
	
	if (OnChicago() /*&& m_bChicagoSizingHack*/)
		ChicagoUpdateWindowHack(this);
	else
		UpdateWindow();

    ShowWindow(SW_HIDE);

    HDWP hdwp = ::BeginDeferWindowPos(nWnds);
    for (pdwi = rgdwi; pdwi->pWnd != NULL; pdwi++)
    {
        CRect rectNew(CPoint(pdwi->iPos, GetWindowOffset(pdwi->iRow)),
        	CSize(pdwi->cAlong, pdwi->cAcross));
        DockTranspose(m_dp, rectNew);

        pdwi->pWnd->GetWindowRect(rectWnd);
        pdwi->iPos = rectWnd.left;	// Save window coords.
        pdwi->iRow = rectWnd.top;
        pdwi->cAlong = rectWnd.Width();
        pdwi->cAcross = rectWnd.Height();
        ScreenToClient(rectWnd);

        // Only move it if position/size changed, or it needs to be shown.
        if (rectNew != rectWnd)
        {
            hdwp = ::DeferWindowPos(hdwp,
            	pdwi->pWnd->GetSafeHwnd(), NULL,
                rectNew.left, rectNew.top,
                rectNew.Width(), rectNew.Height(),
                SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);
        }
    }
	::EndDeferWindowPos(hdwp);

    if ((dwStyle & WS_VISIBLE) != 0)
	{
		ShowWindow(SW_SHOWNOACTIVATE);

	    // The DockWnd itself may need to be sized.
	    if (bRecalc)
	    	GetParentFrame()->RecalcLayout();

	    for (pdwi = rgdwi; pdwi->pWnd != NULL; pdwi++)
	    {
	        CRect rectNew(CPoint(pdwi->iPos, pdwi->iRow),
	        	CSize(pdwi->cAlong, pdwi->cAcross));
	    	pdwi->pWnd->GetWindowRect(rectWnd);

	    	// Validate windows that haven't moved.
	    	if (rectNew == rectWnd)
		    	ValidateWndDeep(pdwi->pWnd);
	    }

		UpdateWindow();
	}

    delete [] rgdwi;
}

//  CDockWnd::FindDockInfo

_DWI* CDockWnd::FindDockInfo(_DWI* pdwi, CWnd* pWndFind)
{
    ASSERT(pdwi != NULL);

    for ( ; pdwi->pWnd != pWndFind; pdwi++)
        ASSERT(pdwi->pWnd);   // window is not part of layout

    return pdwi;
}

//  CDockWnd::GetDockInfo
//      Given a layout struct pointer, and a window, fills the struct with
//      the windows dock info.

void CDockWnd::GetDockInfo(_DWI* pdwi, CWnd* pWnd)
{
    ASSERT(pdwi != NULL);
    ASSERT_VALID(pWnd);

    CRect rectPane;
	pWnd->GetWindowRect(rectPane);
	ScreenToClient(rectPane);
    DockTranspose(m_dp, rectPane);

	pdwi->pWnd = pWnd;
    pdwi->iRow = rectPane.top;
    pdwi->iPos = rectPane.left;
    pdwi->cAlong = rectPane.Width();
    pdwi->cAcross = rectPane.Height();

    // Convert to canonical row.
    for (int iRow = 0; GetWindowOffset(iRow) != pdwi->iRow && iRow<m_nRows; iRow++)
	{
		// ASSERT(iRow < m_nRows);    // it is not in a row
	}

	if(iRow==m_nRows)
	{
		--iRow;
	}

    pdwi->iRow = iRow;
}

int CDockWnd::GetWindowOffset(int iRow)
{
    CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
    DockTranspose(m_dp, &sizeBorder);

    BOOL bSplitAbove = (m_dp == dpRight || m_dp == dpBottom);
    int nOffset;

	nOffset = m_arRows[iRow].nStart;
	if (m_arRows[iRow].bStretchy && bSplitAbove)
		nOffset += g_mt.nSplitter + sizeBorder.cy;

	return nOffset;
}

void CDockWnd::GetDockRestore(DOCKRESTORE* pdr, CWnd* pWnd)
{
	ASSERT(IsChild(pWnd));

	_DWI dwi;
	GetDockInfo(&dwi, pWnd);
	pdr->iPos = dwi.iPos;
	pdr->cAlong = dwi.cAlong;
	pdr->cAcross = dwi.cAcross;
	pdr->nIDRow = m_arRows[dwi.iRow].nIDRow;
}

//  CDockWnd::AddWnd
//      Give a window pointer and a size, adds the window to the dock at the
//      next available location, sizing it to the given size.

BOOL CDockWnd::AddWnd(CWnd* pWnd, CSize size)
{
    CRect rect;
    int iMaxPos = 0;

    // Determine the maximum extent of all windows in the last dock row.
    for (CWnd* pWndPane = GetTopWindow(); pWndPane != NULL;
        pWndPane = pWndPane->GetWindow(GW_HWNDNEXT))
    {
        _DWI dwi;
        GetDockInfo(&dwi, pWndPane);

        if (dwi.iRow == m_nRows - 1)
        {
            pWndPane->GetWindowRect(rect);
            DockTranspose(m_dp, rect);
            iMaxPos = max(iMaxPos, dwi.iPos + rect.Width());
        }
    }

    CRect rectAdd(-g_mt.cxBorder, -g_mt.cyBorder,
    	size.cx - g_mt.cxBorder, size.cy - g_mt.cyBorder);
    DockTranspose(m_dp, rectAdd);

    GetClientRect(rect);
    DockTranspose(m_dp, rect);

    CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
    DockTranspose(m_dp, &sizeBorder);

    // Determine new x and y.
    if (m_nRows == 0 ||
        (iMaxPos + size.cx - (sizeBorder.cx * 2)) > rect.right)
    {
        rectAdd.OffsetRect(0, GetWindowOffset(m_nRows));
    }
    else
    {
    	// center in last row.
        rectAdd.OffsetRect(iMaxPos,
        	(m_arRows[m_nRows].nStart + m_arRows[m_nRows - 1].nStart) / 2 -
        	(rectAdd.bottom + rectAdd.top) / 2);
    }

    DockTranspose(m_dp, rectAdd);
	ClientToScreen(rectAdd);
	return AddWnd(pWnd, rectAdd);
}

//  CDockWnd::AddWnd
//      Given a window pointer, and a restore struct, attempts to add the
//		window to the dock as consistent as possible with the information
//		in the restore struct, following layout rules.

BOOL CDockWnd::AddWnd(CWnd* pWnd, DOCKRESTORE* pdr)
{
	// Find the row in which the window will be placed.
	int iRowLeastBig = -1;
	for (int iRow = 0; iRow < m_nRows; iRow++)
	{
		if (m_arRows[iRow].nIDRow == pdr->nIDRow)
			break;
		// If INSERT_TOLERANCE is 0 then rows will only be inserted at the
		// top or bottom of the dock, so we are assured that IDs are in
		// sorted order.  This allows us to insert rows in the middle of an
		// existing dock, maintaining row ordering.
		else if (INSERT_TOLERANCE == 0 && m_arRows[iRow].nIDRow > pdr->nIDRow)
		{
			// Because of row wrapping we may have a few stray out of
			// order row IDs, so we attempt to ignore them here.
			//
			if (iRowLeastBig == -1 ||
				m_arRows[iRow].nIDRow < m_arRows[iRowLeastBig].nIDRow)
				iRowLeastBig = iRow;
		}
	}

	if (iRow >= m_nRows && iRowLeastBig != -1)
		iRow = iRowLeastBig;

	// If we are a stretchy window being added to an existing row, we
	// may need to adjust the size the window is requesting, or it could
	// reduce all other stretchy windows to min width.
	//
	if ((pWnd->GetStyle() & DWS_STRETCHY) != 0 &&
		iRow < m_nRows && m_arRows[iRow].nIDRow == pdr->nIDRow)
	{
	    CRect rectDock;
	    GetClientRect(rectDock);
	    CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
	    rectDock.InflateRect(sizeBorder);
	    DockTranspose(m_dp, rectDock);
	    DockTranspose(m_dp, &sizeBorder);

		CPoint ptMin = CDockWorker::GetDefMin();
		DockTranspose(m_dp, &ptMin);

		int nSplitterCount = 1, iWnd = 0;
		int nTotalSize = ptMin.x, nStretchCount = 1;	// Count the window.
		int nLastStretch = -1;

		// Calculate how far off we are.
		_DWI* rgdwi = GetRowInfo(iRow);
		for (_DWI* pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == iRow;
			pdwi++, iWnd++)
		{
		    if ((pdwi->pWnd->GetStyle() & DWS_STRETCHY) == 0)
		    	nTotalSize += pdwi->cAlong - sizeBorder.cx;
			else
		    {
		    	if (nLastStretch != -1)
		    	{
		    		if (nLastStretch == iWnd - 1)
		    			nSplitterCount++;
		    		else
		    			nSplitterCount += 2;
		    	}

				nStretchCount++;
		    	nTotalSize += ptMin.x - sizeBorder.cx;
	    		nLastStretch = iWnd;
		    }
		}
		delete [] rgdwi;

		if (nTotalSize > 0)
			nTotalSize += sizeBorder.cx + nSplitterCount * (g_mt.nSplitter + 1);

		// If the window wants more than the available stretch space,
		// then it only gets a part.  Yes this is arbitrary, but it is
		// better than having other stretchy windows minimized.
		//
		int nMaxFit = rectDock.Width() - nTotalSize;
		if (pdr->cAlong >= nMaxFit)
			pdr->cAlong = max(ptMin.x, nMaxFit / nStretchCount);
	}

	// Construct the rect we will use to add the window.
    CRect rectAdd;

	if (iRow >= m_nRows)
		rectAdd.top = m_arRows[m_nRows].nStart;
	else
	{
		// Center rect on the row of interest.
		rectAdd.top = (m_arRows[iRow + 1].nStart + m_arRows[iRow].nStart) / 2 -
    		pdr->cAcross / 2;
	}

	rectAdd.left = pdr->iPos;
	rectAdd.bottom = rectAdd.top + pdr->cAcross;
	rectAdd.right = rectAdd.left + pdr->cAlong;

    DockTranspose(m_dp, rectAdd);
	ClientToScreen(rectAdd);

	if (iRow < m_nRows && m_arRows[iRow].nIDRow == pdr->nIDRow)
		return AddWnd(pWnd, rectAdd);
	else
		return AddWnd(pWnd, rectAdd, pdr->nIDRow);	// Force an insert of this row.
}

//  CDockWnd::AddWnd
//      Given a window pointer, and a rect, attempts to add the window to
//      the dock as close as possible to the given rectangle, following
//		layout rules.

BOOL CDockWnd::AddWnd(CWnd* pWnd, const CRect& rect, ULONG nID /*=ULONG_MAX*/)
{
    pWnd->ShowWindow(SW_HIDE);    // Hide the window for SetParent, and SetPos.

    if (pWnd->SetParent(this) == NULL)
    {
    	pWnd->ShowWindow(SW_SHOWNOACTIVATE);
    	return FALSE;
    }

	CRect rectPlace = rect;

	// Add a row, if we don't have any.
	if (m_nRows == 0)
	{
		CSize size(rect.Size());
		DockTranspose(m_dp, &size);

		_DWI dwi;
		dwi.pWnd = NULL;	// Empty DWI structure.
		InsertRow(&dwi, 0, size.cy, nID);

		// Force the placement rect into the new row.
		CPoint ptPlace(0, 0);
		ClientToScreen(&ptPlace);
		if (m_dp == dpLeft || m_dp == dpRight)
			rectPlace.OffsetRect(ptPlace.x - rectPlace.left, 0);
		else
			rectPlace.OffsetRect(0, ptPlace.y - rectPlace.top);
	}

    // Set position to be on a row, so we can just use MoveWnd.
    // And size the window.
	CPoint ptAdd(-2, GetWindowOffset(0));	// -2 forces the window to be moved.
	DockTranspose(m_dp, &ptAdd);
    pWnd->SetWindowPos(NULL,
        ptAdd.x, ptAdd.y, rectPlace.Width(), rectPlace.Height(),
        SWP_NOACTIVATE | SWP_NOZORDER);

	MoveWnd(pWnd, rectPlace, TRUE, nID);

	ASSERT(pWnd->GetStyle() & WS_VISIBLE);	// EndLayout should have shown.

    return TRUE;
}

//  CDockWnd::MoveWnd
//      Given a window pointer, and a rect, moves the window from its current
//      location in the dock to the new specified location (layout rules
//      applied to the rect).

void CDockWnd::MoveWnd(CWnd* pWnd, CRect rect,
	BOOL bAdd /*=FALSE*/, ULONG nID /*=ULONG_MAX*/)
{
	// We used to assert here, to ensure that were were correctly parented to the dock. Sadly, at the 
	// moment, this can happen in 'valid' situations during layout switches. So we
	// simply return
    // ASSERT(IsChild(pWnd));
	if(!IsChild(pWnd))
	{
		return;
	}

    _DWI dwiMove;

    BOOL bInsert =IsInsert(rect, &dwiMove.iRow, (pWnd->GetStyle() & DWS_MENUBAR)!=0);

	BOOL bStretchTest = OnChicago() && (m_dp == dpRight || m_dp == dpBottom);
	BOOL bStretchy;

    ScreenToClient(rect);
    DockTranspose(m_dp, rect);

    dwiMove.pWnd = pWnd;
    dwiMove.iPos = rect.left;
    dwiMove.cAlong = rect.Width();
    dwiMove.cAcross = rect.Height();

    _DWI* pdwi = BeginLayout();

    if (bInsert || (nID != ULONG_MAX && nID != m_arRows[dwiMove.iRow].nIDRow))
        InsertRow(pdwi, dwiMove.iRow, dwiMove.cAcross, nID);

    _DWI* pdwiFind = FindDockInfo(pdwi, pWnd);
    int iRowOld = pdwiFind->iRow;  // Save the old row.
    *pdwiFind = dwiMove;    // Reset the moved window dock info.

    if (!bAdd && dwiMove.iRow != iRowOld)
    {
		bStretchy = m_arRows[iRowOld].bStretchy;	// Stretchy before?

	    if (!IsRowEmpty(pdwi, iRowOld))
	    {
	    	// In case we removed the largest docked window.
	    	RecalcRow(pdwi, iRowOld);
	    }
	    else
	    {
	        RemoveRow(pdwi, iRowOld);

	        // Old row changes if it was after the one we just removed.
	        if (dwiMove.iRow > iRowOld)
	            dwiMove.iRow--;
	    }

		// Did this row's stretchy status change?
		// Note: we have a sentinel non-stretchy row at m_nRows, so this is
		//       is always a valid test.
		if (bStretchTest && iRowOld > 0 &&
			bStretchy != m_arRows[iRowOld].bStretchy)
		{
			SizeRow(pdwi, iRowOld - 1);
		}
	}

	bStretchy = m_arRows[dwiMove.iRow].bStretchy;	// Stretchy before?

    RecalcRow(pdwi, dwiMove.iRow, pWnd);    // This might wrap and add a row.

	// Did this row's stretchy status change?
	if (bStretchTest && dwiMove.iRow > 0 &&
		bStretchy != m_arRows[dwiMove.iRow].bStretchy)
	{
		SizeRow(pdwi, dwiMove.iRow - 1);
	}

    EndLayout(pdwi);
}

BOOL CDockWnd::IsInsert(CRect rect, int* piRow, BOOL bMenu)
{
    ScreenToClient(rect);
    DockTranspose(m_dp, rect);

    int iCompare = rect.top + rect.Height() / 2;

    // Which row are we in?
    for (int iRow = 0; iRow < m_nRows &&
    	m_arRows[iRow + 1].nStart < iCompare; iRow++)
        ;

    BOOL bInsert = FALSE;

	if(m_arRows[iRow].bMenuBar || (bMenu && (iRow!=0 && iRow!=m_nRows-1)))
	{
		// can't drop into same row as menu bar, and menus always insert
		bInsert=TRUE;

		int nBarRowHeight=m_arRows[iRow + 1].nStart-m_arRows[iRow].nStart;
		if(iCompare > m_arRows[iRow].nStart+(nBarRowHeight/2) && iRow<m_nRows)
		{
			iRow++;
		}
	}
	else
	{
		if (iRow >= m_nRows || iCompare < m_arRows[iRow].nStart + INSERT_TOLERANCE)
			bInsert = TRUE;
		else if (iCompare + INSERT_TOLERANCE > m_arRows[iRow + 1].nStart)
		{
			bInsert = TRUE;
			iRow++;
		}
	}

	if (piRow != NULL)
		*piRow = iRow;

	return bInsert;
}

//  CDockWnd::RemoveWnd
//      Given a pointer to a docked window, and a pointer to new parent
//      window, removes the window from the current dock layout, and sets
//      the parent to the new window.

void CDockWnd::RemoveWnd(CWnd* pWnd, CWnd* pNewParent)
{
    ASSERT(IsChild(pWnd));

    _DWI dwi;
    GetDockInfo(&dwi, pWnd);

	if (m_arRows[dwi.iRow].pWndMax == pWnd)
		m_arRows[dwi.iRow].pWndMax = NULL;	// Removing the maximized window.

    pWnd->SetParent(pNewParent);

    _DWI* pdwi = BeginLayout();

	BOOL bStretchTest = OnChicago() && dwi.iRow > 0 &&
		(m_dp == dpRight || m_dp == dpBottom);
	BOOL bStretchy = m_arRows[dwi.iRow].bStretchy;	// Stretchy before?

    if (IsRowEmpty(pdwi, dwi.iRow))
        RemoveRow(pdwi, dwi.iRow);
    else
        RecalcRow(pdwi, dwi.iRow);

	// Did this row's stretchy status change?
	// Note: we have a sentinal non-stretchy row at m_nRows, so this is
	//       is always a valid test.
	if (bStretchTest && bStretchy != m_arRows[dwi.iRow].bStretchy)
		SizeRow(pdwi, dwi.iRow - 1);

    EndLayout(pdwi);
}

//	CDockWnd::GetMaxState

MAX_STATE CDockWnd::GetMaxState(CWnd* pWnd)
{
	_DWI dwi;
	GetDockInfo(&dwi, pWnd);
	if (!m_arRows[dwi.iRow].bMaxy)
		return stateDisabled;
	else if (m_arRows[dwi.iRow].pWndMax == pWnd)
		return stateRestore;
	else
		return stateMaximize;
}

//	CDockWnd::MaximizeRestore

void CDockWnd::MaximizeRestore(CWnd* pWnd)
{
	_DWI dwi;
	GetDockInfo(&dwi, pWnd);
	if (!m_arRows[dwi.iRow].bMaxy)
		return;

	_DWI* rgdwi = BeginLayout();
	SortRow(rgdwi, dwi.iRow);
	
	// If the window is not currently maximized, then maximize it now.
	// Otherwise, restore it.

	if (m_arRows[dwi.iRow].pWndMax != pWnd)
	{
		m_arRows[dwi.iRow].pWndMax = pWnd;
	}
	else
	{
		m_arRows[dwi.iRow].pWndMax = NULL;

		// Make working variables generic to horizontal and vertical dock.
		CRect rectDock;
		GetClientRect(rectDock);
		DockTranspose(m_dp, rectDock);

		// Make all docking windows the same size, and let recalc row
		// resize them to fit.

		_DWI* pdwi;
		for (pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == dwi.iRow; pdwi++)
		{
			if (pdwi->pWnd->GetStyle() & DWS_STRETCHY)
				pdwi->cAlong = rectDock.Width();
		}
	}

	RecalcRow(rgdwi, dwi.iRow);

	EndLayout(rgdwi);
}

//	CDockWnd::IsRowEmpty
//		Give a layout structure, and row, returns true, if a DWI exists in
//		the array with the given row.

BOOL CDockWnd::IsRowEmpty(_DWI* pdwi, int iRow)
{
    while (pdwi->pWnd != NULL && pdwi->iRow != iRow)
        pdwi++;

    return pdwi->pWnd == NULL;
}

//  CDockWnd::RemoveRow
//      Given a dock info pointer (assumed to point to a valid info array),
//      updates the row info for windows in the array, and updates the DockWnd
//      row member variables to reflect the row removal.  Note: No reallocation
//		here, only in InsertRow.

void CDockWnd::RemoveRow(_DWI* pdwi, int iRow)
{
    ASSERT(pdwi != NULL);

    // All windows in rows after the one removed, get moved back a row.
    for ( ; pdwi->pWnd != NULL; pdwi++)
    {
        ASSERT(pdwi->iRow != iRow); // Never remove a non-empty row.

        if (pdwi->iRow > iRow)
            pdwi->iRow--;
    }

    delete [] m_arRows[iRow].pnPositions;

    // Subtract the size of the row removed from all rows after that removed.
    int iSize = m_arRows[iRow + 1].nStart - m_arRows[iRow].nStart;
    for (int i = iRow; i < m_nRows; i++)
    {
        m_arRows[i] = m_arRows[i + 1];
        m_arRows[i].nStart -= iSize;
    }

    m_nRows--;  // One less row.
}

//  CDockWnd::InsertRow
//      Given a dock info pointer (assumed to point to a valid info array),
//      the row to insert before, and its size, updates affected windows, and
//      rows in row member variables.

void CDockWnd::InsertRow(_DWI* pdwi, int iRow, int iSize,
	ULONG nID /*=ULONG_MAX*/)
{
    ASSERT(pdwi != NULL);

    // Make sure we have the space; allocate and copy to new array.
    ROWSTRUCT* prRows = new ROWSTRUCT[m_nRows + 2];
    memcpy(prRows, m_arRows, (m_nRows + 1) * sizeof(ROWSTRUCT));
    delete [] m_arRows;
    m_arRows = prRows;

    // Increment row for windows in this or following row.
    for ( ; pdwi->pWnd != NULL; pdwi++)
    {
        if (pdwi->iRow >= iRow)
            pdwi->iRow++;
    }

    // Add row size to this and following rows.
    CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
    DockTranspose(m_dp, &sizeBorder);
    for (int i = m_nRows; i >= iRow; i--)
    {
    	m_arRows[i + 1] = m_arRows[i];
        m_arRows[i + 1].nStart += iSize;
        if (!OnChicago())
        	 m_arRows[i + 1].nStart -= g_mt.cyBorder;	// Overlap
    }

	if (nID != ULONG_MAX)
	{
		ASSERT(m_nIDPrev < nID && nID < m_nIDNext);	// Corrupt layout info.
		m_nIDPrev = min(m_nIDPrev, nID - 1);			// Attempt to repair any corruptions.
		m_nIDNext = max(m_nIDNext, nID + 1);
		ASSERT(m_nIDPrev > 100 && ULONG_MAX - 100 > m_nIDNext);	// We are in trouble.
	}
//	Invalid assert if we are wrapping rows.
//	ASSERT(INSERT_TOLERANCE != 0 || nID != ULONG_MAX ||
//		iRow == 0 || iRow == m_nRows);

	if (nID != ULONG_MAX)
		m_arRows[iRow].nIDRow = nID;
	else if (iRow == 0)
		m_arRows[iRow].nIDRow = m_nIDPrev--;
	else
		m_arRows[iRow].nIDRow = m_nIDNext++;

    m_arRows[iRow].bStretchy = FALSE;
    m_arRows[iRow].bMenuBar = FALSE;
	m_arRows[iRow].bMaxy = FALSE;
	m_arRows[iRow].bInit = TRUE;
	m_arRows[iRow].pWndMax = NULL;
    m_arRows[iRow].nSplitters = 0;
    m_arRows[iRow].pnPositions = NULL;
    m_nRows++;  // New row.
}

//  CDockWnd::SizeRow
//      Given a dock info pointer (assumed to point to a valid info array),
//      a row, and (optionally a size), resizes the row to the given size,
//      or to the size of the largest window, if no size is 0, by incrementing
//      following rows by the old - new size difference.

void CDockWnd::SizeRow(_DWI* rgdwi, int iRow, int iSize /*=0*/)
{
    ASSERT(rgdwi != NULL);

    _DWI* pdwi;

    // If no size given, find the largest window size.
    if (iSize)
    {
    	// Make size be the size of the windows in the row.
        if (m_arRows[iRow].bStretchy)
    		iSize -= g_mt.nSplitter;
	}
	else
    {
        for (pdwi = rgdwi ; pdwi->pWnd != NULL; pdwi++)
        {
            if (pdwi->iRow == iRow)
                iSize = max(iSize, pdwi->cAcross);
        }

        // No windows in this row.
        if (!iSize)
        {
        	RemoveRow(rgdwi, iRow);
        	return;
        }
    }

    // Increment following rows.
    int iInc = iSize - (m_arRows[iRow + 1].nStart - m_arRows[iRow].nStart);

    CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
    DockTranspose(m_dp, &sizeBorder);

    BOOL bSplitAbove = (m_dp == dpRight || m_dp == dpBottom);

    if (m_arRows[iRow].bStretchy)
    	iInc += g_mt.nSplitter;
    else
    	iInc -= sizeBorder.cy;	// Overlap.

	// Remove the overlap if the row does not border a splitter below.
	// Note that we have final sentinal row, so that it is always valid
	// to test iRow + 1.
	ASSERT(iRow < m_nRows);

	if (OnChicago() && !m_arRows[bSplitAbove ? iRow + 1 : iRow].bStretchy)
		iInc += sizeBorder.cy;	// Remove overlap.

    if (iInc)
    {
        for (int i = iRow + 1; i <= m_nRows; i++)
            m_arRows[i].nStart += iInc;
    }

    if (m_arRows[iRow].bStretchy)
    {
	    // Resize all stretchy windows.
	    for (pdwi = rgdwi; pdwi->pWnd != NULL; pdwi++)
	    {
	        if (pdwi->iRow == iRow && (pdwi->pWnd->GetStyle() & DWS_STRETCHY) != 0)
            	pdwi->cAcross = iSize;
	    }
	}
}

//	CDockWnd::SortRow
//		Given a layout structure, and a row, sorts the DWI structs for the
//		the row to the top of the array, and by position.  Uses insertion
//		sort, as these are likely to be pretty small sorts.

void CDockWnd::SortRow(_DWI* rgdwi, int iRow, CWnd* pWnd /*=NULL*/)
{
    for (_DWI* pdwi = rgdwi; pdwi->pWnd != NULL; pdwi++)
    {
	    _DWI* pdwiInsert;
	    _DWI dwiTmp;

        if (pdwi->iRow == iRow)
        {
            for (pdwiInsert = rgdwi; pdwiInsert < pdwi &&
            	pdwiInsert->iRow == iRow; pdwiInsert++)
			{
				// We found that people tended to expect small windows dropped
				// in the upper half of large/stretchy windows should sort before
				// them.  Hence the complex comparison below.
				//
				if ((pdwi->pWnd == pWnd && pdwiInsert->cAlong > pdwi->cAlong) ||
					(pdwiInsert->pWnd == pWnd && pdwi->cAlong > pdwiInsert->cAlong))
				{
					if (pdwi->iPos + pdwi->cAlong / 2 <
						pdwiInsert->iPos + pdwiInsert->cAlong / 2)
						break;
				}
				else if (pdwi->iPos < pdwiInsert->iPos)
				{
					break;
				}
            }

            if (pdwiInsert < pdwi)
            {
                dwiTmp = *pdwi;
                memmove(pdwiInsert + 1, pdwiInsert,
                	(pdwi - pdwiInsert) * sizeof(_DWI));
                *pdwiInsert = dwiTmp;
            }
        }
    }
}

//  CDockWnd::RecalcRow
//      Given layout array, row, and optionally window pointer, shifts windows
//      according to layout rules:
//          1. windows don't overlap,
//          2. all windows in a row are visible.  (wrap to new row if off screen)
//          3. windows never extend past left/top of dock.
//          4. only extend off right/bottom if not enough space to fit all windows.
//			5. rows with stretchy windows fill the whole row.

void CDockWnd::RecalcRow(_DWI* rgdwi, int iRow,	CWnd* pWnd /*=NULL*/,
	BOOL bForceWrap /*=FALSE*/)
{
//	TRACE0("CDockWnd::RecalcRow\n");

    // Make working variables generic to horizontal and vertical dock.
    CRect rectDock;
    GetClientRect(rectDock);
    CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
    rectDock.InflateRect(sizeBorder);

	// If the recalc forces the menu bar to change height, this is the ammount we add to nStart in subsequent rows
	// int nMenuBarHeightChange=0;

    DockTranspose(m_dp, rectDock);
    DockTranspose(m_dp, &sizeBorder);

	SortRow(rgdwi, iRow, pWnd);

	m_arRows[iRow].bStretchy = FALSE;
	m_arRows[iRow].bMaxy = FALSE;
	m_arRows[iRow].bMenuBar=FALSE;

	_DWI* pdwi;
	for (pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == iRow; pdwi++)
	{
		if (pdwi->pWnd->GetStyle() & DWS_STRETCHY)
		{
			if (m_arRows[iRow].bStretchy)
				m_arRows[iRow].bMaxy = TRUE;		// More than one stretchy
			else
				m_arRows[iRow].bStretchy = TRUE;	// At least one stretchy
		}
		if (pdwi->pWnd->GetStyle() & DWS_MENUBAR)
		{
			m_arRows[iRow].bMenuBar = TRUE;			// At least one menu bar
		}
	}

	// Initialize the maximize item if necessary.
	if (!m_arRows[iRow].bInit)
	{
		if (m_arRows[iRow].nIDMaxWindow == 0)
			m_arRows[iRow].pWndMax = NULL;
		else
		{
			CDockWorker* pDocker = m_pManager->
				WorkerFromID(m_arRows[iRow].nIDMaxWindow);
			if (pDocker == NULL)
				m_arRows[iRow].pWndMax = NULL;
			else
				m_arRows[iRow].pWndMax = pDocker->m_pWnd;
		}

		m_arRows[iRow].bInit = TRUE;
	}

	// Handle maximization
	if (!m_arRows[iRow].bMaxy)
		m_arRows[iRow].pWndMax = NULL;
	else if (m_arRows[iRow].pWndMax != NULL)
	{
		_DWI* pdwi = FindDockInfo(rgdwi, m_arRows[iRow].pWndMax);
		ASSERT(pdwi != NULL && pdwi->pWnd->GetStyle() & DWS_STRETCHY);
		
		// Make the maximize window as big as possible, and the dominant
		// window, and let the stretch code resize it back to the right
		// size.

		pWnd = pdwi->pWnd;
		pdwi->cAlong = rectDock.Width();
	}

	// menu bar always fills its row. We find it from its toolbar id, which is reliable, but not intellectually satisfying. REVIEW.
	if(m_arRows[iRow].bMenuBar)
	{
		CDockWorker* pDocker = m_pManager->WorkerFromID(MAKEDOCKID(PACKAGE_SUSHI, IDTB_MENUBAR));
		
		if (pDocker != NULL)
		{
			CWnd *pWndMenu=pDocker->m_pWnd;

			_DWI* pdwi = FindDockInfo(rgdwi, pWndMenu);
			ASSERT(pdwi != NULL && pdwi->pWnd->GetStyle() & DWS_MENUBAR);
			
			// Make the maximize window as big as possible, and the dominant
			// window, and let the stretch code resize it back to the right
			// size.

			pWnd = pdwi->pWnd;
			pdwi->cAlong = rectDock.Width();

			// Don't resize menu bar if we're minimized. Restoring will sort it out later
			BOOL bAppMinimized=AfxGetMainWnd()->IsIconic();

			if((m_dp==dpTop || m_dp==dpBottom) && !bAppMinimized)
			{
				// vertically stretch docked menu bar
				CRect rectCurrent;
				pDocker->m_pWnd->GetWindowRect(&rectCurrent);

				ASSERT(pDocker->m_pWnd->IsKindOf(RUNTIME_CLASS(CASBar)));
				CASBar *pBar=(CASBar *)pDocker->m_pWnd;

				CSize sizeFit=pBar->Fit(pdwi->cAlong, orHorz);

				// dockman will change pos for us
				pdwi->cAcross=sizeFit.cy;
			}
		}
	}

	int rgnTmp[128];
	int nSplitterCount = 0, iWnd = 0;

    // Handle window stretching.
    if (m_arRows[iRow].bStretchy ||
		m_arRows[iRow].bMenuBar)
    {
		int nTotalSize = 0;
		int nLastStretch = -1;

		// Calculate how far off we are.
		for (pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == iRow; pdwi++, iWnd++)
		{
		    nTotalSize += pdwi->cAlong;
		    if (!OnChicago())
		    	nTotalSize -= sizeBorder.cx;	// Overlap.

		    if (pdwi->pWnd->GetStyle() & DWS_STRETCHY)
		    {
		    	if (nLastStretch != -1)
		    	{
		    		if (nLastStretch == iWnd - 1)
		    			rgnTmp[nSplitterCount++] = nLastStretch;
		    		else
		    		{
		    			rgnTmp[nSplitterCount++] = nLastStretch;
		    			rgnTmp[nSplitterCount++] = iWnd - 1;
		    		}
		    	}

	    		nLastStretch = iWnd;
		    }
		}

		m_arRows[iRow].nSplitters = nSplitterCount;
		delete [] m_arRows[iRow].pnPositions;

		if (nSplitterCount)
			m_arRows[iRow].pnPositions = new int[nSplitterCount];
		else
			m_arRows[iRow].pnPositions = NULL;

		if (nTotalSize > 0)
		{
			if (OnChicago())
				nTotalSize += nSplitterCount * g_mt.nSplitter;
			else
				nTotalSize += sizeBorder.cx + nSplitterCount * (g_mt.nSplitter + 1);
		}

		BOOL bGrow = (rectDock.Width() > nTotalSize);
		CPoint ptMin = CDockWorker::GetDefMin();
		DockTranspose(m_dp, &ptMin);

		// Try to soak up the size difference into the available stretchy windows.
		while (nTotalSize != rectDock.Width())
		{
			BOOL bTerminalCase;
			int nStretchAlong = 0, nStretchCount = 0;
			int nStretchSize, nLoopDelta, nCurDelta;

			// Loop summing the total size of the stretch windows available to
			// soak up the difference. (May differ depending on whether we grow or not.)
			//
			for (pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == iRow; pdwi++)
			{
			    if (pdwi->pWnd != pWnd &&
			    	(pdwi->pWnd->GetStyle() & (DWS_STRETCHY|DWS_MENUBAR)) != 0 &&
			    	(bGrow || pdwi->cAlong > ptMin.x))
				{
			    	nStretchAlong += pdwi->cAlong;
					nStretchCount++;
				}
			}

			if (nStretchCount == 0)
				break;

			nLoopDelta = rectDock.Width() - nTotalSize;
			bTerminalCase = (abs(nLoopDelta) < nStretchCount);

			for (pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == iRow;
				pdwi++)
			{
			    if (pdwi->pWnd != pWnd &&
			    	(pdwi->pWnd->GetStyle() & DWS_STRETCHY) != 0 &&
			    	(bGrow || pdwi->cAlong > ptMin.x))
		    	{
					if (bTerminalCase)
						nStretchSize = bGrow ? 1 : -1;
					else
		    			nStretchSize = (nLoopDelta * pdwi->cAlong) / nStretchAlong;

					nCurDelta = rectDock.Width() - nTotalSize;
					if (abs(nStretchSize) > abs(nCurDelta))
						nStretchSize = nCurDelta;

					pdwi->cAlong += nStretchSize;
					nTotalSize += nStretchSize;

					if (pdwi->cAlong < ptMin.x)
					{
						nTotalSize += ptMin.x - pdwi->cAlong;
						pdwi->cAlong = ptMin.x;
					}
			   	}
			}
		}

		// If we still have some left, and the placed window is stretchy, let it soak
		// up the differnce.
		if (pWnd != NULL && nTotalSize != rectDock.Width() &&
			(pWnd->GetStyle() & DWS_STRETCHY) != 0)
		{
			ASSERT(pWnd != NULL);
			pdwi = FindDockInfo(rgdwi, pWnd);
			pdwi->cAlong = max(ptMin.x,
				pdwi->cAlong + (rectDock.Width() - nTotalSize));
		}
	}	// bStretch

	rgnTmp[nSplitterCount] = -1;

    // Find last window in the row.
    for (pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == iRow; pdwi++)
        ;

    // Walk back making sure everything fits inside max boundary.
    int nPaneMax;
	if (m_arRows[iRow].bStretchy)
		nPaneMax = rectDock.left;
	else
		nPaneMax = rectDock.right;

    while (--pdwi >= rgdwi && pdwi->pWnd != pWnd)
    {
	    if (pdwi->iPos + pdwi->cAlong > nPaneMax)
	        pdwi->iPos = nPaneMax - pdwi->cAlong;

        nPaneMax -= pdwi->cAlong;
        if (!OnChicago())
        	nPaneMax += sizeBorder.cx;	// Border overlap.
    }

    if (pWnd != NULL)
    {
    	ASSERT(pdwi->pWnd == pWnd);	// Window must be in layout.

        if (pdwi->iPos + pdwi->cAlong > nPaneMax)
            pdwi->iPos = nPaneMax - pdwi->cAlong;

        // Walk back removing window overlap.
        if (!m_arRows[iRow].bStretchy)
        	nPaneMax = pdwi->iPos;

        while (--pdwi >= rgdwi)
        {
			if (!OnChicago())
            	nPaneMax += sizeBorder.cx;   // Overlap.
            if (pdwi->iPos + pdwi->cAlong <= nPaneMax)
                break;

            nPaneMax = pdwi->iPos = nPaneMax - pdwi->cAlong;
        }
    }

    // Walk forward through row, removing window overlap.
    nSplitterCount = 0;
	m_arRows[iRow].bStretchy = FALSE;
    int nPaneMin = rectDock.left;   // Force windows to at least the dock min.

    for (iWnd = 0; (++pdwi)->pWnd != NULL && pdwi->iRow == iRow; iWnd++)
    {
		BOOL bMenuBarWrap=m_arRows[iRow].bMenuBar; // TRUE if we are wrapping the row because it contains the menu bar
        if (bMenuBarWrap ||
			((pWnd != NULL  || bForceWrap) &&
        		(nPaneMin > rectDock.right || pdwi->iPos > rectDock.right)))
        {
            // Wrap remainder to new row.
            InsertRow(rgdwi, iRow + 1, 1);  // size the row later.

            nPaneMin = rectDock.left;
            do
            {
				// wrap everything but the menubar
				if(!bMenuBarWrap ||								// if we're not wrapping because of the menu bar, then we want to move even the menu bar to the next line
					(pdwi->pWnd->GetStyle() & DWS_MENUBAR)==0)
				{
					pdwi->iRow = iRow + 1;
					pdwi->iPos = nPaneMin;
					nPaneMin += pdwi->cAlong;
					if (!OnChicago())
                		nPaneMin -= sizeBorder.cx;	// Overlap

					if (pdwi->pWnd->GetStyle() & DWS_STRETCHY)
						m_arRows[iRow + 1].bStretchy = TRUE;
				}
				else
				{
					// menu bar stays in its row, and gets moved to the left
					pdwi->iPos = 0;
				}
            } while ((++pdwi)->pWnd != NULL && pdwi->iRow == iRow);

            if (m_arRows[iRow + 1].bStretchy)
            	RecalcRow(rgdwi, iRow + 1);
            else
		        SizeRow(rgdwi, iRow + 1);

            break;
        }

        if (pdwi->iPos < nPaneMin)
            nPaneMin = (pdwi->iPos = nPaneMin) + pdwi->cAlong;
        else
            nPaneMin = pdwi->iPos + pdwi->cAlong;

        if (!OnChicago() || iWnd == rgnTmp[nSplitterCount])
        	nPaneMin -= sizeBorder.cx;	// Overlap

        // Update splitters as we go.
        if (iWnd == rgnTmp[nSplitterCount])
        {
        	ASSERT(nSplitterCount < m_arRows[iRow].nSplitters);

        	m_arRows[iRow].pnPositions[nSplitterCount++] = nPaneMin;
        	nPaneMin += g_mt.nSplitter + sizeBorder.cx;
        }

		if (pdwi->pWnd->GetStyle() & DWS_STRETCHY)
			m_arRows[iRow].bStretchy = TRUE;
    }

    SizeRow(rgdwi, iRow);
}

// CDockWnd message map.

BEGIN_MESSAGE_MAP(CDockWnd, CWnd)
    //{{AFX_MSG_MAP(CDockWnd)
    ON_WM_WINDOWPOSCHANGED()
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_RBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_SYSCOMMAND()
	ON_WM_PARENTNOTIFY()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_SIZEPARENT, OnSizeParent)
	ON_MESSAGE(WM_SETMESSAGESTRING, OnSetMessageString)
    ON_REGISTERED_MESSAGE(DMM_CHILDSETFOCUS, OnRouteMessage)
    ON_REGISTERED_MESSAGE(DMM_CHILDKILLFOCUS, OnRouteMessage)
    ON_REGISTERED_MESSAGE(DMM_NCLBUTTONDOWN, OnRouteMessage)
    ON_REGISTERED_MESSAGE(DMM_NCLBUTTONDBLCLK, OnRouteMessage)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDockWnd message handlers

//	CDockWnd::PreTranslateMessage
//		Forward MDI keys to MDI.

BOOL CDockWnd::PreTranslateMessage(MSG* pMsg)
{
	if (MDIKeyMessage(pMsg))
		return TRUE;

	return CWnd::PreTranslateMessage(pMsg);
}

//  CDockWnd::OnRouteMessage
//      Dockable windows send messages (DMM_*) to their parents.  We just
//      forward everything to the manager, to see if it is handled.

LRESULT CDockWnd::OnRouteMessage(WPARAM wParam, LPARAM lParam)
{
    return (BOOL) m_pManager->WorkerMessage(GetCurrentMessage()->message,
        (HWND) wParam, lParam);
}

LRESULT CDockWnd::OnCommandHelp(WPARAM, LPARAM lParam)
{
	return CommandHelp(lParam);
}

//  CDockWnd::OnSizeParent
//      Mostly clipped from CControlBar.  Used to size the CDockWnds, as
//      well as the View/MDI Client, called in CFrameWnd::RecalcLayout()

LRESULT CDockWnd::OnSizeParent(WPARAM, LPARAM lParam)
{
    AFX_SIZEPARENTPARAMS FAR* lpLayout = (AFX_SIZEPARENTPARAMS FAR*)lParam;

    // resize and reposition this control bar based on styles
    DWORD dwStyle = GetStyle();


    if (m_dp != dpHide && (dwStyle & WS_VISIBLE) != 0 &&
    	m_pManager->IsVisible())
    {
        // align the dock
		CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
		if (OnChicago())
			sizeBorder.cx = sizeBorder.cy = 0;

        CRect rect;
        rect.CopyRect(&lpLayout->rect);
        rect.InflateRect(sizeBorder.cx, sizeBorder.cy);

        CSize sizeAvail = rect.Size();  // maximum size available
        CSize size(sizeBorder.cx * 2, sizeBorder.cy * 2);

		DockTranspose(m_dp, &sizeAvail);
		DockTranspose(m_dp, &size);
		size.cx = sizeAvail.cx;
		size.cy += m_arRows[m_nRows].nStart;
		if (OnChicago())
		{
			size.cy -= 1;
			if (size.cy <= 0)
				size.cy = 0;	// Nothing to show.
			else if (m_dp == dpBottom || m_dp==dpTop)
				size.cy += 2;	// Etched border.
		}
		DockTranspose(m_dp, &size);

		switch (m_dp)
		{
		case dpLeft:
            lpLayout->rect.left += size.cx - sizeBorder.cx;
            break;

        case dpTop:
            lpLayout->rect.top += size.cy - sizeBorder.cy;
            break;

        case dpRight:
            rect.left = rect.right - size.cx;
            lpLayout->rect.right -= size.cx - sizeBorder.cx;
			break;

		case dpBottom:
            rect.top = rect.bottom - size.cy;
            lpLayout->rect.bottom -= size.cy - sizeBorder.cy;
            break;

        default:
            ASSERT(FALSE);      // can never happen
            break;
        }

        rect.right = rect.left + size.cx;
        rect.bottom = rect.top + size.cy;

		// only resize the window if doing layout and not just rect query
		if (lpLayout->hDWP != NULL)
			AfxRepositionWindow(lpLayout, m_hWnd, &rect);
    }
    return 0;
}

void CDockWnd::GetSplitterRect(int iRow, CRect& rect, BOOL bTracking /*=FALSE*/)
{
	BOOL bSplitAbove = (m_dp == dpRight || m_dp == dpBottom);

	GetClientRect(rect);
	DockTranspose(m_dp, rect);

	rect.left -= 1;
	rect.right += 1;

	if (bSplitAbove)
	{
		rect.top = m_arRows[iRow].nStart;
		rect.bottom = rect.top + g_mt.nSplitter + 2;
	}
	else
	{
		rect.bottom = m_arRows[iRow + 1].nStart + 1;
		rect.top = rect.bottom - g_mt.nSplitter - 2;
	}

	if (bTracking)
	{
		rect.InflateRect(-1, -1);
		if (OnChicago())
			rect.OffsetRect(0, -1);
	}
	
	DockTranspose(m_dp, rect);
}

void CDockWnd::GetSplitterRect(int iRow, int nPosition, CRect& rect,
	BOOL bTracking /*=FALSE*/)
{
	BOOL bSplitAbove = (m_dp == dpRight || m_dp == dpBottom);

	rect.left = nPosition;
	rect.right = nPosition + g_mt.nSplitter + 2;
	rect.top = m_arRows[iRow].nStart;
	rect.bottom = m_arRows[iRow + 1].nStart - g_mt.nSplitter;

	if (bSplitAbove)
		rect.OffsetRect(0, g_mt.nSplitter + 1);

	if (bTracking)
		rect.InflateRect(-1, -1);
	
	if (OnChicago())
	{
		if (bTracking)
			rect.OffsetRect(-1, 0);
		if (bSplitAbove && !m_arRows[iRow + 1].bStretchy)
			rect.bottom -= 1;
	}

	DockTranspose(m_dp, rect);
}

CPoint CDockWnd::HitTest(CPoint point)
{
	CPoint ptReturn(-1, -1);

	DockTranspose(m_dp, &point);
	for (int i = 0; m_arRows[i].nStart < point.y; i++)
		ASSERT(i <= m_nRows);
	DockTranspose(m_dp, &point);

	if (i == 0)
		return ptReturn;	// Before first row.	

	i--;

	if (m_arRows[i].bStretchy)
	{
		CRect rect;
		GetSplitterRect(i, rect);
		rect.InflateRect(-1, -1);

		if (rect.PtInRect(point))
			ptReturn.x = i;
		else
		{
			for (int j = 0; j < m_arRows[i].nSplitters; j++)
			{
				GetSplitterRect(i, m_arRows[i].pnPositions[j], rect);
				rect.InflateRect(-1, -1);

				if (rect.PtInRect(point))
				{
					ptReturn.x = i;
					ptReturn.y = j;
				}
			}
		}
	}

	return ptReturn;
}

void CDockWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	// The hidden dock should not be getting mouse messages, but due to what
	// seems to be a Windows bug, it does when we are using it to track
	// the popup menu, and we bring up another window to break the tracking.
	//
	if (m_dp == dpHide)
	{
		if (GetCapture() == this)
			ReleaseCapture();

		return;
	}


	BOOL bVertDock = (m_dp == dpLeft || m_dp == dpRight);
	CPoint ptTest = HitTest(point);

	if (ptTest.x != -1 && ptTest.y != -1)
		::SetCursor(bVertDock ? s_hcurHSize : s_hcurVSize);
	else if (ptTest.x != -1)
		::SetCursor(bVertDock ? s_hcurVSize : s_hcurHSize);
	else
		::SetCursor(::LoadCursor(NULL, IDC_ARROW));

	CWnd::OnMouseMove(nFlags, point);
}

void CDockWnd::OnLButtonDown(UINT nFlags, CPoint point)
{
	if (m_dp == dpHide)
		return;

	CPoint ptTest = HitTest(point);
	if (ptTest.x == -1 && ptTest.y == -1)
	{
		CWnd::OnLButtonDown(nFlags, point);
		return;
	}

	int nChange;
	ClientToScreen(&point);

	if (!TrackSize(point, ptTest, nChange))
		return;

	_DWI* rgdwi = BeginLayout();

	if (ptTest.y == -1)
	{
		SizeRow(rgdwi, ptTest.x,
			m_arRows[ptTest.x + 1].nStart -
			m_arRows[ptTest.x].nStart + nChange);
		SizeRow(rgdwi, ptTest.x);	//	Snap back to largest non-stretcher.
	}
	else
	{
		SortRow(rgdwi, ptTest.x);
		_DWI* pdwiWnd;
		_DWI* pdwiNext;

		ASSERT(m_arRows[ptTest.x].pnPositions != NULL);
		int nSplitPos = m_arRows[ptTest.x].pnPositions[ptTest.y];

		// Get the sizes right, and then call RecalcRow to make everything
		// adjacent.
		CPoint ptMin = CDockWorker::GetDefMin();
		DockTranspose(m_dp, &ptMin);

		int nScore = 0;
		int nOffset = (nChange < 0) ? -1 : 1;
		nChange *= -nOffset;

		for (_DWI* pdwi = rgdwi; pdwi->pWnd != NULL && pdwi->iRow == ptTest.x;
			pdwi++)
		{
			if (pdwi->pWnd->GetStyle() & DWS_STRETCHY)
			{
				int nNewScore = (nSplitPos - pdwi->iPos) * nOffset;
				if (nNewScore > 0 && (nNewScore < nScore || nScore == 0))
				{
					nScore = nNewScore;
					pdwiWnd = pdwi;
				}
			}
		}

		ASSERT(nScore);

		// Make the size changes.
    	pdwiWnd->cAlong -= nChange;

        for (pdwiNext = pdwiWnd + nOffset;
        	 pdwiNext >= rgdwi &&
        	 pdwiNext->pWnd != NULL &&
        	 pdwiNext->iRow == ptTest.x; pdwiNext += nOffset)
        {
        	if ((pdwiNext->pWnd->GetStyle() & DWS_STRETCHY) == 0)
        		continue;

        	pdwiNext->cAlong += nChange;

        	if (pdwiNext->cAlong < ptMin.x)
        	{
        		nChange = pdwiNext->cAlong - ptMin.x;
        		pdwiNext->cAlong = ptMin.x;
        	}
        	else
        	{
        		nChange = 0;
        		break;
        	}
        }

        pdwiWnd->cAlong += nChange;	// Absorb the remainder.
		m_arRows[ptTest.x].pWndMax = NULL;	// No max window if the user resizes.
    	RecalcRow(rgdwi, ptTest.x);	// Reposition everything.
	}

	EndLayout(rgdwi);
}

BOOL CDockWnd::TrackSize(CPoint ptStart, CPoint ptHitTest, int& nFinalOffset)
{
	// No tracking when we aren't really visible.  Might end up
	// tracking for during OLE activation.
	if (!m_pManager->IsVisible())
		return FALSE;

    CRect rect, rectOld;
    CPoint pt, ptOld;

    BOOL bCancel = FALSE;
	BOOL bVertDock = (m_dp == dpLeft || m_dp == dpRight);
	BOOL bSplitAbove = (m_dp == dpRight || m_dp == dpBottom);
	BOOL bVertSplit = ((bVertDock && ptHitTest.y == -1) ||
		(!bVertDock && ptHitTest.y != -1));

	nFinalOffset = (ptHitTest.y == -1 && bSplitAbove) ? -1 : 1;

	if (bVertSplit)
		ptStart.y = 0;
	else
		ptStart.x = 0;

	CRect rectBound;
	GetBoundaryRect(ptHitTest, rectBound);

    if (ptHitTest.y == -1)
    	GetSplitterRect(ptHitTest.x, rect, TRUE);
    else
    {
    	ASSERT(m_arRows[ptHitTest.x].pnPositions != NULL);
    	GetSplitterRect(ptHitTest.x,
    		m_arRows[ptHitTest.x].pnPositions[ptHitTest.y], rect, TRUE);
    }

    ClientToScreen(rect);
    rectBound.OffsetRect(ptStart.x - rect.left, ptStart.y - rect.top);

	CClientDC dc(AfxGetApp()->m_pMainWnd);

    // Loop while the mouse is down.
    CWnd* pWndTrack = CWnd::GetFocus();	// So we stay the active window.

	// When in DocObject mode, we save the focus, and give it to one of our
	// window. This is because the doc object's window will not accept
	// that we capture the mouse on its behalf.
	CWnd *pWndSaveFocus=NULL;
	if(m_pManager->IsInDocObjectMode())
	{
		pWndSaveFocus = pWndTrack;
		pWndTrack = this;
	}

    if (pWndTrack == NULL)
	{
		// Try to get a valid focused window.
		m_pManager->m_pFrame->SetFocus();
		if ((pWndTrack = CWnd::GetFocus()) == NULL)
			return FALSE;
	}

    pWndTrack->SetCapture();

    ptOld = pt = ptStart;

    // Turn on the drag rectangle.
    DrawTrackRect(&dc, &rect);

    while (!PollForMouseChange(pt, TRUE, bCancel))
    {
    	if (bVertSplit)
    	{
    		pt.x = max(min(pt.x, rectBound.right), rectBound.left);
    		pt.y = 0;
    	}
    	else
    	{
    		pt.x = 0;
    		pt.y = max(min(pt.y, rectBound.bottom), rectBound.top);
    	}

    	if (pt == ptOld)
    		continue;

        rectOld = rect;
    	rect.OffsetRect(pt.x - ptOld.x, pt.y - ptOld.y);

        // Move the drag rect on screen.
    	DrawTrackRect(&dc, &rectOld, &rect);

        ptOld = pt;
    }

    // Turn off drag rectangle.
    DrawTrackRect(&dc, &rect);
    ::ReleaseCapture();

	// Restore focus to docobject window if we took it
	if(pWndSaveFocus != NULL)
		pWndSaveFocus->SetFocus();

    if (bCancel || ptOld == ptStart)
    	return FALSE;
    else if (bVertSplit)
    	nFinalOffset *= ptOld.x - ptStart.x;
    else
    	nFinalOffset *= ptOld.y - ptStart.y;

    return TRUE;
}

void CDockWnd::DrawTrackRect(CDC* pdc, const CRect* prect1,
	const CRect* prect2 /*=NULL*/)
{
	ASSERT_VALID(pdc);

	// invert the brush pattern (looks just like frame window sizing)
	CBrush* pBrush = CDC::GetHalftoneBrush();
	HBRUSH hOldBrush = NULL;
	if (pBrush != NULL)
		hOldBrush = (HBRUSH)SelectObject(pdc->m_hDC, pBrush->m_hObject);

    CRect rect = *prect1;
	AfxGetApp()->m_pMainWnd->ScreenToClient(rect);
	pdc->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);

    if (prect2 != NULL)
    {
    	rect = *prect2;
		AfxGetApp()->m_pMainWnd->ScreenToClient(rect);
		pdc->PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
    }

	if (hOldBrush != NULL)
		SelectObject(pdc->m_hDC, hOldBrush);
}

void CDockWnd::GetBoundaryRect(CPoint ptHitTest, CRect& rect)
{
	ASSERT(ptHitTest.x >= 0 && ptHitTest.x < m_nRows);
	ASSERT(m_arRows[ptHitTest.x].bStretchy);

	BOOL bSplitAbove = (m_dp == dpRight || m_dp == dpBottom);

	// Client coordinates used below so that the row offsets used
	// will be valid.
	//
	CRect rectDesk;
	m_pManager->GetDeskRects(rectDesk, rect);
	ScreenToClient(rectDesk);
	DockTranspose(m_dp, rectDesk);

	GetWindowRect(rect);
	ScreenToClient(rect);
	DockTranspose(m_dp, rect);

	CPoint ptMinSize = CDockWorker::GetDefMin();
	DockTranspose(m_dp, &ptMinSize);
	CSize sizeBorder(g_mt.cxBorder, g_mt.cyBorder);
	DockTranspose(m_dp, &sizeBorder);

	if (bSplitAbove)
		rect.top = rectDesk.top;
	else
		rect.bottom = rectDesk.bottom;

	int nPos = 0;

	if (ptHitTest.y != -1)
	{
		ASSERT(m_arRows[ptHitTest.x].pnPositions != NULL);
		nPos = m_arRows[ptHitTest.x].pnPositions[ptHitTest.y];
	}

	_DWI dwi;

	for (CWnd* pWnd = GetTopWindow(); pWnd != NULL;
		pWnd = pWnd->GetWindow(GW_HWNDNEXT))
	{
		GetDockInfo(&dwi, pWnd);

		if (ptHitTest.x == dwi.iRow)
		{
			if ((dwi.pWnd->GetStyle() & DWS_STRETCHY) != 0)
			{
				dwi.cAlong = ptMinSize.x;
				dwi.cAcross = ptMinSize.y;
			}

			if (bSplitAbove)
				rect.bottom = min(rect.bottom,
					m_arRows[ptHitTest.x + 1].nStart - dwi.cAcross + 2);
			else
				rect.top = max(rect.top,
					m_arRows[ptHitTest.x].nStart + dwi.cAcross - 1);

			if (nPos > dwi.iPos)
				rect.left += dwi.cAlong - sizeBorder.cx;
			else
				rect.right -= dwi.cAlong - sizeBorder.cx;
		}
	}

	for (int i = 0; i < m_arRows[ptHitTest.x].nSplitters; i++)
	{
		if (nPos > m_arRows[ptHitTest.x].pnPositions[i])
			rect.left += g_mt.nSplitter + 1;
		else
			rect.right -= g_mt.nSplitter + 1;
	}

	rect.right--;
	rect.bottom -= g_mt.nSplitter + 2;

	DockTranspose(m_dp, rect);
	ClientToScreen(rect);
}

void CDockWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if (m_dp == dpHide)
		return;

	CPoint ptTest = HitTest(point);
	if (ptTest.x != -1 || ptTest.y != -1)
	{
		// In a split rect, so ignore.
		CWnd::OnLButtonDblClk(nFlags, point);
		return;
	}

	if (CASBar::s_pCustomizer == NULL)
	{
		ASSERT(m_pManager->m_pFrame != NULL);
#ifdef _DEBUG
		if ((::GetKeyState(VK_CONTROL) & ~1) != 0)
			m_pManager->m_pFrame->SendMessage(WM_COMMAND, IDM_OPENLAYOUT);
		else
#endif
			m_pManager->m_pFrame->SendMessage(WM_COMMAND, IDM_TOOLBAR_EDIT);
	}
}

void CDockWnd::OnRButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnRButtonUp(nFlags, point);

	ClientToScreen(&point);
	m_pManager->ShowMenu(point);
}

void CDockWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (nChar == VK_ESCAPE)
	{
		// DevStudio96 RAID #11708 [patbr]:
		// if there are no MDI child windows open, we want to effectively
		// pass the keypress on to the mainframe's <esc> handler...
		if (theApp.HasOpenDocument(FILTER_NONE))
			theApp.ReactivateView();
		else
			((CMainFrame *)theApp.m_pMainWnd)->OnCancel();
	}

	CWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CDockWnd::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	if (OnChicago())
		OnDrawChicago(&dc);
	else
		OnDrawNT(&dc);
}

void CDockWnd::OnDrawChicago(CDC* pdc)
{
	ASSERT(OnChicago());

	CRect rect;

	// Draw the splitters
	BOOL bVertDock = (m_dp == dpLeft || m_dp == dpRight);

	for (int i = 0; i < m_nRows; i++)
	{
		if (m_arRows[i].bStretchy)
		{
			GetSplitterRect(i, rect);
			DrawSplitter(pdc, rect, bVertDock);
			pdc->ExcludeClipRect(rect);
		}
	}

	for (i = 0; i < m_nRows; i++)
	{
		if (m_arRows[i].bStretchy)
		{
			for (int j = 0; j < m_arRows[i].nSplitters; j++)
			{
				GetSplitterRect(i, m_arRows[i].pnPositions[j], rect);
				DrawSplitter(pdc, rect, !bVertDock);

				DockTranspose(m_dp, rect);
				rect.top -= 1;
				rect.bottom += 1;
				DockTranspose(m_dp, rect);
				pdc->ExcludeClipRect(rect);
			}
		}
	}

	COLORREF colorLt = GetSysColor(COLOR_BTNHIGHLIGHT);
	COLORREF colorDk = GetSysColor(COLOR_BTNSHADOW);

	// Draw the window borders.
	for (CWnd* pWnd = GetTopWindow(); pWnd != NULL;
		pWnd = pWnd->GetWindow(GW_HWNDNEXT))
	{
		pWnd->GetWindowRect(rect);
		ScreenToClient(rect);
		pdc->Draw3dRect(rect, colorLt, colorDk);
		pdc->ExcludeClipRect(rect);
	}

	// Erase the remaining background.
	GetClientRect(rect);
	pdc->FillSolidRect(rect, GetSysColor(COLOR_BTNFACE));

	// This may look really wierd, but it produces the best 3d results for
	// the cost.  Clipping from above, and order of painting are important.

	// Draw borders.
	for (pWnd = GetTopWindow(); pWnd != NULL; pWnd = pWnd->GetWindow(GW_HWNDNEXT))
	{
		pWnd->GetWindowRect(rect);
		ScreenToClient(rect);

		pdc->Draw3dRect(rect, colorLt, colorDk);
	}
}

void CDockWnd::OnDrawNT(CDC* pdc)
{
	// Draw the splitters
	BOOL bVertDock = (m_dp == dpLeft || m_dp == dpRight);

	CRect rect;

	for (int i = 0; i < m_nRows; i++)
	{
		if (m_arRows[i].bStretchy)
		{
			GetSplitterRect(i, rect);
			DrawSplitter(pdc, rect, bVertDock);

			for (int j = 0; j < m_arRows[i].nSplitters; j++)
			{
				GetSplitterRect(i, m_arRows[i].pnPositions[j], rect);
				DrawSplitter(pdc, rect, !bVertDock);
			}
		}
	}
}

//	CDockWnd::OnWindowPosChanged
//		Recalc the rows, if we sized in the stretch direction, so stretchy
//		windows will continue to fill the window.

void CDockWnd::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
    if (m_dp == dpHide || (GetStyle() & WS_VISIBLE) == 0)
		return;

	CSize size(lpwndpos->cx, lpwndpos->cy);

	DockTranspose(m_dp, &size);
    if (size.cx != m_nAlong)
    {
		m_nAlong = size.cx;

		if (m_nRows > 0)
		{
	    	_DWI* pdwi = BeginLayout();

			// Walk back since rows may be deleted if they are empty.
	    	for (int i = m_nRows - 1; i >= 0; i--)
	    		RecalcRow(pdwi, i, NULL, !m_bInitialized);

			// In row stretch shouldn't need to recalc.
			m_bChicagoSizingHack = TRUE;
	    	EndLayout(pdwi, FALSE);
			m_bChicagoSizingHack = FALSE;
    	}

		m_bInitialized = TRUE;
    }
}

void CDockWnd::OnParentNotify(UINT message, LPARAM lParam)
{
	if (theApp.m_hwndValidate != NULL &&
		::SendMessage(theApp.m_hwndValidate, WM_ISERROR, 0, 0L))
	{
		return;
	}
	else if (message == WM_LBUTTONDOWN || message == WM_RBUTTONDOWN)
	{
		CPoint pt(::GetMessagePos());
		CWnd* pWndNotify = WindowFromPoint(pt);
		while (pWndNotify != NULL && pWndNotify->GetParent() != this)
			pWndNotify = pWndNotify->GetParent();

		CDockWorker* pDocker = m_pManager->WorkerFromWindow(pWndNotify);
		if (pDocker != NULL && pDocker != CDockWorker::s_pActiveDocker &&
				pDocker->m_dtWnd == dtEdit && CASBar::s_pCustomizer == NULL)
			pWndNotify->SetFocus();
	}

	CWnd::OnParentNotify(message, lParam);
}

void CDockWnd::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams)
{
	if (OnChicago())
	{
		if (m_dp != dpBottom)
        	lpParams->rgrc->top += 2;
		if (m_dp != dpTop)
        	lpParams->rgrc->bottom -= 2;
		return;
	}
        
	CWnd::OnNcCalcSize(bCalcValidRects, lpParams);
}

void CDockWnd::OnNcPaint()
{
	if (OnChicago())
	{
		// Draw etched border
	    CWindowDC dc(this);

		CRect rect;
	    GetWindowRect(rect);
	    rect.OffsetRect(-rect.left, -rect.top);

		COLORREF colorLt = GetSysColor(COLOR_BTNHIGHLIGHT);
		COLORREF colorDk = GetSysColor(COLOR_BTNSHADOW);

		if (m_dp != dpBottom)
		{
			dc.FillSolidRect(rect.left, rect.top, rect.Width(), 1, colorDk);
			dc.FillSolidRect(rect.left, rect.top + 1, rect.Width(), 1, colorLt);
		}

		if (m_dp != dpTop)
		{
			dc.FillSolidRect(rect.left, rect.bottom - 2, rect.Width(), 1, colorDk);
			dc.FillSolidRect(rect.left, rect.bottom - 1, rect.Width(), 1, colorLt);
		}
		return;
	}

	CWnd::OnNcPaint();
}

LRESULT CDockWnd::OnSetMessageString(WPARAM wParam, LPARAM lParam)
{
	ASSERT_VALID(m_pManager);

	return m_pManager->m_pFrame->SendMessage(WM_SETMESSAGESTRING,
		wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
// 	Utility functions

//	MDIKeyMessage
//		Forward MDI keys to the main window.

BOOL MDIKeyMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN)
	{
		switch (pMsg->wParam)
		{
		case VK_TAB:
		case VK_F4:
		case VK_F6:
			if ((GetKeyState(VK_CONTROL) & ~1) != 0)
			{
				theApp.m_pMainWnd->PostMessage(pMsg->message,
					pMsg->wParam, pMsg->lParam);
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//	Dock coordinate functions
//		Most handling in vertical docks is merely the transpose of that
//		in horizontal docks.  Use these functions to convert to and from
//		canonical coordinates (as if all docks were horizontal).
//

void DockTranspose(DOCKPOS dp, SIZE FAR* lpsize)
{
	if (dp == dpLeft || dp == dpRight)
	{
		SIZE size;

		size.cx = lpsize->cy;
		size.cy = lpsize->cx;

		*lpsize = size;
	}
}

void DockTranspose(DOCKPOS dp, LPPOINT lppt)
{
	if (dp == dpLeft || dp == dpRight)
	{
		POINT pt;

		pt.x = lppt->y;
		pt.y = lppt->x;

		*lppt = pt;
	}
}

void DockTranspose(DOCKPOS dp, LPRECT lprect)
{
	if (dp == dpLeft || dp == dpRight)
	{
		RECT rect;

		rect.left = lprect->top;
		rect.top = lprect->left;
		rect.right = lprect->bottom;
		rect.bottom = lprect->right;

		*lprect = rect;
	}
}

///////////////////////////////////////////////////////////////////////////////
//	CMDIChildDock
//

IMPLEMENT_DYNAMIC(CMDIChildDock, CPartFrame)

CMDIChildDock::CMDIChildDock(CDockManager* pManager)
{
	ASSERT_VALID(pManager);
	m_pManager = pManager;
}

CMDIChildDock::~CMDIChildDock()
{
}

BOOL CMDIChildDock::Create(LPCSTR lpClassName, LPCSTR lpTitle,
	CWnd* pChildWnd, CMDIFrameWnd* pParentWnd,
	CRect rect)
{
	if (!CPartFrame::Create(lpClassName, lpTitle,
			WS_CHILD | WS_OVERLAPPEDWINDOW,	rect, pParentWnd))
		return FALSE;

	// Child docks have a view that will supply the client edge.
	if (theApp.m_bWin4)
		ModifyStyleEx(WS_EX_CLIENTEDGE, 0, SWP_FRAMECHANGED);

	pChildWnd->ShowWindow(SW_SHOWNOACTIVATE);

	// While the child is in the MDI child, the border window needs
	// to have the ID AFX_IDW_PANE_FIRST, so layout will work correctly.
	// The view also needs this ID so MFC will set it as the active view.
	//
	SetChildID(pChildWnd, AFX_IDW_PANE_FIRST);

	pChildWnd->SetParent(this);
    m_pManager->AddMDIChild(this);
    RecalcLayout();

	return TRUE;
}

void CMDIChildDock::ParentChild(CWnd* pWndNewParent)
{
	CWnd* pChildWnd = GetTopWindow();
	ASSERT_VALID(pChildWnd);

	SetChildID(pChildWnd, m_nIDSave);
	pChildWnd->SetParent(pWndNewParent);
}

void CMDIChildDock::SetChildID(CWnd* pChildWnd, UINT nID)
{
	m_nIDSave = pChildWnd->GetDlgCtrlID();

	// Orion 96 Bug 15325 - GetDescendantWindow is finding an IV window with the id E900
	// which happens to be AFX_IDW_PANE_FIRST. Replaced with another function which 
	// returns the first window with an ID which is also a CPartView.
	CPartView* pView = GetFirstChildWindowWithID(pChildWnd->m_hWnd, m_nIDSave);
	ASSERT(pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)));
	::SetWindowLong(pChildWnd->m_hWnd, GWL_ID, nID);
	::SetWindowLong(pView->m_hWnd, GWL_ID, nID);
}

CDockWorker* CMDIChildDock::GetWorker() const
{
	return m_pManager->WorkerFromWindow(GetTopWindow());
}

BEGIN_MESSAGE_MAP(CMDIChildDock, CPartFrame)
    //{{AFX_MSG_MAP(CMDIChildDock)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMDIChildDock message handlers

//	CMDIChildDock::OnClose
//		Defers to dock manager to get rid of the window.

void CMDIChildDock::OnClose()
{
    CDockWorker* pDocker = GetWorker();
	ASSERT_VALID(pDocker);
	pDocker->ShowWindow(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dockwnds.h ===
///////////////////////////////////////////////////////////////////////////////
//	DOCKWNDS.H
//		Declarations for the window classes associated with the docking
//		architecture.
//

#ifndef __DOCKWNDS_H__
#define __DOCKWNDS_H__

class CDockWorker;
class CDockManager;
class CPartView;

///////////////////////////////////////////////////////////////////////////////
//	CPaletteWnd window

class CPaletteWnd : public CMiniFrameWnd
{
public:
    static void GetPaletteRect(CRect& rect, CWnd* pChildWnd = NULL);
    static void GetChildRect(CRect& rect);

    CPaletteWnd(CDockManager* pManager);
    ~CPaletteWnd();

    BOOL Create(LPCSTR lpClassName, LPCSTR lpTitle, CWnd* pChildWnd, CWnd* pParentWnd, CRect rect, UINT nID = 0, BOOL bHasClose=TRUE);
        
	void SetManager(CDockManager* pManager);
	CDockWorker* GetWorker() const;

    void ActivateWindow(BOOL bActive);
	void ActivateNoFocus();
        
// Generated message map functions
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    //{{AFX_MSG(CPaletteWnd)
    afx_msg BOOL OnNcActivate(BOOL bActive);
    afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint pt);
    afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint pt);
    afx_msg void OnClose();
    afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	//}}AFX_MSG
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRouteMessage(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnBarSizeChanging(WPARAM wParam, LPARAM lParam);
    
    DECLARE_MESSAGE_MAP()
    DECLARE_DYNAMIC(CPaletteWnd)

// Helping functions    
protected:
	void SaveFocus();
	void RestoreFocus();

// Implementation
protected:
	HWND m_hwndFocus;
    CDockManager* m_pManager;
};

inline void CPaletteWnd::SetManager(CDockManager* pManager)
{	m_pManager = pManager;	}

/////////////////////////////////////////////////////////////////////////////
// CDockWnd window

struct  _DWI {
    int iRow, iPos, cAlong, cAcross;
    CWnd* pWnd;
};

struct DOCKRESTORE {
	ULONG nIDRow;
	int iPos, cAlong, cAcross;
};

struct ROWSTRUCT {
	int nStart;
	ULONG nIDRow;
	BOOL bStretchy:1;
	BOOL bMenuBar:1;		// A row containing the menu bar contains nothing else
	BOOL bMaxy:1;
	BOOL bInit:1;
	union
	{
		CWnd* pWndMax;
		UINT nIDMaxWindow;
	};
	int nSplitters;
	int* pnPositions;
};

class CDockWnd : public CWnd
{
// Construction
protected:
	CDockWnd();
	
public:
    CDockWnd(DOCKPOS dp);
    ~CDockWnd();
    
    BOOL Create(CFrameWnd* pFrame, UINT nID, CDockManager* pManager);

// Operations
public:
	void GetDockRestore(DOCKRESTORE* pdr, CWnd* pWnd);
    void GetDockInfo(_DWI* pdwi, CWnd* pWnd);
    _DWI* GetRowInfo(int iRow = -1);

    BOOL AddWnd(CWnd* pWnd, CSize size);
	BOOL AddWnd(CWnd* pWnd, DOCKRESTORE* pdr);
    BOOL AddWnd(CWnd* pWnd, const CRect& rect, ULONG nID = ULONG_MAX);
    void MoveWnd(CWnd* pWnd, CRect rect,
    	BOOL bAdd = FALSE, ULONG nID = ULONG_MAX);
    void RemoveWnd(CWnd* pWnd, CWnd* pNewParent);

	BOOL IsInsert(CRect rect, int* piRow, BOOL bMenu);

	MAX_STATE GetMaxState(CWnd* pWnd);
	void MaximizeRestore(CWnd* pWnd);
    
// Implementation
public:
	BOOL m_bInitialized:1;
	BOOL m_bChicagoSizingHack:1;

	DOCKPOS m_dp;
	int m_nAlong;	// Window size along a row.
    int m_nRows;
    ROWSTRUCT* m_arRows;
	ULONG m_nIDNext, m_nIDPrev;
    CDockManager* m_pManager;
    
    static HCURSOR s_hcurHSize, s_hcurVSize;

// Layout helping functions.
protected:
    _DWI* BeginLayout();
    void EndLayout(_DWI* rgdwi, BOOL bRecalc = TRUE);
    
    _DWI* FindDockInfo(_DWI* pdwi, CWnd* pWndFind);

    void RemoveRow(_DWI* pdwi, int iRow);
    void InsertRow(_DWI* pdwi, int iRow, int iSize, ULONG nID = ULONG_MAX);
    void SizeRow(_DWI* pdwi, int iRow, int iSize = 0);
    void RecalcRow(_DWI* rgdwi, int iRow, CWnd* pWnd = NULL,
    	BOOL bForceWrap = FALSE);
    void SortRow(_DWI* pdwi, int iRow, CWnd* pWnd = NULL);
    
    BOOL IsRowEmpty(_DWI* pdwi, int iRow);

	int GetWindowOffset(int iRow);
	void GetSplitterRect(int iRow, CRect& rect, BOOL bTracking = FALSE);
	void GetSplitterRect(int iRow, int iPosition, CRect& rect,
		BOOL bTracking = FALSE);
	void GetBoundaryRect(CPoint ptHitTest, CRect& rect);
	CPoint HitTest(CPoint point);
	
	BOOL TrackSize(CPoint pt, CPoint ptHitTest, int& nFinalOffset);
	void DrawTrackRect(CDC* pdc, const CRect* pRect1,
		const CRect* pRect2 = NULL);

	void OnDrawChicago(CDC* pDC);
	void OnDrawNT(CDC* pDC);
	
// Generated message map functions
protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	
    //{{AFX_MSG(CDockWnd)
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnPaint();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams);
	afx_msg void OnNcPaint();
	afx_msg LRESULT OnCommandHelp(WPARAM, LPARAM);
	//}}AFX_MSG
    afx_msg LRESULT OnSizeParent(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRouteMessage(WPARAM wParam, LPARAM lParam);
    
    virtual void Serialize(CArchive& ar);

    DECLARE_MESSAGE_MAP()
    DECLARE_SERIAL(CDockWnd)
};

void DockTranspose(DOCKPOS dp, SIZE FAR* lpsize);
void DockTranspose(DOCKPOS dp, LPPOINT lppt);
void DockTranspose(DOCKPOS dp, LPRECT lprect);

///////////////////////////////////////////////////////////////////////////////
//	CMDIChildDock window
//

class CMDIChildDock : public CPartFrame
{
public:
    CMDIChildDock(CDockManager* pManager);
    ~CMDIChildDock();

    BOOL Create(LPCSTR lpClassName, LPCSTR lpTitle, CWnd* pChildWnd,
        CMDIFrameWnd* pParentWnd, CRect rect);

	void ParentChild(CWnd* pWndNewParent);
	void SetManager(CDockManager* pManager);
	CDockWorker* GetWorker() const;

public:
	virtual BOOL IsInWorkspace() { return FALSE; }

protected:
	void SetChildID(CWnd* pChildWnd, UINT nID);

    //{{AFX_MSG(CMDIChildDock)
	afx_msg void OnClose();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_DYNAMIC(CMDIChildDock)

protected:
    CDockManager* m_pManager;
	UINT m_nIDSave;
};

inline void CMDIChildDock::SetManager(CDockManager* pManager)
{	m_pManager = pManager;	}

#endif	// __DOCKWNDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobctr.cpp ===
// docobctr.cpp : implementation of the CDocObjectContainerItem class
//

#include "stdafx.h"
#pragma hdrstop

#include "docobctr.h"
#include "docobtpl.h"
#include "docobdoc.h"
#include "docobfhk.h"
#include "oleref.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// REVIEW(scotg)  this needs to be removed when we pick up a new
// docobj.h header that will include this guid.
DEFINE_GUID(SID_SContainerDispatch, 0xb722be00, 0x4e68, 0x101b, 0xa2, 0xbc,0x0, 0xaa, 0x0, 0x40, 0x47,0x70);
DEFINE_GUID(SID_SContainer,			0x0000011b, 0x0,    0x0,    0xc0, 0x0, 0x0, 0x0,  0x0, 0x0,  0x0, 0x46);

/////////////////////////////////////////////////////////////////////////////
// CDocObjectContainerItem implementation

IMPLEMENT_SERIAL(CDocObjectContainerItem, COleClientItem, 0)

BEGIN_INTERFACE_MAP(CDocObjectContainerItem, COleClientItem)
	 INTERFACE_PART(CDocObjectContainerItem, IID_IOleDocumentSite, OleDocumentSite)
	 INTERFACE_PART(CDocObjectContainerItem, IID_IOleInPlaceSite, OleInPlaceSite)
	 INTERFACE_PART(CDocObjectContainerItem, IID_IServiceProvider, ServiceProvider)
END_INTERFACE_MAP()

CDocObjectContainerItem::CDocObjectContainerItem(COleDocument * pContainer)
	: COleClientItem(pContainer)
{
	m_pOleDocument = NULL;
	m_pOleDocumentView = NULL;
	m_lpObject = NULL;
	m_lpStorage = NULL;
	HRESULT hr = ::OleInitialize(NULL);
	// S_OK means initialization succeeded, S_FALSE means already initialized.
	ASSERT(hr == S_OK || hr == S_FALSE);
	m_strCurFileName.Empty();

	m_bReadOnlyOnDisk = FALSE ;
}

CDocObjectContainerItem::~CDocObjectContainerItem()
{
	USES_CONVERSION;

	if (m_pOleDocumentView != NULL)
	{
		m_pOleDocumentView->CloseView(0);
		m_pOleDocumentView->Release();
		m_pOleDocumentView = NULL;
	}

	if (m_pOleDocument != NULL)
	{
		m_pOleDocument->Release();
		m_pOleDocument = NULL;
	}

	::OleUninitialize();
}

BOOL CDocObjectContainerItem::IsModified()
{
	COleRef<IPersistStorage> srpPersistStorage;
	VERIFY(SUCCEEDED(m_lpObject->QueryInterface(IID_IPersistStorage, (LPVOID *)&srpPersistStorage)));
	BOOL bDirty = (srpPersistStorage->IsDirty() != S_FALSE);
	return(bDirty);
}

BOOL CDocObjectContainerItem::IsReadOnlyOnDisk()
{
	return m_bReadOnlyOnDisk ;
}

void CDocObjectContainerItem::OnSizeChange()
{
	ASSERT(m_pView != NULL);

	RECT rectViewClient;
	m_pView->GetClientRect(&rectViewClient);
	if(m_pOleDocumentView)
		VERIFY(SUCCEEDED(m_pOleDocumentView->SetRect(&rectViewClient)));
}

BOOL CDocObjectContainerItem::CreateNewUntitledFile(CLSID clsid)
{
	USES_CONVERSION;

	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);
	ASSERT(clsid != GUID_NULL);

	m_dwItemNumber = GetNewItemNumber();

	// Create a storage for the file.
	if (FAILED(StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE |
			STGM_CREATE | STGM_DELETEONRELEASE, 0, &m_lpStorage)))
		return FALSE;


	if(FAILED(::OleCreate(clsid, IID_IOleObject,
				OLERENDER_NONE, NULL,
				&m_xOleClientSite, m_lpStorage, (void **)&m_lpObject)))
		return FALSE;

	m_lpObject->Advise(&m_xAdviseSink, &m_dwConnection);

	ASSERT_VALID(this);
	// save the storage location file name
	m_strCurFileName = "Untitled";
	return TRUE;
}

#include <initguid.h>
DEFINE_GUID (CLSID_Word97, 0x00020906, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

// Creation of an item whose object storage is not embedded in the container storage, but instead is
// in a separate file.
//
// We do this slightly unusual thing because of the unusual container model of VC++ projects,
// in which a project points to a bunch of other things which live as separate files, not embedded
// within the project file.
//
// Also this is what you probably want for doing File/Open on a doc object.
//
// NOTE: this is not a link, because a link still needs there to be a container storage for the link
//		to be stored in.
BOOL CDocObjectContainerItem::CreateFromExternalFile(LPCTSTR lpszFileName, CLSID clsid)
{
	USES_CONVERSION;

	ASSERT_VALID(this);
	ASSERT(m_lpObject == NULL);     // one time only
	ASSERT(m_pDocument != NULL);

	m_dwItemNumber = GetNewItemNumber();

	// Open a storage on the file.
	if(::StgIsStorageFile(T2W(lpszFileName)) == S_OK)
	{
		if( FAILED(::StgOpenStorage(T2W(lpszFileName), NULL, STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_WRITE, NULL, 0, &m_lpStorage)))
		{
			if(FAILED(::StgOpenStorage(T2W(lpszFileName), NULL, STGM_TRANSACTED | STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, &m_lpStorage)))
				return FALSE;

			m_bReadOnlyOnDisk = TRUE ;
		}
		// Load the file into the storage.
		if (FAILED(::OleLoad(m_lpStorage, IID_IOleObject, &m_xOleClientSite, (void **)&m_lpObject)))
			return FALSE;

		if (NULL == m_lpObject)
			return FALSE;
	}
	else
	{
		CPath path;
		path.Create(lpszFileName);

		if ((IsEqualCLSID(clsid, CLSID_Word97)) && (!_tcsicmp(path.GetExtension(), _T(".RTF"))))
		{
			// if the server is Word97 and the file is RTF then open in-place...
			if (FAILED(::CoCreateInstance(clsid, NULL, (CLSCTX_INPROC_SERVER| CLSCTX_LOCAL_SERVER),
											IID_IOleObject, (void **)&m_lpObject)))
				return FALSE;

			if (NULL == m_lpObject)
				return FALSE;

			DWORD dwStatus = 0;
			m_lpObject->GetMiscStatus(DVASPECT_CONTENT, &dwStatus);

			if ((dwStatus & OLEMISC_SETCLIENTSITEFIRST) != 0 &&
				FAILED(m_lpObject->SetClientSite(&m_xOleClientSite)))
			{
				return FALSE;
			}

			COleRef<IPersistFile> pPersistFile;
			VERIFY(SUCCEEDED(m_lpObject->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile)));
			if (FAILED(pPersistFile->Load(T2W(lpszFileName), STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_DENY_WRITE)))
				if (FAILED(pPersistFile->Load(T2W(lpszFileName), STGM_TRANSACTED | STGM_READ | STGM_SHARE_DENY_WRITE)))
					return FALSE;

			if ((dwStatus & OLEMISC_SETCLIENTSITEFIRST) == 0 &&
				FAILED(m_lpObject->SetClientSite(&m_xOleClientSite)))
			{
				return FALSE;
			}
		}
		else
		{
			// otherwise, attempt to open the file with the server application standalone.
			::ShellExecute(NULL, NULL, lpszFileName, NULL, NULL, SW_SHOWDEFAULT);

			// [patbr] hack! flag our document that open was standalone.
			m_pOleDocument = (LPOLEDOCUMENT)0xFFFFFFFF;
			m_pOleDocumentView = (LPOLEDOCUMENTVIEW)0xFFFFFFFF;

			// return FALSE to indicate that no document or view should be created.
			return FALSE;
		}
	}

	m_lpObject->Advise(&m_xAdviseSink, &m_dwConnection);

	ASSERT_VALID(this);
	// save the storage location file name
	m_strCurFileName = lpszFileName;
	return TRUE;
}

#define SAVE_AS_RTF 6
#define CMD_SAVE_AS 102

BOOL CDocObjectContainerItem::SaveToExternalFile(LPCTSTR lpszFileName)
{
	USES_CONVERSION;

	// if the file is not dirty and the specified storage location
	// has not been changed then we don't have to do anything...
	if (!IsModified() && !m_strCurFileName.CompareNoCase(lpszFileName))
		return(TRUE);

	BOOL bRet;
	
	if(m_lpStorage == NULL)
	{
		BOOL bHasName;
		LPOLESTR pwszFileName = NULL;
		COleRef<IPersistFile> pPersistFile;
		VERIFY(SUCCEEDED(m_lpObject->QueryInterface(IID_IPersistFile, (LPVOID *)&pPersistFile)));
		bHasName = (pPersistFile->GetCurFile(&pwszFileName) == S_OK);
		if (!m_strCurFileName.CompareNoCase(lpszFileName) && bHasName)
		{
			// File.Save
			HRESULT hr = pPersistFile->Save(NULL, TRUE);
			if (SUCCEEDED(hr))
			{
				pPersistFile->SaveCompleted(pwszFileName);
				bRet = TRUE;
			}
			else
			{
				// this failure occurs when the file cannot be saved to a
				// storage--for example, when the file is RTF opened by Word.
				// here we do specific handling for the Word/RTF case.
				CPath path;
				path.Create(lpszFileName);
				CDocObjectDoc *pDoc = GetDocument();
				CLSID clsid = pDoc->m_clsid;
				if ((IsEqualCLSID(clsid, CLSID_Word97)) && (!_tcsicmp(path.GetExtension(), _T(".RTF"))))
				{
					COleRef<IDispatch> pDispatch;
					if (SUCCEEDED(m_lpObject->QueryInterface(IID_IDispatch, (LPVOID *)&pDispatch)))
					{
						VARIANTARG rgvarg[2];
						rgvarg[0].vt = VT_I4;
						rgvarg[0].lVal = SAVE_AS_RTF;
						rgvarg[1].vt = VT_BSTR;
						BSTR bstr = SysAllocString(T2W(lpszFileName));
						ASSERT(bstr);
						rgvarg[1].bstrVal = bstr;
						DISPPARAMS dispparams;
						dispparams.rgvarg = rgvarg;
						dispparams.cArgs = 2;
						dispparams.cNamedArgs = 0;
						dispparams.rgdispidNamedArgs = 0;
						VARIANT varResult;
						EXCEPINFO excepInfo;
						UINT uArgErr = 0;
						TRY
						{
							hr = pDispatch->Invoke(CMD_SAVE_AS, IID_NULL, LOCALE_SYSTEM_DEFAULT,
								DISPATCH_METHOD, &dispparams, &varResult, &excepInfo, &uArgErr);
						}
						CATCH_ALL(e)
						{
							ASSERT(FALSE);
						}
						END_CATCH_ALL
						SysFreeString(bstr);
						bRet = SUCCEEDED(hr);
					}
				}
			}
			if(pwszFileName)
				CoTaskMemFree(pwszFileName);
		}
		else
		{
			// File.SaveAs
			if(pwszFileName)
				CoTaskMemFree(pwszFileName);
			pwszFileName = T2W(lpszFileName);
			bRet = SUCCEEDED(pPersistFile->Save(pwszFileName, TRUE));
			if(bRet)
				pPersistFile->SaveCompleted(pwszFileName);
		}
		return bRet;
	}

	if (!m_strCurFileName.CompareNoCase(lpszFileName))
	{
		// File.Save
		COleRef<IPersistStorage> srpPersistStorage;
		VERIFY(SUCCEEDED(m_lpObject->QueryInterface(IID_IPersistStorage, (LPVOID *)&srpPersistStorage)));
		if ((bRet = (SUCCEEDED(srpPersistStorage->Save(m_lpStorage, TRUE)))) == TRUE)
		{
			VERIFY(SUCCEEDED(srpPersistStorage->SaveCompleted(m_lpStorage)));
			VERIFY(SUCCEEDED(m_lpStorage->Commit(STGC_OVERWRITE)));
		}
	}
	else
	{
		// File.SaveAs
		COleRef<IStorage> srpStorage;
		if (FAILED(StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, 0, &srpStorage)))
			return FALSE;

		COleRef<IPersistStorage> srpPersistStorage;
		VERIFY(SUCCEEDED(m_lpObject->QueryInterface(IID_IPersistStorage, (LPVOID *)&srpPersistStorage)));
		if ((bRet = (SUCCEEDED(::OleSave(srpPersistStorage, srpStorage, FALSE)))) == TRUE)
		{
			VERIFY(SUCCEEDED(srpPersistStorage->HandsOffStorage()));

			// make sure that the file does not exist on disk--the user has already
			// indicated that he wants to overwrite so delete the file if necessary.
			if (_access(lpszFileName, 0) != -1)
				VERIFY(remove(lpszFileName) == 0);
			
			COleRef<IRootStorage> srpRootStorage;
			VERIFY(SUCCEEDED(srpStorage->QueryInterface(IID_IRootStorage, (LPVOID *)&srpRootStorage)));
			VERIFY(SUCCEEDED(srpRootStorage->SwitchToFile(T2W(lpszFileName))));

			VERIFY(SUCCEEDED(srpPersistStorage->SaveCompleted(srpStorage)));
			m_lpStorage->Release();
			m_lpStorage = srpStorage.Disown();
			VERIFY(SUCCEEDED(m_lpStorage->Commit(STGC_OVERWRITE)));

			// NOTE: IPersistFile::GetCurFile() may return temp file name,
			// so we save away the file name on load and on each save-as.
			m_strCurFileName = lpszFileName;
		}
		else
		{
			VERIFY(SUCCEEDED(srpPersistStorage->SaveCompleted(NULL)));
		}

	}

	return(bRet);
}

void CDocObjectContainerItem::DoClose()
{
	// If the object never got created, do nothing.
	if(m_lpObject == NULL)
		return;

	COleRef<IOleInPlaceObject> srpInPlaceObject;

	BOOL fRet = FALSE;
	if (SUCCEEDED(m_lpObject->QueryInterface(IID_IOleInPlaceObject, (void **)&srpInPlaceObject)))
	{
		ASSERT(srpInPlaceObject != NULL);
		VERIFY(SUCCEEDED(srpInPlaceObject->UIDeactivate()));
		VERIFY(SUCCEEDED(srpInPlaceObject->InPlaceDeactivate()));
	}
	srpInPlaceObject.SRelease();

	// remove external lock placed on item during in-place activation
	if (m_bLocked)  //COleClientItem::OnActivate calls OleLockRunning TRUE.
	{
		OleLockRunning(m_lpObject, FALSE, TRUE);
		m_bLocked = FALSE;
	}
	
	if (m_pOleDocumentView != NULL)
	{
		m_pOleDocumentView->CloseView(0);
		OleRelease(m_pOleDocumentView);
	}

	if (m_pOleDocument != NULL)
		OleRelease(m_pOleDocument);

	Release(OLECLOSE_NOSAVE); 

	// need to Remove ourselves from the Document's item collection, otherwise,
	// we will get deleted in COleDocument destructor.
	if (m_pDocument != NULL)
		m_pDocument->RemoveItem(this);

	LPUNKNOWN lpUnknown = (LPUNKNOWN)GetInterface(&IID_IUnknown);
	ASSERT(lpUnknown != NULL);

	// disconnect the object
	::CoDisconnectObject(lpUnknown, 0);
}

void CDocObjectContainerItem::Activate(LONG lVerb, CView *pView)
{
	RECT rc;
	CWaitCursor curWait;

	// Quietly hook up our view to the COleClientItem.
	m_pView = pView;
	pView->GetClientRect(&rc);
	m_lpObject->DoVerb(lVerb, NULL, &m_xOleClientSite, 0, pView->m_hWnd, &rc);
}

BOOL CDocObjectContainerItem::GetOleDocument()
{
	if (m_pOleDocument != NULL)
		return TRUE;	// already have it

	// Get the object into the running state if it isn't already (otherwise QI will fail).
	if (OleRun(m_lpObject) != S_OK)
		return FALSE;	// couldn't start the server

	HRESULT hresult = m_lpObject->QueryInterface(IID_IOleDocument, (void **)&m_pOleDocument);
	ASSERT((hresult == NOERROR) == (m_pOleDocument != NULL));
	return(hresult == NOERROR);
}

IOleInPlaceSite* CDocObjectContainerItem::GetIOleInPlaceSite()
{
	return &m_xOleIPSite;
}

void CDocObjectContainerItem::OnGetItemPosition(CRect &rrcPosition)
{
	ASSERT_VALID(this);
	ASSERT(AfxIsValidAddress(&rrcPosition, sizeof(RECT)));

	ASSERT_VALID(m_pView);
	m_pView->GetClientRect(&rrcPosition);
}

BOOL CDocObjectContainerItem::OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow)
{
	BOOL bRet = FALSE;
	ASSERT_VALID(pFrameWnd);
	
	if (pFrameWnd->IsKindOf(RUNTIME_CLASS(CMainFrame)))
		bRet = !DkDocObjectMode(!bShow);

	COleClientItem::OnShowControlBars(pFrameWnd, bShow);
	return bRet;
}

void CDocObjectContainerItem::OnInsertMenus(CMenu* pMenuShared,
	LPOLEMENUGROUPWIDTHS lpMenuWidths)
{

	// Make sure the inplace menu is initialized.
	CPartTemplate* pTemplate = (CPartTemplate*) GetDocument()->GetDocTemplate();
	ASSERT(pTemplate != NULL && pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
	pTemplate->SetContainerInfo();

	COleClientItem::OnInsertMenus(pMenuShared, lpMenuWidths);
}

void CDocObjectContainerItem::OnSetMenu(CMenu* pMenuShared, HOLEMENU holemenu,
	HWND hwndActiveObject)
{

	COleClientItem::OnSetMenu(pMenuShared, holemenu, hwndActiveObject);

	 // [fabriced] 20 jun 96 -- Force repaint (MFC bug DevStud'96 #4354)
	theApp.CWinApp::OnIdle(0);
	
	if(NULL != pMenuShared)
		theApp.m_bMenuDirty = FALSE;
}

// This routine contains the IServiceProvider/service routing logic.  We search for 
// services as follows:
//	container/site
//	document
//	package that owns the document
//	application, which in turn searches as follows
//		if CLSID_NULL == guidService, call the shell's FindInterface()
//		mainframe
//		itself, if it ever need to provide services
//		round robin through the packages
HRESULT CDocObjectContainerItem::GetService(REFGUID guidService, REFIID riid, void **ppvObj)
{
	IUnknown *punk = NULL;
	HRESULT hr = E_NOINTERFACE;

	if (ppvObj == NULL)
		return E_INVALIDARG;

	*ppvObj = NULL;

	CPartDoc *pDoc = GetDocument();

	if(SID_SContainerDispatch == guidService)
	{
		// get the container object that gets the dispatch
		// don't continue service routing in this case
		// always return
		ASSERT(NULL != pDoc && pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));
		IDispatch *pDisp = pDoc->GetAutomationObject(FALSE);	// no addref
		if(NULL != pDisp)
			hr = pDisp->QueryInterface(riid, ppvObj);
		return hr;					// always return
	}

	if(SID_SContainer == guidService)
	{
		// we don't support an IOleContainer COM abstraction
		return E_NOINTERFACE;		// always return
	}

	// give the package a shot at honoring the service request
	CPackage *pPackage = pDoc->GetPackage();
	ASSERT(NULL != pPackage);
	hr = pPackage->GetService(guidService, riid, ppvObj);
	if(SUCCEEDED(hr))
		return hr;

	// give the app (which will ask the mainframe) and all packages
	// if necessary
	return theApp.GetService(guidService, riid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleDocumentSite

IMPLEMENT_ADDREF		(CDocObjectContainerItem, OleDocumentSite)
IMPLEMENT_RELEASE		(CDocObjectContainerItem, OleDocumentSite)
IMPLEMENT_QUERYINTERFACE(CDocObjectContainerItem, OleDocumentSite)

STDMETHODIMP CDocObjectContainerItem::XOleDocumentSite::ActivateMe(IOleDocumentView *pOleView)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleDocumentSite)

	RECT rc;
	// If we're passed a NULL view pointer, then try to get one from
	// the document object (the object within us).
	if (NULL == pOleView)
	{
		if (FAILED(pThis->m_pOleDocument->CreateView(pThis->GetIOleInPlaceSite(), NULL, 0, &pOleView)))
			return E_OUTOFMEMORY;
		pThis->m_pOleDocumentView = pOleView;
	}

	ASSERT(pOleView == pThis->m_pOleDocumentView);
	// Make sure that the view has our client site.
	pOleView->SetInPlaceSite(pThis->GetIOleInPlaceSite());

	// Activation steps, now that we have a view:
	// 1.  Call IOleDocumentView::SetInPlaceSite (assume done since
	//     either the view already knows, or IOleDocument::CreateView
	//     has done it already.
	// 2.  Call IOleDocumentView::Show to make the thing visible.
	// 3.  Call IOleDocumentView::UIActivate to finish the job.
	// 4.  Call IOleDocumentView::SetRect to give a bunch of space to
	//     the view.  In our case this is the whole client area of
	//     the CPages window.  (Patron doesn't use SetRectComplex)

	// Make it active
	pOleView->Show(TRUE);    

	// virtual call-back for derived classes
	pThis->OnActivateMe();
	
	// This sets up toolbars and menus
	VERIFY(SUCCEEDED(pOleView->UIActivate(TRUE)));

	// Set the window size sensitive to new toolbars
	pThis->m_pView->GetClientRect(&rc);
	pOleView->SetRect(&rc);

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleInPlaceSite

IMPLEMENT_ADDREF		(CDocObjectContainerItem, OleInPlaceSite)
IMPLEMENT_RELEASE		(CDocObjectContainerItem, OleInPlaceSite)
IMPLEMENT_QUERYINTERFACE(CDocObjectContainerItem, OleInPlaceSite)


STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::GetWindow(HWND* lphwnd)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.GetWindow(lphwnd);
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::ContextSensitiveHelp(
	BOOL fEnterMode)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.ContextSensitiveHelp(fEnterMode);
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::CanInPlaceActivate()
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.CanInPlaceActivate();
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::OnInPlaceActivate()
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.OnInPlaceActivate();
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::OnUIActivate()
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.OnUIActivate();
}

// the following won't be necessary when the MFC team uses a virtual function in the 
// IOleInPlaceSite::GetWindowContext method to allow one to use a derived class of 
// COleFrameHook.
STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::GetWindowContext(
	LPOLEINPLACEFRAME* lplpFrame, LPOLEINPLACEUIWINDOW* lplpDoc,
	LPRECT lpPosRect, LPRECT lpClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	METHOD_PROLOGUE_EX(CDocObjectContainerItem, OleInPlaceSite)
	ASSERT_VALID(pThis);

	*lplpFrame = NULL;  // init these in-case of mem-alloc failure
	*lplpDoc = NULL;

	CFrameWnd* pMainFrame = NULL;
	CFrameWnd* pDocFrame = NULL;

	SCODE sc = E_UNEXPECTED;
	TRY
	{
		// get position of the item relative to activation view
		CRect rect;
		pThis->OnGetItemPosition(rect);
		::CopyRect(lpPosRect, &rect);
		pThis->OnGetClipRect(rect);
		::CopyRect(lpClipRect, &rect);

		// get the window context information
		if (pThis->OnGetWindowContext(&pMainFrame, &pDocFrame, lpFrameInfo))
		{
			// hook IOleInPlaceFrame interface to pMainFrame
			if (pThis->m_pInPlaceFrame == NULL)
				pThis->m_pInPlaceFrame = new CDocObjectFrameHook(pMainFrame, pThis);
			pThis->m_pInPlaceFrame->InternalAddRef();
			*lplpFrame = (LPOLEINPLACEFRAME)pThis->m_pInPlaceFrame->
				GetInterface(&IID_IOleInPlaceFrame);

			// save accel table for IOleInPlaceFrame::TranslateAccelerators
			pThis->m_pInPlaceFrame->m_hAccelTable = lpFrameInfo->haccel;

			// hook IOleInPlaceUIWindow to pDocFrame
			if (pDocFrame != NULL)
			{
				if (pThis->m_pInPlaceDoc == NULL)
					pThis->m_pInPlaceDoc = new CDocObjectFrameHook(pDocFrame, pThis);
				pThis->m_pInPlaceDoc->InternalAddRef();
				*lplpDoc = (LPOLEINPLACEUIWINDOW)pThis->m_pInPlaceDoc->
					GetInterface(&IID_IOleInPlaceUIWindow);
			}
			sc = S_OK;
		}
	}
	CATCH_ALL(e)
	{
		// cleanup memory that may be partially allocated
		delete *lplpFrame;
		ASSERT(*lplpDoc == NULL);
		do { e->Delete(); } while (0);
	}
	END_CATCH_ALL

	return sc;
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::Scroll(SIZE scrollExtent)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.Scroll(scrollExtent);
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::OnUIDeactivate(BOOL fUndoable)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.OnUIDeactivate(fUndoable);
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::OnInPlaceDeactivate()
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.OnInPlaceDeactivate();
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::DiscardUndoState()
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.DiscardUndoState();
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::DeactivateAndUndo()
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.DeactivateAndUndo();
}

STDMETHODIMP CDocObjectContainerItem::XOleInPlaceSite::OnPosRectChange(LPCRECT lpPosRect)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, OleInPlaceSite)
	return pThis->m_xOleIPSite.OnPosRectChange(lpPosRect);
}

/////////////////////////////////////////////////////////////////////////////
// CDocObjectContainerItem diagnostics

#ifdef _DEBUG
void CDocObjectContainerItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CDocObjectContainerItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Implementation of IServiceProvider

IMPLEMENT_ADDREF		(CDocObjectContainerItem, ServiceProvider)
IMPLEMENT_RELEASE		(CDocObjectContainerItem, ServiceProvider)
IMPLEMENT_QUERYINTERFACE(CDocObjectContainerItem, ServiceProvider)

HRESULT CDocObjectContainerItem::XServiceProvider::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
	METHOD_PROLOGUE(CDocObjectContainerItem, ServiceProvider)

	if(NULL == ppvObj)
		return E_INVALIDARG;

	*ppvObj = NULL;

	return pThis->GetService(guidService, riid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobdoc.h ===
// docobdoc.h : interface of the CDocObjectDoc class
//

#ifndef __DOCOBDOC_H__
#define __DOCOBDOC_H__

class CDocObjectContainerItem;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CDocObjectDoc

class AFX_EXT_CLASS CDocObjectDoc : public CPartDoc
{
	DECLARE_DYNCREATE(CDocObjectDoc)

protected:
	CDocObjectDoc();

public:
	CLSID m_clsid;	// the CLSID of the thing we are hosting

public:
	//{{AFX_VIRTUAL(CDocObjectDoc)
	public:
	virtual BOOL NewDocumentHook();
	virtual BOOL OpenDocumentHook(LPCTSTR lpszPathName);
	virtual BOOL SaveDocumentHook(const char* pszPathName, UINT nSaveType = 0);
	virtual void CloseDocumentHook();
	//}}AFX_VIRTUAL
	virtual HRESULT	GetService(REFGUID guidService, REFIID riid, void **ppvObj);

public:
	virtual ~CDocObjectDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL IsModified();				// overridden for 'save on close?'
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
	CDocObjectContainerItem *m_pItem;	// the OleClientItem which provides the container site

	virtual void DoClose();

protected:
	//{{AFX_MSG(CDocObjectDoc)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __DOCOBDOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobfhk.cpp ===
// docobfhk.cpp : implementation of the CDocObjectFrameHook class
//

#include "stdafx.h"
#pragma hdrstop

#include "docobfhk.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocObjectFrameHook implementation

BEGIN_INTERFACE_MAP(CDocObjectFrameHook, COleFrameHook)
	INTERFACE_PART(CDocObjectFrameHook, IID_IOleCommandTarget, OleCommandTarget)
END_INTERFACE_MAP()

CDocObjectFrameHook::CDocObjectFrameHook(CFrameWnd* pFrameWnd, COleClientItem* pItem)
	:COleFrameHook(pFrameWnd, pItem)
{
}

CDocObjectFrameHook::~CDocObjectFrameHook()
{
}

BOOL CDocObjectFrameHook::OnDocActivate(BOOL bActive)
{
	ASSERT_VALID(this);

	if (m_lpActiveObject == NULL)
		return TRUE;

	// allow server to do document activation related actions
	VERIFY(SUCCEEDED(m_lpActiveObject->OnDocWindowActivate(bActive)));

	// make sure window caption gets updated later
	COleFrameHook* pNotifyHook = m_pActiveItem->m_pInPlaceFrame;
	pNotifyHook->m_pFrameWnd->DelayUpdateFrameTitle();

	if (!bActive)
	{
		if (m_pActiveItem->m_pInPlaceDoc != NULL)
			m_pActiveItem->m_pInPlaceDoc->m_xOleInPlaceFrame.SetBorderSpace(NULL);

		// remove the menu hook when the doc is not active
		pNotifyHook->m_xOleInPlaceFrame.SetMenu(NULL, NULL, NULL);
		// clear border space
		pNotifyHook->m_xOleInPlaceFrame.SetBorderSpace(NULL);

		// unhook top-level frame if not needed
		if (pNotifyHook != this)
		{
			// shouldn't be removing some other hook
			ASSERT(pNotifyHook->m_pFrameWnd->m_pNotifyHook == pNotifyHook);
			pNotifyHook->m_pFrameWnd->m_pNotifyHook = NULL;
		}
	}
	else
	{
		// rehook top-level frame if necessary (no effect if top-level == doc-level)
		pNotifyHook->m_pFrameWnd->m_pNotifyHook = pNotifyHook;
	}

	// don't do default if activating
	return bActive;

}

/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleCommandTarget

IMPLEMENT_ADDREF		(CDocObjectFrameHook, OleCommandTarget)
IMPLEMENT_RELEASE		(CDocObjectFrameHook, OleCommandTarget)
IMPLEMENT_QUERYINTERFACE(CDocObjectFrameHook, OleCommandTarget)

// This interface is only implemented so that PowerPoint finds us acceptable.  We
// do not have to return anything meaningful from the methods in the interface.

STDMETHODIMP CDocObjectFrameHook::XOleCommandTarget::QueryStatus(
			const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[],
			OLECMDTEXT *pCmdText)
{
	METHOD_PROLOGUE(CDocObjectFrameHook, OleCommandTarget);
	for(int i=0; i<cCmds; i++)
	{
		DWORD dwFlags = 0;
		switch(prgCmds[i].cmdID)
		{
		case OLECMDID_OPEN:
		case OLECMDID_NEW:
		case OLECMDID_SAVE:
		case OLECMDID_PRINT:
		case OLECMDID_PAGESETUP:
			dwFlags = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
			break;
		}
		prgCmds[i].cmdf = dwFlags;
	}
	return S_OK;
}
        
STDMETHODIMP CDocObjectFrameHook::XOleCommandTarget::Exec(
			const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
	METHOD_PROLOGUE(CDocObjectFrameHook, OleCommandTarget);
	switch(nCmdID)
	{
		case OLECMDID_OPEN:
			AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_OPEN);
			break;
		case OLECMDID_NEW:
			AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_NEW_SOURCE);
			break;
		case OLECMDID_SAVE:
			AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_SAVE);
			break;
		case OLECMDID_PRINT:
			AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_PRINT);
			break;
		case OLECMDID_PAGESETUP:
			AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_FILE_PAGE_SETUP);
			break;
		default:
			return OLECMDERR_E_NOTSUPPORTED;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobfhk.h ===
// docobfhk.h : interface of the CDocObjectFrameHook class
//

#ifndef __DOCOBFHK_H__
#define __DOCOBFHK_H__

/////////////////////////////////////////////////////////////////////////////
// CDocObjectFrameHook 

class CDocObjectFrameHook : public COleFrameHook
{

public:
	CDocObjectFrameHook(CFrameWnd* pFrameWnd, COleClientItem* pItem);
	~CDocObjectFrameHook();

	virtual BOOL OnDocActivate(BOOL bActive);

protected:
	DECLARE_INTERFACE_MAP()

	// we implement IOleCommandTarget in addition to the normal frame hook interfaces because
	// PowerPoint queries our IOleInPlaceFrame interface for our IOleCommandTarget interface.
	BEGIN_INTERFACE_PART(OleCommandTarget, IOleCommandTarget)
		INIT_INTERFACE_PART(CDocObjectFrameHook, OleCommandTarget)
		STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds,
				  OLECMD prgCmds[], OLECMDTEXT *pCmdText);
		STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
	END_INTERFACE_PART(OleCommandTarget)
};

#endif	// __DOCOBFHK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobctr.h ===
// docobctr.h : interface of the CDocObjectContainerItem class
//

#ifndef __DOCOBCTR_H__
#define __DOCOBCTR_H__

#include <objext.h>
#include <docobj.h>

class CDocObjectDoc;
class CDocObjectView;

/////////////////////////////////////////////////////////////////////////////
// CDocObjectContainerItem

class CDocObjectContainerItem : public COleClientItem
{
	DECLARE_SERIAL(CDocObjectContainerItem)

// Constructors
public:
	CDocObjectContainerItem(COleDocument *pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

protected:
	DECLARE_INTERFACE_MAP()

	// we implement IOleDocumentSite in addition to the normal container interfaces
	BEGIN_INTERFACE_PART(OleDocumentSite, IOleDocumentSite)
		INIT_INTERFACE_PART(CDocObjectContainerItem, OleDocumentSite)
		STDMETHOD(ActivateMe)(IOleDocumentView *pMsoView);
	END_INTERFACE_PART(OleDocumentSite)

	// we implement IOleInPlaceSite as an override for COleClientItem::XOleClientSite
	BEGIN_INTERFACE_PART(OleInPlaceSite, IOleInPlaceSite)
		INIT_INTERFACE_PART(CDocObjectContainerItem, OleInPlaceSite)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(CanInPlaceActivate)();
		STDMETHOD(OnInPlaceActivate)();
		STDMETHOD(OnUIActivate)();
		STDMETHOD(GetWindowContext)(LPOLEINPLACEFRAME*,
			LPOLEINPLACEUIWINDOW*, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
		STDMETHOD(Scroll)(SIZE);
		STDMETHOD(OnUIDeactivate)(BOOL);
		STDMETHOD(OnInPlaceDeactivate)();
		STDMETHOD(DiscardUndoState)();
		STDMETHOD(DeactivateAndUndo)();
		STDMETHOD(OnPosRectChange)(LPCRECT);
	END_INTERFACE_PART(OleInPlaceSite)

	BEGIN_INTERFACE_PART(ServiceProvider, IServiceProvider)
		STDMETHOD(QueryService) (REFGUID guidService, REFIID iid, void ** ppvObj);
	END_INTERFACE_PART(ServiceProvider)

	virtual BOOL CanActivate() { return TRUE; }

	virtual void OnGetItemPosition(CRect& rPosition);
		// implement OnGetItemPosition if you support in-place activation and we do!

public:
	CDocObjectDoc *GetDocument()
		{ return (CDocObjectDoc *)COleClientItem::GetDocument(); }
	CDocObjectView *GetActiveView()
		{ return (CDocObjectView *)COleClientItem::GetActiveView(); }
	IServiceProvider *GetIServiceProvider()
		{ return &m_xServiceProvider; }
	virtual HRESULT GetService(REFGUID guidService, REFIID riid, void **ppvObj);

	virtual BOOL CreateNewUntitledFile(CLSID clsid);
	virtual BOOL CreateFromExternalFile(LPCTSTR lpszFileName, CLSID clsid);
	virtual BOOL SaveToExternalFile(LPCTSTR lpszFileName);
	virtual BOOL IsModified();
	virtual BOOL IsReadOnlyOnDisk();
	virtual BOOL GetOleDocument();
	virtual void Activate(LONG lVerb, CView *pView);
	virtual void OnSizeChange();
	virtual void OnActivateMe() { }	// default implementation does nothing...
	virtual void DoClose();

protected:
	BOOL m_bReadOnlyOnDisk;

public:
	LPOLEDOCUMENT     m_pOleDocument;		// IOleDocument interface for m_lpObject
	LPOLEDOCUMENTVIEW m_pOleDocumentView;	// IOleDocumentView interface

	IOleInPlaceSite* CDocObjectContainerItem::GetIOleInPlaceSite();

public:
	~CDocObjectContainerItem();
	virtual BOOL OnShowControlBars(CFrameWnd* pFrameWnd, BOOL bShow);
	virtual void OnInsertMenus(CMenu* pMenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
	virtual void OnSetMenu(CMenu* pMenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

private:
	CString           m_strCurFileName;		// current file name storage for doc object
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __DOCOBCTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobdoc.cpp ===
// docobdoc.cpp : implementation of the CDocObjectDoc class
//

#include "stdafx.h"
#pragma hdrstop

#include "docobdoc.h"
#include "docobtpl.h"
#include "docobctr.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocObjectDoc

IMPLEMENT_DYNCREATE(CDocObjectDoc, CPartDoc)

BEGIN_MESSAGE_MAP(CDocObjectDoc, CPartDoc)
	//{{AFX_MSG_MAP(CDocObjectDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, CPartDoc::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, CPartDoc::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, CPartDoc::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, CPartDoc::OnEditLinks)
	ON_UPDATE_COMMAND_UI(ID_OLE_VERB_FIRST, CPartDoc::OnUpdateObjectVerbMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, CPartDoc::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, CPartDoc::OnEditConvert)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDocObjectDoc construction/destruction

CDocObjectDoc::CDocObjectDoc()
{
	// For most containers, using compound files is a good idea.
	EnableCompoundFile();

	m_clsid = GUID_NULL;
	m_pItem = NULL;
}

CDocObjectDoc::~CDocObjectDoc()
{
}

BOOL CDocObjectDoc::IsModified()
{
	if (m_pItem != NULL)
		return(m_pItem->IsModified());
	return(FALSE);

//	return(CPartDoc::IsModified());
}

BOOL CDocObjectDoc::NewDocumentHook()
{
	// set up the clsid for the document, now that template is attached
	CPartTemplate *pTemplate = (CPartTemplate *)GetDocTemplate();
	ASSERT_KINDOF(CPartTemplate, pTemplate);
	m_clsid = pTemplate->GetTemplateClsid();

	m_pItem = new CDocObjectContainerItem(this);
	if (m_pItem->CreateNewUntitledFile(m_clsid))
		return TRUE;

	// it didn't work ... clean up
	DoClose();
	MsgBox(Error, IDS_DOCOBJ_CANT_CREATE) ;
	return FALSE;
}

BOOL CDocObjectDoc::OpenDocumentHook(LPCTSTR lpszPathName)
{
	// set up the clsid for the document, now that template is attached
	CPartTemplate *pTemplate = (CPartTemplate *)GetDocTemplate();
	ASSERT_KINDOF(CPartTemplate, pTemplate);
	m_clsid = pTemplate->GetTemplateClsid();

	// The document is implemented as a single OLE client
	// item, opened from the specified file.
	m_pItem = new CDocObjectContainerItem(this);
	if (m_pItem->CreateFromExternalFile(lpszPathName, m_clsid))
	{
		SetReadOnlyOnDisk(m_pItem->IsReadOnlyOnDisk()) ;
		return TRUE;
	}

	BOOL fIssueError = TRUE;

	if ((m_pItem->m_pOleDocument == (LPOLEDOCUMENT)0xFFFFFFFF) && (m_pItem->m_pOleDocumentView == (LPOLEDOCUMENTVIEW)0xFFFFFFFF))
	{
		// [patbr] hack! we attempted standalone open of file, so shell should issue
		// error message if the file could not be opened, and we should silently fail.
		// we want to return FALSE, though, so no document or view is created.
		m_pItem->m_pOleDocument = (LPOLEDOCUMENT)NULL;
		m_pItem->m_pOleDocumentView = (LPOLEDOCUMENTVIEW)NULL;
		fIssueError = FALSE;
	}

	// it didn't work ... clean up
	DoClose();

	if (fIssueError)
	{
		CString str ;
		MsgBox(Error, MsgText(str, IDS_DOCOBJ_CANT_OPEN, lpszPathName));
	}

	return FALSE;
}

BOOL CDocObjectDoc::SaveDocumentHook(const char* pszPathName, UINT nSaveType)
{
	ASSERT(m_pItem != NULL);
	return(m_pItem->SaveToExternalFile(pszPathName));
}

void CDocObjectDoc::DoClose()
{
	if (m_pItem != NULL)
	{
		POSITION pos = GetFirstViewPosition();
		CView *pView = GetNextView(pos);
		if(pView)
		{
			CFrameWnd *pFrame = (CFrameWnd *)pView->GetParent();
			// The only possible pending activation here is our own frame
			ASSERT(!CPartFrame::s_pFrmHookActivate  || !pFrame || 
				CPartFrame::s_pFrmHookActivate == pFrame->m_pNotifyHook);
			
			// If we are in the process of activating, let's ignore it, it will
			// cancel out when it gets to CPartFrame::MDIActivate
			if(!CPartFrame::s_pFrmHookActivate && pFrame)
			{
				// if we are the active frame now, let's de-activate
				if(CPartFrame::s_pLastActiveFrame == pFrame)
				{
					CPartFrame::s_pFrmHookDeactivate = pFrame->m_pNotifyHook;
					CPartFrame::s_pLastActiveFrame = NULL;
					CPartFrame::FinishActivation();
				}
			}
		}
		m_pItem->DoClose();
		CDocObjectContainerItem *pTempItem = m_pItem;
		m_pItem = NULL;
		pTempItem->InternalRelease();
		OleRelease(m_lpRootStg);
	}
}


BOOL CDocObjectDoc::CanCloseFrame(CFrameWnd *pFrame)
{
	BOOL fRet = TRUE;
	// if pFrame is NULL, only check whether we can close the container item,
	// do NOT call CanCloseFrame which will cause prompting to the user
	if (pFrame)
		fRet = COleDocument::CanCloseFrame(pFrame);

	return fRet;
}

void CDocObjectDoc::CloseDocumentHook()
{
	// delete the contained item if any...this will close the doc object view.
	DoClose();
	CPartDoc::CloseDocumentHook();	// base implementation
}

HRESULT	CDocObjectDoc::GetService(REFGUID guidService, REFIID riid, void **ppvObj)
{
	// we offer not services at this time
	if (ppvObj == NULL)
		return E_INVALIDARG;

	*ppvObj = NULL;
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// CDocObjectDoc serialization

void CDocObjectDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class CPartDoc enables serialization
	//  of the container document's COleClientItem objects.
	CPartDoc::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CDocObjectDoc diagnostics

#ifdef _DEBUG
void CDocObjectDoc::AssertValid() const
{
	CPartDoc::AssertValid();
}

void CDocObjectDoc::Dump(CDumpContext& dc) const
{
	CPartDoc::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDocObjectDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobfrm.h ===
// docobfrm.h : interface of the CDocObjectFrame class
//

#ifndef __DOCOBFRM_H__
#define __DOCOBFRM_H__

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

/////////////////////////////////////////////////////////////////////////////
// CDocObjectFrame 

class CDocObjectFrame : public CPartFrame
{
	DECLARE_DYNCREATE(CDocObjectFrame)

public:
	CDocObjectFrame();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	
protected:
	DECLARE_MESSAGE_MAP()

	afx_msg void OnClose();
	afx_msg void OnGetMinMaxInfo(MINMAXINFO * pMinMaxInfo);
};

#undef AFX_DATA
#define AFX_DATA NEAR

#endif	// __DOCOBFRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobtpl.cpp ===
// docobtpl.cpp : implementation of the CDocObjectTemplate class
//

#include "stdafx.h"

#include <objbase.h>

#include "resource.h"
#include "docobvw.h"
#include "docobtpl.h"
#include "docobdoc.h"
#include "docobfrm.h"

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#include <objext.h>
#include <vbaguids.h>

#include <cmguids.h>
#include <oleipcid.h>

IMPLEMENT_DYNAMIC(CDocObjectTemplate, CPartTemplate)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static int nCurFilter = 0;
extern SRankedStringID arsiOpenFilters[];
extern const int nMaxArsiFilters;
/////////////////////////////////////////////////////////////////////////////

CDocObjectTemplate::CDocObjectTemplate(CPackage* pPackage, REFCLSID clsid,
							const CString &strDefaultExtension, 
							const CString &strDescName, 
							const CString &strDocBaseName, HICON hIcon,
							CRuntimeClass *pDocRuntimeClass,
							CRuntimeClass *pViewRuntimeClass)
	: CPartTemplate(IDR_DOCOBJECT,
					(pDocRuntimeClass != NULL) ? pDocRuntimeClass : RUNTIME_CLASS(CDocObjectDoc), 
					RUNTIME_CLASS(CDocObjectFrame),
					(pViewRuntimeClass != NULL) ? pViewRuntimeClass : RUNTIME_CLASS(CDocObjectView),
					pPackage, NULL, clsid),
	  m_pDocRuntimeClass(pDocRuntimeClass)
{
	int nStart = strDefaultExtension.Find('.');
	int nEnd = strDefaultExtension.Find(',');
	CString strExt = strDefaultExtension.Mid(nStart, nEnd - nStart);
	CString strRest = strDefaultExtension.Right(strDefaultExtension.GetLength() - nEnd - 1);
	strRest.TrimLeft();
	nEnd = strRest.Find('(');
	m_strFilter = strRest.Left(nEnd + 1);
//	m_strFilter += _T("*");
	nStart = strRest.Find('.');
	nEnd = strRest.Find(')');
	strRest = strRest.Mid(nStart, nEnd - nStart + 1);
	m_strFilter += strRest;

	if (!strDocBaseName.IsEmpty())
	{
		m_strDocStrings = _T("\n");
		m_strDocStrings += strDocBaseName;
		m_strDocStrings += _T("\n");
	}
	else
		m_strDocStrings = _T("\nDocObject\n");

	// following line allows File.New for DocObjects
	m_strDocStrings += strDescName;
	m_strDocStrings += _T("\n");
	m_strDocStrings += m_strFilter;
	m_strDocStrings += _T("\n");
	m_strDocStrings += strExt;
	m_strDocStrings += _T("\n");

	m_hIcon = hIcon;

	// Don't let the filters overflow the array!!!
	if(nCurFilter < nMaxArsiFilters)
		arsiOpenFilters[nCurFilter++].ids = (DWORD)(LPCTSTR)m_strFilter;
}

CDocTemplate::Confidence CDocObjectTemplate::MatchDocType(const TCHAR* pszPathName, CDocument*& rpDocMatch)
{
	if (theApp.m_bInvokedCommandLine)
	{
		// this is too expensive to check during a cmdline build
		return (noAttempt);
	}

	USES_CONVERSION;

	CLSID clsid;
	CDocTemplate::Confidence match;

	// See what CDocTemplate thinks.
	match = CDocTemplate::MatchDocType(pszPathName, rpDocMatch);

	if (match == yesAlreadyOpen)
		return(match);				// document is already open, return such
	else if (SUCCEEDED(GetClassFile(T2W(pszPathName), &clsid)) && clsid == m_clsid)
		return(yesAttemptNative);	// clsid matches so document matches exactly
	else if (match == yesAttemptNative)
		return(yesAttemptForeign);	// extension matches so document may match
	else
		return(noAttempt);
}

void CDocObjectTemplate::InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc, BOOL bMakeVisible)
{
	// The frame has to become the active frame sooner than normal, because it is about to
	// undergo in-place activation, and MFC will ignore the server's IOleInPlaceFrame::SetMenu
	// call if the active COleClientItem is in an inactive CMDIChildWnd.
	pFrame->ActivateFrame();

	CPartFrame::FinishActivation();
	// otherwise defer to base class implementation.
	CPartTemplate::InitialUpdateFrame(pFrame, pDoc, bMakeVisible);

}

CDocument *CDocObjectTemplate::OpenDocumentFile(const TCHAR* pszPathName, BOOL bMakeVisible)
{

	CWaitCursor curWait;

	Menu::UseOLE(TRUE);		// We are entring DocObject mode
	Menu::UpdateMode(FALSE); // and update the mode
	DkDocObjectMode(TRUE);
	((CMainFrame*) theApp.m_pMainWnd)->m_pManager->IdleUpdateAvailableWnds();
	((CMainFrame *)theApp.m_pMainWnd)->LockLayout(TRUE);

	// Bypass CPartTemplate so we get correct name associated with with doc object.
	CDocument *pDoc = CMultiDocTemplate::OpenDocumentFile(pszPathName, bMakeVisible);

	if(pDoc)
	{
		CPartFrame *pFrame = (CPartFrame *)((CMainFrame *)AfxGetMainWnd())->GetActiveFrame();
		ASSERT(pFrame != AfxGetMainWnd());
		// If we don't have a valid hook, then init failed, let's clean-up
		if(pFrame->m_pNotifyHook == NULL)
		{
			CString str;
			MsgBox(Error, MsgText(str, IDS_DOCOBJ_CANT_OPEN, pszPathName ? pszPathName : _T("")));
			pFrame->DestroyWindow();
			pDoc = NULL;
		}
	}


	if(!pDoc)
	{
		Menu::UseOLE(FALSE);		// We failed DocObject mode
		Menu::UpdateMode(FALSE); // and update the mode
		DkDocObjectMode(FALSE);
	}
	else
	{
		// The base class method sets the flag for a menu rebuild.  This will hose us since
		// we want to use the menu created via SetMenus from the server -- so suppress it.
		theApp.m_bMenuDirty = FALSE;
	}

	((CMainFrame*) theApp.m_pMainWnd)->m_pManager->IdleUpdateAvailableWnds();
	((CMainFrame *)theApp.m_pMainWnd)->LockLayout(FALSE);
	((CMainFrame *)theApp.m_pMainWnd)->RecalcLayout();
	theApp.m_pMainWnd->RedrawWindow(NULL, NULL,
	            RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_UPDATENOW);

	return pDoc;
}

/////////////////////////////////////////////////////////////////////////////

CRegistryKeyEnum::CRegistryKeyEnum(HKEY hkeyRoot, LPCTSTR szRequiredSubkey)
	: m_strRequiredSubkey(CString(szRequiredSubkey))
{
	m_ikey = 0;
	m_hkey = (HKEY)INVALID_HANDLE_VALUE;
	m_hkeyRoot = hkeyRoot;
	ASSERT(m_hkeyRoot != (HKEY)INVALID_HANDLE_VALUE);
}

CRegistryKeyEnum::~CRegistryKeyEnum()
{
	if (m_hkey != INVALID_HANDLE_VALUE)
		VERIFY(RegCloseKey(m_hkey) == ERROR_SUCCESS);
}

static HICON GetIconFromExecutable(const CString &strIconExe, int nIconNum);

BOOL CRegistryKeyEnum::Next(LPCTSTR szType)
{
	TCHAR szSubkey[256];
	ULONG cchSubkey;
	FILETIME filetime;
	m_strDefaultExtension.Empty();
	while (cchSubkey = 256, RegEnumKeyEx(m_hkeyRoot, m_ikey++, szSubkey, &cchSubkey, NULL, NULL, NULL, &filetime) == ERROR_SUCCESS)
	{
		if (m_hkey != INVALID_HANDLE_VALUE)
		{
			VERIFY(RegCloseKey(m_hkey) == ERROR_SUCCESS);
			m_hkey = (HKEY) INVALID_HANDLE_VALUE;
		}

		HKEY hkey = (HKEY)INVALID_HANDLE_VALUE;
		HKEY hClsKey = (HKEY)INVALID_HANDLE_VALUE;

		BOOL fReturn = FALSE;

		if (!m_strRequiredSubkey.IsEmpty())
		{
			// reject if it does not have the desired attribute
			HKEY hkeySub;
			CString strOpenKey = szSubkey;
			strOpenKey += "\\";
			strOpenKey += m_strRequiredSubkey;
			if (RegOpenKeyEx(m_hkeyRoot, strOpenKey, 0, KEY_READ, &hkeySub) != ERROR_SUCCESS)
			{
				hkeySub = (HKEY) INVALID_HANDLE_VALUE;
				goto CloseKeys;
			}

			VERIFY(RegCloseKey(hkeySub) == ERROR_SUCCESS);
			hkeySub = (HKEY) INVALID_HANDLE_VALUE;

			// get the CLSID string
			TCHAR szClsID[40];
			LONG cch = 40;
			if (RegOpenKeyEx(m_hkeyRoot, szSubkey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
				goto CloseKeys;
			if (RegQueryValue(hkey, "CLSID", szClsID, &cch) != ERROR_SUCCESS)
				goto CloseKeys;
			// get the default extension string from CLSID key
			TCHAR szClsKey[60], szBuf[256];
			cch = 256;
			_tcscpy(szClsKey, "CLSID\\");
			_tcscat(szClsKey, szClsID);
			if (RegOpenKeyEx(m_hkeyRoot, szClsKey, 0, KEY_READ, &hClsKey) != ERROR_SUCCESS)
			{
				// It turns out that if RegOpenKeyEx() fails, it sets the result HKEY to
				// all zeros, which then causes an assertion failure later on when
				// we try to close it because its value is no longer INVALID_HANDLE_VALUE.
				// To alleviate this, if the open failed, we'll explicitly set it to
				// INVALID_HANDLE_VALUE here.  My registry is hosed enough that I get to
				// find strange things like this... -mgrier 10/28/96
				hClsKey = (HKEY) INVALID_HANDLE_VALUE;
				goto CloseKeys;
			}

			// get the default extension--if there is none then don't return string
			if (RegQueryValue(hClsKey, "DefaultExtension", szBuf, &cch) != ERROR_SUCCESS)
				goto CloseKeys;

			m_strDefaultExtension = szBuf;
			// now attempt to get a default icon for the
			cch = 256;
			if (RegQueryValue(hClsKey, "DefaultIcon", szBuf, &cch) != ERROR_SUCCESS)
				goto CloseKeys;

			CString strDefIcon = szBuf;
			int nIndex = strDefIcon.Find(',');
			CString strIconExe = strDefIcon.Left(nIndex);
			CString strIconNum = strDefIcon.Right(strDefIcon.GetLength() - nIndex - 1);
			int nIconNum = atoi(strIconNum);
			m_hIcon = GetIconFromExecutable(strIconExe, nIconNum);
			if (m_hIcon == (HICON)-1)
				goto CloseKeys;
			// Get the Display name
			cch = 256;
			if(RegQueryValue(hClsKey, NULL, szBuf, &cch) != ERROR_SUCCESS)
				goto CloseKeys;
			m_strDescName = szBuf;
			// Get the base document name
			cch = 256;
			if(RegQueryValue(hClsKey, "AuxUserType\\2", szBuf, &cch) == ERROR_SUCCESS)
				m_strDocNameBase = szBuf;
			fReturn = TRUE;
		}
		else if (RegOpenKeyEx(m_hkeyRoot, szSubkey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
		{
			// The key must have evaporated between when the enumeration started
			// and now.  Just move to the next one.  -mgrier 10/28/96
			continue;
		}
		else
			fReturn = TRUE;

CloseKeys:
		if(hClsKey != INVALID_HANDLE_VALUE)
			VERIFY(RegCloseKey(hClsKey) == ERROR_SUCCESS);
		if(hkey != INVALID_HANDLE_VALUE)
			VERIFY(RegCloseKey(hkey) == ERROR_SUCCESS);

		if (fReturn)
		{
			m_strKeyName = CString(szSubkey);
			return TRUE;	// found it
		}
		// continue looping to next key
	}
	// clean exit from loop
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

CTaskAllocator::CTaskAllocator()
{
	VERIFY(CoGetMalloc(MEMCTX_TASK, &m_pmalloc) == S_OK);
}

CTaskAllocator::CTaskAllocator(CTaskAllocator &taskalloc)
{
	(m_pmalloc = taskalloc.m_pmalloc)->AddRef();
}

CTaskAllocator::~CTaskAllocator()
{
	m_pmalloc->Release();
}

/////////////////////////////////////////////////////////////////////////////

static int nCounter = 0;
static int nCountTo = 0;
static HICON hIcon = NULL;

BOOL CALLBACK EnumResNameProc(HANDLE hModule, LPCTSTR lpszType, LPTSTR lpszName, LONG lParam)
{
	if (nCounter++ == nCountTo)
	{
		hIcon = LoadIcon((HINSTANCE)hModule, lpszName);
		return(FALSE);
	}

	return(TRUE);
}

HICON GetIconFromExecutable(const CString &strIconExe, int nIconNum)
{
	nCounter = 0;
	nCountTo = nIconNum;
	hIcon = NULL;
	if (_access(strIconExe, 00) != 0)
		return((HICON)-1);
	HINSTANCE hModule = LoadLibraryEx(strIconExe, NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (hModule == NULL)
		return((HICON)NULL);
	EnumResourceNames(hModule, RT_GROUP_ICON, (ENUMRESNAMEPROC)EnumResNameProc, NULL);
	FreeLibrary(hModule);
	return(hIcon);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobtpl.h ===
// docobtpl.h : interface of the CDocObjectTemplate class
//

#ifndef __DOCOBTPL_H__
#define __DOCOBTPL_H__

class CPackage;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CDocObjectTemplate

class AFX_EXT_CLASS CDocObjectTemplate : public CPartTemplate
{
	DECLARE_DYNAMIC(CDocObjectTemplate)

public:
	CString m_strFilter;
	HICON m_hIcon;

public:
	CDocObjectTemplate(CPackage* pPackage, REFCLSID clsid,
		const CString &strDefaultExtension,
		const CString &strDescName, 
		const CString &strDocBaseName, HICON hIcon,
		CRuntimeClass *pDocRuntimeClass = NULL,
		CRuntimeClass *pViewRuntimeClass = NULL);

	virtual Confidence MatchDocType(const TCHAR* pszPathName,
					CDocument*& rpDocMatch);
	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
	virtual CDocument* OpenDocumentFile(const TCHAR* pszPathName,
		BOOL bMakeVisible = TRUE);

	// override to get alternative icon
	virtual HICON GetIcon() { 
		if(m_hIcon) return m_hIcon;
		else	// The HICON is null on Win95, so we use the default one...
			return CPartTemplate::GetIcon();
	};
	// override to specify tab type
	virtual FileNewTabType GetTabType() { return newother; };

protected:
	CRuntimeClass *m_pDocRuntimeClass;
	CRuntimeClass *m_pViewRuntimeClass;
};

/////////////////////////////////////////////////////////////////////////////
// CRegistryKeyEnum (generally useful thing)

class CRegistryKeyEnum
{
public:
	HKEY m_hkey;
	CString m_strKeyName;
	CString m_strDefaultExtension;
	CString m_strDescName;
	CString m_strDocNameBase;
	HICON m_hIcon;
private:
	HKEY m_hkeyRoot;
	ULONG m_ikey;
	CString m_strRequiredSubkey;
public:
	CRegistryKeyEnum(HKEY hkeyRoot, LPCTSTR szRequiredSubkey = NULL);
	CRegistryKeyEnum(CRegistryKeyEnum& r) { ASSERT(FALSE); }	// no copy ctor implemented
	~CRegistryKeyEnum();
	BOOL Next(LPCTSTR szType = NULL);
};

/////////////////////////////////////////////////////////////////////////////
// CTaskAllocator

class CTaskAllocator
{
public:
	IMalloc *m_pmalloc;

	CTaskAllocator();
	CTaskAllocator(CTaskAllocator &taskalloc);
	~CTaskAllocator();
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __DOCOBTPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\drptcoll.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	DRPTCOLL.CPP:
//
// Implementation of CMapPathToOb defined in PATHCOLL.H
//
//		This file is based on output from the AFX TEMPLDEF samples using 
//	the command line
//
// templdef "CList<CPath*,CPath*,0,0> CPathList" list.ctt temp.h temp.inl 
//		list_pt.cpp
// templdef "CList<CDir*,CDir*,0,0> CDirList" list.ctt temp.h temp.inl 
//		list_dr.cpp
// templdef "CMap<CPath,CPath& ,CObject*,CObject*,0,0> CMapPathToOb" map.ctt 
// 		temp.h temp.inl map_pto.cpp
// templdef "CMap<CDir,CDir&,CObject*,CObject*,0,0> CMapDirToOb" map.ctt 
//		temp.h temp.inl map_dto.cpp
//
//	However, the output has been modified for CMapPathToOb and CMapDirToOb
//	because the CPath and CDir objects used as keys must be constructed 
//	and destroyed.  Changes are to the functions:
//	
//			RemoveAll
//			NewAssoc
//			FreeAssoc
//
// 	Also HashKey has been changed, to hash the Path or Dir's string.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 22-May-93	danw		Created
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "path.h"

IMPLEMENT_DYNAMIC(CMapPathToOb, CObject)

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#ifndef _WIN32
#define MAX_PATH _MAX_PATH
#endif

/////////////////////////////////////////////////////////////////////////////

CMapPathToOb::CMapPathToOb(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapPathToOb::HashKey(CPath& key) const
{
	UINT nHash = 0;									//CHANGE FROM TEMPLATE
	char buf [MAX_PATH], *pc = buf;				    //CHANGE FROM TEMPLATE
	lstrcpy (buf,key);								//CHANGE FROM TEMPLATE
	AnsiUpper (buf);								//CHANGE FROM TEMPLATE
													//CHANGE FROM TEMPLATE
	while (*pc)										//CHANGE FROM TEMPLATE
		nHash = (nHash<<5) + nHash + *pc++;			//CHANGE FROM TEMPLATE
	return nHash;									//CHANGE FROM TEMPLATE
}


void CMapPathToOb::InitHashTable(UINT nHashSize)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	// if had a hash table - get rid of it
	if (m_pHashTable != NULL)
		delete [] m_pHashTable;
	m_pHashTable = NULL;

	m_pHashTable = new CAssoc* [nHashSize];
	memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	m_nHashTableSize = nHashSize;
}

void CMapPathToOb::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)				   //CHANGE FROM TEMPLATE
		{																	   //CHANGE FROM TEMPLATE
			CAssoc* pAssoc;													   //CHANGE FROM TEMPLATE
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;				   //CHANGE FROM TEMPLATE
			  pAssoc = pAssoc->pNext)										   //CHANGE FROM TEMPLATE
			{                                                                  //CHANGE FROM TEMPLATE
				DestructElement( &pAssoc->key) ;  // free up string data	   //CHANGE FROM TEMPLATE
																			   //CHANGE FROM TEMPLATE
			}																   //CHANGE FROM TEMPLATE
		}																	   //CHANGE FROM TEMPLATE

		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapPathToOb::~CMapPathToOb()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapPathToOb::CAssoc* CMapPathToOb::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapPathToOb::CAssoc));
		// chain them into free list
		CMapPathToOb::CAssoc* pAssoc = (CMapPathToOb::CAssoc*) newBlock->data();
		
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapPathToOb::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElement (&pAssoc->key);		   //CHANGE FROM TEMPLATE

	memset(&pAssoc->value, 0, sizeof(CObject*));

	return pAssoc;
}

void CMapPathToOb::FreeAssoc(CMapPathToOb::CAssoc* pAssoc)
{

	DestructElement (&pAssoc->key);			   //CHANGE FROM TEMPLATE
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow
}

CMapPathToOb::CAssoc*
CMapPathToOb::GetAssocAt(CPath& key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
			return pAssoc;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CMapPathToOb::Lookup(const CPath& key, CObject*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt((CPath&) key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

CObject*& CMapPathToOb::operator[](const CPath& key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt((CPath&)key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapPathToOb::RemoveKey(CPath& key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapPathToOb::GetNextAssoc(POSITION& rNextPosition,
	CPath& rKey, CObject*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

/////////////////////////////////////////////////////////////////////////////
// Serialization


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG

void CMapPathToOb::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

#define MAKESTRING(x) #x
	AFX_DUMP1(dc, "a " MAKESTRING(CMapPathToOb) " with ", m_nCount);
	AFX_DUMP0(dc, " elements");
#undef MAKESTRING
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		POSITION pos = GetStartPosition();
		CPath key;
		CObject* val;

		AFX_DUMP0(dc, "\n");
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			AFX_DUMP1(dc, "\n\t[", key);
			AFX_DUMP1(dc, "] = ", val);
		}
	}
}

void CMapPathToOb::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CMapDirToOb, CObject)
/////////////////////////////////////////////////////////////////////////////

CMapDirToOb::CMapDirToOb(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

inline UINT CMapDirToOb::HashKey(CDir& key) const
{
	UINT nHash = 0;									//CHANGE FROM TEMPLATE
	char buf [MAX_PATH], *pc = buf;				    //CHANGE FROM TEMPLATE
	strcpy (buf,key);								//CHANGE FROM TEMPLATE
	AnsiUpper (buf);								//CHANGE FROM TEMPLATE
													//CHANGE FROM TEMPLATE
	while (*pc)										//CHANGE FROM TEMPLATE
		nHash = (nHash<<5) + nHash + *pc++;			//CHANGE FROM TEMPLATE
	return nHash;									//CHANGE FROM TEMPLATE
}


void CMapDirToOb::InitHashTable(UINT nHashSize)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	// if had a hash table - get rid of it
	if (m_pHashTable != NULL)
		delete [] m_pHashTable;
	m_pHashTable = NULL;

	m_pHashTable = new CAssoc* [nHashSize];
	memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	m_nHashTableSize = nHashSize;
}

void CMapDirToOb::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)				   //CHANGE FROM TEMPLATE
		{																	   //CHANGE FROM TEMPLATE
			CAssoc* pAssoc;													   //CHANGE FROM TEMPLATE
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;				   //CHANGE FROM TEMPLATE
			  pAssoc = pAssoc->pNext)										   //CHANGE FROM TEMPLATE
			{                                                                  //CHANGE FROM TEMPLATE
				DestructElement( &pAssoc->key) ;  // free up string data	   //CHANGE FROM TEMPLATE
																			   //CHANGE FROM TEMPLATE
			}																   //CHANGE FROM TEMPLATE
		}																	   //CHANGE FROM TEMPLATE


		// free hash table
		delete [] m_pHashTable;
		m_pHashTable = NULL;
	}

	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CMapDirToOb::~CMapDirToOb()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// same as CList implementation except we store CAssoc's not CNode's
//    and CAssoc's are singly linked all the time

CMapDirToOb::CAssoc* CMapDirToOb::NewAssoc()
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMapDirToOb::CAssoc));
		// chain them into free list
		CMapDirToOb::CAssoc* pAssoc = (CMapDirToOb::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ASSERT(m_pFreeList != NULL);  // we must have something

	CMapDirToOb::CAssoc* pAssoc = m_pFreeList;
	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
	ConstructElement (&pAssoc->key);		   //CHANGE FROM TEMPLATE

	memset(&pAssoc->value, 0, sizeof(CObject*));

	return pAssoc;
}

void CMapDirToOb::FreeAssoc(CMapDirToOb::CAssoc* pAssoc)
{
	DestructElement (&pAssoc->key);			   //CHANGE FROM TEMPLATE
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow
}

CMapDirToOb::CAssoc*
CMapDirToOb::GetAssocAt(CDir& key, UINT& nHash) const
// find association (or return NULL)
{
	nHash = HashKey(key) % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
			return pAssoc;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CMapDirToOb::Lookup(const CDir& key, CObject*& rValue) const
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc = GetAssocAt((CDir&) key, nHash);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

CObject*& CMapDirToOb::operator[](const CDir& key)
{
	ASSERT_VALID(this);

	UINT nHash;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt((CDir&) key, nHash)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		// it doesn't exist, add a new Association
		pAssoc = NewAssoc();
		pAssoc->nHashValue = nHash;
		pAssoc->key = key;
		// 'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHash];
		m_pHashTable[nHash] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}


BOOL CMapDirToOb::RemoveKey(CDir& key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	CAssoc** ppAssocPrev;
	ppAssocPrev = &m_pHashTable[HashKey(key) % m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->key == key)
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

void CMapDirToOb::GetNextAssoc(POSITION& rNextPosition,
	CDir& rKey, CObject*& rValue) const
{
	ASSERT_VALID(this);
	ASSERT(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ASSERT(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
				break;
		ASSERT(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = pAssocRet->nHashValue + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

/////////////////////////////////////////////////////////////////////////////
// Serialization


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG

void CMapDirToOb::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

#define MAKESTRING(x) #x
	AFX_DUMP1(dc, "a " MAKESTRING(CMapDirToOb) " with ", m_nCount);
	AFX_DUMP0(dc, " elements");
#undef MAKESTRING
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		POSITION pos = GetStartPosition();
		CDir key;
		CObject* val;

		AFX_DUMP0(dc, "\n");
		while (pos != NULL)
		{
			GetNextAssoc(pos, key, val);
			AFX_DUMP1(dc, "\n\t[", key);
			AFX_DUMP1(dc, "] = ", val);
		}
	}
}

void CMapDirToOb::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CPathList, CObject)
/////////////////////////////////////////////////////////////////////////////

CPathList::CPathList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void CPathList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CPathList::~CPathList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CPathList::CNode*
CPathList::NewNode(CPathList::CNode* pPrev, CPathList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CPathList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	memset(&pNode->data, 0, sizeof(CPath*));  // zero fill

	return pNode;
}

void CPathList::FreeNode(CPathList::CNode* pNode)
{

	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow
}

/////////////////////////////////////////////////////////////////////////////

POSITION CPathList::AddHead(CPath* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

POSITION CPathList::AddTail(CPath* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

void CPathList::AddHead(CPathList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT(pNewList->IsKindOf(RUNTIME_CLASS(CPathList)));
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void CPathList::AddTail(CPathList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT(pNewList->IsKindOf(RUNTIME_CLASS(CPathList)));
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos)
		AddTail(pNewList->GetNext(pos));
}

CPath* CPathList::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	CPath* returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

CPath* CPathList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	CPath* returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION CPathList::InsertBefore(POSITION position, CPath* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

POSITION CPathList::InsertAfter(POSITION position, CPath* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

void CPathList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CPathList::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION CPathList::Find(CPath* searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
	{
		// need to compare paths, not just pointers
		if ((pNode->data == searchValue) || (*pNode->data == *searchValue))
			return (POSITION) pNode;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// Serialization


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CPathList::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

#define MAKESTRING(x) #x
	AFX_DUMP1(dc, "a " MAKESTRING(CPathList) " with ", m_nCount);
	AFX_DUMP0(dc, " elements");
#undef MAKESTRING
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		AFX_DUMP0(dc, "\n");

		while (pos != NULL)
			AFX_DUMP1(dc, "\n\t", GetNext(pos));
	}
}

void CPathList::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CDirList, CObject)
/////////////////////////////////////////////////////////////////////////////

CDirList::CDirList(int nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

void CDirList::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements


	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

CDirList::~CDirList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
/*
 * Implementation note: CNode's are stored in CPlex blocks and
 *  chained together. Free blocks are maintained in a singly linked list
 *  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
 *  Used blocks are maintained in a doubly linked list using both 'pNext'
 *  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
 *   as the head/tail.
 *
 * We never free a CPlex block unless the List is destroyed or RemoveAll()
 *  is used - so the total number of CPlex blocks may grow large depending
 *  on the maximum past size of the list.
 */

CDirList::CNode*
CDirList::NewNode(CDirList::CNode* pPrev, CDirList::CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ASSERT(m_pNodeFree != NULL);  // we must have something

	CDirList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow


	memset(&pNode->data, 0, sizeof(CDir*));  // zero fill

	return pNode;
}

void CDirList::FreeNode(CDirList::CNode* pNode)
{

	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow
}

/////////////////////////////////////////////////////////////////////////////

POSITION CDirList::AddHead(CDir* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

POSITION CDirList::AddTail(CDir* newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

void CDirList::AddHead(CDirList* pNewList)
{
	ASSERT_VALID(this);

	ASSERT(pNewList != NULL);
	ASSERT(pNewList->IsKindOf(RUNTIME_CLASS(CDirList)));
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

void CDirList::AddTail(CDirList* pNewList)
{
	ASSERT_VALID(this);
	ASSERT(pNewList != NULL);
	ASSERT(pNewList->IsKindOf(RUNTIME_CLASS(CDirList)));
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos)
		AddTail(pNewList->GetNext(pos));
}

CDir* CDirList::RemoveHead()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	CDir* returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

CDir* CDirList::RemoveTail()
{
	ASSERT_VALID(this);
	ASSERT(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	CDir* returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

POSITION CDirList::InsertBefore(POSITION position, CDir* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

POSITION CDirList::InsertAfter(POSITION position, CDir* newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

void CDirList::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}


/////////////////////////////////////////////////////////////////////////////
// slow operations

POSITION CDirList::FindIndex(int nIndex) const
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nCount)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

POSITION CDirList::Find(CDir* searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (pNode->data == searchValue)
			return (POSITION) pNode;
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// String helpers
BOOL CDirList::FromString(LPCTSTR lpszString, BOOL bCheckExist /*= FALSE*/)
{
	RemoveAll();
	ASSERT(lpszString != NULL);

	// Make a copy of our string to play with
	CString str = lpszString;

	// Find the first directory
	BOOL bRC = TRUE;
	LPTSTR lpsz = _tcstok(str.GetBuffer(1), _T(";"));
	while (lpsz != NULL)
	{
		// Create a new CDir
		CDir* pDir = new CDir;
		if (!pDir->CreateFromString(lpsz))
		{
			delete pDir;

			bRC = FALSE;
		}
		else
		{
			// Check for dups, and existance
			if (Find(pDir) == NULL && (!bCheckExist || pDir->ExistsOnDisk()))
				AddTail(pDir);
			else
				delete pDir;
		}

		// Find the next directory
		lpsz = _tcstok(NULL, _T(";"));
	}

	str.ReleaseBuffer(1);
	return bRC;
}

BOOL CDirList::ToString(CString& str)
{
	str.Empty();

	// FUTURE: Not sure which is faster...
#if 1
	// Calculate the final length of our path
	DWORD dwLen = 0;
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		CDir* pDir = GetNext(pos);
		ASSERT_VALID(pDir);

		dwLen += pDir->GetLength() + 1; // don't forget the semi-colon!
	}

	// Now create the actual string
	LPTSTR lpszStart = str.GetBufferSetLength(dwLen);
	LPTSTR lpsz = lpszStart;

	pos = GetHeadPosition();
	while (pos != NULL)
	{
		CDir* pDir = GetNext(pos);
		ASSERT_VALID(pDir);

		// For all except the first entry, prepend a semi-colon
		if (lpsz != lpszStart)
			*lpsz++ = _T(';');

		// Copy the directory name (plus null) into our output.
		lstrcpy(lpsz, (LPCTSTR)pDir);
		lpsz += pDir->GetLength();
	}

	// Tell CString we're done
	str.ReleaseBuffer(dwLen);
	return TRUE;
#else
	pos = GetHeadPosition();
	while (pos != NULL);
	{
		CDir* pDir = GetNext(pos);
		ASSERT_VALID(pDir);

		// For all except the first entry, prepend a semi-colon
		if (!str.IsEmpty())
			str += _T(';');

		// Copy the directory name into our output
		str += pDir;
	}

	return TRUE;
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Serialization


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

#ifdef _DEBUG
void CDirList::Dump(CDumpContext& dc) const
{
	ASSERT_VALID(this);

#define MAKESTRING(x) #x
	AFX_DUMP1(dc, "a " MAKESTRING(CDirList) " with ", m_nCount);
	AFX_DUMP0(dc, " elements");
#undef MAKESTRING
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		AFX_DUMP0(dc, "\n");

		while (pos != NULL)
			AFX_DUMP1(dc, "\n\t", GetNext(pos));
	}
}

void CDirList::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\envrvar.cpp ===
///////////////////////////////////////////
// 
// envrvar.cpp
//
// CEnvironmentVariableList class
// moved from projtool.cpp
///////////////////////////////////////////

#include "stdafx.h"

#pragma hdrstop

#define _SUSHI_PROJECT
#include "utilbld_.h"

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------- CEnvironmentVariableList ------------------------
//
///////////////////////////////////////////////////////////////////////////////
//#define ENVTEST

void CEnvironmentVariableList::AddVariable (
								const TCHAR *pName,
								const TCHAR *pValue
								)
{
	m_VariableNames.Add ( pName );
	m_VariableValues.Add (pValue );
}

#define INIT_BUF_SIZE 128
void CEnvironmentVariableList::SetVariables (BOOL bSaveOldValues  /*= TRUE*/ )
{
	m_bHoldingOld = bSaveOldValues;
	#ifdef ENVTEST
	{
		TCHAR *pc = (char *) GetEnvironmentStrings ();
		TRACE ("Dumping environment before CEnvironmentVariableList::SetVariables:\n");
		while (*pc != 0)
		{
			TRACE ("    %s\n", pc);
			pc += strlen (pc);
			pc++;
		}
	}
	#endif	
	
	int i, j = m_VariableValues.GetSize (), k;
	CString str;
	TCHAR *pc = str.GetBuffer ( INIT_BUF_SIZE );
							
	for (i=0; i<j; i++ )
	{
		if (bSaveOldValues)
		{
		 	k = GetEnvironmentVariable (
		 							(LPTSTR) (LPCSTR) m_VariableNames[i],
		 							pc,
		 							INIT_BUF_SIZE
		 							);
			if ( k > INIT_BUF_SIZE )
			{
				str.ReleaseBuffer ();
				pc = str.GetBuffer (k);
				GetEnvironmentVariable (
									(LPTSTR) (LPCSTR) m_VariableNames[i],
									pc,
									k
									);
			}
			else if (k==0) pc[0] = 0;
		}

		VERIFY (SetEnvironmentVariable (
						(LPTSTR) (LPCSTR) m_VariableNames[i],
						(LPTSTR) (LPCSTR) m_VariableValues[i]
						));	// No idea how this could fail.

		if (bSaveOldValues)	m_VariableValues[i] = pc;
	}

	#ifdef ENVTEST
	{
		TCHAR *pc = (char *) GetEnvironmentStrings ();
		TRACE ("Dumping environment after CEnvironmentVariableList::SetVariables:\n");
		while (*pc != 0)
		{
			TRACE ("    %s\n", pc);
			pc += strlen (pc);
			pc++;
		}
	}
	#endif	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\errcont.cpp ===
//
//	ERRCONT.CPP	
//
//
// History
// =======
// Date			Who			What
// ----			---			----
// 6-19-93		danwh		Created
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "main.h"
#include "utilbld_.h"
#include "msgboxes.h"

IMPLEMENT_DYNAMIC (CErrorContext, CObject)
IMPLEMENT_DYNAMIC (CStorageEC, CErrorContext)

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------- CErrorContext ------------------------------
//
///////////////////////////////////////////////////////////////////////////////
CErrorContext g_DummyEC;
///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CStorageEC -------------------------------
//
///////////////////////////////////////////////////////////////////////////////

void CStorageEC::AddString ( const TCHAR *pstr ) 
{
	m_StringList.AddTail (pstr); 	
}
void CStorageEC::AddString ( UINT ResID ) 
{
	CString str;
	if (str.LoadString (ResID)) m_StringList.AddTail (str);
	else TRACE ("CStorageEC::AddString failed to load string %i\n", ResID );
}

void CStorageEC::GetString ( CString &rstr ) 
{
	rstr.Empty ();
	POSITION pos;
	for (pos = m_StringList.GetHeadPosition (); pos != NULL; )
		rstr += m_StringList.GetNext (pos);
}

void CStorageEC::GetRevString ( CString &rstr ) 
{
	rstr.Empty ();
	POSITION pos;
	for (pos = m_StringList.GetTailPosition (); pos != NULL; )
		rstr += m_StringList.GetPrev (pos);
}

int CStorageEC::DoMessageBox ( 
	const MsgBoxTypes MsgBoxType, /*= Error 	 */
	UINT nButtonIDs, 	/* = DEFAULT_BUTTONS */
	UINT nHelpContext)  /* = DEFAULT_HELP	 */
{ 
	CString str;
	GetString (str);
	return MsgBox (MsgBoxType, str, nButtonIDs, nHelpContext);
}

void CStorageEC::Reset () 
{
	m_StringList.RemoveAll ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobvw.cpp ===
// docobvw.cpp : implementation of the CDocObjectView class
//

#include <stdafx.h>

#include <afxres.h>

#include "resource.h"
#include "docobtpl.h"
#include "docobctr.h"
#include "docobdoc.h"
#include "docobvw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDocObjectView

IMPLEMENT_DYNCREATE(CDocObjectView, CPartView)

BEGIN_MESSAGE_MAP(CDocObjectView, CPartView)
	//{{AFX_MSG_MAP(CDocObjectView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_FILE_PRINT, OnFilePrint)
	ON_COMMAND(ID_FILE_PAGE_SETUP, OnPageSetup)
	ON_UPDATE_COMMAND_UI(ID_FILE_PRINT, OnUpdatePrint)
	ON_UPDATE_COMMAND_UI(ID_FILE_PAGE_SETUP, OnUpdatePrint)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDocObjectView construction/destruction

CDocObjectView::CDocObjectView()
{
	m_pSelection = NULL;
	m_pOleCmdTarget = NULL;
}

CDocObjectView::~CDocObjectView()
{
	if(m_pOleCmdTarget != NULL)
		m_pOleCmdTarget->Release();
}

/////////////////////////////////////////////////////////////////////////////
// CDocObjectView drawing

void CDocObjectView::OnDraw(CDC* pDC)
{
	CDocObjectDoc *pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	// we don't draw anything ... the entire view window is owned by the server.
}

BOOL CDocObjectView::s_bInActivateView = FALSE;

void CDocObjectView::OnActivateView(BOOL bActivate, CView* pActivateView, 
	CView* pDeactiveView)
{
	if(!s_bInActivateView)
	{
		s_bInActivateView = TRUE; // This is to avoid deadly recursions
		CPartView::OnActivateView(bActivate, pActivateView, pDeactiveView);
		s_bInActivateView = FALSE;
	}
}

void CDocObjectView::OnInitialUpdate()
{
	// The document should contain exactly 1 OLE container item (otherwise the
	// doc shouldn't have been created successfully).  Get a pointer to the item.
	CDocObjectDoc *pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	POSITION position = pDoc->GetStartPosition();
	COleClientItem *pItemT = pDoc->GetNextClientItem(position);
	ASSERT(pItemT != NULL && pItemT->IsKindOf(RUNTIME_CLASS(CDocObjectContainerItem)) &&
		   pDoc->GetNextClientItem(position) == NULL);	// should be 1 and only 1 client item
	CDocObjectContainerItem *pItem = (CDocObjectContainerItem *)pItemT;

	if (pItem->GetOleDocument())
	{
		// The client item is a document object -- immediately tell it to 
		// activate and take over our view.
		// (If it isn't a document object, we display its inactive representation
		// until the user explicitly activates it.  This may not be able to happen
		// anyway, since we may not create a CDocObjectView unless the thing is
		// identifiable as a doc object ... however, who knows, it might refuse to
		// activate as a doc object for some reason.)
		pItem->Activate(OLEIVERB_SHOW, this);
	}

	if(pItem->m_lpObject != NULL)
	{
		pItem->m_lpObject->QueryInterface(IID_IOleCommandTarget, (void **)&m_pOleCmdTarget);
	}
	CPartView::OnInitialUpdate();	// see if the base class wants to do anything
}

/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CDocObjectView::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CDocObjectContainerItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item
	return pDocItem == m_pSelection;
}

void CDocObjectView::OnInsertObject()
{
	// this is not supported since it doesn't make sense.
	ASSERT(FALSE);
}

BOOL CDocObjectView::CanClose()
{
	CDocument *pDoc = GetDocument();
	ASSERT(pDoc != NULL);
	// We need to pass in NULL for pFrame, since we only want to check whether we can close 
	// the container item, but we don't want to prompt the user.
	if (pDoc != NULL)
		return(pDoc->CanCloseFrame(NULL));
	return(TRUE);
}

void CDocObjectView::OnUpdateTRUE(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(TRUE);
}

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
void CDocObjectView::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
void CDocObjectView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL && pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	CPartView::OnSetFocus(pOldWnd);
}

void CDocObjectView::OnSize(UINT nType, int cx, int cy)
{
	CPartView::OnSize(nType, cx, cy);

	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		ASSERT(pActiveItem->IsKindOf(RUNTIME_CLASS(CDocObjectContainerItem)));

		// Notify the doc object view of the size change.
		((CDocObjectContainerItem *)pActiveItem)->OnSizeChange();
	}
}

CDocObjectDoc *CDocObjectView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(COleDocument)));
	return((CDocObjectDoc *)m_pDocument);
}

void CDocObjectView::OnFilePrint()
{
	if(m_pOleCmdTarget != NULL)
	{
		m_pOleCmdTarget->Exec(	NULL, 
								OLECMDID_PRINT,			// Command ID
								OLECMDEXECOPT_PROMPTUSER,	// Exec Options
								NULL, NULL);	// Exec args
	}
}

void CDocObjectView::OnPageSetup()
{
	if(m_pOleCmdTarget != NULL)
	{
		m_pOleCmdTarget->Exec(	NULL, 
								OLECMDID_PAGESETUP,			// Command ID
								OLECMDEXECOPT_PROMPTUSER,	// Exec Options
								NULL, NULL);	// Exec args
	}
}

void CDocObjectView::OnUpdatePrint(CCmdUI* pCmdUI)
{
	if(m_pOleCmdTarget != NULL)
	{
		OLECMD rgcmds[2];

		rgcmds[0].cmdID = OLECMDID_PRINT;
		rgcmds[0].cmdf = 0;

		rgcmds[1].cmdID = OLECMDID_PAGESETUP;
		rgcmds[1].cmdf = 0;

		m_pOleCmdTarget->QueryStatus(NULL, 2, rgcmds, NULL);
		if(pCmdUI->m_nID == ID_FILE_PRINT)
			pCmdUI->Enable(rgcmds[0].cmdf & OLECMDF_ENABLED);
		else if(pCmdUI->m_nID == ID_FILE_PAGE_SETUP)
			pCmdUI->Enable(rgcmds[1].cmdf & OLECMDF_ENABLED);
	}
	else
		pCmdUI->Enable(FALSE);
}
/////////////////////////////////////////////////////////////////////////////
// CDocObjectView diagnostics

#ifdef _DEBUG
void CDocObjectView::AssertValid() const
{
	CPartView::AssertValid();
}

void CDocObjectView::Dump(CDumpContext& dc) const
{
	CPartView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\docobvw.h ===
// docobvw.h : interface of the CDocObjectView class
//

#ifndef __DOCOBVW_H__
#define __DOCOBVW_H__

class CDocObjectDoc;
class CDocObjectContainerItem;

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
// CDocObjectView

class AFX_EXT_CLASS CDocObjectView : public CPartView
{
	DECLARE_DYNCREATE(CDocObjectView)

protected:
	CDocObjectView();

public:
	CDocObjectDoc *GetDocument();
	// m_pSelection holds the selection to the current CDocobCntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CDocobCntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
	CDocObjectContainerItem* m_pSelection;

public:
	//{{AFX_VIRTUAL(CDocObjectView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
	//}}AFX_VIRTUAL

public:
	virtual ~CDocObjectView();
	virtual BOOL CanClose();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// The following variable is used to avoid recursing in ActivateView.
	static BOOL s_bInActivateView;

	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);

protected:
	afx_msg void CDocObjectView::OnUpdateTRUE(CCmdUI* pCmdUI);

// Generated message map functions
protected:
	//{{AFX_MSG(CDocObjectView)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	afx_msg void OnFileClose();
	afx_msg void OnFilePrint();
	afx_msg void OnPageSetup();
	afx_msg void OnUpdatePrint(CCmdUI* pCmdUI);
	//}}AFX_MSG

protected:
	IOleCommandTarget *m_pOleCmdTarget;

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __DOCOBVW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\fcdialog.cpp ===
// fcdialog.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include <wingdi.h>
#include "main.h"

#include "fcdialog.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CFontColorDlg dialog

IMPLEMENT_DYNAMIC (CFontColorDlg, CDlgTab)

#pragma warning (disable : 4355 )

CFontColorDlg::CFontColorDlg(CWnd* pParent /*=NULL*/)
	: CDlgTab(CFontColorDlg::IDD, IDS_FONTSANDCOLORS), m_state(this)
{
	m_idsSample = 0;
	m_nOrder = 120;

	//{{AFX_DATA_INIT(CFontColorDlg)
	//m_bProportional = FALSE;
	//}}AFX_DATA_INIT
}
#pragma warning (default: 4355 )


void CFontColorDlg::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFontColorDlg)
	DDX_Control(pDX, IDC_SAMPLE, m_stcSample);
	DDX_Control(pDX, IDC_LIST_WINDOWS, m_lstWindows);
	DDX_Control(pDX, IDC_COMBO_FONT_SIZE, m_cmbFontSize);
	DDX_Control(pDX, IDC_COMBO_FONT_NAME, m_cmbFontName);
	DDX_Control(pDX, IDC_LIST_ELEMENTS, m_lstElements);
	DDX_Control(pDX, IDC_COMBO_BACK_COLOR, m_cmbBackColor);
	DDX_Control(pDX, IDC_COMBO_FORE_COLOR, m_cmbForeColor);
	//DDX_Check(pDX, IDC_CHECK_PROPORTIONAL, m_bProportional);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFontColorDlg, CDlgTab)
	//{{AFX_MSG_MAP(CFontColorDlg)
	ON_CBN_SELCHANGE(IDC_LIST_WINDOWS, OnChangeWindow)
	ON_CBN_SELCHANGE(IDC_COMBO_FONT_NAME, OnChangeFont)
	ON_CBN_SELCHANGE(IDC_COMBO_FORE_COLOR, OnChangeForeColor)
	ON_CBN_SELCHANGE(IDC_COMBO_FONT_SIZE, OnChangeSize)
	ON_LBN_SELCHANGE(IDC_LIST_ELEMENTS, OnChangeElement)
	ON_CBN_SELCHANGE(IDC_COMBO_BACK_COLOR, OnChangeBackColor)
	ON_CBN_KILLFOCUS(IDC_COMBO_FONT_SIZE, OnKillFocusSize)
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_WM_SYSCOLORCHANGE()
	//ON_BN_CLICKED(IDC_CHECK_PROPORTIONAL, OnCheckProportional)
	ON_BN_CLICKED(IDC_BTN_DEFAULTS, OnRestoreDefaults)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


///// UpdateSampleFont - Redraw the sample font with current LOGFONT
//
///
void CFontColorDlg::UpdateSampleFont ()
{
	UINT idsSampleNew;

	m_SampleFont.DeleteObject();

	const LOGFONT * pLogFont = m_state.GetCurrentLogFont();
	if (!pLogFont) {
		pLogFont = GetStdLogfont (font_Fixed);
		idsSampleNew = IDS_MULTIPLE_FONTS;
		}
	else
	{
		switch (pLogFont->lfCharSet)
		{
			case TURKISH_CHARSET:
				idsSampleNew = IDS_SAMPLE_TURKISH;
				break;

			case HEBREW_CHARSET:
				idsSampleNew = IDS_SAMPLE_HEBREW;
				break;

			default:
				idsSampleNew = IDS_SAMPLE_LINE;
				break;
		}
	}

	if (m_idsSample != idsSampleNew)
	{
		m_idsSample = idsSampleNew;
		m_strSample.LoadString (m_idsSample);
	}

	m_SampleFont.CreateFontIndirect (pLogFont);

	CRect rect;

	m_stcSample.GetWindowRect (&rect);
	ScreenToClient (&rect);
	InvalidateRect (rect);
}


/////////////////////////////////////////////////////////////////////////////
// CFontColorDlg message handlers

BOOL CFontColorDlg::OnInitDialog() 
{
	CDlgTab::OnInitDialog();

	// Rank bogosity!  cmbFontName should get a MeasureItem call, but it doesn't.
	
	int nHeight = m_cmbFontSize.GetItemHeight(-1);
	if (nHeight != CB_ERR)
		m_cmbFontName.SetItemHeight (-1, nHeight);

	CDC * pDC = GetDC();
	m_nPixPerInchY = pDC->GetDeviceCaps(LOGPIXELSY);
	ReleaseDC (pDC);
	
	m_stcSample.GetWindowRect (&m_rcSample);
	ScreenToClient (&m_rcSample);

	m_cmbForeColor.SetStandardColors();
	m_cmbBackColor.SetStandardColors();

	m_state.InitDialog();	// Fill data dependent controls, notify handlers of change.

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


///// OnRestoreDefaults - Restore default colors and fonts
//
//	Restores the default fonts and color settings for the currently
//	selected window or window group.
//
///
void CFontColorDlg::OnRestoreDefaults ()
{
	m_state.RestoreDefaults();
}


///// OnChangeWindow - User selected a different Window
//
//	Change list of elements.  Propogate change to fonts, etc.
//
///
void CFontColorDlg::OnChangeWindow() 
{
	m_state.SetCurrentWindow (m_lstWindows.GetCurSel());
}


///// OnChangeFont - User or code has changed currently selected font name
//
//	When the font name changes, the list of available sizes must also change.
//
/// 
void CFontColorDlg::OnChangeFont() 
{
	RegenSizes (TRUE);
}


void CFontColorDlg::RegenSizes (BOOL bUpdateState)
{
CString strFaceName;
int	ptSize;
CDC * pDC = GetDC();
BOOL bTrueType = FALSE;

	ASSERT (pDC);

	if (m_cmbFontName.GetCurSel() == -1)
		return;

	m_cmbFontSize.EnableWindow (TRUE);

	// We assume that we wouldn't be here unless all windows in the
	// current set were using the same font.
	FMT_WINDOW * pWinCur = m_state.GetWinCur (FALSE, TRUE);

	// Pick up the new font name
	m_cmbFontName.GetLBText (m_cmbFontName.GetCurSel(), strFaceName);

	// Pick up the current font size
	//if (CB_ERR == (ptSize = m_cmbFontSize.GetSize()))
	ptSize = pWinCur -> nFontSize;

	// Blow off current size list, then regenerate it for the new font.
	m_cmbFontSize.ResetContent ();

	switch (EnumFontFamilies( pDC->m_hDC, strFaceName, (FONTENUMPROC)SizeCallBack , (LPARAM)this))
	{
		case TRUETYPE_FONTTYPE:
			m_cmbFontSize.SetStandardSizes();
			bTrueType = TRUE;
			break;

		case RASTER_FONTTYPE:
			break;

		default:
			ASSERT (FALSE);
	}

	// Update the dialog state
	if (bUpdateState)
		m_state.SetCurrentFont (strFaceName, ptSize, bTrueType);

	UpdateSampleFont();

	ReleaseDC (pDC);
}

///// SizeCallBack - EnumFontFamilies callback to fill size combo
//
///
int CALLBACK CFontColorDlg::SizeCallBack (
CONST ENUMLOGFONT * pEnumLogFont,
CONST NEWTEXTMETRIC *  pTextMetric,
int fontType,
LPARAM lParam
) {
CFontColorDlg * const pThis = (CFontColorDlg * const)lParam;

	ASSERT (pThis->IsKindOf (RUNTIME_CLASS (CFontColorDlg)));
	
	if (fontType & TRUETYPE_FONTTYPE) {
		return TRUETYPE_FONTTYPE;
		}
	else
	{
		UINT nCharSet = theApp.GetCharSet();
		if ((nCharSet == DEFAULT_CHARSET || nCharSet == pTextMetric->tmCharSet || pTextMetric->tmCharSet == OEM_CHARSET))
		{
			pThis->m_cmbFontSize.AddSize (MulDiv(pTextMetric->tmHeight - pTextMetric->tmInternalLeading,72,pThis->m_nPixPerInchY));
		}
		return RASTER_FONTTYPE;
	}
}


///// OnChangeForeColor - Foreground color has been changed
//
//	Propogates change to underlying data
///
void CFontColorDlg::OnChangeForeColor() 
{
	m_state.SetForeColor (m_cmbForeColor.GetItemData (m_cmbForeColor.GetCurSel()));
	UpdateSampleFont();
}


///// OnChangeBackColor - Background color has been changed
//
//	Propogates change to underlying data
///
void CFontColorDlg::OnChangeBackColor() 
{
	m_state.SetBackColor (m_cmbBackColor.GetItemData (m_cmbBackColor.GetCurSel()));
	UpdateSampleFont();
}


///// OnChangeSize - Font size has been changed
//
//	Propogates change to underlying data
///
void CFontColorDlg::OnChangeSize() 
{
CString strText;

	int cPointsNew = m_cmbFontSize.GetSize();

	//int cPointsNew = m_cmbFontSize.GetItemData ( m_cmbFontSize.GetCurSel() );
	m_state.SetCurrentFontSize (cPointsNew);
	m_cmbFontSize.SetPreferredSize (cPointsNew);
	UpdateSampleFont ();
}


///// OnKillFocusSize - User typed in a new size
//
///
void CFontColorDlg::OnKillFocusSize ()
{
CString strText;

	if (m_cmbFontSize.IsWindowEnabled())
	{
		int ptEditField = m_cmbFontSize.GetSize ();
		int ptCur = m_state.GetWinCur (FALSE, TRUE)->nFontSize;
		//int ptListBox = m_cmbFontSize.GetItemData ( m_cmbFontSize.GetCurSel() );

		if (ptEditField != ptCur)
		{
			m_cmbFontSize.SetPreferredSize (ptEditField);

			BOOL bTrueType = m_cmbFontName.GetItemData (m_cmbFontName.GetCurSel()) & TRUETYPE_FONTTYPE;
			m_cmbFontSize.SetToSize (ptEditField, !bTrueType);

			OnChangeSize ();
		}
	}
}


///// OnChangeElement - Current element has been changed
//
//	Propogates change to underlying data
///
void CFontColorDlg::OnChangeElement() 
{
	m_state.SetCurrentElement(m_lstElements.GetCurSel());

	UpdateSampleFont();
}


///// CommitTab - User has chosen 'OK', or has switched to another tab
//
//	Copy user changes back to the CFormatInfo belonging to the packages.
///
void CFontColorDlg::CommitTab()
{
	OnKillFocusSize ();
	m_state.Commit ();
}


///// OnPaint() - Handle painting of Sample Box
//
///
void CFontColorDlg::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	if (dc.SelectObject (&m_SampleFont))
	{

		dc.SetTextColor (m_state.GetForeColor ());
		dc.SetBkColor (m_state.GetBackColor ());
		dc.SetBkMode (TRANSPARENT);		// Fixes white background color.

		CSize extSample = dc.GetOutputTextExtent (m_strSample, m_strSample.GetLength());

		CPoint ptSample (	m_rcSample.left + (m_rcSample.right - m_rcSample.left) / 2 - extSample.cx / 2,
							m_rcSample.top + (m_rcSample.bottom - m_rcSample.top) / 2 - extSample.cy / 2);

		dc.ExtTextOut (ptSample.x, ptSample.y, ETO_CLIPPED, m_rcSample, m_strSample, m_strSample.GetLength(), NULL);
		// Do not call CDlgTab::OnPaint() for painting messages
	}
}


///// OnEraseBkgnd - Fills the sample box with selected background color
//
///
BOOL CFontColorDlg::OnEraseBkgnd(CDC * pDC)
{
CBrush brush;

	CDlgTab::OnEraseBkgnd (pDC);

	brush.CreateSolidBrush (m_state.GetBackColor ());

	pDC->FillRect (m_rcSample, &brush);

	return TRUE;
}


///// OnSysColorChange - The operating system's colors have been changed
//
//	Fixes up any system-auto colors to use the new system colors.
///
void CFontColorDlg::OnSysColorChange ()
{
	m_state.UpdateAllAutoColors ();

	UpdateSampleFont ();

}




/////////////////////////////////////////////////////////////////////////////
// CColorCombo
COLORREF		CColorCombo::m_rgStandardColors[16] =
{
	RGB (0, 0, 0),
	RGB (0xFF, 0xFF, 0xFF),
	RGB (0x80, 0, 0),
	RGB (0, 0x80, 0),
	RGB (0x80, 0x80, 0),
	RGB (0, 0, 0x80),
	RGB (0x80,0, 0x80),
	RGB (0, 0x80, 0x80),
	RGB (0xC0, 0xC0, 0xC0),
	RGB (0x80, 0x80, 0x80),
	RGB (0xFF, 0, 0),
	RGB (0, 0xFF, 0),
	RGB (0xFF, 0xFF, 0),
	RGB (0, 0, 0xFF),
	RGB (0xFF, 0, 0xFF),
	RGB (0, 0xFF, 0xFF)
};

#define AUTO_INDEX	(sizeof (m_rgStandardColors) / sizeof (m_rgStandardColors[0]))


///// m_brushSwatchFrame - Brush to paint rectangle around color swatches
//
///
CBrush CColorCombo::m_brushSwatchFrame;


///// Constructor
//
//	Create SwatchFrame brush as inverse of window background
//	Load "Automatic" string
///
CColorCombo::CColorCombo() 
{
	if (m_brushSwatchFrame.m_hObject == NULL)
		m_brushSwatchFrame.CreateSolidBrush (~GetSysColor (COLOR_WINDOW) & 0xFFFFFF);

	CString strAuto;
	VERIFY (strAuto.LoadString (IDS_AUTOMATIC));
	m_szAutomatic = new _TCHAR [strAuto.GetLength() + 1];
	_tcscpy (m_szAutomatic, strAuto);
}


///// Destructor
//
//	Blow away auto string and frame brush
///
CColorCombo::~CColorCombo()
{
	ASSERT (m_szAutomatic != NULL);
	delete [] m_szAutomatic;

	// Note that this deletes the brush whenever a CColorCombo is deleted,
	// which isn't the correct algorithm -- we need to keep a brush around
	// until they've ALL been deleted.  However, this works for the limited
	// cases we need right now.
	if (m_brushSwatchFrame.m_hObject != NULL)
	{
		m_brushSwatchFrame.DeleteObject ();
		ASSERT(m_brushSwatchFrame.m_hObject == NULL);
	}
}


///// AddColor - Adds an RGB value to end of list
//
///
int CColorCombo::AddColor ( COLORREF rgb )
{
	return AddString ((LPCSTR) rgb);
}


///// SetStandardColors - Add the "standard colors" to the combo box
//
///
void CColorCombo::SetStandardColors ()
{
	for (int i = 0; i < sizeof(m_rgStandardColors) / sizeof (m_rgStandardColors[0]); i++) {
		// FUTURE :  Isn't there a better way to do this?
		int ix = AddString ( (LPCTSTR) m_rgStandardColors[i]);
		if (ix != CB_ERR)
			SetItemData (ix, m_rgStandardColors[i]);
		}

	VERIFY (AUTO_INDEX == AddString ((LPCTSTR)CColorCombo::rgbAuto));
	VERIFY (0 <= SetItemData (AUTO_INDEX, CColorCombo::rgbAuto));
}


BEGIN_MESSAGE_MAP(CColorCombo, CComboBox)
	//{{AFX_MSG_MAP(CColorCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CColorCombo message handlers


///// DrawItem - draws color items whenever asked
//
///
void CColorCombo::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);

	DrawEntireItem (pDC, lpDrawItemStruct);

	if (lpDrawItemStruct->itemAction & ODA_SELECT)
		DrawSelectionChange (pDC, lpDrawItemStruct);

	if (lpDrawItemStruct->itemAction & ODA_FOCUS)
		DrawFocusChange (pDC, lpDrawItemStruct);
		
}


///// DrawEntireItem - Callback to draw individual color swatches
//
///
void CColorCombo::DrawEntireItem (
CDC * pDC,
LPDRAWITEMSTRUCT lpDrawItemStruct
) {
	if ((int)lpDrawItemStruct->itemID < 0)
		DrawFocusChange (pDC, lpDrawItemStruct);
	else {
		CRect rect (lpDrawItemStruct->rcItem);
		// We need to shrink the items a little to keep them from running
		// together
		rect.InflateRect ( -2, -2 );

		if ((int)lpDrawItemStruct->itemID == AUTO_INDEX) {
			// Center text
			CSize sizeAuto (pDC->GetTextExtent (m_szAutomatic, _tcslen (m_szAutomatic)));
			pDC->TextOut (rect.left + ((rect.Width() - sizeAuto.cx) / 2), rect.top, m_szAutomatic);
			}
		else {
			CBrush brushItem (lpDrawItemStruct->itemData);
			pDC->FillRect (rect, &brushItem);
			}
		// The frame is necessary to delineate the swatch that is the same as
		// the background color.
		pDC->FrameRect (rect, &m_brushSwatchFrame);
		}

}


///// DrawSelectionChange
//
///
void CColorCombo::DrawSelectionChange (
CDC * pDC,
LPDRAWITEMSTRUCT lpDrawItemStruct
) {
	CBrush brush (lpDrawItemStruct->itemState & ODS_SELECTED ? pDC->GetTextColor() : pDC->GetBkColor());

	pDC->FrameRect (&lpDrawItemStruct->rcItem, &brush);
}


///// DrawFocusChange
//
///
void CColorCombo::DrawFocusChange (
CDC * pDC,
LPDRAWITEMSTRUCT lpDrawItemStruct
) {
 	pDC->DrawFocusRect (&lpDrawItemStruct->rcItem);
}



/////////////////////////////////////////////////////////////////////////////
// CSizeCombo

///// m_rgTTSizes - Standard sizes
//
//	The list of sizes is taken from PSS note Q99672
//
///
DWORD	CSizeCombo::m_rgTTSizes[] =
{
	8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72
};


CSizeCombo::CSizeCombo()
{
}

CSizeCombo::~CSizeCombo()
{
	if (::IsWindow (m_hWnd))
		EnableWindow (FALSE);	// Bogosity to work around spurious KillFocus message
}


///// AddSize - Add a size, making sure it is unique and in order
//
///
int CSizeCombo::AddSize ( int cPoints )
{
int nInsert;
int cItems = GetCount();

	ASSERT (cPoints);

	for (nInsert = 0; nInsert < cItems; nInsert++) {
		DWORD itemData;
		VERIFY ((itemData = GetItemData (nInsert)) != CB_ERR);

		if (itemData == (DWORD)cPoints)
			return nInsert;
				
		if (itemData > (DWORD)cPoints)
			break;
		}

	_TCHAR buf[20];

	_itoa (cPoints, buf, 10);

	if (CB_ERR != InsertString (nInsert, buf))
	{
		SetItemData (nInsert, cPoints);
		return nInsert;
	}

	return -1;
}


///// SetStandardSizes - Add the list of standard font sizes
//
//	TrueType fonts can be scaled to any size.  To make things easier on the user, we
//	provide a standard set of sizes.
//
///
void CSizeCombo::SetStandardSizes ()
{
	for (int i = 0; i < sizeof(m_rgTTSizes) / sizeof (m_rgTTSizes[0]); i++)
		AddSize (m_rgTTSizes[i]);
}

 
///// GetSize - Return the point size at the given index
//
///
DWORD	CSizeCombo::GetSize ( int ixSize /* = -1 */ )
{
	if (ixSize == -1)	// Return current size
	{
		int iCurSel = GetCurSel ();
		if (iCurSel != CB_ERR)
			return GetItemData (iCurSel);
		else
		{
			CString strSize;
			GetWindowText (strSize);
			return atol (strSize);
		}
	}
	else
		return GetItemData (ixSize);
}


///// SetToSize - Set current selection to the given size
//
//	Sets the current size selection based on the user's preferred size,
//	the sizes available, and the passed-in new size.
//
//		1. Try to match the preferred size exactly.
//		2. If #1 fails:
//			bMatchClosest == True -> Match the new size as closely as possible (larger size wins).
//			bMatchClosest == False -> Match new size exactly, or add it to list.
//
//	Returns the index of the closest match.
//
//	NOTE: The resulting behaviour depends on SetPreferredSize() being called before this function
//	whenever appropriate.
///
int	CSizeCombo::SetToSize (int ptNewSize, BOOL bMatchClosest)
{
	int nItems = GetCount ();
	int iSelBestMatch;
	int dBestMatchDiff = 0x7FFF;

	if (!bMatchClosest)
	{
		if (ptNewSize < 6)
			ptNewSize = 6;
		else
		if (ptNewSize > 72)
			ptNewSize = 72;
	}

	for (int ptSearchSize = m_ptPreferredSize, cLoops = 0;
			cLoops < 2;
			ptSearchSize = ptNewSize, cLoops++ )
	{
		for (int iItem = 0; iItem < nItems; iItem++)
		{
			int dMatchDiff = GetItemData (iItem) - ptSearchSize;
			// If there are two sizes in the list that are the same distance from
			// the target size (i.e. one smaller and one larger), we want to
			// consistently pick one or the other.
			// The expression below picks the larger.
			if (dMatchDiff > 0
				? dMatchDiff <= dBestMatchDiff
				: abs(dMatchDiff) < dBestMatchDiff)
			{
				iSelBestMatch = iItem;
				dBestMatchDiff = abs(dMatchDiff);
				if (dBestMatchDiff == 0)
				{
					SetCurSel (iSelBestMatch);
					return iSelBestMatch;
				}
			}
		}
	}


	// No exact match
	if (bMatchClosest)
	{
		SetCurSel (iSelBestMatch);
		return iSelBestMatch;
	}
	else
	{
		return SetCurSel (AddSize (ptNewSize));
	}
}


BEGIN_MESSAGE_MAP(CSizeCombo, CComboBox)
	//{{AFX_MSG_MAP(CSizeCombo)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CSizeCombo message handlers


/////////////////////////////////////////////////////////////////////////////
// CFontNameCombo

IMPLEMENT_DYNAMIC (CFontNameCombo, CComboBox)

CFontNameCombo::CFontNameCombo()
{
}

CFontNameCombo::~CFontNameCombo()
{

	for (int i = 0; i < m_rgFontInfo.GetSize (); i++)
	{
		delete [] ((FontInfo *)m_rgFontInfo[i])->szName;
		delete m_rgFontInfo[i];
	}
}


///// AddEntry - Add font name string and associated data
//
///
void CFontNameCombo::AddEntry (
const CString& strName,
DWORD fontType
) {
	FontInfo * pFI = new FontInfo;
	pFI->szName = NewString (strName);
	pFI->dwFontType = fontType;

	m_rgFontInfo.Add (pFI);

	AddString ((LPCTSTR)pFI);
}

///// Enumerate and Callbacks - Get font list from system and fill combo
//
//	Enumerate works with the MainCallBack() to get the list of font face names.
//
///
void CFontNameCombo::Enumerate ( BOOL bProportional )
{
	CDC * pDC = GetDC();

	ASSERT (pDC);

	CString strFontName;
	int 	iCurSelFontName = GetCurSel();

	if (CB_ERR != iCurSelFontName)
		GetLBText (iCurSelFontName, strFontName);

	ResetContent();

	m_bProportional = FALSE;
	EnumFontFamilies ( pDC->m_hDC, NULL, (FONTENUMPROC)FillCallBack , (LPARAM)this );
	if (bProportional)
	{
		m_bProportional = TRUE;
		EnumFontFamilies ( pDC->m_hDC, NULL, (FONTENUMPROC)FillCallBack , (LPARAM)this );
	}

	// This code tries to maintain the same font name in the font name field
	// across a font enumeration.
	if (iCurSelFontName != CB_ERR)
		iCurSelFontName = FindStringExact (-1, strFontName);

	SetCurSel (iCurSelFontName == CB_ERR ? 0 : iCurSelFontName);

	ReleaseDC (pDC);
}

int CALLBACK CFontNameCombo::FillCallBack(
CONST ENUMLOGFONT	* pEnumLogFont,
CONST NEWTEXTMETRIC	* pTextMetric,
int fontType,
LPARAM lParam
) {
CFontNameCombo * const pThis = (CFontNameCombo * const)lParam;

	ASSERT (pThis->IsKindOf (RUNTIME_CLASS (CFontNameCombo)));

	UINT nCharSet = theApp.GetCharSet();
	if ((nCharSet == DEFAULT_CHARSET || nCharSet == ANSI_CHARSET || nCharSet == pTextMetric->tmCharSet || pTextMetric->tmCharSet == OEM_CHARSET) && pEnumLogFont->elfLogFont.lfFaceName[0] != '@')
	{
		// Note - The meaning of TMPF_FIXED_PITCH is the opposite of what the name implies.
		if (	((pTextMetric->tmPitchAndFamily & TMPF_FIXED_PITCH) && pThis->m_bProportional)
			||	(!(pTextMetric->tmPitchAndFamily & TMPF_FIXED_PITCH) && !pThis->m_bProportional) )
		{
			pThis->AddEntry (pEnumLogFont->elfLogFont.lfFaceName, MAKELONG(fontType, pEnumLogFont->elfLogFont.lfPitchAndFamily));
		}
	}

	return TRUE;
}

DWORD CFontNameCombo::GetItemData (int index) const
{
	ASSERT (index > -1 && index < m_rgFontInfo.GetSize ());

	// Initialize pFI to NULL so that it will crash in debug mode if it is not set.
	FontInfo * pFI = NULL;
	CComboBox::GetLBText (index, (char *)&pFI);

	return pFI->dwFontType;
}

int CFontNameCombo::GetLBText (int index, LPTSTR szText) const
{
	ASSERT (index > -1 && index < m_rgFontInfo.GetSize ());

	FontInfo * pFI = NULL;
	CComboBox::GetLBText (index, (char *)&pFI);

	_tcscpy (szText, pFI->szName);
	return _tcslen (szText);
}

void CFontNameCombo::GetLBText (int index, CString & strText) const
{
	ASSERT (index > -1 && index < m_rgFontInfo.GetSize ());

	FontInfo * pFI = NULL;
	CComboBox::GetLBText (index, (char *)&pFI);

	strText = pFI->szName;
}

int CFontNameCombo::FindStringExact (int index, LPCTSTR szFind) const
{
int cMac = m_rgFontInfo.GetSize();

	for (int i = 0; i < cMac; i++)
	{
		if (!_tcsicmp(((FontInfo *)m_rgFontInfo[i])->szName, szFind))
			return CComboBox::FindStringExact (index, (const char *)m_rgFontInfo[i]);
	}

	return CB_ERR;
}


BEGIN_MESSAGE_MAP(CFontNameCombo, CComboBox)
	//{{AFX_MSG_MAP(CFontNameCombo)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFontNameCombo message handlers


///// DrawItem - Draws font name, possibly including TrueType logo
//
///
void CFontNameCombo::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);

	
	if (lpDrawItemStruct->itemID != -1L &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) != 0)
	{
		CRect rect(lpDrawItemStruct->rcItem);
		CRect rectText (rect);
		COLORREF rgbText = 0x80000000;	// Value is a flag for "color was changed"
		COLORREF rgbBack;

		m_bmpTrueType.AdjustDrawRect (rectText);

		if (lpDrawItemStruct->itemState & ODS_SELECTED)
		{	// Show item as selected with standard hilite colors.
			rgbText = pDC->SetTextColor (GetSysColor(COLOR_HIGHLIGHTTEXT));
			rgbBack = pDC->SetBkColor (GetSysColor (COLOR_HIGHLIGHT));
		}

		// Draw font name, plus background for entire item.
		CFont * pFontPrev = NULL;
		CFont font;

		LOGFONT lf;

		ASSERT (::GetCurrentObject (pDC->m_hDC, OBJ_FONT));
		VERIFY (::GetObject (::GetCurrentObject (pDC->m_hDC, OBJ_FONT), sizeof lf, &lf));

		if (lf.lfWeight == FW_NORMAL)
			if (HIWORD (GetItemData (lpDrawItemStruct->itemID)) & FIXED_PITCH)
			{
				lf.lfWeight = FW_BOLD;
				VERIFY (font.CreateFontIndirect (&lf));
				VERIFY (pFontPrev = pDC->SelectObject (&font));
			}
			else
				;
		else
			if (HIWORD (GetItemData (lpDrawItemStruct->itemID)) & VARIABLE_PITCH)
			{
				lf.lfWeight = FW_NORMAL;
				VERIFY (font.CreateFontIndirect (&lf));
				VERIFY (pFontPrev = pDC->SelectObject (&font));
			}
			else
				;
		CString strItem;
		GetLBText (lpDrawItemStruct->itemID, strItem);
		pDC->ExtTextOut (rectText.left, rectText.top, ETO_CLIPPED|ETO_OPAQUE, rect, strItem, strItem.GetLength(), NULL);

		if (pFontPrev)
		{
			VERIFY (pDC->SelectObject (pFontPrev) == &font);
			font.DeleteObject ();
		}

		// Now it's safe to draw this.
		if (GetItemData (lpDrawItemStruct->itemID) & TRUETYPE_FONTTYPE)	
		{
			BOOL b = m_bmpTrueType.DrawImage (pDC, rect);

		}

		if (rgbText != 0x80000000)
		{
			 pDC->SetTextColor (rgbText);
			 pDC->SetBkColor (rgbBack);
		}
	}

}


///// CompareItem - Standard string compare
//
///
int CFontNameCombo::CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct) 
{
	FontInfo * pFI1 = (FontInfo *)lpCompareItemStruct->itemData1;
	FontInfo * pFI2 = (FontInfo *)lpCompareItemStruct->itemData2;

	WORD fontType1 = HIWORD(pFI1->dwFontType);
	WORD fontType2 = HIWORD(pFI2->dwFontType);

	// Fixed pitch fonts come before proportional pitch fonts
	//
	if ( (fontType1 & (VARIABLE_PITCH|FIXED_PITCH)) != (fontType2 & (VARIABLE_PITCH|FIXED_PITCH)) )
	{
		if (fontType1 & FIXED_PITCH)
			return -1;
		else
			return 1;
	}


	CString str1 (pFI1->szName);
	CString str2 (pFI2->szName);

	if (str1 < str2)
		return -1;
	else
		return str1 != str2;
}




/////////////////////////////////////////////////////////////////////////////
// CTTBitmap
//
//	Holds and draws the TrueType bitmap


///// Constructor
//
//	Loads bitmap resource and creates the mask.  The Mask allows the glyph
//	to be drawn transparently
///
CTTBitmap::CTTBitmap ()
{
	m_bValid =		LoadBitmap (IDB_BITMAP_TRUETYPE)
				&&	GetObject (sizeof(m_bmData), &m_bmData)
				&&	CreateMask ();
}

CTTBitmap::~CTTBitmap ()
{
}


///// CreateMask - Create foreground/background mask
//
//	Creates the monochrome bitmap used in DrawImage.
//
///
BOOL CTTBitmap::CreateMask ()
{
CDC		MaskDC;
CDC		BitmapDC;
BOOL	bReturn = FALSE;

	if (BitmapDC.CreateCompatibleDC (NULL) &&
		MaskDC.CreateCompatibleDC (NULL) &&
		m_bmpMask.CreateBitmap (m_bmData.bmWidth, m_bmData.bmHeight, 1, 1, NULL)) {

			//
			//	BitBlt() converts a color bitmap to monochrome by turning pixels of the current
			//	background color into white (1) and all others into black (0).  Since this is
			//	the inverse of the convention for the mask, we use NOTSRCCOPY.
			//
			//	However, Since MskBlt() is not implemented on Win95, we use the standard
			//	"True Mask Method" of drawing a bitmap with transparency.  This technique is
			//	described in "Bitmaps with Transparency" by Ron Gery - available on the MSDN CD.
			//	This technique uses 1 for background (transparent) and 0 for foreground.  So
			//	we use SRCCOPY.
			//
			(void)MaskDC.SelectObject (&m_bmpMask);
			(void)BitmapDC.SelectObject (this);
			(void)BitmapDC.SetBkColor(BitmapDC.GetPixel(0, 0));
			if (MaskDC.BitBlt (0, 0, m_bmData.bmWidth, m_bmData.bmHeight, &BitmapDC, 0, 0, SRCCOPY))
				bReturn = TRUE;
		}

	return bReturn;
}


/////	DrawImage - Draws the bitmap
//
//	pDC		-> Device Context to draw into
//	rect	-> Rectangle to draw into.  Image is drawn at 0,0, but is not stretched.
//
//	The image is drawn "transparently".  That is, background pixels in the bitmap take
//	on the background color of the destination.  The "background color" is the color of the
//	pixel in the upper left hand corner of the bitmap.
//
//	The technique used is to generate a monochrome bitmap mask of the same size and shape as
//	the original bitmap.  In the mask, a 1 indicates that the corresponding pixel in the
//	original bitmap is foreground, and a 0 indicates background.  The Win32 API MaskBlt()
//	uses such a mask to support a BitBlt using two raster ops - one for the foreground pixels,
//	one for the background.
///

#define TRANSBACK	0xAACC0000

BOOL CTTBitmap::DrawImage (CDC * pDC, CRect& rect)
{
	CDC dcBitmap;

	if (m_bValid && dcBitmap.CreateCompatibleDC (pDC)) {

		dcBitmap.SelectObject (this);

		// To achieve the same effect as as MaskBlt(), we make a copy of the bitmap into
		// yet another DC, then floodfill the background with the background color from
		// the target device.
		CDC dcMask;
		dcMask.CreateCompatibleDC (pDC);
		dcMask.SelectObject (&m_bmpMask);

		COLORREF rgbBackOld = pDC->SetBkColor (RGB(255, 255, 255));
		COLORREF rgbTextOld = pDC->SetTextColor (RGB(0,0,0));

		pDC->BitBlt (rect.left, rect.top, m_bmData.bmWidth, m_bmData.bmHeight, &dcBitmap, 0, 0, SRCINVERT);
		pDC->BitBlt (rect.left, rect.top, m_bmData.bmWidth, m_bmData.bmHeight, &dcMask, 0, 0, SRCAND);
		pDC->BitBlt (rect.left, rect.top, m_bmData.bmWidth, m_bmData.bmHeight, &dcBitmap, 0, 0, SRCINVERT);

		pDC->SetBkColor (rgbBackOld);
		pDC->SetTextColor (rgbTextOld);

		return TRUE;

		// Everything above starting with 'CDC dcAdjusted' is the workaround for the lack of
		// MaskBlt() in Win95.
		//return pDC->MaskBlt (rect.left, rect.top, m_bmData.bmWidth, m_bmData.bmHeight, &SrcDC, 0, 0, m_bmpMask, 0, 0, TRANSBACK);
		}

	return FALSE;
}
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWindowList

CWindowList::CWindowList()
{
}

CWindowList::~CWindowList()
{
}

void CWindowList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);

	if (lpDrawItemStruct->itemID != -1L &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) != 0)
	{
		// The items representing a collection of windows will be displayed in BOLD
		//
		CFont * pFontPrev = NULL;
		CFont font;
		COLORREF rgbText = 0x80000000;	// Value is a flag for "color was changed"
		COLORREF rgbBack;

		if (lpDrawItemStruct->itemState & ODS_SELECTED)
		{	// Show item as selected with standard hilite colors.
			rgbText = pDC->SetTextColor (GetSysColor(COLOR_HIGHLIGHTTEXT));
			rgbBack = pDC->SetBkColor (GetSysColor (COLOR_HIGHLIGHT));
		}

		LOGFONT lf;

		ASSERT (::GetCurrentObject (pDC->m_hDC, OBJ_FONT));
		VERIFY (::GetObject (::GetCurrentObject (pDC->m_hDC, OBJ_FONT), sizeof lf, &lf));

		CString strItem;
		BOOL bGroupName = m_pWinList->GetName (lpDrawItemStruct->itemID, strItem);

		if (lf.lfWeight == FW_NORMAL)
			if (bGroupName)
			{
				lf.lfWeight = FW_BOLD;
				VERIFY (font.CreateFontIndirect (&lf));
				VERIFY (pFontPrev = pDC->SelectObject (&font));
			}
			else
				;
		else
			if (!bGroupName)
			{
				lf.lfWeight = FW_NORMAL;
				VERIFY (font.CreateFontIndirect (&lf));
				VERIFY (pFontPrev = pDC->SelectObject (&font));
			}
			else
				;


		CRect rectText (lpDrawItemStruct->rcItem);
		pDC->ExtTextOut (rectText.left + 2, rectText.top, ETO_CLIPPED|ETO_OPAQUE, rectText, strItem, strItem.GetLength(), NULL);

		if (pFontPrev)
		{
			VERIFY (pDC->SelectObject (pFontPrev) == &font);
			font.DeleteObject ();
		}

		if (rgbText != 0x80000000)
		{
			 pDC->SetTextColor (rgbText);
			 pDC->SetBkColor (rgbBack);
		}
	}
}

BEGIN_MESSAGE_MAP(CWindowList, CListBox)
	//{{AFX_MSG_MAP(CWindowList)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWindowList message handlers
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\fcdialog.h ===
// fcdialog.h
//
// Headers necessary for the font and color dropdown controls used in
// the tabbed options pages.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __FCDIALOG_H__
#define __FCDIALOG_H__

/////////////////////////////////////////////////////////////////////////////
// CTTBitmap

class CTTBitmap : CBitmap
{
	BITMAP		m_bmData;
	CBitmap		m_bmpMask;
	BOOL		m_bValid;

public:
	CTTBitmap ();
	~CTTBitmap ();

	BOOL CreateMask ();

	BOOL DrawImage (CDC * pDC, CRect& rect);
	inline void AdjustDrawRect (CRect& rect);
};

///// AdjustDrawRect - Make room in a rect for the bitmap
//
//	The "rect" argument is assumed to be a place to draw a font name.  This function
//	adjusts the left side of that "rect" to make room for the TrueType bitmap.
///
inline void CTTBitmap::AdjustDrawRect (CRect& rect)
{
	rect.left += m_bmData.bmWidth;
}


/////////////////////////////////////////////////////////////////////////////
// CFontNameCombo

class CFontNameCombo : public CComboBox
{
DECLARE_DYNAMIC (CFontNameCombo)

	CTTBitmap		m_bmpTrueType;
	BOOL			m_bProportional;

	//
	struct FontInfo { 
		_TCHAR *	szName;
		DWORD		dwFontType;
		};

	CPtrArray		m_rgFontInfo;	// Necessary because Windows is retarded.

// Construction
public:
	CFontNameCombo();

// Attributes
public:
	DWORD GetItemData (int index) const;
	int GetLBText (int index, LPTSTR szText) const;
	void GetLBText (int index, CString & strText) const;
	int FindStringExact (int index, LPCTSTR szFind) const;

// Operations
private:
	static int CALLBACK FillCallBack(CONST ENUMLOGFONT *, CONST NEWTEXTMETRIC *, int, LPARAM);

public:
	void AddEntry (const CString& strName, DWORD fontType);
	void Enumerate (BOOL bProportional = TRUE);


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontNameCombo)
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFontNameCombo();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFontNameCombo)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CSizeCombo
//
//	Represents the Font Size combo box.  It maintains a list of unique point
//	sizes.

class CSizeCombo : public CComboBox
{
private:
	static DWORD	m_rgTTSizes[];

	int				m_ptPreferredSize;

// Construction
public:
	CSizeCombo();

// Attributes
public:

	int AddSize ( int cPoints );
	void SetStandardSizes ();

	DWORD	GetSize ( int ixSize = -1 );
	int		SetToSize (int nSize, BOOL bMatchClosest);

	inline void	SetPreferredSize (int cPoints);

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSizeCombo)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CSizeCombo();

	// Generated message map functions
protected:
	//{{AFX_MSG(CSizeCombo)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


///// SetPreferredSize - Sets the "center of gravity size"
//
//	The "preferred size" is the size the control will try to display, if possible.
//	The problem being solved is that switching around between fonts with different
//	available sizes tends to make the size drift in one direction or another.  For
//	example, if we start at size 11, then switch to a font with only 10 and 12, we now
//	display 12.  If we go back to the original font we will now being showing 12 instead
//	of 11, although to user didn't make the change.
//	The Preferred size should be set when the category changes (including init time), and
//	whenever the user changes the font size.
///
inline void	CSizeCombo::SetPreferredSize (int cPoints)
{
	m_ptPreferredSize = cPoints;
}


/////////////////////////////////////////////////////////////////////////////
// CColorCombo window
//
//	Displays a list of color swatches.  The elements are references by their
//	RGB values.

class CColorCombo : public CComboBox
{
private:
	static COLORREF		m_rgStandardColors[16];
	static CBrush		m_brushSwatchFrame;
	_TCHAR *			m_szAutomatic;

// Construction
public:
	 CColorCombo();

	int AddColor (COLORREF color);
	void SetStandardColors ();

	inline int SetCurColor (COLORREF rgb) { return SetCurSel (FindStringExact (-1, (LPCTSTR)rgb)); }
	inline COLORREF GetColor (int ix = -1) { return ix == -1 ? GetItemData(GetCurSel()) : GetItemData (ix); }

// Attributes
public:
	enum { rgbAuto = 0x80000000 };	// Represents the "Automatic" selection.	

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CColorCombo)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	//}}AFX_VIRTUAL

	void DrawSelectionChange (CDC * pDC, LPDRAWITEMSTRUCT lpDrawItemStruct);
	void DrawFocusChange (CDC * pDC, LPDRAWITEMSTRUCT lpDrawItemStruct);
	void DrawEntireItem (CDC * pDC, LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CColorCombo();

	// Generated message map functions
protected:
	//{{AFX_MSG(CColorCombo)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};



// CWindowList window
class CWinList;

class CWindowList : public CListBox
{
// Construction
public:
	CWindowList();

// Attributes
private:
	CWinList *		m_pWinList;

public:
	inline void SetWinList (CWinList * pWinList);


// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWindowList)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWindowList();

	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) ;

	// Generated message map functions
protected:
	//{{AFX_MSG(CWindowList)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


inline void CWindowList::SetWinList (CWinList * pWinList)
{
	m_pWinList = pWinList;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CFontColorDlg dialog

class CFontColorDlg : public CDlgTab
{
friend	CFCDialogState;
	
DECLARE_DYNAMIC (CFontColorDlg)

	CFCDialogState		m_state;

	CFont				m_SampleFont;
	CRect				m_rcSample;
	BOOL				m_bSampleIsTrueType;
	CString				m_strSample;
	UINT				m_idsSample;

	int					m_nPixPerInchY;

	static int CALLBACK SizeCallBack(CONST ENUMLOGFONT *, CONST NEWTEXTMETRIC *, int, LPARAM);

	void				RegenSizes (BOOL bUpdateState);

// Construction
public:
	CFontColorDlg(CWnd* pParent = NULL);   // standard constructor

	void UpdateSampleFont ();

// Dialog Data
	//{{AFX_DATA(CFontColorDlg)
	enum { IDD = IDD_OPTIONS_FONTCOLOR };
	CWindowList m_lstWindows;
	CStatic		m_stcSample;
	CSizeCombo	m_cmbFontSize;
	CFontNameCombo	m_cmbFontName;
	CListBox	m_lstElements;
	CColorCombo	m_cmbBackColor;
	CColorCombo	m_cmbForeColor;
	//BOOL	m_bProportional;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFontColorDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual void CommitTab();


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFontColorDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeWindow();
	afx_msg void OnChangeFont();
	afx_msg void OnChangeForeColor();
	afx_msg void OnChangeSize();
	afx_msg void OnChangeElement();
	afx_msg void OnChangeBackColor();
	afx_msg void OnKillFocusSize ();
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC * pDC);
	afx_msg void OnSysColorChange ();
	//afx_msg void OnCheckProportional();
	afx_msg void OnRestoreDefaults ();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif // __FCDIALOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\dualimpl.cpp ===
/////////////////////////////////////////////////////////////////////////////
// dualimpl.cpp

#include "stdafx.h"
#include <afxpriv.h>
#include <utilauto.h>
#include <ObjModel\appdefs.h>
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// This file implements the functions & classes
//  you need to create OLE Automation / dual interface objects that
//  expose functionality FROM Developer Studio packages TO macros
//  and addins.  The code in this file was taken from MFC and the
//  ACDUAL samples, with revisions made.  Functions revised
//  for use in Developer Studio are prefixed with "Ds"
// All declarations of these functions & classes are in
//  include\dualimpl.cpp.
// For examples of usage, see the sample package in
//  dev\ide\pkgs\pkg.  Check out auto*.*.
// For more info, see dualimpl.doc, checked in to the VBA subproject of
//  the V5Spec project.  There's a link to it on
//  http://devstudio/devstudio/automation.


// CONTENTS:
//  CAutoObj:
//		Derive your OLE Automation / dual interface objects from this.
//  CAutoWindowObj:
//		Derive your Window automation objects from this.
//  DsThrowOleDispatchException:
//		Use this instead of AfxThrowOleDispatchException for throwing
//		errors inside your dispatch handlers.
//  CMyOleDispatchImpl:
//		Used in CAutoObj.
//  CMiniOleDispatchDriver:
//		Used in firing dispatch events
//  FireDispatchEvent(V):
//		Functions that use CMiniOleDispatchDriver to fire the dispatch
//		events.  (Firing dual events is taken care of directly in the
//		the macros defined in dualimpl.h.)


////////////////////////////////////////////////////////////////////////
// CAutoObj

IMPLEMENT_DYNCREATE(CAutoObj, CCmdTarget)

CAutoObj::~CAutoObj()
{
	if (m_xDispatch.m_vtbl != 0)
	{
		ExternalDisconnect();
	}
	ASSERT(m_dwRef <= 1);
	m_pModuleState = NULL;

	// Set this to 0 so CCmdTarget's destructor doesn't try
	//  to call nonexistent Disconnect().
	m_xDispatch.m_vtbl = 0;

}

void CAutoObj::ThrowZombifiedException()
{
	DsThrowShellOleDispatchException(DS_E_SHUTDOWN_REQUESTED);
}

////////////////////////////////////////////////////////////////////////
// CAutoWindowObj

IMPLEMENT_DYNCREATE(CAutoWindowObj, CAutoObj)

// Events
/*BEGIN_CONNECTION_MAP(CAutoWindowObj, CAutoObj)
    CONNECTION_PART(CAutoWindowObj, IID_IWindowEvents, WindowCP)
    CONNECTION_PART(CAutoWindowObj, IID_IDispWindowEvents, DispWindowCP)
END_CONNECTION_MAP()*/

CAutoWindowObj::~CAutoWindowObj()
{
}

// RemoveChangeIndicatorFromWindowCaption returns whether " *" was stripped or not
BOOL CAutoWindowObj::RemoveChangeIndicatorFromWindowCaption(CString &strCaption)
{
	int nLength = strCaption.GetLength();

	if (nLength < 3) // if less than 3
		return FALSE; // obviously can't contain a 2-char change indicator!

	static CString strEnd; // to avoid needless construction/destruction overhead

	strEnd = strCaption.Right(2);
	if (strEnd != _T(" *"))
		return FALSE;

	// otherwise, we have a change indicator, so axe it & return TRUE

	strCaption = strCaption.Left(nLength - 2); // remove the trailing *
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DsDualHandleException

// This was taken from ACDUAL's DualHandleException, but was modified to use
//  the scode instead of the wCode in the exception structure.  This way,
//  the error return is NOT DIFFERENT for dispatch clients and dual vtbl
//  clients.  Note that the LINES sample will change to do things this way,
//  and the ACDUAL sample should be changed, too.

HRESULT DsDualHandleException(REFIID riidSource, const CException* pAnyException)
{
    USES_CONVERSION;

    ASSERT_VALID(pAnyException);

    TRACE0("DsDualHandleException called\n");

    // Set ErrInfo object so that VTLB binding container
    // applications can get rich error information.
    ICreateErrorInfo* pcerrinfo;
    HRESULT hr = CreateErrorInfo(&pcerrinfo);
    if (SUCCEEDED(hr))
    {
	    TCHAR   szDescription[256];
	    LPCTSTR pszDescription = szDescription;
        GUID    guid = GUID_NULL;
        DWORD   dwHelpContext = 0;
        BSTR    bstrHelpFile = NULL;
        BSTR    bstrSource = NULL;
	    if (pAnyException->IsKindOf(RUNTIME_CLASS(COleDispatchException)))
	    {
		    // specific IDispatch style exception
		    COleDispatchException* e = (COleDispatchException*)pAnyException;

            guid = riidSource;

			// If this ASSERT fires, perhaps you used AfxThrowOleDispatchException,
			//  instead of DsThrowOleDispatchException.
			ASSERT (e->m_scError != 0);

		    hr = e->m_scError;
		    pszDescription = e->m_strDescription;
		    dwHelpContext = e->m_dwHelpContext;

		    // propagate source and help file if present
            // call ::SysAllocString directly so no further exceptions are thrown
		    if (!e->m_strHelpFile.IsEmpty())
			    bstrHelpFile = ::SysAllocString(T2COLE(e->m_strHelpFile));
		    if (!e->m_strSource.IsEmpty())
			    bstrSource = ::SysAllocString(T2COLE(e->m_strSource));

	    }
	    else if (pAnyException->IsKindOf(RUNTIME_CLASS(CMemoryException)))
	    {
		    // failed memory allocation
		    AfxLoadString(AFX_IDP_FAILED_MEMORY_ALLOC, szDescription);
		    hr = E_OUTOFMEMORY;
	    }
	    else
	    {
		    // other unknown/uncommon error
		    AfxLoadString(AFX_IDP_INTERNAL_FAILURE, szDescription);
		    hr = E_UNEXPECTED;
	    }

	    if (bstrHelpFile == NULL && dwHelpContext != 0)
		    bstrHelpFile = ::SysAllocString(T2COLE(AfxGetApp()->m_pszHelpFilePath));

	    if (bstrSource == NULL)
		    bstrSource = ::SysAllocString(T2COLE(AfxGetAppName()));

        // Set up ErrInfo object
        pcerrinfo->SetGUID(guid);
	    pcerrinfo->SetDescription(::SysAllocString(T2COLE(pszDescription)));
        pcerrinfo->SetHelpContext(dwHelpContext);
        pcerrinfo->SetHelpFile(bstrHelpFile);
        pcerrinfo->SetSource(bstrSource);

        TRACE("\tSource = %ws\n", bstrSource);
        TRACE("\tDescription = %s\n", pszDescription);
        TRACE("\tHelpContext = %lx\n", dwHelpContext);
        TRACE("\tHelpFile = %ws\n", bstrHelpFile);

        // Set the ErrInfo object for the current thread
        IErrorInfo* perrinfo;
        if (SUCCEEDED(pcerrinfo->QueryInterface(IID_IErrorInfo, (LPVOID*)&perrinfo)))
        {
            SetErrorInfo(0, perrinfo);
            perrinfo->Release();
        }

        pcerrinfo->Release();
    }

    TRACE("DsDualHandleException returning HRESULT %lx\n", hr);
    
    return hr;
}

// This was stolen from MFC's AfxThrowOleDispatchException, but was modified
//  to accept an HRESULT instead of the wCode WORD.
void DsThrowOleDispatchException(HRESULT hr, UINT nDescriptionID, UINT nHelpID)
{
	TCHAR szBuffer[256];
	VERIFY(AfxLoadString(nDescriptionID, szBuffer) != 0);
	if (nHelpID == -1)
		nHelpID = nDescriptionID;

	DsThrowOleDispatchException(hr, szBuffer, nHelpID);
}

void DsThrowOleDispatchException(HRESULT hr, LPCTSTR szPrompt, UINT nHelpID)
{
	// Pass in 0 as the wCode, since we're using the scode field instead
	//  of the wCode, for consistency between the dual HRESULT return,
	//  and the dispatch exception error code.
	COleDispatchException* e = new COleDispatchException(szPrompt, nHelpID, 0);
	e->m_scError = hr;
	THROW(e);
}

// This variation of DsThrowOleDispatchException is for taking shell-defined
// HRESULT's & returning the shell's string

void DsThrowShellOleDispatchException(HRESULT hr, UINT nHelpID)
{
  // do an ugly but fast switch stmt to get string resource ID

  UINT uMsgID;

  switch (hr)
	{
		default:
			{
				ASSERT(FALSE); // you shouldn't have called this function with any other value, dummy!
				return;
			}
		case DS_E_SHUTDOWN_REQUESTED:
			{
				uMsgID = IDS_E_SHUTDOWN_REQUESTED;
				break;
			}
		case DS_E_UNKNOWN:
			{
				uMsgID = IDS_E_UNKNOWN;
				break;
			}

		case DS_E_BAD_PARAM_VALUE:
			{
				uMsgID = IDS_E_BAD_PARAM_VALUE;
				break;
			}

		case DS_E_DOC_RELEASED:
			{
				uMsgID = IDS_E_DOC_RELEASED;
				break;
			}

		case DS_E_WINDOW_RELEASED:
			{
				uMsgID = IDS_E_WINDOW_RELEASED;
				break;
			}
	
		case DS_E_CANNOTCREATENEWWINDOW:
			{
				uMsgID = IDS_E_CANNOTCREATENEWWINDOW;
				break ;
			}

		case DS_E_CANNOT_FIND_WINDOW:
			{
				uMsgID = IDS_E_CANNOT_FIND_WINDOW ;
				break ;
			}
		case DS_E_CANNOT_FIND_DOCUMENT:
			{
				uMsgID = IDS_E_CANNOT_FIND_DOCUMENT;
				break ;
			}

			
		//
		// CFileException File I/O Errors
		//
		case DS_E_FILENOTFOUND:
			{
				uMsgID = IDS_E_FILENOTFOUND ;
				break;
			}
		case DS_E_ENDOFFILE:
			{
				uMsgID = IDS_E_ENDOFFILE ;
				break;
			}
		case DS_E_BADPATH :			//All or part of the path is invalid.
			{
				uMsgID = IDS_E_BADPATH  ;
				break;
			}
		case DS_E_ACCESSDENIED :	//The file could not be accessed.
			{
				uMsgID = IDS_E_ACCESSDENIED ;
				break;
			}
		case DS_E_INVALIDFILE :		//There was an attempt to use an invalid file handle.
			{
				uMsgID = IDS_E_INVALIDFILE ;
				break;
			}
		case DS_E_DISKFULL :		//The disk is full.
			{
				uMsgID = IDS_E_DISKFULL ;
				break;
			}
		case DS_E_SHARINGVIOLATION:
			{
				uMsgID = IDS_E_SHARINGVIOLATION;
				break;
			}
		//
		// Other file errors
		// 
		case DS_E_READONLY:
			{
				uMsgID = IDS_E_READONLY ;
				break ;
			}
		case DS_E_NOFILENAME:
			{
				uMsgID = IDS_E_NOFILENAME ;
				break ;
			}

		//
		// See project.cpp in the bld system for these errors.
		// 
		case DS_E_PROJECT_OLD_MAKEFILE_VC:
			{
				uMsgID = IDS_E_PROJECT_OLD_MAKEFILE_VC ;
				break ;
			}
		case DS_E_PROJECT_OLD_MAKEFILE_DEVSTUDIO:
			{
				uMsgID = IDS_E_PROJECT_OLD_MAKEFILE_DEVSTUDIO;
				break ;
			}
		case DS_E_PROJECT_EXTERNAL_MAKEFILE:
			{
				uMsgID = IDS_E_PROJECT_EXTERNAL_MAKEFILE;
				break ;
			}
		case DS_E_PROJECT_FUTURE_FORMAT:
			{
				uMsgID = IDS_E_PROJECT_FUTURE_FORMAT;
				break ;
			}

	}

	// delegate to regular function
  DsThrowOleDispatchException(hr, uMsgID, nHelpID);
}


// This variation of DsThrowOleDispatchException is for taking system-defined
// HRESULT's & returning the system's string under the current locale

void DsThrowCannedOleDispatchException(HRESULT hr, UINT nHelpID)
{
  LPTSTR szBuffer;

	::FormatMessage( // get a canned system string
		FORMAT_MESSAGE_FROM_SYSTEM |   // go from HRESULT to string
		  FORMAT_MESSAGE_ALLOCATE_BUFFER,  // and allocate a buffer for me
		0, // we're not passing in a message, so this is ignored
		hr, // the HRESULT to decode
		LOCALE_USER_DEFAULT, // REVIEW(CFlaat): should we use the current user locale?
		reinterpret_cast<TCHAR*>(&szBuffer), // yes, this is right -- the system allocates memory for us
		1, // this is a minimum size for our buffer
		0); // irrelevant since we're not passing in a string

	// Pass in 0 as the wCode, since we're using the scode field instead
	//  of the wCode, for consistency between the dual HRESULT return,
	//  and the dispatch exception error code.
	COleDispatchException* e = new COleDispatchException(szBuffer, nHelpID, 0);
	e->m_scError = hr;

  VERIFY(!LocalFree(szBuffer)); // the ! will get optimized away

	THROW(e);
}



////////////////////////////////////////////////////////////////////////
// CMyOleDispatchImpl

// This was stolen & modified from MFC.  The change is that this version
//  of the class receives a pThis pointer on initialization rather than
//  constructing it.  It can't construct it, since this class no longer
//  lives at CCmdTarget::m_xDispatch--the implementation
//  of the dual interface lives there instead.
// Another change is the removal of the virtual Disconnect


STDMETHODIMP_(ULONG) CMyOleDispatchImpl::AddRef()
{
	return m_pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMyOleDispatchImpl::Release()
{
	return m_pThis->ExternalRelease();
}

STDMETHODIMP CMyOleDispatchImpl::QueryInterface(REFIID iid, LPVOID* ppvObj)
{
	return m_pThis->ExternalQueryInterface(&iid, ppvObj);
}

STDMETHODIMP CMyOleDispatchImpl::GetTypeInfoCount(UINT* pctinfo)
{
	*pctinfo = m_pThis->GetTypeInfoCount();
	return S_OK;
}

STDMETHODIMP CMyOleDispatchImpl::GetTypeInfo(UINT itinfo, LCID lcid,
	ITypeInfo** pptinfo)
{
	ASSERT_POINTER(pptinfo, LPTYPEINFO);

	if (itinfo != 0)
		return E_INVALIDARG;

	IID iid;
	if (!m_pThis->GetDispatchIID(&iid))
		return E_NOTIMPL;

	return m_pThis->GetTypeInfoOfGuid(lcid, iid, pptinfo);
}

STDMETHODIMP CMyOleDispatchImpl::GetIDsOfNames(
	REFIID riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ASSERT_POINTER(rgszNames, char*);
	ASSERT_POINTER(rgdispid, DISPID);

	USES_CONVERSION;

	// check arguments
	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	SCODE sc;
	LPTYPEINFO lpTypeInfo = NULL;
	if (lcid != 0 && SUCCEEDED(sc = GetTypeInfo(0, lcid, &lpTypeInfo)))
	{
		// For non-zero lcid, let typeinfo do the work (when available)
		ASSERT(lpTypeInfo != NULL);
		sc = lpTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		lpTypeInfo->Release();
		if (sc == TYPE_E_ELEMENTNOTFOUND)
			sc = DISP_E_UNKNOWNNAME;
	}
	else
	{
		// fill in the member name
		const AFX_DISPMAP* pDerivMap = m_pThis->GetDispatchMap();
		rgdispid[0] = m_pThis->MemberIDFromName(pDerivMap, OLE2CT(rgszNames[0]));
		if (rgdispid[0] == DISPID_UNKNOWN)
			sc = DISP_E_UNKNOWNNAME;
		else
			sc = S_OK;

		// argument names are always DISPID_UNKNOWN (for this implementation)
		for (UINT nIndex = 1; nIndex < cNames; nIndex++)
			rgdispid[nIndex] = DISPID_UNKNOWN;
	}

	return sc;
}

STDMETHODIMP CMyOleDispatchImpl::Invoke(
	DISPID dispid, REFIID riid, LCID lcid,
	WORD wFlags, DISPPARAMS* pDispParams, LPVARIANT pvarResult,
	LPEXCEPINFO pexcepinfo, UINT* puArgErr)
{
	ASSERT_NULL_OR_POINTER(pvarResult, VARIANT);
	ASSERT_NULL_OR_POINTER(pexcepinfo, EXCEPINFO);
	ASSERT_NULL_OR_POINTER(puArgErr, UINT);

	// make sure pvarResult is initialized
	if (pvarResult != NULL)
		AfxVariantInit(pvarResult);

	// check arguments
	if (riid != IID_NULL)
		return DISP_E_UNKNOWNINTERFACE;

	// allow subclass to disable Invoke
	if (!m_pThis->IsInvokeAllowed(dispid))
		return E_UNEXPECTED;

	SCODE sc = S_OK;
	const AFX_DISPMAP_ENTRY* pEntry;
	UINT uArgErr = (UINT)-1;    // no error yet
	VARIANT* pvarParamSave = NULL;
	if (theApp.m_pAutoApp == NULL || theApp.m_pAutoApp->IsZombified())
	{
		TRY
		{
			// allow CAutoObj's to disable Invoke w/ specific error message
			m_pThis->ThrowZombifiedException();
		}
		CATCH(COleDispatchException, e)
		{
			if (e->IsKindOf(RUNTIME_CLASS(COleDispatchException)))
			{
				AFX_MANAGE_STATE(m_pThis->m_pModuleState);
				if (pexcepinfo != NULL)
				{
					// fill exception with translation of MFC exception
					COleDispatchException::Process(pexcepinfo, e);
				}
				sc = DISP_E_EXCEPTION;
				goto Cleanup;
			}
		}
		AND_CATCH_ALL(e)
		{
			// Only supposed to throw an OLEDispatchException from ThrowZombifiedException
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		END_CATCH_ALL
	}

	// copy param block for safety
	DISPPARAMS params = *pDispParams;
	pDispParams = &params;

	// most of the time, named arguments are not supported
	if (pDispParams->cNamedArgs != 0)
	{
		// only special PROPERTYPUT named argument is allowed
		if (pDispParams->cNamedArgs != 1 ||
			pDispParams->rgdispidNamedArgs[0] != DISPID_PROPERTYPUT)
		{
			return DISP_E_NONAMEDARGS;
		}
	}

	// get entry for the member ID
	pEntry = m_pThis->GetDispEntry(dispid);
	if (pEntry == NULL)
		return DISP_E_MEMBERNOTFOUND;

	// treat member calls on properties just like property get/set
	if ((wFlags == DISPATCH_METHOD) &&
		((pEntry->pfn == NULL && pEntry->pfnSet == NULL) ||
		 (pEntry->pfn == NULL && pEntry->pfnSet != NULL) ||
		 (pEntry->pfn != NULL && pEntry->pfnSet != NULL)))
	{
		// the entry describes a property but a method call is being
		//  attempted -- change it to a property get/set based on the
		//  number of parameters being passed.
		wFlags &= ~DISPATCH_METHOD;
		UINT nExpectedArgs = pEntry->lpszParams != NULL ?
			(UINT)lstrlenA(pEntry->lpszParams) : 0;
		if (pDispParams->cArgs <= nExpectedArgs)
		{
			// no extra param -- so treat as property get
			wFlags |= DISPATCH_PROPERTYGET;
		}
		else
		{
			// extra params -- treat as property set
			wFlags |= DISPATCH_PROPERTYPUTREF;
			pDispParams->cNamedArgs = 1;
		}
	}

	// property puts should not require a return value
	if (wFlags & (DISPATCH_PROPERTYPUTREF|DISPATCH_PROPERTYPUT))
	{
		pvarResult = NULL;
		// catch attempt to do property set on method
		if (pEntry->pfn != NULL && pEntry->pfnSet == NULL)
			return DISP_E_TYPEMISMATCH;
	}



	// handle special cases of DISPATCH_PROPERTYPUT
	VARIANT vaParamSave;
	DISPPARAMS paramsTemp;
	VARIANT vaTemp;
	AfxVariantInit(&vaTemp);

	if (wFlags == DISPATCH_PROPERTYPUT && dispid != DISPID_VALUE)
	{
		// with PROPERTYPUT (no REF), the right hand side may need fixup
		if (pDispParams->rgvarg[0].vt == VT_DISPATCH &&
			pDispParams->rgvarg[0].pdispVal != NULL)
		{
			// remember old value for restore later
			pvarParamSave = &pDispParams->rgvarg[0];
			vaParamSave = pDispParams->rgvarg[0];
			AfxVariantInit(&pDispParams->rgvarg[0]);

			// get default value of right hand side
			memset(&paramsTemp, 0, sizeof(DISPPARAMS));
			sc = vaParamSave.pdispVal->Invoke(
				DISPID_VALUE, riid, lcid, DISPATCH_PROPERTYGET, &paramsTemp,
				&pDispParams->rgvarg[0], pexcepinfo, puArgErr);
		}

		// special handling for PROPERTYPUT (no REF), left hand side
		if (sc == S_OK && pEntry->vt == VT_DISPATCH)
		{
			memset(&paramsTemp, 0, sizeof(DISPPARAMS));

			// parameters are distributed depending on what the Get expects
			if (pEntry->lpszParams == NULL)
			{
				// paramsTemp is already setup for no parameters
				sc = Invoke(dispid, riid, lcid,
					DISPATCH_PROPERTYGET|DISPATCH_METHOD, &paramsTemp,
					&vaTemp, pexcepinfo, puArgErr);
				if (sc == S_OK &&
					(vaTemp.vt != VT_DISPATCH || vaTemp.pdispVal == NULL))
					sc = DISP_E_TYPEMISMATCH;
				else if (sc == S_OK)
				{
					ASSERT(vaTemp.vt == VT_DISPATCH && vaTemp.pdispVal != NULL);
					// we have the result, now call put on the default property
					sc = vaTemp.pdispVal->Invoke(
						DISPID_VALUE, riid, lcid, wFlags, pDispParams,
						pvarResult, pexcepinfo, puArgErr);
				}
			}
			else
			{
				// pass all but named params
				paramsTemp.rgvarg = &pDispParams->rgvarg[1];
				paramsTemp.cArgs = pDispParams->cArgs - 1;
				sc = Invoke(dispid, riid, lcid,
					DISPATCH_PROPERTYGET|DISPATCH_METHOD, &paramsTemp,
					&vaTemp, pexcepinfo, puArgErr);
				if (sc == S_OK &&
					(vaTemp.vt != VT_DISPATCH || vaTemp.pdispVal == NULL))
					sc = DISP_E_TYPEMISMATCH;
				else if (sc == S_OK)
				{
					ASSERT(vaTemp.vt == VT_DISPATCH && vaTemp.pdispVal != NULL);

					// we have the result, now call put on the default property
					paramsTemp = *pDispParams;
					paramsTemp.cArgs = paramsTemp.cNamedArgs;
					sc = vaTemp.pdispVal->Invoke(
						DISPID_VALUE, riid, lcid, wFlags, &paramsTemp,
						pvarResult, pexcepinfo, puArgErr);
				}
			}
			VariantClear(&vaTemp);

			if (sc != DISP_E_MEMBERNOTFOUND)
				goto Cleanup;
		}

		if (sc != S_OK && sc != DISP_E_MEMBERNOTFOUND)
			goto Cleanup;
	}

	// ignore DISP_E_MEMBERNOTFOUND from above
	ASSERT(sc == DISP_E_MEMBERNOTFOUND || sc == S_OK);

	// undo implied default value on right hand side on error
	if (sc != S_OK && pvarParamSave != NULL)
	{
		// default value stuff failed -- so try without default value
		pvarParamSave = NULL;
		VariantClear(&pDispParams->rgvarg[0]);
		pDispParams->rgvarg[0] = vaParamSave;
	}
	sc = S_OK;

	// check arguments against this entry
	UINT nOrigArgs; nOrigArgs = pDispParams->cArgs;
	if (wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD))
	{
		if (!(wFlags & DISPATCH_METHOD))
		{
			if (pEntry->vt == VT_EMPTY)
				return DISP_E_BADPARAMCOUNT;
			if (pvarResult == NULL)
				return DISP_E_PARAMNOTOPTIONAL;
		}
		if (pEntry->lpszParams == NULL && pDispParams->cArgs > 0)
		{
			if (pEntry->vt != VT_DISPATCH)
				return DISP_E_BADPARAMCOUNT;

			// it is VT_DISPATCH property/method but too many arguments supplied
			// transfer those arguments to the default property of the return value
			// after getting the return value from this call.  This is referred
			// to as collection lookup.
			pDispParams->cArgs = 0;
			if (pvarResult == NULL)
				pvarResult = &vaTemp;
		}
	}

	// make sure that parameters are not passed to a simple property
	if (pDispParams->cArgs > 1 &&
		(wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF)) &&
		pEntry->pfn == NULL)
	{
		sc = DISP_E_BADPARAMCOUNT;
		goto Cleanup;
	}

	// make sure that pvarResult is set for simple property get
	if (pEntry->pfn == NULL && pDispParams->cArgs == 0 && pvarResult == NULL)
	{
		sc = DISP_E_PARAMNOTOPTIONAL;
		goto Cleanup;
	}

	// make sure IsExpectingResult returns FALSE as appropriate
	BOOL bResultExpected;
	bResultExpected = m_pThis->m_bResultExpected;
	m_pThis->m_bResultExpected = pvarResult != NULL;

	TRY
	{
		if (pEntry->pfn == NULL)
		{
			// do standard property get/set
			if (pDispParams->cArgs == 0)
				m_pThis->GetStandardProp(pEntry, pvarResult, &uArgErr);
			else
				sc = m_pThis->SetStandardProp(pEntry, pDispParams, &uArgErr);
		}
		else
		{
			// do standard method call
			sc = m_pThis->CallMemberFunc(pEntry, wFlags,
				pvarResult, pDispParams, &uArgErr);
		}
	}
	CATCH(COleException, e)
	{
		sc = e->m_sc;
	}
	AND_CATCH_ALL(e)
	{
		AFX_MANAGE_STATE(m_pThis->m_pModuleState);
		if (pexcepinfo != NULL)
		{
			// fill exception with translation of MFC exception
			COleDispatchException::Process(pexcepinfo, e);
		}
		sc = DISP_E_EXCEPTION;
	}
	END_CATCH_ALL

	// restore original m_bResultExpected flag
	m_pThis->m_bResultExpected = bResultExpected;

	// handle special DISPATCH_PROPERTYGET collection lookup case
	if (sc == S_OK && nOrigArgs > pDispParams->cArgs)
	{
		ASSERT(wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD));
		ASSERT(pvarResult != NULL);
		// must be non-NULL dispatch, otherwise type mismatch
		if (pvarResult->vt != VT_DISPATCH || pvarResult->pdispVal == NULL)
		{
			sc = DISP_E_TYPEMISMATCH;
			goto Cleanup;
		}
		// otherwise, valid VT_DISPATCH was returned
		pDispParams->cArgs = nOrigArgs;
		LPDISPATCH lpTemp = pvarResult->pdispVal;
		if (pvarResult != &vaTemp)
			AfxVariantInit(pvarResult);
		else
			pvarResult = NULL;
		sc = lpTemp->Invoke(DISPID_VALUE, riid, lcid, wFlags,
			pDispParams, pvarResult, pexcepinfo, puArgErr);
		lpTemp->Release();
	}

Cleanup:
	// restore any arguments which were modified
	if (pvarParamSave != NULL)
	{
		VariantClear(&pDispParams->rgvarg[0]);
		pDispParams->rgvarg[0] = vaParamSave;
	}

	// fill error argument if one is available
	if (sc != S_OK && puArgErr != NULL && uArgErr != -1)
		*puArgErr = uArgErr;

	return sc;
}


////////////////////////////////////////////////////////////////////////
// EVENTS, EVENTS, EVENTS!!

// Stolen from MFC's oledisp2.cpp
#if defined(_68K_) || defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif


////////////////////////////////////////////////////////////////////////
// CMiniOleDispatchDriver - toned-down COleDispatchDriver, without the
//  code to convert arguments or deal with disp return values.  Suited
//  for firing potentially cancelable dispatch events.
// We can't reuse MFC's COleDispatchDriver, because it expects MFC type
//  args that it will translate (e.g., LPCTSTR instead of BSTR, or
//  BOOL instead of Boolean).  However, when firing an event to a
//  dual interface sink, it expects some real dispatch types, not these
//  girly-man MFC types.  In order to make firing events possible by
//  calling a single macro which takes only one version of these types,
//  we re-create the COleDispatchDriver to accept the actual dispatch
//  types.
// As a bonus, since we're redo-ing the COleDispatchDriver, we can make
//  its InvokeHelper return whether the event was canceled.  That way,
//  the macros will know to stop calling the sinks as soon as one
//  cancels the event.
// Changes made just for DevStudio are noted in "// DS:" comments

class CMiniOleDispatchDriver
{
// Constructors
public:
	CMiniOleDispatchDriver();

// Attributes
	LPDISPATCH m_lpDispatch;
	BOOL m_bAutoRelease;

// Operations

	void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
	void ReleaseDispatch();
	LPDISPATCH DetachDispatch();

	// returns whether the event was canceled
	BOOL InvokeHelperV(DISPID dwDispID, WORD wFlags,
		const BYTE* pbParamInfo, va_list argList);
};

CMiniOleDispatchDriver::CMiniOleDispatchDriver()
{
	m_lpDispatch = NULL;
	m_bAutoRelease = TRUE;
}

void CMiniOleDispatchDriver::AttachDispatch(LPDISPATCH lpDispatch,
	BOOL bAutoRelease)
{
	ASSERT(lpDispatch != NULL);

	ReleaseDispatch();  // detach previous
	m_lpDispatch = lpDispatch;
	m_bAutoRelease = bAutoRelease;
}

void CMiniOleDispatchDriver::ReleaseDispatch()
{
	if (m_lpDispatch != NULL)
	{
		if (m_bAutoRelease)
			m_lpDispatch->Release();
		m_lpDispatch = NULL;
	}
}

LPDISPATCH CMiniOleDispatchDriver::DetachDispatch()
{
	LPDISPATCH lpDispatch = m_lpDispatch;
	m_lpDispatch = NULL;    // detach without Release
	return lpDispatch;
}

BOOL CMiniOleDispatchDriver::InvokeHelperV(DISPID dwDispID, WORD wFlags,
	const BYTE* pbParamInfo, va_list argList)
{
	USES_CONVERSION;
	VARIANT_BOOL* pBool = NULL;		// DS: Remembers last BOOL* we came across

	if (m_lpDispatch == NULL)
	{
		TRACE0("Warning: attempt to call Invoke with NULL m_lpDispatch!\n");
		return FALSE;
	}

	DISPPARAMS dispparams;
	memset(&dispparams, 0, sizeof dispparams);

	// determine number of arguments
	if (pbParamInfo != NULL)
		dispparams.cArgs = lstrlenA((LPCSTR)pbParamInfo);

	DISPID dispidNamed = DISPID_PROPERTYPUT;
	if (wFlags & (DISPATCH_PROPERTYPUT|DISPATCH_PROPERTYPUTREF))
	{
		ASSERT(dispparams.cArgs > 0);
		dispparams.cNamedArgs = 1;
		dispparams.rgdispidNamedArgs = &dispidNamed;
	}

	if (dispparams.cArgs != 0)
	{
		// allocate memory for all VARIANT parameters
		VARIANT* pArg = new VARIANT[dispparams.cArgs];
		ASSERT(pArg != NULL);   // should have thrown exception
		dispparams.rgvarg = pArg;
		memset(pArg, 0, sizeof(VARIANT) * dispparams.cArgs);

		// get ready to walk vararg list
		const BYTE* pb = pbParamInfo;
		pArg += dispparams.cArgs - 1;   // params go in opposite order

		while (*pb != 0)
		{
			// DS: Last param wasn't the last bool we found
			//  (since there's another param we're about to
			//  investigate).  So reset the bool pointer.
			pBool = NULL;		
			ASSERT(pArg >= dispparams.rgvarg);

			pArg->vt = *pb; // set the variant type
			if (pArg->vt & VT_MFCBYREF)
			{
				pArg->vt &= ~VT_MFCBYREF;
				pArg->vt |= VT_BYREF;
			}
			switch (pArg->vt)
			{
			case VT_I2:
#ifdef _MAC
				pArg->iVal = (short)va_arg(argList, int);
#else
				pArg->iVal = va_arg(argList, short);
#endif
				break;
			case VT_I4:
				pArg->lVal = va_arg(argList, long);
				break;
			case VT_R4:
				// Note: All float arguments to vararg functions are passed
				//  as doubles instead.  Thats why they are passed as VT_R8
				//  instead of VT_R4.
				pArg->vt = VT_R8;
				*(DOUBLE_ARG*)&pArg->dblVal = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_R8:
				*(DOUBLE_ARG*)&pArg->dblVal = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_DATE:
				*(DOUBLE_ARG*)&pArg->date = va_arg(argList, DOUBLE_ARG);
				break;
			case VT_CY:
				pArg->cyVal = *va_arg(argList, CY*);
				break;
#if !defined(_UNICODE) && !defined(OLE2ANSI)
			case VT_BSTRA:
				// DS: Unlike MFC, we'll never expect an ANSI string, so fix up
				//  the vt field to be a normal VT_BSTR
				pArg->vt = VT_BSTR;
				// Fall through to VT_BSTR case...
#endif
			case VT_BSTR:
				// DS: Unlike MFC, we already expect a BSTR, so no copying.
				pArg->bstrVal = va_arg(argList, BSTR);
				break;
			case VT_DISPATCH:
				pArg->pdispVal = va_arg(argList, LPDISPATCH);
				break;
			case VT_ERROR:
				pArg->scode = va_arg(argList, SCODE);
				break;
			case VT_BOOL:
				// DS: Unlike MFC, we already expect a VARIANT_BOOL, not BOOL
				V_BOOL(pArg) = va_arg(argList, VARIANT_BOOL);
				break;
			case VT_VARIANT:
				*pArg = *va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN:
				pArg->punkVal = va_arg(argList, LPUNKNOWN);
				break;

			case VT_I2|VT_BYREF:
				pArg->piVal = va_arg(argList, short*);
				break;
			case VT_I4|VT_BYREF:
				pArg->plVal = va_arg(argList, long*);
				break;
			case VT_R4|VT_BYREF:
				pArg->pfltVal = va_arg(argList, float*);
				break;
			case VT_R8|VT_BYREF:
				pArg->pdblVal = va_arg(argList, double*);
				break;
			case VT_DATE|VT_BYREF:
				pArg->pdate = va_arg(argList, DATE*);
				break;
			case VT_CY|VT_BYREF:
				pArg->pcyVal = va_arg(argList, CY*);
				break;
			case VT_BSTR|VT_BYREF:
				pArg->pbstrVal = va_arg(argList, BSTR*);
				break;
			case VT_DISPATCH|VT_BYREF:
				pArg->ppdispVal = va_arg(argList, LPDISPATCH*);
				break;
			case VT_ERROR|VT_BYREF:
				pArg->pscode = va_arg(argList, SCODE*);
				break;
			case VT_BOOL|VT_BYREF:
				// DS: Unlike MFC, we already expect a VARIANT_BOOL*, not BOOL*
				// Remember this in pBool in case it's the last parameter.  If we're
				//  firing a cancelable event, this is where the sink
				//  will tell us whether it was canceled
				pBool = pArg->pboolVal = va_arg(argList, VARIANT_BOOL*);
				break;
			case VT_VARIANT|VT_BYREF:
				pArg->pvarVal = va_arg(argList, VARIANT*);
				break;
			case VT_UNKNOWN|VT_BYREF:
				pArg->ppunkVal = va_arg(argList, LPUNKNOWN*);
				break;

			default:
				ASSERT(FALSE);  // unknown type!
				break;
			}

			--pArg; // get ready to fill next argument
			++pb;
		}
	}

	// initialize return value
	VARIANT* pvarResult = NULL;
	VARIANT vaResult;
	AfxVariantInit(&vaResult);

	// initialize EXCEPINFO struct
	EXCEPINFO excepInfo;
	memset(&excepInfo, 0, sizeof excepInfo);

	UINT nArgErr = (UINT)-1;  // initialize to invalid arg

	// make the call
	SCODE sc = m_lpDispatch->Invoke(dwDispID, IID_NULL, 0, wFlags,
		&dispparams, pvarResult, &excepInfo, &nArgErr);

	// DS: Unlike MFC, we don't do any cleanup of the variants, since
	//  we didn't copy any LPCTSTRs into new BSTRs.
	delete[] dispparams.rgvarg;

	// throw exception on failure
	if (FAILED(sc))
	{
		VariantClear(&vaResult);
		if (sc != DISP_E_EXCEPTION)
		{
			// non-exception error code
			AfxThrowOleException(sc);
		}

		// make sure excepInfo is filled in
		if (excepInfo.pfnDeferredFillIn != NULL)
			excepInfo.pfnDeferredFillIn(&excepInfo);

		// allocate new exception, and fill it
		COleDispatchException* pException =
			new COleDispatchException(NULL, 0, excepInfo.wCode);
		ASSERT(pException->m_wCode == excepInfo.wCode);
		if (excepInfo.bstrSource != NULL)
		{
			pException->m_strSource = excepInfo.bstrSource;
			SysFreeString(excepInfo.bstrSource);
		}
		if (excepInfo.bstrDescription != NULL)
		{
			pException->m_strDescription = excepInfo.bstrDescription;
			SysFreeString(excepInfo.bstrDescription);
		}
		if (excepInfo.bstrHelpFile != NULL)
		{
			pException->m_strHelpFile = excepInfo.bstrHelpFile;
			SysFreeString(excepInfo.bstrHelpFile);
		}
		pException->m_dwHelpContext = excepInfo.dwHelpContext;
		pException->m_scError = excepInfo.scode;

		// then throw the exception
		THROW(pException);
		ASSERT(FALSE);  // not reached
	}

	if (pBool != NULL)
		// DS: This is a cancelable event, so return whether it was canceled
		return (*pBool != 0);

	// DS: This is not a cancelable event, so just return FALSE (i.e., not canceled)
	return FALSE;
}


////////////////////////////////////////////////////////////////////////
// Dispatch event-firing functions

// This does the actual firing of the dispatch event.  Returns whether
//  the action was canceled.
BOOL FireDispatchEventV(BOOL bCancelable, CConnectionPoint* pCP,
	DISPID dispid, BYTE* pbParams, va_list argList)
{
	// Cancelable events are not supported until they can be represented
	//  in the event queue (see utilauto.h, definition of CApplication)
	ASSERT (!bCancelable);

	CMiniOleDispatchDriver driver;
	BOOL bWasCanceled = FALSE;

	const CPtrArray* pConnections = pCP->GetConnections();
	ASSERT(pConnections != NULL);
	CPtrArray ConnectionsCopy;
	ConnectionsCopy.Copy(*pConnections);

	int i;
	int cConnections = ConnectionsCopy.GetSize();
	LPDISPATCH pDispatch;
	for(i = 0; i < cConnections; i++)
	{
		pDispatch = (LPDISPATCH)(ConnectionsCopy.GetAt(i));
		ASSERT(pDispatch != NULL);
		pDispatch->AddRef();
	}

	for (i = 0; i < cConnections; i++)
	{
		pDispatch = (LPDISPATCH)(ConnectionsCopy.GetAt(i));
		ASSERT(pDispatch != NULL);
		driver.AttachDispatch(pDispatch, FALSE);
		TRY
			bWasCanceled = driver.InvokeHelperV(dispid, 
				DISPATCH_METHOD, pbParams, argList);
		END_TRY

		driver.DetachDispatch();

		// If this is a cancelable event & was canceled, stop firing!
		if (bCancelable && bWasCanceled)
			break;
	}
	for(i = 0; i < cConnections; i++)
	{
		pDispatch = (LPDISPATCH)(ConnectionsCopy.GetAt(i));
		ASSERT(pDispatch != NULL);
		pDispatch->Release();
	}
	return (bCancelable && bWasCanceled);
}

// This prepares the varargs and calls FireDispatchEventV directly.  It
//  is this function that's actually called by the macros.
BOOL FireDispatchEvent(BOOL bCancelable, CConnectionPoint* pCP,
	DISPID dispid, BYTE* pbParams, ...)
{
	va_list argList;
	va_start(argList, pbParams);
	BOOL bCanceled =
		FireDispatchEventV(bCancelable, pCP, dispid, pbParams, argList);
	va_end(argList);
	return bCanceled;
}

// Event queue functions

// Private queueing function called by the other EventQueueAdd.  This adds an
//  allocated CEventEntry to the event queue.  If the queue fills up, it
//  spills everything out.
void CApplication::EventQueueAdd(CEventEntry* pEventEntry)
{
	m_pEventQueue[m_nEventQueueTail] = pEventEntry;
	m_nEventQueueTail = (m_nEventQueueTail+1) % MAX_EVENT_QUEUE_ENTRIES;
	if ( (m_nEventQueueTail+1) % MAX_EVENT_QUEUE_ENTRIES == m_nEventQueueHead)
	{
		// Queue has filled up.  Most likely a naughty add-in or macro
		//  has screwed up calls to EnableModeless so that we think
		//  we're supposed to be disabled when we're actually enabled.
		//  To fix this, we'll
		//		(1) Fix the EnableModeless situation
		//		(2) Empty out the queue
		// (Note that another way we can get here is if too many events
		//  have been added which are fired in response to posted messages,
		//  and our queue is simply too small to hold them.  If that's true,
		//  we'll need to make MAX_EVENT_QUEUE_ENTRIES bigger.)

		while (m_nEnableModelessLevels != 0)
		{
			// If a naughty macro or add-in doesn't re-enable us enough
			//  times (i.e., not calling EnableModeless(TRUE) for each
			//  EnableModeless(FALSE)), we'll do it ourselves here
			EnableModeless(TRUE);
		}

		EventQueueRemoveAll();
	}
}

// NOTE!  The caller must delete the returned CEventEntry*
CEventEntry* CApplication::EventQueueRemove()
{
	if (m_nEventQueueHead == m_nEventQueueTail)
		return NULL;		// already empty

	CEventEntry* pEventEntry = m_pEventQueue[m_nEventQueueHead];
	m_pEventQueue[m_nEventQueueHead] = NULL;
	m_nEventQueueHead = (m_nEventQueueHead+1) % MAX_EVENT_QUEUE_ENTRIES;
	return pEventEntry;
}

// Dequeues all events and fires them in turn.  This is called after all
//  message boxes (that were displayed by a macro or add-in) are dismissed.
//  It's also called to spill out an overflowing queue (see EventQueueAdd above)
void CApplication::EventQueueRemoveAll()
{
	if (m_bEventQueueEmptying)
		return;
	m_bEventQueueEmptying = TRUE;

	CEventEntry* pEvent;
	while ((pEvent = EventQueueRemove()) != NULL)
	{
		// Fire event stored in pEvent
		pEvent->FireDispatchEvent();
		pEvent->FireDualEvent();
		pEvent->DestroyArgs();

		// Destroy
		delete pEvent;
	}

	m_bEventQueueEmptying = FALSE;
}

void CApplication::EventQueueInit()
{
	m_bEventQueueEmptying = FALSE;
	m_nEventQueueHead = 0;
	m_nEventQueueTail = 0;

	for (int i=0; i < MAX_EVENT_QUEUE_ENTRIES; i++)
		m_pEventQueue[i] = NULL;
}

void CApplication::EventQueueDestroy()
{
	for (int i=0; i < MAX_EVENT_QUEUE_ENTRIES; i++)
	{
		if (m_pEventQueue[i] != NULL)
		{
			delete m_pEventQueue[i];
			m_pEventQueue[i] = NULL;
		}
	}
}

////////////////////////////////////////////////////////////////////////////
//
// Variant Convertions helpers.
//
//

ConvertVariantToCString(/*in*/	const VARIANT &vInput, 
					   /*out*/	CString& tReturnValue, 
					   /*in*/	CString tDefaultValue, 
					   /*in*/	BOOL bThrowException /*= TRUE*/)
{
	if ( ((vInput.vt == VT_ERROR) && (vInput.scode == DISP_E_PARAMNOTFOUND))
		|| (vInput.vt == VT_EMPTY))
	{
		tReturnValue = tDefaultValue; // lDefault is our default value
		return S_FALSE;
	}

	VARIANT vTemp;
	::VariantInit(&vTemp);

	HRESULT hr = ::VariantChangeType(&vTemp, const_cast<VARIANT*>(&vInput), 0, VT_BSTR) ;
	if (FAILED(hr))
	{	
	// they gave us an unusable type, so trigger an error		
		if (bThrowException)
		{
			::DsThrowCannedOleDispatchException(hr);
		}
		else
		{
			return E_FAIL ;
		}
	}

	tReturnValue = vTemp.bstrVal;
	if (tReturnValue.IsEmpty())
	{
		tReturnValue = tDefaultValue; 
		return S_FALSE;
	}
 	return S_OK;
}


ConvertVariantToLong(/*in*/	const VARIANT &vInput, 
					   /*out*/	long& tReturnValue, 
					   /*in*/	long tDefaultValue, 
					   /*in*/	BOOL bThrowException /*= TRUE*/)
{
   	if (((vInput.vt == VT_ERROR) && (vInput.scode == DISP_E_PARAMNOTFOUND)) // if param omitted
		|| (vInput.vt == VT_EMPTY))
	{
		tReturnValue = tDefaultValue; // lDefault is our default value
		return S_FALSE;
	}

	VARIANT vTemp;
	::VariantInit(&vTemp);

	HRESULT hr = ::VariantChangeType(&vTemp, const_cast<VARIANT*>(&vInput), 0, VT_I4) ;
	if (FAILED(hr))
	{	
	// they gave us an unusable type, so trigger an error		
		if (bThrowException)
		{ 
			::DsThrowCannedOleDispatchException(hr);
		}
		else
		{
			return E_FAIL ;
		}
	}

	tReturnValue = vTemp.lVal;
 	return S_OK;
}



ConvertVariantToBOOL(/*in*/	const VARIANT &vInput, 
					   /*out*/	BOOL& tReturnValue, 
					   /*in*/	BOOL tDefaultValue, 
					   /*in*/	BOOL bThrowException /*= TRUE*/)
{
	if ( ((vInput.vt == VT_ERROR) && (vInput.scode == DISP_E_PARAMNOTFOUND)) // if param omitted
		|| (vInput.vt == VT_EMPTY))

	{
		tReturnValue = tDefaultValue; // lDefault is our default value
		return S_FALSE;
	}

	VARIANT vTemp;
	::VariantInit(&vTemp);

	HRESULT hr = ::VariantChangeType(&vTemp, const_cast<VARIANT*>(&vInput), 0, VT_BOOL) ;
	if (FAILED(hr))
	{	
	// they gave us an unusable type, so trigger an error		
		if (bThrowException)
		{
			::DsThrowCannedOleDispatchException(hr);
		}
		else
		{
			return E_FAIL ;
		}
	}

	tReturnValue = (vTemp.boolVal == VARIANT_TRUE) ? TRUE : FALSE ;
 	return S_OK;
}


// this fn is used by quoted strings for recording
void CQuotedStringArg::GetQuotedBasicString(CString &strOut, LPCTSTR szData)
{
	CString strTemp(szData);
	int i;

	static TCHAR chQuote = _T('\"');
	strOut = chQuote; // our opening quote

	while (1)
	{
		i = strTemp.Find(chQuote);

		if (-1 == i) // if no embedded double quotes
		{
			strOut += strTemp; // grab the rest of the string

#ifdef _DEBUG
			CString strData(szData);
			int iOutLen = strOut.GetLength() - 1; // to account for the opening quote
			ASSERT(strData.GetLength() <= iOutLen); // can't be smaller
			int iMaxLen = 1 + strData.GetLength() * 2;
			ASSERT(iOutLen <= iMaxLen); // can't be more than twice as large
#endif

			strOut += chQuote;
			return; // and return
		}

		// otherwise, i is the _byte_ (!) index into our character string

		strOut += strTemp.Left(i); // grab the characters before the quote
		strOut += _T("\"\""); // append two double quotes
		strTemp = strTemp.Mid(i + 1); // discard the quote & the characters before it
		// and repeat the find operation
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\filechng.cpp ===
//-----------------------------------------------------------------------------
//  filechng.cpp
//
//  Copyright (C) 1993, Microsoft Corporation
//
//  Purpose:    Implement the CFileChange class
//
//  Functions/Methods present:
//
//  Revision History:
//
//  []      14-Jan-1994 Dans    Created
//
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <process.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#if defined(_DEBUG)
#define debug(x)	x
#else
#define debug(x)
#endif

//-----------------------------------------------------------------------------
// Road map to file change
//
//  The main features of the CFileChange class are 1) the auxilliary thread
//  that handles the file change events and requests from the other threads and
//  2) the data structures that represent how it looks upon the file change.
//
//  Basically, we have a mapping of CString to a CListPtr using CMapStringToOb,
//  that is implemented in a subclass called CSafeMapStringToOb (it will clean
//  up all the lists on the range side of the mapping, unlike CMapStringToOb).
//  These CStrings in the map are the directory names we are watching.  The
//  Win32 file change api's watch only directories and leave the responsibility
//  of finding the files that actually changed to the programmer.  That is the
//  reason we have this machinery.
//
//  The CPtrList (implemented in CSafePFiledataList) contains all the files
//  in the directory that we are interested in.  A CFileData object is a
//  CString along with some extra data for determining if the file has changed
//  on disk.  This includes a buffer (StatBuf), the ignore count,
//  and some housekeeping data.
//
//  So, what we have is really just another implementation of a directory
//  hierarchy:!!!:
//
//  CSafeMapStringToOb
//      |
//      CString (directory1) -> CSafePFiledataList
//      |                       |
//      |                       CFileData (file1 + aux data)
//      |                       CFileData (file2 + aux data)
//      |
//      CString (directory2) -> CSafePFiledataList
//                              |
//                              CFileData (file3 + aux data)
//
//  Also, we have two arrays that create a reverse mapping from Win32
//  FileChange handles to a directory so that we can map from:
//  HANDLE->Directory->FileList quickly to see if any of the files we have
//  an interest in were the ones that fired the file change event.  This is
//  encapsulated in the HtoStr structure embedded in the CFileChange object.
//  Note that the handle array and the string array are kept discrete because
//  Win32 requires an array of handles in the WaitForMultipleObjects api call.
//
//  The class CSafePFiledataList also has the index of the corresponding
//  handle and string in the HtoStr structure (this is kept in _dwAux) for
//  the purpose of keeping the HtoStr arrays of handles and strings packed as
//  is necessary for WaitForMultipleObjects call.  We have to know which
//  HANDLE and string in the HtoStr arrays to remove when the last file in
//  a directory is removed, so we don't have to watch for changes in that
//  directory anymore.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//  Global data, this object is the main CFileChange instance for everyone
//-----------------------------------------------------------------------------
CFileChange	g_filechange;

CFileChange *
GetFileChange() {
	return &g_filechange;
	}
//----------------------------------------------------------------------------
// MakeFileLCase()
// 
//	Purpose:	lowercase the filename only if it is not dbcs
//----------------------------------------------------------------------------
void MakeFileLCase (LPSTR szFileLower, LPCSTR szFileName)
{
	CONST TCHAR * pch1 = szFileName;
	// DevStudio96 #14887 [patbr]: use unsigned chars--otherwise sign
	// extension will mess up the isupper() and tolower() calls below.
	unsigned char * pch2 = (unsigned char *)szFileLower;
	while (*pch1!= '\0')
	{
		if (IsDBCSLeadByte (*pch1))
		{
			*pch2 = *pch1;
			pch1++ ; pch2++;
			*pch2 = *pch1;
			pch1++; pch2++;
		}
		else
		{
			*pch2 = *pch1;
			if (isupper (*pch2))
				*pch2 = _tolower (*pch2);
			pch1++; pch2++;
		}
	}
	*pch2 = '\0';
};

//-----------------------------------------------------------------------------
//  FDirFromFile
//
//  Purpose:    provide the directory for the fullpath filename input
//
//  Input:      str,        CString reference for output
//              szFileName, filename to return directory of
//
//  Output:     str is updated with the directory of the file passed in.
//
//  Returns:    TRUE if successful
//
//  Note:       file must be full path form already.
//
//-----------------------------------------------------------------------------
BOOL    FDirFromFile ( CString & str, LPCTSTR szFileName ) {

	CPath   path;
	CDir    dir;
	LPSTR	szFileLower;
	BOOL	bRet = FALSE;
	szFileLower = new TCHAR [_tcslen(szFileName) + 1];

	::MakeFileLCase (szFileLower, szFileName);
	if ( path.Create ( szFileLower ) && dir.CreateFromPath ( path ) ) {
		str = dir;
		// Make sure we can be found in the file list... all lowercase.
		bRet = fTrue;
		}
	else {
		bRet = fFalse;
		}
	delete []szFileLower;
	return bRet;

	}

//-----------------------------------------------------------------------------
//  ctor/dtor for CFileChange class
//-----------------------------------------------------------------------------
CFileChange::CFileChange() {
	_cIdles = 0;
	_cBoosts = 0;
	_fThreadRunning = fFalse;
	_fDupThreadHandle = fFalse;
	_hThread = 0;
	memset ( &_hts, 0, sizeof(_hts) );
	_hts.rgh[ iHandleITC ] = _eventIn;
	}

CFileChange::~CFileChange() {
	if ( _fThreadRunning ) {
		Terminate();
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::FInit
//
//  Purpose:    initialize a CFileChange object for use
//
//  Input:      pfn,    callback function to call on each filechange notification
//              dwUser, optional parameter to pass to each invocation of callback
//
//  Returns:    TRUE on success
//
//  Note:       starts up auxilliary thread to handle file change notifications
//
//-----------------------------------------------------------------------------


BOOL    CFileChange::FInit ( DWORD dwUser ) {
	CWinThread * pWinThread = NULL;
	ASSERT ( !_fThreadRunning );
	if ( !_fThreadRunning ) {
		 _fThreadRetCode = fFalse;
		_dwUser = dwUser;
		if ( (pWinThread = AfxBeginThread ( CFileChange::ThreadEntry, this, prtyStandard, 0x10000)) != NULL) {
			if ( !(_fDupThreadHandle = 
					DuplicateHandle ( ::GetCurrentProcess( ),
									pWinThread->m_hThread,
									::GetCurrentProcess( ),
									&_hThread,
									DUPLICATE_SAME_ACCESS,
									TRUE,
									DUPLICATE_SAME_ACCESS
						     		)
						)
				) {
					ASSERT(FALSE);
					_hThread = pWinThread->m_hThread; 
			}

			_eventOut.Wait();
			}
		return _fThreadRetCode;
		}
	return fFalse;
	}

//-----------------------------------------------------------------------------
//  CFileChange::Terminate
//
//  Purpose:    handle the main thread cleanup chores
//
//  Note:       this tells the aux thread to cleanup and exit if it exists,
//              else it cleans up on its own.  generally, the only time the main
//              thread needs to do this is when ExitProcess is called, and we
//              are in a DLL and we have not cleaned up yet--NT kills all threads
//              prior to calling the DllMain code.
//
//-----------------------------------------------------------------------------
void    CFileChange::Terminate() {

	if ( _hThread ) {
		DWORD	dw = ::WaitForSingleObject ( _hThread, 0 );

		if ( dw == WAIT_OBJECT_0 ) {
			// thread handle signalled means thread is dead--probably
			// killed by system during cleanup, we need to do it for it
			if ( _fThreadRunning ) {
				ThreadCleanup();
				}
			}
		else {
			FCItem	fci;
			IDEL	idelDummy;
			
			fci._op = FCItem::opQuit;
			fci._pfnAsyncReturn = CFileChange::SyncCallback;
			fci._pvUser1 = this;
			_queueFCItem.put ( fci, idelDummy );
			_eventIn.Set();

			_eventOut.Wait ( 1000 );

			// We are assuming that 10 seconds is enough time for the 
			// other thread terminate. Might want to revisit this. 
			dw = ::WaitForSingleObject(_hThread, 10000 );
			ASSERT (_fDupThreadHandle == FALSE || dw == WAIT_OBJECT_0);
			}


		if ( _fDupThreadHandle ) {
			CloseHandle(_hThread);
			}

		_hThread = NULL;
		_fThreadRunning = fFalse;
		_fDupThreadHandle = fFalse;

		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::FAddFile
//
//  Purpose:    add a file to the file change list, main thread access
//
//  Input:      szFile, file (fullpath!) to add.
//
//  Returns:    TRUE if successful
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FAddFile ( LPCSTR szFile, PfnFCCallBack pfn, BOOL fCallAlways /* = fFalse */ ) {
	if ( _fThreadRunning ) {
		// note that szFile must be a full path

		//
		// Don't bother making inter-thread call if file doesn't even exist.
		//
		WIN32_FILE_ATTRIBUTE_DATA find;
		if (Compatible_GetFileAttributesEx( szFile, GetFileExInfoStandard, &find))
			return ThreadCall ( szFile, pfn, FCItem::opAdd, fCallAlways );
		else
			return fFalse;
		}
	return fFalse;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FDelFile
//
//  Purpose:    remove a file from the filechange list, main thread access
//
//  Input:      szFile, file (fullpath!) to remoev
//
//  Returns:    TRUE if file was in the list and was removed.
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FDelFile ( LPCTSTR szFile, PfnFCCallBack pfn ) {
	if ( _fThreadRunning ) {
		return ThreadCall ( szFile, pfn, FCItem::opDel );
		}
	return fFalse;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FIgnoreFile
//
//  Purpose:    used to temporarily ignore filechange events on a specific file
//              or to restore an ignored file to unignored status.  it is a
//              counting ignore flag.
//
//  Input:      szFile,     file to ignore/unignore
//              fIgnore,    whether to ignore/unignore
//
//  Returns:    TRUE if file is in the list
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FIgnoreFile ( LPCTSTR szFile, BOOL fIgnore /* = fTrue */,
	PfnFCCallBack pfn /* = NULL */) {
	if ( _fThreadRunning ) {
		return ThreadCall ( szFile, pfn, (fIgnore ? FCItem::opIgnore : FCItem::opUnignore) );
		}
	return fFalse;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FSyncFile
//
//  Purpose:    used to synchronize the filechange data with the file system.
//              typically used after an ignore/unignore phase to make sure that
//              if the file change event comes after the last unignore, we
//              don't have unintended change event notifications.
//
//  Input:      szFile,     file to ignore/unignore
//
//  Returns:    TRUE if file is in the list
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FSyncFile ( LPCTSTR szFile ) {
	if ( _fThreadRunning ) {
		return ThreadCall ( szFile, NULL, FCItem::opSyncFile );
		}
	return fFalse;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FFilelistEtcFromFilename
//
//  Purpose:    Utility function to do the lookup to find the filelist and
//              filedata associated with the filename, if they exist.
//
//  Input:      szFilename, the filename to search for
//
//  Output:     pFilelist,  reference to the filelist if we find the directory
//              pFiledata,  reference to the filedata if we find the file
//              posRet,     reference to position of found filedata in filelist
//
//  Returns:    TRUE if successful
//
//  Note:       the caller of this fuction must own the critical section.
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FFilelistEtcFromFilename (
	LPCTSTR                 szFilename,
	CSafePFileDataList * &  pFilelist,
	CFileData * &           pFiledata,
	POSITION &              posRet
	) {

	BOOL    fRet = fFalse;
	CString strPath;

	pFilelist = NULL;
	pFiledata = NULL;
	posRet = 0;
	VERIFY ( ::FDirFromFile ( strPath, szFilename ) );

	CObject *   pObj;
	if ( _mpDirsFilelist.Lookup ( strPath, pObj ) ) {
		// directory exists
		ASSERT ( pObj->IsKindOf(RUNTIME_CLASS(CPtrList)) );
		pFilelist = (CSafePFileDataList *) pObj;

		POSITION    pos = pFilelist->GetHeadPosition();
		POSITION    posCur;

		while ( posCur = pos ) {
			CFileData * pFile = (CFileData *) pFilelist->GetNext ( pos );
			if ( pFile->CompareNoCase ( szFilename ) == 0 ) {
				// found one, return it and leave
				fRet = fTrue;
				posRet = posCur;
				pFiledata = pFile;
				break;
				}
			}
		}
	else {
		// not in the directory list, try the overspill...
		POSITION    pos;
		CFileData * pFile = PFileDataOverspill ( szFilename, pos );
		if ( pFile ) {
			fRet = fTrue;
			posRet = pos;
			pFiledata = pFile;
			pFilelist = NULL;
			}
		}
	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::ThreadEntry
//
//  Purpose:    static method used for aux thread entry point
//
//  Input:      pv, void pointer that points to the CFileChange instance
//              that the thread is running in.
//
//-----------------------------------------------------------------------------
UINT CFileChange::ThreadEntry ( void * pv ) {
	CFileChange *   pfc = (CFileChange *) pv;
	ASSERT ( pfc );

	pfc->_fThreadRunning = GetCurrentThreadId();

	// success returned to calling thread.
	pfc->ThreadReturn ( fTrue );
	pfc->WaitAndHandleIt();
	pfc->_fThreadRunning = fFalse;
	
	return 0;
	}

//-----------------------------------------------------------------------------
//  CFileChange::SyncCallback
//
//  Purpose:    static method used for calling back to force synchronous
//				behavior using the async calls.
//
//  Input:      pfci, const pointer to an FCItem that was operated on.
//
//-----------------------------------------------------------------------------
void    CFileChange::SyncCallback ( const FCItem * pfci ) {
	ASSERT ( pfci );
	ASSERT ( pfci->_pvUser1 );

	CFileChange *	pfc = (CFileChange*) pfci->_pvUser1;

	pfc->ThreadReturn ( pfci->_fAsyncReturn );
	}

//-----------------------------------------------------------------------------
//  CFileChange::ThreadCall
//
//  Purpose:    handles the common functions for the synchronous calls
//-----------------------------------------------------------------------------
BOOL
CFileChange::ThreadCall (
	LPCTSTR			szFile,
	PfnFCCallBack	pfn,
	FCItem::Op		op,
	BOOL			fCallAlways /* =fTrue */
	) {
	ASSERT (
		op == FCItem::opAdd ||
		op == FCItem::opDel ||
		op == FCItem::opQuit ||
		op == FCItem::opIgnore ||
		op == FCItem::opUnignore ||
		op == FCItem::opSyncFile
		);
	CritSection	cs(_critsecCall);

	ASSERT( 0 < _tcslen(szFile) );
	
	_fcitemThread._op = op;
	_fcitemThread._strFileName = szFile;
	_fcitemThread._pfnFCCallBack = pfn;
	_fcitemThread._fCallAlways = fCallAlways;
	_fcitemThread._pfnAsyncReturn = CFileChange::SyncCallback;
	_fcitemThread._pvUser1 = this;
	
	IDEL	idelDummy;

	BoostPriority();

	_queueFCItem.put ( _fcitemThread, idelDummy );
	_eventIn.Set();
	_eventOut.Wait();

	RestorePriority();

	return _fThreadRetCode;
	}

//-----------------------------------------------------------------------------
//  CFileChange::WaitAndHandleIt
//
//  Purpose:    the main routine for handling the events being signaled for the
//              aux thread to do something, either a file change event or a
//              request from another thread to add, delete, or ignore a file.
//
//-----------------------------------------------------------------------------
void    CFileChange::WaitAndHandleIt() {

	DWORD		cMsecsCumulative = 0;
	DWORD		cMsecs = ::GetTickCount();

	ASSERT ( _mpDirsFilelist.GetCount() == 0 ); // must be 0 at start
	ASSERT ( _hts.rgh[ iHandleITC ] == _eventIn );

	for ( ; ; ) {   // forever
		unsigned    cHandles;
		if ( _cIdles ) {
			cHandles = 1;
			}
		else {
			cHandles = _mpDirsFilelist.GetCount() + 1;
			}

		DWORD   dwWaitCode;
		dwWaitCode = ::WaitForMultipleObjects (
			cHandles,
			_hts.rgh,
			fFalse,
			DwTimeout()
			);

		ASSERT (
			dwWaitCode == WAIT_TIMEOUT ||
			dwWaitCode == WAIT_FAILED ||
			(dwWaitCode >= WAIT_OBJECT_0 && dwWaitCode < WAIT_OBJECT_0 + cHandles)
			);

		DWORD	cMsecsNew = ::GetTickCount();

		if ( _cIdles ) {
			cMsecsCumulative += cMsecsNew - cMsecs;
			}
		else {
			cMsecsCumulative = 0;
			}
		cMsecs = cMsecsNew;

		if ( dwWaitCode == WAIT_FAILED ) {
			TRACE("WaitForMultipleObjects returned WAIT_FAILED; file change notification thread exiting...\n");
			ThreadReturn ( fFalse );
			break;
			}
		else if ( dwWaitCode == WAIT_TIMEOUT ) {
			// we need to do the manual list now and accumulate our idle time
			DoCheckOverspillFiles();
			if ( _cIdles && cMsecsCumulative >= cIdleMsecsCumulative ) {
				// cycle each of the file change handles...
				cMsecsCumulative = 0;
				for (
					unsigned iHandle = 1;
					iHandle <= unsigned(_mpDirsFilelist.GetCount());
					iHandle++
					) {
					if ( WAIT_OBJECT_0 == WaitForSingleObject ( _hts.rgh[ iHandle ], 0 ) ) {
						DoFileChange ( iHandle );
						}
					}
				}
			}
		else {	// only thing left is that an event is signalled.
			unsigned    iHandle = dwWaitCode - WAIT_OBJECT_0;

			if ( iHandleITC == iHandle ) {
				// our inter-thread communication event handle
				if ( !FThreadDoRequest() ) {
					// opQuit came through if FDoRequest returns fFalse
					break;
					}
				}
			else {
				// a file change notification came through--see if we care
				DoFileChange ( iHandle );
				}
			}
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::FThreadDoRequest
//
//  Purpose:    handles requests from other threads in our aux thread for all
//              the requests (add, delete, ignore/unignore, terminate).
//
//  Returns:    TRUE if not FCItem::opQuit, FALSE if we are quitting.
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FThreadDoRequest() {

	BOOL    fRet = fTrue;   // this function always returns true unless
							//  the thread is quitting.

	BoostPriority();
	while ( _queueFCItem.size() ) {
		FCItem	fci;
		IDEL	idelDummy;
		_queueFCItem.get ( fci, idelDummy );


		ASSERT ( int(fci._op) < int(FCItem::opFileChanged) );

		switch ( fci._op ) {
			case FCItem::opAdd : {
				ASSERT ( fci._strFileName.GetLength() );
				fci._fAsyncReturn = FThreadAddFile ( fci );
				break;
				}
			case FCItem::opDel : {
				ASSERT ( fci._strFileName.GetLength() );
				fci._fAsyncReturn = FThreadDelFile ( fci );
				break;
				}
			case FCItem::opIgnore :
			case FCItem::opUnignore : {
				ASSERT ( fci._strFileName.GetLength() );
				fci._fAsyncReturn = FThreadIgnoreFile ( fci );
				break;
				}
			case FCItem::opSyncFile : {
				ASSERT ( fci._strFileName.GetLength() );
				fci._fAsyncReturn = FThreadSyncFile ( fci );
				break;
				}
			case FCItem::opNull :
			case FCItem::opFileChanged : {
				// do nothing on these requests--they are meaningless
				fci._fAsyncReturn = fFalse;
				break;
				}
			case FCItem::opQuit : {
				ThreadCleanup();
				fci._fAsyncReturn = fTrue;
				fRet = fFalse;
				break;
				}
			}
		if ( fci._pfnAsyncReturn ) {
			fci._pfnAsyncReturn ( &fci );
			}
		}
	
	RestorePriority();
	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FThreadAddFile
//
//  Purpose:    aux thread side of adding a file to the file change list
//
//  Input:      input from fci set up in calling thread.
//
//  Output:     if a valid file, added to the list
//
//  Returns:    TRUE if everything copasetic
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FThreadAddFile ( FCItem & fci ) {

	CFileData * pFile = new CFileData ( fci._strFileName );
	if ( NULL == pFile ) {
		return fFalse;
		}

	pFile->FAddCallBack ( fci._pfnFCCallBack, fci._fCallAlways );

	StatBuf sb;
 	if ( pFile->FGetCachedStatBuf(sb) && (sb.dwAttrs & StatBuf::fattrDir) ) {
		delete pFile;
		return fFalse;
		}

	fci._statNew = sb;

	BOOL                    fRet = fTrue;
	CSafePFileDataList *    pFileList;
	CFileData *             pFileData = NULL;
	POSITION                posDummy;

	CritSection	cs(_critSection);

	if ( !FFilelistEtcFromFilename ( fci._strFileName, pFileList, pFileData, posDummy ) ) {
		if ( !pFileList ) {
			ASSERT ( pFileData == NULL );
			// directory is new, must add a entry and open a filechange event
			if ( _mpDirsFilelist.GetCount() < cDirMax ) {
				pFileList = new CSafePFileDataList;
				CString strPath;

				VERIFY ( ::FDirFromFile ( strPath, fci._strFileName ) );

				unsigned    i = _mpDirsFilelist.GetCount() + 1; // next index is the count of dirs
				pFileList->_dwAux = i;
				_hts.rgh[ i ] = ::FindFirstChangeNotification (
					strPath,            // watch the directory
					fFalse,             // don't watch subtree
					DwStdFileChange()   // watch for standard file changes
					);
				if ( _hts.rgh[ i ] != INVALID_HANDLE_VALUE ) {
					_mpDirsFilelist.SetAt ( strPath, pFileList );
					_hts.rgpstr[ i ] = new CString ( strPath );
					}
				else {
					// couldn't add it for some reason...add to manual list if the dir
					// exists
					CDir	dir;
					dir.CreateFromString ( strPath );

					if ( dir.ExistsOnDisk() ) {
						if ( !FAddOverspillFile ( pFile ) ) {
							delete pFile;
							}
						}
					else {
						delete pFile;
						fRet = fFalse;
						}
					delete pFileList;
					pFileList = NULL;
					}
				}
			else {
				CString strPath;

				VERIFY ( ::FDirFromFile ( strPath, fci._strFileName ) );
				CDir	dir;
				dir.CreateFromString ( strPath );

				if ( dir.ExistsOnDisk() ) {
					if ( !FAddOverspillFile ( pFile ) ) {
						delete pFile;
						}
					}
				else {
					delete pFile;
					fRet = fFalse;
					}
				}
			}

		// at this point, we must have a file list, else we bail
		if ( pFileList ) {
			ASSERT ( pFile != NULL );
			pFileList->AddTail ( (void *) pFile );
			}
		}

	else {
		// file already exists in our list, delete our filedata
		// So now we'd better add the callback to the filedata
		// structure if it's not already there
		pFileData->FAddCallBack ( fci._pfnFCCallBack, fci._fCallAlways );
		delete pFile;
		}

	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::DoCheckFile
//
//  Purpose:    check a given file to see if it has been modified and if
//				so send out a notification by calling the callback function
//
//  Input:      pFileData,	a pointer to the CFileData object for the file
//				to check
//
//  Note:       if a file was found to have changed, we call the callback
//              function with a FCItem class filled out.
//
//-----------------------------------------------------------------------------
void CFileChange::DoCheckFile ( CFileData * pFileData ) {
	StatBuf sbPrev, sbCur;
	FCBits  fcbits = {0};
	BOOL    fPrevValid = pFileData->FGetCachedStatBuf ( sbPrev );

	if ( pFileData->FSetCachedStatBuf ( sbCur ) ) {
		fcbits.fTime = (sbPrev.fcft.qwFiletime != sbCur.fcft.qwFiletime);
		fcbits.fSize = (sbPrev.cbFile != sbCur.cbFile);
		if ( sbPrev.dwAttrs != sbCur.dwAttrs ) {
			DWORD	modePrev = sbPrev.dwAttrs;
			DWORD	modeCur = sbCur.dwAttrs;

			ASSERT ( !fPrevValid || !(modePrev & StatBuf::fattrDir) );
			if ( (modeCur & StatBuf::fattrDir) ) {
				// not a file anymore!
				fcbits.fType = fTrue;
				}
			// check for read/write <-> read/only changes
			modePrev &= FattrFileMask();
			modeCur  &= FattrFileMask();
			fcbits.fAttrs = (modeCur != modePrev);
			}
		}
	else if ( fPrevValid ) {
		// not available, file has been deleted?
		fcbits.fDel = TRUE;
		// leave it in the list, may just be unavailable
		}

	// any changes happen?  if so, do the callback
	if ( fcbits.fAll ) {
		FCItem	fci;
		fci._strFileName = *pFileData;
		fci._fcb = fcbits;
		fci._op = FCItem::opFileChanged;
		fci._statNew = sbCur;
		pFileData->DoCallAlways ( &fci, _dwUser );	// Do normal callbacks
		if ( pFileData->CIgnores() == 0 ) {
			pFileData->DoCallIfNotIgnore ( &fci, _dwUser );
			}
		else if( pFileData->FSpecificIgnore() )
		{
			pFileData->DoCallIfNotSpecificIgnore ( &fci, _dwUser );
		}
		if ( fcbits.fDel ) {
			pFileData->Reinit();
			}
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::DoFileChange
//
//  Purpose:    handles the file change events from WaitAndHandleIt
//
//  Input:      iHandle,    index of the handle in the HtoStr array
//                          that fired the event
//
//  Note:       this iterates over the files in the dir that changed and
//				calls DoCheckFile on each one.
//
//-----------------------------------------------------------------------------
void    CFileChange::DoFileChange ( unsigned iHandle ) {
	HANDLE      h = _hts.rgh [ iHandle ];
	CString *   pstr = _hts.rgpstr [ iHandle ];

	ASSERT ( h );
	ASSERT ( pstr );
	ASSERT ( pstr->GetLength() );

	if ( ::FindNextChangeNotification ( h ) == NULL) {
		// The directory is no longer there (net connection lost?)
		ThreadDeleteDirectory ( iHandle );
		return;
		}

	CObject *               pObj;
	CSafePFileDataList *    pFileList;

	CritSection cs(_critSection);

	// get the list of files to go with the directory
	if ( _mpDirsFilelist.Lookup ( *pstr, pObj ) ) {
		ASSERT ( pObj );
		ASSERT ( pObj->IsKindOf(RUNTIME_CLASS(CPtrList)) );

		pFileList = (CSafePFileDataList *) pObj;
		ASSERT ( pFileList->_dwAux == iHandle );

		POSITION    pos = pFileList->GetHeadPosition();

		while ( pos ) {
			// check each file to see if it was the one that fired off the event
			CFileData * pFileData = (CFileData *) pFileList->GetNext ( pos );
			DoCheckFile ( pFileData );
 			}
		}
	else {
		ASSERT ( fFalse );  // this should never happen!
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::FThreadDelFile
//
//  Purpose:    delete a file from our list, while possibly removing an entire
//              entry in the directory map if the last file is removed from
//              that directory.
//
//  Input:      all input taken from fci.
//
//  Returns:    TRUE if file was removed, FALSE if file didn't exist.
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FThreadDelFile ( FCItem & fci ) {

	BOOL                    fRet = fFalse;
	CSafePFileDataList *    pFileList = NULL;
	CFileData *             pFileData = NULL;
	POSITION                posFile = NULL;

	CritSection	cs(_critSection);

	// find all the data associated with the file
	if ( FFilelistEtcFromFilename (
			fci._strFileName,
			pFileList,
			pFileData,
			posFile
			)
		) {
		ASSERT ( pFileData != NULL );
		ASSERT ( posFile != NULL );

		// if we have more than one callback, delete the one we match...
		pFileData->FDelCallBack ( fci._pfnFCCallBack );
		fRet = fTrue;
		if ( pFileData->CCallBacks() == 0 ) {
			if ( pFileList == NULL ) {
				// file came from overspill list...remove it if we match...
				DeleteOverspillFile ( pFileData );
				}
			else {
				// remove filedata entry in filelist and delete the filedata
				pFileList->RemoveAt ( posFile );
				delete pFileData;

				if ( pFileList->IsEmpty() ) {
					// remove the whole list and dir entry
					unsigned    i = pFileList->_dwAux;
					unsigned    iLast = _mpDirsFilelist.GetCount();

					ASSERT ( i > 0 );   // can't be 0, since that is our ITC handle
					ASSERT ( i <= iLast );
					ASSERT ( _hts.rgh[ i ] );
					ASSERT ( _hts.rgpstr[ i ] );

					// close the notification handle
					VERIFY ( ::FindCloseChangeNotification ( _hts.rgh[ i ] ) );

					// remove entry from map
					VERIFY ( _mpDirsFilelist.RemoveKey ( *_hts.rgpstr[ i ] ) );
					delete pFileList;

					// cache the soon-to-be-removed directory string
					CString	*	pstrPath = _hts.rgpstr[ i ];

					// move the arrays so that they are packed
					memmove ( &_hts.rgh[ i ],    &_hts.rgh[ i + 1 ],    (iLast - i) * sizeof(HANDLE) );
					memmove ( &_hts.rgpstr[ i ], &_hts.rgpstr[ i + 1 ], (iLast - i) * sizeof(CString *) );
					_hts.rgh[ iLast ] = 0;
					_hts.rgpstr[ iLast ] = NULL;

					// fix up all the _dwAux records in each file list
					POSITION    pos = _mpDirsFilelist.GetStartPosition();

					while ( pos ) {
						CObject *   pObj;
						_mpDirsFilelist.GetNextAssoc ( pos, *pstrPath, pObj );
						ASSERT ( pObj );
						ASSERT ( pObj->IsKindOf(RUNTIME_CLASS(CPtrList)) );

						pFileList = (CSafePFileDataList *) pObj;
						if ( pFileList->_dwAux > i ) {
							pFileList->_dwAux--;
							}
						}
					delete pstrPath;
					}
				}
			}
		}
	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::ThreadCleanup
//
//  Purpose:    release all data and handles prior to destruction
//
//  Note:       should be done from aux thread, but in the case where the aux
//              thread is killed by the system due to a call to ExitProcess
//              AND this code resides in a dll, then the main thread will
//              note that the thread is dead and do the cleanup itself.
//
//-----------------------------------------------------------------------------
void    CFileChange::ThreadCleanup () {

	// we either think the thread is running or we know it is--this can be called
	// generally only by the 2nd thread, but can be used by the main thread if the 2nd
	// thread has been killed by the system (like during ExitProcess and we be called
	// by our dtor from the DllMain code.
	ASSERT ( _fThreadRunning );

	_critSection.Enter();
	unsigned    cHandles = _mpDirsFilelist.GetCount();

	// remove all items in dir list (does a deep remove, dtors all called!)
	_mpDirsFilelist.RemoveAllAssoc();

	// remove all file change handles and cached dir strings
	// don't close handle 0: handle 0 is the thread sync handle, not a 
	//  change notification handle
	while ( cHandles >= 1 ) {
		VERIFY ( ::FindCloseChangeNotification ( _hts.rgh[ cHandles ] ) );
		delete _hts.rgpstr[ cHandles ];
		cHandles--;
		}

	_fThreadRunning = fFalse;
	_critSection.Leave();
	}

//-----------------------------------------------------------------------------
//  CFileChange::FThreadIgnoreFile
//
//  Purpose:    to tell the file change handler to ignore or unignore a file.
//              typically used to handle known changes, like File.Save or
//              the ClassWizard.
//
//  Input:      op, an FCItem::Op that is either opIgnore or opUnignore
//              filename comes from fci.
//
//  Returns:    TRUE if successful
//
//  Note:       these are counting hits, so a ignore must be matched with an
//              unignore.
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FThreadIgnoreFile ( FCItem & fci ) {

	ASSERT ( fci._op == FCItem::opIgnore || fci._op == FCItem::opUnignore );

	BOOL                    fRet = fFalse;
	CSafePFileDataList *    pFileList;
	CFileData *             pFileData;
	POSITION                posDummy;

	CritSection	cs(_critSection);

	if ( FFilelistEtcFromFilename (
			fci._strFileName,
			pFileList,
			pFileData,
			posDummy
			)
		) {
		ASSERT ( pFileData != NULL );
		ASSERT ( posDummy != NULL );
		if ( fci._op == FCItem::opIgnore ) {
			pFileData->FIgnore(fci._pfnFCCallBack);
			}
		else {
			// We are about to unignore the file completely
			// so notify anyone who didn't ignore this file
			// that it has probably changed
			if ( pFileData->CIgnores() == 1 ) {
				DoCheckFile ( pFileData );
				}
			pFileData->FUnignore(fci._pfnFCCallBack);
 			}
		fRet = fTrue;
		}

	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FThreadSyncFile
//
//  Purpose:    to sync up the file data we have cached with the file system.
//              typically used after a ignore/unignore pair to make sure
//              file change events don't happen after the unignore.
//
//  Returns:    TRUE if successful
//
//-----------------------------------------------------------------------------
BOOL    CFileChange::FThreadSyncFile ( FCItem & fci ) {

	BOOL                    fRet = fFalse;
	CSafePFileDataList *    pFileList;
	CFileData *             pFileData;
	POSITION                posDummy;

	CritSection	cs(_critSection);

	if ( FFilelistEtcFromFilename (
			fci._strFileName,
			pFileList,
			pFileData,
			posDummy
			)
		) {
		ASSERT ( pFileData != NULL );
		ASSERT ( posDummy != NULL );

		fRet = pFileData->FSetCachedStatBuf();
		}
	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::ThreadDeleteDirectory
//
//  Purpose:    Remove all the files from a directory entry, and the directory
//              entry itself.
//
//  Input:      iHandle,    index of the handle in the HtoStr of the directory
//
//  Note:       This function handles a failed FindNextFileChangeNotification
//
//-----------------------------------------------------------------------------
void    CFileChange::ThreadDeleteDirectory ( unsigned iHandle ) {
	HANDLE      h = _hts.rgh [ iHandle ];
	CString *   pstr = _hts.rgpstr [ iHandle ];

	ASSERT ( h );
	ASSERT ( pstr );
	ASSERT ( pstr->GetLength() );

	CObject *               pObj;
	CSafePFileDataList *    pFileList;

	CritSection	cs(_critSection);

	// get the list of files to go with the directory
	if ( _mpDirsFilelist.Lookup ( *pstr, pObj ) ) {
		ASSERT ( pObj );
		ASSERT ( pObj->IsKindOf(RUNTIME_CLASS(CPtrList)) );

		pFileList = (CSafePFileDataList *) pObj;
		ASSERT ( pFileList->_dwAux == iHandle );

		FCItem		fci;
		POSITION    pos = pFileList->GetHeadPosition();
		POSITION    posLast;
		
		fci._fcb.fDirDel = fTrue;
		fci._fcb.fDel = fTrue;
		fci._op = FCItem::opFileChanged;

		while ( pos ) {
			// remove each file from the list and tell each client
			posLast = pos;
			CFileData * pFileData = (CFileData *) pFileList->GetNext ( pos );
			pFileList->RemoveAt ( posLast );
			fci._strFileName = *pFileData;
			pFileData->DoCallAlways ( &fci, _dwUser );
			pFileData->DoCallIfNotIgnore ( &fci, _dwUser );
			delete pFileData;
			}
		}

	// remove the whole list and dir entry
	unsigned    i = pFileList->_dwAux;
	unsigned    iLast = _mpDirsFilelist.GetCount();

	ASSERT ( i > 0 );   // can't be 0, since that is our ITC handle
	ASSERT ( i <= iLast );
	ASSERT ( _hts.rgh[ i ] );
	ASSERT ( _hts.rgpstr[ i ] );

	// remove entry from map
	VERIFY ( _mpDirsFilelist.RemoveKey ( *_hts.rgpstr[ i ] ) );
	delete pFileList;

	// cache the soon-to-be-removed directory string
	CString	*	pstrPath = _hts.rgpstr[ i ];

	// move the arrays so that they are packed
	memmove ( &_hts.rgh[ i ],    &_hts.rgh[ i + 1 ],    (iLast - i) * sizeof(HANDLE) );
	memmove ( &_hts.rgpstr[ i ], &_hts.rgpstr[ i + 1 ], (iLast - i) * sizeof(CString *) );
	_hts.rgh[ iLast ] = 0;
	_hts.rgpstr[ iLast ] = NULL;

	// close the change notification handle
	VERIFY ( ::FindCloseChangeNotification ( h ) );

	// fix up all the _dwAux records in each file list
	POSITION    pos = _mpDirsFilelist.GetStartPosition();

	while ( pos ) {
		CObject *   pObj;
		_mpDirsFilelist.GetNextAssoc ( pos, *pstrPath, pObj );
		ASSERT ( pObj );
		ASSERT ( pObj->IsKindOf(RUNTIME_CLASS(CPtrList)) );

		pFileList = (CSafePFileDataList *) pObj;
		if ( pFileList->_dwAux > i ) {
			pFileList->_dwAux--;
			}
		}
	delete pstrPath;
	}

//-----------------------------------------------------------------------------
//  CFileChange::PFileDataOverspill
//
//  Purpose:    find if a filedata object exists in our overspill list and
//				if so, return a pointer to it.
//
//  Input:      szFileName, name of file!
//
//-----------------------------------------------------------------------------
CFileData *
CFileChange::PFileDataOverspill ( LPCTSTR szFileName, POSITION & posCur ) {
	POSITION	pos = _listPFileDataEx.GetHeadPosition();
	while ( posCur = pos ) {
		CFileData *	pfile = (CFileData *) _listPFileDataEx.GetNext ( pos );
		if ( pfile && 0 == pfile->CompareNoCase ( szFileName ) ) {
			return pfile;
			}
		}
	return NULL;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FAddOverspillFile
//
//  Purpose:    Adds a filedata object into the overspill list.  If already in
//				the list, returns fFalse so caller can take appropriate action.
//				The callback is added into an existing one.
//
//  Input:      pFiledata
//
//-----------------------------------------------------------------------------
BOOL
CFileChange::FAddOverspillFile ( CFileData * pFiledata ) {
	debug(::OutputDebugString ( "Using manual overspill area for \"" ));
	debug(::OutputDebugString ( LPCTSTR(*pFiledata) ));
	debug(::OutputDebugString ( "\" change notifications.\n" ));

	POSITION	pos;
	CFileData *	pfile = PFileDataOverspill ( *pFiledata, pos );

	if ( pfile ) {
		pfile->MergeFileData ( pFiledata );
		return fFalse;
		}
	else {
		_listPFileDataEx.AddTail ( pFiledata );
		return fTrue;
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::DeleteOverspillFile
//
//  Purpose:    Removes a filedata object from the overspill list.
//
//  Input:      pFiledata
//
//-----------------------------------------------------------------------------
void
CFileChange::DeleteOverspillFile ( CFileData * pFiledata ) {
	POSITION	pos = _listPFileDataEx.Find ( pFiledata );
	if ( pos ) {
		_listPFileDataEx.RemoveAt ( pos );
		}
	delete pFiledata;
	}


//-----------------------------------------------------------------------------
//  CFileChange::DoCheckOverspillFiles
//
//  Purpose:    Iterate over the overspill files and check for changes...
//
//-----------------------------------------------------------------------------
void
CFileChange::DoCheckOverspillFiles() {
	POSITION	pos = _listPFileDataEx.GetHeadPosition();
	while ( pos ) {
		CFileData * pFile = (CFileData *) _listPFileDataEx.GetNext ( pos );
		DoCheckFile ( pFile );
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::FAddFileAsync
//
//  Purpose:    Add a file asynchronously to the file change list,
//				returns true if it is able to queue it up successfully.
//
//-----------------------------------------------------------------------------
BOOL
CFileChange::FAddFileAsync (
	LPCTSTR			szFile,
	PfnFCCallBack	pfnFCCallBack,
	PfnAsyncReturn	pfnAsyncReturn,
	PV				pvUser1 /* = NULL */,
	PV				pvUser2 /* = NULL */,
	BOOL			fCallAlways /*= fFalse */
	) {

	FCItem	fci;

	ASSERT ( szFile );
	ASSERT( 0 < _tcslen(szFile) );
	ASSERT ( pfnFCCallBack );

	fci._strFileName = szFile;
	fci._op = FCItem::opAdd;
	fci._fCallAlways = fCallAlways;
	fci._pfnFCCallBack = pfnFCCallBack;
	fci._pfnAsyncReturn = pfnAsyncReturn;
	fci._pvUser1 = pvUser1;
	fci._pvUser2 = pvUser2;

	IDEL	idelDummy;
	BOOL	fRet = _queueFCItem.put ( fci, idelDummy );
	_eventIn.Set();
	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::FDelFileAsync
//
//  Purpose:    Delete a file asynchronously to the file change list,
//				returns true if it is able to queue it up successfully.
//
//-----------------------------------------------------------------------------
BOOL
CFileChange::FDelFileAsync (
	LPCTSTR			szFile,
	PfnFCCallBack	pfnFCCallBack,
	PfnAsyncReturn	pfnAsyncReturn,
	PV				pvUser1 /* = NULL */,
	PV				pvUser2 /* = NULL */
	) {

	FCItem	fci;

	ASSERT ( szFile );
	ASSERT ( pfnFCCallBack );

	fci._strFileName = szFile;
	fci._op = FCItem::opDel;
	fci._pfnFCCallBack = pfnFCCallBack;
	fci._pfnAsyncReturn = pfnAsyncReturn;
	fci._pvUser1 = pvUser1;
	fci._pvUser2 = pvUser2;

	IDEL	idelDummy;
	BOOL	fRet = _queueFCItem.put ( fci, idelDummy );
	_eventIn.Set();
	return fRet;
	}

//-----------------------------------------------------------------------------
//  CFileChange::SetIdleMode
//
//  Purpose:    to tell the 2nd thread to raise or lower its priority,
//				generally in response to doing a build so the thread doesn't
//				compete so much with the background processes.
//
//-----------------------------------------------------------------------------
unsigned
CFileChange::SetIdleMode ( BOOL fIdle ) {

	CritSection	cs(_critsecPrty);
	unsigned	cIdlesPrev = _cIdles;

	if ( fIdle ) {
		_cIdles++;
		}
	else {
		_cIdles--;
		}
	
	if ( !cIdlesPrev && _cIdles ) {
		// signal 2nd thread to get it to go into its idle mode, just by doing
		// an FCItem::opNull operation.
		IDEL	idelDummy;
		FCItem	fci;
		
		_queueFCItem.put ( fci, idelDummy );
		_eventIn.Set();

		VERIFY ( ::SetThreadPriority ( _hThread, prtyIdle ) );
		}
	else if ( cIdlesPrev && !_cIdles ) {
		// give a boost to clear stuff out
		BoostPriority();

		// signal 2nd thread to get it to wake up, just by doing an
		// FCItem::opNull operation.
		IDEL	idelDummy;
		FCItem	fci;
		
		_queueFCItem.put ( fci, idelDummy );
		_eventIn.Set();
		::Sleep ( 0 );

		// put us back to normal.
		RestorePriority();
		}
	
	return cIdlesPrev;
	}

//-----------------------------------------------------------------------------
//  CFileChange::BoostPriority
//
//  Purpose:    boost the priority for quick response to clients
//
//-----------------------------------------------------------------------------
void
CFileChange::BoostPriority() {

	CritSection	cs(_critsecPrty);
	
	if ( 0 == _cBoosts++ ) {
		VERIFY ( ::SetThreadPriority ( _hThread, prtyAboveNormal ) );
		}
	}

//-----------------------------------------------------------------------------
//  CFileChange::RestorePriority
//
//  Purpose:    restore the priority to either our normal or idle state
//
//-----------------------------------------------------------------------------
void
CFileChange::RestorePriority() {

	CritSection	cs(_critsecPrty);
		
	if ( 0 == --_cBoosts ) {
		if ( _cIdles ) {
			VERIFY ( ::SetThreadPriority ( _hThread, prtyStandard ) );
			}
		else {
			VERIFY ( ::SetThreadPriority ( _hThread, prtyStandard ) );
			}
		}
	}

//-----------------------------------------------------------------------------
//  FFileInfo
//
//  Purpose:    replace _stat with one that does it via Win32 apis
//
//-----------------------------------------------------------------------------
BOOL
StatBuf::FGetFileInfo ( LPCTSTR szFile ) {
	HANDLE				hfind;
	BOOL				fRet = fFalse;	
	WIN32_FILE_ATTRIBUTE_DATA find;

	fcft.qwFiletime = 0;
	cbFile = 0;
	dwAttrs = 0;

	if (Compatible_GetFileAttributesEx( szFile, GetFileExInfoStandard, &find))
	{
		fcft.filetime = find.ftLastWriteTime;
		cbFile = find.nFileSizeLow + QWORD(find.nFileSizeHigh) * 0x100000000i64;
		dwAttrs = find.dwFileAttributes;
		if ( 0 == dwAttrs ) {
			// HACK: Win95 doesn't set the normal bit if
			//	no other attributes are set.
			dwAttrs = fattrNormal;
			}
		fRet = fTrue;
	}
	return fRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\filecmd.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Standard File Commands
//
// This file contains implementations for:
//
//	* File New
//	* File Open
//	* File Save All
//	* Recently opened files
//	* Recently opened projects
//
// Various related utilities are also included here.
//

#include "stdafx.h"
#include "docobtpl.h"
#include <dlgs.h>
#include "shell.h"
#include "resource.h"
#include "filenew.h"
#include "barglob.h"

#include <sys/types.h>
#include <sys/stat.h>

#include "toolexpt.h"
#include "shellrec.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////

static BOOL fForceAddToProject = FALSE;
static BOOL fForceShowProjectTab = FALSE;

void CTheApp::OnFileNew()
{
	BOOL fDialogDone = FALSE;
	BOOL fBackButton = FALSE;

	while (!fDialogDone)
	{
		CFileNewTabbedDialog dlg(fBackButton, fForceAddToProject, fForceShowProjectTab);
		if (dlg.DoModal() == IDOK)
		{
			if (dlg.GetType() == CPartTemplate::newfile || dlg.GetType() == CPartTemplate::newother)
			{
				fDialogDone = TRUE;
				CPartTemplate *pTemplate = (CPartTemplate *)dlg.GetTemplate();
				ASSERT(pTemplate != NULL);
				ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
				CString strFileName   = dlg.GetFileName();
				CString strPathName   = dlg.GetPathName();
				IPkgProject *pProject = dlg.GetProject(); // Un-AddRefed

				if (!strFileName.IsEmpty())
				{
					if (strPathName.IsEmpty())
						strPathName = ".";

					CDir dir;
					dir.CreateFromStringEx(strPathName, TRUE);
					CPath path;
					path.CreateFromDirAndFilename(dir, (LPCTSTR)strFileName);

					// if extension not provided for file, use default from doctemplate
					if (_tcslen(path.GetExtension()) == 0)
					{
						CString strExtension;
						pTemplate->GetDocString(strExtension, CDocTemplate::filterExt);
						path.ChangeExtension(strExtension);
					}

					if (dlg.GetType() == CPartTemplate::newfile)
					{
						CDocument *pOpenDoc;
						CDocTemplate *pOpenTemplate = theApp.GetOpenTemplate((LPCTSTR)path, pOpenDoc);
						if ((pOpenTemplate != NULL) && (pOpenDoc != NULL))
						{
							ASSERT(pOpenDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));
							((CPartDoc*)pOpenDoc)->OnCloseDocument();
						}

						pTemplate->NewDocumentFile((LPCTSTR)path, pProject, NULL);
					}
					else	// DocObject file
					{
						CDocument *pOpenDoc;
						CDocTemplate *pOpenTemplate = theApp.GetOpenTemplate((LPCTSTR)path, pOpenDoc);
						if ((pOpenTemplate != NULL) && (pOpenDoc != NULL))
						{
							ASSERT(pOpenDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));
							if (((CPartDoc *)pOpenDoc)->AttemptCloseDoc())
							{
								((CPartDoc*)pOpenDoc)->OnCloseDocument();
								pTemplate->NewDocumentFile((LPCTSTR)path, pProject, NULL);
							}
						}
						else
							pTemplate->NewDocumentFile((LPCTSTR)path, pProject, NULL);
					}
				}
				else
				{
					pTemplate->NewDocumentFile((LPCTSTR)"", NULL, NULL);
				}
			}
			else if (dlg.GetType() == CPartTemplate::newtemplate)
			{
				fDialogDone = TRUE;
			}
			else if (dlg.GetType() == CPartTemplate::newproject)
			{
				USES_CONVERSION;

				fDialogDone = TRUE;
				CString strPathName = dlg.GetPathName();
				CString strFileName = dlg.GetFileName();
				CDir dir;
				dir.CreateFromStringEx(strPathName, TRUE);
				CPath path;
				CString strPath = dir;
				// If strPath's length is 3, then we have a C:\ situation. Shouldn't add \ to it
				if(strPath.GetLength() > 3)
					strPath += "\\";
				strPath += strFileName;
				BOOL fCanCreate;

				IProjectWorkspace *pInterface;
				pInterface = g_IdeInterface.GetProjectWorkspace();
				ASSERT(pInterface != NULL);

				if (SUCCEEDED(dlg.GetProjectProvider()->CanCreateProject(T2W(strPath), dlg.GetProjectType(), &fCanCreate)) && fCanCreate)
				{
					COleRef<IPkgProject> pProject;
					DWORD dwRetVal;
					if (dlg.GetCreateNew())
					{
						CDocument *pDoc;
						// workspace creation will create the directory if necessary
						if ((SUCCEEDED(pInterface->CreateEmptyWorkspace(&pDoc, strPath))) && (pDoc != NULL))
						{
							// REVIEW [patbr]: extension can be project specific!
							strFileName += _T(BUILDER_EXT);
							path.CreateFromDirAndFilename(dir, (LPCTSTR)strFileName);
							
							VERIFY(SUCCEEDED(dlg.GetProjectProvider()->CreateProject(T2W(path), dlg.GetProjectType(), &pProject, &dwRetVal)));
							if (dwRetVal == CREATE_PROJ_OK)
							{
								VERIFY(SUCCEEDED(pInterface->AddProject(pProject, TRUE)));
								theApp.NotifyPackages(PN_NEW_PROJECT, (void *)pProject);
								theApp.NotifyPackages(PN_WORKSPACE_INIT, (void *)(const TCHAR *)path);
								pInterface->SetActiveProject(pProject, TRUE);
								// force Project Workspace window visible
								DkWShowWindow(MAKEDOCKID(PACKAGE_PRJSYS, IDDW_PROJECT), TRUE);
							}
							else if (dwRetVal == CREATE_PROJ_RERUN_PROMPT)
							{
								VERIFY(SUCCEEDED(pInterface->CloseWorkspace()));
								// remove newly created MDP and OPT files from disk.
								path.ChangeExtension(WORKSPACE_EXT);
								if (_access(path, 00) == 0)
									VERIFY(path.DeleteFromDisk());
								path.ChangeExtension(WSOPTIONS_EXT);
								if (_access(path, 00) == 0)
									VERIFY(path.DeleteFromDisk());
								// attempt to delete directory from disk--it may be empty.
								dir.RemoveFromDisk();

								// remove the filename from the workspace MRU list.
								int iCount = m_pRecentProjectList->GetSize();
								for (int i = 0; i < iCount; i++)
								{
									CString strMRU;
									strMRU = (*(m_pRecentProjectList))[i];

									char szPath[_MAX_PATH], szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
									_splitpath(path.GetFullPath(), szDrive, szDir, szFName, szExt);
									_makepath(szPath, szDrive, szDir, szFName, NULL);

									if (!(strMRU.CompareNoCase(szPath)))
									{
										m_pRecentProjectList->Remove(i);
										break;
									}
								}

								fDialogDone = FALSE;
								fBackButton = TRUE;
							}
							else if (dwRetVal == CREATE_PROJ_CANCEL)
							{
								// remove newly created MDP and OPT files from disk.
								VERIFY(SUCCEEDED(pInterface->CloseWorkspace()));
								path.ChangeExtension(WORKSPACE_EXT);
								if (_access(path, 00) == 0)
									VERIFY(path.DeleteFromDisk());
								path.ChangeExtension(WSOPTIONS_EXT);
								if (_access(path, 00) == 0)
									VERIFY(path.DeleteFromDisk());
								// attempt to delete directory from disk--it may be empty.
								dir.RemoveFromDisk();

								// remove the filename from the workspace MRU list.
								int iCount = m_pRecentProjectList->GetSize();
								for (int i = 0; i < iCount; i++)
								{
									CString strMRU;
									strMRU = (*(m_pRecentProjectList))[i];

									char szPath[_MAX_PATH], szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
									_splitpath(path.GetFullPath(), szDrive, szDir, szFName, szExt);
									_makepath(szPath, szDrive, szDir, szFName, NULL);

									if (!(strMRU.CompareNoCase(szPath)))
									{
										m_pRecentProjectList->Remove(i);
										break;
									}
								}
							}
						}
						else
						{
							// could not create empty workspace, probably because a package
							// returned FALSE from the PN_QUERY_NEW_WORKSPACE notification.
							MsgBox(Error, IDS_FAIL_NEW_WORKSPACE);
						}
					}
					else
					{
						// create the directory for the project if necessary
						if (!dir.ExistsOnDisk())
							VERIFY(dir.CreateOnDisk());

						BOOL fWorkspaceEmpty = TRUE;
						// if there are no projects in the workspace then freeze the
						// project workspace window while project is being added...
						COleRef<IPkgProject> pActiveProject;
						pInterface->GetActiveProject(&pActiveProject);
						if (pActiveProject != NULL)
							fWorkspaceEmpty = FALSE;

						// REVIEW [patbr]: extension can be project specific!
						strFileName += _T(BUILDER_EXT);
						path.CreateFromDirAndFilename(dir, (LPCTSTR)strFileName);


						VERIFY(SUCCEEDED(dlg.GetProjectProvider()->CreateProject(T2W(path), dlg.GetProjectType(), &pProject, &dwRetVal)));
						if (dwRetVal == CREATE_PROJ_OK)
						{
							// REVIEW [patbr]: freezing workspace window causes it to not paint during wizards
							COleRef<IProjectWorkspaceWindow> pPrjWksWin;
							pPrjWksWin = NULL;
							if (fWorkspaceEmpty && SUCCEEDED(FindInterface(IID_IProjectWorkspaceWindow, (LPVOID FAR *)&pPrjWksWin)) && (pPrjWksWin != NULL))
								pPrjWksWin->FreezeContainingPane(NULL);

							VERIFY(SUCCEEDED(pInterface->AddProject(pProject, TRUE)));
							IPkgProject *pDependentProject = dlg.GetProject();
							if (pDependentProject != NULL)
							{
								HRESULT hr = pProject->SetDependentProject(pDependentProject);
								ASSERT(SUCCEEDED(hr) || hr == E_NOTIMPL);
								if (hr == E_NOTIMPL)
									MsgBox(Error, IDS_PROJECT_NOT_DEPENDENT);
							}
							theApp.NotifyPackages(PN_NEW_PROJECT, (void *)pProject);
							pInterface->SetActiveProject(pProject, TRUE);

							if (fWorkspaceEmpty && (pPrjWksWin != NULL))
								pPrjWksWin->ThawContainingPane(NULL);

							// force Project Workspace window visible
							DkWShowWindow(MAKEDOCKID(PACKAGE_PRJSYS, IDDW_PROJECT), TRUE);
						}
						else if (dwRetVal == CREATE_PROJ_RERUN_PROMPT)
						{
							// remove newly created MDP and OPT files from disk.
							path.ChangeExtension(WORKSPACE_EXT);
							if (_access(path, 00) == 0)
								VERIFY(path.DeleteFromDisk());
							path.ChangeExtension(WSOPTIONS_EXT);
							if (_access(path, 00) == 0)
								VERIFY(path.DeleteFromDisk());
							// attempt to delete directory from disk--it may be empty.
							dir.RemoveFromDisk();

							// remove the filename from the workspace MRU list.
							int iCount = m_pRecentProjectList->GetSize();
							for (int i = 0; i < iCount; i++)
							{
								CString strMRU;
								strMRU = (*(m_pRecentProjectList))[i];

								char szPath[_MAX_PATH], szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
								_splitpath(path.GetFullPath(), szDrive, szDir, szFName, szExt);
								_makepath(szPath, szDrive, szDir, szFName, NULL);

								if (!(strMRU.CompareNoCase(szPath)))
								{
									m_pRecentProjectList->Remove(i);
									break;
								}
							}

							fDialogDone = FALSE;
							fBackButton = TRUE;
						}
					}
				}
				else
				{
					fDialogDone = FALSE;
					fBackButton = TRUE;
				}
				pInterface->ReleaseProjectTypeInfo();
			}
			else if (dlg.GetType() == CPartTemplate::newworkspace)
			{
				fDialogDone = TRUE;
				CPartTemplate *pTemplate = (CPartTemplate *)dlg.GetTemplate();
				ASSERT(pTemplate != NULL);
				ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
				CString strFileName   = dlg.GetFileName();
				CString strPathName   = dlg.GetPathName();

				if (strPathName.IsEmpty())
					strPathName = ".";

				CDir dir;
				dir.CreateFromStringEx(strPathName, TRUE);
				CPath path;
				path.CreateFromDirAndFilename(dir, (LPCTSTR)strFileName);

				COleRef<IProjectWorkspace> pInterface;
				VERIFY(SUCCEEDED(theApp.FindInterface(IID_IProjectWorkspace, (LPVOID FAR *)&pInterface)));
				ASSERT(pInterface != NULL);

				CDocument *pDoc;
				// workspace creation will create the directory if necessary
				VERIFY(SUCCEEDED(pInterface->CreateEmptyWorkspace(&pDoc, path)));
				if (pDoc != NULL)
				{
					theApp.NotifyPackages(PN_WORKSPACE_INIT, (void *)(const TCHAR *)path);
				}
				else
				{
					// could not create empty workspace, probably because a package
					// returned FALSE from the PN_QUERY_NEW_WORKSPACE notification.
					MsgBox(Error, IDS_FAIL_NEW_WORKSPACE);
				}
			}
		}
		else
			fDialogDone = TRUE;
	}
}

void CTheApp::OnFileNewInProject()
{
	fForceAddToProject = TRUE;
	OnFileNew();
	fForceAddToProject = FALSE;
}

void CTheApp::OnFileNewProject(BOOL fAddToWks)
{
	fForceAddToProject = fAddToWks;
	fForceShowProjectTab = TRUE;
	OnFileNew();
	fForceShowProjectTab = FALSE;
	fForceAddToProject = FALSE;
}

void CTheApp::OnInsertFiles()
{
	CAddFilesDialog dlg;
	if (dlg.DoModal() == IDOK)
	{
		USES_CONVERSION;

		int iMaxFile = dlg.m_saFileNames.GetSize();
		if (iMaxFile > 0)
		{
			LPOLESTR *ppszFiles = new LPOLESTR[iMaxFile];
			for (int iFile = 0; iFile < iMaxFile; iFile++)
			{
				LPOLESTR wstr = T2W(dlg.m_saFileNames[iFile]);
				ppszFiles[iFile] = (LPOLESTR)malloc((wcslen(wstr)+1) * sizeof(wchar_t));
				wcscpy(ppszFiles[iFile], wstr);
			}
			LPCOLESTR pszDefaultFolder = NULL;
			VERIFY(SUCCEEDED(dlg.GetProject()->AddFiles((LPCOLESTR *)ppszFiles, iMaxFile, NULL)));
			for (iFile = 0; iFile < iMaxFile; iFile++)
				free(ppszFiles[iFile]);
			delete[] ppszFiles;
		}
	}
}

CDocTemplate* CTheApp::GetTemplateFromEditor(UINT idsEditor, const char* szFilename)
{
	CDocTemplate* pTemplate = NULL;
	POSITION pos = m_packages.GetHeadPosition();
	while( pos != NULL )
	{
		CPackage* pPackage = (CPackage*)m_packages.GetNext(pos);
		if( (pTemplate = pPackage->GetTemplateFromEditor(idsEditor, szFilename))
			!= NULL )
		{
			break;
		}
	}
	return pTemplate;
}

extern CPartDoc* ActivateExistingDoc(LPCTSTR lpszFileName,
	CDocTemplate* pTemplate)
{
	CDocument* pOpenDoc;
	CDocTemplate* pOpenTemplate =
		theApp.GetOpenTemplate(lpszFileName, pOpenDoc);

	if (pOpenTemplate == NULL)
		return NULL;

	ASSERT(pOpenDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));

	((CPartDoc*) pOpenDoc)->ActivateDoc();

	if (pTemplate != NULL && pTemplate != pOpenTemplate)
	{
		if (((CPartDoc*) pOpenDoc)->AttemptCloseDoc())
			return NULL;
	}

	return (CPartDoc*) pOpenDoc;
}

void CTheApp::OnFileOpen()
{
	// prompt the user (with all document templates)
	CStringArray saFileNames;
//	CFileOpenReturn forUserInput;
	UINT nOpenAsEditor;
	BOOL bReadOnly = FALSE;
	if (!DoPromptFileOpen(saFileNames, AFX_IDS_OPENFILE,
		OFN_OVERWRITEPROMPT | OFN_ALLOWMULTISELECT, NULL, &nOpenAsEditor, &bReadOnly))
		return; // open cancelled

	CString strFileName;
	for( int iFile = 0; iFile < saFileNames.GetSize(); iFile++)
	{
		strFileName = saFileNames[iFile];

		CString strFileTemp = strFileName;
		// don't do MakeUpper on the original file name--this mangles MBCS characters
		strFileTemp.MakeUpper();
		int nIndex;
		// check for indications that this is a UNC or URL path name and adjust if necessary
		if ((nIndex = strFileTemp.Find("\\\\\\")) != -1)
		{
			strFileName = strFileName.Right(strFileName.GetLength() - nIndex - 1);
		}
		else if ((nIndex = strFileTemp.Find("FILE:")) != -1)
		{
			strFileName = strFileName.Right(strFileName.GetLength() - nIndex);
		}
		else if ((nIndex = strFileTemp.Find("HTTP:")) != -1)
		{
			strFileName = strFileName.Right(strFileName.GetLength() - nIndex);
		}

		// Change the case of the file to match the actual file
		GetActualFileCase( strFileName );

		CPartDoc* pDocument = NULL;

		// Determine which doc-template to use.
		CDocTemplate* pTemplate = GetTemplateFromEditor(nOpenAsEditor, strFileName);

		if (!OpenFile(pTemplate, strFileName, bReadOnly))
		{
			// If we can't open the filename, then stop.
			break ;
		};
/*
		if (pTemplate == NULL)		// auto
			pDocument = (CPartDoc*)OpenDocumentFile(strFileName);
		else if (ActivateExistingDoc(strFileName, pTemplate) != NULL)
			continue;
		else						// open using a specific editor
			pDocument = (CPartDoc*)pTemplate->OpenDocumentFile(strFileName);

		if (bReadOnly && pDocument != NULL)
			pDocument->SetReadOnly();

		if (pDocument == NULL)
			break;	// Assume something is terribly wrong and *bail out*.
*/
	}
}

//
// Called by Documents.Open and CTheApp.OnFileOpen to open a file.
//
CDocument* CTheApp::OpenFile(	CDocTemplate* pTemplate, // Pointer to the template which opens the file. Can be Null.
								CString strFileName,	 // Filename to open.
								BOOL bReadOnly)		 // True if the file should be marked readonly
{
	CPartDoc* pDocument = NULL ;

	if (pTemplate == NULL)
	{
		// Open using the Auto type.
		pDocument = (CPartDoc*)OpenDocumentFile(strFileName);
	}
	else 
	{
		CPartDoc* pExistingDoc = ActivateExistingDoc(strFileName, pTemplate) ;
		if ( pExistingDoc == NULL)
		{
			// Open using a specific editor.
			pDocument = (CPartDoc*)pTemplate->OpenDocumentFile(strFileName);
		}
		else 
		{
			// Notice this function does not return null if the file already exitst.
			return pExistingDoc ;
		}
	}

	if (bReadOnly && pDocument != NULL)
	{
		pDocument->SetReadOnly();
	}

	return pDocument ;
}

CDocument* CTheApp::OpenDocumentFile(LPCSTR lpszFileName)
{
	CDocument* pDocument = ActivateExistingDoc(lpszFileName, NULL);
	if (pDocument == NULL)
		pDocument = CWinApp::OpenDocumentFile(lpszFileName);

	// FUTURE: Bug 1031 needs a message box here when file doesn't exist...

	// FUTURE: Maybe remove binary editor from MatchDocType loop and
	// lookup file associations before trying it here...

	return pDocument;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class for handling IDIS compatible file dialogs.
//
class CIdisFileDialog : public C3dFileDialog
{
public:
	CIdisFileDialog(BOOL bOpenFileDialog,
		CDocument *pCurrentDoc = NULL,
		LPCSTR lpszDefExt = NULL,
		LPCSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_SHOWHELP,
		LPCSTR lpszFilter = NULL,
		CWnd* pParentWnd = NULL,
		UINT nHelpID = 0);

	virtual BOOL OnInitDialog();
 	virtual BOOL OnFileNameOK();
	afx_msg void OnSelChangeFilter();
	afx_msg void OnTypeChange(UINT idCtl, NMHDR* pNMHDR, LRESULT* pResult);

	CPtrArray* m_ppaEditors;
	UINT m_nOpenAsEditor;
	CString m_strCurrentExt;
	CDocument *m_pCurrentDoc;

protected:
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CIdisFileDialog, C3dFileDialog)
	ON_CBN_SELCHANGE(cmb1, OnSelChangeFilter)
	ON_NOTIFY_RANGE(CDN_TYPECHANGE, 0, 0xffff, OnTypeChange)
END_MESSAGE_MAP()


CIdisFileDialog::CIdisFileDialog(BOOL bOpenFileDialog, CDocument *pCurrentDoc, LPCSTR lpszDefExt,
	LPCSTR lpszFileName, DWORD dwFlags, LPCSTR lpszFilter, CWnd* pParentWnd,
	UINT nHelpID)
: C3dFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
	dwFlags, lpszFilter, pParentWnd,
	(nHelpID != 0 ? nHelpID : (bOpenFileDialog ? IDD_CHICAGO_FILEOPEN : IDD_FILE_SAVE_AS)))
{
	m_ofn.hInstance = GetResourceHandle();
	m_pCurrentDoc = pCurrentDoc;

	if( bOpenFileDialog )
	{
		m_iddWin95 = IDD_CHICAGO_FILEOPEN;
		m_iddWinNT = IDD_CHICAGO_FILEOPEN;
		m_ofn.Flags &= ~OFN_HIDEREADONLY;
	} 
	else
	{
		ASSERT(m_pCurrentDoc != NULL);
		m_iddWin95 = NULL;
		m_iddWinNT = NULL;
		m_ofn.Flags |= OFN_HIDEREADONLY;
	}
}

BOOL CIdisFileDialog::OnInitDialog()
{
	if (m_bOpenFileDialog)
	{
		CComboBox* pOpenAs = (CComboBox*)GetDlgItem(IDC_EDITOR);
		ASSERT( pOpenAs != NULL );

		if( !IsExplorer() )
		{
			// non-Chicago dialog has read-only checkbox hidden
			CWnd* pReadOnly = GetDlgItem(chx1);
			pReadOnly->ShowWindow(SW_SHOWNOACTIVATE);
			pReadOnly->EnableWindow(TRUE);

			// same goes for OpenAs Edit Combo
			pOpenAs->ShowWindow(SW_SHOWNOACTIVATE);
			pOpenAs->EnableWindow(TRUE);
			CWnd * pOpenAsCap = GetDlgItem(IDC_EDITOR_CAP);
			pOpenAsCap->ShowWindow(SW_SHOWNOACTIVATE);
			pOpenAsCap->EnableWindow(TRUE);
		}
		else
		{
			// resize the commdlg controls slightly for long filter strings, and
			// position the Open As combo directly below the Filters combo
			CRect rcFileName, rcOpenAs, rcFilters, rcOpenAsTxt, rcFilterTxt;
			pOpenAs->GetWindowRect(&rcOpenAs);

			CWnd *pFileName = GetParent()->GetDlgItem(edt1);
			ASSERT(pFileName != NULL);			// File name edit
			pFileName->GetWindowRect(&rcFileName);
			rcFileName.right += 5;
			pFileName->SetWindowPos(NULL, rcFileName.left, rcFileName.top, rcFileName.right - rcFileName.left,
				rcFileName.bottom - rcFileName.top, SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOZORDER | SWP_SHOWWINDOW);

			CWnd* pFilters = GetParent()->GetDlgItem(cmb1);		// List files of type combo
			ASSERT( pFilters != NULL );
			pFilters->GetWindowRect(&rcFilters);
			rcFilters.right += 5;
			pFilters->SetWindowPos(NULL, rcFilters.left, rcFilters.top, rcFilters.right - rcFilters.left,
				rcFilters.bottom - rcFilters.top, SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOZORDER | SWP_SHOWWINDOW);

			CWnd* pFilterTxt = GetParent()->GetDlgItem(stc2);	// List files of type caption
			ASSERT( pFilterTxt != NULL );
			pFilterTxt->GetWindowRect(&rcFilterTxt);

			CWnd* pOpenAsTxt = GetDlgItem(IDC_EDITOR_CAP);	// Open As caption
			ASSERT( pOpenAsTxt != NULL );
			pOpenAsTxt->GetWindowRect(&rcOpenAsTxt);

			rcOpenAsTxt.left = rcFilterTxt.left;
			rcOpenAsTxt.right = rcFilterTxt.right;
			ScreenToClient(&rcOpenAsTxt);
			pOpenAsTxt->MoveWindow(&rcOpenAsTxt);

			rcOpenAs.left = rcFilters.left;
			rcOpenAs.right = rcFilters.right;
			ScreenToClient(&rcOpenAs);
			pOpenAs->MoveWindow(&rcOpenAs);
		}

		for( int nEd = 0; nEd < m_ppaEditors->GetSize(); nEd++ )
		{
			SRankedStringID* prsi = (SRankedStringID*)m_ppaEditors->GetAt(nEd);
			CString strEd;
			strEd.LoadString(prsi->ids);
			int nIndex = pOpenAs->AddString(strEd);
			pOpenAs->SetItemData(nIndex, prsi->ids);
		}

		pOpenAs->SetCurSel(0);
	}
	else
	{
		if( !IsExplorer() )
		{
			GetDlgItem(IDC_EDITOR_CAP)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_EDITOR)->ShowWindow(SW_HIDE);
			GetDlgItem(chx1)->ShowWindow(SW_HIDE);  // Read-only checkbox.
			
			CString strSaveType;
			strSaveType.LoadString(IDS_SAVE_FILE_AS_TYPE);
			GetDlgItem(stc2)->SetWindowText(strSaveType);
		}
	}

	return C3dFileDialog::OnInitDialog();
}

static IsInFilterList(CDocTemplate* pTemplate, const CPtrArray& paEditors)
{
	int nEditors = paEditors.GetSize();
	for (int i = 0; i < nEditors; i++)
	{
		SRankedStringID* prsi = (SRankedStringID *)	paEditors[i];
		if (pTemplate == theApp.GetTemplateFromEditor(prsi->ids, NULL))
			return TRUE;
	}

	return FALSE;
}

BOOL CIdisFileDialog::OnFileNameOK()
{
	// tack on default extension, if no extension present
	if (!m_bOpenFileDialog && !m_strCurrentExt.IsEmpty())
	{
		// make sure save filename is of legal length
		if (_tcslen(m_ofn.lpstrFile) + m_strCurrentExt.GetLength() >= _MAX_PATH-1)
		{
			CString strFileName = m_ofn.lpstrFile;
			strFileName += m_strCurrentExt;
			ErrorBox(ERR_File_Invalid_Length, strFileName);
			return TRUE; // Don't let the dialog go away!
		}

		char acExt[_MAX_EXT];
		_splitpath(m_ofn.lpstrFile, NULL, NULL, NULL, acExt);
		if ((*acExt == '\0') || ((*acExt == '.') && (_tcslen(acExt) == 1)))
		{
			LPSTR pchEnd = m_ofn.lpstrFile + strlen(m_ofn.lpstrFile);
			strcpy(pchEnd, (LPCSTR)m_strCurrentExt);
		}
	}

	BOOL bError = C3dFileDialog::OnFileNameOK();

	// we don't get OnOK anymore, so do this stuff here.
	if( m_bOpenFileDialog )
	{
		CComboBox* pOpenEditor = (CComboBox*)GetDlgItem(IDC_EDITOR);
		ASSERT( pOpenEditor != NULL );
		int nIndex = pOpenEditor->GetCurSel();
		m_nOpenAsEditor = pOpenEditor->GetItemData(nIndex);

		// Check to see if it is a workspace document type, and only
		// allow single selection if it is.
		int nFiles = (m_psaFileNames == NULL) ?
			1 : m_psaFileNames->GetSize();

		if (nFiles > 1)
		{
			// Do not allow the user to open more than one workspace file.

			CPtrArray paWorkspaceEditors;
			CDocTemplate* pTemplate;
			BOOL bOnlyOne = FALSE;
			BOOL bProject = FALSE;
			CString strFileName;

			CString strFilter;
			theApp.BuildFilterList(strFilter, &paWorkspaceEditors,
				CPackage::GODI_WORKSPACEOPEN);

			pTemplate = theApp.GetTemplateFromEditor(m_nOpenAsEditor, NULL);
			bOnlyOne = (nIndex != 0) &&
				(pTemplate == theApp.GetTemplate(CLSID_WorkspaceDocument) ||
				IsInFilterList(pTemplate, paWorkspaceEditors));

			for( int iFile = 0; iFile < nFiles; iFile++ )
			{
				strFileName = m_psaFileNames->GetAt(iFile);

				bError = bOnlyOne && iFile > 0;

				if (nIndex == 0)
				{
					// Will 'auto' open this as a project?
					CDocTemplate* pBestTemplate = NULL;
					CDocTemplate::Confidence bestMatch = CDocTemplate::noAttempt;
					CDocument* pOpenDocument;

					POSITION pos = theApp.GetFirstDocTemplatePosition();
					while (pos)
					{
						pTemplate = theApp.GetNextDocTemplate(pos);
						ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

						CDocTemplate::Confidence match;
						match = pTemplate->MatchDocType(strFileName, pOpenDocument);
						if (match > bestMatch)
						{
							bestMatch = match;
							pBestTemplate = pTemplate;
						}
						if (match == CDocTemplate::yesAlreadyOpen)
							break;      // stop here
					}
					
					if (bestMatch != CDocTemplate::noAttempt &&
						(pBestTemplate == theApp.GetTemplate(CLSID_WorkspaceDocument) ||
						IsInFilterList(pBestTemplate, paWorkspaceEditors)))
					{
						bError = bProject;
						bProject = TRUE;
					}
				}

				if (bError)
				{
					ErrorBox(ERR_MultipleMakes, strFileName);
	   				return TRUE;    // don't allow dialog to close
				}
			}
		}
	}

	if (m_bOpenFileDialog || bError)
		return bError;

	// Here we do the work that OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT
	// would normally be used for as well as make sure the user doesn't
	// try to overwrite an open file.  We can't use those flags because
	// in the case where the user is trying to save over some other open
	// file, they would get two warnings...

	CDocument* pOpenDoc = NULL;
	CDocTemplate* pOpenTemplate = theApp.GetOpenTemplate(m_ofn.lpstrFile, pOpenDoc);

	// Note: No longer assumes we are performing save as on the active document. [olympus 14704]
	if (pOpenDoc != NULL &&
		pOpenDoc != m_pCurrentDoc)
	{
		// "File already open"
		ErrorBox(ERR_File_Already_Open, m_ofn.lpstrFile);
		return TRUE; // Don't let the dialog go away!
	}

	// On NT, CommDlg will have already checked to see if the file is writable
	// by creating a zero-sized archive file, that it doesn't clean up.
    CFileStatus fs;
	BOOL bExists = CFile::GetStatus(m_ofn.lpstrFile, fs) && (IsExplorer()
		|| (fs.m_size != 0) || !(fs.m_attribute == CFile::archive));
	if( bExists )
	{
		if ((fs.m_attribute & CFile::readOnly) != 0)
		{
			// "File is read-only."
			ErrorBox(ERR_File_Read_Only, m_ofn.lpstrFile);
			return TRUE; // Don't let the dialog go away!
		}

		// "Replace existing file?"
		if (QuestionBox(ERR_File_Exists,
			MB_YESNO | MB_DEFBUTTON2,
			m_ofn.lpstrFile) != IDYES)
		{
			return TRUE; // Don't let the dialog go away!
		}
	}

	return FALSE;
}

void CIdisFileDialog::OnSelChangeFilter()
{
	if( m_bOpenFileDialog )
	{
		Default();				// the Open dialog hasn't changed
		return;
	}

	// get new filter index
	CComboBox* pCombo = (CComboBox*)(IsExplorer() ? 
		GetParent()->GetDlgItem(cmb1) : GetDlgItem(cmb1));
	ASSERT( pCombo != NULL );
	int nSel = pCombo->GetCurSel();
	// get extension from filter string array
	CString strFilter = GetFilterExtension(nSel);

	// extract extension (use first if more than one)
	CStringArray saFilterExt;
	LPCTSTR pch = strFilter;
	while( *pch != '\0' )
	{
		// find beginning of extension
		LPCTSTR pchDot = _tcschr(pch, '.');
		if( pchDot == NULL )
			break;

		// find end of extension (semicolon, space, or EOL)
		LPCTSTR pchSemi = pchDot;
		while( (*pchSemi != '\0') && (*pchSemi != ';') && !isspace(*pchSemi) )
			pchSemi = _tcsinc(pchSemi);

		// add the extension to the array, including the dot
		saFilterExt.Add(CString(pchDot, pchSemi - pchDot));
		pch = pchSemi;
	}

	static char acFilterExt[_MAX_EXT];
	if( saFilterExt.GetSize() == 0 )
		*acFilterExt = '\0';
	else
		strcpy(acFilterExt, saFilterExt[0]);
	if( *acFilterExt != '\0' )
	{
		ASSERT( *acFilterExt == '.' );
		m_ofn.lpstrDefExt = acFilterExt + 1;
		if( (_tcschr(m_ofn.lpstrDefExt, '*') != NULL) ||
			(_tcschr(m_ofn.lpstrDefExt, '?') != NULL) )
		{
			if( IsExplorer() || m_strCurrentExt.IsEmpty() )
				m_ofn.lpstrDefExt = NULL;
			else
				m_ofn.lpstrDefExt = ((LPCSTR)m_strCurrentExt) + 1;
			return;
		}
	}
	else
		m_ofn.lpstrDefExt = NULL;

	// get current filename
	CWnd* pFileName = IsExplorer() ? GetParent()->GetDlgItem(edt1)
		: GetDlgItem(edt1);
	ASSERT( pFileName != NULL );
	CString strFileName;
	pFileName->GetWindowText(strFileName);

	char acDrive[_MAX_DRIVE];
	char acDir[_MAX_DIR];
	char acName[_MAX_FNAME];
	char acExt[_MAX_EXT];
	_splitpath(strFileName,acDrive, acDir, acName, acExt);

	// if the file is already using *any* of the extensions, leave it alone
	for( int n = 0; n < saFilterExt.GetSize(); n++ )
	{
		if( _tcsicmp(saFilterExt[n], acExt) == 0 )
			return;
	}

	// otherwise coerce it to the primary (first) extension from the filter
	strFileName = acDrive;
	strFileName += acDir;
	strFileName += acName;
	strFileName += acFilterExt;

	pFileName->SetWindowText(strFileName);
}

void CIdisFileDialog::OnTypeChange(UINT idCtl, NMHDR* pNMHDR, LRESULT* pResult)
{
	OnSelChangeFilter();
}

static void AppendFilterSuffix(CString& filter, OPENFILENAME& ofn,
	CDocTemplate* pTemplate, CString* pstrDefaultExt)
{
	ASSERT_VALID(pTemplate);
	ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CDocTemplate)));

	CString strDefaultExt, strFilterName;
	if (pTemplate->GetDocString(strDefaultExt, CDocTemplate::filterExt) &&
	 !strDefaultExt.IsEmpty() &&
	 pTemplate->GetDocString(strFilterName, CDocTemplate::filterName) &&
	 !strFilterName.IsEmpty())
	{
		// a file based document template - add to filter list
		ASSERT(strDefaultExt[0] == '.');
		if (pstrDefaultExt != NULL)
		{
			// set the default extension
			*pstrDefaultExt = ((LPCTSTR)strDefaultExt) + 1;  // skip the '.'
			ofn.lpstrDefExt = (LPTSTR)(LPCTSTR)(*pstrDefaultExt);
			ofn.nFilterIndex = ofn.nMaxCustFilter + 1;  // 1 based number
		}

		// add to filter
		AppendFilterSuffix(filter, ofn, strFilterName);
	}
}


// File dialog filters may be specified in the registry by adding a key
// called "File Filters" to the "Visual C++ 2.0" key.  This key contains
// values with names of the form "Filter<n>" where <n> starts at 1.  The
// range of <n> must be contiguous.  Each value specifies one file filter
// in the form of "<class>,<filter>" where class is a number representing
// which dialogs the filter should be used in and <filter> specifies the text
// that will be seen in the "List Files of Type" dropdown in the file dialog.
//
// Each bit of <class> specifies a class of file dialog that filters will
// appear in.  Filters may appear in more than one class of dialog by
// specifying or'd class bits in the registry.  The FLT_ values defined in
// dlgbase.h describe the bit values for each class.

const char szFileFiltersKey [] = _TEXT("File Filters");

BOOL AddRegistryFilters(CString& strFilter, int nDesiredType, OPENFILENAME& ofn)
{
	BOOL bAddedFilter = FALSE;
	CString strTemp;
	for (int i = 1; ; i += 1)
	{
		TCHAR szName [40];
		wsprintf(szName, _TEXT("Filter%d"), i);
		strTemp = GetRegString(szFileFiltersKey, szName);
		if (strTemp.IsEmpty())
			break;

		char* szFilter = NULL;
		long nType = _tcstol(strTemp, &szFilter, 0);
		if (szFilter == NULL || *szFilter != ',' || (nDesiredType & nType) == 0)
			continue; // ignore illegal or undesirable entries

		szFilter += 1; // skip comma
		while (*szFilter == ' ')
			szFilter += 1;

		AppendFilterSuffix(strFilter, ofn, szFilter);
		bAddedFilter = TRUE;
	}

	return bAddedFilter;
}

// Append "All Files (*.*)" to a file filter list.
//
void AddWildFilter(CString& strFilter, OPENFILENAME& ofn)
{
	CString str;
	VERIFY(str.LoadString(AFX_IDS_ALLFILTER));
	AppendFilterSuffix(strFilter, ofn, str);

	ofn.lpstrFilter = strFilter;
}


// Fill out a file filter list with information from the registry, or some
// preset default filters.
//
// strFilter and ofn contain the filter list when done
// nDesiredType is one of the FLT_ values and specifies which dialog this is for
// rgidDefaults and nDefaults specify the array of default filter ids
// szCommon is the name of a reg entry that specifies a "Common Files" filter
// If szCommon is NULL, the filter list has no "Common Files" entry
//
void SetFileFilters(CString& strFilter, OPENFILENAME& ofn, int nDesiredType,
	UINT* rgidDefaults, int nDefaults, const TCHAR* szCommon /* = NULL */)
{
	CString str;
	int nDefault = 0;

	// Start with the "Common Files" entry, if any...
	if (szCommon != NULL)
	{
		str = GetRegString(szFileFiltersKey, szCommon);
		if (str.IsEmpty())
		{
			// Use first default if no registry entry
			if (nDefaults)
			{
				VERIFY(str.LoadString(rgidDefaults[nDefault++]));
			}
		}

		if (!str.IsEmpty())
		{
			AppendFilterSuffix(strFilter, ofn, str);
		}
	}

	// Now add the more specific filters...
	if (!AddRegistryFilters(strFilter, nDesiredType, ofn))
	{
		// No filters in the registry, use defaults...
		for (int i = nDefault; i < nDefaults; i++)
		{
			VERIFY(str.LoadString(rgidDefaults[i]));
			AppendFilterSuffix(strFilter, ofn, str);
		}
	}

	// Finish off the list with *.*
	AddWildFilter(strFilter, ofn);

	ofn.lpstrFilter = strFilter;
}


BOOL CTheApp::DoPromptFileSave(CString& fileName, UINT nIDSTitle,
	DWORD lFlags, CPartDoc* pDocument, UINT* pnSaveType)
{
	CIdisFileDialog dlgFile(FALSE, pDocument);		// Create a File Save dialog

	CString strTitle;
	VERIFY(strTitle.LoadString(nIDSTitle));
	dlgFile.m_ofn.lpstrTitle = strTitle;
	dlgFile.m_ofn.lpstrFile = fileName.GetBuffer(_MAX_PATH);
	dlgFile.m_ofn.hwndOwner = AfxGetMainWnd()->GetSafeHwnd();

	dlgFile.m_ofn.Flags |= lFlags;

	CString strFilter;
	CString strDefault;
	UINT* pIDSFilters = NULL;
	UINT nSaveFilter = 0;

	ASSERT( pDocument != NULL );
	if( !pDocument->GetValidFilters(&pIDSFilters, &nSaveFilter) )
	{		// lacking anything better, use the template's doc info string
		CDocTemplate* pTemplate = pDocument->GetDocTemplate();
		ASSERT_VALID(pTemplate);
		AppendFilterSuffix(strFilter, dlgFile.m_ofn, pTemplate, &strDefault);
	}
	else
	{
		ASSERT( pIDSFilters != NULL );
		CString str;
		for( int n = 0; pIDSFilters[n] != 0; n++ )
		{
			str.LoadString(pIDSFilters[n]);
			if( pIDSFilters[n] == nSaveFilter )
			{
				AppendFilterSuffix(strFilter, dlgFile.m_ofn, str, TRUE);
				dlgFile.m_ofn.nFilterIndex = n + 1;		// default filter in combo
			}
			else
				AppendFilterSuffix(strFilter, dlgFile.m_ofn, str, FALSE);
		}
	}

	// Note current extension, and make that the default.  Can't actually 
	// use m_ofn.lpstrDefExt, because that gets tacked on to EVERYTHING!
	if( dlgFile.m_ofn.lpstrDefExt == NULL )
	{
		char acExt[_MAX_EXT];
		_splitpath(dlgFile.m_ofn.lpstrFile, NULL, NULL, NULL, acExt);
		ASSERT( (acExt[0] == '.') || (acExt[0] == '\0') );
		dlgFile.m_strCurrentExt = acExt;
		if( !dlgFile.IsExplorer() )
			dlgFile.m_ofn.lpstrDefExt = ((LPCSTR)dlgFile.m_strCurrentExt) + 1;
	}
	else
	{
		dlgFile.m_strCurrentExt.Empty();
		if (*(dlgFile.m_ofn.lpstrDefExt) != '.')
			dlgFile.m_strCurrentExt += ".";
		dlgFile.m_strCurrentExt += dlgFile.m_ofn.lpstrDefExt;
	}

	dlgFile.m_ofn.lpstrFilter = strFilter;

	BOOL bRet = (dlgFile.DoModal() == IDOK) ? TRUE : FALSE;

	if( bRet && pIDSFilters != NULL )
	{
		ASSERT( dlgFile.m_ofn.nFilterIndex > 0 );
		*pnSaveType = pIDSFilters[dlgFile.m_ofn.nFilterIndex - 1];
	}
	else
		*pnSaveType = 0;

	fileName.ReleaseBuffer();
	fileName.TrimLeft();
	fileName.TrimRight();

	return bRet;
}

SRankedStringID rsiOpenAsAuto =
{
	IDS_AUTO,	0
};

CString GetFilterDescription(LPCTSTR szFilter)
{
	LPCTSTR pchParen = _tcschr(szFilter, '(');
	if( pchParen == NULL )
		return szFilter;
	else
		return CString(szFilter, pchParen - szFilter);
}

void ParseFilters(LPCTSTR szFilter, CStringArray& rsa)
{
	// add any filters we find
	LPCTSTR pch = _tcschr(szFilter, '(');
	if( pch == NULL )
		return;
	pch = _tcsinc(pch);
	while( _istspace(*pch) || (*pch == ';') || (*pch == ')') )
		pch = _tcsinc(pch);

	while( *pch != '\0' )
	{
		LPCTSTR pchStart = pch;
		while( (*pch != '\0') && !_istspace(*pch) && (*pch != ';') && (*pch != ')') )
			pch = _tcsinc(pch);
		rsa.Add(CString(pchStart, pch - pchStart));
		while( _istspace(*pch) || (*pch == ';') || (*pch == ')') )
			pch = _tcsinc(pch);
	}
}

CString MergeFilters(LPCTSTR szFilter1, LPCTSTR szFilter2)
{
	CString strMerge = GetFilterDescription(szFilter1);
	ASSERT( strMerge == GetFilterDescription(szFilter2) );
	CStringArray sa;
	ParseFilters(szFilter1, sa);
	ParseFilters(szFilter2, sa);

	strMerge += '(';
	for( int n = 0; n < sa.GetSize(); n++ )
	{
		LPCTSTR szExt = sa[n];
		BOOL bUnique = TRUE;
		for( int nComp = 0; nComp < n; nComp++ )
		{
			if( _tcsicmp(szExt, sa[nComp]) == 0 )
			{
				bUnique = FALSE;
				break;
			}
		}
		if( bUnique )
		{
			if( n > 0 )
				strMerge += ";";
			strMerge += szExt;
		}
	}
	strMerge += ')';
	return strMerge;
}

void CTheApp::BuildFilterList(CString& rstrFilter, CPtrArray* ppaEditors, 
	int nOpenDialog, IPkgProject *pContextProject /* = NULL */)
{
	CString strOpenFilters;
	CPtrArray paFilters;
	if( ppaEditors != NULL && nOpenDialog != CPackage::GODI_WORKSPACEOPEN)
		ppaEditors->Add(&rsiOpenAsAuto);

	CLSID clsidActiveProject = CLSID_NULL;
	if (pContextProject == NULL)
	{
		IProjectWorkspace *pInterface;
		pInterface = g_IdeInterface.GetProjectWorkspace();
		if(pInterface)
		{
			IPkgProject *pProject;
			pInterface->GetActiveProject(&pProject);
			if (pProject != NULL)
			{
				VERIFY(SUCCEEDED(pProject->GetClassID(&clsidActiveProject)) && clsidActiveProject != CLSID_NULL);
				pProject->Release();
			}
		}
	}
	else
	{
		VERIFY(SUCCEEDED(pContextProject->GetClassID(&clsidActiveProject)) && clsidActiveProject != CLSID_NULL);
	}

	POSITION pos = m_packages.GetHeadPosition();
	while( pos != NULL )
	{
		CPackage* pPackage = (CPackage*)m_packages.GetNext(pos);
		ASSERT( pPackage != NULL );

		SRankedStringID* prsiFilters = NULL;
		SRankedStringID* prsiEditors = NULL;
		pPackage->GetOpenDialogInfo(&prsiFilters, &prsiEditors, nOpenDialog);

		// insert the filters into their list, in rank order
		if (prsiFilters != NULL)
		{
			for (; prsiFilters->ids != 0; prsiFilters++)		// the array must be NULL-terminated
			{
				int nInsert = 0;
				for (; nInsert < paFilters.GetSize(); nInsert++)
				{
					int nRank = ((SRankedStringID*)paFilters[nInsert])->nRank;
					const CLSID *pclsid = ((SRankedStringID*)paFilters[nInsert])->pclsid;
					if ((nRank > prsiFilters->nRank) || 
						((nRank == prsiFilters->nRank) && (clsidActiveProject != *pclsid) && (clsidActiveProject == *(prsiFilters->pclsid))))
					{
						break;
					}
				}
				paFilters.InsertAt(nInsert, prsiFilters);
			}
		}

		// insert the editors into their list, in rank order
		if ((ppaEditors != NULL) && (prsiEditors != NULL))
		{
			for (; prsiEditors->ids != 0; prsiEditors++)		// the array must be NULL-terminated
			{
				int nInsert = 0;
				for (; nInsert < ppaEditors->GetSize(); nInsert++)
				{
					int nRank = ((SRankedStringID*)ppaEditors->GetAt(nInsert))->nRank;
					const CLSID *pclsid = ((SRankedStringID*)paFilters[nInsert])->pclsid;
					if ((nRank > prsiEditors->nRank) || 
						((nRank == prsiEditors->nRank) && (clsidActiveProject != *pclsid) && (clsidActiveProject == *(prsiFilters->pclsid))))
					{
						break;
					}
				}
				ppaEditors->InsertAt(nInsert, prsiEditors);
			}
		}
	}

	// load strings
	CStringArray saFilters;
	for( int nFilter = 0; nFilter < paFilters.GetSize(); nFilter++ )
	{
		SRankedStringID* prsi = (SRankedStringID*)paFilters[nFilter];
		CString str;
		if (prsi->bIsID)
	 		VERIFY(str.LoadString(prsi->ids));
		else
			str = (LPTSTR)prsi->ids;
		saFilters.Add(str);
	}

	// eliminate duplicate strings
	for (nFilter = 0; nFilter < saFilters.GetSize(); nFilter++)
	{
		CString strNew = saFilters[nFilter];
		for (int nOld = 0; nOld < nFilter; nOld++)
		{
			CString strOld = saFilters[nOld];
			if (strNew == strOld)
			{	
				saFilters.RemoveAt(nFilter--);	// remove later one
				break;
			}
		}
	}

#if 0
	// merge duplicates
	for( nFilter = 0; nFilter < saFilters.GetSize(); nFilter++ )
	{
		CString strNew = saFilters[nFilter];
		CString strDesc = GetFilterDescription(strNew);
		for( int nOld = 0; nOld < nFilter; nOld++ )
		{
			CString strOld = saFilters[nOld];
			if( strDesc == GetFilterDescription(strOld) )
			{		// if filter categories are the same, merge them
				CString strMerge = MergeFilters(strOld, strNew);
				saFilters.SetAt(nOld, strMerge);		// update existing one
				saFilters.RemoveAt(nFilter--);			// remove later one
				break;
			}
		}
	}
#endif

	// build filter string
	OPENFILENAME ofnTemp;
	for( nFilter = 0; nFilter < saFilters.GetSize(); nFilter++ )
	{
		AppendFilterSuffix(strOpenFilters, ofnTemp, saFilters[nFilter]);
	}
	AddWildFilter(strOpenFilters, ofnTemp);		// Finish off the list with *.*

	// now that the list is built, add any user filters from the registry
	// FUTURE: check the registry
	rstrFilter = strOpenFilters;
}

BOOL CTheApp::DoPromptFileOpen(CStringArray& saFileNames, UINT nIDSTitle,
	DWORD lFlags, CDocTemplate* pTemplate,
	UINT* pnOpenAsEditor, BOOL* pbOpenReadOnly)
{
	static UINT iOpenFilter = 1;

	CIdisFileDialog dlgFile(TRUE);	// Create a File Open dialog

	CString title;
	VERIFY(title.LoadString(nIDSTitle));

	dlgFile.m_ofn.Flags |= lFlags;

	CString strFilter;
	CString strDefault;
	CPtrArray paFileOpenEditors;

	BuildFilterList(strFilter, &paFileOpenEditors, CPackage::GODI_FILEOPEN);
	dlgFile.m_ofn.lpstrFilter = strFilter;
	dlgFile.m_ppaEditors = &paFileOpenEditors;

	dlgFile.m_ofn.hwndOwner = AfxGetMainWnd()->GetSafeHwnd();
	dlgFile.m_ofn.lpstrTitle = title;
	if (dlgFile.m_ofn.Flags & OFN_ALLOWMULTISELECT)
			dlgFile.m_ofn.nMaxFile = 20480;	// See PSS Q99338
	char acFileNameBuffer[20480] = "";
	dlgFile.m_ofn.lpstrFile = acFileNameBuffer;
	dlgFile.m_psaFileNames = &saFileNames;

	dlgFile.m_ofn.nFilterIndex = (DWORD) iOpenFilter;

	BOOL bRet = (dlgFile.DoModal() == IDOK) ? TRUE : FALSE;

	if (pnOpenAsEditor != NULL)
		*pnOpenAsEditor = dlgFile.m_nOpenAsEditor;

	if (pbOpenReadOnly != NULL)
		*pbOpenReadOnly = dlgFile.GetReadOnlyPref();

	if (bRet)
		iOpenFilter = (UINT) dlgFile.m_ofn.nFilterIndex;

	return bRet;
}

void CTheApp::DestroyAll(UINT nFlags /*= 0*/)
{
	// Always use the mainframe's close all to destroy all windows.
	((CMainFrame *)m_pMainWnd)->CloseWindows(nFlags);
}

BOOL CTheApp::CanCloseAll(UINT nFlags /*= 0*/)
{
   // First see if all windows can close.
	CMDIClientValidator* m_pWndMDIClient = ((CMainFrame *)m_pMainWnd)->m_pWndMDIClient;
	CPartFrame* pMDIChild = MDITypedGetActive(nFlags);

	while (pMDIChild != NULL)
	{
		CPartView* pView = (CPartView*)pMDIChild->GetActiveView();
		if (pView != NULL)
		{
			ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));
			if (!pView->CanClose())
				return FALSE;
		}

		pMDIChild = MDITypedGetNext(pMDIChild, nFlags);
	}

	return TRUE;
}

extern CShellRecorder g_theShellRecorder;

BOOL CTheApp::SaveAll(BOOL bQuery /*= FALSE*/, UINT nFlags /*= 0*/)
{
	POSITION pos = GetFirstDocTemplatePosition();
	BOOL bRetval = TRUE;
	// Save the active MDI child in case one of the templates activates one
	// of its views:
	CWnd *pWnd = ((CMDIFrameWnd *) theApp.m_pMainWnd)->MDIGetActive ();

	// DS96 #13311 [CFlaat]: record a Documents.SaveAll operation here
	g_theShellRecorder.EmitMethodCall(seSaveAll, CShellConstArg(scTrue));

	CWaitCursor waitCursor;
	CHaltRecording HaltRec; // DS96 #13311 [CFlaat]: don't record individual find operations hereafter

	while (pos)
	{
		CPartTemplate* pTemplate = (CPartTemplate*)GetNextDocTemplate(pos);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
		if (!pTemplate->SaveAll(bQuery, nFlags))
		{
			bRetval = FALSE;
			break;
		}
	}
	if (((CMDIFrameWnd *) theApp.m_pMainWnd)->MDIGetActive () != pWnd)
	{
		((CMDIFrameWnd *) theApp.m_pMainWnd)->MDIActivate (pWnd);
	}
	return bRetval;
}

BOOL CTheApp::HasOpenDocument(UINT nFlags /*= 0*/)
{
	return (MDITypedGetActive(nFlags) != NULL);
}

///////////////////////////////////////////////////////////////////////////////
//      CTypedRecentFileList
//              Extended recent file list helper class implementation.

// DER - 5 June 96 CTypedRecentFileList now inherits from CBRecentFileList.
CTypedRecentFileList::CTypedRecentFileList(UINT nStart, LPCTSTR lpszSection,
		LPCTSTR lpszEntryFormat, LPCTSTR lpszEntryTypeFormat, int nSize,
		int nMaxDispLen /*=AFX_ABBREV_FILENAME_LEN*/, int nShortCount)
	: CBRecentFileList(nStart, lpszSection, lpszEntryFormat, nSize, nMaxDispLen, nShortCount)
{
	m_nLastSize=m_nSize;
	m_arrTypes = new CLSID[nSize];
	m_strEntryTypeFormat = lpszEntryTypeFormat;
}

CTypedRecentFileList::~CTypedRecentFileList()
{
	delete [] m_arrTypes;
}

CDocTemplate* CTypedRecentFileList::GetTypeAt(int nIndex)
{
	return theApp.GetTemplate(m_arrTypes[nIndex]);
}

void CTypedRecentFileList::Add(LPCTSTR lpszPathName, CDocTemplate* pTemplate)
{
//      ASSERT_VALID(this); CRecentFileList no longer is a CObject
	ASSERT(lpszPathName != NULL);
	ASSERT(AfxIsValidString(lpszPathName));

	// fully qualify the path name
	CPath path;
	if (!path.Create(lpszPathName))
		return;

	LPCTSTR lpszFullPath = path.GetFullPath();

	// update the MRU list
	int iMRU;
	// if an existing MRU string matches file name
	int nSize = GetSize();
	for (iMRU = 0; iMRU < nSize - 1; iMRU++)
	{
		if (lstrcmpi(m_arrNames[iMRU], lpszFullPath) == 0)
			break;      // iMRU will point to matching entry
	}

	// move the filenames down the list, removes the last filename
	//      or the matching filename (in iMRU).
	int istr;
	for (istr = iMRU; istr > 0; istr--)
	{
		m_arrNames[istr] = m_arrNames[istr - 1];
		m_arrTypes[istr] = m_arrTypes[istr - 1];
	}

	m_arrNames[0] = lpszFullPath; //put new items at beginning
	m_arrTypes[0] = (pTemplate == NULL) ?
		GUID_NULL : ((CPartTemplate*)pTemplate)->GetTemplateClsid();
}

void CTypedRecentFileList::ReadList()
{
	USES_CONVERSION;

	ASSERT(!m_strSectionName.IsEmpty());
	ASSERT(!m_strEntryFormat.IsEmpty());
	ASSERT(!m_strEntryTypeFormat.IsEmpty());

	int nSize = GetSize();
	LPTSTR pszEntry = new TCHAR[m_strEntryFormat.GetLength()+5];
	for (int iMRU = 0; iMRU < nSize; iMRU++)
	{
		wsprintf(pszEntry, m_strEntryFormat, iMRU + 1);
		m_arrNames[iMRU] = GetRegString(m_strSectionName, pszEntry);
		
		wsprintf(pszEntry, m_strEntryTypeFormat, iMRU + 1);
		CString str = GetRegString(m_strSectionName, pszEntry);
		if (str.IsEmpty() || (CLSIDFromString(A2W(str), &m_arrTypes[iMRU]) != S_OK))
			m_arrTypes[iMRU] = GUID_NULL;
	}
	delete [] pszEntry;
}

void CTypedRecentFileList::WriteList()
{
	USES_CONVERSION;

	ASSERT(!m_strSectionName.IsEmpty());
	ASSERT(!m_strEntryFormat.IsEmpty());

	LPWSTR lpwsz;
	
	int nSize = GetSize();
	LPTSTR pszEntry = new TCHAR[m_strEntryFormat.GetLength()+5];
	for (int iMRU = 0; iMRU < nSize; iMRU++)
	{
		if (m_arrNames[iMRU].IsEmpty())
			break;  // all done

		wsprintf(pszEntry, m_strEntryFormat, iMRU + 1);
		WriteRegString(m_strSectionName, pszEntry, m_arrNames[iMRU]);

		wsprintf(pszEntry, m_strEntryTypeFormat, iMRU + 1);
		if (StringFromCLSID(m_arrTypes[iMRU], &lpwsz) == NOERROR)
		{
			WriteRegString(m_strSectionName, pszEntry, W2A(lpwsz));
			AfxFreeTaskMem(lpwsz);
		}
	}

	delete[] pszEntry;
}

void CTypedRecentFileList::SetSize(int nSize)
{
	// resize the name array to the new size. Forced to do a manual copy - no realloc in c++
	CLSID *arrNewTypes=new CLSID[nSize];

	ASSERT(arrNewTypes);

	int nCopy=min(nSize,GetSize());

	for(int i=0;i<nCopy; ++i)
	{
		arrNewTypes[i]=m_arrTypes[i];
	}

	delete [] m_arrTypes;

	m_arrTypes=arrNewTypes;

	CBRecentFileList::SetSize(nSize);
}

void CBRecentFileList::SetStart(int nStart)
{
	m_nStart=nStart;
}

void CBRecentFileList::SetShortCount(int nShortCount)
{
	m_nShortCount=nShortCount;
}

// This code stolen from MFC sources, and modified to only show a limited number of accelerators, plus to
// work with either menus or command bars
void CBRecentFileList::UpdateMenu(CCmdUI* pCmdUI)
{
	ASSERT(m_arrNames != NULL);

	CMenu*			pWinMenu = pCmdUI->m_pMenu;
	CBMenuPopup *	pCBMenu= (CBMenuPopup*) pCmdUI->m_pOther;

	// do nothing for the  top level call
	if(pWinMenu && pCmdUI->m_pSubMenu)
	{
		return;
	}

	// This is used to extract the disable/empty string the first time we are called. 
	if (m_strOriginal.IsEmpty())
	{
		if(pWinMenu != NULL)
		{
			pWinMenu->GetMenuString(pCmdUI->m_nID, m_strOriginal, MF_BYCOMMAND);
		} 
		else
		{
			if(pCBMenu != NULL)
			{
				pCBMenu->GetMenuString(pCmdUI->m_nID, m_strOriginal, MF_BYCOMMAND);
			}
		}
	}

	if (m_arrNames[0].IsEmpty())
	{
		// no MRU files
		if (!m_strOriginal.IsEmpty())
			pCmdUI->SetText(m_strOriginal);
		pCmdUI->Enable(FALSE);
		return;
	}

	// No menu, no need to update, really.
	if (pWinMenu==NULL && pCBMenu==NULL)
		return;

	for (int iMRU = 0; iMRU < m_nLastSize; iMRU++)
	{
		if(pWinMenu)
		{
			pWinMenu->DeleteMenu(pCmdUI->m_nID + iMRU, MF_BYCOMMAND);
		}
		else if(pCBMenu)
		{
			pCBMenu->DeleteMenu(pCmdUI->m_nID + iMRU, MF_BYCOMMAND);
		}
	}

#ifndef _MAC
	TCHAR szCurDir[_MAX_PATH];
	GetCurrentDirectory(_MAX_PATH, szCurDir);
	int nCurDir = lstrlen(szCurDir);
	ASSERT(nCurDir >= 0);
	szCurDir[nCurDir] = '\\';
	szCurDir[++nCurDir] = '\0';
#endif

	int cxScreen = ::GetSystemMetrics(SM_CXSCREEN);
	TEXTMETRIC tm;

	// determine maximum size of menu item we're willing to create
	{
		CDC dc;               
		dc.CreateCompatibleDC(NULL);

		// select the menu font
		CFont *pOldFont=dc.SelectObject(globalData.GetMenuFont(FALSE));

		dc.GetTextMetrics(&tm);

		// ensure that zero wasn't returned for some reason
		if(tm.tmAveCharWidth==0)
		{
			// arbitrary
			tm.tmAveCharWidth=15;
		}

		// clean up context
		dc.SelectObject(pOldFont);
	}

	// menu should be allowed to hold enough characters to fill half the screen
	m_nMaxDisplayLength=(cxScreen/2)/tm.tmAveCharWidth;

	// small max len implies large fonts/small screen. Allow item to almost fill screen (90% fill)
	if(m_nMaxDisplayLength<10)
	{
		m_nMaxDisplayLength=(((double)cxScreen)*0.9)/(double)tm.tmAveCharWidth;

		ASSERT(m_nMaxDisplayLength>1);
	}

	CString strName;
	CString strTemp;
	int nMnemonics=m_nShortCount;
	for (iMRU = 0; iMRU < m_nSize; iMRU++)
	{
#ifndef _MAC
		if (!GetDisplayName(strName, iMRU, szCurDir, nCurDir))
			break;
#else
		if (!GetDisplayName(strName, iMRU, NULL, 0))
			break;
#endif

		// if the name is longer than the display length, then the result will just be the base name. We'll truncate that, and add an ellipsis
		if(strName.GetLength() > m_nMaxDisplayLength)
		{
			strName=strName.Left(m_nMaxDisplayLength-4)+" ...";
		}

		// double up any '&' characters so they are not underlined
		LPCTSTR lpszSrc = strName;
		LPTSTR lpszDest = strTemp.GetBuffer(strName.GetLength()*2);
		while (*lpszSrc != 0)
		{
			if (*lpszSrc == '&')
				*lpszDest++ = '&';
			if (_istlead(*lpszSrc))
				*lpszDest++ = *lpszSrc++;
			*lpszDest++ = *lpszSrc++;
		}
		*lpszDest = 0;
		strTemp.ReleaseBuffer();

		// insert mnemonic + the file name
		CString strMnemonic;
		int nMnemonic=iMRU+1+m_nStart;
		if(nMnemonics>0 && (nMnemonic)<11)
		{
			// insert mnemonic string
			if(nMnemonic<10)
			{
				wsprintf(strMnemonic.GetBuffer(10), _T("&%d "), nMnemonic);
			}
			else
			{
				wsprintf(strMnemonic.GetBuffer(10), _T("1&0 "));
			}

			strMnemonic.ReleaseBuffer();
			--nMnemonics;
		}
		if(pWinMenu)
		{
			pWinMenu->InsertMenu(pCmdUI->m_nIndex++,MF_STRING | MF_BYPOSITION, pCmdUI->m_nID++,	strMnemonic + strTemp);
		}
		else if(pCBMenu)
		{
			pCBMenu->InsertMenu(pCmdUI->m_nIndex++,MF_STRING | MF_BYPOSITION, pCmdUI->m_nID++, strMnemonic + strTemp);
		}
	}

	// remember how many items we added this time, so that we can delete the right number next time.
	m_nLastSize=m_nSize;

	// update end menu count
	pCmdUI->m_nIndex--; // point to last menu added
	if(pWinMenu)
	{
		pCmdUI->m_nIndexMax = pWinMenu->GetMenuItemCount();
	}
	else if(pCBMenu)
	{
		pCmdUI->m_nIndexMax = pCBMenu->GetMenuItemCount();
	}

	pCmdUI->m_bEnableChanged = TRUE;    // all the added items are enabled
}

void CBRecentFileList::SetSize(int nSize)
{
	// resize the name array to the new size. Forced to do a manual copy - no realloc in c++
	CString *arrNewNames=new CString[nSize];

	ASSERT(arrNewNames);

	int nCopy=min(nSize,GetSize());

	for(int i=0;i<nCopy; ++i)
	{
		arrNewNames[i]=m_arrNames[i];
	}

	delete [] m_arrNames;

	m_arrNames=arrNewNames;
	m_nSize=nSize;
}

/////////////////////////////////////////////////////////////////////////////
// MRU file list extended implementation

void CTheApp::OnUpdateRecentProjMenu(CCmdUI* pCmdUI)
{
	ASSERT_VALID(this);
	if (m_pRecentProjectList == NULL) // no MRU projects
	{
		pCmdUI->Enable(FALSE);
	}
	else
	{
		m_pRecentProjectList->UpdateMenu(pCmdUI);
	}
}

// Before Orion 6072, this function assumed that ID_PROJ_MRU_LAST and
// ID_FILE_MRU_LAST were invalid MRU ids. They are valid, so the assertions 
// and code have been modified. martynl 12Mar96
BOOL CTheApp::OnOpenRecentFile(UINT nID)
{
	ASSERT_VALID(this);
	ASSERT((nID >= ID_FILE_MRU_FIRST && nID <= ID_FILE_MRU_LAST) ||
		(nID >= ID_PROJ_MRU_FIRST && nID <= ID_PROJ_MRU_LAST));

	BOOL bFile = TRUE;
	UINT nIndex = nID - ID_FILE_MRU_FIRST;
	if (nID >= ID_PROJ_MRU_FIRST && nID <= ID_PROJ_MRU_LAST)
	{
		bFile = FALSE;
		nIndex = nID - ID_PROJ_MRU_FIRST;
	}

	ASSERT((bFile && m_pRecentFileList != NULL) ||
		(!bFile && m_pRecentProjectList != NULL));
	ASSERT((bFile && nIndex < (UINT) m_pRecentFileList->GetSize()) ||
		(!bFile && nIndex < (UINT) m_pRecentProjectList->GetSize()));

	CString strOpen;

	if (bFile)
		strOpen = (*m_pRecentFileList)[nIndex];
	else
	{
		// executables opened as workspaces have extensions in MRU
		strOpen = (*m_pRecentProjectList)[nIndex];
		// Check first if a .dsw or mdp file exists. If not,
		// we probably have a exe open as a workspace.
		CString strOpenT = strOpen + _T(WORKSPACE_EXT);
		if (_access(strOpenT, 00) == 0)
		{
			strOpen = strOpenT;
		}
		else
		{
			CString strOpenT2 = strOpen + _T(".mdp");;
			if (_access(strOpenT2, 00) == 0)
				strOpen = strOpenT2;
		}
	}

	ASSERT(strOpen.GetLength() != 0);

	TRACE2("MRU: open file (%d) '%s'.\n", nIndex, (LPCTSTR)strOpen);

	// Try to choose the right template to open the file.
	CDocTemplate* pOpenTemplate = NULL;
	if (!bFile)
	{
		pOpenTemplate = GetTemplate(CLSID_WorkspaceDocument);
 
		// If this doesn't look like a MDP file the let the application decide
		CDocument* pOpenDoc;
		if (pOpenTemplate != NULL && !pOpenTemplate->MatchDocType(strOpen, pOpenDoc))
			pOpenTemplate = NULL;
	}
	else
	{
		pOpenTemplate = ((CTypedRecentFileList*) m_pRecentFileList)->
			GetTypeAt(nID - ID_FILE_MRU_FILE1);
	}

	// See if the file is already open.
	CDocument* pCurDoc;
	CDocTemplate* pCurTemplate = GetOpenTemplate(strOpen, pCurDoc);

	if (pCurTemplate != NULL)
	{
		ASSERT(pCurDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));

		((CPartDoc*) pCurDoc)->ActivateDoc();
		if (pOpenTemplate == NULL || pOpenTemplate == pCurTemplate ||
			!((CPartDoc*) pCurDoc)->AttemptCloseDoc())
			return TRUE;
	}

	// Set a flag so that we can find out if we were opened using the MRU or not.
	m_bOpenedFromMRU = TRUE;

	if (pOpenTemplate == NULL)
		pCurDoc = OpenDocumentFile(strOpen);
	else
		pCurDoc = pOpenTemplate->OpenDocumentFile(strOpen);

	if (pCurDoc == NULL)
	{
		// If file does not exist, remove the filename from the appropriate MRU list.
		if (_access(strOpen, 00) != 0)
		{
			CRecentFileList *pRecentList = (bFile ? m_pRecentFileList : m_pRecentProjectList);
			int iCount = pRecentList->GetSize();
			for (int i = 0; i < iCount; i++)
			{
				CString strMRU;
				strMRU = (*(pRecentList))[i];

				char szPath[_MAX_PATH], szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
				_splitpath(strOpen, szDrive, szDir, szFName, szExt);
				if (bFile)
					_makepath(szPath, szDrive, szDir, szFName, szExt);
				else
					_makepath(szPath, szDrive, szDir, szFName, NULL);

				if (!(strMRU.CompareNoCase(szPath)))
				{
					pRecentList->Remove(i);
					break;
				}
			}
		}
	}

	// Reset the flag
	m_bOpenedFromMRU = FALSE;

	return TRUE;
}

void CTheApp::LockRecentFileList(BOOL bLock)
{
	if (bLock)
		m_nLockRecentFileList++;
	else
		m_nLockRecentFileList--;
}

void CTheApp::AddToRecentFileList(LPCTSTR lpszPathName)
	// pszPathName must be a full path in upper-case ANSI character set
{
	if (m_nLockRecentFileList < 1)
	{
		CDocument* pDoc;
		CDocTemplate* pTemplate = GetOpenTemplate(lpszPathName, pDoc);

		if (m_pRecentProjectList != NULL && pTemplate == GetTemplate(CLSID_WorkspaceDocument))
		{
			// olympus 16294 [patbr]
			// it's a workspace, so add it to the MRU workspace list, but only
			// if the file exists on disk--otherwise we'll handle this when
			// the workspace is closed and the file is written to disk.
			struct _stat stBuf;
			if (_stat(lpszPathName, &stBuf) != -1)
			{
				// executables opened as workspaces have extensions in MRU--all
				// other workspace files (DSW/MDP) appear with no extension
				TCHAR * pchDot = _tcsrchr(lpszPathName, '.');
				if (!_tcsicmp(pchDot, WORKSPACE_EXT) || !_tcsicmp(pchDot, ".mdp"))
				{
					CString strProjName(lpszPathName, pchDot - lpszPathName);
					m_pRecentProjectList->Add(strProjName);
				}
				else
				{
					CString strProjName(lpszPathName);
					m_pRecentProjectList->Add(strProjName);
				}
			}
		}
		else if (m_pRecentFileList != NULL)
		{
			// otherwise add to recent file list
			if( (pTemplate != NULL) && 
				pTemplate->IsKindOf(RUNTIME_CLASS(CDocObjectTemplate)) )
			{
				// docobject template--not necessary to remember the type
				((CTypedRecentFileList*)m_pRecentFileList)->Add(lpszPathName, NULL);
			}
			else
			{
				// remember the type file was opened as
				((CTypedRecentFileList*)m_pRecentFileList)->Add(lpszPathName, pTemplate);
			}
		}
	}
}

void CTheApp::SetRecentFileListSize(int nSize)
{ 
	((CBRecentFileList *)m_pRecentFileList)->SetSize(nSize); 
}

void CTheApp::SetRecentProjectListSize(int nSize)
{
	m_pRecentProjectList->SetSize(nSize); 
}

int CTheApp::GetRecentFileListSize()
{
	return m_pRecentFileList->GetSize();
}

int CTheApp::GetRecentProjectListSize()
{
	return m_pRecentProjectList->GetSize();
}

void CVshellPackage::OnFileNew()
{
	theApp.OnFileNew();
}

void CVshellPackage::OnFileNewInProject()
{
	theApp.OnFileNewInProject();
}

void CVshellPackage::OnFileOpen()
{
	theApp.OnFileOpen();
}

void CVshellPackage::OnFileSaveAll()
{
	theApp.SaveAll(FALSE, FILTER_DEBUG);
}

void CVshellPackage::OnInsertFiles()
{
	theApp.OnInsertFiles();
}

void CVshellPackage::OnFileSaveAllExit()
{
	theApp.SaveAll(FALSE, FILTER_DEBUG);
	AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_APP_EXIT, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\filenew.cpp ===
// filenew.cpp : implementation file for CFileNewTabbedDialog,
//										 CNewFileDialogTab,
//										 CNewTemplateDialogTab,
//										 CNewProjectDialogTab,
//										 CNewWorkspaceDialogTab,
//										 CNewOtherDocDialogTab
//

#include "stdafx.h"
#include "afxcview.h"

#include "filenew.h"
#include "shell.h"
#include "docobtpl.h"
#include "toolexpt.h"
#include <iswsguid.h>				// IID_IWebPkgProject


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define COLUMNEXTRA 20	// extra column width for small icon and spacing

extern HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);

extern void GetRegWorkspaceDir(CString& strLocation);
extern void WriteRegWorkspaceDir(const CString& strLocation);

void SetListCtrlStyle(CListCtrl *pListCtrl, LONG lNewStyle)
{
	LONG lStyle;
	lStyle = ::GetWindowLong(pListCtrl->m_hWnd, GWL_STYLE);
	lStyle &= ~LVS_TYPEMASK;
	lStyle |= lNewStyle;
	::SetWindowLong(pListCtrl->m_hWnd, GWL_STYLE, lStyle);
	pListCtrl->Arrange(LVA_SNAPTOGRID);
	pListCtrl->Invalidate();
	pListCtrl->UpdateWindow();
}

typedef enum CreateFileError
{
	cfeNoError,
	cfeFileExists,
	cfeInvalidFile,
	cfeInvalidPath,
	cfeNonexistentPath,
	cfeCannotCreatePath,
	cfeCannotCreateFile
};

extern void EnsureSlashAtEnd(CString& str);

CreateFileError CanCreateFile(const CString &strFileName, const CString &strPathName, BOOL fDirMustExist)
{
	CDir dir;
	CPath path;
	CWaitCursor wc;
	if (!dir.CreateFromStringEx(strPathName, TRUE))
		return cfeInvalidPath;
	if (!path.CreateFromDirAndFilename(dir, strFileName))
		return cfeInvalidFile;
	if (path.ExistsOnDisk())
		return cfeFileExists;
	if (fDirMustExist && !dir.ExistsOnDisk())
		return cfeNonexistentPath;
	if (!dir.CreateOnDisk())
		return cfeCannotCreatePath;
	if (!path.CanCreateOnDisk(TRUE))
		return cfeCannotCreateFile;
	return cfeNoError;
}

BOOL IsProjectNameValid(LPCTSTR pszProject)
{

	// Disallow a few reserved DOS words
	const char * szReserved[]={"nul", "con", "aux", "template" };

	for(int i=0; i<(sizeof(szReserved)/sizeof(char *)); i++)
		if(_tcsicmp(pszProject, szReserved[i])==0)
			return FALSE;

	// We need to disallow com? and lpt? where ? can be any number from 1 to 9
	if(_tcslen(pszProject)==4 && pszProject[3]>='1' && pszProject[3]<='9')
	{
		if((_tcsnicmp(pszProject, "com", 3)==0) 
			|| (_tcsnicmp(pszProject, "lpt", 3)==0))
			return FALSE;
	}

	// DevStudio96 RAID 7501 [patbr]: disallow space as first or last character in name
	if (*pszProject == _T('\0') || *pszProject == _T(' ') || *pszProject == _T('.'))
		return FALSE;

	DWORD cchLeft = 8;	// 8 as default maximum length for file name
	DWORD dwMaxLen = 8;
	DWORD dwDummy1;
	if (::GetVolumeInformation(NULL, NULL, 0, NULL, &dwMaxLen, &dwDummy1, NULL, 0))
	{
		// succesfully got info from file system -- use it.
		cchLeft = dwMaxLen;
	}

	TCHAR ch;
	while ((ch = *pszProject) != _T('\0'))
	{
		if (_istalnum(ch) || ch == _T('_') || ch == _T(' ') || IsDBCSLeadByte(ch) || (IsJapaneseSystem() && IsSBKatakana(ch)) || ch < 0)
		{
			cchLeft -= _tclen(pszProject);	// count the character
			if (cchLeft < 0)
				return FALSE;	// too long as name for project
		}
		else
		{
			return FALSE;	// illegal as name for project
		}
		pszProject = _tcsinc(pszProject);

		// disallow trailing spaces and dots.
		if( (ch == _T(' ') || ch == _T('.')) && *pszProject == _T('\0'))
			return FALSE;	// illegal as name for project
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFileNewTabbedDialog

int CFileNewTabbedDialog::c_nSelectTab = 0;

IMPLEMENT_DYNAMIC(CFileNewTabbedDialog, CTabbedDialog);

CFileNewTabbedDialog::CFileNewTabbedDialog(BOOL bUseSavedData /*=FALSE*/, BOOL bForceAddToProject /*=FALSE*/, BOOL bForceShowProjectTab /*=FALSE*/)
	: CTabbedDialog(IDS_NEW, NULL, bUseSavedData ? c_nSelectTab: 0, commitOnOk)
{
	IProjectWorkspace *pInterface;
	pInterface = g_IdeInterface.GetProjectWorkspace();
	ASSERT(pInterface != NULL);
	CADWORD Projects;
	pInterface->GetLoadedProjects(&Projects);
	int nSize;
	if ((nSize = Projects.cElems) != 0)
	{
		COleRef<IPkgProject> pActive;
		pInterface->GetActiveProject(&pActive);
		m_pActiveProject = pActive;

		for (int nIndex = 0; nIndex < nSize; nIndex++)
		{
			IPkgProject *pProject = (IPkgProject *)Projects.pElems[nIndex];
			LPCOLESTR pszProjName, pszProjPath;
			DWORD dwPackageID, dwFlags;
			pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
			if ((dwFlags & GPI_PROJISEXECUTABLE) == 0)
			{
				CString strProject = pszProjName;
				m_strlistProjects.AddTail(strProject);
				m_ptrlistBuilders.AddTail(pProject);
				pProject->AddRef();
			}
			pProject->Release();
			CoTaskMemFree((void *)pszProjName);
			CoTaskMemFree((void *)pszProjPath);
		}
		CoTaskMemFree((void *)Projects.pElems);
	}

	m_pTemplate = NULL;
	m_pProject = NULL;
	m_pProjectProvider = NULL;
	m_dwProjectType = 0L;
	m_fAddToProject = FALSE;

	m_strFileName.Empty();
	m_strPathName.Empty();

	m_fCommitting = FALSE;
	m_Type = CPartTemplate::newnone;

	BOOL fHaveWizards = FALSE;
	POSITION pos = theApp.GetFirstDocTemplatePosition();
	while (pos != NULL)
	{
		CPartTemplate *pTemplate = (CPartTemplate *)theApp.GetNextDocTemplate(pos);
		if (CPartTemplate::newtemplate == pTemplate->GetTabType())
		{
			fHaveWizards = TRUE;
			break;
		}
	}

	AddTab(new CNewFileDialogTab(bUseSavedData, bForceAddToProject));
	if (fHaveWizards)
		AddTab(new CNewTemplateDialogTab(bUseSavedData, bForceAddToProject));
	AddTab(new CNewProjectDialogTab(bUseSavedData, bForceAddToProject));
	if (!bForceAddToProject && !bForceShowProjectTab)
		AddTab(new CNewWorkspaceDialogTab(bUseSavedData));
	AddTab(new CNewOtherDocDialogTab(bUseSavedData, bForceAddToProject));

	if ((nSize == 0) || bForceShowProjectTab)
		SelectTab(fHaveWizards ? 2 : 1, TRUE);
}

CFileNewTabbedDialog::~CFileNewTabbedDialog()
{
	c_nSelectTab = GetCurrentTab();
	m_strlistProjects.RemoveAll();
	while(!m_ptrlistBuilders.IsEmpty())
	{
		IPkgProject *pProj = (IPkgProject *)m_ptrlistBuilders.RemoveHead();
		pProj->Release();
	}
}

void CFileNewTabbedDialog::OnOK()
{
	m_fCommitting = TRUE;
	if (m_nTabCur != -1)
	{
		CDlgTab* pTab = GetTab(m_nTabCur);
		if (!pTab->ValidateTab())
		{
		//	TRACE("Tab %s not validated!\n", (const char*)GetTab(m_nTabCur)->m_strCaption);
			m_fCommitting = FALSE;
			return;
		}

		pTab->Deactivate(this);
	}

	// At this point, all tabs must be valid.  We differ from CTabbedDialog in that
	// we commit only the active tab, and cancel all of the others.
	for (int nTab = 0; nTab < m_tabs.GetSize(); nTab++)
	{
		if (GetTab(nTab)->GetSafeHwnd() != NULL)
		{
			if (nTab == m_nTabCur)
				GetTab(nTab)->CommitTab();
			else
				GetTab(nTab)->CancelTab();
		}
	}

	m_fCommitting = FALSE;
	EndDialog(IDOK);
}

void CFileNewTabbedDialog::OnCancel()
{
	CTabbedDialog::OnCancel();
}

/////////////////////////////////////////////////////////////////////////////
// CNewFileDialogTab

int CNewFileDialogTab::m_nSelected;
BOOL CNewFileDialogTab::m_fAddToProject = TRUE;
int CNewFileDialogTab::m_nIndex;
CString CNewFileDialogTab::m_strFileName;
CString CNewFileDialogTab::m_strPathName;
int CNewFileDialogTab::m_nFocusCtrlId = -1;
#ifdef ENABLE_LISTVIEW_MODES
VIEW_MODE CNewFileDialogTab::c_ViewMode = smallicon;
#endif	// ENABLE_LISTVIEW_MODES

IMPLEMENT_DYNAMIC(CNewFileDialogTab, CDlgTab);

CNewFileDialogTab::CNewFileDialogTab(BOOL bUseSavedData /*=FALSE*/, BOOL bForceAddToProject /*=FALSE*/)
	: CDlgTab(IDDP_FILENEW_FILES, IDS_FILESTAB)
{
	if (!bUseSavedData)
	{
		m_nFocusCtrlId = -1;
		m_nSelected = 0;
		m_strFileName.Empty();
	}

	if (m_strPathName.IsEmpty())
	{
		CDir dir;
		dir.CreateFromCurrent();
		m_strPathName = (const TCHAR *)dir;
	}

	if (bForceAddToProject)
	{
		m_fAddToProjectPrev = m_fAddToProject;
		m_fAddToProject = TRUE;
	}
	m_fForceAddToProj = bForceAddToProject;

	m_fIsInitialized = FALSE;
	m_fDoubleClicked = FALSE;
}

void CNewFileDialogTab::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CNewFileDialogTab)
	DDX_Control(pDX, IDC_FILETYPES, m_FileTypes);
	DDX_Check(pDX, IDC_ADDFILETOPROJECT, m_fAddToProject);
	DDX_CBIndex(pDX, IDC_PROJECTFORFILE, m_nIndex);
	DDX_Text(pDX, IDC_NAMEFORFILE, m_strFileName);
	DDX_Text(pDX, IDC_LOCATIONFORFILE, m_strPathName);
	//}}AFX_DATA_MAP
}

BOOL CNewFileDialogTab::OnInitDialog()
{
	UpdateData(FALSE);

//	m_imageListNormal.Create(32, 32, ILC_COLOR, 1, 1);
//	m_imageListNormal.SetBkColor(GetSysColor(COLOR_WINDOW));
	m_imageListSmall.Create(16, 16, ILC_COLOR, 1, 1);
	m_imageListSmall.SetBkColor(GetSysColor(COLOR_WINDOW));

	POSITION pos = theApp.GetFirstDocTemplatePosition();

	// Set the generic members of the LV_ITEM stuct:
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvItem.iSubItem = 0;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = 0;

	// while loop variables
	CPartTemplate *pTemplate;
	HICON hIcon;
	CString strDisplay;
	int nIndex = 0;
	int nColumnWidth = 0;
	while (pos != NULL)
	{
		pTemplate = (CPartTemplate *)theApp.GetNextDocTemplate(pos);
		ASSERT(pTemplate != NULL);
		if (CPartTemplate::newfile == pTemplate->GetTabType() && (hIcon = pTemplate->GetIcon()) &&
			pTemplate->GetDocString(strDisplay, CDocTemplate::fileNewName) && !strDisplay.IsEmpty())
		{
			hIcon = pTemplate->GetIcon();
		//	m_imageListNormal.Add(hIcon);
			m_imageListSmall.Add(hIcon);

			pTemplate->GetDocString(strDisplay, CDocTemplate::fileNewName);
			lvItem.iItem = nIndex;
			lvItem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
			lvItem.iImage = nIndex;
			lvItem.lParam = (LPARAM)pTemplate;

			VERIFY(m_FileTypes.InsertItem(&lvItem) != -1);

			nColumnWidth = max(nColumnWidth, m_FileTypes.GetStringWidth(strDisplay));
			nIndex++;
		}
	}

	m_FileTypes.SetColumnWidth(-1, nColumnWidth + COLUMNEXTRA);
	m_FileTypes.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

//	m_FileTypes.SetImageList(&m_imageListNormal, LVSIL_NORMAL);
	m_FileTypes.SetImageList(&m_imageListSmall, LVSIL_SMALL);

#ifndef ENABLE_LISTVIEW_MODES
	SetListCtrlStyle(&m_FileTypes, LVS_SMALLICON);
	SetListCtrlStyle(&m_FileTypes, LVS_LIST);
#else	// ENABLE_LISTVIEW_MODES
	switch (c_ViewMode)
	{
		case largeicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LARGEICONVIEW);
			SetListCtrlStyle(&m_FileTypes, LVS_SMALLICON);
			SetListCtrlStyle(&m_FileTypes, LVS_ICON);
			break;

		case smallicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_SMALLICONVIEW);
			SetListCtrlStyle(&m_FileTypes, LVS_ICON);
			SetListCtrlStyle(&m_FileTypes, LVS_SMALLICON);
			break;

		case list:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LISTVIEW);
			SetListCtrlStyle(&m_FileTypes, LVS_ICON);
			SetListCtrlStyle(&m_FileTypes, LVS_LIST);
			break;
	}
#endif	// ENABLE_LISTVIEW_MODES

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	CString strProjectDir;
	pos = pParent->m_strlistProjects.GetHeadPosition();
	if (pos != NULL)
	{
		POSITION pos2 = pParent->m_ptrlistBuilders.GetHeadPosition();
		while (pos != NULL)
		{
			CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORFILE);
			ASSERT(pos2 != NULL);
			CString strProject = pParent->m_strlistProjects.GetNext(pos);
			IPkgProject *pProject = (IPkgProject *)pParent->m_ptrlistBuilders.GetNext(pos2);
			int nIndex = pComboBox->InsertString(-1, strProject);
			pComboBox->SetItemData(nIndex, (DWORD)pProject);
			if (pProject == pParent->m_pActiveProject)
			{
				pComboBox->SetCurSel(nIndex);

				m_nIndex = nIndex;

				LPCOLESTR pszProjName, pszProjPath;
				DWORD dwPackageID, dwFlags;
				pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
				CString strProjPath = pszProjPath;
				CPath path;
				path.Create(strProjPath);
				CDir dir;
				dir.CreateFromPath(path);
				strProjectDir = (const TCHAR *)dir;
				CoTaskMemFree((void *)pszProjName);
				CoTaskMemFree((void *)pszProjPath);
			}
		}
		ASSERT(pos2 == NULL);
	}
	else
	{
		m_fAddToProject = FALSE;
		((CButton *)GetDlgItem(IDC_ADDFILETOPROJECT))->SetCheck(m_fAddToProject);
		GetDlgItem(IDC_ADDFILETOPROJECT)->EnableWindow(m_fAddToProject);
	}

	GetDlgItem(IDC_PROJECTFORFILE)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_NAMEFORFILE)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_FILENAMESTATIC)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_LOCATIONFORFILE)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_FILELOCATIONSTATIC)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_BROWSE)->EnableWindow(m_fAddToProject);

	if (!strProjectDir.IsEmpty())
		SetDlgItemText(IDC_LOCATIONFORFILE, strProjectDir);

	// limit length of file name
	((CEdit *)GetDlgItem(IDC_NAMEFORFILE))->LimitText(_MAX_FNAME);

	m_fIsInitialized = TRUE;

	if (m_nFocusCtrlId == -1)
		return(TRUE);

	CWnd *pWnd = GetDlgItem(m_nFocusCtrlId);
	if (pWnd == NULL)
		return(TRUE);

	GotoDlgCtrl(pWnd);
	return(FALSE);
}

BOOL CNewFileDialogTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	BOOL fRet = CDlgTab::Activate(pParentWnd, position);
	EnableButtons();
	return fRet;
}

void CNewFileDialogTab::Deactivate(CTabbedDialog* pParentWnd)
{
	CDlgTab::Deactivate(pParentWnd);
}

BOOL CNewFileDialogTab::ValidateTab()
{
	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	if (pParent->IsCommitting() || m_fDoubleClicked)
	{
		if (m_FileTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) == -1)
		{
			MsgBox(Error, IDS_ERR_FILE_TYPE);
			m_FileTypes.SetFocus();
			return FALSE;
		}

		m_nSelected = m_FileTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
		CPartTemplate *pTemplate = (CPartTemplate *)m_FileTypes.GetItemData(m_nSelected);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));

		((CEdit *)GetDlgItem(IDC_NAMEFORFILE))->GetWindowText(m_strFileName);

		// trim leading and trailing spaces from filename...
		m_strFileName.TrimLeft();
		m_strFileName.TrimRight();
		CString strCreate;

		if (!m_strFileName.IsEmpty())
		{
			// add default extension for name checking--it will be added on creation.
			if (m_strFileName.Find('.') == -1)
			{
				CString strExtension;
				pTemplate->GetDocString(strExtension, CDocTemplate::filterExt);
				m_strFileName += strExtension;
			}

			((CEdit *)GetDlgItem(IDC_LOCATIONFORFILE))->GetWindowText(m_strPathName);
			CreateFileError cfe = CanCreateFile(m_strFileName, m_strPathName, TRUE);
			if (cfe == cfeFileExists)
			{
				if (MsgBox(Question, IDS_EXISTING_FILEPATH, MB_YESNO) != IDYES)
					return FALSE;
			}
			else if (cfe == cfeInvalidFile || cfe == cfeCannotCreateFile)
			{
				if (m_strFileName.GetLength() + m_strPathName.GetLength() >= _MAX_PATH - 1)
				{
					CString strMsg;
					MsgBox(Error, MsgText(strMsg, IDS_TOOLONG_FILENAME, m_strFileName, m_strPathName));
				}
				else
					MsgBox(Error, IDS_INVALID_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORFILE));
				return FALSE;
			}
			else if (cfe == cfeInvalidPath || cfe == cfeNonexistentPath || cfe == cfeCannotCreatePath)
			{
				MsgBox(Error, IDS_INVALID_PATHNAME);
				GotoDlgCtrl(GetDlgItem(IDC_LOCATIONFORFILE));
				return FALSE;
			}

			strCreate = m_strPathName;
			EnsureSlashAtEnd(strCreate);
			strCreate += m_strFileName;

			if (!pTemplate->CanCreateDocument(strCreate))
			{
				// pTemplate is responsible for issuing appropriate error message!
				return FALSE;
			}
		}
		if (IsDlgButtonChecked(IDC_ADDFILETOPROJECT))
		{
			if (m_strFileName.IsEmpty())
			{
				MsgBox(Error, IDS_NEED_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORFILE));
				return FALSE;
			}

			USES_CONVERSION;

			CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORFILE);
			IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemData(m_nIndex);
			if (pProject->CanAddFile(T2W(strCreate), NULL, TRUE) != S_OK)
			{
				return FALSE;
			}
		}
	}

	return(TRUE);
}

void CNewFileDialogTab::CommitTab()
{
	CDlgTab::CommitTab();

	m_nSelected = m_FileTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	CDocTemplate *pTemplate = (CDocTemplate *)m_FileTypes.GetItemData(m_nSelected);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	pParent->SetType(CPartTemplate::newfile);
	pParent->SetTemplate(pTemplate);
	pParent->SetAddToProject(m_fAddToProject);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	pParent->SetFileName(m_strFileName);
	pParent->SetPathName(m_strPathName);
	if (m_fAddToProject)
	{
		CString strProject;
		CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORFILE);
		pComboBox->GetLBText(m_nIndex, strProject);
		DWORD dwData = pComboBox->GetItemData(m_nIndex);
		pParent->SetProject((IPkgProject *)dwData);
	}

	if (m_fForceAddToProj)
		m_fAddToProject = m_fAddToProjectPrev;
}

void CNewFileDialogTab::CancelTab()
{
	CDlgTab::CancelTab();

	if (m_fForceAddToProj)
		m_fAddToProject = m_fAddToProjectPrev;
}

void CNewFileDialogTab::OnBrowse()
{
	CDir dir;
	if (!dir.CreateFromStringEx(m_strPathName, TRUE))
		VERIFY(dir.CreateFromCurrent());

	CDirChooser dlg((const TCHAR *)dir);
	if (dlg.DoModal() == IDOK)
	{
		m_strPathName = dlg.GetPathName();
		GetDlgItem(IDC_LOCATIONFORFILE)->SetWindowText(m_strPathName);
	}
	EnableButtons();
}

#ifdef ENABLE_LISTVIEW_MODES
void CNewFileDialogTab::OnClickLargeIconView()
{
	SetListCtrlStyle(&m_FileTypes, LVS_ICON);
	c_ViewMode = largeicon;
}

void CNewFileDialogTab::OnClickSmallIconView()
{
	SetListCtrlStyle(&m_FileTypes, LVS_SMALLICON);
	c_ViewMode = smallicon;
}

void CNewFileDialogTab::OnClickListView()
{
	SetListCtrlStyle(&m_FileTypes, LVS_LIST);
	c_ViewMode = list;
}
#endif	// ENABLE_LISTVIEW_MODES

void CNewFileDialogTab::OnClickAddToProject()
{
	GetDlgItem(IDC_PROJECTFORFILE)->EnableWindow(IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
//	GetDlgItem(IDC_NAMEFORFILE)->EnableWindow(IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
//	GetDlgItem(IDC_LOCATIONFORFILE)->EnableWindow(IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
//	GetDlgItem(IDC_FILENAMESTATIC)->EnableWindow(IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
//	GetDlgItem(IDC_FILELOCATIONSTATIC)->EnableWindow(IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
//	GetDlgItem(IDC_BROWSE)->EnableWindow(IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
	EnableButtons();
}

void CNewFileDialogTab::OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult)
{
	m_fDoubleClicked = TRUE;
	if (ValidateTab())
	{
		CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
		ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
		pParent->OnOK();
	}
	m_fDoubleClicked = FALSE;
}

void CNewFileDialogTab::OnSelectType(NMHDR* pNMHDR, LRESULT* pResult)
{
	EnableButtons();
}

void CNewFileDialogTab::OnChangeName()
{
	EnableButtons();
}

void CNewFileDialogTab::OnChangeLocation()
{
	EnableButtons();
}

void CNewFileDialogTab::OnProjectChange()
{
	CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORFILE);
	m_nIndex = pComboBox->GetCurSel();
	IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemDataPtr(m_nIndex);
	LPCOLESTR pszProjName, pszProjPath;
	DWORD dwPackageID, dwFlags;
	pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
	CString strProjPath = pszProjPath;
	CPath path;
	path.Create(strProjPath);
	CDir dir;
	dir.CreateFromPath(path);
	CString strProjectDir = (const TCHAR *)dir;
	SetDlgItemText(IDC_LOCATIONFORFILE, strProjectDir);
	CoTaskMemFree((void *)pszProjName);
	CoTaskMemFree((void *)pszProjPath);
}

void CNewFileDialogTab::EnableButtons()
{
	if (!m_fIsInitialized)
		return;

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->m_btnOk.GetSafeHwnd() == NULL)
		return;

	((CEdit *)GetDlgItem(IDC_NAMEFORFILE))->GetWindowText(m_strFileName);
	((CEdit *)GetDlgItem(IDC_LOCATIONFORFILE))->GetWindowText(m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	BOOL fHasItems = (m_FileTypes.GetItemCount() > 0);
	BOOL fSelected = (m_FileTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) != -1);
	BOOL fAddToPrj = (IsDlgButtonChecked(IDC_ADDFILETOPROJECT));
	BOOL fFileName = (!m_strFileName.IsEmpty());
	BOOL fFilePath = (!m_strPathName.IsEmpty());

	if (fHasItems && fSelected && (!fAddToPrj || (fAddToPrj && fFileName && fFilePath)))
	{
		pParent->SetDefButtonIndex(IDOK - 1);
		pParent->m_btnOk.EnableWindow(TRUE);
	}
	else
	{
		pParent->SetDefButtonIndex(IDCANCEL - 1);
		pParent->m_btnOk.EnableWindow(FALSE);
	}
}

BEGIN_MESSAGE_MAP(CNewFileDialogTab, CDlgTab)
	//{{AFX_MSG_MAP (CNewFileDialogTab)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
#ifdef ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_LARGEICONVIEW, OnClickLargeIconView)
	ON_BN_CLICKED(IDC_SMALLICONVIEW, OnClickSmallIconView)
	ON_BN_CLICKED(IDC_LISTVIEW, OnClickListView)
#endif	// ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_ADDFILETOPROJECT, OnClickAddToProject)
	ON_NOTIFY(NM_DBLCLK, IDC_FILETYPES, OnDblClkType)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_FILETYPES, OnSelectType)
	ON_EN_CHANGE(IDC_NAMEFORFILE, OnChangeName)
	ON_EN_CHANGE(IDC_LOCATIONFORFILE, OnChangeLocation)
	ON_CBN_SELCHANGE(IDC_PROJECTFORFILE, OnProjectChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewTemplateDialogTab

int CNewTemplateDialogTab::m_nSelected;
BOOL CNewTemplateDialogTab::m_fAddToProject = TRUE;
int CNewTemplateDialogTab::m_nIndex;
CString CNewTemplateDialogTab::m_strFileName;
CString CNewTemplateDialogTab::m_strPathName;
int CNewTemplateDialogTab::m_nFocusCtrlId = -1;
#ifdef ENABLE_LISTVIEW_MODES
VIEW_MODE CNewTemplateDialogTab::c_ViewMode = smallicon;
#endif	// ENABLE_LISTVIEW_MODES

IMPLEMENT_DYNAMIC(CNewTemplateDialogTab, CDlgTab);

CNewTemplateDialogTab::CNewTemplateDialogTab(BOOL bUseSavedData /*=FALSE*/, BOOL bForceAddToProject /*=FALSE*/)
	: CDlgTab(IDDP_FILENEW_TEMPLATES, IDS_TEMPLATESTAB)
{
	if (!bUseSavedData)
	{
		m_nFocusCtrlId = -1;
		m_nSelected = 0;
		m_strFileName.Empty();
	}

	if (m_strPathName.IsEmpty())
	{
		CDir dir;
		dir.CreateFromCurrent();
		m_strPathName = (const TCHAR *)dir;
	}

	if (bForceAddToProject)
	{
		m_fAddToProjectPrev = m_fAddToProject;
		m_fAddToProject = TRUE;
	}
	m_fForceAddToProj = bForceAddToProject;

	m_fIsInitialized = FALSE;
	m_fDoubleClicked = FALSE;
}

void CNewTemplateDialogTab::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);
	
	//{{AFX_DATA_MAP(CNewTemplateDialogTab)
	DDX_Control(pDX, IDC_TEMPLATETYPES, m_TemplateTypes);
	DDX_Check(pDX, IDC_ADDTEMPLATETOPROJECT, m_fAddToProject);
	DDX_CBIndex(pDX, IDC_PROJECTFORTEMPLATE, m_nIndex);
	DDX_Text(pDX, IDC_NAMEFORTEMPLATE, m_strFileName);
	DDX_Text(pDX, IDC_LOCATIONFORTEMPLATE, m_strPathName);
	//}}AFX_DATA_MAP
}

BOOL CNewTemplateDialogTab::OnInitDialog()
{
	UpdateData(FALSE);

//	m_imageListNormal.Create(32, 32, ILC_COLOR, 1, 1);
//	m_imageListNormal.SetBkColor(GetSysColor(COLOR_WINDOW));
	m_imageListSmall.Create(16, 16, ILC_COLOR, 1, 1);
	m_imageListSmall.SetBkColor(GetSysColor(COLOR_WINDOW));

	POSITION pos = theApp.GetFirstDocTemplatePosition();

	// Set the generic members of the LV_ITEM stuct:
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvItem.iSubItem = 0;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = 0;

	// while loop variables
	CPartTemplate *pTemplate;
	HICON hIcon;
	CString strDisplay;
	int nIndex = 0;
	int nColumnWidth = 0;
	while (pos != NULL)
	{
		pTemplate = (CPartTemplate *)theApp.GetNextDocTemplate(pos);
		ASSERT(pTemplate != NULL);
		if (CPartTemplate::newtemplate == pTemplate->GetTabType() && (hIcon = pTemplate->GetIcon()) &&
			pTemplate->GetDocString(strDisplay, CDocTemplate::fileNewName) && !strDisplay.IsEmpty())
		{
			hIcon = pTemplate->GetIcon();
		//	m_imageListNormal.Add(hIcon);
			m_imageListSmall.Add(hIcon);

			pTemplate->GetDocString(strDisplay, CDocTemplate::fileNewName);
			lvItem.iItem = nIndex;
			lvItem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
			lvItem.iImage = nIndex;
			lvItem.lParam = (LPARAM)pTemplate;

			VERIFY(m_TemplateTypes.InsertItem(&lvItem) != -1);

			nColumnWidth = max(nColumnWidth, m_TemplateTypes.GetStringWidth(strDisplay));
			nIndex++;
		}
	}

	m_TemplateTypes.SetColumnWidth(-1, nColumnWidth + COLUMNEXTRA);
	m_TemplateTypes.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

//	m_TemplateTypes.SetImageList(&m_imageListNormal, LVSIL_NORMAL);
	m_TemplateTypes.SetImageList(&m_imageListSmall, LVSIL_SMALL);

#ifndef ENABLE_LISTVIEW_MODES
	SetListCtrlStyle(&m_TemplateTypes, LVS_SMALLICON);
	SetListCtrlStyle(&m_TemplateTypes, LVS_LIST);
#else	// ENABLE_LISTVIEW_MODES
	switch (c_ViewMode)
	{
		case largeicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LARGEICONVIEW);
			SetListCtrlStyle(&m_TemplateTypes, LVS_SMALLICON);
			SetListCtrlStyle(&m_TemplateTypes, LVS_ICON);
			break;

		case smallicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_SMALLICONVIEW);
			SetListCtrlStyle(&m_TemplateTypes, LVS_ICON);
			SetListCtrlStyle(&m_TemplateTypes, LVS_SMALLICON);
			break;

		case list:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LISTVIEW);
			SetListCtrlStyle(&m_TemplateTypes, LVS_ICON);
			SetListCtrlStyle(&m_TemplateTypes, LVS_LIST);
			break;
	}
#endif	// ENABLE_LISTVIEW_MODES

	OnSelectType(NULL, NULL);

	// limit length of template name
	((CEdit *)GetDlgItem(IDC_NAMEFORTEMPLATE))->LimitText(_MAX_FNAME);

	m_fIsInitialized = TRUE;

	if (m_nFocusCtrlId == -1)
		return(TRUE);

	CWnd *pWnd = GetDlgItem(m_nFocusCtrlId);
	if (pWnd == NULL)
		return(TRUE);

	GotoDlgCtrl(pWnd);
	return(FALSE);
}

BOOL CNewTemplateDialogTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	BOOL fRet = CDlgTab::Activate(pParentWnd, position);
	EnableButtons();
	return fRet;
}

void CNewTemplateDialogTab::Deactivate(CTabbedDialog* pParentWnd)
{
	CDlgTab::Deactivate(pParentWnd);
}

BOOL CNewTemplateDialogTab::ValidateTab()
{
	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	if (pParent->IsCommitting() || m_fDoubleClicked)
	{
		if (m_TemplateTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) == -1)
		{
			MsgBox(Error, IDS_ERR_WIZARD_TYPE);
			m_TemplateTypes.SetFocus();
			return FALSE;
		}

		m_nSelected = m_TemplateTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
		CPartTemplate *pTemplate = (CPartTemplate *)m_TemplateTypes.GetItemData(m_nSelected);

		if (IsDlgButtonChecked(IDC_ADDTEMPLATETOPROJECT))
		{
			((CEdit *)GetDlgItem(IDC_NAMEFORTEMPLATE))->GetWindowText(m_strFileName);

			// trim leading and trailing spaces from filename...
			m_strFileName.TrimLeft();
			m_strFileName.TrimRight();

			if (m_strFileName.IsEmpty())
			{
				MsgBox(Error, IDS_NEED_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORTEMPLATE));
				return FALSE;
			}

			((CEdit *)GetDlgItem(IDC_LOCATIONFORTEMPLATE))->GetWindowText(m_strPathName);
			CString strCreate;
			strCreate = m_strPathName;
			EnsureSlashAtEnd(strCreate);
			strCreate += m_strFileName;

			ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
			CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORTEMPLATE);
			ASSERT(m_nIndex >= 0);
			IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemData(m_nIndex);

			if (!pTemplate->CanBeAddedToProject(pProject))
			{
				MsgBox(Error, IDS_ERR_WIZARD_PROJ);
				return FALSE;
			}

			if (!pTemplate->CanCreateDocument(strCreate))
			{
				// pTemplate is responsible for issuing appropriate error message!
				return FALSE;
			}

			USES_CONVERSION;
			if (pProject->CanAddFile(T2W(strCreate), NULL, TRUE) != S_OK)
			{
				return FALSE;
			}

			CreateFileError cfe = CanCreateFile(m_strFileName, m_strPathName, TRUE);
			if (cfe == cfeFileExists)
			{
				return(MsgBox(Question, IDS_EXISTING_FILEPATH, MB_YESNO) == IDYES);
			}
			else if (cfe == cfeInvalidFile || cfe == cfeCannotCreateFile)
			{
				if (m_strFileName.GetLength() + m_strPathName.GetLength() >= _MAX_PATH - 1)
				{
					CString strMsg;
					MsgBox(Error, MsgText(strMsg, IDS_TOOLONG_FILENAME, m_strFileName, m_strPathName));
				}
				else
					MsgBox(Error, IDS_INVALID_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORTEMPLATE));
				return FALSE;
			}
			else if (cfe == cfeInvalidPath || cfe == cfeNonexistentPath || cfe == cfeCannotCreatePath)
			{
				MsgBox(Error, IDS_INVALID_PATHNAME);
				GotoDlgCtrl(GetDlgItem(IDC_LOCATIONFORTEMPLATE));
				return FALSE;
			}
		}
		else if (!pTemplate->CanBeAddedToProject(NULL))
		{
			MsgBox(Error, IDS_ERR_WIZARD_NO_PROJ);
			return FALSE;
		}
		else
		{
			return(MsgBox(Question, IDS_WIZARD_ORPHANS));
		}
	}

	return(TRUE);
}

void CNewTemplateDialogTab::CommitTab()
{
	CDlgTab::CommitTab();

	m_nSelected = m_TemplateTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	CDocTemplate *pTemplate = (CDocTemplate *)m_TemplateTypes.GetItemData(m_nSelected);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	pParent->SetType(CPartTemplate::newfile);
	pParent->SetTemplate(pTemplate);
	pParent->SetAddToProject(m_fAddToProject);

	if (m_fAddToProject)
	{
		// trim leading and trailing spaces from filename...
		m_strFileName.TrimLeft();
		m_strFileName.TrimRight();

		pParent->SetFileName(m_strFileName);
		pParent->SetPathName(m_strPathName);
		CString strProject;
		//CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORFILE);
		CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORTEMPLATE);

		pComboBox->GetLBText(m_nIndex, strProject);
		DWORD dwData = pComboBox->GetItemData(m_nIndex);
		pParent->SetProject((IPkgProject *)dwData);
	}

	if (m_fForceAddToProj)
		m_fAddToProject = m_fAddToProjectPrev;
}

void CNewTemplateDialogTab::CancelTab()
{
	CDlgTab::CancelTab();

	if (m_fForceAddToProj)
		m_fAddToProject = m_fAddToProjectPrev;
}

void CNewTemplateDialogTab::OnBrowse()
{
	CDir dir;
	if (!dir.CreateFromStringEx(m_strPathName, TRUE))
		VERIFY(dir.CreateFromCurrent());

	CDirChooser dlg((const TCHAR *)dir);
	if (dlg.DoModal() == IDOK)
	{
		m_strPathName = dlg.GetPathName();
		GetDlgItem(IDC_LOCATIONFORTEMPLATE)->SetWindowText(m_strPathName);
	}
	EnableButtons();
}

#ifdef ENABLE_LISTVIEW_MODES
void CNewTemplateDialogTab::OnClickLargeIconView()
{
	SetListCtrlStyle(&m_TemplateTypes, LVS_ICON);
	c_ViewMode = largeicon;
}

void CNewTemplateDialogTab::OnClickSmallIconView()
{
	SetListCtrlStyle(&m_TemplateTypes, LVS_SMALLICON);
	c_ViewMode = smallicon;
}

void CNewTemplateDialogTab::OnClickListView()
{
	SetListCtrlStyle(&m_TemplateTypes, LVS_LIST);
	c_ViewMode = list;
}
#endif	// ENABLE_LISTVIEW_MODES

void CNewTemplateDialogTab::OnClickAddToProject()
{
	EnableButtons();
}

void CNewTemplateDialogTab::OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult)
{
	m_fDoubleClicked = TRUE;
	if (ValidateTab())
	{
		CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
		ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
		pParent->OnOK();
	}
	m_fDoubleClicked = FALSE;
}

void CNewTemplateDialogTab::OnSelectType(NMHDR* pNMHDR, LRESULT* pResult)
{
	m_nIndex = -1;
	m_nSelected = m_TemplateTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	if (m_nSelected == -1)
		return;
	CPartTemplate *pTemplate = (CPartTemplate *)m_TemplateTypes.GetItemData(m_nSelected);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORTEMPLATE);
	pComboBox->ResetContent();

	BOOL fHaveProjects = FALSE;
	CString strProjectDir;
	POSITION pos = pParent->m_strlistProjects.GetHeadPosition();
	if (pos != NULL)
	{
		POSITION pos2 = pParent->m_ptrlistBuilders.GetHeadPosition();
		while (pos != NULL)
		{
			ASSERT(pos2 != NULL);
			CString strProject = pParent->m_strlistProjects.GetNext(pos);
			IPkgProject *pProject = (IPkgProject *)pParent->m_ptrlistBuilders.GetNext(pos2);

			// project list only contains projects that the wizard can be added to...
			if (pTemplate->CanBeAddedToProject(pProject))
			{
				int nIndex = pComboBox->InsertString(-1, strProject);
				pComboBox->SetItemData(nIndex, (DWORD)pProject);
				if (pProject == pParent->m_pActiveProject)
				{
					pComboBox->SetCurSel(nIndex);

					m_nIndex = nIndex;

					LPCOLESTR pszProjName, pszProjPath;
					DWORD dwPackageID, dwFlags;
					pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
					CString strProjPath = pszProjPath;
					CPath path;
					path.Create(strProjPath);
					CDir dir;
					dir.CreateFromPath(path);
					strProjectDir = (const TCHAR *)dir;
					CoTaskMemFree((void *)pszProjName);
					CoTaskMemFree((void *)pszProjPath);
				}
				fHaveProjects = TRUE;
			}
		}
		ASSERT(pos2 == NULL);
	}

	if (fHaveProjects && (m_nIndex == -1))
	{
		m_nIndex = 0;
		pComboBox->SetCurSel(m_nIndex);
	}

	if (fHaveProjects && !pTemplate->CanBeAddedToProject(NULL))
	{
		((CButton *)GetDlgItem(IDC_ADDTEMPLATETOPROJECT))->SetCheck(TRUE);
		GetDlgItem(IDC_ADDTEMPLATETOPROJECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_PROJECTFORTEMPLATE)->EnableWindow(TRUE);
		GetDlgItem(IDC_EXPLANATION)->ShowWindow(SW_HIDE);
	}
	else if (!fHaveProjects)
	{
		((CButton *)GetDlgItem(IDC_ADDTEMPLATETOPROJECT))->SetCheck(FALSE);
		GetDlgItem(IDC_ADDTEMPLATETOPROJECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_PROJECTFORTEMPLATE)->EnableWindow(FALSE);
		GetDlgItem(IDC_EXPLANATION)->ShowWindow(SW_SHOW);
	}
	else
	{
		((CButton *)GetDlgItem(IDC_ADDTEMPLATETOPROJECT))->SetCheck(m_fAddToProject);
		GetDlgItem(IDC_ADDTEMPLATETOPROJECT)->EnableWindow(TRUE);
		GetDlgItem(IDC_PROJECTFORTEMPLATE)->EnableWindow(m_fAddToProject);
		GetDlgItem(IDC_EXPLANATION)->ShowWindow(SW_HIDE);
	}

	if (!strProjectDir.IsEmpty())
		SetDlgItemText(IDC_LOCATIONFORTEMPLATE, strProjectDir);

	EnableButtons();
}

void CNewTemplateDialogTab::OnChangeName()
{
	EnableButtons();
}

void CNewTemplateDialogTab::OnChangeLocation()
{
	EnableButtons();
}

void CNewTemplateDialogTab::OnProjectChange()
{
	CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFORTEMPLATE);
	m_nIndex = pComboBox->GetCurSel();
	ASSERT(m_nIndex >= 0);
	IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemDataPtr(m_nIndex);
	LPCOLESTR pszProjName, pszProjPath;
	DWORD dwPackageID, dwFlags;
	pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
	CString strProjPath = pszProjPath;
	CPath path;
	path.Create(strProjPath);
	CDir dir;
	dir.CreateFromPath(path);
	CString strProjectDir = (const TCHAR *)dir;
	SetDlgItemText(IDC_LOCATIONFORTEMPLATE, strProjectDir);
	CoTaskMemFree((void *)pszProjName);
	CoTaskMemFree((void *)pszProjPath);
}

void CNewTemplateDialogTab::EnableButtons()
{
	if (!m_fIsInitialized)
		return;

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->m_btnOk.GetSafeHwnd() == NULL)
		return;

	((CEdit *)GetDlgItem(IDC_NAMEFORTEMPLATE))->GetWindowText(m_strFileName);
	((CEdit *)GetDlgItem(IDC_LOCATIONFORTEMPLATE))->GetWindowText(m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	BOOL fHasItems = (m_TemplateTypes.GetItemCount() > 0);
	BOOL fSelected = (m_TemplateTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) != -1);
	BOOL fAddToPrj = (IsDlgButtonChecked(IDC_ADDTEMPLATETOPROJECT));
	BOOL fFileName = (!m_strFileName.IsEmpty());
	BOOL fFilePath = (!m_strPathName.IsEmpty());

	if (fHasItems && fSelected && (!fAddToPrj || (fAddToPrj && fFileName && fFilePath)))
	{
		pParent->SetDefButtonIndex(IDOK - 1);
		pParent->m_btnOk.EnableWindow(TRUE);
	}
	else
	{
		pParent->SetDefButtonIndex(IDCANCEL - 1);
		pParent->m_btnOk.EnableWindow(FALSE);
	}
}

BEGIN_MESSAGE_MAP(CNewTemplateDialogTab, CDlgTab)
	//{{AFX_MSG_MAP (CNewTemplateDialogTab)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
#ifdef ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_LARGEICONVIEW, OnClickLargeIconView)
	ON_BN_CLICKED(IDC_SMALLICONVIEW, OnClickSmallIconView)
	ON_BN_CLICKED(IDC_LISTVIEW, OnClickListView)
#endif	// ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_ADDTEMPLATETOPROJECT, OnClickAddToProject)
	ON_NOTIFY(NM_DBLCLK, IDC_TEMPLATETYPES, OnDblClkType)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_TEMPLATETYPES, OnSelectType)
	ON_EN_CHANGE(IDC_NAMEFORTEMPLATE, OnChangeName)
	ON_EN_CHANGE(IDC_LOCATIONFORTEMPLATE, OnChangeLocation)
	ON_CBN_SELCHANGE(IDC_PROJECTFORTEMPLATE, OnProjectChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProjectDialogTab

int CNewProjectDialogTab::m_nSelected;
BOOL CNewProjectDialogTab::m_fCreateNew = TRUE;
BOOL CNewProjectDialogTab::m_fDependency;
int CNewProjectDialogTab::m_nIndexProject;
int CNewProjectDialogTab::m_nIndexPlatform;
CString CNewProjectDialogTab::m_strFileName;
CString CNewProjectDialogTab::m_strPathName;
CString CNewProjectDialogTab::m_strPrevName;
int CNewProjectDialogTab::m_nFocusCtrlId = -1;
int CNewProjectDialogTab::m_nIndexSave = -1;
#ifdef ENABLE_LISTVIEW_MODES
VIEW_MODE CNewProjectDialogTab::c_ViewMode = smallicon;
#endif	// ENABLE_LISTVIEW_MODES

IMPLEMENT_DYNAMIC(CNewProjectDialogTab, CDlgTab);

CNewProjectDialogTab::CNewProjectDialogTab(BOOL bUseSavedData /*=FALSE*/, BOOL bForceAddToProject /*=FALSE*/)
	: CDlgTab(IDDP_FILENEW_PROJECTS, IDS_PROJECTSTAB)
{
	if (!bUseSavedData)
	{
		m_nFocusCtrlId = -1;
		m_nSelected = 0;
		m_strFileName.Empty();
		m_strPrevName.Empty();

		IProjectWorkspace *pInterface;
		pInterface = g_IdeInterface.GetProjectWorkspace();
		ASSERT(pInterface != NULL);

		BOOL fWorkspaceInit = (pInterface->IsWorkspaceInitialised() == S_OK);
		if (!fWorkspaceInit)
			m_fCreateNew = TRUE;

		m_fDependency = FALSE;
	}

	m_nIndexSave = -1;

	if (bForceAddToProject)
	{
		m_fCreateNewPrev = m_fCreateNew;
		m_fCreateNew = FALSE;
	}
	m_fForceAddToWks = bForceAddToProject;

	m_fIsInitialized = FALSE;
	m_fDoubleClicked = FALSE;
}

void CNewProjectDialogTab::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CNewProjectDialogTab)
	DDX_Control(pDX, IDC_PROJECTTYPES, m_ProjectTypes);
	DDX_Check(pDX, IDC_CREATENEWWORKSPACE, m_fCreateNew);
	DDX_Check(pDX, IDC_DEPENDENCYOF, m_fDependency);
	DDX_CBIndex(pDX, IDC_DEPENDENCYPROJECT, m_nIndexProject);
	DDX_LBIndex(pDX, IDC_PLATFORMS, m_nIndexPlatform);
	DDX_Text(pDX, IDC_NAMEFORPROJECT, m_strFileName);
	DDX_Text(pDX, IDC_LOCATIONFORPROJECT, m_strPathName);
	//}}AFX_DATA_MAP
}

BOOL CNewProjectDialogTab::OnInitDialog()
{
	CWaitCursor wc;
	UpdateData(FALSE);

	m_fUserChangedLocation = FALSE;

	// Subclass the check listbox
	VERIFY(m_Platforms.SubclassDlgItem(IDC_PLATFORMS, this));
	
	CPtrArray paProjects;
//	paProjects.RemoveAll();

	IProjectWorkspace *pInterface;
	pInterface = g_IdeInterface.GetProjectWorkspace();
	ASSERT(pInterface != NULL);
	pInterface->GetProjectTypes(&paProjects);

//	m_imageListNormal.Create(32, 32, ILC_COLOR, 1, 1);
//	m_imageListNormal.SetBkColor(GetSysColor(COLOR_WINDOW));
	m_imageListSmall.Create(16, 16, ILC_COLOR, 1, 1);
	m_imageListSmall.SetBkColor(GetSysColor(COLOR_WINDOW));

	// Set the generic members of the LV_ITEM stuct:
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvItem.iSubItem = 0;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = 0;

	BOOL fSupportsDeps = FALSE;
	int nSize;
	int nColumnWidth = 0;
	if ((nSize = paProjects.GetSize()) != 0)
	{
		for (int nIndex = 0; nIndex < nSize; nIndex++)
		{
			CProjTypeItem *pItem = (CProjTypeItem *)paProjects.GetAt(nIndex);

			ASSERT(pItem->m_hIcon != NULL);
		//	m_imageListNormal.Add(pItem->m_hIcon);
			m_imageListSmall.Add(pItem->m_hIcon);

			lvItem.iItem = nIndex;
			lvItem.pszText = (LPTSTR)(LPCTSTR)pItem->m_strName;
			lvItem.iImage = nIndex;
			lvItem.lParam = (LPARAM)pItem;

			VERIFY(m_ProjectTypes.InsertItem(&lvItem) != -1);

			if ((nIndex == m_nSelected) && (pItem->m_bSupportDependency))
				fSupportsDeps = TRUE;

			nColumnWidth = max(nColumnWidth, m_ProjectTypes.GetStringWidth(pItem->m_strName));
		}
	}

	m_ProjectTypes.SetColumnWidth(-1, nColumnWidth + COLUMNEXTRA);
	m_ProjectTypes.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

//	m_ProjectTypes.SetImageList(&m_imageListNormal, LVSIL_NORMAL);
	m_ProjectTypes.SetImageList(&m_imageListSmall, LVSIL_SMALL);

#ifndef ENABLE_LISTVIEW_MODES
	SetListCtrlStyle(&m_ProjectTypes, LVS_SMALLICON);
	SetListCtrlStyle(&m_ProjectTypes, LVS_LIST);
#else	// ENABLE_LISTVIEW_MODES
	switch (c_ViewMode)
	{
		case largeicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LARGEICONVIEW);
			SetListCtrlStyle(&m_ProjectTypes, LVS_SMALLICON);
			SetListCtrlStyle(&m_ProjectTypes, LVS_ICON);
			break;

		case smallicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_SMALLICONVIEW);
			SetListCtrlStyle(&m_ProjectTypes, LVS_ICON);
			SetListCtrlStyle(&m_ProjectTypes, LVS_SMALLICON);
			break;

		case list:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LISTVIEW);
			SetListCtrlStyle(&m_ProjectTypes, LVS_ICON);
			SetListCtrlStyle(&m_ProjectTypes, LVS_LIST);
			break;
	}
#endif	// ENABLE_LISTVIEW_MODES

	BOOL fWorkspaceInit = (pInterface->IsWorkspaceInitialised() == S_OK);
	BOOL fWorkspaceTemp = (pInterface->IsWorkspaceTemporary() == S_OK);
	if (!fWorkspaceInit || fWorkspaceTemp)
		m_fCreateNew = TRUE;
	GetDlgItem(IDC_ADDTOCURRENTWORKSPACE)->EnableWindow(fWorkspaceInit && !fWorkspaceTemp);

	((CButton *)GetDlgItem(IDC_CREATENEWWORKSPACE))->SetCheck(m_fCreateNew);
	((CButton *)GetDlgItem(IDC_ADDTOCURRENTWORKSPACE))->SetCheck(!m_fCreateNew);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	m_nIndexProject = 0;
	CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_DEPENDENCYPROJECT);
	BOOL fComboEmpty = TRUE;
	POSITION pos = pParent->m_strlistProjects.GetHeadPosition();
	if (pos != NULL)
	{
		POSITION pos2 = pParent->m_ptrlistBuilders.GetHeadPosition();
		while (pos != NULL)
		{
			ASSERT(pos2 != NULL);
			CString strProject = pParent->m_strlistProjects.GetNext(pos);
			IPkgProject *pProject = (IPkgProject *)pParent->m_ptrlistBuilders.GetNext(pos2);
			LPCOLESTR lpszProjectName, lpszProjectPath;
			DWORD dwPackageID, dwFlags;
			// REVIEW [patbr]: should be able to pass NULL in for arguments we are not interested in!
			VERIFY(SUCCEEDED(pProject->GetProjectInfo(&lpszProjectName, &lpszProjectPath, &dwPackageID, &dwFlags)));
			if (dwFlags & GPI_PROJSUPPORTSDEPS)
			{
				int nIndex = pComboBox->InsertString(-1, strProject);
				pComboBox->SetItemData(nIndex, (DWORD)pProject);
				if (pProject == pParent->m_pActiveProject)
					m_nIndexProject = nIndex;
				fComboEmpty = FALSE;
			}
		}
		ASSERT(pos2 == NULL);
	}

	pComboBox->SetCurSel(m_nIndexProject);

	GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(fSupportsDeps && !m_fCreateNew && !fComboEmpty);
	GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(fSupportsDeps && !m_fCreateNew && !fComboEmpty && m_fDependency);

	m_nIndexSave = -1;
	OnSelectType(NULL, NULL);

	// limit length of project name
	((CEdit *)GetDlgItem(IDC_NAMEFORPROJECT))->LimitText(_MAX_FNAME);

	m_fIsInitialized = TRUE;

	if (m_nFocusCtrlId == -1)
		return(TRUE);

	CWnd *pWnd = GetDlgItem(m_nFocusCtrlId);
	if (pWnd == NULL)
		return(TRUE);

	GotoDlgCtrl(pWnd);
	return(FALSE);
}

BOOL CNewProjectDialogTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	BOOL fRet = CDlgTab::Activate(pParentWnd, position);
	EnableButtons();
	return fRet;
}

void CNewProjectDialogTab::Deactivate(CTabbedDialog* pParentWnd)
{
	CDlgTab::Deactivate(pParentWnd);
}

BOOL CNewProjectDialogTab::ValidateTab()
{
	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->IsCommitting() || m_fDoubleClicked)
	{
		if (m_ProjectTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) == -1)
		{
			MsgBox(Error, IDS_ERR_PROJECT_TYPE);
			m_ProjectTypes.SetFocus();
			return FALSE;
		}

		if (m_Platforms.GetCount() > 0)
		{
			BOOL fPlatformChecked = FALSE;
			for (int i = 0; i < m_Platforms.GetCount(); i++)
			{
				if (m_Platforms.GetCheck(i))
					fPlatformChecked = TRUE;
			}

			if (!fPlatformChecked)
			{
				MsgBox(Error, IDS_ERR_NO_PLATFORMS);
				m_Platforms.SetFocus();
				return(FALSE);
			}
		}

		((CEdit *)GetDlgItem(IDC_NAMEFORPROJECT))->GetWindowText(m_strFileName);
		((CEdit *)GetDlgItem(IDC_LOCATIONFORPROJECT))->GetWindowText(m_strPathName);

		// trim leading and trailing spaces from filename...
		m_strFileName.TrimLeft();
		m_strFileName.TrimRight();

		if (!IsProjectNameValid(m_strFileName))
		{
			MsgBox(Error, IDS_INVALID_PROJECTNAME);
			GotoDlgCtrl(GetDlgItem(IDC_NAMEFORPROJECT));
			return FALSE;
		}

		if (IsDlgButtonChecked(IDC_ADDTOCURRENTWORKSPACE))
		{
			if(g_IdeInterface.GetProjectWorkspace()->CanAddProject(m_strFileName)==S_FALSE)
			{
				MsgBox(Error, IDS_EXISTING_PROJECT2);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORPROJECT));
				return FALSE;
			}
		}

		int nIndex;
		if ((nIndex = m_strPathName.ReverseFind('\\')) == (m_strPathName.GetLength() - 1))
			m_strPathName = m_strPathName.Left(nIndex);
		
		CString strTestFile;
		CreateFileError cfe;

		if (IsDlgButtonChecked(IDC_CREATENEWWORKSPACE))
		{
			strTestFile = m_strFileName;
			strTestFile += WORKSPACE_EXT;
			cfe = CanCreateFile(strTestFile, m_strPathName, FALSE);
			if (cfe == cfeFileExists)
			{
				MsgBox(Error, IDS_EXISTING_WORKSPACE);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORPROJECT));
				return FALSE;
			}
			else if (cfe == cfeInvalidFile || cfe == cfeCannotCreateFile)
			{
				if (strTestFile.GetLength() + m_strPathName.GetLength() >= _MAX_PATH - 1)
				{
					CString strMsg;
					MsgBox(Error, MsgText(strMsg, IDS_TOOLONG_FILENAME, strTestFile, m_strPathName));
				}
				else
					MsgBox(Error, IDS_INVALID_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFORPROJECT));
				return FALSE;
			}
			else if (cfe == cfeInvalidPath || cfe == cfeCannotCreatePath)
			{
				MsgBox(Error, IDS_INVALID_PATHNAME);
				GotoDlgCtrl(GetDlgItem(IDC_LOCATIONFORPROJECT));
				return FALSE;
			}
		}

		strTestFile = m_strFileName;
		strTestFile += BUILDER_EXT;
		cfe = CanCreateFile(strTestFile, m_strPathName, FALSE);
		if (cfe == cfeFileExists)
		{
			MsgBox(Error, IDS_EXISTING_PROJECT);
			GotoDlgCtrl(GetDlgItem(IDC_NAMEFORPROJECT));
			return FALSE;
		}
		else if (cfe == cfeInvalidFile || cfe == cfeCannotCreateFile)
		{
			if (strTestFile.GetLength() + m_strPathName.GetLength() >= _MAX_PATH - 1)
			{
				CString strMsg;
				MsgBox(Error, MsgText(strMsg, IDS_TOOLONG_FILENAME, strTestFile, m_strPathName));
			}
			else
				MsgBox(Error, IDS_INVALID_FILENAME);
			GotoDlgCtrl(GetDlgItem(IDC_NAMEFORPROJECT));
			return FALSE;
		}
		else if (cfe == cfeInvalidPath || cfe == cfeCannotCreatePath)
		{
			MsgBox(Error, IDS_INVALID_PATHNAME);
			GotoDlgCtrl(GetDlgItem(IDC_LOCATIONFORPROJECT));
			return FALSE;
		}
	}

	return(TRUE);
}

void CNewProjectDialogTab::CommitTab()
{
	CDlgTab::CommitTab();

	m_nSelected = m_ProjectTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	CProjTypeItem *pItem = (CProjTypeItem *)m_ProjectTypes.GetItemData(m_nSelected);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	pParent->SetType(CPartTemplate::newproject);
	pParent->SetProjectProvider(pItem->m_pProjectProvider);
	pParent->SetProjectType(pItem->m_dwProject_ID);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	pParent->SetFileName(m_strFileName);
	pParent->SetPathName(m_strPathName);
	pParent->SetCreateNew(IsDlgButtonChecked(IDC_CREATENEWWORKSPACE));

	if (!m_fCreateNew && m_fDependency)
	{
		CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_DEPENDENCYPROJECT);
		int nItem = pComboBox->GetCurSel();
		IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemDataPtr(nItem);
		pParent->SetProject(pProject);
	}
	else
		pParent->SetProject(NULL);

	// user may have changed default platform selection, so notify provider
	for (int i = 0; i < m_Platforms.GetCount(); i++)
		pItem->m_pProjectProvider->ChangePlatformSelection(i, m_Platforms.GetCheck(i));

	int nIndex = m_ProjectTypes.GetNextItem(-1, LVNI_ALL);
	while (nIndex != -1)
	{
		CProjTypeItem *pItem = (CProjTypeItem *)m_ProjectTypes.GetItemData(nIndex);
		delete pItem;
		nIndex = m_ProjectTypes.GetNextItem(nIndex, LVNI_ALL);
	}

	// update the default workspace/project directory
	if (m_fCreateNew)
	{
		CDir dir;
		dir.CreateFromStringEx(m_strPathName, TRUE);
		if (!dir.IsRootDir())
			dir.RemoveLastSubdirName();
		WriteRegWorkspaceDir((const TCHAR *)dir);
	}

	if (m_fForceAddToWks)
		m_fCreateNew = m_fCreateNewPrev;
}

void CNewProjectDialogTab::CancelTab()
{
	CDlgTab::CancelTab();

	int nIndex = m_ProjectTypes.GetNextItem(-1, LVNI_ALL);
	while (nIndex != -1)
	{
		CProjTypeItem *pItem = (CProjTypeItem *)m_ProjectTypes.GetItemData(nIndex);
		delete pItem;
		nIndex = m_ProjectTypes.GetNextItem(nIndex, LVNI_ALL);
	}
	IProjectWorkspace *pInterface;
	pInterface = g_IdeInterface.GetProjectWorkspace();
	ASSERT(pInterface != NULL);
	pInterface->ReleaseProjectTypeInfo();

	if (m_fForceAddToWks)
		m_fCreateNew = m_fCreateNewPrev;
}

void CNewProjectDialogTab::OnBrowse()
{
	CDir dir;
	if (!dir.CreateFromStringEx(m_strPathName, TRUE))
	{
		CString strWorkspaceDir;
		GetRegWorkspaceDir(strWorkspaceDir);
		VERIFY(dir.CreateFromStringEx(strWorkspaceDir, TRUE));
	}

	CDirChooser dlg((const TCHAR *)dir);
	if (dlg.DoModal() == IDOK)
	{
		if (m_strPathName.Compare(dlg.GetPathName()) != 0)
		{
			m_strPathName = dlg.GetPathName();
			((CEdit *)GetDlgItem(IDC_NAMEFORPROJECT))->GetWindowText(m_strFileName);
			EnsureSlashAtEnd(m_strPathName);
			m_strPathName += m_strFileName;
			GetDlgItem(IDC_LOCATIONFORPROJECT)->SetWindowText(m_strPathName);
			m_fUserChangedLocation = TRUE;
		}
	}
	EnableButtons();
}

#ifdef ENABLE_LISTVIEW_MODES
void CNewProjectDialogTab::OnClickLargeIconView()
{
	SetListCtrlStyle(&m_ProjectTypes, LVS_ICON);
	c_ViewMode = largeicon;
}

void CNewProjectDialogTab::OnClickSmallIconView()
{
	SetListCtrlStyle(&m_ProjectTypes, LVS_SMALLICON);
	c_ViewMode = smallicon;
}

void CNewProjectDialogTab::OnClickListView()
{
	SetListCtrlStyle(&m_ProjectTypes, LVS_LIST);
	c_ViewMode = list;
}
#endif	// ENABLE_LISTVIEW_MODES

void CNewProjectDialogTab::OnClickCreateNew()
{
	GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(FALSE);
	GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(FALSE);

	SetAppropriateLocation();
}

void CNewProjectDialogTab::OnClickAddToCurrent()
{
	m_nSelected = m_ProjectTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);

	if (m_nSelected == -1)
	{
		GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(FALSE);
		GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(FALSE);
	}
	else
	{
		CProjTypeItem *pItem = (CProjTypeItem *)m_ProjectTypes.GetItemData(m_nSelected);

		if (pItem->m_bSupportDependency && ((CComboBox *)GetDlgItem(IDC_DEPENDENCYPROJECT))->GetCount() >= 1)
		{
			GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(TRUE);
			GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(IsDlgButtonChecked(IDC_DEPENDENCYOF));
		}
		else
		{
			GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(FALSE);
			GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(FALSE);
		}
	}

	SetAppropriateLocation();
}

void CNewProjectDialogTab::OnClickDependencyOf()
{
	GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(IsDlgButtonChecked(IDC_DEPENDENCYOF));
}

void CNewProjectDialogTab::OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult)
{
	m_fDoubleClicked = TRUE;
	if (ValidateTab())
	{
		CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
		ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
		pParent->OnOK();
	}
	m_fDoubleClicked = FALSE;
}

void CNewProjectDialogTab::OnSelectType(NMHDR* pNMHDR, LRESULT* pResult)
{
	int nIndex = m_ProjectTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	m_Platforms.ResetContent();
	if (nIndex != -1)
	{
		CProjTypeItem *pItem = (CProjTypeItem *)m_ProjectTypes.GetItemData(nIndex);

		if (pItem->m_bSupportDependency && IsDlgButtonChecked(IDC_ADDTOCURRENTWORKSPACE) && 
			((CComboBox *)GetDlgItem(IDC_DEPENDENCYPROJECT))->GetCount() >= 1)
		{
			GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(TRUE);
			GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(IsDlgButtonChecked(IDC_DEPENDENCYOF));
		}
		else
		{
			GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(FALSE);
			GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(FALSE);
		}

		if (nIndex != m_nIndexSave)
		{
			LPCOLESTR *ppszPlatforms;
			BOOL *pbDefSelections;
			ULONG ulCount;
			pItem->m_pProjectProvider->GetPlatforms(pItem->m_dwProject_ID, &ppszPlatforms, &pbDefSelections, &ulCount);

		//	GetDlgItem(IDC_PLATSTATIC)->EnableWindow(ulCount != 0L);
		//	m_Platforms.EnableWindow(ulCount != 0L);
			GetDlgItem(IDC_PLATSTATIC)->ShowWindow(ulCount != 0L ? SW_SHOW : SW_HIDE);
			GetDlgItem(IDC_PLATFORMS)->ShowWindow(ulCount != 0L ? SW_SHOW : SW_HIDE);

			CString strEntry;
			for (int i = 0; i < (int)ulCount; i++)
			{
				strEntry = ppszPlatforms[i];
				CoTaskMemFree((void *)ppszPlatforms[i]);
				VERIFY(m_Platforms.InsertString(-1, strEntry) == i);
				m_Platforms.SetCheck(i, pbDefSelections[i]);
			}
			CoTaskMemFree((void *)ppszPlatforms);

			m_nIndexSave = nIndex;

			// user may have changed default platform selection, so notify provider
			for (i = 0; i < m_Platforms.GetCount(); i++)
				pItem->m_pProjectProvider->ChangePlatformSelection(i, m_Platforms.GetCheck(i));
		}
	}
	else
	{
		GetDlgItem(IDC_PLATSTATIC)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_PLATFORMS)->ShowWindow(SW_HIDE);

		GetDlgItem(IDC_DEPENDENCYOF)->EnableWindow(FALSE);
		GetDlgItem(IDC_DEPENDENCYPROJECT)->EnableWindow(FALSE);
	}
	m_nIndexSave = nIndex;
	SetAppropriateLocation();
	EnableButtons();
}

void CNewProjectDialogTab::OnChangeName()
{
	// When the name of the project changes, we update the location field to indicate the
	// directory that will become the root of the project (that contains the .BLD file).
	//
	// To do this, we just grab what used to be displayed, strip off the old project 
	// name (if it's there) and append the new project name.

	GetDlgItemText(IDC_NAMEFORPROJECT, m_strFileName);
	GetDlgItemText(IDC_LOCATIONFORPROJECT, m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	// Remove the old project name
	if (m_strPathName.GetLength() >= m_strPrevName.GetLength() && 
		m_strPathName.Right(m_strPrevName.GetLength()).CompareNoCase(m_strPrevName) == 0)
	{
		m_strPathName = m_strPathName.Left(m_strPathName.GetLength() - m_strPrevName.GetLength());
	}

	// Add the new project name
	EnsureSlashAtEnd(m_strPathName);
	m_strPathName += m_strFileName;

	// Update the location control...
	SetDlgItemText(IDC_LOCATIONFORPROJECT, m_strPathName);

	// Keep the string to remove next time...
	m_strPrevName = m_strFileName;
	EnableButtons();
}

void CNewProjectDialogTab::OnChangeLocation()
{
	if (GetFocus() == GetDlgItem(IDC_LOCATIONFORPROJECT))
		m_fUserChangedLocation = TRUE;
	EnableButtons();
}

void CNewProjectDialogTab::EnableButtons()
{
	if (!m_fIsInitialized)
		return;

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->m_btnOk.GetSafeHwnd() == NULL)
		return;

	((CEdit *)GetDlgItem(IDC_NAMEFORPROJECT))->GetWindowText(m_strFileName);
	((CEdit *)GetDlgItem(IDC_LOCATIONFORPROJECT))->GetWindowText(m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	BOOL fHasItems = (m_ProjectTypes.GetItemCount() > 0);
	BOOL fSelected = (m_ProjectTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) != -1);
	BOOL fFileName = (!m_strFileName.IsEmpty());
	BOOL fFilePath = (!m_strPathName.IsEmpty());

	if (fHasItems && fSelected && fFileName && fFilePath)
	{
		pParent->SetDefButtonIndex(IDOK - 1);
		pParent->m_btnOk.EnableWindow(TRUE);
	}
	else
	{
		pParent->SetDefButtonIndex(IDCANCEL - 1);
		pParent->m_btnOk.EnableWindow(FALSE);
	}
}

void CNewProjectDialogTab::SetAppropriateLocation()
{
	if (m_fUserChangedLocation)
		return;

	BOOL fUseWorkspaceSubdir = FALSE;

	int nIndex = m_ProjectTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	if (nIndex != -1)
	{
		CProjTypeItem *pItem = (CProjTypeItem *)m_ProjectTypes.GetItemData(nIndex);
		if (pItem->m_bUseSubDirectories && IsDlgButtonChecked(IDC_ADDTOCURRENTWORKSPACE))
			fUseWorkspaceSubdir = TRUE;
	}

	GetDlgItemText(IDC_NAMEFORPROJECT, m_strFileName);

	if (fUseWorkspaceSubdir)
	{
		// Get the current workspace directory.
		IProjectWorkspace *pInterface;
		pInterface = g_IdeInterface.GetProjectWorkspace();
		ASSERT(pInterface != NULL);
		LPCTSTR pszWorkspacePath;
		pInterface->GetWorkspaceDocPathName(&pszWorkspacePath);
		CString strWorkspacePath = pszWorkspacePath;
		CDir dir;
		dir.CreateFromPath(strWorkspacePath);
		m_strPathName = (const TCHAR *)dir;
	}
	else
	{
		// Get the user's workspace root directory.
		CString strWorkspaceDir;
		GetRegWorkspaceDir(strWorkspaceDir);
		CDir dir;
		dir.CreateFromStringEx(strWorkspaceDir, TRUE);
		m_strPathName = (const TCHAR *)dir;
	}

	// Add the new project name
	EnsureSlashAtEnd(m_strPathName);
	m_strPathName += m_strFileName;

	// Update the location control...
	SetDlgItemText(IDC_LOCATIONFORPROJECT, m_strPathName);
}

BEGIN_MESSAGE_MAP(CNewProjectDialogTab, CDlgTab)
	//{{AFX_MSG_MAP (CNewProjectDialogTab)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
#ifdef ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_LARGEICONVIEW, OnClickLargeIconView)
	ON_BN_CLICKED(IDC_SMALLICONVIEW, OnClickSmallIconView)
	ON_BN_CLICKED(IDC_LISTVIEW, OnClickListView)
#endif	// ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_CREATENEWWORKSPACE, OnClickCreateNew)
	ON_BN_CLICKED(IDC_ADDTOCURRENTWORKSPACE, OnClickAddToCurrent)
	ON_BN_CLICKED(IDC_DEPENDENCYOF, OnClickDependencyOf)
	ON_NOTIFY(NM_DBLCLK, IDC_PROJECTTYPES, OnDblClkType)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROJECTTYPES, OnSelectType)
	ON_EN_CHANGE(IDC_NAMEFORPROJECT, OnChangeName)
	ON_EN_CHANGE(IDC_LOCATIONFORPROJECT, OnChangeLocation)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewWorkspaceDialogTab

int CNewWorkspaceDialogTab::m_nSelected;
CString CNewWorkspaceDialogTab::m_strFileName;
CString CNewWorkspaceDialogTab::m_strPathName;
CString CNewWorkspaceDialogTab::m_strPrevName;
int CNewWorkspaceDialogTab::m_nFocusCtrlId = -1;
#ifdef ENABLE_LISTVIEW_MODES
VIEW_MODE CNewWorkspaceDialogTab::c_ViewMode = smallicon;
#endif	// ENABLE_LISTVIEW_MODES

IMPLEMENT_DYNAMIC(CNewWorkspaceDialogTab, CDlgTab);

CNewWorkspaceDialogTab::CNewWorkspaceDialogTab(BOOL bUseSavedData /*=FALSE*/)
	: CDlgTab(IDDP_FILENEW_WORKSPACES, IDS_WORKSPACESTAB)
{
	if (!bUseSavedData)
	{
		m_nFocusCtrlId = -1;
		m_nSelected = 0;
		m_strFileName.Empty();
		m_strPrevName.Empty();

		// Get the user's workspace root directory.
		CString strWorkspaceDir;
		GetRegWorkspaceDir(strWorkspaceDir);
		CDir dir;
		dir.CreateFromStringEx(strWorkspaceDir, TRUE);
		m_strPathName = (const TCHAR *)dir;
	}
	m_fIsInitialized = FALSE;
	m_fDoubleClicked = FALSE;
}

void CNewWorkspaceDialogTab::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CNewWorkspaceDialogTab)
	DDX_Control(pDX, IDC_WORKSPACETYPES, m_WorkspaceTypes);
	DDX_Text(pDX, IDC_NAMEFORWORKSPACE, m_strFileName);
	DDX_Text(pDX, IDC_LOCATIONFORWORKSPACE, m_strPathName);
	//}}AFX_DATA_MAP
}

BOOL CNewWorkspaceDialogTab::OnInitDialog()
{
	UpdateData(FALSE);

//	m_imageListNormal.Create(32, 32, ILC_COLOR, 1, 1);
//	m_imageListNormal.SetBkColor(GetSysColor(COLOR_WINDOW));
	m_imageListSmall.Create(16, 16, ILC_COLOR, 1, 1);
	m_imageListSmall.SetBkColor(GetSysColor(COLOR_WINDOW));

	POSITION pos = theApp.GetFirstDocTemplatePosition();

	// Set the generic members of the LV_ITEM stuct:
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvItem.iSubItem = 0;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = 0;

	// while loop variables
	CPartTemplate *pTemplate;
	HICON hIcon;
	CString strTemplate;
	int nIndex = 0;
	int nColumnWidth = 0;
	while (pos != NULL)
	{
		pTemplate = (CPartTemplate *)theApp.GetNextDocTemplate(pos);
		ASSERT(pTemplate != NULL);
		if (CPartTemplate::newworkspace == pTemplate->GetTabType() && (hIcon = pTemplate->GetIcon()) &&
			pTemplate->GetDocString(strTemplate, CDocTemplate::fileNewName) && !strTemplate.IsEmpty())
		{
			hIcon = pTemplate->GetIcon();
		//	m_imageListNormal.Add(hIcon);
			m_imageListSmall.Add(hIcon);

			pTemplate->GetDocString(strTemplate, CDocTemplate::fileNewName);
			CString strDisplay;
			strDisplay.FormatMessage(IDS_BLANKWKS, strTemplate);
			lvItem.iItem = nIndex;
			lvItem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
			lvItem.iImage = nIndex;
			lvItem.lParam = (LPARAM)pTemplate;

			VERIFY(m_WorkspaceTypes.InsertItem(&lvItem) != -1);

			nColumnWidth = max(nColumnWidth, m_WorkspaceTypes.GetStringWidth(strDisplay));
			nIndex++;
		}
	}

	m_WorkspaceTypes.SetColumnWidth(-1, nColumnWidth + COLUMNEXTRA);
	m_WorkspaceTypes.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

//	m_WorkspaceTypes.SetImageList(&m_imageListNormal, LVSIL_NORMAL);
	m_WorkspaceTypes.SetImageList(&m_imageListSmall, LVSIL_SMALL);

#ifndef ENABLE_LISTVIEW_MODES
	SetListCtrlStyle(&m_WorkspaceTypes, LVS_SMALLICON);
	SetListCtrlStyle(&m_WorkspaceTypes, LVS_LIST);
#else	// ENABLE_LISTVIEW_MODES
	switch (c_ViewMode)
	{
		case largeicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LARGEICONVIEW);
			SetListCtrlStyle(&m_WorkspaceTypes, LVS_SMALLICON);
			SetListCtrlStyle(&m_WorkspaceTypes, LVS_ICON);
			break;

		case smallicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_SMALLICONVIEW);
			SetListCtrlStyle(&m_WorkspaceTypes, LVS_ICON);
			SetListCtrlStyle(&m_WorkspaceTypes, LVS_SMALLICON);
			break;

		case list:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LISTVIEW);
			SetListCtrlStyle(&m_WorkspaceTypes, LVS_ICON);
			SetListCtrlStyle(&m_WorkspaceTypes, LVS_LIST);
			break;
	}
#endif	// ENABLE_LISTVIEW_MODES

	// limit length of workspace name
	((CEdit *)GetDlgItem(IDC_NAMEFORWORKSPACE))->LimitText(_MAX_FNAME);

	m_fIsInitialized = TRUE;

	if (m_nFocusCtrlId == -1)
		return(TRUE);

	CWnd *pWnd = GetDlgItem(m_nFocusCtrlId);
	if (pWnd == NULL)
		return(TRUE);

	GotoDlgCtrl(pWnd);
	return(FALSE);
}

BOOL CNewWorkspaceDialogTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	BOOL fRet = CDlgTab::Activate(pParentWnd, position);
	EnableButtons();
	return fRet;
}

void CNewWorkspaceDialogTab::Deactivate(CTabbedDialog* pParentWnd)
{
	CDlgTab::Deactivate(pParentWnd);
}

BOOL CNewWorkspaceDialogTab::ValidateTab()
{
	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->IsCommitting() || m_fDoubleClicked)
	{
		if (m_WorkspaceTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) == -1)
		{
			MsgBox(Error, IDS_ERR_WORKSPACE_TYPE);
			m_WorkspaceTypes.SetFocus();
			return FALSE;
		}

		((CEdit *)GetDlgItem(IDC_NAMEFORWORKSPACE))->GetWindowText(m_strFileName);
		((CEdit *)GetDlgItem(IDC_LOCATIONFORWORKSPACE))->GetWindowText(m_strPathName);

		// trim leading and trailing spaces from filename...
		m_strFileName.TrimLeft();
		m_strFileName.TrimRight();

		if (!IsProjectNameValid(m_strFileName))
		{
			MsgBox(Error, IDS_INVALID_PROJECTNAME);
			GotoDlgCtrl(GetDlgItem(IDC_NAMEFORWORKSPACE));
			return FALSE;
		}

		int nIndex;
		if ((nIndex = m_strPathName.ReverseFind('\\')) == (m_strPathName.GetLength() - 1))
			m_strPathName = m_strPathName.Left(nIndex);
		
		CString strTestFile;
		strTestFile = m_strFileName;
		strTestFile += WORKSPACE_EXT;
		CreateFileError cfe = CanCreateFile(strTestFile, m_strPathName, FALSE);
		if (cfe == cfeFileExists)
		{
			MsgBox(Error, IDS_EXISTING_WORKSPACE);
			GotoDlgCtrl(GetDlgItem(IDC_NAMEFORWORKSPACE));
			return FALSE;
		}
		else if (cfe == cfeInvalidFile || cfe == cfeCannotCreateFile)
		{
			if (strTestFile.GetLength() + m_strPathName.GetLength() >= _MAX_PATH - 1)
			{
				CString strMsg;
				MsgBox(Error, MsgText(strMsg, IDS_TOOLONG_FILENAME, strTestFile, m_strPathName));
			}
			else
				MsgBox(Error, IDS_INVALID_FILENAME);
			GotoDlgCtrl(GetDlgItem(IDC_NAMEFORWORKSPACE));
			return FALSE;
		}
		else if (cfe == cfeInvalidPath || cfe == cfeCannotCreatePath)
		{
			MsgBox(Error, IDS_INVALID_PATHNAME);
			GotoDlgCtrl(GetDlgItem(IDC_LOCATIONFORWORKSPACE));
			return FALSE;
		}

		m_nSelected = m_WorkspaceTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
		CPartTemplate *pTemplate = (CPartTemplate *)m_WorkspaceTypes.GetItemData(m_nSelected);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));
		CString strCreate;
		strCreate = m_strPathName;
		EnsureSlashAtEnd(strCreate);
		strCreate += m_strFileName;
		if (!pTemplate->CanCreateDocument(strCreate))
		{
			// pTemplate is responsible for issuing appropriate error message!
			return FALSE;
		}
	}

	return(TRUE);
}

void CNewWorkspaceDialogTab::CommitTab()
{
	CDlgTab::CommitTab();

	m_nSelected = m_WorkspaceTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	CDocTemplate *pTemplate = (CDocTemplate *)m_WorkspaceTypes.GetItemData(m_nSelected);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	pParent->SetType(CPartTemplate::newworkspace);
	pParent->SetTemplate(pTemplate);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	pParent->SetFileName(m_strFileName);
	pParent->SetPathName(m_strPathName);

	// update the default workspace/project directory
	CDir dir;
	dir.CreateFromStringEx(m_strPathName, TRUE);
	if (!dir.IsRootDir())
		dir.RemoveLastSubdirName();
	WriteRegWorkspaceDir((const TCHAR *)dir);
}

void CNewWorkspaceDialogTab::CancelTab()
{
	CDlgTab::CancelTab();
}

void CNewWorkspaceDialogTab::OnBrowse()
{
	CDir dir;
	if (!dir.CreateFromStringEx(m_strPathName, TRUE))
	{
		CString strWorkspaceDir;
		GetRegWorkspaceDir(strWorkspaceDir);
		VERIFY(dir.CreateFromStringEx(strWorkspaceDir, TRUE));
	}

	CDirChooser dlg((const TCHAR *)dir);
	if (dlg.DoModal() == IDOK)
	{
		if (m_strPathName.Compare(dlg.GetPathName()) != 0)
		{
			m_strPathName = dlg.GetPathName();
			((CEdit *)GetDlgItem(IDC_NAMEFORWORKSPACE))->GetWindowText(m_strFileName);
			EnsureSlashAtEnd(m_strPathName);
			m_strPathName += m_strFileName;
			GetDlgItem(IDC_LOCATIONFORWORKSPACE)->SetWindowText(m_strPathName);
		}
	}
	EnableButtons();
}

#ifdef ENABLE_LISTVIEW_MODES
void CNewWorkspaceDialogTab::OnClickLargeIconView()
{
	SetListCtrlStyle(&m_WorkspaceTypes, LVS_ICON);
	c_ViewMode = largeicon;
}

void CNewWorkspaceDialogTab::OnClickSmallIconView()
{
	SetListCtrlStyle(&m_WorkspaceTypes, LVS_SMALLICON);
	c_ViewMode = smallicon;
}

void CNewWorkspaceDialogTab::OnClickListView()
{
	SetListCtrlStyle(&m_WorkspaceTypes, LVS_LIST);
	c_ViewMode = list;
}
#endif	// ENABLE_LISTVIEW_MODES

void CNewWorkspaceDialogTab::OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult)
{
	m_fDoubleClicked = TRUE;
	if (ValidateTab())
	{
		CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
		ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
		pParent->OnOK();
	}
	m_fDoubleClicked = FALSE;
}

void CNewWorkspaceDialogTab::OnSelectType(NMHDR* pNMHDR, LRESULT* pResult)
{
	EnableButtons();
}

void CNewWorkspaceDialogTab::OnChangeName()
{
	// When the name of the project changes, we update the location field to indicate the
	// directory that will become the root of the project (that contains the .BLD file).
	//
	// To do this, we just grab what used to be displayed, strip off the old project 
	// name (if it's there) and append the new project name.

	GetDlgItemText(IDC_NAMEFORWORKSPACE, m_strFileName);
	GetDlgItemText(IDC_LOCATIONFORWORKSPACE, m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	// Remove the old project name
	if (m_strPathName.GetLength() >= m_strPrevName.GetLength() && 
		m_strPathName.Right(m_strPrevName.GetLength()).CompareNoCase(m_strPrevName) == 0)
	{
		m_strPathName = m_strPathName.Left(m_strPathName.GetLength() - m_strPrevName.GetLength());
	}

	// Add the new project name
	EnsureSlashAtEnd(m_strPathName);
	m_strPathName += m_strFileName;

	// Update the location control...
	SetDlgItemText(IDC_LOCATIONFORWORKSPACE, m_strPathName);

	// Keep the string to remove next time...
	m_strPrevName = m_strFileName;
	EnableButtons();
}

void CNewWorkspaceDialogTab::OnChangeLocation()
{
	EnableButtons();
}

void CNewWorkspaceDialogTab::EnableButtons()
{
	if (!m_fIsInitialized)
		return;

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->m_btnOk.GetSafeHwnd() == NULL)
		return;

	((CEdit *)GetDlgItem(IDC_NAMEFORWORKSPACE))->GetWindowText(m_strFileName);
	((CEdit *)GetDlgItem(IDC_LOCATIONFORWORKSPACE))->GetWindowText(m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	BOOL fHasItems = (m_WorkspaceTypes.GetItemCount() > 0);
	BOOL fSelected = (m_WorkspaceTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) != -1);
	BOOL fFileName = (!m_strFileName.IsEmpty());
	BOOL fFilePath = (!m_strPathName.IsEmpty());

	if (fHasItems && fSelected && fFileName && fFilePath)
	{
		pParent->SetDefButtonIndex(IDOK - 1);
		pParent->m_btnOk.EnableWindow(TRUE);
	}
	else
	{
		pParent->SetDefButtonIndex(IDCANCEL - 1);
		pParent->m_btnOk.EnableWindow(FALSE);
	}
}

BEGIN_MESSAGE_MAP(CNewWorkspaceDialogTab, CDlgTab)
	//{{AFX_MSG_MAP (CNewWorkspaceDialogTab)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
#ifdef ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_LARGEICONVIEW, OnClickLargeIconView)
	ON_BN_CLICKED(IDC_SMALLICONVIEW, OnClickSmallIconView)
	ON_BN_CLICKED(IDC_LISTVIEW, OnClickListView)
#endif	// ENABLE_LISTVIEW_MODES
	ON_NOTIFY(NM_DBLCLK, IDC_WORKSPACETYPES, OnDblClkType)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_WORKSPACETYPES, OnSelectType)
	ON_EN_CHANGE(IDC_NAMEFORWORKSPACE, OnChangeName)
	ON_EN_CHANGE(IDC_LOCATIONFORWORKSPACE, OnChangeLocation)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewOtherDocDialogTab

int CNewOtherDocDialogTab::m_nSelected;
BOOL CNewOtherDocDialogTab::m_fAddToProject = TRUE;
int CNewOtherDocDialogTab::m_nIndex;
CString CNewOtherDocDialogTab::m_strFileName;
CString CNewOtherDocDialogTab::m_strPathName;
int CNewOtherDocDialogTab::m_nFocusCtrlId = -1;
#ifdef ENABLE_LISTVIEW_MODES
VIEW_MODE CNewOtherDocDialogTab::c_ViewMode = smallicon;
#endif	// ENABLE_LISTVIEW_MODES

IMPLEMENT_DYNAMIC(CNewOtherDocDialogTab, CDlgTab);

CNewOtherDocDialogTab::CNewOtherDocDialogTab(BOOL bUseSavedData /*=FALSE*/, BOOL bForceAddToProject /*=FALSE*/)
	: CDlgTab(IDDP_FILENEW_OTHERDOCS, IDS_OTHERDOCSTAB)
{
	if (!bUseSavedData)
	{
		m_nFocusCtrlId = -1;
		m_nSelected = 0;
		m_strFileName.Empty();
	}

	if (m_strPathName.IsEmpty())
	{
		CDir dir;
		dir.CreateFromCurrent();
		m_strPathName = (const TCHAR *)dir;
	}

	if (bForceAddToProject)
	{
		m_fAddToProjectPrev = m_fAddToProject;
		m_fAddToProject = TRUE;
	}
	m_fForceAddToProj = bForceAddToProject;

	m_fIsInitialized = FALSE;
	m_fDoubleClicked = FALSE;
}

void CNewOtherDocDialogTab::DoDataExchange(CDataExchange* pDX)
{
	CDlgTab::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CNewOtherDocDialogTab)
	DDX_Control(pDX, IDC_OTHERDOCTYPES, m_OtherDocTypes);
	DDX_Check(pDX, IDC_ADDOTHERFILETOPROJECT, m_fAddToProject);
	DDX_CBIndex(pDX, IDC_PROJECTFOROTHERFILE, m_nIndex);
	DDX_Text(pDX, IDC_NAMEFOROTHERFILE, m_strFileName);
	DDX_Text(pDX, IDC_LOCATIONFOROTHERFILE, m_strPathName);
	//}}AFX_DATA_MAP
}

BOOL CNewOtherDocDialogTab::OnInitDialog()
{
	UpdateData(FALSE);

//	m_imageListNormal.Create(32, 32, ILC_COLOR, 1, 1);
//	m_imageListNormal.SetBkColor(GetSysColor(COLOR_WINDOW));
	m_imageListSmall.Create(16, 16, ILC_COLOR, 1, 1);
	m_imageListSmall.SetBkColor(GetSysColor(COLOR_WINDOW));

	POSITION pos = theApp.GetFirstDocTemplatePosition();

	// Set the generic members of the LV_ITEM stuct:
	LV_ITEM lvItem;
	lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvItem.iSubItem = 0;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = 0;

	// while loop variables
	CPartTemplate *pTemplate;
	HICON hIcon;
	CString strDisplay;
	int nIndex = 0;
	int nColumnWidth = 0;
	while (pos != NULL)
	{
		pTemplate = (CPartTemplate *)theApp.GetNextDocTemplate(pos);
		ASSERT(pTemplate != NULL);
		if (CPartTemplate::newother == pTemplate->GetTabType() && (hIcon = pTemplate->GetIcon()) &&
			pTemplate->GetDocString(strDisplay, CDocTemplate::fileNewName) && !strDisplay.IsEmpty())
		{
			hIcon = pTemplate->GetIcon();
		//	m_imageListNormal.Add(hIcon);
			m_imageListSmall.Add(hIcon);

			pTemplate->GetDocString(strDisplay, CDocTemplate::fileNewName);
			lvItem.iItem = nIndex;
			lvItem.pszText = (LPTSTR)(LPCTSTR)strDisplay;
			lvItem.iImage = nIndex;
			lvItem.lParam = (LPARAM)pTemplate;

			VERIFY(m_OtherDocTypes.InsertItem(&lvItem) != -1);

			nColumnWidth = max(nColumnWidth, m_OtherDocTypes.GetStringWidth(strDisplay));
			nIndex++;
		}
	}

	m_OtherDocTypes.SetColumnWidth(-1, nColumnWidth + COLUMNEXTRA);
	m_OtherDocTypes.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

//	m_OtherDocTypes.SetImageList(&m_imageListNormal, LVSIL_NORMAL);
	m_OtherDocTypes.SetImageList(&m_imageListSmall, LVSIL_SMALL);

#ifndef ENABLE_LISTVIEW_MODES
	SetListCtrlStyle(&m_OtherDocTypes, LVS_SMALLICON);
	SetListCtrlStyle(&m_OtherDocTypes, LVS_LIST);
#else	// ENABLE_LISTVIEW_MODES
	switch (c_ViewMode)
	{
		case largeicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LARGEICONVIEW);
			SetListCtrlStyle(&m_OtherDocTypes, LVS_SMALLICON);
			SetListCtrlStyle(&m_OtherDocTypes, LVS_ICON);
			break;

		case smallicon:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_SMALLICONVIEW);
			SetListCtrlStyle(&m_OtherDocTypes, LVS_ICON);
			SetListCtrlStyle(&m_OtherDocTypes, LVS_SMALLICON);
			break;

		case list:
			::CheckRadioButton(m_hWnd, IDC_LARGEICONVIEW, IDC_LISTVIEW, IDC_LISTVIEW);
			SetListCtrlStyle(&m_OtherDocTypes, LVS_ICON);
			SetListCtrlStyle(&m_OtherDocTypes, LVS_LIST);
			break;
	}
#endif	// ENABLE_LISTVIEW_MODES

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	CString strProjectDir;
	pos = pParent->m_strlistProjects.GetHeadPosition();
	if (pos != NULL)
	{
		POSITION pos2 = pParent->m_ptrlistBuilders.GetHeadPosition();
		while (pos != NULL)
		{
			CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFOROTHERFILE);
			ASSERT(pos2 != NULL);
			CString strProject = pParent->m_strlistProjects.GetNext(pos);
			IPkgProject *pProject = (IPkgProject *)pParent->m_ptrlistBuilders.GetNext(pos2);
			int nIndex = pComboBox->InsertString(-1, strProject);
			pComboBox->SetItemData(nIndex, (DWORD)pProject);
			if (pProject == pParent->m_pActiveProject)
			{
				pComboBox->SetCurSel(nIndex);

				m_nIndex = nIndex;
				LPCOLESTR pszProjName, pszProjPath;
				DWORD dwPackageID, dwFlags;
				pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
				CString strProjPath = pszProjPath;
				CPath path;
				path.Create(strProjPath);
				CDir dir;
				dir.CreateFromPath(path);
				strProjectDir = (const TCHAR *)dir;
				CoTaskMemFree((void *)pszProjName);
				CoTaskMemFree((void *)pszProjPath);
			}
		}
		ASSERT(pos2 == NULL);
	}
	else
	{
		m_fAddToProject = FALSE;
		((CButton *)GetDlgItem(IDC_ADDOTHERFILETOPROJECT))->SetCheck(m_fAddToProject);
		GetDlgItem(IDC_ADDOTHERFILETOPROJECT)->EnableWindow(m_fAddToProject);
	}

	GetDlgItem(IDC_PROJECTFOROTHERFILE)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_NAMEFOROTHERFILE)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_LOCATIONFOROTHERFILE)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_OTHERFILENAMESTATIC)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_OTHERFILELOCATIONSTATIC)->EnableWindow(m_fAddToProject);
//	GetDlgItem(IDC_BROWSE)->EnableWindow(m_fAddToProject);

	if (!strProjectDir.IsEmpty())
		SetDlgItemText(IDC_LOCATIONFOROTHERFILE, strProjectDir);

	// limit length of file name
	((CEdit *)GetDlgItem(IDC_NAMEFOROTHERFILE))->LimitText(_MAX_FNAME);

	m_fIsInitialized = TRUE;

	if (m_nFocusCtrlId == -1)
		return(TRUE);

	CWnd *pWnd = GetDlgItem(m_nFocusCtrlId);
	if (pWnd == NULL)
		return(TRUE);

	GotoDlgCtrl(pWnd);
	return(FALSE);
}

BOOL CNewOtherDocDialogTab::Activate(CTabbedDialog* pParentWnd, CPoint position)
{
	BOOL fRet = CDlgTab::Activate(pParentWnd, position);
	EnableButtons();
	return fRet;
}

void CNewOtherDocDialogTab::Deactivate(CTabbedDialog* pParentWnd)
{
	CDlgTab::Deactivate(pParentWnd);
}

BOOL CNewOtherDocDialogTab::ValidateTab()
{
	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	if (pParent->IsCommitting() || m_fDoubleClicked)
	{
		if (m_OtherDocTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) == -1)
		{
			MsgBox(Error, IDS_ERR_DOCUMENT_TYPE);
			m_OtherDocTypes.SetFocus();
			return FALSE;
		}

		m_nSelected = m_OtherDocTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
		CPartTemplate *pTemplate = (CPartTemplate *)m_OtherDocTypes.GetItemData(m_nSelected);
		ASSERT(pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)));

		((CEdit *)GetDlgItem(IDC_NAMEFOROTHERFILE))->GetWindowText(m_strFileName);

		// trim leading and trailing spaces from filename...
		m_strFileName.TrimLeft();
		m_strFileName.TrimRight();
		CString strCreate;

		if (!m_strFileName.IsEmpty())
		{
			// add default extension for name checking--it will be added on creation.
			if (m_strFileName.Find('.') == -1)
			{
				CString strExtension;
				pTemplate->GetDocString(strExtension, CDocTemplate::filterExt);
				m_strFileName += strExtension;
			}

			((CEdit *)GetDlgItem(IDC_LOCATIONFOROTHERFILE))->GetWindowText(m_strPathName);
			CreateFileError cfe = CanCreateFile(m_strFileName, m_strPathName, TRUE);
			if (cfe == cfeFileExists)
			{
				if (MsgBox(Question, IDS_EXISTING_FILEPATH, MB_YESNO) != IDYES)
					return FALSE;
			}
			else if (cfe == cfeInvalidFile || cfe == cfeCannotCreateFile)
			{
				if (m_strFileName.GetLength() + m_strPathName.GetLength() >= _MAX_PATH - 1)
				{
					CString strMsg;
					MsgBox(Error, MsgText(strMsg, IDS_TOOLONG_FILENAME, m_strFileName, m_strPathName));
				}
				else
					MsgBox(Error, IDS_INVALID_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFOROTHERFILE));
				return FALSE;
			}
			else if (cfe == cfeInvalidPath || cfe == cfeNonexistentPath || cfe == cfeCannotCreatePath)
			{
				MsgBox(Error, IDS_INVALID_PATHNAME);
				GotoDlgCtrl(GetDlgItem(IDC_LOCATIONFOROTHERFILE));
				return FALSE;
			}

			strCreate = m_strPathName;
			EnsureSlashAtEnd(strCreate);
			strCreate += m_strFileName;

			if (!pTemplate->CanCreateDocument(strCreate))
			{
				// pTemplate is responsible for issuing appropriate error message!
				return FALSE;
			}
		}
		if (IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT))
		{
			if (m_strFileName.IsEmpty())
			{
				MsgBox(Error, IDS_NEED_FILENAME);
				GotoDlgCtrl(GetDlgItem(IDC_NAMEFOROTHERFILE));
				return FALSE;
			}

			USES_CONVERSION;

			CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFOROTHERFILE);
			IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemData(m_nIndex);
			if (pProject->CanAddFile(T2W(strCreate), NULL, TRUE) != S_OK)
			{
				return FALSE;
			}
		}
	}

	return(TRUE);
}

void CNewOtherDocDialogTab::CommitTab()
{
	CDlgTab::CommitTab();

	m_nSelected = m_OtherDocTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED);
	CDocTemplate *pTemplate = (CDocTemplate *)m_OtherDocTypes.GetItemData(m_nSelected);

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
	pParent->SetType(CPartTemplate::newother);
	pParent->SetTemplate(pTemplate);
	pParent->SetAddToProject(m_fAddToProject);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	pParent->SetFileName(m_strFileName);
	pParent->SetPathName(m_strPathName);
	if (m_fAddToProject)
	{
		CString strProject;
		CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFOROTHERFILE);
		pComboBox->GetLBText(m_nIndex, strProject);
		DWORD dwData = pComboBox->GetItemData(m_nIndex);
		pParent->SetProject((IPkgProject *)dwData);
	}

	if (m_fForceAddToProj)
		m_fAddToProject = m_fAddToProjectPrev;
}

void CNewOtherDocDialogTab::CancelTab()
{
	CDlgTab::CancelTab();

	if (m_fForceAddToProj)
		m_fAddToProject = m_fAddToProjectPrev;
}

void CNewOtherDocDialogTab::OnBrowse()
{
	CDir dir;
	if (!dir.CreateFromStringEx(m_strPathName, TRUE))
		VERIFY(dir.CreateFromCurrent());

	CDirChooser dlg((const TCHAR *)dir);
	if (dlg.DoModal() == IDOK)
	{
		m_strPathName = dlg.GetPathName();
		GetDlgItem(IDC_LOCATIONFOROTHERFILE)->SetWindowText(m_strPathName);
	}
	EnableButtons();
}

#ifdef ENABLE_LISTVIEW_MODES
void CNewOtherDocDialogTab::OnClickLargeIconView()
{
	SetListCtrlStyle(&m_OtherDocTypes, LVS_ICON);
	c_ViewMode = largeicon;
}

void CNewOtherDocDialogTab::OnClickSmallIconView()
{
	SetListCtrlStyle(&m_OtherDocTypes, LVS_SMALLICON);
	c_ViewMode = smallicon;
}

void CNewOtherDocDialogTab::OnClickListView()
{
	SetListCtrlStyle(&m_OtherDocTypes, LVS_LIST);
	c_ViewMode = list;
}
#endif	// ENABLE_LISTVIEW_MODES

void CNewOtherDocDialogTab::OnClickAddToProject()
{
	GetDlgItem(IDC_PROJECTFOROTHERFILE)->EnableWindow(IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
//	GetDlgItem(IDC_NAMEFOROTHERFILE)->EnableWindow(IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
//	GetDlgItem(IDC_LOCATIONFOROTHERFILE)->EnableWindow(IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
//	GetDlgItem(IDC_OTHERFILENAMESTATIC)->EnableWindow(IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
//	GetDlgItem(IDC_OTHERFILELOCATIONSTATIC)->EnableWindow(IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
//	GetDlgItem(IDC_BROWSE)->EnableWindow(IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
	EnableButtons();
}

void CNewOtherDocDialogTab::OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult)
{
	m_fDoubleClicked = TRUE;
	if (ValidateTab())
	{
		CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
		ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));
		pParent->OnOK();
	}
	m_fDoubleClicked = FALSE;
}

void CNewOtherDocDialogTab::OnSelectType(NMHDR* pNMHDR, LRESULT* pResult)
{
	EnableButtons();
}

void CNewOtherDocDialogTab::OnChangeName()
{
	EnableButtons();
}

void CNewOtherDocDialogTab::OnChangeLocation()
{
	EnableButtons();
}

void CNewOtherDocDialogTab::OnProjectChange()
{
	CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTFOROTHERFILE);
	m_nIndex = pComboBox->GetCurSel();
	IPkgProject *pProject = (IPkgProject *)pComboBox->GetItemDataPtr(m_nIndex);
	LPCOLESTR pszProjName, pszProjPath;
	DWORD dwPackageID, dwFlags;
	pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
	CString strProjPath = pszProjPath;
	CPath path;
	path.Create(strProjPath);
	CDir dir;
	dir.CreateFromPath(path);
	CString strProjectDir = (const TCHAR *)dir;
	SetDlgItemText(IDC_LOCATIONFOROTHERFILE, strProjectDir);
	CoTaskMemFree((void *)pszProjName);
	CoTaskMemFree((void *)pszProjPath);
}

void CNewOtherDocDialogTab::EnableButtons()
{
	if (!m_fIsInitialized)
		return;

	CFileNewTabbedDialog *pParent = (CFileNewTabbedDialog *)GetParent();
	ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CFileNewTabbedDialog)));

	if (pParent->m_btnOk.GetSafeHwnd() == NULL)
		return;

	((CEdit *)GetDlgItem(IDC_NAMEFOROTHERFILE))->GetWindowText(m_strFileName);
	((CEdit *)GetDlgItem(IDC_LOCATIONFOROTHERFILE))->GetWindowText(m_strPathName);

	// trim leading and trailing spaces from filename...
	m_strFileName.TrimLeft();
	m_strFileName.TrimRight();

	BOOL fHasItems = (m_OtherDocTypes.GetItemCount() > 0);
	BOOL fSelected = (m_OtherDocTypes.GetNextItem(-1, LVNI_ALL | LVNI_SELECTED) != -1);
	BOOL fAddToPrj = (IsDlgButtonChecked(IDC_ADDOTHERFILETOPROJECT));
	BOOL fFileName = (!m_strFileName.IsEmpty());
	BOOL fFilePath = (!m_strPathName.IsEmpty());

	if (fHasItems && fSelected && (!fAddToPrj || (fAddToPrj && fFileName && fFilePath)))
	{
		pParent->SetDefButtonIndex(IDOK - 1);
		pParent->m_btnOk.EnableWindow(TRUE);
	}
	else
	{
		pParent->SetDefButtonIndex(IDCANCEL - 1);
		pParent->m_btnOk.EnableWindow(FALSE);
	}
}

BEGIN_MESSAGE_MAP(CNewOtherDocDialogTab, CDlgTab)
	//{{AFX_MSG_MAP (CNewOtherDocDialogTab)
	ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
#ifdef ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_LARGEICONVIEW, OnClickLargeIconView)
	ON_BN_CLICKED(IDC_SMALLICONVIEW, OnClickSmallIconView)
	ON_BN_CLICKED(IDC_LISTVIEW, OnClickListView)
#endif	// ENABLE_LISTVIEW_MODES
	ON_BN_CLICKED(IDC_ADDOTHERFILETOPROJECT, OnClickAddToProject)
	ON_NOTIFY(NM_DBLCLK, IDC_OTHERDOCTYPES, OnDblClkType)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_OTHERDOCTYPES, OnSelectType)
	ON_EN_CHANGE(IDC_NAMEFOROTHERFILE, OnChangeName)
	ON_EN_CHANGE(IDC_LOCATIONFOROTHERFILE, OnChangeLocation)
	ON_CBN_SELCHANGE(IDC_PROJECTFOROTHERFILE, OnProjectChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\filenew.h ===
// filenew.h : header file for CFileNewTabbedDialog,
//							   CNewFileDialogTab,
//							   CNewTemplateDialogTab,
//							   CNewProjectDialogTab,
//							   CNewWorkspaceDialogTab,
//							   CNewOtherDocDialogTab
//

#ifndef __FILENEW_H__
#define __FILENEW_H__

#include "resource.h"
#include "utilbld_.h"
#include "utilctrl.h"

#include <bldapi.h>
#include <prjapi.h>
#include <prjguid.h>

class CFileNewTabbedDialog;
class CNewFileDialogTab;
class CNewTemplateDialogTab;
class CNewProjectDialogTab;
class CNewWorkspaceDialogTab;
class CNewOtherDocDialogTab;

#ifdef ENABLE_LISTVIEW_MODES
enum VIEW_MODE { largeicon, smallicon, list };
#endif	// ENABLE_LISTVIEW_MODES

/////////////////////////////////////////////////////////////////////////////
// CFileNewTabbedDialog

class CFileNewTabbedDialog : public CTabbedDialog
{
public:

	CFileNewTabbedDialog(BOOL bUseSavedData = FALSE, BOOL bForceAddToProject = FALSE, BOOL bForceShowProjectTab = FALSE);
	~CFileNewTabbedDialog();

// Operations
public:
	virtual void OnOK();
	virtual void OnCancel();

protected:
	BOOL IsCommitting() const { return(m_fCommitting); }

	void SetType(CPartTemplate::FileNewTabType nType) { m_Type = nType; }
	void SetTemplate(CDocTemplate * pTemplate) { m_pTemplate = pTemplate; }
	void SetFileName(const CString &strFileName) { m_strFileName = strFileName; }
	void SetPathName(const CString &strPathName) { m_strPathName = strPathName; }
	void SetAddToProject(BOOL fAddToProject) { m_fAddToProject = fAddToProject; }
	void SetProject(IPkgProject * pProject) { m_pProject = pProject; }
	void SetProjectProvider(IPkgProjectProvider *pProjectProvider) { m_pProjectProvider = pProjectProvider; }
	void SetProjectType(DWORD dwProjectType) { m_dwProjectType = dwProjectType; }
	void SetCreateNew(BOOL fCreateNew) { m_fCreateNewWorkspace = fCreateNew; }

public:
	CPartTemplate::FileNewTabType GetType() const { return(m_Type); }
	CDocTemplate *GetTemplate() const { return(m_pTemplate); }
	CString GetFileName() const { return(m_strFileName); }
	CString GetPathName() const { return(m_strPathName); }
	IPkgProject *GetProject() const { return(m_pProject); }
	IPkgProjectProvider *GetProjectProvider() const { return(m_pProjectProvider); }
	DWORD GetProjectType() const { return (m_dwProjectType); }
	BOOL GetCreateNew() const { return(m_fCreateNewWorkspace); }

	DECLARE_DYNAMIC(CFileNewTabbedDialog);

public:
	CStringList m_strlistProjects;
	CPtrList m_ptrlistBuilders;
	IPkgProject *m_pActiveProject;

private:
	CPartTemplate::FileNewTabType m_Type;
	CDocTemplate *m_pTemplate;
	CString m_strFileName;
	CString m_strPathName;
	BOOL m_fAddToProject;
	IPkgProject *m_pProject;

	IPkgProjectProvider *m_pProjectProvider;
	DWORD m_dwProjectType;
	BOOL m_fCreateNewWorkspace;

	BOOL m_fCommitting;

	static int c_nSelectTab;

	friend class CNewFileDialogTab;
	friend class CNewTemplateDialogTab;
	friend class CNewProjectDialogTab;
	friend class CNewWorkspaceDialogTab;
	friend class CNewOtherDocDialogTab;
};

/////////////////////////////////////////////////////////////////////////////
// CNewFileDialogTab

class CNewFileDialogTab : public CDlgTab
{
// Construction
public:
	
// Dialog data
	//{{AFX_DATA(CNewFileDialogTab)
	enum { IDD = IDDP_FILENEW_FILES };
	CListCtrl m_FileTypes;
	static int m_nSelected;
	static BOOL m_fAddToProject;
	static int m_nIndex;
	static CString m_strFileName;
	static CString m_strPathName;
	static int m_nFocusCtrlId;
	//}}AFX_DATA

	CNewFileDialogTab(BOOL bUseSavedData = FALSE, BOOL bForceAddToProject = FALSE);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();

protected:
	//{{AFX_MSG(CNewFileDialogTab)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnBrowse();
#ifdef ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickLargeIconView();
	afx_msg void	OnClickSmallIconView();
	afx_msg void	OnClickListView();
#endif	// ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickAddToProject();
	afx_msg void	OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnSelectType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnChangeName();
	afx_msg void	OnChangeLocation();
	afx_msg void	OnProjectChange();
	//}}AFX_MSG	

	// our message map functions
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CNewFileDialogTab)

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

private:
	void EnableButtons();

	BOOL m_fIsInitialized;
	BOOL m_fDoubleClicked;
	BOOL m_fForceAddToProj;
	BOOL m_fAddToProjectPrev;
//	CImageList m_imageListNormal;
	CImageList m_imageListSmall;

#ifdef ENABLE_LISTVIEW_MODES
	static VIEW_MODE c_ViewMode;
#endif	// ENABLE_LISTVIEW_MODES
};

/////////////////////////////////////////////////////////////////////////////
// CNewTemplateDialogTab

class CNewTemplateDialogTab : public CDlgTab
{
// Construction
public:
	
// Dialog data
	//{{AFX_DATA(CNewTemplateDialogTab)
	enum { IDD = IDDP_FILENEW_TEMPLATES };
	CListCtrl m_TemplateTypes;
	static int m_nSelected;
	static BOOL m_fAddToProject;
	static int m_nIndex;
	static CString m_strFileName;
	static CString m_strPathName;
	static int m_nFocusCtrlId;
	//}}AFX_DATA

	CNewTemplateDialogTab(BOOL bUseSavedData = FALSE, BOOL bForceAddToProject = FALSE);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();

protected:
	//{{AFX_MSG(CNewTemplateDialogTab)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnBrowse();
#ifdef ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickLargeIconView();
	afx_msg void	OnClickSmallIconView();
	afx_msg void	OnClickListView();
#endif	// ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickAddToProject();
	afx_msg void	OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnSelectType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnChangeName();
	afx_msg void	OnChangeLocation();
	afx_msg void	OnProjectChange();
	//}}AFX_MSG	

	// our message map functions
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CNewTemplateDialogTab)

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

private:
	void EnableButtons();

	BOOL m_fIsInitialized;
	BOOL m_fDoubleClicked;
	BOOL m_fForceAddToProj;
	BOOL m_fAddToProjectPrev;
//	CImageList m_imageListNormal;
	CImageList m_imageListSmall;

#ifdef ENABLE_LISTVIEW_MODES
	static VIEW_MODE c_ViewMode;
#endif	// ENABLE_LISTVIEW_MODES
};

/////////////////////////////////////////////////////////////////////////////
// CNewProjectDialogTab

class CNewProjectDialogTab : public CDlgTab
{
// Construction
public:
	
// Dialog data
	//{{AFX_DATA(CNewProjectDialogTab)
	enum { IDD = IDDP_FILENEW_PROJECTS };
	CListCtrl m_ProjectTypes;
	static int m_nSelected;
	static BOOL m_fCreateNew;
	static BOOL m_fDependency;
	static int m_nIndexProject;
	static int m_nIndexPlatform;
	static CString m_strFileName;
	static CString m_strPathName;
	static int m_nFocusCtrlId;
	//}}AFX_DATA

	CNewProjectDialogTab(BOOL bUseSavedData = FALSE, BOOL bForceAddToWorkspace = FALSE);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();

	virtual void SetAppropriateLocation();

protected:
	//{{AFX_MSG(CNewProjectDialogTab)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnBrowse();
#ifdef ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickLargeIconView();
	afx_msg void	OnClickSmallIconView();
	afx_msg void	OnClickListView();
#endif	// ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickCreateNew();
	afx_msg void	OnClickAddToCurrent();
	afx_msg void	OnClickDependencyOf();
	afx_msg void	OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnSelectType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnChangeName();
	afx_msg void	OnChangeLocation();
	//}}AFX_MSG	

	// our message map functions
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CNewProjectDialogTab)

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

private:
	void EnableButtons();

	BOOL m_fIsInitialized;
	BOOL m_fDoubleClicked;
	BOOL m_fUserChangedLocation;
	BOOL m_fForceAddToWks;
	BOOL m_fCreateNewPrev;
//	CImageList m_imageListNormal;
	CImageList m_imageListSmall;

	static CString m_strPrevName;

	CCheckList m_Platforms;
	static	int m_nIndexSave;

#ifdef ENABLE_LISTVIEW_MODES
	static VIEW_MODE c_ViewMode;
#endif	// ENABLE_LISTVIEW_MODES
};

/////////////////////////////////////////////////////////////////////////////
// CNewWorkspaceDialogTab

class CNewWorkspaceDialogTab : public CDlgTab
{
// Construction
public:
	
// Dialog data
	//{{AFX_DATA(CNewWorkspaceDialogTab)
	enum { IDD = IDDP_FILENEW_WORKSPACES };
	CListCtrl m_WorkspaceTypes;
	static int m_nSelected;
	static CString m_strFileName;
	static CString m_strPathName;
	static int m_nFocusCtrlId;
	//}}AFX_DATA

	CNewWorkspaceDialogTab(BOOL bUseSavedData = FALSE);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();

protected:
	//{{AFX_MSG(CNewWorkspaceDialogTab)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnBrowse();
#ifdef ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickLargeIconView();
	afx_msg void	OnClickSmallIconView();
	afx_msg void	OnClickListView();
#endif	// ENABLE_LISTVIEW_MODES
	afx_msg void	OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnSelectType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnChangeName();
	afx_msg void	OnChangeLocation();
	//}}AFX_MSG	

	// our message map functions
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CNewWorkspaceDialogTab)

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

private:
	void EnableButtons();

	BOOL m_fIsInitialized;
	BOOL m_fDoubleClicked;
//	CImageList m_imageListNormal;
	CImageList m_imageListSmall;
	
	static CString m_strPrevName;

#ifdef ENABLE_LISTVIEW_MODES
	static VIEW_MODE c_ViewMode;
#endif	// ENABLE_LISTVIEW_MODES
};

/////////////////////////////////////////////////////////////////////////////
// CNewOtherDocDialogTab

class CNewOtherDocDialogTab : public CDlgTab
{
// Construction
public:
	
// Dialog data
	//{{AFX_DATA(CNewOtherDocDialogTab)
	enum { IDD = IDDP_FILENEW_OTHERDOCS };
	CListCtrl m_OtherDocTypes;
	static int m_nSelected;
	static BOOL m_fAddToProject;
	static int m_nIndex;
	static CString m_strFileName;
	static CString m_strPathName;
	static int m_nFocusCtrlId;
	//}}AFX_DATA

	CNewOtherDocDialogTab(BOOL bUseSavedData = FALSE, BOOL bForceAddToProject = FALSE);

	virtual BOOL Activate(CTabbedDialog* pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog* pParentWnd);

	virtual BOOL ValidateTab();
	virtual void CommitTab();
	virtual void CancelTab();

protected:
	//{{AFX_MSG(CNewOtherDocDialogTab)
	virtual BOOL	OnInitDialog();
	afx_msg void	OnBrowse();
#ifdef ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickLargeIconView();
	afx_msg void	OnClickSmallIconView();
	afx_msg void	OnClickListView();
#endif	// ENABLE_LISTVIEW_MODES
	afx_msg void	OnClickAddToProject();
	afx_msg void	OnDblClkType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnSelectType(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void	OnChangeName();
	afx_msg void	OnChangeLocation();
	afx_msg void	OnProjectChange();
	//}}AFX_MSG	

	// our message map functions
	DECLARE_MESSAGE_MAP()
	DECLARE_DYNCREATE(CNewOtherDocDialogTab)

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

private:
	void EnableButtons();

	BOOL m_fIsInitialized;
	BOOL m_fDoubleClicked;
	BOOL m_fForceAddToProj;
	BOOL m_fAddToProjectPrev;
//	CImageList m_imageListNormal;
	CImageList m_imageListSmall;

#ifdef ENABLE_LISTVIEW_MODES
	static VIEW_MODE c_ViewMode;
#endif	// ENABLE_LISTVIEW_MODES
};

/////////////////////////////////////////////////////////////////////////////

#endif	// __FILENEW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\fileadd.cpp ===
// fileadd.cpp : implementation file for CAddFilesDialog

#include "stdafx.h"		// the standard AFX include
#pragma hdrstop
#include "resource.h"
#include "dlgs.h"		// for commdlg control IDs
#include "toolexpt.h"

#include <cderr.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddFilesDialog

//  COMMDLG's special file validation message:
const UINT CAddFilesDialog::msgValidateFileMessage = ::RegisterWindowMessage(FILEOKSTRING);

CAddFilesDialog::CAddFilesDialog()
	: C3dFileDialog(TRUE, NULL, NULL, OFN_ENABLETEMPLATE | OFN_SHOWHELP | OFN_HIDEREADONLY | OFN_ALLOWMULTISELECT,
		NULL, AfxGetApp()->m_pMainWnd, NULL, IDD_CHICAGO_ADDFILES)
{
	m_pProject = NULL;
	m_strFolderName.Empty();
}

CAddFilesDialog::CAddFilesDialog(IPkgProject *pProject, const CString &strFolderName)
	: C3dFileDialog(TRUE, NULL, NULL, OFN_ENABLETEMPLATE | OFN_SHOWHELP | OFN_HIDEREADONLY | OFN_ALLOWMULTISELECT,
		NULL, AfxGetApp()->m_pMainWnd, NULL, IDD_CHICAGO_ADDFILES)
{
	m_pProject = pProject;
	m_strFolderName = strFolderName;
}

CAddFilesDialog::~CAddFilesDialog()
{
}

BEGIN_MESSAGE_MAP(CAddFilesDialog, C3dFileDialog)
	//{{AFX_MSG_MAP(CAddFilesDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDir CAddFilesDialog::c_dirInitial;

/////////////////////////////////////////////////////////////////////////////

void CAddFilesDialog::ResetCurrentDir()
{
	c_dirInitial.CreateFromCurrent();
}

int CAddFilesDialog::DoModal()
{
	CString strDialogTitle;
	VERIFY(strDialogTitle.LoadString(IDS_INSERTFILESDLG));
	m_ofn.lpstrTitle = strDialogTitle;
        CString *pszType;
	CString strFilter;
        IPkgProject *pPkgProject;
        BOOL fMustRelease = FALSE;
        
	theApp.BuildFilterList(strFilter, NULL, CPackage::GODI_ADDFILE, m_pProject);
        
        // Make sure we have a valid CPkgProject
        pPkgProject = m_pProject;
	if (pPkgProject == NULL)
	{
            IProjectWorkspace *pInterface;
            
            pInterface = g_IdeInterface.GetProjectWorkspace();
            if(pInterface)
            {
                pInterface->GetActiveProject(&pPkgProject);

            }
            ASSERT(pPkgProject);
            fMustRelease = TRUE;
	}
        
        // Set the default filter based on project type
        HRESULT hr = pPkgProject->GetProjectTypeName(&pszType);
        if (SUCCEEDED(hr) && *pszType != _T("Generic Project"))
        {
            m_ofn.nFilterIndex = 1;
        }
        else
        {
            int    nCount;
            LPTSTR szLastFilter;
            
            // Count the number of filters and choose the last one
            for (nCount = 0, szLastFilter = strFilter.GetBuffer(2);
                 *szLastFilter; nCount++)
            {
                while (*szLastFilter)
                {
                    szLastFilter++;
                }
                szLastFilter++;
            }
            m_ofn.nFilterIndex = nCount / 2;
        }
	m_ofn.lpstrFilter = strFilter;

        // Release the PkgProject if necessary
        if (fMustRelease)
        {
            pPkgProject->Release();
        }

	// no read-only checkbox
	m_ofn.Flags |= OFN_HIDEREADONLY;

	// set up our initial directory
	if (c_dirInitial.GetLength() == 0)
		c_dirInitial.CreateFromCurrent();
	m_ofn.lpstrInitialDir = (LPCSTR)(const TCHAR *)c_dirInitial;

	TCHAR szFileBuf[20480];
	lstrcpy(szFileBuf, _T("\0"));
	m_ofn.lpstrFile = szFileBuf;
	m_ofn.nMaxFile = 20480;

	m_fSuccess = FALSE;	// Hook will set this to true if OK was pressed.  
						// Return value of GetOpenFileName means nothing.

	// Do the base class thing
	C3dFileDialog::DoModal();

	// Check for errors
	if (m_fSuccess && (CommDlgExtendedError() != 0L))
	{
		m_fSuccess = FALSE;
		TRACE("In CAddFilesDialog::DoModal() CommDlgExtendedError returned (%lx)\n",CommDlgExtendedError());
		if (CommDlgExtendedError() == FNERR_BUFFERTOOSMALL)
		{
			AfxMessageBox(IDS_TOOMANY_FILES);
		}
	}

	c_dirInitial.CreateFromCurrent();
	return(m_fSuccess ? IDOK : IDCANCEL);
}

BOOL CAddFilesDialog::OnInitDialog()
{
	C3dFileDialog::OnInitDialog();

	// Use appropriate OK button
	SetOkButtonText(IDS_INSERTFILESDLG_OK);

	CComboBox *pComboBox = (CComboBox *)GetDlgItem(IDC_PROJECTTOADDTO);
	
	if (m_strFolderName.IsEmpty())
	{
		// resize the commdlg controls slightly for long filter strings, and also
		// position the Insert Into combo directly below the Filters combo, same size
		CRect rcFileName, rcInsertInto, rcFilters, rcInsertIntoTxt, rcFilterTxt;
		pComboBox->GetWindowRect(&rcInsertInto);

		CWnd *pFileName = GetParent()->GetDlgItem(edt1);
		ASSERT(pFileName != NULL);			// File name edit
		pFileName->GetWindowRect(&rcFileName);
		rcFileName.right += 5;
		pFileName->SetWindowPos(NULL, rcFileName.left, rcFileName.top, rcFileName.right - rcFileName.left,
			rcFileName.bottom - rcFileName.top, SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOZORDER | SWP_SHOWWINDOW);

		CWnd *pFilters = GetParent()->GetDlgItem(cmb1);
		ASSERT(pFilters != NULL);			// List files of type combo
		pFilters->GetWindowRect(&rcFilters);
		rcFilters.right += 5;
		pFilters->SetWindowPos(NULL, rcFilters.left, rcFilters.top, rcFilters.right - rcFilters.left,
			rcFilters.bottom - rcFilters.top, SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOZORDER | SWP_SHOWWINDOW);

		CWnd *pFilterTxt = GetParent()->GetDlgItem(stc2);
		ASSERT(pFilterTxt != NULL);			// List files of type caption
		pFilterTxt->GetWindowRect(&rcFilterTxt);

		CWnd *pInsertIntoTxt = GetDlgItem(IDC_PROJECTTOADDTO_LABEL);
		ASSERT(pInsertIntoTxt != NULL);		// Insert Into caption
		pInsertIntoTxt->GetWindowRect(&rcInsertIntoTxt);

		rcInsertIntoTxt.left = rcFilterTxt.left;
		rcInsertIntoTxt.right = rcFilterTxt.right;
		ScreenToClient(&rcInsertIntoTxt);
		pInsertIntoTxt->MoveWindow(&rcInsertIntoTxt);

		rcInsertInto.left = rcFilters.left;
		rcInsertInto.right = rcFilters.right;
		ScreenToClient(&rcInsertInto);
		pComboBox->MoveWindow(&rcInsertInto);
	}

	CString strProjectName;
	LPPROJECTWORKSPACE pInterface = g_IdeInterface.GetProjectWorkspace();
	if (pInterface != NULL)
	{
		CADWORD Projects;
		pInterface->GetLoadedProjects(&Projects);
		int nSize;
		if ((nSize = Projects.cElems) != 0)
		{
			IPkgProject *pActive;
			if (m_pProject == NULL)
			{
				COleRef<IPkgProject> pProject;
				pInterface->GetActiveProject(&pProject);
				pActive = pProject;
			}
			else
				pActive = m_pProject;

			for (int nIndex = 0; nIndex < nSize; nIndex++)
			{
				IPkgProject *pProject = (IPkgProject *)Projects.pElems[nIndex];
				LPCOLESTR pszProjName, pszProjPath;
				DWORD dwPackageID, dwFlags;
				pProject->GetProjectInfo(&pszProjName, &pszProjPath, &dwPackageID, &dwFlags);
				CString strProject = pszProjName;
				CoTaskMemFree((void *)pszProjName);
				CoTaskMemFree((void *)pszProjPath);
				
				VERIFY(pComboBox->InsertString(-1, strProject) == nIndex);
				pComboBox->SetItemData(nIndex, (DWORD)pProject);
				if (pProject == pActive)
				{
					pComboBox->SetCurSel(nIndex);
					strProjectName = strProject;
				}
				// The projects are still referenced by the workspace,
				// so we now they will be good for the duration of this dialog.
				pProject->Release();
			}
		}
		CoTaskMemFree((void *)Projects.pElems);
	}

	if (!m_strFolderName.IsEmpty())
	{
		// resize the commdlg controls slightly for long filter strings, and also
		// position the Insert Into text directly below the Filters combo, same size
		CRect rcFileName, rcCancel, rcInsertIntoTxt, rcFilterTxt, rcFilters, rcTextFrame;

		CWnd *pFileName = GetParent()->GetDlgItem(edt1);
		ASSERT(pFileName != NULL);			// File name edit
		pFileName->GetWindowRect(&rcFileName);
		rcFileName.right += 5;
		pFileName->SetWindowPos(NULL, rcFileName.left, rcFileName.top, rcFileName.right - rcFileName.left,
			rcFileName.bottom - rcFileName.top, SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOZORDER | SWP_SHOWWINDOW);

		CWnd *pFilters = GetParent()->GetDlgItem(cmb1);
		ASSERT(pFilters != NULL);			// List files of type combo
		pFilters->GetWindowRect(&rcFilters);
		rcFilters.right += 5;
		pFilters->SetWindowPos(NULL, rcFilters.left, rcFilters.top, rcFilters.right - rcFilters.left,
			rcFilters.bottom - rcFilters.top, SWP_NOCOPYBITS | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOSENDCHANGING | SWP_NOZORDER | SWP_SHOWWINDOW);

		CWnd *pCancel = GetParent()->GetDlgItem(IDCANCEL);
		ASSERT(pCancel != NULL);			// Cancel button
		pCancel->GetWindowRect(&rcCancel);

		CWnd *pFilterTxt = GetParent()->GetDlgItem(stc2);
		ASSERT(pFilterTxt != NULL);			// List files of type caption
		pFilterTxt->GetWindowRect(&rcFilterTxt);

		pComboBox->ShowWindow(SW_HIDE);
		CWnd *pLabel = GetDlgItem(IDC_PROJECTTOADDTO_LABEL);
		pLabel->ShowWindow(SW_HIDE);

		CWnd *pInsertIntoTxt = GetDlgItem(IDC_FOLDERPROJECT);
		ASSERT(pInsertIntoTxt != NULL);		// Insert Into caption
		CString strMsg;
		pInsertIntoTxt->SetWindowText(MsgText(strMsg, IDS_INSERTING_FILES, m_strFolderName, strProjectName));
		pInsertIntoTxt->GetWindowRect(&rcInsertIntoTxt);
		rcInsertIntoTxt.left = rcFilterTxt.left;
		rcInsertIntoTxt.right = rcCancel.right;
		ScreenToClient(&rcInsertIntoTxt);
		pInsertIntoTxt->MoveWindow(&rcInsertIntoTxt);
		pInsertIntoTxt->ShowWindow(SW_SHOW);
	}

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CAddFilesDialog::OnFileNameOK()
{
	BOOL bRet = CFileDialog::OnFileNameOK();

	// workaround for Windows bug [patbr]
	// allocate enough space for the filenames selected/entered by the user
	CEdit *pEdit = (CEdit *)GetParent()->GetDlgItem(edt1);
	int nLength = pEdit->GetWindowTextLength();
	CDir dir;
	VERIFY(dir.CreateFromCurrent());
	nLength += dir.GetLength() + _MAX_EXT + 3;	// add room for extension, backslash, trailing double NULL

	LPSTR lpstrFileT = m_ofn.lpstrFile;
	int nMaxFileT = m_ofn.nMaxFile;

	LPSTR lpstrFile = (LPSTR)malloc(nLength);
	memset(lpstrFile, 0, nLength);
	m_ofn.lpstrFile = lpstrFile;
	m_ofn.nMaxFile = (DWORD)nLength;

	CString strText;
	pEdit->GetWindowText(strText);
	if (strText.Find("\"") >= 0)
	{
		// we may have multiple filenames selected or entered by the user
		// also, commdlg doesn't handle quotes properly
		_tcscpy(m_ofn.lpstrFile, (const TCHAR *)dir);
		int nOffset = dir.GetLength() + 1;
		m_ofn.lpstrFileTitle = m_ofn.lpstrFile + nOffset;
		m_ofn.nFileOffset = (WORD)nOffset;
		int nStart, nEnd;
		while ((nStart = strText.Find("\"")) != -1)
		{
			strText = strText.Right(strText.GetLength() - nStart - 1);
			nEnd = strText.Find("\"");
			CString strName = strText.Left(nEnd);
			_tcscpy(m_ofn.lpstrFile + nOffset, strName);
			strText = strText.Right(strText.GetLength() - nEnd - 1);
			nOffset += nEnd + 1;
		}
	}
	else
	{
		// single filename selected or entered--commdlg has
		// the right path and we don't have to do anything to it
		_tcscpy(m_ofn.lpstrFile, lpstrFileT);
		m_ofn.nMaxFile = nMaxFileT;
	}

	m_saFileNames.RemoveAll();
	POSITION pos = GetStartPosition();
	BOOL fFileFound;
	while (pos != (POSITION)NULL)
	{
		fFileFound = FALSE;

		CString strFileName = GetNextPathName(pos);
		CPath path;
		path.Create(strFileName);
		if (path.IsInit() && path.ExistsOnDisk())
		{
#ifdef NOTDEF
			CString strFile = strFileName;
			strFile.MakeUpper();
			CString strPrj = BUILDER_EXT;
			strPrj.MakeUpper();
			CString strWks = WORKSPACE_EXT;
			strWks.MakeUpper();
			if (strFile.Find(strPrj) != -1)
			{
				CString strMsg;
				MsgBox(Error, MsgText(strMsg, IDS_ERR_CANNOT_ADD_PRJ, strFileName));
			}
			else if (strFile.Find(strWks) != -1)
			{
				CString strMsg;
				MsgBox(Error, MsgText(strMsg, IDS_ERR_CANNOT_ADD_WKS, strFileName));
			}
			else
#endif	// NOTDEF
			{
				m_saFileNames.Add(strFileName);
				fFileFound = TRUE;
			}
		}
		else
		{
			if(!path.IsInit())
			{
				ErrorBox(ERR_File_Not_Found, strFileName);
				bRet = TRUE;
				goto exit;
			}

			// first, try to give the file an extension if it hasn't got one
			CString strExt = GetExtension(strFileName);
			if (strExt.IsEmpty())
			{
				CComboBox* pComboBox = (CComboBox*)GetParent()->GetDlgItem(cmb1);

				ASSERT (pComboBox != NULL);
				int nSel = pComboBox->GetCurSel();
				if (nSel >= 0)
				{
					LPCSTR lpsz = m_ofn.lpstrFilter;
					while (lpsz != NULL && nSel--)
					{
						lpsz += lstrlen(lpsz)+1;		// skip past display text
						if (lpsz != NULL)
							lpsz += lstrlen(lpsz)+1;    // skip past *.ext info
					}

					if (lpsz != NULL)
					{
						lpsz += lstrlen(lpsz)+1;    // skip past display text
						ASSERT(lpsz[0] == '*');
						ASSERT(lpsz[1] == '.');
						ASSERT(lpsz[2] != '\0');
						do
						{
							CString strTestName = strFileName;
							_TCHAR ext[_MAX_EXT];
							int i = 0;

							while (*++lpsz != '\0' && *lpsz != ';')
								ext[i++] = *lpsz;
							ext[i] = '\0';

							strTestName += ext;

							// Check for existence.
							if (_access(strTestName, 00) == 0)
							{
					    		// Update the file name
								m_saFileNames.Add(strTestName);
								fFileFound = TRUE;
							}

						} while ((*lpsz++ != '\0') && (!fFileFound));
					}
				}
			}

			if (!fFileFound)
			{
				CString strMsg;
				int nReturn;
				if (strFileName.Find(" ") > 0)
				{
					CString strDir = strFileName.Left(strFileName.ReverseFind('\\'));
					CString strFile = strFileName.Right(strFileName.GetLength() - strFileName.ReverseFind('\\') - 1);
					nReturn = MsgBox(Question, MsgText(strMsg, IDS_ADD_NONEXISTENT_FILE2, strFileName, strFile, strDir), MB_YESNOCANCEL);
				}
				else
					nReturn = MsgBox(Question, MsgText(strMsg, IDS_ADD_NONEXISTENT_FILE, strFileName), MB_YESNOCANCEL);

				if (nReturn == IDYES)
				{
					m_saFileNames.Add(strFileName);
				}
				else if (nReturn == IDCANCEL)
				{
					bRet = TRUE;
					goto exit;
				}
			}
		}
	}

	{ // scope
		int nIndex = ((CComboBox *)GetDlgItem(IDC_PROJECTTOADDTO))->GetCurSel();
		m_pProject = (IPkgProject *)(((CComboBox *)GetDlgItem(IDC_PROJECTTOADDTO))->GetItemDataPtr(nIndex));
		// we don't allow wildcards in the filenames...
		for (int iFile = 0; iFile < m_saFileNames.GetSize(); iFile++)
		{
			if (m_saFileNames[iFile].FindOneOf("*?") != -1)
			{
				bRet = TRUE;
				goto exit;
			}
		}
	}

	m_fSuccess = TRUE;
exit:
	free(lpstrFile);
	m_ofn.lpstrFile = lpstrFileT;
	m_ofn.nMaxFile = nMaxFileT;
	return(bRet);
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\findctrl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FINDCTRL.CPP
//		Contains implementation for the customizable find combo.
//

#include "stdafx.h"
#include "findctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//	Global interface to the find control.
//

HWND CreateFindCombo(DWORD dwStyle, RECT* lpRect, HWND hwndParent, UINT nID)
{
	CFindCombo* pCombo = new CFindCombo;
	HWND hwndCombo=::CreateToolbarEditCombo(pCombo, dwStyle, lpRect, hwndParent, nID);
	if(hwndCombo==NULL)
	{
		delete pCombo;
		return NULL;
	}
	else
	{
		return hwndCombo;
	}
}

void SetFindFocus()
{
	CFindCombo::SetFindFocus();
}

void UpdateFindCombos()
{
	CFindCombo::UpdateAllViews();
}

BOOL IsFindComboActive()
{
	CWnd* pWnd = CWnd::GetFocus();
	CWnd* pWndParent = pWnd==NULL ? NULL : pWnd->GetParent();
	return pWndParent != NULL && pWndParent->IsKindOf(RUNTIME_CLASS(CFindCombo));
}

///////////////////////////////////////////////////////////////////////////////
//	CFindCombo
//

IMPLEMENT_DYNAMIC(CFindCombo, CToolbarEditCombo)

CObList CFindCombo::s_listCombos;

CFindCombo::CFindCombo()
//:	m_nId(0)
{
	s_listCombos.AddTail(this);
}

CFindCombo::~CFindCombo()
{
	CObject* pObj;

	POSITION pos = s_listCombos.GetHeadPosition();
	while (pos != NULL)
	{       
		pObj = s_listCombos.GetAt(pos);
		if (pObj == this)
		{
			s_listCombos.RemoveAt(pos);
			break;
		}

		s_listCombos.GetNext(pos);
	}
}

BOOL CFindCombo::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	if (!CToolbarEditCombo::Create(dwStyle, rect, pParentWnd, nID))
		return FALSE;

	LimitText(LIMIT_FIND_COMBO_TEXT);

	return TRUE;
}

BOOL CFindCombo::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message != WM_KEYDOWN)
		return FALSE;

	switch (pMsg->wParam)
	{
	case VK_RETURN:
		if ((pMsg->lParam & 0x4000000) == 0)	// Not a repeat.
		{
			// See if there's something to find
			if (UpdateFindInfo(TRUE))
			{
				SetCurSel(0);

				HWND hwndView = theApp.GetActiveView();
				if (hwndView == NULL)
					return 0L;

				CPartView* pView = (CPartView*) FromHandlePermanent(hwndView);
				ASSERT(pView != NULL && pView->IsKindOf(RUNTIME_CLASS(CPartView)));

				// Shift+Enter means search up.
				if (GetKeyState (VK_SHIFT) & 0x8000)
					findReplace.goUp = TRUE;
				else
					findReplace.goUp = FALSE;

				pView->OnFindNext();
			}
		}
		return TRUE;  
	}
	
	return CToolbarEditCombo::PreTranslateMessage(pMsg);
}

BOOL CFindCombo::UpdateFindInfo(BOOL bUpdateDropDown)
{
	char szTmp[LIMIT_FIND_COMBO_TEXT + 1];
	SendMessage(WM_GETTEXT, LIMIT_FIND_COMBO_TEXT, (long)(LPSTR)szTmp);
	if (szTmp[0] == '\0')
		return FALSE;

	lstrcpy(findReplace.findWhat, szTmp); // update the find string
	findReplace.DisposeOfPattern(); // invalidate the old regex pattern compiled previously

	ShellPickList().InsertEntry(FIND_PICK, &findReplace);	// This updates all views.

	if (bUpdateDropDown)
		UpdateDropDown();

	return TRUE;
}

void CFindCombo::UpdateDropDown()
{
	LPCSTR lpsz;

	ResetContent();

	for (int i = 0 ; i < ShellPickList().GetEntryCount(FIND_PICK); i++)
	{
		VERIFY(lpsz = ShellPickList().GetEntry(FIND_PICK,i));
		InsertString(-1, lpsz);
	}

	SetCurSel(0);
}

void CFindCombo::UpdateView()
{
	CString strCurrent;
	GetWindowText(strCurrent);

	if (ShellPickList().GetEntryCount(FIND_PICK) > 0)
	{
		LPCSTR lpsz;

		VERIFY(lpsz = ShellPickList().GetEntry(FIND_PICK,0));
		if (strCurrent != lpsz)
			SetWindowText(lpsz);
	}
	else if (!strCurrent.IsEmpty())
	{
		SetWindowText("");
	}
}

void CFindCombo::UpdateAllViews()
{
	CFindCombo* pCombo;

	POSITION pos = s_listCombos.GetHeadPosition();
	while (pos != NULL)
	{       
		pCombo = (CFindCombo*) s_listCombos.GetNext(pos);
		ASSERT(pCombo != NULL);
		pCombo->UpdateView();
	}
}

void CFindCombo::SetFindFocus()
{
	CFindCombo* pCombo;
	BOOL fComboFound = FALSE;

	POSITION pos = s_listCombos.GetHeadPosition();
	while (pos != NULL)
	{       
		pCombo = (CFindCombo*) s_listCombos.GetNext(pos);
		ASSERT(pCombo != NULL);

		if (pCombo->IsWindowVisible() && pCombo->IsWindowEnabled())
		{
			pCombo->SetFocus();
			fComboFound = TRUE;
			break;
		}
	}

	if (!fComboFound)
	{
		theApp.m_pMainWnd->SendMessage(WM_COMMAND, MAKEWPARAM((WORD)ID_EDIT_FIND, 1));
	}
}

BOOL CFindCombo::DoHelp(void)
{
	if (UpdateFindInfo(FALSE)) {
		theApp.HelpOnKeyword(findReplace.findWhat);
	}
	else {
		theApp.HelpOnApplication(m_nId,HELPTYPE_COMMAND);
	}
	// Grab focus if no view has gotten it
	if (theApp.GetActiveView() == NULL)
	{
		// and no flosting window (like Query results) is active.
		CWnd * pwnd = GetActiveWindow();
		if (pwnd && pwnd->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd)))
			return TRUE;
		SetFindFocus();
	}
	return TRUE;
}

void CFindCombo::OnEditKillFocus(void)
{
	if (!UpdateFindInfo(FALSE))
	{
		SetCurSel(0);
	}
}

void CFindCombo::OnEditSetFocus(void)
{
	UpdateDropDown();
}

BOOL CFindCombo::OnEditHelp(void)
{
	return DoHelp();
}

BEGIN_MESSAGE_MAP(CFindCombo, CToolbarEditCombo)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\findctrl.h ===
///////////////////////////////////////////////////////////////////////////////
//	FINDCTRL.H
//		Declarations for the find combo.

#ifndef __FINDCTRL_H__
#define __FINTCTRL_H__

#include "shlbar.h"

HWND CreateFindCombo(DWORD dwStyle, RECT* lpRect, HWND hwndParent, UINT nID);

class CFindCombo : public CToolbarEditCombo
{
// Construction.
public:
	CFindCombo();
	~CFindCombo();

	Create(DWORD dwStyle, const RECT& rect, CWnd* pWnd, UINT nID);

	virtual BOOL PreTranslateMessage(MSG* pMsg);

public:
	BOOL UpdateFindInfo(BOOL bUpdateDropDown);
	void UpdateDropDown();
	virtual void UpdateView();
	virtual void OnEditSetFocus(void);
	virtual void OnEditKillFocus(void);
	virtual BOOL OnEditHelp(void);
	static void UpdateAllViews();
	static void SetFindFocus();
	BOOL DoHelp(void);

    DECLARE_MESSAGE_MAP()

// Attributes.
protected:
	static CObList s_listCombos;
	UINT m_nId; // Help ID

public:
	DECLARE_DYNAMIC(CFindCombo);
};

class CFindComboEdit : public CWnd
{
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	CFindCombo* GetFindCombo(void);

public:
	DECLARE_DYNAMIC(CFindComboEdit);
};

#endif	//	__FINDCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\filesave.cpp ===
///////////////////////////////////////////////////////////////////////////////
//	FILESAVE.CPP
//		Utilities used in saving files.

#include "stdafx.h"
#include "path.h"
#include "resource.h"

#include "utilauto.h" // For g_pAutomationState.

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//	CFileSaver

static BOOL RenameFile(LPCTSTR szOldName, LPCTSTR szNewName);
static void RemoveFileIfPossible(LPCTSTR szFileName);

// base for temp file names
const char BASED_CODE CFileSaver::c_szAps [] = "~VC";
static char BASED_CODE acDot[] = ".";

CFileSaver::CFileSaver(const char* szFileName)
{
	m_strName = szFileName;

	LPTSTR lpsz;
	TCHAR szDir[_MAX_PATH];
	LPTSTR lpszTempName = m_strTempName.GetBuffer(_MAX_PATH);
	LPTSTR lpszBackupName = m_strBackupName.GetBuffer(_MAX_PATH);
	BOOL bSuccess = FALSE, bNeedPath = FALSE;

	// First try to get temp names if the directory of interest.
	int nLen = GetFullPathName(szFileName, _MAX_PATH, szDir, &lpsz);
	if( (nLen > 0) && (nLen < _MAX_PATH) )
	{
		*lpsz = _T('\0');	// Strip file name.
		if( GetTempFileName(szDir, c_szAps, 0, lpszTempName) != 0 )
		{
			if( GetTempFileName(szDir, c_szAps, 0, lpszBackupName) != 0 )
				bSuccess = TRUE;
			else
				RemoveFileIfPossible(lpszTempName);
		}
	}

	// If we could get temp names in the directory of interest,
	// then try curdir.  This is not strictly cosher, but mostly this
	// will happen when the directory does not exist, and we should
	// catch this type of error later on.
	
	if (!bSuccess)
	{
		bNeedPath = TRUE;
		if( GetTempFileName(acDot, c_szAps, 0, lpszTempName) != 0 )
		{
			if( GetTempFileName(acDot, c_szAps, 0, lpszBackupName) != 0 )
				bSuccess = TRUE;
			else
				RemoveFileIfPossible(lpszTempName);
		}
	}

	m_strTempName.ReleaseBuffer();
	m_strBackupName.ReleaseBuffer();

	if (!bSuccess)
	{
		m_strTempName.Empty();
		m_strBackupName.Empty();
		return;
	}

	// GetTempFileName actually creates files.
	RemoveFileIfPossible(m_strTempName);

	// n.b. We must leave the backup file around to preserve namespace
	// until we need it.  Otherwise, an unrelated call to GetTempFileName
	// may try to use the same name, especially under Win95

	// If we got temp names for curdir, the we have to change the paths.
	if (bNeedPath)
	{
		RemoveFileIfPossible(m_strBackupName);

		CString strDir = StripName(szFileName);

		m_strTempName = strDir + StripPath(m_strTempName);
		m_strBackupName = strDir + StripPath(m_strBackupName);

		// REVIEW: create m_strBackupName
	}
}

CFileSaver::~CFileSaver()
{
	if (FileExists(m_strTempName))
		RemoveFileIfPossible(m_strTempName);
	
	if (FileExists(m_strBackupName))
		RemoveFileIfPossible(m_strBackupName);
}

BOOL CFileSaver::CanSave() const
{
	CFileStatus fs;

	if (CFile::GetStatus(m_strName, fs) &&
		(fs.m_attribute & CFile::readOnly) != 0)
	{
		SetFileError(ferrCantSaveReadOnly);
		return FALSE;
	}
	
	if (m_strTempName.IsEmpty() || m_strBackupName.IsEmpty())
	{
		SetFileError(ferrCantSaveTempFiles);
		return FALSE;
	}
	
	return TRUE;
}

BOOL CFileSaver::MakeWriteable() const
{
	CFileStatus fs;

	if (CFile::GetStatus(m_strName, fs))
	{
		if ((fs.m_attribute & CFile::readOnly) == 0)
			return TRUE;
		else
		{
			fs.m_attribute &= ~CFile::readOnly;
			TRY
			{
				CFile::SetStatus(m_strName, fs);
				return TRUE;
			}
			CATCH_ALL(e)
			{
				return FALSE;
			}
			END_CATCH_ALL
		}
	}

	return FALSE;
}

BOOL CFileSaver::Finish()
{
	// delete 0-length place-saver file first
	RemoveFileIfPossible(m_strBackupName);

	if (FileExists(m_strName))
	{
		if (!RenameFile(m_strName, m_strBackupName))
		{
			// If we weren't able to rename the file, at least
			// give some indication of this fact.
			FileErrorMessageBox(IDS_RENAME_FAILED, m_strName);
			RemoveFileIfPossible(m_strTempName);
			return FALSE;
		}
	}
	else
	{
		// no backup was made since the "original" didn't exists,
		// wipe out the name so we don't delete the file later...	
		m_strBackupName.Empty();
	}
	
	if (!RenameFile(m_strTempName, m_strName))
	{
		if (!m_strBackupName.IsEmpty() &&
			RenameFile(m_strBackupName, m_strName))
		{
			RemoveFileIfPossible(m_strTempName);
		}
		
		return FALSE;
	}
	
	if (!m_strBackupName.IsEmpty())
		RemoveFileIfPossible(m_strBackupName);
	
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////
// File Utilities

BOOL RenameFile(LPCTSTR szOldName, LPCTSTR szNewName)
{
    TRACE2("RenameFile: \"%s\" to \"%s\"\n", szOldName, szNewName);
    
    TRY
    {
        if (FileExists(szNewName))
            CFile::Remove(szNewName);
        CFile::Rename(szOldName, szNewName);
    }
    CATCH(CFileException, e)
    {
        TRACE("Rename failed!\n");
        SetFileError(e->m_cause);
        return FALSE;
    }
    END_CATCH
    
    return TRUE;
}

void RemoveFileIfPossible(LPCTSTR szFileName)
{
	TRY
	{
		CFile::Remove(szFileName);
	}
	CATCH_ALL(e)
	{
		// Just silently ignore if we cant remove the file.
	}
	END_CATCH_ALL
}

///////////////////////////////////////////////////////////////////////////////
//	File Error support

static int g_nFileErrorCause = CFileException::none; // from CFileException::m_cause

int GetFileError()
{
	return g_nFileErrorCause;
}

void SetFileError(int nCause)
{
	g_nFileErrorCause = nCause;

	// Mirror the error for the automation object.	ShellOM:State
	g_pAutomationState->SetFileError(nCause) ;
}

// Display a message box informing the user of a file related exception.
// The format of the box is something like:
//
//     <file name>
//     <operation failed>
//     <reason>
//
// <file name> describes what file has the problem, <operation files>
// indicated what kind of thing failed (e.g. "Cannot save file"), and
// <reason> provides more information about why the operation failed
// (e.g. "Disk full").
//
// The <reason> parameter must have been setup previously via a call to
// SetFileError().

void FileErrorMessageBox(unsigned int idsOperation, LPCTSTR szFileName)
{
	// Only display and clear the error if an automation macro is not running.
	if (g_pAutomationState->DisplayUI()) // ShellOM::Save
	{

		if (g_nFileErrorCause > 0)
		{
			CString strOperation;
			VERIFY(strOperation.LoadString(idsOperation));

			CString strReason;
			VERIFY(strReason.LoadString(theApp.IdsFromFerr(g_nFileErrorCause)));

			CString strMsg;
			MsgBox(Error, MsgText(strMsg, IDS_ERROR_FILE_TEMPLATE,
        		szFileName, (LPCTSTR)strOperation, (LPCTSTR)strReason));
		}
    
		SetFileError(CFileException::none) ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\findspec.h ===
// findspec.h

// FindSpecialHandler
//
// hDlg		Dialog handle
// idEdit	ID of combo box control to modify
// cmd		Menu command ID from the IDR_FIND_SPECIAL menu
// dwSel	Packed selection range (use return val from CB_GETEDITSEL)
// bWrap	TRUE: Wrap range/group/tag items.
//			FALSE: Just replace selection
//
// Use OnCommandRange ID_FIND_ANYCHARACTER to ID_FIND_STRING
// for Find What text.
//
// Use OnCommandRange ID_REPLACE_FINDWHATTEXT to ID_REPLACE_TAG_9
// for Replace With text:
//
// Example use in a DlgProc:
//
//	case WM_COMMAND:
//	{
//		UINT CommandId;
//
//		CommandId = GET_WM_COMMAND_ID(wParam, lParam);
//		if (ID_FIND_ANYCHARACTER <= CommandId && CommandId <= ID_FIND_STRING)
//		{
//			// add appropriate item to Find What
//			return FindSpecialHandler(hDlg,ID_FIND_WHAT,CommandId);
//		}
//	...

BOOL FindSpecialHandler( CButtonEdit &ComboEdit, UINT cmd, BOOL bWrap = FALSE );

/////////////////////////////////////////////////////////////
// ReplaceSel - Replace the selection in a combobox.
//
//   ComboEdit		Edit control to modify
//
//   szRep		Replacement string
//
//   selpos		How to select the result:
//		spStart			Ip at start of replaced selection
//	 	spEnd			Ip at end of replaced selection
//	 	spSel			Select the replacement
//		spInsideStart	Ip inside start of wrap
//		spInsideEnd		Ip inside end of wrap
//
//   bWrap		Wrap the replacement around the selection?
//
//   nWrapBreak	Position in szRep to break when wrapping.
//   
enum NewSelPos { spStart, spEnd, spSel, spInsideStart, spInsideEnd };
void ReplaceSel( 
	CButtonEdit & ComboEdit,
	LPCTSTR szRep, 
	NewSelPos selpos = spEnd, 
	BOOL bWrap = FALSE, 
	int nWrapBreak = 0
	);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\find.h ===
#ifndef __DLGBASE_H__
#include <dlgbase.h>	// C3dDialog
#endif

#ifndef __MENUBTN_H__
#include <utilctrl.h>
#endif

void SaveFindReplaceStrings();
void LoadFindReplaceStrings();

/////////////////////////////////////////////////////////////////////////////
// CButtonEdit window
// use CButtonEdit to associate an edit field and a menu button item:
// the edit field will remember the last selection and cursor position

class CButtonEdit : public CEdit
{
// Construction
public:
	CButtonEdit();

// Attributes
public:
	DWORD m_dwLastSel; // last selection on KillFocus

// Methods
public:
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);

// Operations
protected:
	afx_msg void OnKillFocus(CWnd *pNewWnd);

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CFindStringDlg dialog

class CFindStringDlg : public C3dDialog
{
// Construction
public:
	CFindStringDlg(LONG lStyle, CWnd* pParent = NULL);
	~CFindStringDlg();

// Dialog Data
	//{{AFX_DATA(CFindStringDlg)
//	enum { IDD = IDD_FIND };
	BOOL	m_bMatchCase;
	BOOL	m_bRegExp;
	BOOL	m_bWholeWord;
	int		m_nDirection;
	BOOL	m_bSearchAllDocs;
	CString	m_strFindString;
	CButton	m_btnFindNext;
	//}}AFX_DATA

	CMenuBtn m_btnSpecial;
	CButtonEdit m_comboEdit;

	LONG m_lStyle;
	BOOL m_bInitString;

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CFindStringDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickedFindNext();
	afx_msg void OnClickedMarkAll();
	afx_msg void OnClickedSearchAll();
	afx_msg void OnEditChangeFindWhat();
	afx_msg void OnSelChangeFindWhat();
	afx_msg void OnKillfocusFindWhat();
	afx_msg void OnSpecialItem(UINT nId);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Helper functions
	void UpdateState();
	void UpdateButtons(BOOL fEnable);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\floatwnd.cpp ===
// floatwnd.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern UINT WM_ISERROR;

IMPLEMENT_DYNAMIC(CFloatingFrameBar, C3dDialogBar)

CFloatingFrameBar::CFloatingFrameBar()
{
}

BOOL CFloatingFrameBar::Create(CWnd* pParentWnd, UINT nIDTemplate)
{
	// parameters: (CWnd* pParentWnd, UINT nIDTemplate, UINT nStyle, UINT nID );
	return C3dDialogBar::Create(pParentWnd, nIDTemplate, CBRS_TOP, AFX_IDW_TOOLBAR);
}

BOOL CFloatingFrameBar::OnInitDialog()
{
	if (!m_btnPushPin.AutoLoad(ID_PROP_PUSHPIN, this, TRUE) ||
		!m_btnHelp.AutoLoad(ID_HELP, this))
	{
		return FALSE;
	}

	// Override dialog bar sizing, so all our bars are the same size
	m_sizeDefault.cy = CY_TOOLBAR + CY_BORDER;
	if (theApp.m_bWin4)
		m_sizeDefault.cy += CY_BORDER;

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CToggleBitmapButton
//

CToggleBitmapButton::CToggleBitmapButton()
{
	m_fDown = FALSE;	// button starts up
}

void CToggleBitmapButton::SetChecked(BOOL fDown)
{
	if (fDown == m_fDown)
		return;

	// exchange the up and down bitmaps...
	m_fDown = !m_fDown;
	HGDIOBJ hbitmap1 = m_bitmap.Detach();
	HGDIOBJ hbitmap2 = m_bitmapSel.Detach();
	m_bitmap.Attach(hbitmap2);
	m_bitmapSel.Attach(hbitmap1);

	InvalidateRect(NULL, FALSE);
}

BEGIN_MESSAGE_MAP(CToggleBitmapButton, CBitmapButton)
	ON_WM_LBUTTONUP()
END_MESSAGE_MAP()

void CToggleBitmapButton::OnLButtonUp(UINT n1, CPoint pt)
//
// the user has just released the button, we must now swap the bitmap
// images to get the toggle behaviour -- i.e. the nuetral state becomes
// down if it used to be up and up if it used to be down BUT ONLY
// IF THE USER RELEASED THE BUTTON WITH THE CURSOR IN THE CLIENT AREA
//
{
	CRect rect;
	GetClientRect(&rect);

	if (GetCapture() == this && rect.PtInRect(pt))
	{
		// exchange the up and down bitmaps...
		m_fDown = !m_fDown;
		HGDIOBJ hbitmap1 = m_bitmap.Detach();
		HGDIOBJ hbitmap2 = m_bitmapSel.Detach();
		m_bitmap.Attach(hbitmap2);
		m_bitmapSel.Attach(hbitmap1);
	}

	// do default processing for this message...
	C3dBitmapButton::OnLButtonUp(n1, pt);
}


/////////////////////////////////////////////////////////////////////////////
// CFloatingFrameWnd
//
// This class implements floating frame windows with push pins, such
// as the browser window.  The shell identifies these windows using
// IsKindOf(), so all floating frame windows should be derived from
// this class.

IMPLEMENT_DYNAMIC(CFloatingFrameWnd, CFrameWnd)


BEGIN_MESSAGE_MAP(CFloatingFrameWnd, CFrameWnd)

	ON_WM_ACTIVATE()
	ON_WM_ACTIVATEAPP()
	ON_WM_MOUSEACTIVATE()

	ON_BN_CLICKED(ID_HELP, OnHelp)
	ON_BN_CLICKED(ID_PROP_PUSHPIN, OnPushPin)
	ON_BN_DOUBLECLICKED(ID_PROP_PUSHPIN, OnPushPin)

END_MESSAGE_MAP()


CFloatingFrameWnd::CFloatingFrameWnd()
{
	m_pToolBar = NULL;
}

CFloatingFrameWnd::~CFloatingFrameWnd()
{
	if (m_pToolBar != NULL)
	{
		delete m_pToolBar;
		m_pToolBar = NULL;
	}
}

BOOL CFloatingFrameWnd::IsWindowPinned()
{
	CFloatingFrameBar* pBar = GetToolBar();
	ASSERT(pBar && pBar->IsKindOf( RUNTIME_CLASS(CFloatingFrameBar) ));

	return pBar->m_btnPushPin.IsButtonDown();
}

void CFloatingFrameWnd::SetPushPin(BOOL bPinned)
{
	CFloatingFrameBar* pBar = GetToolBar();
	ASSERT(pBar && pBar->IsKindOf( RUNTIME_CLASS(CFloatingFrameBar) ));

	pBar->m_btnPushPin.SetChecked(bPinned);
}

void CFloatingFrameWnd::OnActivate(UINT nState, CWnd* pWndNew, BOOL b)
{
	if (nState == WA_INACTIVE)
	{
		// If the window isn't pinned and our app is retaining the focus,
		// close this window.
		if (!IsWindowPinned() && pWndNew != NULL)
			PostMessage(WM_CLOSE, 0, 0L);
	}

	CFrameWnd::OnActivate(nState, pWndNew, b);
}

void CFloatingFrameWnd::OnActivateApp(BOOL bActive, HTASK)
{
	// if button is not down... we must activate now or
	// we'll go away regardless of where the user clicks

	if (!IsWindowPinned())
		SetFocus();
}

int CFloatingFrameWnd::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest,
	UINT message)
{
	if (theApp.m_hwndValidate != NULL &&
		::SendMessage(theApp.m_hwndValidate, WM_ISERROR, 0, 0L))
	{
		return MA_NOACTIVATEANDEAT;
	}

	return CFrameWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

BOOL CFloatingFrameWnd::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_SYSKEYDOWN)
	{
#if 0
		// Don't do this.  These windows usually have a system menu.
		// Under Win95, the system menu shows the accelerator Alt+F4
		// for the close menuitem.  The windows are more like modeless
		// dialogs which can be closed using Alt+F4.

		// forward Alt+F4 to the shell window
		if (pMsg->wParam == VK_F4) 
		{
			AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_APP_EXIT, 0L);
			return TRUE;
		}
#endif
		if (GetToolBar()->PreTranslateSysKey(pMsg))
		{
			return TRUE;
		}
		if (::IsChild(m_hWnd, pMsg->hwnd))
		{
			PostMessage(WM_SYSKEYDOWN, pMsg->wParam, pMsg->lParam);
			return TRUE;
		}
	}

	return CFrameWnd::PreTranslateMessage(pMsg);	
}

BOOL CFloatingFrameWnd::OnCreateClient(LPCREATESTRUCT lpCreateStruct, CCreateContext* pCreateContext)
{
	// If a derived class hasn't already created the toolbar, create it

	if (GetToolBar() == NULL)
		m_pToolBar = new CFloatingFrameBar;

	if ((GetToolBar()->m_hWnd == NULL) &&
	    !GetToolBar()->Create(this, IDD_PUSHPIN_DIALOGBAR))
	{
		TRACE("Failed to Create/Init Toolbar\n");
		return FALSE;
	}

	// must manually initialize the dialog bar because there will be no
	// WM_INIT message as there is no dialog per se.  We are just a dialog
	// template...
	if (!GetToolBar()->OnInitDialog())
	{
		TRACE("Failed to Init Toolbar\n");
		return FALSE;
	}

	return CFrameWnd::OnCreateClient(lpCreateStruct, pCreateContext);
}

afx_msg void CFloatingFrameWnd::OnHelp()
{
	// Each floating window derived class will override the GetHelpID
	// virtual function to provide the proper help context ID.
	//
	DWORD helpID = GetHelpID();

	// orion  bug 24 bobz: help button causes unpinned browser to vanish,
	// taking help with it.
	// Seems to me that this is the simplest fix: see if window is pinned; if not pin it
	// restore state afterward. Much simpler than messing with activation code
	// etc.

	BOOL fWasPinned = IsWindowPinned();
	if (!fWasPinned) 
		SetPushPin(TRUE);

	if (helpID != 0)
		theApp.HelpOnApplication(helpID);

#ifdef _DEBUG
	else
	{
		::MessageBeep(0);	// no help available, apparently
		AfxMessageBox("This CFloatingFrameWnd derived class has not provided a help context ID");
	}
#endif	// _DEBUG

	if (!fWasPinned) 	// restore if required
		SetPushPin(FALSE);

}

afx_msg void CFloatingFrameWnd::OnPushPin()
{
	// The push-pin control handles its own visual appearance.
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\fmtinfo.cpp ===
//						FMTINFO.CPP
//
//
/////

#include "stdafx.h"
#include "resource.h"
#include "fcdialog.h"
#include <stddef.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC (CFormatInfo, CObject);

//////////////////////////////////////////////////////////////////////////////
//																			//
//							class CFormatInfo								//
//																			//
//////////////////////////////////////////////////////////////////////////////

_TCHAR	CFormatInfo::m_szRegKey[]	= _TEXT("Format");
_TCHAR	CFormatInfo::m_szFontFace[] = _TEXT("FontFace");
_TCHAR	CFormatInfo::m_szFontSize[] = _TEXT("FontSize");


int		CFormatInfo::m_nPixPerInchY = 0;

///// Constructor
//
///
CFormatInfo::CFormatInfo (
CPackage *	pPackage
) :
m_pPackage	(pPackage),
m_pWinGroup (NULL),
m_nWinGroups (0)
{
	if (m_nPixPerInchY == 0)
	{
		CDC * pDC = theApp.m_pMainWnd->GetDC();
		m_nPixPerInchY = pDC->GetDeviceCaps (LOGPIXELSY);
		theApp.m_pMainWnd->ReleaseDC (pDC);
	}
}


///// Destructors
//
//	Deallocate everything
//
///
CFormatInfo::~CFormatInfo ()
{
	Clear ();
}


///// Clear - Blow off all data
//
///
void CFormatInfo::Clear ()
{
	if (m_pWinGroup == NULL) {
		ASSERT (m_nWinGroups == 0);
		return;
		}

	for (	int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++ )
	{

		for ( int iWindow = 0; iWindow < m_pWinGroup[iWinGroup].nWindows; iWindow++ )
		{
			FMT_WINDOW * pWindow = &m_pWinGroup[iWinGroup].rgWindows[iWindow];

			for (	FMT_ELEMENT * pElement = &pWindow->rgElements[0];
					pElement <  &pWindow->rgElements[pWindow->nElements];
					pElement++ )
			{
				delete [] pElement->szElement;
			}

			delete [] pWindow->rgElements;

			delete [] pWindow->szWindow;

			delete [] pWindow->szRegEntry;

			if (pWindow->pLogFont)
				delete pWindow->pLogFont;
			if (pWindow->szFontFace)
				delete [] pWindow->szFontFace;
	
		}

		if (m_pWinGroup[iWinGroup].rgWindows)
			delete [] m_pWinGroup[iWinGroup].rgWindows;
		if (m_pWinGroup[iWinGroup].szName)
			delete [] m_pWinGroup[iWinGroup].szName;
	}

	delete [] m_pWinGroup;

	m_pWinGroup = NULL;
	m_nWinGroups = 0;
}


///// GetFormatInfo - Query package for its Format Information
//
///
BOOL CFormatInfo::GetFormatInfo (
CPackage * pPackage
) {

	if (pPackage == NULL) {
		// Either the constructor or this function must establish the m_pPackage field
		ASSERT (m_pPackage != NULL);
		pPackage = m_pPackage;
		}
	else
	if (m_pPackage == NULL)
		m_pPackage = pPackage;

	m_pFormatInfoFromPackage = pPackage->GetFormatInfo();

	if (m_pFormatInfoFromPackage != NULL) {

		(*this) = *m_pFormatInfoFromPackage;

		UpdateAllAutoColors ();

		return TRUE;
		}
	else
		return FALSE;
}


///// SaveToRegistry - Update registry
//
///
void CFormatInfo::SaveToRegistry () const
{
	if (m_pWinGroup == NULL) {
		ASSERT (m_nWinGroups == 0);
		return;
		}

	CString strMasterKey = GetRegistryKeyName();
	strMasterKey += chKeySep;
	strMasterKey += m_szRegKey;
	strMasterKey += chKeySep;

	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++)
	{
		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++)
		{

			FMT_WINDOW * pWindow = &pWinGroup->rgWindows[iWindow];

			HKEY	hkey;
			DWORD	dwResult;

			if (ERROR_SUCCESS == RegCreateKeyEx (
									HKEY_CURRENT_USER,		// Master Key
									strMasterKey + pWindow->szRegEntry,
									0,						// Reserved
									NULL,					// We have no class
									0,						// Default volatility
									KEY_ALL_ACCESS,			// What the heck
									NULL,					// Default security
									&hkey,
									&dwResult ))			// Created/Opened
			{

				if (pWindow->szFontFace)
				{
					if (ERROR_SUCCESS != RegSetValueEx (hkey, m_szFontFace, 0, REG_SZ, (CONST BYTE *)pWindow->szFontFace, _tcslen(pWindow->szFontFace)+1))
					{
						ASSERT (FALSE);
						return;
					}

					if (ERROR_SUCCESS != RegSetValueEx (hkey, m_szFontSize, 0, REG_DWORD, (CONST BYTE *)&pWindow->nFontSize, sizeof(pWindow->nFontSize)))
					{
						ASSERT (FALSE);
						return;
					}

				}

				for ( int iElement = 0; iElement < pWindow->nElements; iElement++ )
				{

					FMT_ELEMENT * pElement = &pWindow->rgElements[iElement];

					if (ERROR_SUCCESS != RegSetValueEx (
											hkey,
											pElement->szElement,
											0,
											REG_BINARY,
											(BYTE *)pElement + offsetof (FMT_ELEMENT, rgbText),
		 									sizeof (FMT_ELEMENT) - offsetof(FMT_ELEMENT, rgbText)
											))
					{
						ASSERT (FALSE);
						return;
					}
				}
			}			
		}
	}
}


///// UpdateFromRegistry () - Update current FMT_WINGROUP data from registry
//
//	This supports reading the registry more than once. 
///
void CFormatInfo::UpdateFromRegistry ()
{
	if (m_pWinGroup == NULL) {
		ASSERT (m_nWinGroups == 0);
		return;
		}

	CString strMasterKey = GetRegistryKeyName();
	strMasterKey += chKeySep;
	strMasterKey += m_szRegKey;
	strMasterKey += chKeySep;

	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++)
	{
		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++)
		{

			FMT_WINDOW * pWindow = &pWinGroup->rgWindows[iWindow];

			HKEY	hkey;

			if (ERROR_SUCCESS == RegOpenKeyEx (
										HKEY_CURRENT_USER,		// Master Key
										strMasterKey + pWindow->szRegEntry,	
										0,						// Reserved
										KEY_ALL_ACCESS,			// What the heck
										&hkey ))
			{
				DWORD dwType;
				_TCHAR rgchBuffer[60];	// Arbitrary   
				DWORD cbBuffer = sizeof(rgchBuffer);

			
				if (ERROR_SUCCESS == RegQueryValueEx (hkey, m_szFontFace, NULL, &dwType, (PUCHAR)rgchBuffer, &cbBuffer))
				{
					ASSERT (dwType == REG_SZ);

					if (pWindow->szFontFace)
						if (_tcsicmp (pWindow->szFontFace, rgchBuffer))
						{
							delete [] pWindow->szFontFace;
							pWindow->szFontFace = NewString (rgchBuffer);
						}
						else
							;
				}

				cbBuffer = sizeof(pWindow->nFontSize);

				if (ERROR_SUCCESS == RegQueryValueEx (hkey, m_szFontSize, NULL, &dwType, (PUCHAR)&pWindow->nFontSize, &cbBuffer))
				{
					ASSERT (dwType == REG_DWORD);
				}

				UpdateLogFont (pWindow);

				for ( int iElement = 0; iElement < pWindow->nElements; iElement++ )
				{

					FMT_ELEMENT * pElement = &pWindow->rgElements[iElement];

					cbBuffer = sizeof(FMT_ELEMENT) - offsetof(FMT_ELEMENT, rgbText);

					if (ERROR_SUCCESS == RegQueryValueEx (hkey, pElement->szElement, NULL, &dwType, (PUCHAR)&pElement->rgbText, &cbBuffer))
					{
						ASSERT (dwType == REG_BINARY);
						ASSERT (cbBuffer == sizeof (FMT_ELEMENT) - offsetof(FMT_ELEMENT, rgbText));
					}
				}

				RegCloseKey(hkey);
			}
		}
	}

	UpdateAllAutoColors ();
}


///// Update - Update from one instance to another without changing structure
//
//	Assume that the CFormatInfo argument is structured the same as this.
//	iWinGroupUpd == -1 means do all groups
//	iWinUpd == -1 means do all Windows
///
void CFormatInfo::Update (const CFormatInfo& fmtInfo, int iWinGroupUpd, int iWindowUpd)
{
	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++)
	{
		if (iWinGroupUpd != -1 && iWinGroup != iWinGroupUpd)
			continue;

		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++ )
		{
			if (iWindowUpd != -1 && iWindow != iWindowUpd)
				continue;

			FMT_WINDOW * pWinDst = &pWinGroup->rgWindows[iWindow];
			FMT_WINDOW * pWinSrc = fmtInfo.GetWindow (pWinDst->szWindow);

			if (pWinSrc != NULL)
			{
				pWinDst->bChanged = TRUE;

				if (	pWinSrc->szFontFace == NULL
					||	pWinDst->szFontFace == NULL
					|| _tcsicmp (pWinDst->szFontFace, pWinSrc->szFontFace))
				{
					if (pWinDst->szFontFace)
						delete [] pWinDst->szFontFace;
					
					if (pWinSrc->szFontFace)
						pWinDst->szFontFace = NewString (pWinSrc->szFontFace);
					else
						pWinDst->szFontFace = NULL;
				}

				pWinDst->nFontSize = pWinSrc->nFontSize;

				if (pWinSrc->pLogFont)
				{
					if (pWinDst->pLogFont == NULL)
						pWinDst->pLogFont = new LOGFONT;

					*(pWinDst->pLogFont) = *(pWinSrc->pLogFont);
				}
				else
					UpdateLogFont (pWinDst);

				ASSERT (pWinDst->nElements == pWinSrc->nElements);

				for ( int iElement = 0; iElement < pWinDst->nElements; iElement++)
				{
					FMT_ELEMENT * pElSrc = &pWinSrc->rgElements[iElement];
					FMT_ELEMENT * pElDst = &pWinDst->rgElements[iElement];

					ASSERT (!_tcsicmp (pElDst->szElement, pElSrc->szElement));

					pElDst->rgbText			= pElSrc->rgbText;
					pElDst->rgbBackground	= pElSrc->rgbBackground;
					pElDst->autoFore		= pElSrc->autoFore;
					pElDst->autoBack		= pElSrc->autoBack;
				}

			}
		}
	}
}


///// UpdateLogFonts
//
//	Regenerate all LOGFONT structures.  Used when responding to WM_FONTCHANGE.
///
void CFormatInfo::UpdateAllLogFonts ()
{
	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++)
	{
		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++ )
		{
			FMT_WINDOW * pWindow = &pWinGroup->rgWindows[iWindow];

			UpdateLogFont (pWindow);
		}
	}

}


///// UpdateAllAutoColors
//
//	Update Auto colors for all windows
///
void CFormatInfo::UpdateAllAutoColors ()
{
	for (int iGroup = 0; iGroup < m_nWinGroups; iGroup++)
	{
		for (int iWindow = 0; iWindow < m_pWinGroup[iGroup].nWindows; iWindow++)
		{
			UpdateAutoColors(&m_pWinGroup[iGroup].rgWindows[iWindow]);
		}
	}
}


///// operator=
//
//	This does the following:
//
//		1. Clears all existing Window/element information
//		2. Creates a copy of the the passed in fmtinfo.
//		3. Updates the color/font particulars from the registry.	
///
const CFormatInfo& CFormatInfo::operator= (
const FMT_WINGROUP& WinGroup 
) {

	Clear ();

	return *this += WinGroup;
}

const CFormatInfo& CFormatInfo::operator= (
const CFormatInfo& fmtInfo
) {
	Clear ();

	for ( int iWinGroup = 0; iWinGroup < fmtInfo.m_nWinGroups; iWinGroup++ )
		*this += fmtInfo.m_pWinGroup[iWinGroup];

	return *this;
}

///// operator+= - Add the given information
//
//	Same as operator=, but without clearing the existing information first.
///
const CFormatInfo& CFormatInfo::operator+= (const FMT_WINGROUP& WinGroupSrc)
{
	if (WinGroupSrc.nWindows == 0) {
		return *this;
		}

	// Extend the FMT_WINGROUP array by one.
	//
	FMT_WINGROUP * pWinGroupNew = new FMT_WINGROUP[m_nWinGroups + 1];
	if (m_pWinGroup != NULL)
	{
		memcpy (pWinGroupNew, m_pWinGroup, m_nWinGroups * sizeof FMT_WINGROUP);
		delete [] m_pWinGroup;
	}		
	m_pWinGroup = pWinGroupNew;

	// pWinGroupNew points to new, empty WINGROUP.
	//
	pWinGroupNew = &m_pWinGroup[m_nWinGroups++];

	pWinGroupNew->nWindows	= WinGroupSrc.nWindows;
	pWinGroupNew->bSingleGroup = WinGroupSrc.bSingleGroup;
	pWinGroupNew->szName	= NewString (WinGroupSrc.szName);
	pWinGroupNew->rgWindows	= new FMT_WINDOW[WinGroupSrc.nWindows];
	memcpy (pWinGroupNew->rgWindows, WinGroupSrc.rgWindows, WinGroupSrc.nWindows * sizeof FMT_WINDOW);

	// We now have a bitcopy of all the Window information.  We need to
	// make copies of all the "pointed-to" stuff.
	for (int iWindow = 0; iWindow < WinGroupSrc.nWindows; iWindow++)
	{
		FMT_WINDOW * pWinDst = &pWinGroupNew->rgWindows[iWindow];
		FMT_WINDOW * pWinSrc = &WinGroupSrc.rgWindows[iWindow];

		pWinDst->szWindow	= NewString (pWinSrc->szWindow);
		pWinDst->szRegEntry	= NewString (pWinSrc->szRegEntry);
		if (pWinSrc->szFontFace)
			pWinDst->szFontFace	= NewString (pWinSrc->szFontFace);
		else
			pWinDst->szFontFace	= NULL;

		// We want a copy of the LOGFONT, unless there is none to copy.  In that case,
		// we want to generate a LOGFONT from the other information.
		//
		if (pWinSrc->pLogFont != NULL)
		{
			pWinDst->pLogFont = new LOGFONT;
			*pWinDst->pLogFont = *pWinSrc->pLogFont;
		}
		else
		{
			UpdateLogFont (pWinDst);
		}

		// Finally, copy all the Element stuff
		//
		if (pWinSrc->nElements)
		{
			pWinDst->rgElements = new FMT_ELEMENT [pWinSrc->nElements];
			memcpy (pWinDst->rgElements, pWinSrc->rgElements, pWinSrc->nElements * sizeof (FMT_ELEMENT));
													 
			for ( int iElement = 0; iElement < pWinSrc->nElements; iElement++ )
			{
				pWinDst->rgElements[iElement].szElement = NewString (pWinSrc->rgElements[iElement].szElement);
			}
		}
	}

	return *this;
}


///// GetWindow - Gets FMT_WINDOW from name
//
///
FMT_WINDOW * CFormatInfo::GetWindow ( const _TCHAR * szWindow ) const
{
	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++ )
	{
		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++ )
		{
			FMT_WINDOW * pWindow = &pWinGroup->rgWindows[iWindow];

			if (!_tcsicmp ( szWindow, pWindow->szWindow ))
				return pWindow;
		}
	}

	return NULL;
}


///// operator GetElementList - Get Window from string
//
///
FMT_ELEMENT * CFormatInfo::GetElementList ( const TCHAR * szWindow ) const
{
	FMT_WINDOW * pWindow = GetWindow (szWindow);

	if (pWindow != NULL)
		return pWindow->rgElements;
	else
		return NULL;
}

///// SetForeColor - Set the foreground color of the current element
//
///
void CFormatInfo::SetForeColor ( UINT iGroup, UINT iWindow, UINT iElement, COLORREF rgb )
{
FMT_WINDOW * pWindow = &m_pWinGroup[iGroup].rgWindows[iWindow];
FMT_ELEMENT * pElement = &pWindow->rgElements[iElement];

	pWindow->bChanged = TRUE;

	if (rgb == CColorCombo::rgbAuto) {
		pElement->autoFore.bOn = TRUE;
		// ->rgbText will be set in UpdateAutoColors()
		}
	else {
		pElement->autoFore.bOn = FALSE;
		pElement->rgbText = rgb; 
		}
	UpdateAutoColors (pWindow);
}



///// SetBackColor - Set the background color of the current element
//
///
void CFormatInfo::SetBackColor ( UINT iGroup, UINT iWindow, UINT iElement, COLORREF rgb )
{
FMT_WINDOW * pWindow = &m_pWinGroup[iGroup].rgWindows[iWindow];
FMT_ELEMENT * pElement = &pWindow->rgElements[iElement];

	pWindow->bChanged = TRUE;

	if (rgb == CColorCombo::rgbAuto) {
		pElement->autoBack.bOn = TRUE;
		// ->rgbBackground will be set in UpdateAutoColors()
		}
	else {
		pElement->autoBack.bOn = FALSE;
		pElement->rgbBackground = rgb;
		}

	UpdateAutoColors (pWindow);
}

///// UpdateColor - update a color
//
// Return:
//  TRUE if the color was updated, FALSE if it's source is not 
//  up to date
//
BOOL UpdateColor(AUTO_COLOR & acDst, COLORREF & rgbDst, 
				 const AUTO_COLOR & acSrc, COLORREF rgbSrc, 
				 const AUTO_COLOR & acSrcRev, COLORREF rgbSrcRev)
{
	BOOL bRet = FALSE;
	if (acDst.bRev)
	{
		if (acSrcRev.bUpd)
		{
			rgbDst = rgbSrcRev;
			bRet = acDst.bUpd = TRUE;
		}
	}
	else
	{
		if (acSrc.bUpd)
		{
			rgbDst = rgbSrc;
			bRet = acDst.bUpd = TRUE;
		}
	}
	return bRet;
}

// define this to 1 to get trace messages from this function
#if 0
#define UACTRACE TRACE
#else
#define UACTRACE
#endif

///// UpdateAutoColors - Walk through current Window and update rgb fields in Auto elements
//
//	An Element's color comes from one of the following:
//
//	1.	User					- The user selects the color manually
//	2.	Auto System				- The color comes from a system color
//	3.	Auto Reference			- The color comes from another element...
//		3a.	Ref to type 1		- Source element is type 1, 2 or 3 above.
//		3b. Ref to type 2		
//		3c. Ref to type 3
//
// To properly update automatic colors, we make 1 to N passes, where
// N is the number of elements in the window.
//
// Pass 1.
//  Set .bUpd bit for all type 1, clear .bUpd for all others.
//	Update color from system and set .bUpd for all type 2s.
//
// Pass 2.
//	Update color and set .bUpd for all type 3s whose source element has .bUpd set.
//  Repeat until a full pass is made without updating any colors.
//  In the absence of a cycle, each pass updates at least one color.
//  
///
void CFormatInfo::UpdateAutoColors (FMT_WINDOW * pWindow)
{

	if (NULL == pWindow->rgElements || 0 >= pWindow->nElements)
		return;

	FMT_ELEMENT * pElement;

	for (pElement = &pWindow->rgElements[0]; pElement < &pWindow->rgElements[pWindow->nElements]; pElement++)
	{
		// Foreground

		pElement->autoFore.bUpd = !pElement->autoFore.bOn;
		
		// Update system colors.
		if (pElement->autoFore.bOn && pElement->autoFore.bSys)
		{
			pElement->rgbText = GetSysColor(pElement->autoFore.index);
			pElement->autoFore.bUpd = TRUE;
		}

		// Background

		pElement->autoBack.bUpd = !pElement->autoBack.bOn;

		// Update system colors.
		if (pElement->autoBack.bOn && pElement->autoBack.bSys)
		{
			pElement->rgbBackground = GetSysColor(pElement->autoBack.index);
			pElement->autoBack.bUpd = TRUE;
		}
	}

	int cPasses;	
	BOOL bDoItAgain = TRUE;
	for (cPasses = 0; bDoItAgain && (cPasses < pWindow->nElements); cPasses++)
	{
		bDoItAgain = FALSE;

		for (	pElement = &pWindow->rgElements[0];
				pElement < &pWindow->rgElements[pWindow->nElements];
				pElement++)
		{
			FMT_ELEMENT * pElSource;

			// Foreground
			//
			if (!pElement->autoFore.bUpd)
			{
				if (pElement->autoFore.bSrc)
					pElSource = &m_pWinGroup[0].rgWindows[0].rgElements[pElement->autoFore.index];
				else		
					pElSource = &pWindow->rgElements[pElement->autoFore.index];

				bDoItAgain = !UpdateColor(
					pElement->autoFore, pElement->rgbText, 
					pElSource->autoFore, pElSource->rgbText,
					pElSource->autoBack, pElSource->rgbBackground);
			}

			// Background
			//
			if (!pElement->autoBack.bUpd)
			{
				if (pElement->autoBack.bSrc)
					pElSource = &m_pWinGroup[0].rgWindows[0].rgElements[pElement->autoBack.index];
				else		
					pElSource = &pWindow->rgElements[pElement->autoBack.index];

				bDoItAgain = !UpdateColor(
					pElement->autoBack, pElement->rgbBackground,
					pElSource->autoBack, pElSource->rgbBackground,
					pElSource->autoFore, pElSource->rgbText);
			}
		}
	}

	UACTRACE( "CFormatInfo::UpdateAutoColors: %s is %sup to date after pass %d.\n", 
		pWindow->szRegEntry,
		bDoItAgain ? "not " : "", 
		cPasses);

// FUTURE: HACK ALERT: InfoViewer triggers this assert and needs to fix it.
ASSERT(!bDoItAgain || (0 == _tcscmp(pWindow->szRegEntry, _T("InfoViewer Topic Window"))));
//  When InfoViewer is fixed, use this ASSERT
//	ASSERT(!bDoItAgain); // table has a cycle or bad entries
}


///// Commit () - Copy back to package's original CFormatInfo
//
///
BOOL CFormatInfo::Commit () const
{
	if (IsDirty()) {
		ASSERT (m_pFormatInfoFromPackage != NULL);
		m_pFormatInfoFromPackage->Update (*this);
		SaveToRegistry ();
		m_pPackage->OnFormatChanged ();
		return TRUE;
		}
	else
		return FALSE;
}


///// IsDirty () - Have any changes been made?
//
//	The changed state is kept on a per-Window basis.  When you need to know whether a change
//	has been made at all, you call this.
//
///
BOOL CFormatInfo::IsDirty () const
{
	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++ )
	{
		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++ )
		{
			if (pWinGroup->rgWindows[iWindow].bChanged)
				return TRUE;
		}
	}
	
	return FALSE;
}


///// Clean () - Mark all Windows as unchanged
//
///
void CFormatInfo::Clean ()
{
	for ( int iWinGroup = 0; iWinGroup < m_nWinGroups; iWinGroup++ )
	{
		FMT_WINGROUP * pWinGroup = &m_pWinGroup[iWinGroup];

		for ( int iWindow = 0; iWindow < pWinGroup->nWindows; iWindow++ )
		{
			pWinGroup->rgWindows[iWindow].bChanged = FALSE;
			// HACK!  The PRJ package sometimes hands you a bolded font.
			// That is not what we want.
			if (pWinGroup->rgWindows[iWindow].pLogFont)
				pWinGroup->rgWindows[iWindow].pLogFont->lfWeight = FW_NORMAL;
		}
	}
}


///// GetLogFont () - Find a LOGFONT structure matching the name/size combo.
///
//	** Font sizes and LOGFONT and TEXTMETRIC **
//
//		The TEXTMETRIC member tmHeight describes the height of the character "cell"
//		in device units (i.e. pixels). This cell includes the character below the
//		"baseline" (the descender, like the tail of 'q'), as well as room above the
//		character for accents and other diactrical marks.  This latter area is called
//		"internal leading" (pronounced ledding).
//
//		The "point" size of a character differs in two ways from tmHeight: 1) Internal
//		leading is *not* included, and 2) it is expressed in units of 1/72 of an inch.
//
//		The LOGFONT member lfHeight is an input value to the font API.  When positive, it
//		expresses the same type of value as tmHeight.  When lfHeight is negative, the
//		absolute value of lfHeight is the size of the character not including the internal
//		leading.
//		
///
int CFormatInfo::GetLogFont (
LOGFONTSEARCH * plfs
) {
	if (plfs->szFontFace == NULL)
		return 0;

	CDC * pDC = theApp.m_pMainWnd->GetDC();

	// First, let's try to find an exact match for the face/size pair.
	if (!EnumFontFamilies (pDC->m_hDC, plfs->szFontFace, (FONTENUMPROC)CFormatInfo::SearchCallBack, (LPARAM)plfs)) {
		theApp.m_pMainWnd->ReleaseDC (pDC);
		return 1;
		}

	//
	// That failed, so now let's let the system find a close match
	//
	plfs->LogFont.lfHeight		= -MulDiv (plfs->nFontSize, plfs->nPixPerInchY, 72);
	plfs->LogFont.lfWidth		= 0;
	plfs->LogFont.lfEscapement	= 0;
	plfs->LogFont.lfOrientation = 0;
	plfs->LogFont.lfWeight		= 0;
	plfs->LogFont.lfItalic		= FALSE;
	plfs->LogFont.lfUnderline	= FALSE;
	plfs->LogFont.lfStrikeOut	= FALSE;
	plfs->LogFont.lfCharSet		= plfs->nCharSet;
	plfs->LogFont.lfOutPrecision= OUT_DEFAULT_PRECIS;
	plfs->LogFont.lfClipPrecision=CLIP_DEFAULT_PRECIS;
	plfs->LogFont.lfQuality		= DEFAULT_QUALITY;
	plfs->LogFont.lfPitchAndFamily= DEFAULT_PITCH | FF_DONTCARE;
	_tcsncpy (plfs->LogFont.lfFaceName, plfs->szFontFace, sizeof plfs->LogFont.lfFaceName);

	CFont font;
	font.CreateFontIndirect ( &plfs->LogFont );

	CFont * pFontPrev = pDC->SelectObject ( &font );
	ASSERT (pFontPrev );

	TEXTMETRIC tm;
	VERIFY (pDC->GetTextMetrics ( &tm )); 

	plfs->LogFont.lfHeight		= -(tm.tmHeight - tm.tmInternalLeading);
	plfs->LogFont.lfWidth		= tm.tmAveCharWidth;
	plfs->LogFont.lfWeight		= tm.tmWeight;
	plfs->LogFont.lfCharSet		= tm.tmCharSet;
	// Yes, this is right - the constant TMPF_FIXED_PITCH is the opposite of
	// what the name implies.
	plfs->LogFont.lfPitchAndFamily = ((tm.tmPitchAndFamily & TMPF_FIXED_PITCH) ? VARIABLE_PITCH : FIXED_PITCH)
									 | (tm.tmPitchAndFamily & 0xF0);
	pDC->GetTextFace (sizeof plfs->LogFont.lfFaceName, plfs->LogFont.lfFaceName);

	pDC->SelectObject ( pFontPrev );
	font.DeleteObject ();

	theApp.m_pMainWnd->ReleaseDC (pDC);

	// This stuff may be different than what we asked for.  The caller should check
	// for the negative return and update its corresponding values.
	if (_tcsicmp (plfs->LogFont.lfFaceName, plfs->szFontFace))
		plfs->szFontFace	= plfs->LogFont.lfFaceName;
	plfs->nFontSize		= (UCHAR)MulDiv(tm.tmHeight - tm.tmInternalLeading, 72, plfs->nPixPerInchY);
	plfs->nCharSet		= tm.tmCharSet;
	plfs->bMonospace	= !(tm.tmPitchAndFamily & TMPF_FIXED_PITCH);
	plfs->bTrueType		= tm.tmPitchAndFamily & TMPF_TRUETYPE;
	return -1;
}

void CFormatInfo::UpdateLogFont (FMT_WINDOW * pWindow)
{
LOGFONTSEARCH lfs;

	lfs.szFontFace	= pWindow->szFontFace;
	lfs.nFontSize	= (UCHAR)pWindow->nFontSize;
	lfs.nCharSet	= DEFAULT_CHARSET;
	lfs.nPixPerInchY = m_nPixPerInchY;
	lfs.bMonospace	= pWindow->bMonospace;

	switch (GetLogFont (&lfs))
	{
		case 0:
			if (pWindow->pLogFont != NULL)
				delete pWindow->pLogFont;
			pWindow->pLogFont = NULL;
			break;

		case -1:
			// Yes, this compares pointer values, but we trust GetLogFont
			// to change lfs.szFontFace only if the name actually changes.
			if (lfs.szFontFace != pWindow->szFontFace)
			{
				delete [] pWindow->szFontFace;
				pWindow->szFontFace = NewString (lfs.szFontFace);
			}

			pWindow->nFontSize = lfs.nFontSize;
			ASSERT (!pWindow->bMonospace || lfs.bMonospace);
					
		case 1:
			pWindow->bChanged = TRUE;
			if (pWindow->pLogFont == NULL)
				pWindow->pLogFont = new LOGFONT;
			*pWindow->pLogFont = lfs.LogFont;
			break;

	}
}


int CALLBACK CFormatInfo::SearchCallBack(
CONST ENUMLOGFONT * pEnumLogFont,
CONST NEWTEXTMETRIC *	pTextMetric,
int	fontType,
LPARAM	lParam )
{
LOGFONTSEARCH * plfs = (LOGFONTSEARCH * )lParam;

	if (!(fontType & TRUETYPE_FONTTYPE)) {
		//DWORD height = 	(fontType & RASTER_FONTTYPE) ? pTextMetric->tmHeight - pTextMetric->tmInternalLeading : pEnumLogFont->elfLogFont.lfHeight;
		DWORD height = 	pTextMetric->tmHeight - pTextMetric->tmInternalLeading;
		DWORD cPoints = MulDiv(height, 72, plfs->nPixPerInchY);

		if (cPoints != plfs->nFontSize)
			return 1;
		}
	else {
		}

	// Before it can be a match, the character set has to be right
	//
	if (plfs->nCharSet == DEFAULT_CHARSET || pTextMetric->tmCharSet == OEM_CHARSET)
	{
		plfs->nCharSet = pTextMetric->tmCharSet;
	}
	else
	if (plfs->nCharSet != pTextMetric->tmCharSet)
		return 1;

	//
	// Match!
	//
	memcpy ( &plfs->LogFont, &pEnumLogFont->elfLogFont, sizeof (LOGFONT));

	if (fontType & TRUETYPE_FONTTYPE) {
		// Using a negative value in the lfHeight member causes GDI to use the value
		// as the height of the character glyphs, not the height of the character cell.
		plfs->LogFont.lfHeight = -MulDiv (plfs->nFontSize, plfs->nPixPerInchY, 72);
		plfs->LogFont.lfWidth = 0;		
		plfs->bTrueType = TRUE;
		}
	else 
		plfs->bTrueType = FALSE;

	return 0;
}


///// MewString - duplicate a string, using operator new
//
///
_TCHAR * NewString (const _TCHAR * sz)
{
	_TCHAR * szCopy = new _TCHAR[_tcslen(sz) + 1];
	_tcscpy (szCopy, sz);
	return szCopy;
}

//////////////////////////////////////////////////////////////////////////////
//						class CFmtIterator									//
//						class CFmtGroupIterator								//
//						class CFmtWindowIterator							//
//						class CFmtElementIterator							//
//																			//
//	Iteration classes for CFormatInfo.  Each class iterates over one type.	//
//	Normally, the domain is the array of <type> attached to the current		//
//  <basetype>, where <basetype> is the type of the base class.				//
//	Iteration can also be done "linearly", meaning that all instances of	//
//	<type> are reached in a "flat addressing" fashion.						//
//																			//
//////////////////////////////////////////////////////////////////////////////

///// Base class - handles array of FormatInfo
//
///
CFmtIterator::CFmtIterator (const CObArray& rgFmtInfo)
:
m_rgFmtInfo (rgFmtInfo),
m_iFmtInfo  (0)
{}


CFormatInfo * CFmtIterator::Get ()
{
	CFormatInfo * pFmtInfo = Peek ();
	
	if (pFmtInfo)
		Inc();

	return pFmtInfo;
}


CFormatInfo * CFmtIterator::Peek () const
{
	if (m_iFmtInfo >= m_rgFmtInfo.GetSize())
		return NULL;

	return (CFormatInfo *)m_rgFmtInfo[m_iFmtInfo];
}


///// First derived class - handles array of groups within a CFormatInfo
//
///
CFmtGroupIterator::CFmtGroupIterator (const CObArray& rgFmtInfo)
:
CFmtIterator (rgFmtInfo),
m_iGroup (0)
{}


FMT_WINGROUP * CFmtGroupIterator::Get ()
{
	FMT_WINGROUP * pGroup = Peek();

	if (pGroup)
		Inc();

	return pGroup;
}


FMT_WINGROUP * CFmtGroupIterator::Peek () const
{
	CFormatInfo * pFI = CFmtIterator::Peek();

	if (pFI == NULL)
		return NULL;

	if (m_iGroup >= pFI->m_nWinGroups)
		return NULL;

	return &pFI->m_pWinGroup[m_iGroup];
}


FMT_WINGROUP *  CFmtGroupIterator::GetLinear ()
{
	FMT_WINGROUP * pGroup = Get();

	if (pGroup)
		return pGroup;

	// Current FormatInfo is exhausted, try to move to next
	if (CFmtIterator::Get() && CFmtIterator::Peek())
	{
		m_iGroup = 0;
		return Get();
	}
	else
		return NULL;
}

/////
//
// Like Peek(), except that out-of-bounds indices are fixed up first
///
FMT_WINGROUP * CFmtGroupIterator::PeekLinear ()
{
	CFormatInfo * pFI = CFmtIterator::Peek();

	if (pFI == NULL)
		return NULL;

	if (m_iGroup >= pFI->m_nWinGroups)
	{
		(void)CFmtIterator::Get();
		if (NULL == (pFI = CFmtIterator::Peek()))
			return NULL;
		m_iGroup = 0;
	}

	return &pFI->m_pWinGroup[m_iGroup];
}


void	CFmtGroupIterator::SetLinear (UINT iGroupLinear)
{
	// Translate the linear iGroup argument into a fmtinfo/igroup pair.
	//
	m_iGroup = iGroupLinear;
	for (m_iFmtInfo = 0; m_iFmtInfo < m_rgFmtInfo.GetSize(); m_iFmtInfo++)
	{
		CFormatInfo * pFmtInfo = (CFormatInfo *)m_rgFmtInfo[m_iFmtInfo];

		if (m_iGroup >= pFmtInfo->m_nWinGroups)
			m_iGroup -= pFmtInfo->m_nWinGroups;
		else
			return;	// We're done!
	}
}


void	CFmtGroupIterator::Set (FMT_WINGROUP * pGroup)
{
	// Find this group, then set iterator values
	for (m_iFmtInfo = 0; m_iFmtInfo < m_rgFmtInfo.GetSize (); m_iFmtInfo++)
		for (m_iGroup = 0; m_iGroup < ((CFormatInfo *)m_rgFmtInfo[m_iFmtInfo])->m_nWinGroups; m_iGroup++)
			if (pGroup == &((CFormatInfo *)m_rgFmtInfo[m_iFmtInfo])->m_pWinGroup[m_iGroup])
				return;

	ASSERT (FALSE);
}


///// Second derived class - handles array of Windows within a group
//
///
CFmtWindowIterator::CFmtWindowIterator (const CObArray& rgFmtInfo)
:
CFmtGroupIterator (rgFmtInfo),
m_iWindow (0)
{
}


FMT_WINDOW * CFmtWindowIterator::Peek () const
{
	FMT_WINGROUP * pGroup = CFmtGroupIterator::Peek();

	if (pGroup == NULL)
		return NULL;

	if (m_iWindow >= pGroup->nWindows)
		return NULL;

	return &pGroup->rgWindows[m_iWindow];
}


FMT_WINDOW * CFmtWindowIterator::Get ()
{
	FMT_WINDOW * pWindow = Peek();

	if (pWindow)
		Inc();

	return pWindow;
}


FMT_WINDOW * CFmtWindowIterator::GetLinear ()
{
	FMT_WINDOW * pWindow = Get();

	if (pWindow)
		return pWindow;

	// Current WINGROUP is exhausted, try to move to next
	if (CFmtGroupIterator::GetLinear() && CFmtGroupIterator::PeekLinear())
	{
		m_iWindow = 0;
		return Get();
	}
	else
		return NULL;
}


void CFmtWindowIterator::SetLinear (UINT iWinLinear)
{

	// Translate the linear nWindow argument into a fmtinfo/igroup/iWindow set,
	//
	m_iWindow = iWinLinear;
	for (m_iFmtInfo = 0; m_iFmtInfo < m_rgFmtInfo.GetSize(); m_iFmtInfo++)
	{
		CFormatInfo * pFmtInfo = (CFormatInfo *)m_rgFmtInfo[m_iFmtInfo];

		for (	m_iGroup = 0;
				m_iGroup < pFmtInfo->m_nWinGroups;
				m_iGroup++ )
		{
			if (m_iWindow >= pFmtInfo->m_pWinGroup[m_iGroup].nWindows)
				m_iWindow -= pFmtInfo->m_pWinGroup[m_iGroup].nWindows;
			else
				return;	// We're done!
		}
	}
}


void	CFmtWindowIterator::Set (FMT_WINDOW * pWindow)
{
	// Find this group, then set iterator values
	for (m_iFmtInfo = 0; m_iFmtInfo < m_rgFmtInfo.GetSize (); m_iFmtInfo++)
		for (m_iGroup = 0; m_iGroup < ((CFormatInfo *)m_rgFmtInfo[m_iFmtInfo])->m_nWinGroups; m_iGroup++)
			for (m_iWindow = 0; m_iWindow < ((CFormatInfo *)m_rgFmtInfo[m_iFmtInfo])->m_pWinGroup[m_iGroup].nWindows; m_iWindow++)
				if (pWindow == &((CFormatInfo *)m_rgFmtInfo[m_iFmtInfo])->m_pWinGroup[m_iGroup].rgWindows[m_iWindow])
					return;

	ASSERT (FALSE);
}


FMT_WINDOW * CFmtWindowIterator::PeekLinear ()
{
	FMT_WINGROUP * pGroup = CFmtGroupIterator::PeekLinear();

	if (pGroup == NULL)
		return NULL;

	if (m_iWindow >= pGroup->nWindows)
	{
		(void)CFmtGroupIterator::Get ();
		if (NULL == (pGroup = CFmtGroupIterator::PeekLinear()))
			return NULL;
		m_iWindow = 0;
	}

	return &pGroup->rgWindows[m_iWindow];
}


///// Third derived class - handles array of Elements within a Window
//
///
CFmtElementIterator::CFmtElementIterator (const CObArray& rgFmtInfo)
:
CFmtWindowIterator (rgFmtInfo),
m_iElement (0)
{}


FMT_ELEMENT * CFmtElementIterator::Peek () const
{
	FMT_WINDOW * pWindow = CFmtWindowIterator::Peek();

	if (pWindow == NULL)
		return NULL;

	if (m_iElement >= pWindow->nElements)
		return NULL;

	return &pWindow->rgElements[m_iElement];
}


FMT_ELEMENT * CFmtElementIterator::Get ()
{
	FMT_ELEMENT * pElement = Peek ();

	if (pElement)
		Inc();

	return pElement;
}


///// CFmtElementIterator Linear functions
//
// The normal Get() function retrieves ELEMENTS in the current window, then stops.
// GetLinear() retrieves all elements in linear fashion.
//
///
FMT_ELEMENT * CFmtElementIterator::GetLinear ()
{
	do
	{

		FMT_ELEMENT * pElement = Get();

		if (pElement)
			return pElement;

		// Current WINDOW is exhausted, try to move to next
		if (CFmtWindowIterator::GetLinear() && CFmtWindowIterator::PeekLinear())
		{
			m_iElement = 0;
		}
		else
			return NULL;

	} while (TRUE);
		
}

void CFmtElementIterator::SetLinear (UINT iElementLinear)
{

	// Translate the linear nWindow argument into a fmtinfo/igroup/iWindow set,
	//
	m_iElement = iElementLinear;
	for (m_iFmtInfo = 0; m_iFmtInfo < m_rgFmtInfo.GetSize(); m_iFmtInfo++)
	{
		CFormatInfo * pFmtInfo = (CFormatInfo *)m_rgFmtInfo[m_iFmtInfo];

		for (	m_iGroup = 0;
				m_iGroup < pFmtInfo->m_nWinGroups;
				m_iGroup++ )
		{
			for (	m_iWindow = 0;
					m_iWindow < pFmtInfo->m_pWinGroup[m_iGroup].nWindows;
					m_iWindow++ )
			{
			
				if (m_iElement >= pFmtInfo->m_pWinGroup[m_iGroup].rgWindows[m_iWindow].nElements)
					m_iElement -= pFmtInfo->m_pWinGroup[m_iGroup].rgWindows[m_iWindow].nElements;
				else
					return;	// We're done!
			}
		}
	}
}

FMT_ELEMENT * CFmtElementIterator::PeekLinear ()
{
	FMT_WINDOW * pWindow = CFmtWindowIterator::PeekLinear();

	if (pWindow == NULL)
		return NULL;

	while (m_iElement >= pWindow->nElements)
	{
		(void)CFmtWindowIterator::Get();
		if (NULL == (pWindow = CFmtWindowIterator::PeekLinear()))
			return NULL;
		m_iElement = 0;
	}

	return &pWindow->rgElements[m_iElement];
}


//////////////////////////////////////////////////////////////////////////////
//							class CElList									//
//																			//
// A list of unique element names.  Uniqueness is enforced.  Will also		//
// iterate a given name - i.e. will sequentially find all elements with		//
// the given name.															//
//																			//
//////////////////////////////////////////////////////////////////////////////

CElList::CElList (UINT inc)
: m_inc(inc)
{
	m_rgStrings.SetSize(0, inc);
}

CElList::~CElList ()
{
	Clear ();
}

BOOL CElList::AddString (const CString& str)
{
	for (int iString = 0; iString < m_rgStrings.GetSize(); iString++)
	{
		if ((_TCHAR *)m_rgStrings[iString] == str)
			return FALSE;
	}

	m_rgStrings.Add (NewString (str));

	return TRUE;
}

///// CElList Iteration functions
//
// This is a lot cleaner if the passed-in iterator is allowed to come
// back one past the found item.  However, some callers really need the
// iterator to point to the returned ELEMENT...
///
FMT_ELEMENT * CElList::GetFirst (_TCHAR * szName, CFmtElementIterator& it, int iFormat, int iGroup)
{
	it.SetLinear (0);

	m_strSearch = szName;

	it.Dec ();	// HACK!

	return GetNext (it, iFormat, iGroup);
}


FMT_ELEMENT * CElList::GetFirst (UINT iEl, CFmtElementIterator& it, int iFormat, int iGroup)
{
	return GetFirst ((_TCHAR *)m_rgStrings[iEl], it, iFormat, iGroup);
}


FMT_ELEMENT * CElList::GetNext (CFmtElementIterator& it, int iFormat, int iGroup)
{
	FMT_ELEMENT * pElement;
	do
	{
		it.Inc();

		if (pElement = it.PeekLinear())
		{
			if (!_tcsicmp (m_strSearch, pElement->szElement)
				&& ( (iFormat == -1)
					|| (	(it.CFmtIterator::GetIndex() == (UINT)iFormat)
						&&	(it.CFmtGroupIterator::GetIndex() == (UINT)iGroup) )))
				return pElement;
		}
		else
			break;
	} while (TRUE);

	return NULL;
}


///// IsFore/BackColorUnique
//
//	Is the color in each of the elements using the given name the same?
//
//  'rgb' is a return value.	If IFCTS() returns TRUE, rgb is set to the color in question.
//								If IFCTS() returns FALSE, rgb is undefined.
///
BOOL CElList::IsForeColorTheSame (UINT iEl, CFmtElementIterator& itEl, int iFormat, int iGroup, COLORREF& rgb)
{
	FMT_ELEMENT * pElement = GetFirst (iEl, itEl, iFormat, iGroup);
	ASSERT (pElement);
	FMT_ELEMENT * pElementNext;

	do
	{
		pElementNext = GetNext (itEl, iFormat, iGroup);

		if (pElementNext && ((pElement->rgbText != pElementNext->rgbText) || (pElement->autoFore.bOn != pElementNext->autoFore.bOn)))
				return FALSE;

		rgb = pElement->autoFore.bOn ? CColorCombo::rgbAuto : pElement->rgbText;

	} while (pElement = pElementNext);

	return TRUE;
}

BOOL CElList::IsBackColorTheSame (UINT iEl, CFmtElementIterator& itEl, int iFormat, int iGroup, COLORREF& rgb)
{
	FMT_ELEMENT * pElement = GetFirst (iEl, itEl, iFormat, iGroup);
	ASSERT (pElement);
	FMT_ELEMENT * pElementNext;

	do
	{

		pElementNext = GetNext (itEl, iFormat, iGroup);

		if (pElementNext && ((pElement->rgbBackground != pElementNext->rgbBackground) || (pElement->autoBack.bOn != pElementNext->autoBack.bOn)))
				return FALSE;

		rgb = pElement->autoBack.bOn ? CColorCombo::rgbAuto : pElement->rgbBackground;

	} while (pElement = pElementNext);

	return TRUE;
}


/////
//
///
void CElList::Fill (CListBox& lbox) const
{
	for (int iString = 0; iString < m_rgStrings.GetSize(); iString++)
	{
		lbox.AddString ((_TCHAR *)m_rgStrings[iString]);
	}
}



void CElList::Clear ()
{
	for (int iString = 0; iString < m_rgStrings.GetSize(); iString++)
	{
		delete [] m_rgStrings[iString];
	}

	m_rgStrings.RemoveAll ();
}

//////////////////////////////////////////////////////////////////////////////
//							class CWinList									//
//																			//
//	A list of FMT_WINDOW and FMT_WINGROUP.  Used for the list of windows	//
//	under "Category" in the Fonts dialogs.									//
//																			//
//////////////////////////////////////////////////////////////////////////////

CWinList::CWinList (UINT inc)
{
	m_rgGroups.SetSize (0, inc);
	m_rgWindows.SetSize (0, inc);
}

CWinList::~CWinList ()
{
}

void CWinList::Add (FMT_WINGROUP * pGroup)
{
	if (pGroup->nWindows == 1)
	{
		if (pGroup->bSingleGroup)
			m_rgGroups.Add (pGroup);
		else
			m_rgWindows.Add (pGroup->rgWindows);
	}
	else
	{
		m_rgGroups.Add (pGroup);

		for (int iWin = 0; iWin < pGroup->nWindows; iWin++)
		{
			m_rgWindows.Add (&pGroup->rgWindows[iWin]);
		}	
	}

}


void CWinList::Fill (CListBox& lbox) const
{
	CString strAllWindows;
	strAllWindows.LoadString (IDS_ALLWINDOWS);
	lbox.AddString (strAllWindows);
	
	for (int iGroup = 0; iGroup < m_rgGroups.GetSize(); iGroup++)
		lbox.AddString (((FMT_WINGROUP *)(m_rgGroups[iGroup]))->szName);

	for (int iWindow = 0; iWindow < m_rgWindows.GetSize(); iWindow++)
		lbox.AddString (((FMT_WINDOW *)m_rgWindows[iWindow])->szWindow);
}

BOOL CWinList::GetName (int index, CString& strName) const
{
	// The index value is the item ID from the listbox.  So, 0 == "All Windows",
	// 1 -> m_rgGroups.GetSize () are group names, and the rest are window names.
	if (index == 0)
	{
		strName.LoadString (IDS_ALLWINDOWS);
		return TRUE;
	}
	else
	if (index > m_rgGroups.GetSize ())
	{
		index -= m_rgGroups.GetSize () + 1;
		ASSERT (index < m_rgWindows.GetSize ());
		strName = ((FMT_WINDOW *)m_rgWindows[index])->szWindow;
		return FALSE;
	}
	else
	{
		strName = ((FMT_WINGROUP *)m_rgGroups[index - 1])->szName;
		return TRUE;
	}
}

BOOL CWinList::GetPtr (int index, void * &p) const
{
	if (index == 0)
	{
		return TRUE;
	}
	else
	if (index > m_rgGroups.GetSize ())
	{
		index -= m_rgGroups.GetSize () + 1;
		ASSERT (index < m_rgWindows.GetSize ());
		p = m_rgWindows[index];
		return FALSE;
	}
	else
	{
		p = m_rgGroups[index - 1];
		return TRUE;
	}
}

int CWinList::FirstWindowIndex () const
{
	return m_rgGroups.GetSize() + 1;
}

//////////////////////////////////////////////////////////////////////////////
//							class CFCDialogState							//
//																			//
//	This class acts as an intermediary between a CFontColorDlg and the		//
//	CFormatInfo objects underlying it.  It locates and manages the data		//
//	from the packages, it keeps track of the state of the dialog and		//
//  propogates changes to the underlying data.  It also propogates state	//
//	changes in one part of the dialog to the rest of the dialog.			//
//																			//
//////////////////////////////////////////////////////////////////////////////

CFCDialogState::CFCDialogState ( CFontColorDlg * pDialog )
:
m_pDialog(pDialog),
m_state (PreDialog),
m_nFmtInfoCur (0),
m_nWinGroupCur (0),
m_nWindowCur (0),
m_nElementCur (0)
{
	CFormatInfo * pFormatInfo;
	CPackage * pPackage;
	POSITION pos = theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
		if (pPackage->m_flags & PKS_FORMAT)
		{
			pFormatInfo = new CFormatInfo (pPackage);
			if (pFormatInfo->GetFormatInfo (pPackage))
			{
				pFormatInfo->Clean ();
				m_rgFmtInfo.Add (pFormatInfo);
			}
			else
			{
				ASSERT(0); // the package lied! PKS_FORMAT, but GetFormatInfo returned NULL
				delete pFormatInfo;
			}
		}
	}
}

CFCDialogState::~CFCDialogState ()
{
int cFmtInfo = m_rgFmtInfo.GetSize();

	for (int i = 0; i < cFmtInfo; i++)
		delete m_rgFmtInfo[i];

	// Let CObArray destructor do the rest
}


void CFCDialogState::InitDialog ()
{
	// First, we fill the dialog's m_lstWindows combo box with the names of
	// all the windows.
#if 0
	int nGroups = 1;
	CString strAllWindows;
	strAllWindows.LoadString (IDS_ALLWINDOWS);
	m_pDialog->m_lstWindows.AddString (strAllWindows);

	FMT_WINGROUP * pGroup;
	CFmtGroupIterator  itGroup (m_rgFmtInfo);
	while (pGroup = itGroup.GetLinear())
	{
		m_pDialog->m_lstWindows.AddString (pGroup->szName);
		nGroups++;
	}
	m_pDialog->m_lstWindows.SetFirstWindowIndex (nGroups);

	CFmtWindowIterator itWin (m_rgFmtInfo);
	FMT_WINDOW * pWindow;
	while (pWindow = itWin.GetLinear())
	{
		//if (!pWindow->bSingleton)
			m_pDialog->m_lstWindows.AddString (pWindow->szWindow);
	}
#endif
	FMT_WINGROUP * pGroup;
	CFmtGroupIterator  itGroup (m_rgFmtInfo);
	while (pGroup = itGroup.GetLinear())
	{
		m_winList.Add (pGroup);
	}

	m_pDialog->m_lstWindows.SetWinList (&m_winList);

	m_winList.Fill (m_pDialog->m_lstWindows);
	
	m_pDialog->m_lstWindows.SetCurSel (0);

	m_pDialog->OnChangeWindow ();

	m_state = SelAll;
}


///// CFCDialogState::SetCurrentWindow ()
//
//	"iWindow" means the i'th element in the Window combo has been selected.  This function
//	translates that into a window reference/state-change as needed, and propogates the change
//	to the rest of the dialog.
//
///
void CFCDialogState::SetCurrentWindow (int iWindow)
{
	// First we decide whether the user has selected an individual
	// window, a group of windows, or ALL windows.
	void * ptr;
	BOOL bIsGroup = m_winList.GetPtr (iWindow, ptr);

	m_iCurWin = iWindow;
	m_nElementCur	= 0;

	m_elList.Clear ();

	if (!bIsGroup)
	{	// This is the single window case.
		//
		m_state = SelWindow;
	

		CFmtElementIterator itEl (m_rgFmtInfo);
		itEl.CFmtWindowIterator::Set ((FMT_WINDOW *)ptr);

		m_nFmtInfoCur	= itEl.CFmtIterator::GetIndex();
		m_nWinGroupCur	= itEl.CFmtGroupIterator::GetIndex();
		m_nWindowCur	= itEl.CFmtWindowIterator::GetIndex();

		// Now we refill the Elements listbox
		//
		FMT_ELEMENT * pElement;
		while (pElement = itEl.Get())
		{
			m_elList.AddString (pElement->szElement);
		}
	}
	else
	{
		if ( iWindow > 0 )
		{	// This is the WinGroup case
			m_state = SelGroup;

			CFmtElementIterator itEl (m_rgFmtInfo);
			itEl.CFmtGroupIterator::Set ((FMT_WINGROUP *)ptr);

			m_nFmtInfoCur	= itEl.CFmtIterator::GetIndex();
			m_nWinGroupCur	= itEl.CFmtGroupIterator::GetIndex();
			LPCTSTR pszGroupName = ((FMT_WINGROUP *)ptr)->szName;
			m_nWindowCur	= (UINT)-1;

			// Now we refill the Elements listbox
			//
			FMT_ELEMENT * pElement;
			while (pElement = itEl.GetLinear())
			{
				// Is this element in the current group?
				FMT_WINGROUP *pwgCur = itEl.CFmtGroupIterator::Peek();
				ASSERT(pwgCur);
				if (0 != _tcscmp(pszGroupName,pwgCur->szName))
					continue;

				m_elList.AddString (pElement->szElement);

			}
		
		}
		else
		{	// This is the All Windows case
			ASSERT (iWindow == 0);
			m_state = SelAll;
			CFmtElementIterator itEl (m_rgFmtInfo);

			m_nFmtInfoCur	= 0;
			m_nWinGroupCur	= 0;
			m_nWindowCur	= (UINT)-1;

			// Now we refill the Elements listbox
			//
			FMT_ELEMENT * pElement;
			while (pElement = itEl.GetLinear())
			{
				m_elList.AddString (pElement->szElement);
			}
		}
		
	}

	if (m_elList.GetSize())
	{
		m_pDialog->m_lstElements.ResetContent();
		m_elList.Fill (m_pDialog->m_lstElements);
		m_pDialog->m_lstElements.EnableWindow (m_benElements = TRUE);
		m_pDialog->m_cmbBackColor.EnableWindow (m_benBackColor = TRUE);
		m_pDialog->m_cmbForeColor.EnableWindow (m_benForeColor = TRUE);
		m_pDialog->m_lstElements.SetCurSel (0);
		m_pDialog->OnChangeElement ();
	}
	else
	{
		m_pDialog->m_lstElements.EnableWindow (m_benElements = FALSE);
		m_pDialog->m_cmbBackColor.EnableWindow (m_benBackColor = FALSE);
		m_pDialog->m_cmbForeColor.EnableWindow (m_benForeColor = FALSE);
		m_pDialog->m_lstElements.ResetContent();

	}


	// Now decide whether proportional fonts are enabled in the new window, and
	// fill the font list if it needs it.

	m_pDialog->m_cmbFontName.Enumerate ( WindowWalk (FontPitch) == PitchProportional );

	switch (WindowWalk (FontEquality))
	{
		case SameFont:
			FMT_WINDOW * pWinCur;
			int iCurFont;
			pWinCur = GetWinCur (FALSE, TRUE);
			ASSERT (pWinCur->szFontFace[0]);

			// Now set the font name and size 
			m_pDialog->m_cmbFontName.EnableWindow ( TRUE );
			iCurFont = m_pDialog->m_cmbFontName.FindStringExact (0, pWinCur->szFontFace);
			if (iCurFont < 0)
			{
				// Bug Fix for Orion 96 Bug 19746
				goto diffont ;
			}

			m_pDialog->m_cmbFontName.SetCurSel ( iCurFont );

			m_pDialog->RegenSizes (FALSE);
			m_pDialog->m_cmbFontSize.SetPreferredSize (pWinCur->nFontSize);
			m_pDialog->m_cmbFontSize.SetToSize (pWinCur->nFontSize, !(m_pDialog->m_cmbFontName.GetItemData (iCurFont) & TRUETYPE_FONTTYPE));
			break;

		case NoWindows:
		case NoFont:
			m_pDialog->m_cmbFontName.EnableWindow ( FALSE );
			goto diffont;
			
		case FontsDiffer:
			m_pDialog->m_cmbFontName.EnableWindow ( TRUE );
		diffont:
			m_pDialog->m_cmbFontName.SetCurSel ( -1 );
			m_pDialog->m_cmbFontSize.SetCurSel ( -1 );
			m_pDialog->m_cmbFontSize.EnableWindow (FALSE);
			break;
	}

}


///// SetCurrentElement
//
///
void CFCDialogState::SetCurrentElement  (int iElement)
{
	FMT_ELEMENT * pElement;
	CFmtElementIterator it (m_rgFmtInfo);

	m_nElementCur = iElement;

	switch (m_state)
	{
		case SelGroup:
		case SelAll:
			int iFormat;
			int iGroup;

			if (m_state == SelAll)
			{
				iFormat = -1;
				iGroup = -1;
			}
			else
			{
				iFormat = m_nFmtInfoCur;
				iGroup = m_nWinGroupCur;
			}

			COLORREF rgb;

			if (m_elList.IsForeColorTheSame (m_nElementCur, it, iFormat, iGroup, rgb))
				m_pDialog->m_cmbForeColor.SetCurColor (rgb);
			else
			{
				m_pDialog->m_cmbForeColor.SetCurSel (-1);
			}

			if (m_elList.IsBackColorTheSame (m_nElementCur, it, iFormat, iGroup, rgb))
				m_pDialog->m_cmbBackColor.SetCurColor (rgb);
			else
			{
				m_pDialog->m_cmbBackColor.SetCurSel (-1);
			}

			break;

		case SelWindow:
			ASSERT (iElement >= -1 && iElement < GetWinCur(FALSE, FALSE)->nElements);
			pElement =  &GetWinCur()->rgElements[m_nElementCur];

			m_pDialog->m_cmbForeColor.SetCurColor (pElement->autoFore.bOn ? CColorCombo::rgbAuto : pElement->rgbText);
			m_pDialog->m_cmbBackColor.SetCurColor (pElement->autoBack.bOn ? CColorCombo::rgbAuto : pElement->rgbBackground);
			break;

		default:
			ASSERT(FALSE);
	}
}


///// SetCurrentFont
//
//	Change the font and size in the current window.
//
///
void CFCDialogState::SetCurrentFont (const CString& strFontName, int ptSize, BOOL bTrueType)
{
FMT_WINDOW * pWindow;
CFmtWindowIterator itWin (m_rgFmtInfo);

	// First figure out what font size to use.  The given size may not be available, so we try to
	// set the size in the Font Size control, then use whatever it came up with.
	//
	ptSize = m_pDialog->m_cmbFontSize.GetSize (m_pDialog->m_cmbFontSize.SetToSize (ptSize, !bTrueType));


	switch (m_state)
	{
		case SelGroup:
			itWin.CFmtGroupIterator::Set(m_nFmtInfoCur, m_nWinGroupCur);
			while (pWindow = itWin.Get())
			{
				if (pWindow->szFontFace != NULL)
				{
					delete [] pWindow->szFontFace;

					pWindow->szFontFace = NewString (strFontName);
					pWindow->nFontSize = ptSize;

					CFormatInfo::UpdateLogFont (pWindow);
				}
			}
			break;

		case SelAll:
			itWin.CFmtGroupIterator::SetLinear(0);
			while (pWindow = itWin.GetLinear())
			{
				if (pWindow->szFontFace != NULL)
				{
					delete [] pWindow->szFontFace;

					pWindow->szFontFace = NewString (strFontName);
					pWindow->nFontSize = ptSize;


					CFormatInfo::UpdateLogFont (pWindow);
				}
			}
			break;

		case SelWindow:
			pWindow = GetWinCur(FALSE, TRUE);

			// Set the face
			//
			ASSERT (pWindow->szFontFace != NULL);
			delete [] pWindow->szFontFace;

			pWindow->szFontFace = NewString (strFontName);
			pWindow->nFontSize = ptSize;

			CFormatInfo::UpdateLogFont (pWindow);
			break;

		default:
			ASSERT(FALSE);
	}
}

/////
//
///
void CFCDialogState::SetCurrentFontSize (int nFontSize)
{
FMT_WINDOW * pWindow;
CFmtWindowIterator itWin (m_rgFmtInfo);

	switch (m_state)
	{
		case SelGroup:
			itWin.CFmtGroupIterator::Set(m_nFmtInfoCur, m_nWinGroupCur);
			while (pWindow = itWin.Get())
			{
				pWindow->nFontSize	= nFontSize;
				CFormatInfo::UpdateLogFont (pWindow);
			}
			break;

		case SelAll:
			itWin.CFmtGroupIterator::SetLinear(0);
			while (pWindow = itWin.GetLinear())
			{
				pWindow->nFontSize	= nFontSize;
				CFormatInfo::UpdateLogFont (pWindow);
			}
			break;

		case SelWindow:
			pWindow = GetWinCur(FALSE, TRUE);

			pWindow->nFontSize	= nFontSize;
			CFormatInfo::UpdateLogFont (pWindow);
			break;

		default:
			ASSERT(FALSE);
	}
}

void CFCDialogState::SetForeColor ( COLORREF rgb )
{
CFmtElementIterator itEl (m_rgFmtInfo);
FMT_WINGROUP * pGroupCur = NULL;

void * p;
	m_winList.GetPtr (m_iCurWin, p);

	switch (m_state)
	{
		case SelGroup:
			// FUTURE: why won't the compiler allow pGroupCur to be passed?
			pGroupCur = (FMT_WINGROUP *)p;

		case SelAll:
			m_elList.GetFirst (m_nElementCur, itEl);
			do
			{
				if (m_state == SelGroup && itEl.CFmtGroupIterator::Peek() != pGroupCur)
					continue;

				((CFormatInfo *)m_rgFmtInfo[itEl.CFmtIterator::GetIndex()])
					->SetForeColor (itEl.CFmtGroupIterator::GetIndex()
									, itEl.CFmtWindowIterator::GetIndex()
									, itEl.GetIndex()
									, rgb);
			} while ( m_elList.GetNext (itEl));
			
			break;

		case SelWindow:
			itEl.CFmtWindowIterator::Set ((FMT_WINDOW *)p);

			((CFormatInfo *)m_rgFmtInfo[itEl.CFmtIterator::GetIndex()])-> SetForeColor (itEl.CFmtGroupIterator::GetIndex(), itEl.CFmtWindowIterator::GetIndex(), m_nElementCur, rgb);
			break;

		default:
			ASSERT (FALSE);
	}

	UpdateAllAutoColors ();
}

void CFCDialogState::SetBackColor ( COLORREF rgb )
{
CFmtElementIterator itEl (m_rgFmtInfo);
FMT_WINGROUP * pGroupCur = NULL;

	void * p;
	m_winList.GetPtr (m_iCurWin, p);

	switch (m_state)
	{
		case SelGroup:
			pGroupCur = (FMT_WINGROUP *)p;

		case SelAll:
			m_elList.GetFirst (m_nElementCur, itEl);
			do
			{
				if (m_state == SelGroup && itEl.CFmtGroupIterator::Peek() != pGroupCur)
					continue;

				((CFormatInfo *)m_rgFmtInfo[itEl.CFmtIterator::GetIndex()])
					->SetBackColor (itEl.CFmtGroupIterator::GetIndex()
									, itEl.CFmtWindowIterator::GetIndex()
									, itEl.GetIndex()
									, rgb);
			} while ( m_elList.GetNext (itEl));
			
			break;

		case SelWindow:
			itEl.CFmtWindowIterator::Set ((FMT_WINDOW *)p);

			((CFormatInfo *)m_rgFmtInfo[itEl.CFmtIterator::GetIndex()])-> SetBackColor (itEl.CFmtGroupIterator::GetIndex(), itEl.CFmtWindowIterator::GetIndex(), m_nElementCur, rgb);
			break;

		default:
			ASSERT (FALSE);
	}

	UpdateAllAutoColors ();
}


///// CFCDialogState::UpdateAllAutoColors() - Update *ALL* auto colors
//
///
void CFCDialogState::UpdateAllAutoColors ()
{
CFmtIterator it (m_rgFmtInfo);

	CFormatInfo * pFmt;

	while (pFmt = it.Get())
		pFmt->UpdateAllAutoColors ();
}


COLORREF CFCDialogState::GetForeColor ()
{
CFmtElementIterator itEl (m_rgFmtInfo);

	if (m_benForeColor)
	{
		switch (m_state)
		{
			case SelAll:
				return m_elList.GetFirst (m_nElementCur, itEl)->rgbText;

			case SelGroup:
				return  m_elList.GetFirst (m_nElementCur, itEl, m_nFmtInfoCur, m_nWinGroupCur)->rgbText;

			case SelWindow:
				return GetWinCur(FALSE, FALSE)->rgElements[m_nElementCur].rgbText;

			default:
				ASSERT (FALSE);
				return 0;
		}	
	}
	else
		return GetSysColor (COLOR_WINDOWTEXT);	
}



COLORREF CFCDialogState::GetBackColor ()
{
CFmtElementIterator itEl (m_rgFmtInfo);

	if (m_benBackColor)
	{
		switch (m_state)
		{
			case SelAll:
				return m_elList.GetFirst (m_nElementCur, itEl)->rgbBackground;

			case SelGroup:
				return  m_elList.GetFirst (m_nElementCur, itEl, m_nFmtInfoCur, m_nWinGroupCur)->rgbBackground;

			case SelWindow:
				return GetWinCur(FALSE, FALSE)->rgElements[m_nElementCur].rgbBackground;

			default:
				ASSERT (FALSE);
				return 0;
		}	
	}
	else
		return GetSysColor (COLOR_WINDOW);	
}


///// IsFontUnique ()
//
//	Possible acts are:
//
//		FontEquality - Are all the windows using the same font
//		FontPitch - Are all the windows fixed-pitch only, or all not or mixed.
///
CFCDialogState::WW_RESULT CFCDialogState::WindowWalk (WW_ACTION act) const
{
CFmtWindowIterator itWin (m_rgFmtInfo);
LOGFONT lf;
BOOL bFirstTime = TRUE;
FMT_WINDOW * pWindow;
WW_RESULT result = NoWindows;


	switch (m_state)
	{
		case SelWindow:
			if (NULL == (pWindow = GetWinCur()))
				break;

			if (pWindow->szFontFace == NULL)
				return NoFont;

			switch (act)
			{
				case FontEquality:
					return SameFont;

				case FontPitch:
					ASSERT (pWindow);
					return pWindow->bMonospace ? PitchFixed : PitchProportional;

				default:
					ASSERT(FALSE);
			}

		case SelAll:
			while (pWindow = itWin.GetLinear ())
			{
				if (bFirstTime)
				{
					if (pWindow->pLogFont)
					{
						lf = *pWindow->pLogFont;
						bFirstTime = FALSE;
						switch (act)
						{
							case FontEquality:
								result = SameFont;
								break;

							case FontPitch:
								result = pWindow->bMonospace ? PitchFixed : PitchProportional;
								break;

							default:
								ASSERT (FALSE);
						}
					}
					else
						;
				}
				else
				switch (act)
				{
					case FontEquality:
						if (	pWindow->pLogFont &&
							(	lf.lfHeight != pWindow->pLogFont->lfHeight
							||	_tcscmp (lf.lfFaceName, pWindow->pLogFont->lfFaceName)))
							return FontsDiffer;
						break;

					case FontPitch:
						if (	pWindow->pLogFont &&
							(	((result == PitchFixed) && !pWindow->bMonospace)
							||	((result == PitchProportional) && pWindow->bMonospace)))
							return PitchMixed;
						break;

					default:
						ASSERT (FALSE);
				}
			}
			break;

		case SelGroup:
			itWin.CFmtGroupIterator::Set(m_nFmtInfoCur, m_nWinGroupCur);
			while (pWindow = itWin.Get())
			{
				if (bFirstTime)
				{
					if (pWindow->pLogFont)
					{
						lf = *pWindow->pLogFont;
						bFirstTime = FALSE;
						switch (act)
						{
							case FontEquality:
								result = SameFont;
								break;

							case FontPitch:
								result = pWindow->bMonospace ? PitchFixed : PitchProportional;
								break;

							default:
								ASSERT (FALSE);
						}
					}
					else
						;
				}
				else
				switch (act)
				{
					case FontEquality:
						if (	pWindow->pLogFont &&
							(	lf.lfHeight != pWindow->pLogFont->lfHeight
							||	_tcscmp (lf.lfFaceName, pWindow->pLogFont->lfFaceName)))
							return FontsDiffer;
						break;

					case FontPitch:
						if (	pWindow->pLogFont &&
							(	((result == PitchFixed) && !pWindow->bMonospace)
							||	((result == PitchProportional) && pWindow->bMonospace)))
							return PitchMixed;
						break;

					default:
						ASSERT (FALSE);
				}
			}
			break;
	}

	return result;
}


///// RestoreDefaults
//
///
void CFCDialogState::RestoreDefaults ()
{
CFormatInfo fiDefault;
CFmtIterator itFmt(m_rgFmtInfo);
CFmtGroupIterator itGroup(m_rgFmtInfo);
CFmtWindowIterator itWin(m_rgFmtInfo);

	switch (m_state)
	{
		case SelAll:
			// Loop through all CFormatInfo's
			CFormatInfo * pFI;

			while (pFI = itFmt.Get ())
			{	
				pFI->m_pPackage->GetDefaultFormatInfo (fiDefault);
				pFI->Update (fiDefault);
			}		
			UpdateAllAutoColors ();
			break;

		case SelGroup:

			// Find group, update 
			((CFormatInfo *)(m_rgFmtInfo[m_nFmtInfoCur]))->m_pPackage->GetDefaultFormatInfo (fiDefault);
			((CFormatInfo *)(m_rgFmtInfo[m_nFmtInfoCur]))->Update (fiDefault, m_nWinGroupCur);
			break;

		case SelWindow:
			// Find window, update 
			((CFormatInfo *)(m_rgFmtInfo[m_nFmtInfoCur]))->m_pPackage->GetDefaultFormatInfo (fiDefault);
			((CFormatInfo *)(m_rgFmtInfo[m_nFmtInfoCur]))->Update (fiDefault, m_nWinGroupCur, m_nWindowCur);
			break;
	}

	UpdateAllAutoColors ();
	m_pDialog->OnChangeWindow();	// This will refresh the dialog controls.
}


/////
//
///
FMT_WINDOW * CFCDialogState::GetWinCur (BOOL bReturnNull, BOOL bMustHaveFont) const
{
UINT iWindow = m_nWindowCur;
FMT_WINDOW * pWindow;

// FUTURE: What if !bReturnNull and there are no windows at all?
//
	pWindow =  ((iWindow != -1) || (!bReturnNull && !(iWindow = 0)))
		? &((CFormatInfo *)m_rgFmtInfo[m_nFmtInfoCur])->m_pWinGroup[m_nWinGroupCur].rgWindows[iWindow]
		: NULL;

	if (pWindow && bMustHaveFont && pWindow->szFontFace == NULL)
	{
		if (bReturnNull)
			pWindow = NULL;
		else
		{
			CFmtWindowIterator itWin (m_rgFmtInfo);

			itWin.Set (pWindow);
			while ( pWindow = itWin.GetLinear() )
			{
				if (pWindow->szFontFace)
					break;
			}

			ASSERT (pWindow);	// Can't return NULL, must return NULL, oops.
		}
	}

	return pWindow;
}


/////
//
///
PLOGFONT CFCDialogState::GetCurrentLogFont () const
{
	if (SameFont == WindowWalk (FontEquality))
		return GetWinCur(FALSE, TRUE)->pLogFont;
	else
		return NULL;
}


/////
//
///
void CFCDialogState::Commit()
{
	for (int i = 0; i < m_rgFmtInfo.GetSize (); i++)
		((CFormatInfo *)m_rgFmtInfo [i])->Commit ();

	m_state = PostDialog;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\findspec.cpp ===
// FindSpec.cpp

#include "stdafx.h"
#include "find.h"
#include "findspec.h"
#include "resource.h"

//////////////////////////////////////////////////////////////////////
// FindSpecialHandler tables
// reUnix, reZibo, reBrief, reEpsilon

static LPCTSTR rgszSpecialUnix[] = {
	".",		// ID_FIND_ANYCHARACTER
	"[]",		// ID_FIND_RANGE
	"[^]",		// ID_FIND_NOTRANGE
	"^",		// ID_FIND_LINE_BEGIN
	"$",		// ID_FIND_LINE_END
	"\\(\\)",	// ID_FIND_TAG
	"\\~",		// ID_FIND_NOT
	"\\!",		// ID_FIND_OR
	"*",		// ID_FIND_CLOSURE_ZERO
	"+",		// ID_FIND_CLOSURE_ONE
	"\\{\\}",	// ID_FIND_GROUP

	"\\:a", // "[a-zA-Z0-9]"							ID_FIND_ALPHANUM
	"\\:b+", // "[ \t]#"								ID_FIND_WHITESPACE
	"\\:c", // "[a-zA-Z]"								ID_FIND_ALPHA
	"\\:d", // "[0-9]"									ID_FIND_DECIMAL
	"\\:h", // "([0-9a-fA-F]#)"							ID_FIND_HEX
	"\\:n", // "([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)"	ID_FIND_NUMBER
	"\\:z", // "([0-9]#)"								ID_FIND_INTEGER
	"\\:i", // "([a-zA-Z_$][a-zA-Z0-9_$]@)"				ID_FIND_IDENTIFIER
	"\\:w", // "([a-zA-Z]#)"							ID_FIND_WORD
	"\\:q" // "([0-9]#)"								ID_FIND_STRING
};

static LPCTSTR rgszSpecialBrief[] = {
	"?",		// ID_FIND_ANYCHARACTER
	"[]",		// ID_FIND_RANGE
	"[~]",		// ID_FIND_NOTRANGE
	"%",		// ID_FIND_LINE_BEGIN
	"$",		// ID_FIND_LINE_END
	"{}",		// ID_FIND_TAG
	"~",		// ID_FIND_NOT
	"|",		// ID_FIND_OR
	"@",		// ID_FIND_CLOSURE_ZERO
	"+",		// ID_FIND_CLOSURE_ONE
	"{}",		// ID_FIND_GROUP

	"[a-zA-Z0-9]",	// ID_FIND_ALPHANUM
	"[ \\x09]+",	// ID_FIND_WHITESPACE
	"[a-zA-Z]",		// ID_FIND_ALPHA
	"[0-9]",		// ID_FIND_DECIMAL
	"[0-9a-fA-F]+", // ID_FIND_HEX
	"{[0-9]+.[0-9]@}|{[0-9]@.[0-9]+}|{[0-9]+}",	// ID_FIND_NUMBER
	"[0-9]+",								// ID_FIND_INTEGER
	"[a-zA-Z_$][a-zA-Z0-9_$]@",				// ID_FIND_IDENTIFIER
	"[a-zA-Z]+",	// ID_FIND_WORD
	"\"[~\"]@\""	// ID_FIND_STRING
};

static LPCTSTR rgszSpecialEpsilon[] = {
	".",		// ID_FIND_ANYCHARACTER
	"[]",		// ID_FIND_RANGE
	"[^]",		// ID_FIND_NOTRANGE
	"^",		// ID_FIND_LINE_BEGIN
	"$",		// ID_FIND_LINE_END
	"()",		// ID_FIND_TAG
	"~",		// ID_FIND_NOT
	"|",		// ID_FIND_OR
	"*",		// ID_FIND_CLOSURE_ZERO
	"+",		// ID_FIND_CLOSURE_ONE
	"()",		// ID_FIND_GROUP

	"[a-zA-Z0-9]",	// ID_FIND_ALPHANUM
	"[ <tab>]+",	// ID_FIND_WHITESPACE
	"[a-zA-Z]",		// ID_FIND_ALPHA
	"[0-9]",		// ID_FIND_DECIMAL
	"[0-9a-fA-F]+", // ID_FIND_HEX
	"([0-9]+.[0-9]*|[0-9]*.[0-9]+|[0-9]+)",	// ID_FIND_NUMBER
	"[0-9]+",								// ID_FIND_INTEGER
	"[a-zA-Z_$][a-zA-Z0-9_$]@",				// ID_FIND_IDENTIFIER
	"[a-zA-Z]+",	// ID_FIND_WORD
	"\"[~\"]*\""	// ID_FIND_STRING
};


void ReplaceSel( CButtonEdit & ComboEdit, LPCTSTR szRep, NewSelPos selpos, BOOL bWrap, int nWrapBreak )
{
	DWORD nStart = 0;
	DWORD nEnd = 0;
	// where to put the ip after we insert the item
	DWORD ipStart = 0;
	DWORD ipEnd = 0;

	_TCHAR szText[LIMIT_FIND_COMBO_TEXT+1];
	_TCHAR szNew[LIMIT_FIND_COMBO_TEXT+1];
	szText[0] = _T('\0');
	szNew[0] = _T('\0');
	nStart = LOWORD(ComboEdit.m_dwLastSel);
	nEnd = HIWORD(ComboEdit.m_dwLastSel);
	ComboEdit.GetWindowText(szText, LIMIT_FIND_COMBO_TEXT);

	LPTSTR Src = szText;
	LPTSTR Dst = szNew;
	LPCTSTR Rep = szRep;

	// copy left part before the selection
	_tcsncpy(Dst,Src,nStart);
	Src = _tcsninc(Src,nStart);
	Dst = _tcsninc(Dst,nStart);

	if (bWrap)
	{
		// copy left half of rep
		_tcsncpy(Dst,Rep,nWrapBreak);
		Rep = _tcsninc(Rep,nWrapBreak);
		Dst = _tcsninc(Dst,nWrapBreak);
		// copy selected text
		_tcsncpy(Dst,Src,nEnd-nStart);
		Dst = _tcsninc(Dst,nEnd-nStart);
	}

	// copy remaining replacement (all if no wrap)
	_tcscpy(Dst,Rep);
	Dst = _tcsninc(Dst, _tcslen(Rep));

	// point Src to end of selection
	Src = _tcsninc(szText,nEnd);

	// copy remaining Src
	_tcscpy(Dst,Src);

	switch(selpos)
	{
	case spStart:
		ipStart = ipEnd = nStart;
		break;
	case spEnd:
		ipStart = ipEnd = nStart + _tcslen(szRep);
		break;
	case spSel:
		ipStart = nStart;
		if (bWrap)
			ipEnd = nEnd + _tcslen(szRep);
		else
			ipEnd = nStart + _tcslen(szRep);
		break;
	case spInsideStart:
		ipStart = ipEnd = nStart + nWrapBreak;
		break;
	case spInsideEnd:
		if (bWrap)
			ipStart = ipEnd = nEnd + nWrapBreak;
		else
			ipStart = ipEnd = nStart + nWrapBreak;
		break;
	}

	ComboEdit.SetWindowText(szNew);
	ComboEdit.SetFocus();
	ComboEdit.SetSel(MAKELONG(ipStart, ipEnd));
}

LPCTSTR *GetCurrentRegexHintTable(void)
{
	switch (GetRegExprSyntax())
	{
		case reUnix:    return rgszSpecialUnix;
		case reBrief:   return rgszSpecialBrief;
		case reEpsilon: return rgszSpecialEpsilon;
	}

	ASSERT(FALSE); // shouldn't have fallen through!!
	return rgszSpecialUnix; // we'll send back something valid if this happens
}


// FindSpecialHandler
//
// hDlg		Dialog handle
// idEdit	ID of edit control to receive the text.
// cmd		Menu ID from the IDR_FIND_SPECIAL menu
//
// environParams.reSyntax:
//	reUnix, reZibo, reBrief, reEpsilon
BOOL FindSpecialHandler( CButtonEdit & ComboEdit, UINT cmd, BOOL bWrap )
{
	CString strText, strLeft, strRight;
	LPCTSTR * rgszSpecial;
	LPCTSTR szRe;
	NewSelPos selpos = spEnd;

	rgszSpecial = GetCurrentRegexHintTable();

	switch(cmd)
	{

	// smart insert
	case ID_FIND_NOTRANGE:
		selpos = spInsideEnd;
		szRe = rgszSpecial[cmd - ID_FIND_ANYCHARACTER];
		ReplaceSel( ComboEdit, szRe, selpos, bWrap, 2);
		return TRUE;
		break;

	case ID_FIND_RANGE:
	case ID_FIND_GROUP:
	case ID_FIND_TAG:
		selpos = spInsideStart;
		szRe = rgszSpecial[cmd - ID_FIND_ANYCHARACTER];
		ReplaceSel( ComboEdit, szRe, selpos, bWrap, _tcslen(szRe)/2);
		return TRUE;
		break;

	// simple insert
	case ID_FIND_ANYCHARACTER:
	case ID_FIND_LINE_BEGIN:
	case ID_FIND_LINE_END:
	case ID_FIND_NOT:
	case ID_FIND_OR:
	case ID_FIND_CLOSURE_ZERO:
	case ID_FIND_CLOSURE_ONE:
	// shorthand
	case ID_FIND_ALPHANUM:
	case ID_FIND_WHITESPACE:
	case ID_FIND_ALPHA:
	case ID_FIND_DECIMAL:
	case ID_FIND_HEX:
	case ID_FIND_NUMBER:
	case ID_FIND_INTEGER:
	case ID_FIND_IDENTIFIER:
	case ID_FIND_WORD:
	case ID_FIND_STRING:
		szRe = rgszSpecial[cmd - ID_FIND_ANYCHARACTER];
		ReplaceSel( ComboEdit, szRe );
		return TRUE;
		break;

	case ID_REPLACE_FINDWHATTEXT:
	case ID_REPLACE_TAG_1:
	case ID_REPLACE_TAG_2:
	case ID_REPLACE_TAG_3:
	case ID_REPLACE_TAG_4:
	case ID_REPLACE_TAG_5:
	case ID_REPLACE_TAG_6:
	case ID_REPLACE_TAG_7:
	case ID_REPLACE_TAG_8:
	case ID_REPLACE_TAG_9:
	{
		//reZibo, reUnix, reBrief, reEpsilon
		const _TCHAR rgchTag[] = "$\\\\#";
		_TCHAR szRep[3];
		szRep[0] = rgchTag[g_reCurrentSyntax];
		szRep[1] = (cmd - ID_REPLACE_FINDWHATTEXT) + _T('0');
		szRep[2] = _T('\0');
		ReplaceSel( ComboEdit, szRep );
		break;
	}

	default:
		ASSERT(0);
		break;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\fnwiztpl.h ===
/////////////////////////////////////////////////////////////////////////////
//	fnwiztpl.h
//		File New Wizard template

#ifndef __FNWIZTPL_H__
#define __FNWIZTPL_H__

class CFileNewWizardTemplate : public CPartTemplate
{
	DECLARE_DYNAMIC(CFileNewWizardTemplate)
private:
	HICON m_hIcon;
	
public:
	// constructor
	CFileNewWizardTemplate(CPackage* pPackage, REFCLSID clsid, CString strDesc, HICON hIcon=NULL);

	// Dont call this.  You should call NewDocumentFile
	virtual CDocument*	OpenDocumentFile(LPCTSTR pszPathName, BOOL bMakeVis = TRUE);
	// Override this one.
	virtual CPartDoc	  *NewDocumentFile(LPCTSTR szFileName, IPkgProject *pProject, LPCTSTR szFolder);

	// override to get alternative icon
	virtual HICON GetIcon() { return m_hIcon; };
	virtual FileNewTabType GetTabType() { return newtemplate; };
	//
	//	BOOL CFileNewWizardTemplate::CanBeAddedToProject
	//
	//	Description:
	//		This FileNewWizard can only be added to IWebPkgProjects.
	//
	//	Arguments:
	//		IPkgProject *pProject:
	//
	//	Return (BOOL): TRUE if Project CLSID == IID_IWebPkgProject(s), FALSE otw
	//
	virtual BOOL CanBeAddedToProject(IPkgProject *pProject);
};

#endif		// __FNWIZTPL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\gotodlg.cpp ===
#include "stdafx.h"
#include "resource.h"

#include "shell.hid" // 26 Jun 96 - Dynamic context menu ids for Next/Goto Button

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CGoToDialog dialog

// static member used to prevent multiple instances. Must be declared at file scope
CGoToDialog * CGoToDialog::c_pGotodialog = NULL; // used to prevent multiple instances of modeless dialog

#ifdef DEBUG  // flags to check that needed functions are called by package onselect
BOOL fOnSelCalledButtonStyle = FALSE;
BOOL fOnSelCalledControlStyle = FALSE;
BOOL fOnSelCalledPrompt = FALSE;
#endif

// Constructor (MUST HAVE HELP ID!!!)
CGoToDialog :: CGoToDialog(UINT idHelp, LPCTSTR szItemInit, CWnd* pParent /*=NULL*/)
	: C3dDialog(CGoToDialog::IDD, pParent)
{
	SetHelpID( idHelp );
	c_pGotodialog = this;
	m_fFirstMoveMsg = FALSE; // will be set true in initdialog
	m_fForcePinForHelp = FALSE;

	ASSERT(m_strItemInit.IsEmpty());
	if (szItemInit != NULL && *szItemInit != '\0')
	{
		m_strItemInit = szItemInit; // copy string
		ASSERT(!m_strItemInit.IsEmpty());
	}
}


// destructor
CGoToDialog::~CGoToDialog()
{
	c_pGotodialog = NULL;

}
// this is a static member function
CGoToDialog *CGoToDialog::PGoToDialogCur()
{
	return (c_pGotodialog);

}

void CGoToDialog::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGoToDialog)
	DDX_Control(pDX, IDC_GOTOCOMBO, m_gotoCombo);
	DDX_Control(pDX, IDC_GOTOHELPTEXT, m_helpText);
	DDX_Control(pDX, IDC_GOTOCAPTION, m_gotoCaption);
	DDX_Control(pDX, IDC_GOTOWHAT, m_gotoWhat);
	DDX_Control(pDX, IDC_GOTOLIST, m_gotoList);
	DDX_Control(pDX, IDC_GOTOEDIT, m_gotoEdit);
	//}}AFX_DATA_MAP
}

IMPLEMENT_DYNAMIC(CGoToDialog, CDialog)  // skip C3dDialog since not dynamic. Randy says this is ok

BEGIN_MESSAGE_MAP(CGoToDialog, C3dDialog)
	//{{AFX_MSG_MAP(CGoToDialog)
	ON_LBN_SELCHANGE(IDC_GOTOLIST, OnSelchangeGoToList)
	ON_LBN_SELCHANGE(IDC_GOTOWHAT, OnSelchangeGoToWhat)
	ON_CBN_SELCHANGE(IDC_GOTOCOMBO, OnSelchangeGoToCombo)
	ON_BN_CLICKED(ID_PREVIOUS, OnPrevious)
	ON_EN_CHANGE(IDC_GOTOEDIT, OnChangeGoToEdit)
	ON_CBN_EDITCHANGE(IDC_GOTOCOMBO, OnEditchangeGoToCombo)
	ON_WM_ACTIVATE()
	ON_WM_MOVE()
	ON_BN_CLICKED(ID_GOTO_GOTOANDNEXT, OnGotoGotoAndNext)
	ON_WM_ACTIVATEAPP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGoToDialog message handlers

BOOL CGoToDialog::OnHelpInfo(HELPINFO* pInfo) 
{
	// need to prevent this dialog going away when decativated by help.
	// set this flag, which causes deactivate code to not take down the dialog. The 
	// flag is cleared in the activate or activateapp code. one of which we will receive.
	// this is rather peculiar, but gets us past a multitude of evils, like the pin button changing
	// state when clicked in the ? state.  bobz 9/25/96

	m_fForcePinForHelp = TRUE;  // cleared in OnActivate

	return (DoHelpInfo(this, m_nIDHelp, pInfo));
}


BOOL CGoToDialog::PreTranslateMessage(MSG* pMsg)
{
	// CG: The following block was added by the ToolTips component.
	{
		// Let the ToolTip process this message.
		m_tooltip.RelayEvent(pMsg);

		return C3dDialog::PreTranslateMessage(pMsg);
	}
}

void CGoToDialog::OnChangeGoToEdit() 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (m_pGoToItemCur != NULL);

	CString str;

	GetSelectData(str, NULL, NULL, NULL, FALSE /* fComboSelChange */);
	m_pGoToItemCur->OnSelectChange(str, FALSE, dwItemDataInvalid);

	m_cLockSelectAtActivate--;  // allow reset on activation
}


void CGoToDialog::OnSelchangeGoToList() 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (m_pGoToItemCur != NULL);

	CString str;
	DWORD dwItemData;
	BOOL fSelInList;

	GetSelectData(str, &dwItemData, NULL, &fSelInList, FALSE /* fComboSelChange */);
	m_pGoToItemCur->OnSelectChange(str, fSelInList, dwItemData);

	m_cLockSelectAtActivate--;  // allow reset on activation
}

void CGoToDialog::OnSelchangeGoToCombo() 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (m_pGoToItemCur != NULL);

	CString str;
	DWORD dwItemData;
	BOOL fSelInList;

	GetSelectData(str, &dwItemData, NULL, &fSelInList, TRUE /* fComboSelChange */);
	m_pGoToItemCur->OnSelectChange(str, fSelInList, dwItemData);
		
	m_cLockSelectAtActivate--;  // allow reset on activation
}

void CGoToDialog::OnEditchangeGoToCombo() 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (m_pGoToItemCur != NULL);

	CString str;
	DWORD dwItemData;
	BOOL fSelInList;

	GetSelectData(str, &dwItemData, NULL, &fSelInList, FALSE /* fComboSelChange */);
	m_pGoToItemCur->OnSelectChange(str, fSelInList, dwItemData);

	m_cLockSelectAtActivate--;  // allow reset on activation

}


// Helper: gets text and item data and the dialog id from the current selection control
// NOTE: for a combo, we return the text in the selected item in the
// list box if the edit text is a prefix of a list box entry, and the edit control text otherwise
// fComboSelChanged is used for a combo, because on a CBN_SELCHANGE, the selection is updated but the
// edit text is not, where on a CBN_EDITCHANGE, the edit text change and the selection has not, so you
// need to know where to look for data in that case
void CGoToDialog::GetSelectData(CString &strData, 
			DWORD *pdwItemData, 
			int *pidSelect,
			BOOL *pfSelInList,
			BOOL fComboSelChanged) 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (m_pGoToItemCur != NULL);

	int iItem;
	DWORD dwItemData = dwItemDataInvalid;
	BOOL fSelInList = FALSE;
	int idSelect = -1;

	strData.Empty();

	if (m_csSelection == csDropList)
	{
		iItem = m_gotoList.GetCurSel();
		if (iItem != CB_ERR)
		{
			m_gotoList.GetText(iItem, strData);
			dwItemData = m_gotoList.GetItemData(iItem);
			idSelect = IDC_GOTOLIST;
			fSelInList = TRUE;
		}

	} // droplist
	else if (m_csSelection == csDropCombo)
	{
		idSelect = IDC_GOTOCOMBO;

		// use FindString to determine if the edit text is a prefix of a list entry.
		// if so, treat the list entry as being selected. This handles cases when the list box is not
		// visible and no actual selection exists

		// if we change the combo list selection, we get a selchange BEFORE the edit text is updated.
		// in that case, get the text from the selection. Otherwise use the text in the edit control
		// and use findstring to see if there is a prefix match

		if (fComboSelChanged)
		{
			iItem = m_gotoCombo.GetCurSel();
			if (iItem != CB_ERR)  // use selection in list box, if any
			{
				fSelInList = TRUE;
				// if there is a selection, use full LB text rather than
				// contents of edit control
				m_gotoCombo.GetLBText(iItem, strData);
				dwItemData = m_gotoCombo.GetItemData(iItem);
			}
		}
		else  // edit text changed, or not in a changing state (OK?Previous)
		{
			m_gotoCombo.GetWindowText(strData);
			if (!strData.IsEmpty())  // defaults are all correct for the empty case
			{
				iItem = m_gotoCombo.FindString(-1, strData); // look for prefix match in list
				if (iItem != CB_ERR)  // If no match, strData is correct (edit text), and other args are correctly set up now
				{
					fSelInList = TRUE;
					// if there is a selection, use full LB text rather than
					// contents of edit control
					m_gotoCombo.GetLBText(iItem, strData);
					dwItemData = m_gotoCombo.GetItemData(iItem);
				}
			}
		}
	}  // combo
	else 
	{
		ASSERT (m_csSelection == csEdit);
		m_gotoEdit.GetWindowText(strData);
		idSelect = IDC_GOTOEDIT;
	}

	if (pdwItemData != NULL)
			*pdwItemData = dwItemData;
	if (pidSelect != NULL)
			*pidSelect = idSelect;
	if (pfSelInList != NULL)
			*pfSelInList = fSelInList;
	
	m_cLockSelectAtActivate--;  // allow reset on activation
}

// handle change in selection of Go To What list
void CGoToDialog::OnSelchangeGoToWhat() 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated
	DoSelchangeGoToWhat();
	GotoDlgCtrl(&m_gotoWhat);  // grab focus back
	m_cLockSelectAtActivate--;  // allow reset on activation
}

// handle change in selection of Go To What list
void CGoToDialog::DoSelchangeGoToWhat() 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	// store the active view whenever we come up. Could change while up (as in goto bookmark can change
	// the file you are looking at, and changing to gotoline will need new view.

	m_pActiveView = (CPartView *) FromHandle(theApp.GetActiveView());

	int iItem = m_gotoWhat.GetCurSel();

	m_pGoToItemCur = (CGoToItem *)m_gotoWhat.GetItemDataPtr(iItem);
	if (m_pGoToItemCur == NULL || iItem == LB_ERR)
	{
		ASSERT(FALSE);  // should never happen
		return;
	}

	m_helpText.SetWindowText(""); // because package may not support SetHelperText
	// debug flags to ensure that package called necessary functions
#ifdef DEBUG
	fOnSelCalledButtonStyle = FALSE;
	fOnSelCalledControlStyle = FALSE;
	fOnSelCalledPrompt = FALSE;
#endif

	m_pGoToItemCur->OnSelectWhat();

#ifdef DEBUG
	ASSERT(fOnSelCalledButtonStyle);  
	ASSERT(fOnSelCalledControlStyle);
	ASSERT(fOnSelCalledPrompt);

#endif

	BOOL fEnableItem;
	fEnableItem =  m_pGoToItemCur->CanGoViewActive(m_pActiveView);  // just so each package does not need to do this in OnSelect
	SetItemEnabled(m_pGoToItemCur, fEnableItem); // enable/disable relevant controls
	
	if (fEnableItem)
	{
		// if item enabled, force button state settings to reflect initial contents of selection control
		CString str;
		DWORD dwItemData;
		BOOL fSelInList;

		GetSelectData(str, &dwItemData, NULL, &fSelInList, FALSE /* fComboSelChange */);
		m_pGoToItemCur->OnSelectChange(str, fSelInList, dwItemData);
	}
	// select selection control if any
	GotoCtlSel();
	m_cLockSelectAtActivate--;  // allow reset on activation
}

// Note: since close button id == IDCANCEL, close box, esc and the Close button go through here
void CGoToDialog::OnCancel() 
{
	// if we come in multiple times - possible due to calling this on deactivate, get out or we destroy ourselves again
	if (GetSafeHwnd() == NULL)
	{
		ASSERT(FALSE);
		return;
	}

	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	if (m_cBusyNoClose != 0) // goto operation still in progress
	{
		ErrorBox(ERR_Goto_Busy);
		m_cLockSelectAtActivate--;  // allow reset on activation
		return;  // leave dialog up
	}
	else
	{
		if (m_btnPushPin.GetSafeHwnd() != NULL)	// handles failure case in InitDialog
			theApp.m_bPinGoToDlg = m_btnPushPin.IsButtonDown();  // save in global

		// delete all the items we received
		int i;
		int cItem =  m_gotoWhat.GetCount();
		for (i = 0; i < cItem; i++)
			{
			ASSERT(m_gotoWhat.GetItemDataPtr(i) != NULL);
			delete m_gotoWhat.GetItemDataPtr(i);
			}
		
		m_gotoWhat.ResetContent();

		CPartView *pActiveView = m_pActiveView;

		m_cLockSelectAtActivate--;  // allow reset on activation
		if (GetSafeHwnd() != NULL)	// safety measure in case of already down when we get this message
			DestroyWindow();  // since modeless, don't call default which calls EndDialog

		if (pActiveView != NULL)
			pActiveView->SetFocus();
	}
}

void CGoToDialog::OnPrevious() 
{
	OnOKPrevious(goPrevious); // OnOkPrevious sets m_cLockSelectAtActivate. don;t need it here
}

/* See OnGotoGotoAndNext...
void CGoToDialog::OnOK() 
{
		// OK button can be goto or next
	GOTO_TYPE go = (m_bsCur == bsGoTo ? goGoTo: goNext);
	OnOKPrevious(go);  // OnOkPrevious sets m_cLockSelectAtActivate. don;t need it here
}
*/

void CGoToDialog::OnOKPrevious(GOTO_TYPE go) 
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated
	m_cBusyNoClose++;  // prevents closing dialog. See fat note below

	ASSERT (m_pGoToItemCur != NULL);
	CString str;
	DWORD dwItemData;
	int idSelect;
	BOOL fSelInList;
	CGoToItem * pGoToItemCur; // local copies of dialog globals
	CPartView * pActiveView;  

	// handle case when you click on ok button when inactive and out of context
	if (m_pGoToItemCur == NULL || (!m_pGoToItemCur->CanGoViewActive(m_pActiveView)))
	{
		::MessageBeep(0);
		goto LRet;
	}

	GetSelectData(str, &dwItemData, &idSelect, &fSelInList, FALSE /* fComboSelChange */);

	// FAT NOTE (bobz): The universe can change between CanGoTo and OnGoTo. For example,
	// GotoReference can spawn a build to create a bsc file. While that is going on, you could
	// change the doc you are pointing to, and click on the goto dialog again, among
	// other things. The dialog global state, like m_pGoToItemCur and m_pGoToItemCur might
	// have changed. One solution would be to dump CanGoTo and put all the check and
	// go code into OnGoTo, but that is a fairly radical change. So instead this is the scheme:
	// We save local copies of the dialog state (globals). After CanGoTo, if the current global
	// state matches the local state, we do on goto, otherwise we act as if CanGoTo had failed.
	// We resync up the dialog and the view after CanGoTo, whether or not we did OnGoTo

	// Actually what is even worse,is that the user could close the dialog during the CanGoTo Processing
	// and OnGoTo would crash. So we now set a counter to effectively disable the Close button 
	// around can/on goto and reset at the end. This disables ESC and the X (Close) button too.

	// So we allow the dialog to be used while something like a build is on, but it can't be closed
	// until process completes - an error box comes up in that case.


	pGoToItemCur = m_pGoToItemCur; // save local copy of global state in case globals change
	pActiveView = m_pActiveView;

	if (m_pGoToItemCur->CanGoTo(idSelect, go, str, fSelInList, dwItemData))
	{
		// implied else clause is to just not do the go to
		if (pGoToItemCur == m_pGoToItemCur &&  pActiveView == m_pActiveView)
		{
			CString strCur;
			GetSelectData(strCur, NULL, NULL, NULL, FALSE /* fComboSelChange */);
			if (str == strCur)
				m_pGoToItemCur->OnGoTo(go, str, fSelInList, dwItemData);  
		}
	}

	// above may cause a change in view. Determine if a change, if so, call change view function
	// then update m_pActiveView

	{  // BLOCK
	CPartView *pView = (CPartView *) FromHandle(theApp.GetActiveView());
	ASSERT((pView == (CPartView *)NULL) || pView->IsKindOf(RUNTIME_CLASS(CPartView)));
	if (pView != m_pActiveView)  // deal with changing view. If item needs to reset itself on view
								 // change, do that in CanGoViewActive 
	{
		BOOL fEnableItem;

		pGoToItemCur = m_pGoToItemCur; // save local copy of global state in case globals change
		pActiveView = m_pActiveView;	// don;t bother checking string text as well in this case bobz

		fEnableItem = m_pGoToItemCur->CanGoViewActive(pView);  // call before resetting dialog state so CanGo can check differences

		if (pGoToItemCur != m_pGoToItemCur ||  pActiveView != m_pActiveView)
		{
			ASSERT(FALSE);  // unexpected change, just disable for now
			fEnableItem = FALSE;
		}

		SetItemEnabled(m_pGoToItemCur, fEnableItem); // enable/disable relevant controls

		m_pActiveView = pView;
	}
		// scroll out of the way if in a text view
	if ((pView != (CPartView *)NULL))
		pView->SetDialogPos(FALSE /* fFirstTime */, this->m_hWnd);
	}


	// Set the focus back to the selection control, if any
	GotoCtlSel();

  // do not call OnOk to dismiss - let close do that (modeless)
LRet:
	m_cBusyNoClose--;	// allows dialog to be closed
	ASSERT(m_cBusyNoClose == 0);
  	m_cLockSelectAtActivate--;  // allow reset on activation
	ASSERT(m_cLockSelectAtActivate >= 0);

	if (!m_btnPushPin.IsButtonDown())
		OnCancel();
}


afx_msg void CGoToDialog::OnMove(int cx, int cy)
{
	C3dDialog::OnMove(cx, cy);

	if (m_fFirstMoveMsg)
	{
		CPartView *pView = (CPartView *) FromHandle(theApp.GetActiveView());
		if ((pView != (CPartView *)NULL))
			pView->SetDialogPos(TRUE /* fFirstTime */, this->m_hWnd);
	}
	m_fFirstMoveMsg = FALSE;
}


void CGoToDialog::OnActivate(UINT nState, CWnd *pWndOther, BOOL bMinimized)
{
// This is rather complex because we want to force reinitialization sometimes, mainly when the
// user clicks away from the dialog, but not other times, like when an error box comes up or
// a goto action sets the focus on the doc. So the current scheme reinits the selection on
// activation if the active view has changed. 
// bobz

	C3dDialog::OnActivate(nState, pWndOther, bMinimized);

	if (nState == WA_INACTIVE)
	{
		// change in behavior (bobz) to act more like property sheets, this dialog will disappear
		// on deactivation if it is unpinned.
		// 	m_fForcePinForHelp is reset in the OnActivateApp handler and in the ACTIVE side of this code
		if (!m_fForcePinForHelp)
			if ((m_btnPushPin.GetSafeHwnd() != NULL) && !m_btnPushPin.IsButtonDown())
			{
				if (GetSafeHwnd() != NULL)	// safety measure in case of already down when we get this message
					PostMessage(WM_CLOSE); // take it down
			}
		return;
	}

	m_fForcePinForHelp = FALSE; // stay up but let us come down next time

	// Consider activation a time to reestablish the selection, since the basis for selection
	// may have changed. However, since we can lose activation for things like message boxes, we
	// don't always want to reset on activation, as we may throw away useful state. So we set a
	// sentinal (m_cLockSelectAtActivate) when we want to prevent reselection

	// Note there are some scenarios. like Bookmarks, where the act of going to a new doc may take the
	// focus from this dialog. If this happens, and the item wants to reclaim the focus for the dialog,
	// it must be careful, because activation will take place.The sentinal will be set in such cases. Be
	// sure to restablish the dialog's m_pActiveView in that case however.


	CPartView *pView = (CPartView *) FromHandle(theApp.GetActiveView());
	ASSERT((pView == (CPartView *)NULL) || pView->IsKindOf(RUNTIME_CLASS(CPartView)));
	m_pActiveView = pView;

	if (!m_cLockSelectAtActivate)  // counter, not flag. Setters use ++ and --
	{
		m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

		DoSelchangeGoToWhat(); // reestablish current what selection. Will reset m_pActiveView as well

		m_cLockSelectAtActivate--;  // allow reset on activation
	}
}

BOOL CGoToDialog::OnInitDialog() 
{
// wrapper function for DoInitDialog so code does not have to worry about exiting w/o resetting mode flag
	m_fInInitDialog = TRUE; // mode flag
	m_cLockSelectAtActivate = 1; // prevent reset if we are inactivated and reactivated. Initial setting
	m_cBusyNoClose = 0; // set in OK handler to prevent dialog close while process underway

	BOOL fRet = DoInitDialog();

	m_fInInitDialog = FALSE; // mode flag
	m_cLockSelectAtActivate--;  // allow reset on activation
	ASSERT(m_cLockSelectAtActivate == 0);

	return fRet;
}

BOOL CGoToDialog::DoInitDialog() 
{
	// mode flags were set in OnInitDialog

	BOOL fRet = C3dDialog::OnInitDialog();

	// 1. init dialog variables.
	m_pctlSelection = NULL;
	m_csSelection = csUninit;
	m_pGoToItemCur = NULL;
	m_bsCur = bsGoTo;
	// 26 Jun 96 - This button needs two different help context ids.
	// The ids can be found in Shell.hid.
	// This line will set up the default help id for this button.
	GetDlgItem(ID_GOTO_GOTOANDNEXT)->SetWindowContextHelpId(HIDC_GOTO_GOTO) ;

	m_fFirstMoveMsg = TRUE;

	// be sure this is NULL so WM_ACTIVATE will force initial selection
	m_pActiveView = NULL;

	// set up pushpin. This does a SubclassDlgItem call
	if (!m_btnPushPin.AutoLoad(IDC_GOTO_PUSHPIN, this, TRUE)) 
	{
		CString str;
		str.LoadString(IDS_ERROR_NO_GOTOITEMS);
		AfxMessageBox(str, MB_OK | MB_ICONEXCLAMATION);
		EndDialog(IDCANCEL);  // enddialog in Initdialog works even for a modeless dialog
		return FALSE;
	}

	m_btnPushPin.SetChecked(theApp.m_bPinGoToDlg);
	
	// Create the ToolTip control.
	m_tooltip.Create(this);
	m_tooltip.Activate(TRUE);

	TCHAR szFullText[256];
	CString strTipText;
	AfxLoadString(ID_PROP_PUSHPIN, szFullText);
		// this is the tt text which follows the status line text
	AfxExtractSubString(strTipText, szFullText, 1, '\n');

	m_tooltip.AddTool((CWnd *)&m_btnPushPin, strTipText);

	// 2. walk the packages andd call AddGoToItems. 

	POSITION pos = theApp.m_packages.GetHeadPosition();
	while (pos != NULL)
	{
		CPackage* pPackage = (CPackage*)theApp.m_packages.GetNext(pos);
		pPackage->AddGoToItems(this);
	}

	// can't bring up dialog if nothing to see.
	if (m_gotoWhat.GetCount() < 1)
	{
		CString str;
		str.LoadString(IDS_ERROR_NO_GOTOITEMS);
		AfxMessageBox(str, MB_OK | MB_ICONEXCLAMATION);
		EndDialog(IDCANCEL);  // enddialog in Initdialog works even for a modeless dialog
		return FALSE;
	}
		
	// 3. Get the What string from the items and determine the original selection from
	//		the current editor

	// If we received a strItemInit, and it is in the list, use that as
	// the initial selection. Otherwise look for an appropriate entry

	int iInit = LB_ERR;

	if (!m_strItemInit.IsEmpty())
	 	iInit = m_gotoWhat.FindStringExact(-1, m_strItemInit); // look for exact match

	if (iInit == LB_ERR)
	{
		int i;

		for (i = 0; i < m_gotoWhat.GetCount(); i++)
		{
			CGoToItem * pItem = (CGoToItem *)m_gotoWhat.GetItemDataPtr(i);
			ASSERT (pItem != NULL);  // additem should ensure this

			// seek initial selection based on the first item that can be active
			if (pItem->CanGoViewActive(m_pActiveView))
				{
					iInit = i;
					break;  // don't need to look any longer
				}
		}

		if (iInit == LB_ERR)
			// if still no active items, arbitrarily select first in list
			iInit = 0;
	}

	ASSERT (iInit != LB_ERR);

	// 4. select the appropriate "what" entry

	m_gotoWhat.SetCurSel(iInit);

	DoSelchangeGoToWhat(); // establish current what selection. Will reset m_pActiveView as well

	CenterWindow();
	return 0;  // focus set explicitly, so return 0
}


// call this from CPackage:AddGoToItems for each item to add (editor-
// specific items should be added even if the right kind of editor 
// is not currently added.

// Note that we screen these entries carefully before adding them, so we can trust them later.
void CGoToDialog::AddItem(CGoToItem *pItemNew)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (pItemNew != NULL);  // warning to implementor in package (harmless though: bobz)
	if (pItemNew != NULL)
	{
		LPCTSTR szNew;

		szNew = pItemNew->GetItemString();	
		ASSERT(szNew != NULL);	
		if (szNew != NULL)	
		{
			// disallow duplicate names in list. User should never see this error

			int i;	
			CGoToItem * pItem;
			LPCTSTR szInList;
			for (i = 0; i < m_gotoWhat.GetCount(); i++)
			{
				pItem = (CGoToItem *)m_gotoWhat.GetItemDataPtr(i);
				szInList = pItem->GetItemString();
				// lstrcmp should be ok even for dbcs since it is a byte by byte comparison bobz
				if (lstrcmp(szNew, szInList) == 0)  // same
				{
					ErrorBox(ERR_Duplicate_AddItem, szNew);
					goto LRet;
				}
			}

			// ok - so add it

			i = m_gotoWhat.AddString(szNew);
			if (i != LB_ERR)
				m_gotoWhat.SetItemDataPtr(i, (void *)pItemNew);
		}
	}
LRet:
	m_cLockSelectAtActivate--;  // allow reset on activation
}

// call this from the CGoToItem callbacks to change the style of buttons
// being used. (This must be called from CGoToItem::OnSelect at the very least!)

void CGoToDialog::SetButtonStyle (BUTTON_STYLE buttonstyle)
{
m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

#ifdef DEBUG
	fOnSelCalledButtonStyle = TRUE;  // for assert that OnSelect called me
#endif

	if (buttonstyle != m_bsCur)
	{
		CString str;
		if (buttonstyle == bsGoTo)
		{
			str.LoadString(IDS_GOTO_GOTO);
			GetDlgItem(ID_GOTO_GOTOANDNEXT)->SetWindowText(str);
			// 26 Jun 96 - This button needs two different help context ids.
			// The ids can be found in Shell.hid.
			GetDlgItem(ID_GOTO_GOTOANDNEXT)->SetWindowContextHelpId(HIDC_GOTO_GOTO) ;
		}
		else
		{
			ASSERT(buttonstyle == bsNextPrev);
			str.LoadString(IDS_GOTO_NEXT);
			GetDlgItem(ID_GOTO_GOTOANDNEXT)->SetWindowText(str);
			GetDlgItem(ID_GOTO_GOTOANDNEXT)->SetWindowContextHelpId(HIDC_GOTO_NEXT) ;
		}

	m_bsCur = buttonstyle;
	}
	// reset possible changed enable states
	GetDlgItem(ID_GOTO_GOTOANDNEXT)->EnableWindow(TRUE);
	BOOL fEnablePrev = (buttonstyle == bsNextPrev);
	GetDlgItem(ID_PREVIOUS)->EnableWindow(fEnablePrev);

	m_cLockSelectAtActivate--;  // allow reset on activation

}

// call this from the CGoToItem callbacks to change the style of selection control
// being used. (This must be called from CGoToItem::OnSelect at the very least!)

void CGoToDialog::SetControlStyle (CONTROL_STYLE controlstyle)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated


#ifdef DEBUG
	fOnSelCalledControlStyle = TRUE;  // for assert that OnSelect called me
#endif

	ASSERT (controlstyle != csUninit);
	if (controlstyle != m_csSelection)  // only change stuff if changed
	{
		m_csSelection = controlstyle;

		if (m_pctlSelection != NULL) // hide previous control
			m_pctlSelection->ShowWindow(SW_HIDE);

		if (controlstyle == csDropList)
			m_pctlSelection = &m_gotoList;
		else if (controlstyle == csDropCombo)
			m_pctlSelection = &m_gotoCombo;
		else if (controlstyle == csEdit)
			m_pctlSelection = &m_gotoEdit;
		else
			{
			ASSERT(controlstyle == csNone);
			m_pctlSelection = NULL;
			goto LRet;  // no need to set up control
			}

		m_pctlSelection->EnableWindow(TRUE);
		m_pctlSelection->InvalidateRect(NULL);  // NT sometimes does not redraw
		m_pctlSelection->ShowWindow(SW_SHOW);
		
	}
LRet:
	m_cLockSelectAtActivate--;  // allow reset on activation

}
 
// call this to change the selection prompt. (This must be called from 
// CGoToItem::OnSelect at the very least!)
void CGoToDialog::SetPrompt (const TCHAR * szPrompt)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

#ifdef DEBUG
	fOnSelCalledPrompt = TRUE;  // for assert that OnSelect called me
#endif

	ASSERT (szPrompt != NULL);
	if (szPrompt == NULL)
		m_gotoCaption.SetWindowText("");
	else
		m_gotoCaption.SetWindowText(szPrompt);

	m_gotoCaption.EnableWindow(TRUE);

	m_cLockSelectAtActivate--;  // allow reset on activation

}
 
// call this to enable or disable dialog controls depending on whether the item
// can be active based on the active editor. This is called internally after
// CGoToItem::CanGoViewActive is called. Ignored if pGoToItem is not the current
// selection in the Go To What list.
void CGoToDialog::SetItemEnabled(CGoToItem *pGoToItem, BOOL fEnabledItem)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT(m_pGoToItemCur == pGoToItem); // harmless warning to implementor something may be wrong
	if (m_pGoToItemCur == pGoToItem)
	{
		// always do the enables in case some package messes up
		ASSERT(m_pctlSelection != NULL || m_csSelection == csNone); 

		GetDlgItem(ID_GOTO_GOTOANDNEXT)->EnableWindow(fEnabledItem);
		GotoDlgCtrl(GetDlgItem(ID_GOTO_GOTOANDNEXT)); // keeps default appearance better
		if (m_bsCur == bsNextPrev)  //otherwise this button always disabled
			GetDlgItem(ID_PREVIOUS)->EnableWindow(fEnabledItem);
		else
			GetDlgItem(ID_PREVIOUS)->EnableWindow(FALSE);

		m_gotoCaption.EnableWindow(fEnabledItem);
		if (m_pctlSelection != NULL)
		{
			m_pctlSelection->EnableWindow(fEnabledItem);
			GotoCtlSel();
		}

	}
	m_cLockSelectAtActivate--;  // allow reset on activation
}


// call this to change the helper text. If not called from 
// CGoToItem::OnSelect it will be blank by default.
void CGoToDialog::SetHelperText (const TCHAR * szHelperText)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	ASSERT (szHelperText != NULL);
	if (szHelperText == NULL)
		m_helpText.SetWindowText("");
	else
		m_helpText.SetWindowText(szHelperText);

	m_cLockSelectAtActivate--;  // allow reset on activation
}

// call this to empty the selection list when csDropList or csDropCombo are used.
void CGoToDialog::EmptyList ()
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	BOOL fValid;

	fValid = (m_pctlSelection != NULL) && 
			 (m_csSelection == csDropList || m_csSelection == csDropCombo);
	ASSERT (fValid);

	if (fValid)
		{
		((CComboBox *)m_pctlSelection)->ResetContent();
		}

	m_cLockSelectAtActivate--;  // allow reset on activation
}

// call this to add a string to the selection list
void CGoToDialog::AddString (const TCHAR * szSelect, DWORD dwItemData)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	BOOL fValid;

	fValid = (m_pctlSelection != NULL) && (szSelect != NULL) &&
			 (m_csSelection == csDropList || m_csSelection == csDropCombo);
	ASSERT (fValid);

	if (fValid)
	{
		int i;

		CComboBox * pCombo = (CComboBox *)m_pctlSelection;
		i = pCombo->AddString(szSelect);
		if (dwItemData != 0 && i != CB_ERR && i != CB_ERRSPACE)
			pCombo->SetItemData(i, dwItemData);
	}
	m_cLockSelectAtActivate--;  // allow reset on activation

}

// call this to lock/unlock the selection list when csDropList or csDropCombo are used.
// Typically called while the control is being filled.
void CGoToDialog::LockList (BOOL fLock)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	BOOL fValid;

	fValid = (m_pctlSelection != NULL) && (m_csSelection == csDropList || m_csSelection == csDropCombo);
	ASSERT (fValid);
	if (fValid)
		m_pctlSelection->SetRedraw(!fLock);

	m_cLockSelectAtActivate--;  // allow reset on activation
}

// call this to get the dialog id of the "selection control" in the rare
// case when the List and Select functions are not adequate
// pcs will be set to the control style of the control, since it can be
// either and edit control . a combo or a list box. Use GetDlgItem to 
// get a pointer to the selection control.
// In case of csNone, we will return the id for the edit control, which will be invisible
int CGoToDialog::IdCtlSelection (CONTROL_STYLE *pcs)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	CString str;
	int id;

	*pcs = 	m_csSelection;
	GetSelectData(str, NULL, &id, NULL, FALSE /* fComboSelChange */);

	m_cLockSelectAtActivate--;  // allow reset on activation

	return id;
}

// call one of these to initialize the current selection control
void CGoToDialog::Select (const TCHAR * szSelect)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	BOOL fValid;

	fValid = (m_pctlSelection != NULL) && (szSelect != NULL) 
		 && (m_csSelection == csEdit || m_csSelection == csDropCombo);
	ASSERT (fValid);

	if (fValid)
	{
		m_pctlSelection->SetWindowText(szSelect);
	}

	m_cLockSelectAtActivate--;  // allow reset on activation
}

void CGoToDialog::Select (int iSelect)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	BOOL fValid;

	fValid = (m_pctlSelection != NULL) && (iSelect >= 0) 
		 && (m_csSelection == csDropList || m_csSelection == csDropCombo);
	ASSERT (fValid);

	if (fValid)
	{
		CComboBox * pCombo = (CComboBox *)m_pctlSelection;
		pCombo->SetCurSel(iSelect);
	}

	m_cLockSelectAtActivate--;  // allow reset on activation
}

// call this when a CGoToItem::OnSelectChange needs to change the button state
// OR the msk values into grfButton to set the state of one or more buttons

void CGoToDialog::EnableButton (WORD grfButton, BOOL fEnable)
{
	m_cLockSelectAtActivate++; // prevent reset if we are inactivated and reactivated

	// if bsGoTo, Previous button is always disabled, so we ignore any change to that button

	if (grfButton & mskButtonGoToNext)
		GetDlgItem(ID_GOTO_GOTOANDNEXT)->EnableWindow(fEnable);

	if (grfButton & mskButtonPrevious && m_bsCur != bsGoTo)
		GetDlgItem(ID_PREVIOUS)->EnableWindow(fEnable);

	if (grfButton & mskButtonClose)
		GetDlgItem(IDCANCEL)->EnableWindow(fEnable);

	if (grfButton & mskButtonHelp)
		GetDlgItem(ID_HELP)->EnableWindow(fEnable);

	m_cLockSelectAtActivate--;  // allow reset on activation
}

void CGoToDialog::GotoCtlSel()
{
	if (m_pctlSelection != NULL && m_pctlSelection->IsWindowEnabled())
		GotoDlgCtrl(m_pctlSelection);
	else
		GotoDlgCtrl(&m_gotoWhat);
}

void CGoToDialog::PostNcDestroy()
{
	delete this;
}


/////////////////////////////////////////////////////////////////////////////
// CGoToItem

// constructor
CGoToItem::CGoToItem(CGoToDialog * pDlg)
{
	ASSERT(pDlg != NULL);
	m_pDlg = pDlg;
}

 void CGoToItem::OnSelectWhat() 
 {}

 BOOL CGoToItem::CanGoViewActive(CPartView * pActiveView)
 {
 return FALSE;
 }

 void CGoToItem::OnSelectChange(const TCHAR * szSelect, 
		BOOL fSelInList,
		DWORD dwItemData)
 {}

 BOOL CGoToItem::CanGoTo(int idDlgItemError, 
						GOTO_TYPE go, 
						const TCHAR * szSelect, 
						BOOL fSelInList,
						DWORD dwItemData)
 {
 return FALSE;
 }

 void CGoToItem::OnGoTo(GOTO_TYPE go,
						const TCHAR * szSelect,
						BOOL fSelInList,
						DWORD dwItemData)
 {}


////////////////////////////////////////////////////////////////////
// Generic goto dialog utility routines

void DoGoToDialog(int iddHelp, LPCTSTR szItemInit) 
{
	CGoToDialog * pDlgPrev = CGoToDialog::PGoToDialogCur();
	if (pDlgPrev != NULL)
		{

		CPartView *pView = (CPartView *) pDlgPrev->FromHandle(theApp.GetActiveView());
			// scroll out of the way 
		if ((pView != (CPartView *)NULL))
			pView->SetDialogPos(TRUE /* fFirstTime */, pDlgPrev->m_hWnd);
		pDlgPrev->SetFocus();
		pDlgPrev->GotoCtlSel();  // go to either the edit control or goto what list
		}
	else
	{
		CGoToDialog *pDlg = new CGoToDialog(iddHelp,  szItemInit);
		pDlg->Create(MAKEINTRESOURCE(IDD_GOTODIALOG)); // self-deleting dialog
	}

}

//
// 26 Jun 96 - ID_GOTO_GOTOANDNEXT was IDOK, however, we cannot use IDOK with
// a unique help ID, because it gets eaten inside the help.cpp. 
//
void CGoToDialog::OnGotoGotoAndNext() 
{
	// ID_GOTO_GOTOANDNEXT button can be goto or next
	GOTO_TYPE go = (m_bsCur == bsGoTo ? goGoTo: goNext);
	OnOKPrevious(go);  // OnOkPrevious sets m_cLockSelectAtActivate. don;t need it here	
}

void CGoToDialog::OnActivateApp(BOOL bActive, HTASK hTask) 
{
	
	// this is called when context help has gone away. If we were unpinned at
	// context help time, we force a pin so deactivation will not close
	// the dialog. Since we can't otherwise tell when the help goes away, we
	// set a flag and reset here and in OnActivate bobz
	if (bActive)
	{
		C3dDialog::OnActivateApp(bActive, hTask);
	
		// we are being reactivated indirectly after context help and had been unpinned
		// so we'd like to take the dialog down but can't tell if we would be reactivated so
		// jsut turn off the flag.
		if (m_fForcePinForHelp)
		{
			m_fForcePinForHelp = FALSE;
		}
	}  

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\help.cpp ===
// help.cpp : implementation of Olympus help support
//

#include "stdafx.h"

#include "shell.h"
#include "resource.h"

//#define NO_XBOX_F1
#ifndef NO_XBOX_F1
#include "xboxhelp.h"
#include "main.h"
#endif

#ifdef __DEVHELP98__ 
#include "helpsys.h" //TODO:[der] Move this file
#include "helpsysid.c"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Constants
//

// The following are used to enable the PSS Technical Support Menu.
const wchar_t c_pssHelpFile[] = L"vsintro.chm";
const long c_pssContextId = 151001; // This id can be found in %devbin%\htmlhelp\v6\include\ctxids.h

///////////////////////////////////////////////////////////////////////////////
//
// Prototypes
//
// Helper function for DoContextHelpMenu
CWnd* ChildWindowFromPointAvoidGroupBoxes(CWnd*, const CPoint& point);

#ifdef __DEVHELP98__ 
IVsHelpSystem* GetHelpInterface(BOOL bDisplayNoHelpMsg = TRUE);
#endif 

void CancelModes();
BOOL HelpDebug();
BOOL HelpDebug(LPCTSTR szKeyword);
BOOL HelpDebug(LPCTSTR szKeyword, LPCTSTR szFile);

///////////////////////////////////////////////////////////////////////////////
//
//
//
LPCTSTR HelpFileFromID(DWORD dwId, UINT type)
{
	LPCTSTR szFileName = NULL;
	EXESTRING_INDEX iExeString = DefaultAppHelpFile;
	CPackage::HELPFILE_TYPE hft = CPackage::APPLICATION_HELP;
	CPackage::RANGE_TYPE minRange;
	CPackage::RANGE_TYPE maxRange;
	switch (type)
	{
	case HELPTYPE_CONTROL:
		hft = CPackage::CONTROL_HELP;
		iExeString = DefaultControlHelpFile;
		// fall through
	case HELPTYPE_DIALOG:
		minRange = CPackage::MIN_RESOURCE;
		maxRange = CPackage::MAX_RESOURCE;
		break;

	case HELPTYPE_WINDOW:
		minRange = CPackage::MIN_WINDOW;
		maxRange = CPackage::MAX_WINDOW;
		break;

	case HELPTYPE_COMMAND:
		minRange = CPackage::MIN_COMMAND;
		maxRange = CPackage::MAX_COMMAND;
		break;

	default:
		ASSERT(FALSE);
	}

	POSITION pos = theApp.m_packages.GetHeadPosition();
	while (szFileName == NULL && pos != NULL)
	{
		CPackage* pPackage = (CPackage*)(theApp.m_packages.GetNext(pos));
		ASSERT(pPackage != NULL);
		if (pPackage->m_flags & PKS_HELPFILE)
		{
			if ((dwId >= pPackage->GetIdRange(minRange)) &&
				(dwId <= pPackage->GetIdRange(maxRange)))
			{
				szFileName = pPackage->GetHelpFileName(hft);
			}
		}
	}
	if (szFileName == NULL)
	{
		// if no other filename is found, use the exe's helpfile
		szFileName = theApp.GetExeString(iExeString);
	}
	ASSERT(szFileName != NULL);
	return szFileName;
}

///////////////////////////////////////////////////////////////////////////////
// Context aka 'Control' help

// Map of Control ID to Help ID 
//
// Required by WinHelp HELP_CONTEXTMENU and HELP_WM_HELP calls
// Terminated by zero pair.
//
// -1 for HID of a pair disables the context help/context menu.
//
static DWORD rgHID[] = {
	(DWORD)-2, (DWORD)-1,
	0,0
};

// Synthesize the WinHelp ID map for the current/clicked-on control
// based on HelpID properties in the control. If we found the help
// ID in something other than hwndCtrl, return it's hwnd through 
// pwndHelp.
//
static BOOL SetHID(HWND, HWND hwndCtrl, HWND * phwndHelp)
{
	DWORD idCtrl = ::GetDlgCtrlID(hwndCtrl);
	if (0 == idCtrl)
		return FALSE;
	if (phwndHelp)
		*phwndHelp = hwndCtrl;
	DWORD idHelp = ::GetWindowContextHelpId(hwndCtrl);
	rgHID[0] = idCtrl;
	rgHID[1] = idHelp ? idHelp : (DWORD)-1;

	CString strClass;
	::GetClassName(hwndCtrl, strClass.GetBuffer(16), 16);
	strClass.ReleaseBuffer();

	// Special behavior for standard buttons
	if (strClass.CompareNoCase("Button") == 0)
	{
		switch (idCtrl)
		{
		case IDOK:
		case IDCANCEL:
			// Fall through. Uncomment below to use standard help.
			//
			// WinHelp has built-in Help for standard buttons, so 
			// we'll use that.
			//rgHID[0] = (DWORD)-2;
			//rgHID[1] = (DWORD)-1;
			//return TRUE;
			//break;
		case IDCLOSE:
		case IDHELP:
			// Convention for standard: help id is control id
			rgHID[0] = rgHID[1] = idCtrl;
			return TRUE;

		default:
			break;
		}
	}  
	else if (strClass.CompareNoCase("Static") == 0)
  	// Label: probe for next control in tab order for help id
	//
	// We are using these rules for this: we check if the wndow class is "Static"
	// this handles IDC_STATIC and dynamic labels. We are explicitly NOT
	// handling Group Boxes in this code, but we could by adding the class test.
	// (Button with BS_GROUPBOX style). The old code did this for all IDC_STATIC items
	// and included group boxes.
	// So if it is a static item, we get the next control's help if
	// EITHER the id is IDC_STATIC OR there is no help id specified. If you want to
	// specify a help id you may not use IDC_STATIC, because winhelp does not like it.
	// bobz 9/25/96
	//
	// For dynamic labels, we could add some conventional IDs that get the help 
	// id probing, and can be addressed individually for text-changing purposes.
	// case IDC_DYNALABEL:

	// This code is now complicated by the fact that GetNextDlgTabItem requires the WS_TABSTOP style to
	// be set. However, in some cases, we want to find non-tabstop items because the label is labelling
	// a static item. To fix this problem, we will first manually probe forward to find statics with the
	// right configuration. If this search fails, or if we first meet a non-static, then we give up and
	// revert to the normal mechanism. martynl Oct 07 96
	//
	{
		if (idHelp == 0 || idCtrl == 65535 || idCtrl == 0xffffffff)	 // idctrl values for IDC_STATIC in Win95 and Win NT respectively
		{
			// probe forward for labelled static
			HWND hwndNext=hwndCtrl;		//
			BOOL bFinished=FALSE;		// TRUE if we hit a non-static, or a tabstopped control

			while(!bFinished)
			{
				// get the next control
				hwndNext=::GetNextWindow(hwndNext,GW_HWNDNEXT);

				// Nothing next, so this can't be used
				if(hwndNext!=NULL)
				{
					int nStyle=::GetWindowLong(hwndNext, GWL_STYLE);

					// next was a tabstop, which means normal means should be used
					if((nStyle & WS_TABSTOP)==0)
					{
						CString strNextClass;
						::GetClassName(hwndNext, strNextClass.GetBuffer(16), 16);
						strNextClass.ReleaseBuffer();

						// next wasn't static means normal mechanisms should be used
						if(strNextClass.CompareNoCase("Static") == 0)
						{
							DWORD idNextCtrl = ::GetDlgCtrlID(hwndNext);

							// next has bad ctrl ids means keep probing
							if (idNextCtrl != 65535 && idNextCtrl != 0xffffffff)	 // idctrl values for IDC_STATIC in Win95 and Win NT respectively
							{
								// now actually get help id
								DWORD dwId = ::GetWindowContextHelpId(hwndNext);
								if (dwId)
								{
									if (phwndHelp)
										*phwndHelp = hwndNext;
									rgHID[0] = idNextCtrl;
									rgHID[1] = dwId;
									return TRUE;
								}
								else
								{
									// continue probing forward
								}
							}
							else
							{
								// continue probing forward
							}
							
						}
						else
						{
							bFinished=TRUE;
						}
					}
					else
					{
						bFinished=TRUE;
					}
				}
				else
				{
					bFinished=TRUE;
				}
			}

			// probe forward for tabstop
			//hwndNext = ::GetNextDlgTabItem(hwndDlg, hwndCtrl, 0);
			if (hwndNext)
			{
				DWORD dwId = ::GetWindowContextHelpId(hwndNext);
				if (dwId)
				{
					if (phwndHelp)
						*phwndHelp = hwndNext;
					rgHID[0] = ::GetDlgCtrlID(hwndNext);
					rgHID[1] = dwId;
					return TRUE;
				}
			}
		}
	}

	return idHelp != 0;
}

///////////////////////////////////////////////////////////
//
// 
//
BOOL GetHID(HWND hwndDlg, HWND hwndCtrl, HWND * phwndHelp, DWORD* hid)
{
	BOOL bRetVal = SetHID(hwndDlg, hwndCtrl, phwndHelp);
	*hid = (DWORD)(LPVOID)rgHID;
	return bRetVal;
}
	
///////////////////////////////////////////////////////////
//
// GetFullHelpFile
// Look for szHelpfile in several places:
// - as specified
// - MSDEV\HELP
// - MSDEV\BIN
// - MSDEV\BIN\IDE
// if we don't find it anywhere around here, we let WinHelp fend for itself.

void GetFullHelpFile( LPCTSTR szHelpfile, CString & strHelp)
{
    if (FileExists(szHelpfile))
    {
        strHelp = szHelpfile;
        return;
    }

    CString strDir;
    GetHelpDir(strDir);
    strDir += '\\';

    // Try MSDEV\HELP\file
    CString str(strDir);  
    str += szHelpfile;
    if (FileExists(str))
    {
        strHelp = str;
        return;
    }

	// Convert "C:\FOO\BIN\MSDEV.EXE" to "C:\FOO\BIN\"
    ::GetModuleFileName(NULL, strDir.GetBufferSetLength(_MAX_PATH), _MAX_PATH);
	strDir.ReleaseBuffer();
	int i = strDir.ReverseFind('\\');
	ASSERT(i != -1);
	strDir.GetBufferSetLength(i + 1);
	strDir.ReleaseBuffer();

	// Try "C:\FOO\BIN\file"
    str = strDir + szHelpfile;
    if (FileExists(str))
    {
        strHelp = str;
        return;
    }

    // Now try "C:\FOO\BIN\extdir\file"
    str = strDir + theApp.GetExeString(DefaultExtensionDir);
    str += '\\';
    str += szHelpfile;
    if (FileExists(str))
    {
        strHelp = str;
        return;
    }

    // lastly, let WinHelp fend for itself
    strHelp = szHelpfile;
}

///////////////////////////////////////////////////////////
//
// This function handles the right mouse button context help
// for dialog boxes.
//
void DoHelpContextMenu(CWnd * pDialog, UINT idDlg, CPoint pt)
{
	// Orion Bug 12420	
	//	pDialog->ScreenToClient(&pt);
	//	CWnd * pCtrl = pDialog->ChildWindowFromPoint(pt, CWP_SKIPINVISIBLE);
	CWnd* pCtrl = ChildWindowFromPointAvoidGroupBoxes(pDialog, pt) ;
	if (pCtrl)
	{
		HWND hwndHelp;
		if (::SetHID(pDialog->m_hWnd, pCtrl->m_hWnd, &hwndHelp))
		{
            CString strHelp;
            GetFullHelpFile(HelpFileFromID(idDlg, HELPTYPE_CONTROL), strHelp);
            ASSERT(!strHelp.IsEmpty());
			if (HelpDebug())
			{
				char sz[34];
				_ultoa(rgHID[1], sz, 10);
				HelpDebug(sz, strHelp);
				return;
			}
	        ::WinHelp(hwndHelp, strHelp, HELP_CONTEXTMENU, (DWORD)(LPVOID)rgHID);
		}
	}
}

///////////////////////////////////////////////////////////
//
// This function handles getting the context help for a dialog item.
// it takes a pointer to the dialog, the id of the dialog and a
// pointer to the HELPINFO structure.
//
// Currently, it always returns TRUE ;
//
BOOL DoHelpInfo(CWnd * pDialog, UINT idDlg, HELPINFO* pInfo)
{
	if (pInfo->iContextType == HELPINFO_WINDOW)
	{
		HWND hwndHelp = NULL;
		HWND hwndCtrl = (HWND)pInfo->hItemHandle;
		if (!::SetHID(pDialog->m_hWnd, hwndCtrl, &hwndHelp))
		{
			// default F1 to dialog help in main help window
//			CWnd::OnHelp();
			return 1;
		}

        CString strHelp;
        GetFullHelpFile(HelpFileFromID(idDlg, HELPTYPE_CONTROL), strHelp);
        ASSERT(!strHelp.IsEmpty());
			if (HelpDebug())
			{
				char sz[34];
				_ultoa(rgHID[1], sz, 10);
				HelpDebug(sz, strHelp);
				return 1;
			}
		ASSERT(hwndHelp != NULL);
   		::WinHelp(hwndHelp, strHelp, HELP_WM_HELP, (DWORD)(LPVOID)rgHID);
	}
	return 1;
}

///////////////////////////////////////////////////////////
//
// 
//
void CMainFrame::WinHelp(DWORD dwData, UINT nCmd)
{
	UINT ht = HELPTYPE_DIALOG;
	// synthesize HELPTYPE and possibly un-munge id munged by MFC
	if ((dwData > HID_WND_TEXT) && (dwData < HID_WND_TEXT + 0x100))
	{
		ht = HELPTYPE_WINDOW;
	}
	else if (dwData > HID_BASE_RESOURCE)
	{
		dwData -= HID_BASE_RESOURCE;
		// We get this when nothing reasonable has the focus, or
		// some other bizarre circumstances -- we'll ignore this
		// because there's no good help to display.
		if (dwData == IDR_MAINFRAME)
			return;
	}
	else if (dwData == HID_BASE_RESOURCE)
	{
		// no id = no help
		return;
	}
	else if (dwData > HID_BASE_COMMAND)
	{
		return; // ignore commands
//              dwData -= HID_BASE_COMMAND;
//              ht = HELPTYPE_COMMAND;
	}
	theApp.HelpOnApplication(dwData, ht);
}

///////////////////////////////////////////////////////////
//
// 
//
void CMainFrame::OnFastHelp ()
{
	theApp.m_bFastHelp = TRUE;

	CMDIFrameWnd::OnHelp();

	theApp.m_bFastHelp = FALSE;
}

///////////////////////////////////////////////////////////
//
// 
//
void CMainFrame::OnHelpContents()
{
	theApp.HelpContents();
}

///////////////////////////////////////////////////////////
//
// 
//
#ifdef __DEVHELP98__
void CMainFrame::OnHelpKeywords()
{
	// If the current PartView has a search word to offer, use it.
/* BUG 10593
	CString strKeyword;
	CPartFrame* pFrame = (CPartFrame*) MDIGetActive();
	if (pFrame && pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
	{
		CPartView* pView = (CPartView*)pFrame->GetActiveView();
		ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));

		pView->GetHelpWord(strKeyword);
	}
*/
	theApp.HelpOnKeyword(NULL);
}
#endif

///////////////////////////////////////////////////////////
//
// 
//
void CMainFrame::OnHelpSearch()
{
	// If the current PartView has a search word to offer, use it.
	CString strSearch;
	CPartFrame* pFrame = (CPartFrame*) MDIGetActive();
	if (pFrame && pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
	{
		CPartView* pView = (CPartView*)pFrame->GetActiveView();
		ASSERT(pView->IsKindOf(RUNTIME_CLASS(CPartView)));

		pView->GetHelpWord(strSearch);
	}

	theApp.HelpFind(strSearch, HF_Default);
}

///////////////////////////////////////////////////////////
//
// 
//
void CancelModes()
{
	// All of the following code is basically from CWnd::WinHelp.  It
	// just cancels special modes and mouse capture.
	theApp.m_bHelpMode = FALSE;

	CMainFrame* pMainFrame = (CMainFrame*)theApp.m_pMainWnd;
	pMainFrame->ExitHelpMode();

	/* cancel any tracking modes */
	pMainFrame->SendMessage(WM_CANCELMODE);
	pMainFrame->SendMessageToDescendants(WM_CANCELMODE, 0, 0, TRUE, TRUE);

	/* attempt to cancel capture */
	HWND hWndCapture = ::GetCapture();
	if (hWndCapture != NULL)
		::SendMessage(hWndCapture, WM_CANCELMODE, 0, 0);
}

///////////////////////////////////////////////////////////
//
// GetHelpInterface
//
#ifdef __DEVHELP98__ 
	static IVsHelpSystem* s_pIVsHelpSystem = NULL;

IVsHelpSystem* GetHelpInterface(BOOL bDisplayNoHelpMsg)
{
	if( NULL == s_pIVsHelpSystem )
	{
		HRESULT hr = theApp.GetService(SID_SHelpService, IID_IVsHelpSystem, (void**)&s_pIVsHelpSystem) ;
		if (FAILED(hr) || (s_pIVsHelpSystem == NULL))
		{
			if( bDisplayNoHelpMsg )
			{
				ASSERT(s_pIVsHelpSystem == NULL) ;
				CString strNoHelp;
				VERIFY(strNoHelp.LoadString(IDS_HELPLESS));
				MsgBox(Information, strNoHelp);
			}
		}
	}
	return s_pIVsHelpSystem ;
}
#endif

///////////////////////////////////////////////////////////
//
// 
//
void ReleaseHelpInterface()
{
#ifdef __DEVHELP98__ 
	if(s_pIVsHelpSystem)
	{
		s_pIVsHelpSystem->Release() ;
		s_pIVsHelpSystem = NULL;
	}
#endif
}

///////////////////////////////////////////////////////////
//
// HelpContents
//
void CTheApp::HelpContents()
{
	if (UseExtHelp())
	{
		HelpContentsExt();
		return;
	}
#ifdef __DEVHELP98__ 
	IVsHelpSystem* pIVsHelpSystem = GetHelpInterface();
	if (pIVsHelpSystem)
	{
		pIVsHelpSystem->ActivateHelpSystem(0) ;
	}
#endif
}


///////////////////////////////////////////////////////////
//
// HelpFind
//
void CTheApp::HelpFind(LPCTSTR szKeyword, HELP_FIND_PAGE hf)
{
	if (UseExtHelp())
	{
		HelpIndexExt(szKeyword);
		return;
	}
#ifdef __DEVHELP98__ 
	ASSERT(hf == HF_Default) ; //TODO: [der] Remove HELP_FIND_PAGE

	IVsHelpSystem* pIVsHelpSystem = GetHelpInterface();
	if (pIVsHelpSystem)
	{		
		BSTR bstrQuery = NULL ;
		if ((szKeyword != NULL) && (_tcslen(szKeyword) > 0))
		{
			// We need to trim the keyword. Easiest way is in a CString.
			CString strKeyword(szKeyword) ;
			strKeyword.TrimLeft() ;
			strKeyword.TrimRight() ;
			
			if (!strKeyword.IsEmpty())
			{
				// Put the keyword (if it exists) into a BSTR. 
				bstrQuery = strKeyword.AllocSysString() ;
				ASSERT(bstrQuery) ;
			}
		}

		HRESULT hr = pIVsHelpSystem->FullTextSearchDlg(	/*BSTR*/ bstrQuery, 
														/*dwFlags*/ NULL,
														/*lpContext*/ NULL);
		ASSERT(SUCCEEDED(hr)) ;

		if (bstrQuery)
		{
			SysFreeString(bstrQuery) ;
		}
	}
#endif //__DEVHELP98__
}

///////////////////////////////////////////////////////////
//
// HelpOnApplication
//
void CTheApp::HelpOnApplication(DWORD dwID, UINT type, LPCTSTR szFileName)
{
#ifdef __DEVHELP98__ 
	USES_CONVERSION;
#endif

	TRACE("Help: id = 0x%x  type = 0x%x\n", dwID, type);
	// if the type is not HELP_FINDER or HELP_CONTENTS and the context is 0,
	// beep and return
	if (HELP_CONTENTS != type && HELP_FINDER != type && dwID == 0)
	{
		// Never a valid ID
		::MessageBeep(0);
		return;
	}

	// Now we have to figure out what filename to look in
	if (szFileName == NULL)
		szFileName = HelpFileFromID(dwID, type);

	_TCHAR szExt[_MAX_EXT];
	_splitpath(szFileName, NULL, NULL, NULL, szExt);
	if (_tcsicmp(szExt, ".hlp") == 0)
	{
		// Use WinHelp
		CString strHelpFile;
		GetFullHelpFile(szFileName, strHelpFile);
		if (HelpDebug())
		{
			char sz[34];
			_ultoa(dwID, sz, 10);
			HelpDebug(sz, strHelpFile);
			return;
		}

		switch (type)
		{
		// Map old IV help types to HELP_CONTEXT
		case HELPTYPE_DIALOG:  
		case HELPTYPE_WINDOW:
		case HELPTYPE_COMMAND: 
			type = HELP_CONTEXT;
			break;

		// Pass through standard Winhelp command types (except TCARD)
		// From WINUSER.H
		case HELP_CONTEXT:
		case HELP_QUIT:
//		case HELP_INDEX: // same as HELP_CONTENTS
		case HELP_CONTENTS:
		case HELP_HELPONHELP:
		case HELP_SETINDEX:
//		case HELP_SETCONTENTS: // same as HELP_SETINDEX
		case HELP_CONTEXTPOPUP:
		case HELP_FORCEFILE:
		case HELP_KEY:
		case HELP_COMMAND:
		case HELP_PARTIALKEY:
		case HELP_MULTIKEY:
		case HELP_SETWINPOS:
		case HELP_CONTEXTMENU:
		case HELP_FINDER:
		case HELP_WM_HELP:
		case HELP_SETPOPUP_POS:
			break;

		// Ignore garbage
		default:
			ASSERT(0);// Shouldn't get anything but the known types above.
			return;
		}
		// All our help is displayed in this secondary window
		strHelpFile += _T(">VSMain");
		::WinHelp(AfxGetMainWnd()->m_hWnd, strHelpFile, type, dwID);
	}
	else
	{
		if (dwID == 0)
		{
			// Never a valid ID
			::MessageBeep(0);
			return;
		}

		// Use InfoViewer
		TCHAR szContext[50];
		LPCTSTR sz;

		// make context string from type and id
		switch (type)
		{
		case HELPTYPE_DIALOG:  sz = _T("HID_DIALOG_"); break;
		case HELPTYPE_WINDOW:  sz = _T("HID_WINDOW_"); break;
		case HELPTYPE_COMMAND: sz = _T("HID_COMMAND_"); break;
		default:
			sz = _T("HID_");
			ASSERT(0);
			break;
		}
		_tcscpy(szContext,sz);
		_ultot(dwID, _tcschr(szContext,0), 10);

		TRACE("Help: context='%s' file='%s'\n", (LPCTSTR)szContext, szFileName);

		if (HelpDebug(szContext, szFileName))
			return;

#ifdef __DEVHELP98__ 
		// We need to do a keyword help lookup.
	IVsHelpSystem* pIVsHelpSystem = GetHelpInterface();
	if (pIVsHelpSystem)
	{		
		LPOLESTR str = T2OLE(szContext) ;
		HRESULT hr = pIVsHelpSystem->ALinkSearch(str, 
											/*dwFlags*/ NULL,
											/*lpContext*/ NULL);

		ASSERT(SUCCEEDED(hr)) ;
	}
#endif //__DEVHELP98__
	}
	CancelModes();
}

///////////////////////////////////////////////////////////
//
// HelpOnKeyword
//
void CTheApp::HelpOnKeyword(LPCTSTR szKeyword, BOOL bAlink /*= FALSE*/, REF_DISPLAY_TYPE dt)
{

	if (HelpDebug(szKeyword))
		return;

	if (UseExtHelp())
	{
		HelpOnKeywordExt(szKeyword);
		return;
	}

#ifndef NO_XBOX_F1
	// Keywords are only built for english systems.
	if ( !IsJapaneseSystem() && DoXboxHelp(szKeyword) ) 
		return;
#endif // NO_XBOX_F1

#ifdef __DEVHELP98__ 
	IVsHelpSystem* pIVsHelpSystem = GetHelpInterface();
	if (pIVsHelpSystem)
	{		
		HRESULT hr = E_FAIL ;

		// We need to trim the keyword. Easiest way is in a CString.
		CString strKeyword(szKeyword) ;
		strKeyword.TrimLeft() ;
		strKeyword.TrimRight() ;

		if (!strKeyword.IsEmpty())
		{
			// Put the keyword (if it exists) into a BSTR. 
			BSTR bstrQuery = strKeyword.AllocSysString() ;
			ASSERT(bstrQuery) ;

			if (bAlink)
			{
				hr = pIVsHelpSystem->ALinkSearch(	bstrQuery, 
													/*dwFlags*/ NULL,
													/*lpContext*/ NULL);

			}
			else
			{
				hr = pIVsHelpSystem->KeywordSearch(	bstrQuery, 
													/*dwFlags*/ NULL,
													/*lpContext*/ NULL);
			}

			// Cleanup
			if (bstrQuery)
			{
				SysFreeString(bstrQuery) ;
			}
		}
		else
		{
			// No keyword. Do a KeywordSearchDlg
			hr = pIVsHelpSystem->KeywordSearchDlg(	NULL, 
													/*dwFlags*/ NULL,
													/*lpContext*/ NULL);
		}


		ASSERT(SUCCEEDED(hr)) ;
	}
#endif
	CancelModes();
}


///////////////////////////////////////////////////////////
//
// HelpDebug
//

//#ifdef _DEBUG
BOOL HelpDebug()
{
	// Determine whether the HelpDebug registry flag is set.
	if (GetRegInt("Help", "HelpDebug", FALSE))
		return TRUE;

#ifndef _SHIP
	// If we can confirm that there's no entry (because it gives us
	// the default regardless of whether that default is TRUE or FALSE)
	// then go ahead and create an entry; this will make it easier for
	// the UE team to modify the setting for the first time.
	else if (GetRegInt("Help", "HelpDebug", TRUE))
		WriteRegInt("Help", "HelpDebug", FALSE);
#endif

	return FALSE;
}

///////////////////////////////////////////////////////////
//
// HelpDebug
//
BOOL HelpDebug(LPCTSTR szKeyword)
{
	if (HelpDebug())
	{
		char sz [255];
		wsprintf(sz, "Help requested on keyword '%s'", szKeyword);
		MsgBox(Information,sz);
		return TRUE;
	}

	return FALSE;
}

///////////////////////////////////////////////////////////
//
// Help
//
BOOL HelpDebug(LPCTSTR szItem, LPCTSTR szFile)
{
	if (HelpDebug())
	{
		_TCHAR sz [255];
		_sntprintf(sz, sizeof(sz), _T("Help requested on '%s' in file '%s'"), 
			szItem, (szFile != NULL) ? szFile : _T("(unknown)"));
		MsgBox(Information,sz);
		return TRUE;
	}

	return FALSE;
}
//#endif


///////////////////////////////////////////////////////////////////////////
//
// WinHelp services
//
///////////////////////////////////////////////////////////
//
// Construct default help directory
//
void GetHelpDir(CString & strHelpDir)
{
	// Our best-guess default is a "help" directory which is at the same
	// level in the directory hierarchy as the current executable.
	
	::GetModuleFileName(NULL, strHelpDir.GetBufferSetLength(_MAX_PATH), _MAX_PATH);
	strHelpDir.ReleaseBuffer();

	// Convert C:\FOO\BIN\MSVC.EXE to C:\FOO\HELP.
	int i = strHelpDir.ReverseFind('\\');
	ASSERT(i != -1);
	strHelpDir.GetBufferSetLength(i);
	strHelpDir.ReleaseBuffer();

	// Now we have C:\FOO\BIN
	i = strHelpDir.ReverseFind('\\');
	if (i != -1)
	{
		strHelpDir.GetBufferSetLength(i);
		strHelpDir.ReleaseBuffer();
	}

	// Now we have C:\FOO (or just "C:", if the exe was in the root).
	strHelpDir += _TEXT("\\HELP");

}

///////////////////////////////////////////////////////////////////////////
//
// PSS Help
//
BOOL GetPSSHelpFile(CString & strHelpFile)
{
	// Used to enable the menu.
	return TRUE ;
/*
	GetHelpDir(strHelpFile);
	strHelpFile += _TEXT("\\pss.hlp");
	if (_access(strHelpFile, 04) == 0)      // check for read privs
		return TRUE;
	else

		return FALSE;
*/
}

void CVshellPackage::OnHelpPSS()
{
#ifdef __DEVHELP98__ 
	IVsHelpSystem* pIVsHelpSystem = GetHelpInterface();
	if (pIVsHelpSystem)
	{
		pIVsHelpSystem->DisplayTopicFromIdentifier(c_pssHelpFile, c_pssContextId, VHS_Localize);
	}
#else
	CString strPSSHelp;
	if (GetPSSHelpFile(strPSSHelp))
	{
		::WinHelp(AfxGetMainWnd()->m_hWnd, strPSSHelp, HELP_FINDER, 0);
	}
	else
		::MessageBeep(0);
#endif
}

///////////////////////////////////////////////////////////////////////////
// Microsoft on the Web Help

void CVshellPackage::OnHelpMSOnTheWeb(UINT nID)
{
	ASSERT( nID >= IDM_HELP_MOW_FIRST   &&  nID <= IDM_HELP_MOW_LAST );

	static WORD rgURLMap[] = {
		IDS_HELP_MOW_FREESTUFF,
		IDS_HELP_MOW_PRODUCTNEWS,
		IDS_HELP_MOW_FAQ,
		IDS_HELP_MOW_ONLINESUPPORT,
		IDS_HELP_MOW_DEVONLYHOMEPAGE,
		IDS_HELP_MOW_SENDFEEDBACK,
		IDS_HELP_MOW_BESTOFTHEWEB,
		IDS_HELP_MOW_SEARCHTHEWEB,
		IDS_HELP_MOW_WEBTUTORIAL,
		IDS_HELP_MOW_MSHOMEPAGE,
	};
	UINT uiOffset = nID - IDM_HELP_MOW_FIRST;

	CString strURL;
	VERIFY( strURL.LoadString( rgURLMap[uiOffset] ));

	OpenURL( strURL, eHonorIVOption );
}

void OpenURL( CString& strURL, EOpenURLOption eURLOpt /*=eHonorIVOption*/)
{
	if( eURLOpt != eExternalOnly )
	{
#ifdef __DEVHELP98__ 
		IVsHelpSystem* pIVsHelpSystem = GetHelpInterface();
		if (pIVsHelpSystem)
		{		
			BSTR bstrURL = strURL.AllocSysString() ;

			HRESULT hr = pIVsHelpSystem->DisplayTopicFromURL(	/*BSTR*/ bstrURL, 
																/*dwCommands*/ VHS_UseBrowser);

			if (bstrURL)
			{
				::SysFreeString(bstrURL) ;
			}
			ASSERT(SUCCEEDED(hr)) ;
		}
#endif //__DEVHELP98__ 
	}
	else
	{
	    if (strURL.GetLength() < _MAX_PATH)
		{
			// make null-terminated list of files from this filename
	        TCHAR lszFiles[_MAX_PATH+1];
		    _tcscpy(lszFiles,strURL);
			lszFiles[strURL.GetLength() + 1] = 0; // null terminate file list

	        SHELLEXECUTEINFO sei;
		    memset(&sei, 0, sizeof sei);
			sei.cbSize = sizeof sei;
	        sei.fMask = SEE_MASK_FLAG_NO_UI | SEE_MASK_NOCLOSEPROCESS;
		    sei.hwnd = AfxGetMainWnd()->m_hWnd;
			sei.lpFile = lszFiles;
	        sei.nShow = 0;
		    if (ShellExecuteEx(&sei))
			   return;
		}
	}
}


///////////////////////////////////////////////////////////////////////////
// Extension Help

const TCHAR szkHelpExtension[] = _TEXT("Help\\Extension");
const TCHAR szkShowExtHelp[] = _TEXT("Enable");
const TCHAR szkExtHelpFile[] = _TEXT("Filename");
const TCHAR szkExtUse[] = _TEXT("State");

void EnsureExtHelpKeys()
{
	// make sure keys are there for user to fill in and in a consistent state
	CString str = GetRegString(szkHelpExtension, szkExtHelpFile);
	WriteRegString(szkHelpExtension, szkExtHelpFile, str);
	BOOL bShow = !str.IsEmpty() && GetRegInt(szkHelpExtension, szkShowExtHelp, 0);
	WriteRegInt(szkHelpExtension, szkShowExtHelp, bShow);
	WriteRegInt(szkHelpExtension, szkExtUse, bShow ? GetRegInt(szkHelpExtension, szkExtUse, 0) : 0);
}

// Is feature enabled?
BOOL ShowExtHelp()
{
	EnsureExtHelpKeys();
	return !!GetRegInt(szkHelpExtension, szkShowExtHelp, 0);
}

BOOL UseExtHelp()
{
	if (!ShowExtHelp())
		return FALSE;
	return !!GetRegInt(szkHelpExtension, szkExtUse, 0);
}

BOOL SetExtHelp(BOOL b)
{
	b = !!b;
	WriteRegInt(szkHelpExtension, szkExtUse, b);
	return b;
}

BOOL ToggleExtHelp()
{
	return SetExtHelp(!UseExtHelp());
}

BOOL GetExtHelpFile(CString & strHelpFile)
{
	strHelpFile = GetRegString(szkHelpExtension, szkExtHelpFile);
	if (strHelpFile.IsEmpty())
	{
		EnsureExtHelpKeys();
		return FALSE;
	}

	if (_access(strHelpFile, 04) == 0)
		return TRUE;
	// Look in help directory
	CString strHelpDir;
	GetHelpDir(strHelpDir);
	if (strHelpFile[0] != _T('\\'))
		strHelpDir += _T('\\');
	strHelpDir += strHelpFile;
	if (_access(strHelpDir, 04) == 0)
	{
		// update reg with full path
		WriteRegString(szkHelpExtension, szkExtHelpFile, strHelpDir);
		return TRUE;
	}
	return FALSE;
}

void CVshellPackage::OnHelpExtHelp()
{
	ToggleExtHelp();
}

void ExtHelpNotAvailable( LPCTSTR szFile )
{
	_TCHAR szMsg[1024];
	CString strFmtMsg;
	VERIFY(strFmtMsg.LoadString(IDS_NO_EXT_HELP));
	_sntprintf(szMsg, (sizeof szMsg)-1, (LPCTSTR)strFmtMsg, szFile );
	MsgBox( Information, szMsg );
}

BOOL HelpOnKeywordExt(LPCTSTR szKeyword)
{
	CWaitCursor waitCursor;
	BOOL bRet = FALSE;
	CString strExtHelpFile;
	bRet = GetExtHelpFile(strExtHelpFile);
	if (bRet)
	{
		bRet = ::WinHelp(AfxGetMainWnd()->m_hWnd, strExtHelpFile, 
			HELP_PARTIALKEY, szKeyword ? (DWORD)szKeyword : (DWORD)"");
	}
	else
		ExtHelpNotAvailable(strExtHelpFile);
	return bRet;
}

BOOL HelpContentsExt()
{
	CWaitCursor waitCursor;
	BOOL bRet;
	CString strExtHelpFile;
	bRet = GetExtHelpFile(strExtHelpFile);
	if (bRet)
	{
		bRet = ::WinHelp(AfxGetMainWnd()->m_hWnd, strExtHelpFile, 
			HELP_FINDER, 0 );
	}
	else
		ExtHelpNotAvailable(strExtHelpFile);
	return bRet;
}

BOOL HelpIndexExt(LPCTSTR szKeyword)
{
	CWaitCursor waitCursor;
	BOOL bRet;
	CString strExtHelpFile;
	bRet = GetExtHelpFile(strExtHelpFile);
	if (bRet)
	{
		bRet = ::WinHelp(AfxGetMainWnd()->m_hWnd, strExtHelpFile, 
			HELP_PARTIALKEY, szKeyword ? (DWORD)szKeyword : (DWORD)"" );
	}
	else
		ExtHelpNotAvailable(strExtHelpFile);
	return bRet;
}

///////////////////////////////////////////////////////////
//
// ChildWindowFromPointAvoidGroupBoxes
//
// Orion Bug # 12420 - DoHelpContextMenu called ChildWindowFromPoint
// which returns the first control containing the point. However,
// the group box is the first control, so items in the group box
// are not returned.
//
// Created: 22 Oct 96 - dalero
//
CWnd* ChildWindowFromPointAvoidGroupBoxes(
		CWnd* pWnd,				// Pointer to DialogBox or window with children.
		const CPoint& point		// Reference to a point in screen coordinates.
)
{
	ASSERT(pWnd != NULL) ;

	// Ensure that point is actually in the window.
	CRect rectChild ;	
	pWnd->GetWindowRect(rectChild) ;
	if (!rectChild.PtInRect(point))
	{
		// Point is not in window.
		return NULL ;
	}

	// Variable to cache a pointer to group box, if we encounter one.
	CWnd* pGroup = NULL;

	// Get first child.
	CWnd* pChild = pWnd->GetWindow(GW_CHILD) ;

	// iterate through the children
	while(pChild != NULL)
	{
		// Only check if the window is visible
		if (pChild ->IsWindowVisible())
		{
			// Get the rectangle for the child
			pChild ->GetWindowRect(&rectChild) ;

			// Check to see if the pt is in the child.
			if (rectChild.PtInRect(point))
			{
				// Check to see if this is a group box.
				if ((pGroup == NULL) &&						// Set pGroup only if not already set.
					(pChild->GetStyle() & BS_GROUPBOX))		// Set pGroup only if child is a group.
				{
					// This is a group box.
					pGroup = pChild ;
					// look for another child.
				}
				else
				{
					// This is not a group box, so we are done.
					return pChild  ;
				}
			}
		}
		// get the next control
		pChild = pChild->GetWindow(GW_HWNDNEXT) ;
	}
	return pGroup ? pGroup : pWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\fnwiztpl.cpp ===
// fnwiztpl.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "fnwiztpl.h"
#include "oleref.h"
#include "bwizmgr.h"
#include "resource.h"
#include "prjapi.h"   //IPkgProject
#include "iswsguid.h" //IID_IWebPkgProject
#include "iswsapi.h"  //IWebProject
IMPLEMENT_DYNAMIC(CFileNewWizardTemplate, CPartTemplate)

CFileNewWizardTemplate :: CFileNewWizardTemplate (
	CPackage*	pPackage,
	REFCLSID	clsid,
	CString		strDesc, HICON hIcon /*=NULL*/) :
	CPartTemplate(IDR_DOCOBJECT /*IDR_FNWIZOBJECT*/,
		RUNTIME_CLASS(CPartDoc),
		RUNTIME_CLASS(CPartFrame),
		RUNTIME_CLASS(CPartView),
		pPackage,
		NULL,
		clsid)
{
	m_strDocStrings = _T("\n");		//  no default window title
	m_strDocStrings += _T("FileNew\n");// user visible name for default document
	// following lines for File.New
	m_strDocStrings += strDesc;		// for User Visible name for File New
	m_strDocStrings += _T("\n");
	// Assumption:
	// assuming all files for the time being
	m_strDocStrings += _T("All Files (*.*)\n");	// user visible name for FileOpen
	m_strDocStrings += _T(".~~~\n");	// user visible extension for FileOpen
   // Use Default Icon if hIcon is null
   m_hIcon = (hIcon == NULL) ? theApp.LoadIcon(IDI_FILENEWWIZDEFAULT) : hIcon;
}

CDocument* CFileNewWizardTemplate :: OpenDocumentFile(
	LPCTSTR		pszcPathName,
	BOOL		bMakeVisible)
{
	// Dont call this.  You should call NewDocumentFile
	ASSERT(!_T("FileNewWizards need a Project. Use NewDocumentFile"));
	return NULL;
}


// Execute the New File Wizard
CPartDoc* CFileNewWizardTemplate::NewDocumentFile
(
   LPCTSTR     pszFileName,
   IPkgProject *pProject,
   LPCTSTR     pszFolder
)
{
#define	NUM_PARAMS	6

	HRESULT	hr;
	COleRef<IBuilderWizardManager>	srpBWM;

	hr = theApp.GetService(SID_SBuilderWizardManager, IID_IBuilderWizardManager,
		(void**)&srpBWM);
	ASSERT(SUCCEEDED(hr));
	if(SUCCEEDED(hr))
	{
		COleRef<IDispatch>	srpBldrDisp;
		COleRef<IDispatch>	srpAppDisp;
		COleRef<IUnknown>	srpunk;

		CWnd*		pMainWnd = AfxGetMainWnd();
		ASSERT(pMainWnd);
		HWND		hMainWnd = pMainWnd->GetSafeHwnd();

		// IStudio bug fix (by scotg)
		// for VB4 created inproc servers, it is recommended
		// (by the VB group) to cocreate the object asking for
		// IUknown and then using the returned punk to QI for
		// the desired interface.
		hr = srpBWM->GetBuilder(m_clsid, 
			// REVIEW(cgomes): Should use BLDGETOPT_FAUTOMAPGUID 
			// rather than 0once MapBuilderCATIDToCLSID is fixed
			0,
			hMainWnd, &srpAppDisp, NULL, IID_IUnknown, (IUnknown**)&srpunk);
		ASSERT(SUCCEEDED(hr));
		hr = srpunk->QueryInterface(IID_IDispatch, (void**)&srpBldrDisp);
		ASSERT(SUCCEEDED(hr));
		if(hr == S_OK)
		{
			DISPID		diExecute;
			LPOLESTR	szExecute = (L"Execute");
			LCID		lcid = MAKELCID(
							MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
							SORT_DEFAULT);

			hr = srpBldrDisp->GetIDsOfNames(IID_NULL, &szExecute, 1, lcid, &diExecute);
			ASSERT(SUCCEEDED(hr));
			if(SUCCEEDED(hr))
			{
				// set up the dispparms.  They are:
				// 1. app object's IDispatch,
				// 2. hwndPromptOwner,
				// 3. IServiceProvider
				// 4. Project name,
				// 5. path name,
				// 6. bool flag to indicate "add to project"
				
				UINT		cArgs = NUM_PARAMS;
				DISPPARAMS	dp;

				dp.rgvarg = new VARIANTARG[cArgs];
				dp.cArgs = cArgs;
				dp.rgdispidNamedArgs = NULL;
				dp.cNamedArgs = 0;

				// since the machine pushes items on stack, store them in reverse order

				// param 1 (app object's IDispatch)
				::VariantInit(&(dp.rgvarg[--cArgs]));	
				dp.rgvarg[cArgs].vt = VT_DISPATCH;
				dp.rgvarg[cArgs].pdispVal = srpAppDisp.Disown();

				// param 2 (hwndOwner)
				::VariantInit(&(dp.rgvarg[--cArgs]));	
				dp.rgvarg[cArgs].vt = VT_I4;
				dp.rgvarg[cArgs].lVal = (long)hMainWnd;

				// param 3 (IServiceProvider interface)
				::VariantInit(&(dp.rgvarg[--cArgs]));
				dp.rgvarg[cArgs].vt = VT_UNKNOWN;
				dp.rgvarg[cArgs].punkVal = NULL;

#if 1
				// Get Project URL
				BSTR bstrProjectName = NULL;
				COleRef<IWebProject> srpWebProject;
				if(pProject == NULL ||
					FAILED(pProject->GetAutomationObject((IDispatch**)&srpWebProject)) ||
					FAILED(srpWebProject->get_VirtualRoot(&bstrProjectName)))
				{
					bstrProjectName = ::SysAllocString(L"");
				}
				ASSERT(bstrProjectName != NULL);
#else
				// Get the Project Name
				LPCOLESTR pszProjectName = NULL;
				LPCOLESTR pszProjFullPath = NULL;
				BSTR      bstrProjectName = NULL;
				DWORD     dwPackageID;
				DWORD     dwFlags;
				// Call GetProjectInfo to get back project name
				if(pProject != NULL && 
				   SUCCEEDED(pProject->GetProjectInfo(&pszProjectName, 
													  &pszProjFullPath, 
													  &dwPackageID, &dwFlags)))
				{
				   ASSERT(pszProjectName != NULL);
				   bstrProjectName = ::SysAllocString(pszProjectName);
				   ::AfxFreeTaskMem((void*)pszProjectName);
				   pszProjectName = NULL;
				   ::AfxFreeTaskMem((void*)pszProjFullPath);
				   pszProjFullPath = NULL;
				}
				else
				   bstrProjectName = ::SysAllocString(L"");
				ASSERT(bstrProjectName != NULL);
#endif
            
				// param 3 (Project Name)
				::VariantInit(&(dp.rgvarg[--cArgs]));	
				dp.rgvarg[cArgs].vt = VT_BSTR;
				dp.rgvarg[cArgs].bstrVal = bstrProjectName; // Freed by VariantClear

				// Format path name.  This should be the Folder \\ FileName
				CString		strPathName(pszFolder);
				if(!strPathName.IsEmpty())
				   // add \ to end of path b/c filename will be appended
				   strPathName += _T("\\");
				strPathName += pszFileName;

				// param 4 (path name)
				::VariantInit(&(dp.rgvarg[--cArgs]));	
				dp.rgvarg[cArgs].vt = VT_BSTR;
				dp.rgvarg[cArgs].bstrVal = strPathName.AllocSysString(); // Freed by Variant Clear

				// param 5 ("Add to Project" flag)
				// File New Wizards always add to Project, so this flag is use less
				::VariantInit(&(dp.rgvarg[--cArgs]));	
				dp.rgvarg[cArgs].vt = VT_BOOL;
				dp.rgvarg[cArgs].boolVal = VARIANT_TRUE;		//TRUE;

				VARIANT	varReturn;

				::VariantInit(&varReturn);

				srpBWM->EnableModeless(FALSE);
				hr = srpBldrDisp->Invoke(diExecute, IID_NULL, lcid,
					DISPATCH_METHOD, &dp, &varReturn, NULL, NULL);
				srpBWM->EnableModeless(TRUE);
				ASSERT(SUCCEEDED(hr));
				if(SUCCEEDED(hr))
				{
					// check the return value
					ASSERT(VT_BOOL == V_VT(&varReturn));
					if(V_BOOL(&varReturn))
					{
						// TODO
						// do whatever we need to do on success
					}
					::VariantClear(&varReturn);
				}
				else
					::AfxMessageBox(IDS_NOFILENEWWIZSUPPORT);

				// free the variants
				for(cArgs = 0; cArgs < NUM_PARAMS; cArgs++)
					::VariantClear(&(dp.rgvarg[cArgs]));

				// free the variant array
				delete [] dp.rgvarg;
			}
			else
				::AfxMessageBox(IDS_NOFILENEWWIZSUPPORT);
		}
		else
			::AfxMessageBox(IDS_REGISTRYCORRUPTED);
	}
	else
		::AfxMessageBox(IDS_REGISTRYCORRUPTED);

	return NULL;
}

//
//	BOOL CFileNewWizardTemplate::CanBeAddedToProject
//
//	Description:
//		This FileNewWizard can only be added to IWebPkgProjects.
//
//	Arguments:
//		IPkgProject *pProject:
//
//	Return (BOOL): TRUE if Project CLSID == IID_IWebPkgProject(s), FALSE otw
//
BOOL CFileNewWizardTemplate::CanBeAddedToProject(IPkgProject *pProject)
{
	if(NULL != pProject)
	{
		CLSID clsid;
		HRESULT hr = pProject->GetClassID(&clsid);
		ASSERT(SUCCEEDED(hr));
		return (SUCCEEDED(hr) && (clsid == IID_IWebPkgProject));
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\guids.cpp ===
// guids.cpp : add all header files that contain DEFINE_GUID in this
//				file.  this file is the only file that contains 
//				initguid
//
#include <stdafx.h>

#include <initguid.h>	// this enables definition of GUID's



#define INIT_MSO_GUIDS

#include <ObjModel\appguid.h>	// Shell Automation Guids
#include <utilauto.h>
#include "autoguid.h"			// Internal Shell Automation Guids
#include <aut1guid.h>
#include <aut1gui_.h>
#include <clvwguid.h>
#include <bldguid.h>
#include <cmguids.h>
#include <multinfo.h>
#include <ocdesign.h>
#include <oleipcid.h>
#include <objext.h>
#include <prjguid.h>
#include <srcguid.h>
#include <vbaguids.h>
#include <bldguid_.h>	// For IAutoBld
#include <ocdevo.h>
#include <shlguid_.h>
#include <oaidl.h>

#include "ipcits.h"

#include <iswsguid.h>				// IID_IWebPkgProject

// REVIEW(scotg)  this needs to be removed when we pick up a new
// docobj.h header that will include this guid.
DEFINE_GUID(SID_SContainerDispatch, 0xb722be00, 0x4e68, 0x101b, 0xa2, 0xbc,0x0, 0xaa, 0x0, 0x40, 0x47,0x70);
DEFINE_GUID(SID_SContainer,			0x0000011b, 0x0,    0x0,    0xc0, 0x0, 0x0, 0x0,  0x0, 0x0,  0x0, 0x46);

// REVIEW(billmc) these Guids are defined in ocx96.lib; once we have
// versions of that library for all packages, we can link to it
// and remove these definitions.
//
DEFINE_GUID(IID_IOleUndoManager,	0xd001f200, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);
DEFINE_GUID(IID_IOleUndoUnit, 	0x894ad3b0, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);
DEFINE_GUID(IID_IOleParentUndoUnit, 0xa1faf330, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);
DEFINE_GUID(IID_IEnumOleUndoUnits,	0xb3e7c340, 0xef97, 0x11ce, 0x9b, 0xc9, 0x00, 0xaa, 0x00, 0x60, 0x8e, 0x01);

// This GUID is defined in fm20uuid.lib, which we don't want to use because there
// do not exist RISC builds and the IDE needs to be built for some RISC platforms.
// Also see ipcslob.cpp
DEFINE_GUID(IID_IElement,	0x3050f1ff, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);


// IID_IForm needed for ISBug: 7249 - defined in forms3.h which wont compile
// in the devstudio tree
DEFINE_GUID(IID_IForm, 0x04598fc8, 0x866c, 0x11cf, 0xab, 0x7c, 0x0, 0xaa, 0x0, 0xc0, 0x8f, 0xcf);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\grid.cpp ===
// grid.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "imeutil.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define SORT_COLUMNS	// undefine to prevent column sorting
//#define DYNAMIC_SIZING // undefine if column sizing should happen on button up

#define cxSelectMargin 8

extern CFont* GetStdFont(const int);

///////////////////////////////////////////////////////////////////////////////
//	CGridToolBar

CGridToolBar::CGridToolBar()
	: CToolBar()
{
}

void CGridToolBar::SetSizes()
{
	CToolBar::SetSizes(CSize(sizeButtonX, sizeButtonY),
	                   CSize(sizeImageX, sizeImageY));

	m_cxDefaultGap = 0;
	m_cyTopBorder = m_cyBottomBorder = 0;
	m_cxLeftBorder = 0;
	m_dwStyle = m_dwStyle & ~0x0F00;

}
///////////////////////////////////////////////////////////////////////////////
//	CStaticVCenter

void CStaticVCenter::OnPaint()
{
	CPaintDC dc(this);
	CRect rc;
	CString str;

	GetClientRect(rc);

	dc.SetBkMode( TRANSPARENT );

	if (IsWindowEnabled())
		dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	else
		dc.SetTextColor(::GetSysColor(COLOR_GRAYTEXT));

	COLORREF bkColor = GetSysColor(COLOR_BTNFACE);
	if (theApp.m_bWin4 && GetRValue(bkColor) == 0 && GetGValue(bkColor) == 0 && GetBValue(bkColor) == 0)
		bkColor = GetSysColor(COLOR_WINDOW);

	// this all to avoid problems with disabled control text drawing. this sets the bkcolor in the dc too
	dc.FillSolidRect(rc, bkColor);

	CBrush brWindow(bkColor);
	CBrush * pbrushOld = dc.SelectObject(&brWindow);

	CFont* pfontOld = dc.SelectObject(GetStdFont(font_Normal));

	rc.left += 2;  // seems to be the norm... bobz
	GetWindowText(str);
	dc.DrawText(str, str.GetLength(), rc, DT_LEFT | DT_VCENTER | DT_SINGLELINE );

	dc.SelectObject(pfontOld);
	dc.SelectObject(pbrushOld);

}

void CStaticVCenter::OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpParams)
{
	// NT won't draw sunken border
	if (!UseWin4Look())
	{
		LPRECT pRect = &(lpParams->rgrc[0]);
		::InflateRect(pRect, -1, -1); // make room for borders
		return;
	}
        
	CStatic::OnNcCalcSize(bCalcValidRects, lpParams);
}

void CStaticVCenter::OnNcPaint()
{
	// NT won't draw sunken border
	if (!UseWin4Look())
	{
		// Draw sunken border
	    CWindowDC dc(this);

		CRect rect;
	    GetWindowRect(rect);
		rect.OffsetRect(-rect.left, -rect.top); // essentially convert to client coords for draw

		dc.Draw3dRect(rect, GetSysColor(COLOR_BTNSHADOW), GetSysColor(COLOR_BTNHIGHLIGHT));
		return;
	}

	CStatic::OnNcPaint();
}

BEGIN_MESSAGE_MAP(CStaticVCenter, CStatic)
	//{{AFX_MSG_MAP(CStaticVCenter)
	ON_WM_PAINT()
	ON_WM_NCCALCSIZE()
	ON_WM_NCPAINT()

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGridElement

CGridElement::~CGridElement()
{
}

void CGridElement::SetCapture()
{
	CGridWnd* pGrid = GetGrid();
	pGrid->m_pCaptureElement = this;
	pGrid->SetCapture();
}

void CGridElement::ReleaseCapture()
{
	CGridWnd* pGrid = GetGrid();
	if (pGrid->m_pCaptureElement == this)
	{
		pGrid->m_pCaptureElement = NULL;
		::ReleaseCapture();
	}
}

void CGridElement::Invalidate(BOOL bErase, BOOL bInflate)
{
	CGridWnd* pGrid = GetGrid();
	if (pGrid->m_hWnd == NULL)
		return;
	
	CRect rect;
	GetRect(rect);
	if (bInflate)
		rect.InflateRect(0, 3);

	pGrid->InvalidateRect(rect, bErase);
}

void CGridElement::OnSelect(BOOL bSelected)
{
}

void CGridElement::ResetSize(CDC* pDC)
{
}

CGridElement* CGridElement::ElementFromPoint(const CPoint& point)
{
	return this;
}

BOOL CGridElement::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_bWasSelected = GetGrid()->IsSelected(this);

	return FALSE;
}

BOOL CGridElement::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	GetGrid()->SetActiveElement(this, GetGrid()->ColumnFromX(point.x));
	return TRUE;
}

BOOL CGridElement::OnLButtonUp(UINT nFlags, CPoint point)
{
	if (m_bWasSelected)
	{
		GetGrid()->SetActiveElement(this, GetGrid()->ColumnFromX(point.x));
	}
	else {
		GetGrid()->Select(this, nFlags & (MK_SHIFT | MK_CONTROL));
	}

	return TRUE;
}

BOOL CGridElement::OnMouseMove(UINT nFlags, CPoint point)
{
	return FALSE;
}

void CGridElement::OnActivate(BOOL bActivate, int nColumn)
{
}

void CGridElement::OnControlNotify(UINT nControlID, UINT nNotification)
{
}

CGridRow* CGridElement::GetRow() const
{
	ASSERT(this != NULL);
	ASSERT(!m_bIsCell);

	return (CGridRow*)this;
}

/////////////////////////////////////////////////////////////////////////////
// CGridCell

CGridCell::CGridCell()
{
	m_size.cx = m_size.cy = 0;
	m_pRow = NULL;
	m_nColumn = 0;
	m_dt = DT_WORDBREAK;
	m_bIsCell = TRUE;
}

void CGridCell::GetRect(CRect& cellRect)
{
	CGridWnd* pGrid = GetGrid();
	CGridRow* pRow = GetRow();
	pRow->GetRect(cellRect);
	for (int nColumn = 0; nColumn < m_nColumn; nColumn += 1)
		cellRect.left += pGrid->GetColumnWidth(nColumn);
	cellRect.right = cellRect.left + pGrid->GetColumnWidth(m_nColumn);
}

void CGridCell::Invalidate(BOOL bErase)
{
	CGridWnd* pGrid = GetGrid();
	if (pGrid->m_hWnd != NULL)
	{
		CRect cellRect;
		GetRect(cellRect);
		pGrid->InvalidateRect(cellRect, bErase);
	}
}

void CGridCell::SetText(const char* szText)
{
	if (m_str.Compare(szText) != 0)
	{
		m_str = szText;
		Invalidate();
	}
}

void CGridCell::Draw(CDC* pDC, const CRect& cellRect)
{
	CGridWnd* pGrid = GetGrid();
	BOOL bCurCell = pGrid->LooksSelected(this);
	COLORREF oldTextColor = pDC->SetTextColor(bCurCell ? pGrid->GetHighlightTextColor():pGrid->GetWindowTextColor());
	COLORREF oldBkColor = pDC->SetBkColor(bCurCell ? pGrid->GetHighlightColor() : pGrid->GetWindowColor());
	
	CRect rect = cellRect;
	rect.right -= 1;
	rect.bottom -= 1;
	
	pDC->ExtTextOut(0, 0, ETO_OPAQUE, &rect, "", 0, NULL);

	rect.InflateRect(-1, -1);
	pDC->DrawText(m_str, m_str.GetLength(), rect, DT_NOPREFIX | m_dt);
	rect.InflateRect(1, 1);
	
	CBrush brush;
	brush.CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
	CBrush* pOldBrush = pDC->SelectObject(&brush);
	pDC->PatBlt(cellRect.left, cellRect.bottom - 1, cellRect.Width(), 1, PATCOPY);
	pDC->PatBlt(cellRect.right - 1, cellRect.top, 1, cellRect.Height() - 1, PATCOPY);
	pDC->SelectObject(pOldBrush);
		
	CWnd* pFocus = CWnd::GetFocus();
	if ((pFocus == pGrid /*|| pGrid->IsChild(pFocus)*/) && pGrid->IsPrimary(this))
		pDC->DrawFocusRect(rect);
	
	pDC->SetTextColor(oldTextColor);
	pDC->SetBkColor(oldBkColor);
}

void CGridCell::ResetSize(CDC* pDC)
{
	CRect rect(0, 0, GetGrid()->GetColumnWidth(GetColumnIndex()), 0);
	if (rect.Width() <= 0)
	{
		m_size.cx = m_size.cy = 0;
	}
	else
	{
		pDC->DrawText(m_str, m_str.GetLength(), rect, DT_CALCRECT | DT_NOPREFIX | m_dt);
		m_size = rect.Size();
		m_size.cx += 3;
		m_size.cy += 3;
	}
}

CGridRow* CGridCell::GetRow() const
{
	ASSERT(this != NULL);
	ASSERT(m_bIsCell);

	return m_pRow;
}


/////////////////////////////////////////////////////////////////////////////
// CGridRow

CGridRow::CGridRow(CGridWnd* pGrid)
{
	m_pGrid = pGrid;
	m_cyHeight = 0;
	m_bIsCell = FALSE;
}

CGridRow::~CGridRow()
{
	if (m_pGrid != NULL)
		m_pGrid->RemoveRow(this);
}

CSize CGridRow::GetCellSize(CDC* pDC, int nColumn) const
{
	return GetGrid()->GetCaptionRow()->GetCellSize(nColumn);
}

void CGridRow::GetRect(CRect& rowRect)
{
	CGridWnd* pGrid = GetGrid();
	pGrid->GetClientRect(rowRect);
	
	int yTopVisible, yThis;
	int y = 0;
	BOOL bFoundThis = FALSE;
	BOOL bFoundTop = FALSE;
	POSITION pos = pGrid->GetHeadRowPosition();
	if (pGrid->m_posTopVisibleRow == NULL)
		pGrid->m_posTopVisibleRow = pos;

	while (pos != NULL && !(bFoundThis && bFoundTop))
	{
		if (pos == pGrid->m_posTopVisibleRow)
		{
			bFoundTop = TRUE;
			yTopVisible = y;
		}
		
		CGridRow* pRow = pGrid->GetNextRow(pos);
		if (pRow == this)
		{
			bFoundThis = TRUE;
			yThis = y;
		}
		
		y += pRow->GetRowHeight();
	}
	
	ASSERT(bFoundThis && bFoundTop);
	
	rowRect.top = yThis - yTopVisible - pGrid->m_cyScroll +
		pGrid->GetCaptionRow()->GetRowHeight();
	rowRect.bottom = rowRect.top + GetRowHeight();
}

void CGridRow::Draw(CDC* pDC, const CRect& rowRect)
{
	CGridWnd* pGrid = GetGrid();
	
	COLORREF oldTextColor;
	COLORREF oldBkColor;

	if (!pGrid->m_bHasCells)
	{
		BOOL bCurRow = pGrid->LooksSelected(this);
		oldTextColor = pDC->SetTextColor(bCurRow ? pGrid->GetHighlightTextColor():pGrid->GetWindowTextColor());
		oldBkColor = pDC->SetBkColor(bCurRow ? pGrid->GetHighlightColor() : pGrid->GetWindowColor());
	}
	
	CRect cellRect = rowRect;
	int nColumnCount = pGrid->GetColumnCount();
	for (int nColumn = 0; nColumn < nColumnCount; nColumn += 1)
	{
		cellRect.right = cellRect.left + pGrid->GetColumnWidth(nColumn);
		if (cellRect.right > cellRect.left)
			DrawCell(pDC, cellRect, nColumn);
		cellRect.left = cellRect.right;
	}
	
	if (!pGrid->m_bHasCells)
	{
		oldTextColor = pDC->SetTextColor(oldTextColor);
		oldBkColor = pDC->SetBkColor(oldBkColor);
		
		CWnd* pFocus = CWnd::GetFocus();
		if ((pFocus == pGrid /*|| pGrid->IsChild(pFocus)*/) && pGrid->IsPrimary(this))
			pDC->DrawFocusRect(rowRect);
	}
}

int CGridRow::Compare(const CGridRow* pCompareRow) const
{
	return 0; // don't know, so claim they're equal!
}

/////////////////////////////////////////////////////////////////////////////
// CGridControlRow

CGridControlRow::CGridControlRow(CGridWnd* pGrid) : CGridRow(pGrid)
{
}

CGridControlRow::~CGridControlRow()
{
}

void CGridControlRow::GetColumnRect(int nColumn, CRect& rect)
{
	CGridWnd* pGrid = GetGrid();
	int x = 0;
	for (int n = 0; n < nColumn; n += 1)
		x += pGrid->GetColumnWidth(n);
	GetRect(rect);
	rect.left = x;
	rect.right = x + pGrid->GetColumnWidth(nColumn);
}

#define cxDefaultGridCellMargin 8
#define cyDefaultGridCellMargin 2

void CGridControlRow::AdjustForMargins(CRect& rect, int nColumn)
{
	if (nColumn == 0)
	{
		int cx = max(cxDefaultGridCellMargin, GetGrid()->m_cxSelectMargin);

		rect.right -= cxDefaultGridCellMargin;
		rect.left += cx;
		rect.InflateRect(0, -cyDefaultGridCellMargin);
	}
	else
	{
		rect.InflateRect(-cxDefaultGridCellMargin, -cyDefaultGridCellMargin);
	}
}

void CGridControlRow::DrawCell(CDC* pDC, const CRect& cellRect, int nColumn)
{
	CRect textRect = cellRect;
	AdjustForMargins(textRect, nColumn);
	CString str;
	GetColumnText(nColumn, str);
	
	int x;
	switch (pDC->GetTextAlign() & (TA_LEFT | TA_RIGHT | TA_CENTER))
	{
	default:
		ASSERT(FALSE);
		
	case TA_LEFT:
		x = textRect.left;
		break;
		
	case TA_CENTER:
		x = textRect.left + textRect.Width() / 2;
		break;
		
	case TA_RIGHT:
		x = textRect.right;
		break;
	}
	
	pDC->ExtTextOut(x, textRect.top, ETO_CLIPPED | ETO_OPAQUE,
		cellRect, str, str.GetLength(), NULL);
}

CEdit* CGridControlRow::NewEdit( )
{
	return( new CEdit ) ;
}

CComboBox* CGridControlRow::NewCombo( )
{
	return( new CComboBox );
}

// Called when the grid is about to create a control in the cell.
// The CRect argument has the rectangle corr to the cell
// and is adjusted to give the dimensions of the control.

void CGridControlRow::AdjustControlRect( GRID_CONTROL_TYPE controlType, int nColumn, CRect& rect  )
{
	switch ( controlType )
	{
		default:
			ASSERT(FALSE);
			break;
		case none:
			break;
		case edit:
			// FUTURE: hacky numbers won't work for all sys fonts
			rect.left -= 4;
			rect.top -= 4;
			rect.right += 4;
			rect.bottom += 4;
			break;
		case editCombo:
			// FUTURE: hacky numbers won't work for all sys fonts
			rect.left -= 3;
			rect.top -= 3;
			rect.right += 3;
			rect.bottom = rect.top + 150;
			break;
		case listCombo:
			// FUTURE: hacky numbers won't work for all sys fonts
			rect.left -= 3;
			rect.top -= 3;
			rect.right += 3;
			rect.bottom = rect.top + 150;
			break;						
	}
}

int GetEllipseWidth()
{
	static int cxWidth;
	if (cxWidth == 0)
	{
		CWindowDC dc(NULL);
		cxWidth = dc.GetTextExtent("...W", 4).cx;
	}

	return cxWidth;
}

BOOL CGridControlRow::CreateControl(GRID_CONTROL_TYPE controlType, int nColumn, DWORD dwStyle)
{
	CGridControlWnd* pGrid = (CGridControlWnd*)GetGrid();
	BOOL bDestroyedControl = FALSE;
	
	if (pGrid->m_pControlWnd != NULL && controlType != pGrid->m_controlType)
	{
		delete pGrid->m_pControlWnd;
		pGrid->m_pControlWnd = NULL;
		pGrid->m_controlType = none;
		pGrid->m_nControlColumn = -1;
		bDestroyedControl = TRUE;

		if (pGrid->m_Ellipse.m_hWnd != NULL)
			pGrid->m_Ellipse.DestroyWindow();
	}
	
	ASSERT(nColumn >= 0 || controlType == none);
	CRect rect;
	if (nColumn >= 0)
	{
		GetColumnRect(nColumn, rect);
		AdjustForMargins(rect, nColumn);
	}
	
	if (pGrid->m_pControlWnd == NULL)
	{
		CRect rcEllipse;
		switch (controlType)
		{
		default:
			ASSERT(FALSE);
			
		case none:
			break;
		
		case edit:
			AdjustControlRect(controlType, nColumn, rect);
			if (pGrid->m_bEnableEllipse)
			{
				rcEllipse = rect;
				rect.right -= GetEllipseWidth();
				rcEllipse.left = rect.right;
			}

			pGrid->m_pControlWnd = NewEdit();
			if ((dwStyle & ES_MULTILINE) != 0)
			{
				dwStyle |= ES_AUTOVSCROLL;
				rect.bottom++;		// multiline edit's draw text 1 pixel lower
			}
			else
				dwStyle |= ES_AUTOHSCROLL;
			if (!((CEdit*)pGrid->m_pControlWnd)->Create(WS_BORDER | dwStyle, rect, pGrid, 1))
			{
				delete pGrid->m_pControlWnd;
				pGrid->m_pControlWnd = NULL;
				return FALSE;
			}

			if (pGrid->m_bEnableEllipse)
				pGrid->m_Ellipse.Create("...", BS_PUSHBUTTON, rcEllipse, pGrid, 2);
	
			ASSERT(pGrid->m_pControlWnd->GetDlgCtrlID() == 1);
			break;
			
		case editCombo:
			AdjustControlRect( controlType, nColumn, rect);			
			pGrid->m_pControlWnd = NewCombo() ;

			if (!((CComboBox*)pGrid->m_pControlWnd)->Create(
				CBS_DROPDOWN | CBS_AUTOHSCROLL | WS_VSCROLL | dwStyle, rect, pGrid, 1))
			{
				delete pGrid->m_pControlWnd;
				pGrid->m_pControlWnd = NULL;
				return FALSE;
			}
			break;

		case listCombo:
			AdjustControlRect( controlType, nColumn, rect);			
			pGrid->m_pControlWnd = NewCombo() ;

			if (!((CComboBox*)pGrid->m_pControlWnd)->Create(
				CBS_DROPDOWNLIST | CBS_AUTOHSCROLL | WS_VSCROLL | dwStyle, rect, pGrid, 1))
			{
				delete pGrid->m_pControlWnd;
				pGrid->m_pControlWnd = NULL;
				return FALSE;
			}
			break;
		}
	}
	else
	{
		CRect rcEllipse;
		pGrid->m_pControlWnd->ShowWindow(SW_HIDE);

		AdjustControlRect(controlType, nColumn, rect);
		if (pGrid->m_bEnableEllipse)
		{
			rcEllipse = rect;
			rect.right -= GetEllipseWidth();
			rcEllipse.left = rect.right;
		}

		pGrid->m_pControlWnd->MoveWindow(rect);

		if (pGrid->m_bEnableEllipse)
		{
			ASSERT(pGrid->m_Ellipse.m_hWnd != NULL);
			pGrid->m_Ellipse.ShowWindow(SW_HIDE);
			pGrid->m_Ellipse.MoveWindow(rcEllipse);
		}
	}
	
	if (pGrid->m_pControlWnd != NULL)
	{
		pGrid->m_pControlWnd->SetFont(pGrid->GetFont( ));
		pGrid->m_pControlWnd->SetFocus();
					
		CString str;
		GetColumnText(nColumn, str);
		
		switch (controlType)
		{
		case edit:
			pGrid->m_pControlWnd->SetWindowText(str);
			((CEdit*)pGrid->m_pControlWnd)->SetSel(0, -1);
			break;
			
		case editCombo:
		case listCombo:
			AddListItems(nColumn, (CComboBox*) pGrid->m_pControlWnd);
#ifdef _WIN32			
			pGrid->m_pControlWnd->SetWindowText(str);
#else			
			// Win16 dropdown lists don't respond to WM_GETWINDOWTEXT
			((CComboBox*)pGrid->m_pControlWnd)->SelectString(-1, str);
#endif			
			((CComboBox*)pGrid->m_pControlWnd)->SetEditSel(32767, 32767);
			break;
		}

		pGrid->m_pControlWnd->ShowWindow(SW_SHOWNA);
		if (pGrid->m_bEnableEllipse && pGrid->m_Ellipse.m_hWnd != NULL)
			pGrid->m_Ellipse.ShowWindow(SW_SHOWNA);
	}
	else
	{
		// If we destroyed a control, set the focus back to the grid.
		if ( bDestroyedControl && (GetFocus() == NULL))
			pGrid->SetFocus();
	}
	
	pGrid->m_controlType = controlType;
	if (nColumn != -1)
		pGrid->m_nControlColumn = nColumn;
	
	return TRUE;
}

void CGridControlRow::OnControlNotify(UINT nControlID, UINT nNotification)
{
	CGridControlWnd* pGrid = (CGridControlWnd*)GetGrid();
		CWnd* pParent = pGrid->GetParent();
		ASSERT_VALID(pParent);
	
	if (nControlID == 2)
	{
		if (nNotification == BN_CLICKED)
			pParent->PostMessage(WM_COMMAND, MAKEWPARAM(pGrid->GetDlgCtrlID(), GLN_ELLIPSE), (LPARAM)pGrid->m_hWnd);

		return; 
	}

	ASSERT(nControlID == 1);
	switch (pGrid->m_controlType)
	{
		case edit:
			if (nNotification == EN_KILLFOCUS || nNotification == EN_SETFOCUS)
				pParent->PostMessage(WM_COMMAND,
									 MAKEWPARAM(pGrid->GetDlgCtrlID(), nNotification == EN_KILLFOCUS ? GLN_KILLFOCUS : GLN_SETFOCUS),
									 (LPARAM)pGrid->m_hWnd);
				
			if (nNotification != EN_CHANGE)
				return;
			break;

		case editCombo:
		case listCombo:
			if (nNotification == CBN_KILLFOCUS || nNotification == CBN_SETFOCUS)
				pParent->PostMessage(WM_COMMAND,
									 MAKEWPARAM(pGrid->GetDlgCtrlID(), nNotification == CBN_KILLFOCUS ? GLN_KILLFOCUS : GLN_SETFOCUS),
									 (LPARAM)pGrid->m_hWnd);

			if (nNotification != CBN_SELENDCANCEL)
				return;
			break;

		default:
			return;
	}

	CString strOld;
	GetColumnText(pGrid->m_nControlColumn, strOld);

	CString strNew;
#ifdef _WIN32	
	pGrid->m_pControlWnd->GetWindowText(strNew);
#else
 	// Stupid, annoying, innane Win16 DROPDOWNLISTs don't support WM_GETTEXTLENGTH so
 	// we have to do something else instead
 	if (pGrid->m_controlType == listCombo)
 	{
 		CComboBox* pcombo = (CComboBox*) pGrid->m_pControlWnd;
 		pcombo->GetLBText(pcombo->GetCurSel(), strNew);
 	}
 	else
 		pGrid->m_pControlWnd->GetWindowText(strNew);
#endif	
	

	if (strNew.Compare(strOld) == 0)
		return;

	OnChangeColumnText(pGrid->m_nControlColumn, strNew);

	switch (pGrid->m_controlType)
	{
	case edit:
		{
			int cyOldHeight = m_cyHeight;
			
			CClientDC dc(GetGrid());
			CFont* pOldFont = dc.SelectObject(pGrid->GetFont( ));
			ResetSize(&dc);
			dc.SelectObject(pOldFont);
			
			if (m_cyHeight != cyOldHeight)
			{
				GetGrid()->Invalidate(FALSE);
				
				CRect rect;
				GetColumnRect(pGrid->m_nControlColumn, rect);
				AdjustForMargins(rect, pGrid->m_nControlColumn);
				// FUTURE: hacky numbers won't work for all sys fonts
				rect.left -= 4;
				rect.top -= 4;
				rect.right += 4;
				rect.bottom += 4;
				pGrid->m_pControlWnd->MoveWindow(rect);
			
				// Hack alert!  Since we have to have ES_AUTOSCROLL set to prevent the
				// edit from just beeping when the cursor is at the bottom-right and
				// the user types, the edit has auto-scrolled when we have to resize the
				// window.  Here we scroll it back...
				((CEdit*)pGrid->m_pControlWnd)->LineScroll(-10, 0);
			}
		}
		break;
		
	case editCombo:
	case listCombo:
		// FUTURE: NYI
		break;
	}
}

BOOL CGridControlRow::OnAccept(CWnd* pControlWnd)
{
	return TRUE;
}

int CGridControlRow::GetNextControlColumn(int nColumn)
{
	int nColumnCount = GetGrid()->GetColumnCount();
	return nColumn == nColumnCount - 1 ? 0 : nColumn + 1;
}

int CGridControlRow::GetPrevControlColumn(int nColumn)
{
	int nColumnCount = GetGrid()->GetColumnCount();
	return nColumn <= 0 ? nColumnCount - 1 : nColumn - 1;
}

void CGridControlRow::OnChangeColumnText(int nColumn, const char* szText)
{
}

void CGridControlRow::AddListItems(int nColumn, CComboBox* pComboBox)
{

}

/////////////////////////////////////////////////////////////////////////////
// CGridCellRow

CGridCellRow::CGridCellRow(CGridWnd* pGrid) : CGridRow(pGrid)
{
}

CGridCellRow::~CGridCellRow()
{
	int nColumnCount = GetGrid()->GetColumnCount();
	for (int nColumn = 0; nColumn < nColumnCount; nColumn += 1)
		delete GetCell(nColumn);
}

void CGridCellRow::DrawCell(CDC* pDC, const CRect& cellRect, int nColumn)
{
	CGridCell* pCell = GetCell(nColumn);
	pCell->Draw(pDC, cellRect);
}

void CGridCellRow::ResetSize(CDC* pDC)
{
	int nColumnCount = GetGrid()->GetColumnCount();
	int cyHeight = 4; // FUTURE: minimum row height...
	for (int nColumn = 0; nColumn < nColumnCount; nColumn += 1)
	{
		CGridCell* pCell = GetCell(nColumn);
		pCell->ResetSize(pDC);
		int cyCell = pCell->GetSize().cy;
		if (cyCell > cyHeight)
			cyHeight = cyCell;
	}
	
	m_cyHeight = cyHeight;
}

int CGridCellRow::Compare(const CGridRow* pCompareRow) const
{
	int nSortColumn = GetGrid()->m_nSortColumn;
	return GetCell(nSortColumn)->m_str.Compare(((CGridCellRow*)pCompareRow)->GetCell(nSortColumn)->m_str);
}

BOOL CGridCellRow::CreateCells()
{
	int nColumnCount = GetGrid()->GetColumnCount();
	for (int nColumn = 0; nColumn < nColumnCount; nColumn += 1)
	{
		CGridCell* pCell = new CGridCell;
		pCell->m_pRow = this;
		pCell->m_nColumn = nColumn;
		m_cells.Add(pCell);
	}
	
	return TRUE;
}

CGridElement* CGridCellRow::ElementFromPoint(const CPoint& point)
{
	int x = 0;
	for (int nColumn = 0; nColumn < GetGrid()->GetColumnCount(); nColumn += 1)
	{
		x += GetGrid()->GetColumnWidth(nColumn);
		if (point.x < x)
			break;
	}
	
	if ( nColumn == GetGrid()->GetColumnCount() )
		return NULL;
	else
		return GetCell(nColumn);
}


/////////////////////////////////////////////////////////////////////////////
// CGridCaptionCell

CGridCaptionCell::CGridCaptionCell(BOOL bDisplay)
{
	m_bPressed = FALSE;
	m_bFixedWidth = FALSE;
	m_trackZone = none;
	m_dt &= ~DT_WORDBREAK;
}

CGridCaptionCell::HitZone CGridCaptionCell::GetHitZone(const CPoint& point)
{
	CRect cellRect;
	GetRect(cellRect);
	
	if (GetColumnIndex() > 0 && point.x < cellRect.left + 2 )
	{
		// Exclude fixed width columns.
		if (!((CGridCaption *)GetRow())->IsColumnFixedWidth(GetColumnIndex() - 1))
			return resizeLeft;
	}
	
	if (GetColumnIndex() < GetGrid()->GetColumnCount() - 1 &&
		point.x > cellRect.right - 3)
	{
		if ( !m_bFixedWidth )
			return resizeRight;
	}
	
	return select;
}

void CGridCaptionCell::InvertResizeTracker(CDC* pDC)
{
#ifndef DYNAMIC_SIZING
	BOOL bReleaseDC = FALSE;
	if (pDC == NULL)
	{
		bReleaseDC = TRUE;
		pDC = GetGrid()->GetDC();
	}
		
	// NYI: select a 50% halftone brush
	
	pDC->PatBlt(m_xSizeTracker, 0, 2, 32767, PATINVERT);
	
	if (bReleaseDC)
		GetGrid()->ReleaseDC(pDC);
#endif
}

BOOL CGridCaptionCell::OnLButtonDown(UINT nFlags, CPoint point)
{
	SetCapture();
	m_trackZone = GetHitZone(point);
	switch (m_trackZone)
	{
	case resizeLeft:
	case resizeRight:
		m_xSizeTracker = point.x;
		GetGrid()->UpdateWindow();
		InvertResizeTracker();
		break;
		
	case select:
#ifdef SORT_COLUMNS
		if (GetGrid()->m_bSort)
		{	
			m_bPressed = TRUE;
			Invalidate();
		}
#endif		
		break;
	}
	
	return TRUE;
}

BOOL CGridCaptionCell::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	int nColumn = GetColumnIndex();
	
	switch (GetHitZone(point))
	{
	case resizeLeft:
		if (nColumn > 0)
			GetGrid()->SizeColumnToFit(nColumn - 1);
		break;
		
	case resizeRight:
		GetGrid()->SizeColumnToFit(nColumn);
		break;
	}
	
	return TRUE;
}

void CGridCaptionCell::SizeFromTracker()
{
	InvertResizeTracker();

	int nColumn = GetColumnIndex();
	if (m_trackZone == resizeLeft)
	{
		ASSERT(nColumn > 0);
		nColumn -= 1;
	}
			
	CGridWnd* pGrid = GetGrid();
	CGridCell* pLeftCell = pGrid->GetCaptionRow()->GetCell(nColumn);
	CGridCell* pRightCell = pGrid->GetCaptionRow()->GetCell(nColumn + 1); // may be NULL
			
	CRect cellRect;
	pLeftCell->GetRect(cellRect);
	int dx = m_xSizeTracker - cellRect.right;

	pLeftCell->m_size.cx += dx;
			
	if (pRightCell != NULL)
		pRightCell->m_size.cx -= dx;
			
	pGrid->ResetSize();
	pGrid->Invalidate(FALSE);
	pGrid->ResetScrollBars();
}

BOOL CGridCaptionCell::OnLButtonUp(UINT nFlags, CPoint point)
{
	ReleaseCapture();
		
	switch (m_trackZone)
	{
	case resizeRight:
	case resizeLeft:
#ifndef DYNAMIC_SIZING
		SizeFromTracker();
#endif
		break;
		
	case select:
		if (m_bPressed)
		{
#ifdef SORT_COLUMNS	
			if (GetGrid()->m_bSort)
			{	
				m_bPressed = FALSE;
				Invalidate();
				GetGrid()->SortColumn(GetColumnIndex(), (nFlags & MK_SHIFT) != 0);
			}
#endif			
		}
		break;
	}
	
	m_trackZone = none;
	
	return TRUE;
}

BOOL CGridCaptionCell::OnMouseMove(UINT nFlags, CPoint point)
{
	switch (m_trackZone == none ? GetHitZone(point) : m_trackZone)
	{
	case resizeLeft:
	case resizeRight:
		SetCursor(AfxGetApp()->LoadCursor(IDC_SIZE_BAR_HORZ));
		break;
				
	default:
		SetCursor(LoadCursor(NULL, IDC_ARROW));
		break;
	}
	
	switch (m_trackZone)
	{
	case none:
		// Just set the cursor (already done)...
		break;

	case resizeLeft:
	case resizeRight:
		// The user is resizing a column...
		{
			CGridWnd* pGrid = GetGrid();
			CRect rect;
			GetRect(rect);
			if (m_trackZone == resizeLeft)
				rect.left -= pGrid->GetColumnWidth(GetColumnIndex() - 1);
			else
				rect.right += pGrid->GetColumnWidth(GetColumnIndex() + 1);
			
			InvertResizeTracker();
			
			m_xSizeTracker = point.x;
			if (m_xSizeTracker < rect.left)
				m_xSizeTracker = rect.left;
			else if (m_xSizeTracker > rect.right)
				m_xSizeTracker = rect.right;

			InvertResizeTracker();

#ifdef DYNAMIC_SIZING
			SizeFromTracker();
			pGrid->UpdateWindow();
#endif
		}
		break;
		
	case select:
		{
			// The user clicked in the "button" so we track the mouse
			// to see if they let go in there too..
#ifdef SORT_COLUMNS		
			if ( GetGrid()->m_bSort )		
			{
				CRect cellRect;
				GetRect(cellRect);
				if (cellRect.PtInRect(point))
				{
					if (!m_bPressed)
					{
						m_bPressed = TRUE;
						Invalidate();
					}
				}
				else
				{
					if (m_bPressed)
					{
						m_bPressed = FALSE;
						Invalidate();
					}
				}
			}
#endif					
		}
		break;
	}
	
	return TRUE;
}

void CGridCaptionCell::Draw(CDC* pDC, const CRect& cellRect)
{
	CBrush whiteBrush;
	if (!whiteBrush.CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)))
		return;

	CBrush blackBrush;
	if (!blackBrush.CreateSolidBrush(GetSysColor(COLOR_BTNTEXT)))
		return;

	CBrush* pOldBrush = pDC->SelectObject(m_bPressed ? &blackBrush : &whiteBrush);
	pDC->PatBlt(cellRect.left, cellRect.top, cellRect.Width() - 1, 1, PATCOPY);
	pDC->PatBlt(cellRect.left, cellRect.top + 1, 1, cellRect.Height() - 2, PATCOPY);
	
	pDC->SelectObject(m_bPressed ? &whiteBrush : &blackBrush);
	pDC->PatBlt(cellRect.right - 1, cellRect.top, 1, cellRect.Height(), PATCOPY);
	pDC->PatBlt(cellRect.left, cellRect.bottom - 1, cellRect.Width(), 1, PATCOPY);
	
	pDC->SelectObject(pOldBrush);
	
	COLORREF oldBkColor = pDC->SetBkColor(GetSysColor(COLOR_BTNFACE));
	COLORREF oldTextColor = pDC->SetTextColor(GetSysColor(COLOR_BTNTEXT));
	CSize textSize = pDC->GetTextExtent(m_str, m_str.GetLength());
	
	CRect rect = cellRect;
	rect.InflateRect(-1, -1); // border
	
	int xText = rect.left + 1;
	int cxText = pDC->GetTextExtent(m_str, m_str.GetLength()).cx;
	if ((m_dt & DT_CENTER) != 0)
	{
		xText += (rect.Width() - cxText) / 2;
	}
	else if ((m_dt & DT_RIGHT) != 0)
	{
		xText = rect.right - 1 - cxText;
	}
	pDC->ExtTextOut(xText + m_bPressed, rect.top + 1 + m_bPressed,
		ETO_OPAQUE | ETO_CLIPPED, &rect, m_str, m_str.GetLength(), NULL);
	pDC->SetBkColor(oldBkColor);
	pDC->SetTextColor(oldTextColor);
}

void CGridCaptionCell::ResetSize(CDC* pDC)
{
	CRect rect(0, 0, GetGrid()->GetColumnWidth(GetColumnIndex()), 0);
	if (rect.Width() <= 0)
	{
		m_size.cx = m_size.cy = 0;
	}
	else
	{
		m_size = rect.Size();
		pDC->DrawText(m_str, m_str.GetLength(), rect, DT_CALCRECT | DT_NOPREFIX | m_dt);
		m_size.cy = rect.Height() + 3;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGridCaption

CGridCaption::CGridCaption(CGridWnd* pGrid, BOOL bDisplay)
	: CGridCellRow(pGrid)
{
	int nColumnCount = pGrid->GetColumnCount();
	for (int nColumn = 0; nColumn < nColumnCount; nColumn += 1)
	{
		CGridCaptionCell* pCell = new CGridCaptionCell(bDisplay);
		pCell->m_pRow = this;
		pCell->m_nColumn = nColumn;
		m_cells.Add(pCell);
	}

	m_bDisplay = bDisplay;
}

void CGridCaption::GetRect(CRect& rowRect)
{
	GetGrid()->GetClientRect(rowRect);
	rowRect.bottom = rowRect.top + m_cyHeight;
}

void CGridCaption::ResetSize(CDC* pDC)
{
	if (!m_bDisplay)
	{
		m_cyHeight = 0;
	}
	else
	{
		int nColumnCount = GetGrid()->GetColumnCount();
		int cyHeight = 4; // FUTURE: minimum row height...
		for (int nColumn = 0; nColumn < nColumnCount; nColumn += 1)
		{
			CGridCell* pCell = GetCell(nColumn);
			pCell->ResetSize(pDC);
			int cyCell = pCell->GetSize().cy;
			if (cyCell > cyHeight)
				cyHeight = cyCell;
		}
	
		m_cyHeight = cyHeight;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGridWnd


CGridWnd::CGridWnd(int nColumns, BOOL bDisplayCaption )
{
	m_nColumnCount = nColumns;
	m_cyScroll = 0;
	m_posTopVisibleRow = NULL;
	m_pCaptureElement = NULL;
	
	m_posCurRow = NULL;
	m_nCurColumn = 0;
	m_bShowSelection = TRUE;

	m_nSortColumn = -1; // not sorted
	m_bReverseSort = FALSE;
	
	m_bHasCells = FALSE;
	
	m_bDragSelecting = FALSE;
	m_bDragRow = FALSE;
	m_pDropRow = NULL;
	m_pFirstSelect = NULL;

	m_pFont = NULL ;
	m_pCaptionFont = NULL ;

	m_bSysDefaultColors = TRUE;
		
	m_pActiveElement = NULL;

	m_fMultiSelect = TRUE;
	m_bSort = TRUE;
	m_bAutoSort = TRUE;
	m_bShowContextPopup = FALSE;
	m_bShowProperties = FALSE;
	m_bDestruct = FALSE;
	m_bEnableDragRow = FALSE;
	m_bEnableEllipse = FALSE;

	m_bBtnDownValid = FALSE;  // only used in LBUTTONDOWN processing

	m_cxSelectMargin = cxSelectMargin;
	
	m_rows.AddHead(new CGridCaption(this, bDisplayCaption));
	m_pToolBar = NULL;

}

CGridWnd::~CGridWnd()
{
	if (m_pToolBar != NULL)
	{
		delete m_pToolBar;
		m_pToolBar = NULL;
	}

	// Clearing these speeds up row deletion
	m_selection.RemoveAll();
	m_posCurRow = NULL;
	m_posTopVisibleRow = NULL;
	m_cyScroll = 0;

	m_bDestruct = TRUE;
	while (!m_rows.IsEmpty())
		delete (CGridRow*)m_rows.GetHead();
}

BOOL CGridWnd::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	return CreateEx(0, dwStyle, rect, pParentWnd, nID);
}

BOOL CGridWnd::CreateEx(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	return CWnd::CreateEx(dwExStyle, AfxRegisterWndClass(CS_DBLCLKS), NULL, dwStyle,
	                      rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
	                      pParentWnd->GetSafeHwnd(), (HMENU)nID, NULL);
}

UINT rgidBtnGrid [] =
{
	ID_GRD_NEW,
	ID_GRD_DELETE,
	ID_GRD_MOVEUP,
	ID_GRD_MOVEDOWN,
};

BOOL CGridWnd::ReplaceControl(CWnd* pWnd, UINT nIDTemp, UINT nIDGrid,
	DWORD dwStyle /*= WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP*/, 
	DWORD dwExStyle /*= WS_EX_CLIENTEDGE */,
	DWORD dwTBStyle /* = GRIDWND_TB_NOTOOLBAR */,
	BOOL bRemovePlaceholder /* = TRUE */)
{
	// Get the place holder window
	CWnd* pReplace = pWnd->GetDlgItem(nIDTemp);
	if (pReplace == NULL)
		return FALSE;
	ASSERT_VALID(pReplace);
	
	// Get the correct location and size
	CRect rcGrid;
	CRect rcStatic;
	pReplace->GetWindowRect(rcGrid);
	pWnd->ScreenToClient(rcGrid);
	rcStatic = rcGrid;

	CString strLabel;
	pReplace->GetWindowText(strLabel);

	// we layout the text at least if present
	BOOL fNeedStatic =  (dwTBStyle != GRIDWND_TB_NOTOOLBAR || !strLabel.IsEmpty());

	if (fNeedStatic)
	{    		
		CRect rcToolBar;
		if (dwTBStyle != GRIDWND_TB_NOTOOLBAR)
		{
			CWnd *pwndParent = pWnd;

			int cBtnToolBar = 0;
			int iRgidBtnGrid = 0;
			BOOL fDelOnly = (dwTBStyle == GRIDWND_TB_DELETE);
			UINT nIDBitmap = (fDelOnly ? IDR_GRD_TB_DELETE : IDR_GRD_TOOLBAR);
				
			if (dwTBStyle & GRIDWND_TB_NEW)
				cBtnToolBar++;
			if (dwTBStyle & GRIDWND_TB_DELETE)
			{
				cBtnToolBar++;
				if (!(dwTBStyle & GRIDWND_TB_NEW))
					iRgidBtnGrid = 1;
			}
			
			if (dwTBStyle & GRIDWND_TB_MOVE)
			{
				cBtnToolBar += 2;
				if (!(dwTBStyle & (GRIDWND_TB_NEW | GRIDWND_TB_DELETE)))
					iRgidBtnGrid = 2;
			}
			
			if( !pwndParent->IsKindOf(RUNTIME_CLASS(CDialog)))
			{
				ASSERT(FALSE); // only grid controls in dialogs should be using toolbars. We will ignore flag otherwise bobz
				return (FALSE);
			}

			if (m_pToolBar == NULL)
				m_pToolBar = new CGridToolBar;

			// create as child of dialog. Will set owner to grid later
			DWORD dwStyleTB = WS_CHILD | WS_VISIBLE | CBRS_ALIGN_TOP | CBRS_TOOLTIPS | CBRS_FLYBY;
			if (m_pToolBar == NULL)
				{
				TRACE("Failed to Create/Init ToolBar\n");
				return FALSE;
				}

			if	(m_pToolBar->m_hWnd == NULL)
				if (m_pToolBar->Create(pwndParent, dwStyleTB) == 0)
				{
					TRACE("Failed to Create/Init ToolBar\n");
					return FALSE;
				}

			if (!m_pToolBar->LoadBitmap(nIDBitmap) ||
				!m_pToolBar->SetButtons(&rgidBtnGrid[iRgidBtnGrid], cBtnToolBar))
			{
				TRACE("Failed to Create/Init ToolBar\n");
				return FALSE;
			}
		
			m_pToolBar->SetSizes();
			// force tooltips
			m_pToolBar->EnableToolTips(TRUE);

			// reposition toolbar outside of parent window. at corner of grid
			// at create time toolbar size is set to 0. Use the rect of the first and last button to
			// determine toolbar size

			CRect rcFirst;
			CRect rcLast;
			CSize csizeTB;
			CSize csizeText;
			int cyStatic;

			rcFirst.SetRectEmpty();
			rcLast.SetRectEmpty();

			m_pToolBar->GetItemRect(0, rcFirst);
			ASSERT(cBtnToolBar > 0);
			m_pToolBar->GetItemRect(cBtnToolBar - 1, rcLast);
			// rcLast.right is end of last btn from start of toolbar (includes left border). 
			// Add in rcFirst.left to get end border width
			csizeTB.cx = rcLast.right + rcFirst.left;
			csizeTB.cy = rcFirst.Height() + 2 * rcFirst.top;   // top offset is border height. 2 for top and bottom

			CWindowDC dc(pReplace);
			CFont* pfontOld = dc.SelectObject(GetStdFont(font_Normal));
			csizeText = dc.GetTextExtent(strLabel, 1); // get font height
			dc.SelectObject(pfontOld);
			
			// height of window enclosing toolbar based on max of toolbar and font
			cyStatic = max(csizeText.cy, csizeTB.cy);
			int cyOffset = (cyStatic - csizeTB.cy) / 2; // so we center in window
			
			// NOTE: bobz these offsets will only work if the static text has a sunken border
#define cyBorderTop (1)
#define cxBorderRight (1)
			
			// center toolbar vertically in static window
			rcToolBar.top = rcGrid.top + cyOffset + cyBorderTop;
			rcToolBar.right = rcGrid.right - cxBorderRight;
			rcToolBar.left = rcToolBar.right - csizeTB.cx;
			rcToolBar.bottom = rcToolBar.top + csizeTB.cy;

			// adjust rcGrid to exclude the toolbar. 2 for the borders.
			rcGrid.top += cyStatic + (cyBorderTop * 2);

			// position the toolbar 
			m_pToolBar->SetWindowPos(pReplace, rcToolBar.left, rcToolBar.top,
				rcToolBar.Width(), rcToolBar.Height(), SWP_NOACTIVATE);
		}
		else  // no toolbar, but leave room for text. Use height of caption row
		{
			rcGrid.top += GetCaptionRow()->GetRowHeight();
		}

		// create a CStaticVCenter window from the placeholder, with same text and border styles
		// size will be based on what we have now
		// make it a child of the dialog, so it can be outside the grid
		
		rcStatic.bottom = rcGrid.top;
		
		if (!m_cstatVCenter.Create(strLabel, (pReplace->GetStyle() | WS_CLIPSIBLINGS) , rcStatic, pWnd))
		{
			return FALSE;
		}

		m_cstatVCenter.SetFont(GetStdFont(font_Normal));
	}

	// Create the grid

		// NT won't draw clientedge border, so force in normal border
	if (!UseWin4Look())
	{
		if (dwExStyle & WS_EX_CLIENTEDGE)
			dwStyle |= WS_BORDER;
	}

	if (!CreateEx(dwExStyle, dwStyle, rcGrid, pWnd, nIDGrid))
		return FALSE;
	
	// set the control help ID on the grid to be the ID that the placeholder had.
	DWORD dwHelpID = pReplace->GetWindowContextHelpId();
	if (dwHelpID)
		SetWindowContextHelpId(dwHelpID);

	// tab order of controls: toolbar, static, grid. Position in reverse order, all
	// with respect to pReplace

	// Fix the grid control's Z-Order
	SetWindowPos(pReplace, 0, 0, 0, 0,
		SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOSIZE);
	
	if (fNeedStatic)
	{
				// Fix the static control's Z-Order
		m_cstatVCenter.SetWindowPos(pReplace, 0, 0, 0, 0,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOSIZE);
	}

	// establish toolbar chain of command
	if (m_pToolBar != NULL)
	{
		m_pToolBar->SetOwner(this);
					// Fix the toolbar control's Z-Order
		m_pToolBar->SetWindowPos(pReplace, 0, 0, 0, 0,
			SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOREDRAW | SWP_NOSIZE);
	}


	if (bRemovePlaceholder)
			pReplace->DestroyWindow();

	return TRUE;
}



IMPLEMENT_DYNAMIC(CGridWnd, CWnd)

BEGIN_MESSAGE_MAP(CGridWnd, CWnd)
	//{{AFX_MSG_MAP(CGridWnd)
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_SYSKEYDOWN()
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_SIZE()
	ON_WM_VSCROLL()
	ON_WM_TIMER()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0x0000, 0xffff, OnToolTipText)
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0x0000, 0xffff, OnToolTipText)
	ON_WM_SHOWWINDOW()
	ON_WM_ENABLE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGridWnd message handlers

int CGridWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if ( m_pFont == NULL )
	{	
		m_pFont = GetStdFont(FALSE);
	}
	if ( m_pCaptionFont == NULL )
	{
		m_pCaptionFont = GetStdFont(TRUE);
	}

	CWnd* pParent = GetParent();
	if (pParent != NULL)
	{
		if (pParent->IsKindOf(RUNTIME_CLASS(CDialog)))
			m_bParentIsDialog = TRUE;
		else
			m_bParentIsDialog = FALSE;
	}
	else
	{
		ASSERT (FALSE);
		m_bParentIsDialog = FALSE;
	}


	ResetSize();
	
	return 0;
}

// NOTE: Only works if point is on or below a visible row!
CGridElement* CGridWnd::ElementFromPoint(const CPoint& point)
{
	CGridRow* pRow = GetCaptionRow();
	if (point.y < pRow->GetRowHeight())
		return pRow->ElementFromPoint(point);
	
	int y = pRow->GetRowHeight() - m_cyScroll;
	for (POSITION posRow = m_posTopVisibleRow; posRow != NULL; )
	{
		pRow = GetNextRow(posRow);
		y += pRow->GetRowHeight();
		if (point.y < y)
			return pRow->ElementFromPoint(point);
	}
	
	return NULL;
}

void CGridWnd::SetFont( CFont *pNewFont,  BOOL bRedraw /* TRUE */  )
{
	m_pFont = pNewFont ;
	
	if ( m_hWnd != NULL &&  bRedraw )
 	{
		ResetSize( );
		Invalidate( );
		ResetScrollBars( );
	}
}

void CGridWnd::SetCaptionFont( CFont *pNewFont,  BOOL bRedraw /* TRUE */  )
{

	m_pCaptionFont = pNewFont ;

	if ( m_hWnd != NULL && bRedraw )
 	{
		ResetSize( );
		Invalidate( );																				
		ResetScrollBars( );
	}
}

void CGridWnd::SetColor(COLORREF colorText, COLORREF colorBk, COLORREF colorHighlight,
					COLORREF colorHighlightText)
{
	m_bSysDefaultColors = FALSE;
	m_colorWindowText = colorText;
	m_colorWindow = colorBk;
	m_colorHighlightText = colorHighlightText;
	m_colorHighlight = colorHighlight;

	if (m_hWnd != NULL)
		Invalidate();
}

void CGridWnd::EnableMultiSelect( BOOL fEnable /* = TRUE */ )
{
	m_fMultiSelect = fEnable;
}

void CGridWnd::EnableAutoSort( BOOL bEnable /* = TRUE */ )
{
	m_bAutoSort = bEnable;
}

void CGridWnd::EnableSort( BOOL bEnable /* = TRUE */ )
{
	m_bSort = bEnable;
}
	
BOOL CGridWnd::BeginDrag(UINT nFlags, const CPoint& point)
{
	// Override this function to provide drag'n'drop functionality...
	// This will be called from OnLButtonDown with the same flags and
	// mouse point.  Return TRUE if your grid is going to initiate a
	// drag'n'drop, or FALSE to use the default (extend selection).

	if (m_bEnableDragRow)
	{
		// Begin a row drag
		m_bDragSelecting = FALSE;
		m_bDragRow = TRUE;
		m_pDropRow = NULL;
		SetCapture();

		DWORD dwTimeout; // NT Defines this lparam as LPDWORD
		SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &dwTimeout, FALSE);
		SetTimer(0, dwTimeout, NULL);

		return TRUE;
	}
	return FALSE;
}

void CGridWnd::DoDragDrop(CPoint point)
{
	// NOP
}

BOOL CGridWnd::ProcessKeyboard(MSG* pMsg, BOOL bPreTrans /*= FALSE*/)
{
	if (pMsg->message == WM_KEYDOWN && GetHeadRowPosition() != NULL)
	{
		UINT nChar = (UINT)pMsg->wParam;
		UINT nRepCnt = (UINT)LOWORD(pMsg->lParam);
		UINT nFlags = (UINT)HIWORD(pMsg->lParam);
		BOOL bShift = GetKeyState(VK_SHIFT) < 0;
		BOOL bControl = GetKeyState(VK_CONTROL) < 0;

		switch (nChar)
		{

		case VK_ESCAPE:
			ClearSelection();
			break;

		case VK_UP:
			{
				if (m_bHasCells)
				{
					if (m_posCurRow == NULL)
					{
						m_posCurRow = GetHeadRowPosition();
						Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn));
					}
					else if (m_posCurRow != GetHeadRowPosition())
					{
						GetPrevRow(m_posCurRow);
						Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn),
							bShift || bControl);
					}
				}
				else
				{
					if (m_posCurRow == NULL)
					{
						m_posCurRow = GetHeadRowPosition();
						Select(GetRowAt(m_posCurRow));
					}
					else if (m_posCurRow != GetHeadRowPosition())
					{
						GetPrevRow(m_posCurRow);
						Select(GetRowAt(m_posCurRow), bShift || bControl);
					}
				}
			}
			return TRUE;

		case VK_DOWN:
			{
				if (m_bHasCells)
				{
					if (m_posCurRow == NULL)
					{
						m_posCurRow = GetHeadRowPosition();
						Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn));
					}
					else if (m_posCurRow != m_rows.GetTailPosition())
					{
						GetNextRow(m_posCurRow);
						Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn),
							bShift || bControl);
					}
				}
				else
				{
					if (m_posCurRow == NULL)
					{
						m_posCurRow = GetHeadRowPosition();
						Select(GetRowAt(m_posCurRow));
					}
					else if (m_posCurRow != m_rows.GetTailPosition())
					{
						GetNextRow(m_posCurRow);
						Select(GetRowAt(m_posCurRow), bShift || bControl);
					}
				}
			}
			return TRUE;
	
		case VK_LEFT:
			if (m_bHasCells)
			{
				if  (m_nCurColumn > 0)
				{
					Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn - 1),
						bShift || bControl);
				}
				return TRUE;
			}
			break;
	
		case VK_RIGHT:
			if (m_bHasCells)
			{
				if ( m_nCurColumn < GetColumnCount() - 1 )
				{
					Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn + 1),
						bShift || bControl);
				}
				return TRUE;
			}
			break;

		case VK_HOME:
		case VK_END:
			{
				UINT nColumn = (nChar == VK_HOME)? 0 : GetColumnCount();
				 
				if (bControl || !m_bHasCells)
				{
					m_posCurRow = (nChar == VK_HOME) ? 
									GetHeadRowPosition() : m_rows.GetTailPosition();

					CGridElement * pElementTo;

					if (m_bHasCells)
						pElementTo = GetCellRowAt(m_posCurRow)->GetCell(nColumn);
					else
						pElementTo = GetRowAt(m_posCurRow);

					if (bShift && GetHeadSelPosition() != NULL)
					{
						CGridElement * pElementFrom = (CGridElement *)m_selection.GetHead();
						SelectBetween(pElementFrom, pElementTo); 
					}

					Select(pElementTo, bShift);	 // Will ensure this is the primary selection.
				}
				else if (m_bHasCells)
				{
					Select(GetCellRowAt(m_posCurRow)->GetCell(nColumn), bShift);
				}			
				return TRUE;
			}

		case VK_NEXT:
		case VK_PRIOR:
			CRect rect;
			POSITION pos;
			int yCurPos, y;
			
			if (bControl)
				break;

			// Get the y coord (ignoring caption rows) of the selection
			if (!m_posCurRow)
				m_posCurRow = m_posTopVisibleRow;
			ASSERT( m_posCurRow );
			ScrollIntoView( GetRowAt(m_posCurRow) );

			pos = m_posTopVisibleRow;
			yCurPos = 0;
			while (pos != m_posCurRow)
			{
				yCurPos += GetRowAt(pos)->GetRowHeight();
				GetNextRow(pos);
			}

			// Scroll by a screenfull
			GetClientRect( &rect );
			VScroll( (rect.bottom - GetCaptionRow()->GetRowHeight()) * ((nChar == VK_NEXT) ? 1 : -1));

			// Set selection
			int yScrollPos = GetScrollPos(SB_VERT);
			int yScrollMin, yScrollLim;
			GetScrollRange(SB_VERT, &yScrollMin, &yScrollLim);

			if ((yScrollPos == yScrollMin) && (nChar == VK_PRIOR))
			{
				m_posCurRow = GetHeadRowPosition();
			}
			else if ((yScrollPos == yScrollLim) && (nChar == VK_NEXT))
			{
				m_posCurRow = m_rows.GetTailPosition();
			}
			else
			{
				pos = m_posTopVisibleRow;
				y = 0;
				while (pos && (y < yCurPos))
				{
					y += GetRowAt(pos)->GetRowHeight();
					GetNextRow(pos);
				}
				m_posCurRow = pos;
				if (!m_posCurRow)
					m_posCurRow = m_posTopVisibleRow;
			}

			ASSERT( m_posCurRow );
			if (m_bHasCells)
				Select(GetCellRowAt(m_posCurRow)->GetCell(m_nCurColumn), bShift || bControl);
			else
				Select(GetRowAt(m_posCurRow), bShift || bControl);
			return TRUE;
		}
	} 

	if (bPreTrans)
		return CWnd::PreTranslateMessage(pMsg);
	else
		return FALSE;
}

void CGridWnd::AdjustDropRow(CGridRow* &rpDropRow)
{
}

void CGridWnd::InvalidateSelection(CGridElement* pElement)
{
	if (pElement != NULL)
	{
		// We have a new primary element...
		
		pElement->Invalidate();
		
		if (m_selection.GetCount() > 1)
		{
			// Invalidate the old primary as well
			POSITION pos = m_selection.GetHeadPosition();
			m_selection.GetNext(pos);
			((CGridElement*)m_selection.GetAt(pos))->Invalidate();
		}
	}
	else
	{
		// Invalidate the whole selection...
		
		POSITION pos = m_selection.GetHeadPosition();
		while (pos != NULL)
			((CGridElement*)m_selection.GetNext(pos))->Invalidate(FALSE, TRUE);
	}
}

void CGridWnd::ScrollIntoView(CGridRow* pRow)
{
	CRect rowRect;
	pRow->GetRect(rowRect);
	
	CRect view;
	GetClientRect(view);
	view.top += GetCaptionRow()->GetRowHeight();
	
	if (rowRect.top < view.top)
	{
		VScroll(rowRect.top - view.top);
	}
	else if (rowRect.bottom >= view.bottom)
	{
		VScroll(rowRect.bottom - view.bottom);
	}
}

void CGridWnd::ClearSelection()
{
	SetActiveElement(NULL);
	InvalidateSelection();

	POSITION pos = m_selection.GetHeadPosition();
	while (pos != NULL)
		((CGridElement*)m_selection.GetNext(pos))->OnSelect(FALSE);

	m_selection.RemoveAll();
}

void CGridWnd::ShowSelection(BOOL bShow /* =TRUE */)
{ 
	if (m_bShowSelection == bShow)
		return;

	m_bShowSelection = bShow;
	InvalidateSelection();
}

void CGridWnd::Deselect(CGridElement* pElement)
{
	POSITION pos = m_selection.Find(pElement);
	if (pos != NULL)
	{
		if (pElement == m_pActiveElement)
			SetActiveElement(NULL);
		
		pElement->Invalidate();
		pElement->OnSelect(FALSE);
		m_selection.RemoveAt(pos);
		InvalidateSelection(NULL);
	}
}

void CGridWnd::Select(CGridElement* pElement, BOOL bAdd)
{
	CloseActiveElement();
	if (!bAdd || !m_fMultiSelect)	 // single select
		ClearSelection();
	
	POSITION pos = m_selection.Find(pElement);
	if (pos != NULL)
		m_selection.RemoveAt(pos);
	
	m_selection.AddHead(pElement);
	pElement->OnSelect(TRUE);
	
	CGridRow* pRow = pElement->GetRow();
	if (pElement->m_bIsCell)
	{
		CGridCell* pCell = (CGridCell*)pElement;
		m_nCurColumn = pCell->GetColumnIndex();
	}

	// Update the keyboard position
	if (m_posCurRow == NULL || GetRowAt(m_posCurRow) != pRow)
		m_posCurRow = m_rows.Find(pRow);

	ScrollIntoView(pRow);
	InvalidateSelection(pElement);
}

void CGridWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ProcessKeyboard((MSG*)GetCurrentMessage());
}

void CGridWnd::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	MSG *pMsg = (MSG *)GetCurrentMessage();
	if(!ProcessKeyboard(pMsg))
		DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
}

BOOL CGridWnd::SubclassDlgItem(UINT nID, CWnd* pParent)
{
	if (!CWnd::SubclassDlgItem(nID, pParent))
		return FALSE;
	
	return TRUE;
}


void CGridWnd::SetColumnCaption(int nColumn, const char* szCaption)
{
	GetCaptionRow()->GetCell(nColumn)->SetText(szCaption);
}

void CGridWnd::SetColumnWidth(int nColumn, int cxWidth)
{
	GetCaptionRow()->GetCell(nColumn)->m_size.cx = cxWidth;
	ResetSize();
	
	if (m_hWnd)
		Invalidate(); // FUTURE: Invalidate selectively
}

POSITION CGridWnd::GetHeadRowPosition() const
{
	POSITION pos = m_rows.GetHeadPosition();
	m_rows.GetNext(pos); // first one is caption row
	return pos;
}

void CGridWnd::OnPaint()
{
	CPaintDC dc(this);
	
	CGridRow* pRow;
	CRect rowRect;
	
	GetClientRect(rowRect);

	// Draw the captions first
	pRow = GetCaptionRow();
	rowRect.bottom = rowRect.top + pRow->m_cyHeight;
	if (dc.m_ps.rcPaint.top < rowRect.bottom)
	{
		CFont* pOldFont = dc.SelectObject(GetCaptionFont( ));
		pRow->Draw(&dc, rowRect);
		dc.SelectObject(pOldFont);
	}
	
	CFont* pOldFont = dc.SelectObject(GetFont( ));
	
	// Setup clip rect around the actual grid (client less captions)
	rowRect.top = rowRect.bottom;
	rowRect.bottom = dc.m_ps.rcPaint.bottom;
	dc.IntersectClipRect(rowRect);

	// Figure out where to start drawing
	POSITION pos = m_posTopVisibleRow;
	if (pos == NULL)
	{
		// Need to kickstart things
		pos = m_posTopVisibleRow = GetHeadRowPosition();
		m_cyScroll = 0;
	}
	
	CRect activeRowRect(0, 0, 0, 0);
	
	// Draw each row in turn
	rowRect.top -= m_cyScroll;
	while (pos != NULL)
	{
		CGridRow* pRow = GetNextRow(pos);
		rowRect.bottom = rowRect.top + pRow->m_cyHeight;
		if (rowRect.bottom > dc.m_ps.rcPaint.top)
			pRow->Draw(&dc, rowRect);
		
		if ((pRow == m_pActiveElement) && LooksSelected(pRow))
			activeRowRect = rowRect;
		
		rowRect.top = rowRect.bottom;
		
		if (rowRect.top >= dc.m_ps.rcPaint.bottom)
			break; // we're done!
	}
	
	// Erase the bottom of the window
	if (rowRect.top < dc.m_ps.rcPaint.bottom)
	{
		rowRect.bottom = dc.m_ps.rcPaint.bottom;
		dc.SetBkColor(GetWindowColor());
		dc.ExtTextOut(0, 0, ETO_OPAQUE, rowRect, NULL, 0, NULL);
	}
	
	if (!activeRowRect.IsRectEmpty())
	{
		CRect rect;
		dc.SetBkColor(GetHighlightColor());
		rect.left = activeRowRect.left;
		rect.top = activeRowRect.top - 3;
		rect.right = activeRowRect.right;
		rect.bottom = activeRowRect.top;
		dc.ExtTextOut(0, 0, ETO_OPAQUE, rect, NULL, 0, NULL);
		rect.top = activeRowRect.bottom;
		rect.bottom = activeRowRect.bottom + 3;
		dc.ExtTextOut(0, 0, ETO_OPAQUE, rect, NULL, 0, NULL);
	}
	
	dc.SelectObject(pOldFont);

	// Draw the drop marker
	if (m_pDropRow != NULL && m_pDropRow != GetCaptionRow())
	{
		BOOL bTop = TRUE;
		POSITION posSel = GetHeadSelPosition();
		if (posSel != NULL)
		{
			CGridElement* pHeadSelElem = GetNextSel(posSel);
			CGridRow* pHeadSel = pHeadSelElem->GetRow();

			POSITION pos = GetHeadRowPosition();
			while (pos != NULL)
			{
				CGridRow* pRow = GetNextRow(pos);
				ASSERT(pRow != NULL);

				if (pRow == pHeadSel)
				{
					bTop = FALSE;
					break;
				}
				else if (pRow == m_pDropRow)
				{
					break;
				}
			}
		}

		// BLOCK: Draw the drop marker
		{
			CBrush* pHalftone = dc.GetHalftoneBrush();
			CRect rcRow, rc;
			m_pDropRow->GetRect(rcRow);
			rcRow.left += m_cxSelectMargin / 2;
			rcRow.right -= m_cxSelectMargin / 2;

			int y = bTop ? rcRow.top - 1: rcRow.bottom - 1;
			m_rcDropInvalidate.SetRect(rcRow.left, y - 5,
			                           rcRow.right + 1, y + 8);

			// Draw the main line
			rc.SetRect(rcRow.left, y,
			           rcRow.right + 1, y + 3);
			dc.FillRect(rc, pHalftone);

			// Draw the left vertical line
			rc.SetRect(rc.left, y - 5,
			           rc.left + 3, y + 8);
			dc.FillRect(rc, pHalftone);

			// Draw the right vertical line
			rc.SetRect(rcRow.right - 2, y - 5,
			           rcRow.right + 1, y + 8);
			dc.FillRect(rc, pHalftone);
		}
	}
}

void CGridWnd::InvalidateColumn(int nColumn, BOOL bErase)
{
	CRect rect;
	GetCaptionRow()->GetCell(nColumn)->GetRect(rect);
	rect.bottom = 32767;
	InvalidateRect(rect, bErase);
}

void CGridWnd::SizeColumnToFit(int nColumn)
{
	CClientDC dc(this);
	CFont* pOldFont = dc.SelectObject(GetFont( ));
	
	int cxWidth = 0;
	POSITION pos = GetHeadRowPosition();
	while (pos != NULL)
	{
		int cxCell = GetNextRow(pos)->GetCellSize(&dc, nColumn).cx;
		if (cxCell > cxWidth)
			cxWidth = cxCell;
	}
	dc.SelectObject(pOldFont);
	
	CRect client;
	GetClientRect(client);
	CRect column;
	GetCaptionRow()->GetCell(nColumn)->GetRect(column);
	if (column.left + cxWidth > client.right)
		cxWidth = client.right - column.left;
	
	SetColumnWidth(nColumn, cxWidth);
	
	OnSize(SIZE_RESTORED, client.Width(), client.Height()); // adjust last column
}

#include <search.h>

static int CompareRows(const void* p1, const void* p2)
{
	const CGridRow* pRow1 = *(const CGridRow**)p1;
	const CGridRow* pRow2 = *(const CGridRow**)p2;
	return pRow1->Compare(pRow2);
}

void CGridWnd::SortColumn(int nColumn, BOOL bReverse)
{
	if (nColumn == m_nSortColumn && !bReverse == !m_bReverseSort && m_bAutoSort)
		return;
	
	CPtrArray rows;
	rows.SetSize(GetRowCount());
	POSITION pos = GetHeadRowPosition();
	int nRow = 0;
	while (pos != NULL)
		rows[nRow++] = GetNextRow(pos);
	
	m_bReverseSort = bReverse;

	if (m_nSortColumn != nColumn)
	{
		m_nSortColumn = nColumn;
		if ( rows.GetSize( ) > 0 )
			qsort(&rows[0], rows.GetSize(), sizeof (void*), CompareRows);
	}
	else
	{
		// Just reversing previous sort...
		bReverse = TRUE;
	}
	
	CGridRow* pCaptionRow = GetCaptionRow();
	CGridRow* pCurRow = m_posCurRow == NULL ? NULL : GetRowAt(m_posCurRow);

	m_rows.RemoveAll();
	for (nRow = 0; nRow < rows.GetSize(); nRow += 1)
	{
		if (bReverse)
			m_rows.AddHead(rows[nRow]);
		else
			m_rows.AddTail(rows[nRow]);
	}
	
	m_rows.AddHead(pCaptionRow);
	
	// Reset the position's that are cached...
	m_posTopVisibleRow = GetHeadRowPosition();//m_rows.Find(pTopRow);
	m_cyScroll = 0;
	SetScrollPos(SB_VERT, 0);
	
	if (pCurRow != NULL)
	{
		m_posCurRow = m_rows.Find(pCurRow);
		ScrollIntoView(pCurRow);
	}
	
	Invalidate(FALSE);
}

void CGridWnd::ReSort()
{
	// force grid to re-sort all entries; may be needed when items
	// have been added, deleted, or modified.
	int column = m_nSortColumn;
	m_nSortColumn = -1;
	SortColumn(column);
}

void CGridWnd::SelectBetween(CGridElement* pElement1, CGridElement* pElement2)
{
	int nIndex1 = 0;
	int nIndex2 = 0;

	if (!m_fMultiSelect)	// single select
	{
		Select(pElement2);
		return;
	}
			
	POSITION pos = GetHeadRowPosition();
	int nIndex = 1;
	while (pos != NULL)
	{
		CGridRow* pRow = GetRowAt(pos);
				
		if (pRow == pElement1)
			nIndex1 = nIndex;
				
		if (pRow == pElement2)
			nIndex2 = nIndex;
				
		if (nIndex1 != 0 && nIndex2 != 0)
			break;
				
		GetNextRow(pos);
		nIndex += 1;
	}
			
	ASSERT(nIndex1 != 0 && nIndex2 != 0);
			
	int nFirstSel = min(nIndex1, nIndex2);
	int nLastSel = max(nIndex1, nIndex2);
	pos = m_rows.FindIndex(nFirstSel);
	for (int n = nFirstSel; n <= nLastSel; n += 1)
	{
		CGridRow* pRow = GetNextRow(pos);
		if (!IsSelected(pRow))
			Select(pRow, TRUE);
	}
}

void CGridWnd::OnRButtonDown(UINT nFlags, CPoint point)
{
	CGridElement * pElement = ElementFromPoint(point);

	if (pElement != NULL && pElement->GetRow() != GetCaptionRow() 
	    && (point.x < m_cxSelectMargin || !IsSelected(pElement)) )
	{
		Select(pElement, FALSE);
		UpdateWindow(); // So we don't blow save bits
	}
}

void CGridWnd::OnRButtonUp(UINT nFlags, CPoint point)
{
	CSlobWnd* pWnd = GetActiveSlobWnd();
	if (!(m_bShowContextPopup && pWnd && pWnd->IsChild(this)))
		return;

	ClientToScreen(&point);
	pWnd->ShowContextPopupMenu(point);
}

CPoint CGridWnd::c_LastClick;
void CGridWnd::OnLButtonDown(UINT nFlags, CPoint point)
{
	// NOTE: m_bBtnDownValid is used to determine if we have lost focus during
	// the keydown processing. We currently set it true only in CGridCOntrolWnd::LButtonDown
	// and turn it off during KillFocus. In case we are called from another place, we
	// are careful to always reset it to FALSE, so if you return out of here,
	// please be sure to set it. (do a goto LRet rather than a return! bobz)

	c_LastClick = point;

	SetFocus();
	
	CGridElement* pElement = ElementFromPoint(point);
	if (pElement != NULL)
	{
		if (pElement->OnLButtonDown(nFlags, point))
			goto LRet;
		
		// Make a selection, unless the element is already selected
		// since we don't want to collapse the selection in the case
		// of a drag'n'drop...
		BOOL bSelected = IsSelected(pElement);
		if ((nFlags & MK_SHIFT) != 0 && !m_selection.IsEmpty())
		{
			bSelected = TRUE;
			SelectBetween((CGridElement*)m_selection.GetHead(), pElement);
			Select(pElement, TRUE); // this will ensure this is the primary selection
		}
		else if (point.x < m_cxSelectMargin || !bSelected)
		{
			bSelected = TRUE;
			Select(pElement, (nFlags & (MK_CONTROL | MK_SHIFT)));
		}
		else if (bSelected)
		{
			if (nFlags & MK_CONTROL)
			{
				// Ctl-click a selected row to deselect it
				if (m_fMultiSelect)
				{
					bSelected = FALSE;
					Deselect(pElement);
				}
			}
			else
			{
				Select(pElement, FALSE); // Ensure this is the primary selection
			}
		}
		ASSERT(bSelected == IsSelected(pElement));

		// make sure row is visible
		CGridRow* pRow = pElement->GetRow();
		ScrollIntoView(pRow);

		// only set up extended select or drag/drop if we did not lose focus while
		// key down was processed
		if (m_bBtnDownValid && (point.x < m_cxSelectMargin || !BeginDrag(nFlags, point)) && bSelected)
		{
			TRACE("Begin drag-select\n");
			
			m_bDragSelecting = TRUE;
			m_bDragRow = FALSE;
			m_pDropRow = NULL;
			SetCapture();
			DWORD dwTimeout; // NT Defines this lparam as LPDWORD
			SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &dwTimeout, FALSE);
			SetTimer(0, dwTimeout, NULL);
		}
	}
	
	m_pFirstSelect = m_pLastSelect = pElement;

LRet:
	m_bBtnDownValid = FALSE;  // return to known state
}

void CGridWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CGridElement* pElement = ElementFromPoint(point);

	if (pElement != NULL)	
	{
		// CHICAGO: Move property handling to rbutton.
		if (point.y > GetCaptionRow()->GetRowHeight() &&
				m_bShowProperties && (GetKeyState(VK_MENU) & ~1) != 0)
			ActivatePropertyBrowser();
		else
			pElement->OnLButtonDblClk(nFlags, point);
	}
}

int CGridWnd::ColumnFromX(int x)
{
	for (int nColumn = 0; nColumn < GetColumnCount(); nColumn += 1)
	{
		x -= GetColumnWidth(nColumn);
		if (x < 0)
			return nColumn;
	}
	
	return -1;
}

static CGridElement *g_pLastActive = NULL;
void CGridWnd::OnLButtonUp(UINT nFlags, CPoint point)
{
	int cSelItems = m_selection.GetCount();
	if (m_pCaptureElement != NULL)
	{
		m_pCaptureElement->OnLButtonUp(nFlags, point);
	}
	else if (cSelItems > 0)
	{
		CGridElement* pSel = (CGridElement*)m_selection.GetHead();
		if (g_pLastActive != pSel)
		{
			if (m_bDragRow && c_LastClick != point)
			{
				DoDragDrop(point);
			}
			else
			{
				if (cSelItems == 1 && c_LastClick == point &&
				    ElementFromPoint(point) == pSel)
				{
					pSel->OnLButtonUp(nFlags, point);
				}
			}
		}
		else
		{
			CloseActiveElement();
		}

		g_pLastActive = NULL;
	}

	m_bDragSelecting = FALSE;
	m_bDragRow = FALSE;
	if (m_pDropRow != NULL)
		InvalidateRect(m_rcDropInvalidate);
	m_pDropRow = NULL;
	m_pFirstSelect = NULL;
	ReleaseCapture();
	KillTimer(0);

	// if you clicked a row, set m_posCurRow
	if (point.y > GetCaptionRow()->GetRowHeight())
	{
		int y = GetCaptionRow()->GetRowHeight() - m_cyScroll;
		POSITION pos = m_posTopVisibleRow;
		while (pos && ((y += GetRowAt(pos)->GetRowHeight()) < point.y))
			GetNextRow(pos);
		if (pos)
			m_posCurRow = pos;
	}
}

void CGridWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bDragSelecting || m_bDragRow)
	{
		CRect gridRect;
		GetClientRect(gridRect);
		gridRect.top += GetCaptionRow()->GetRowHeight();
		
		BOOL bNoDrop = FALSE;
		if (point.y < gridRect.top)
		{
			point.y = gridRect.top;
			bNoDrop = TRUE;
		}
		else if (point.y > gridRect.bottom - 1)
		{
			point.y = gridRect.bottom - 1;
			bNoDrop = TRUE;
		}
		
		CGridElement* pElement = ElementFromPoint(point);
		CGridRow* pNewRow = GetRowAt(m_rows.GetTailPosition());
		if (pElement == GetCaptionRow())
		{
			bNoDrop = TRUE;
			POSITION pos = m_posTopVisibleRow;
			ASSERT(pos != NULL);
			pElement = GetPrevRow(pos);
			if (pos != NULL)
				pElement = GetRowAt(pos);
			if (pElement == GetCaptionRow())
				pElement = GetRowAt(m_posTopVisibleRow);
		}
		
		if (pElement != NULL && pElement != m_pLastSelect)
		{
			int nDownIndex = 0;
			int nLastIndex = 0;
			int nThisIndex = 0;
			
			POSITION pos = GetHeadRowPosition();
			int nIndex = 1;
			while (pos != NULL)
			{
				CGridRow* pRow = GetRowAt(pos);
				
				if (pRow == m_pFirstSelect)
					nDownIndex = nIndex;
				
				if (pRow == m_pLastSelect)
					nLastIndex = nIndex;
				
				if (pRow == pElement)
					nThisIndex = nIndex;
				
				if (nDownIndex != 0 && nLastIndex != 0 && nThisIndex != 0)
					break;
				
				GetNextRow(pos);
				nIndex += 1;
			}
			
			ASSERT(nDownIndex != 0 && nLastIndex != 0 && nThisIndex != 0);
			
			int nFirstSel = min(nDownIndex, nThisIndex);
			int nFirst = min(nLastIndex, nFirstSel);
			int nLastSel = max(nDownIndex, nThisIndex);
			int nLast = max(nLastIndex, nLastSel);
			pos = m_rows.FindIndex(nFirst);
			for (int n = nFirst; n <= nLast; n += 1)
			{
				CGridRow* pRow = GetNextRow(pos);
				if (n >= nFirstSel && n <= nLastSel)
				{
					if (!IsSelected(pRow) && !m_bDragRow)
						Select(pRow, TRUE);
				}
				else
				{
					if (!m_bDragRow)
						Deselect(pRow);
				}
			}
			
			m_pLastSelect = pElement;
			if (!m_bDragRow)
				Select(pElement, TRUE); // this will ensure this is the primary selection
		}

		if (m_bEnableDragRow && m_bDragRow)
		{
			// Set the drop row
			CGridRow* pOldDrop = m_pDropRow;
			if (bNoDrop)
			{
				m_pDropRow = NULL;
			}
			else
			{
				if (pElement == NULL)
					m_pDropRow = (CGridRow*)m_rows.GetTail();
				else
					m_pDropRow = pElement->GetRow();

				ASSERT(m_pDropRow != NULL);
				AdjustDropRow(m_pDropRow);

				if (pOldDrop != m_pDropRow)
				{
					CRect rcRow;
					m_pDropRow->GetRect(rcRow);

					rcRow.top -= 8;
					rcRow.bottom += 16;
					InvalidateRect(rcRow, FALSE);
				}
			}

			if (pOldDrop != NULL && pOldDrop != m_pDropRow)
				InvalidateRect(m_rcDropInvalidate, FALSE);
		}
		return; // don't change mouse cursor...
	}
	else if (m_pCaptureElement != NULL)
	{
		if (m_pCaptureElement->OnMouseMove(nFlags, point))
			return;
	}
	else
	{
		CGridElement* pElement = ElementFromPoint(point);
		if (pElement != NULL && pElement->OnMouseMove(nFlags, point))
			return;
			
		if (point.x < m_cxSelectMargin && m_fMultiSelect)
		{
			SetCursor(AfxGetApp()->LoadCursor(IDC_RIGHT_ARROW));
			return;
		}
	}
	
	SetCursor(LoadCursor(NULL, IDC_ARROW));
}

void CGridWnd::AdjustTopVisible()
{
	if (m_posTopVisibleRow)
	{
		CRect rect;
		GetWindowRect(rect);
		int cy = rect.Height();

		POSITION pos = m_rows.GetTailPosition();
		ASSERT( pos );

		GetRowAt(pos)->GetRect( rect );
		if ( (rect.bottom < cy) &&
				 (m_posTopVisibleRow != m_rows.GetHeadPosition() ? TRUE : !m_cyScroll) )
		{
			POSITION posPrev = NULL;
			int y = GetCaptionRow()->GetRowHeight();
			int yThis;
			while (pos)
			{
				yThis = GetRowAt(pos)->GetRowHeight();
				if ((yThis + y) > cy)
				{
					pos = posPrev;
					break;
				}
				y += yThis;
				posPrev = pos;
				GetPrevRow( pos );
			}

			// adjust m_cyScroll
			m_cyScroll = 0;

			if (pos && pos != GetHeadRowPosition())
			{
				if ((cy - y) > 0)
				{
					GetPrevRow(pos);
					ASSERT(pos);
					m_cyScroll = (y + GetRowAt(pos)->GetRowHeight()) - cy;
				}
			}

			if (pos)
				m_posTopVisibleRow = pos;
			else
				m_posTopVisibleRow = GetHeadRowPosition();
		}
	}
}

void CGridWnd::OnSize(UINT nType, int cx, int cy)
{
	// Deactivate the element first
	SetActiveElement(NULL);
	
	// Reset the width of the last column...
	int nLastColumn = GetColumnCount() - 1;
	for (int nColumn = 0; nColumn < nLastColumn; nColumn += 1)
		cx -= GetColumnWidth(nColumn);
	SetColumnWidth(nLastColumn, cx);

	// Adjust the topvisible row if needed (window is made taller, and the last row is already visible)	
	AdjustTopVisible();
	ResetScrollBars();

	// UNDONE: Warning! Do not reactivate the element at this time, or it could cause crashes when
	// the Active element tries to get the focus. [fabriced] 25jul96 (DevStudio #5847)
}

void CGridWnd::RemoveRow(CGridRow* pRow, BOOL bRedraw /* = TRUE */ )
{
	POSITION pos = m_rows.Find(pRow);
	if (pos == NULL)
		return;

	if (m_pActiveElement == pRow)
	{
		SetActiveElement(NULL);
	}

	POSITION posSel = m_selection.Find(pRow);
	if (posSel != NULL)
	{
		// Make sure the row is properly deselected before removing it
		Deselect(pRow);
	}
	
	if (m_posTopVisibleRow == pos)
	{
		GetNextRow(m_posTopVisibleRow);
		if (m_posTopVisibleRow == NULL)
		{
			m_posTopVisibleRow = pos;
			GetPrevRow(m_posTopVisibleRow);
		}
	}
	
	if (m_posCurRow == pos)
	{
		GetNextRow(m_posCurRow);
		if (m_posCurRow == NULL)
		{
			m_posCurRow = pos;
			GetPrevRow(m_posCurRow);
		}
	}
	
	m_rows.RemoveAt(pos);
	
	if (m_hWnd != NULL && bRedraw )
	{
		Invalidate(FALSE); // INEFFICIENT
		ResetScrollBars();
	}
}

void CGridWnd::AddRow(CGridRow* pRow, BOOL bRedraw /* = TRUE */ )
{
	if (m_nSortColumn == -1)
	{
		m_rows.AddTail(pRow);
	}
	else
	{
		POSITION pos = GetHeadRowPosition();
		while (pos != NULL)
		{
			int nCompare = pRow->Compare(GetRowAt(pos));
			if (m_bReverseSort)
				nCompare = -nCompare;
			if (nCompare < 0)
				break;
			GetNextRow(pos);
		}
		
		if (pos == NULL)
		{
			m_rows.AddTail(pRow);
		}
		else
		{
			m_rows.InsertBefore(pos, pRow);
		}
	}
	
	if ((m_hWnd != NULL) && bRedraw  )
	{
		ResetSize(); // INEFFICIENT
		Invalidate(FALSE); // INEFFICIENT
		ResetScrollBars();
	}
}

CGridCellRow* CGridWnd::AddCellRow()
{
	CGridCellRow* pRow = new CGridCellRow(this);
	if (!pRow->CreateCells())
	{
		delete pRow;
		return NULL;
	}
	m_rows.AddTail(pRow);
	m_bHasCells = TRUE;
	
	if (m_hWnd != NULL)
	{
		ResetSize(); // INEFFICIENT
		Invalidate(FALSE); // INEFFICIENT
		ResetScrollBars();
	}

	return pRow;
}

void CGridWnd::ResetScrollBars()
{
	if (m_bDestruct)
		return;

	if (m_hWnd == NULL)
		return;
	
	int cyRange = 0;
	int yScroll = 0;
	POSITION pos = GetHeadRowPosition();
	while (pos != NULL)
	{
		if (pos == m_posTopVisibleRow)
			yScroll = cyRange + m_cyScroll;
		cyRange += GetNextRow(pos)->GetRowHeight();
	}
	
	CRect client;
	GetClientRect(client);
	cyRange -= client.Height() - GetCaptionRow()->GetRowHeight();
	if (cyRange < 0)
	{
		cyRange = 0;
		yScroll = 0;
		m_cyScroll = 0;
		m_posTopVisibleRow = GetHeadRowPosition();
		Invalidate(FALSE);
	}

	if (theApp.m_bOnChicago)
	{
		SCROLLINFO si;
		si.cbSize = sizeof (si);
		si.fMask = SIF_RANGE | SIF_PAGE | SIF_POS;
		si.nMin = 0;
		si.nPage = client.Height() - GetCaptionRow()->GetRowHeight();
		si.nMax = cyRange + si.nPage;
		si.nPos = yScroll;
		SetScrollInfo(SB_VERT, &si, TRUE);
	}
	else
	{
		SetScrollRange(SB_VERT, 0, cyRange, FALSE);
		SetScrollPos(SB_VERT, yScroll);
	}

	if (yScroll > cyRange)
		VScroll(cyRange - yScroll);
}

void CGridWnd::VScroll(int cyScroll)
{
	CRect client;
	GetClientRect(client);

	int yCurPos = GetScrollPos(SB_VERT);
	int yMin, yLim;
	GetScrollRange(SB_VERT, &yMin, &yLim);
	if (theApp.m_bOnChicago)
		yLim -= client.Height() - GetCaptionRow()->GetRowHeight();
	
	if (yCurPos + cyScroll < 0)
		cyScroll = -yCurPos;
	else if (yCurPos + cyScroll > yLim)
		cyScroll = yLim - yCurPos;
	
	client.top += GetCaptionRow()->GetRowHeight();
	UpdateWindow(); // since we're not scrolling whole client
	SetActiveElement(NULL);
	ScrollWindow(0, -cyScroll, client, client);
	if (m_pDropRow != NULL)
		m_rcDropInvalidate.OffsetRect(0, -cyScroll);
	
	SetScrollPos(SB_VERT, yCurPos + cyScroll);
	
	if (cyScroll < 0)
	{
		// scroll towards top
		
		cyScroll = -cyScroll;
		if (cyScroll <= m_cyScroll)
		{
			m_cyScroll -= cyScroll;
		}
		else
		{
			cyScroll -= m_cyScroll;
			while (cyScroll > 0)
			{
				POSITION pos = m_posTopVisibleRow;
				if (pos == GetHeadRowPosition())
					break;

				GetPrevRow(pos);
				m_posTopVisibleRow = pos;
				cyScroll -= GetRowAt(pos)->GetRowHeight();
			}
			m_cyScroll = -cyScroll;
		}
	}
	else if (cyScroll > 0)
	{
		// scroll towards bottom
		
		m_cyScroll += cyScroll;
		POSITION pos = m_posTopVisibleRow;
		while (pos != NULL && m_cyScroll > GetRowAt(pos)->GetRowHeight())
		{
			m_cyScroll -= GetRowAt(pos)->GetRowHeight();
			GetNextRow(pos);
			if (pos != NULL)
				m_posTopVisibleRow = pos;
		}
	}
}

void CGridWnd::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	CRect page;
	GetClientRect(page);
	page.top += GetCaptionRow()->GetRowHeight();
	if (page.Height() > 20)
		page.top += 10;

	// FUTURE: This isn't the perfect solution...
	int cyLine = m_posCurRow != NULL ? GetRowAt(m_posCurRow)->GetRowHeight() : 15;
	if (cyLine > page.Height())
		cyLine = page.Height() - 1;

	if (cyLine <= 0)
		return;
	
	switch (nSBCode)
	{
	case SB_LINEUP:
		VScroll(-cyLine);
		break;
		
	case SB_LINEDOWN:
		VScroll(cyLine);
		break;
	
	case SB_PAGEUP:
		VScroll(-page.Height());
		break;
	
	case SB_PAGEDOWN:
		VScroll(page.Height());
		break;
		
	case SB_THUMBTRACK:
		VScroll(nPos - GetScrollPos(SB_VERT));
		break;
	}
}

void CGridWnd::ResetSize()
{
	if (m_hWnd != NULL)
	{
		CClientDC dc(this);

		if (GetCaptionRow() != NULL)
		{
			ASSERT( GetCaptionFont() != NULL );
			CFont *pOldFont = dc.SelectObject( GetCaptionFont() );
		
			GetCaptionRow()->ResetSize( &dc );
			dc.SelectObject( pOldFont );
		}
		
		CFont* pOldFont = dc.SelectObject(GetFont( ));
		POSITION pos = GetHeadRowPosition();
		while (pos != NULL)
		{
			CGridRow* pRow = GetNextRow(pos);
			pRow->ResetSize(&dc);
		}
		dc.SelectObject(pOldFont);
	}
}

void CGridWnd::OnTimer(UINT nIDEvent)
{
	ASSERT(nIDEvent == 0);
	
	CPoint point;
	GetCursorPos(&point);
	ScreenToClient(&point);

	// Auto-scroll
	CRect gridRect;
	GetClientRect(gridRect);
	gridRect.top += GetCaptionRow()->GetRowHeight();
	if (point.y <= gridRect.top)
	{
		VScroll(-15); // FUTURE: random number!
		OnMouseMove(0, CPoint(gridRect.left, gridRect.top - 1));
	}
	else if (point.y >= gridRect.bottom - 1)
	{
		VScroll(15); // FUTURE: random number!
		OnMouseMove(0, CPoint(gridRect.left, gridRect.bottom - 1));
	}
}

void CGridWnd::SetActiveElement(CGridElement* pElement, int nColumn)
{
	BOOL bSetFocus = FALSE;
	
	if (m_pActiveElement != NULL)
	{
		if (!m_bDestruct)
			m_pActiveElement->Invalidate(FALSE, TRUE);
		
		if (pElement == NULL && m_hWnd != NULL && IsChild(GetFocus()))
			bSetFocus = TRUE;
		
		m_pActiveElement->OnActivate(FALSE, -1);

		// Inform the owner of the grid.
		GetParent()->PostMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), GLN_ACCEPT_CTL), (LPARAM)m_hWnd);
	}
	
	m_pActiveElement = pElement;
	
	if (m_pActiveElement != NULL)
	{
		if (!m_bDestruct)
			m_pActiveElement->Invalidate(FALSE, TRUE);
		m_pActiveElement->OnActivate(TRUE, nColumn);

		// Inform the owner of the grid.
		GetParent()->PostMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), GLN_ACTIVATE_CTL), (LPARAM)m_hWnd);
	}
	
	if (bSetFocus)
		SetFocus();
}

BOOL CGridWnd::CloseActiveElement()
{
	SetActiveElement( NULL );
	return TRUE;
}

void CGridWnd::OnSetFocus(CWnd* pOldWnd)
{
	InvalidateSelection();
  
	// only if the old focus was not child window
	if (!IsChild(pOldWnd))
		GetParent()->PostMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), GLN_SETFOCUS), (LPARAM)m_hWnd);
}

void CGridWnd::OnKillFocus(CWnd* pNewWnd)
{
	InvalidateSelection();
	m_bBtnDownValid = FALSE; // so we don't try to handle drag in a buttondown if focus is lost

	// only if the new focus is not a child window
	if (!IsChild(pNewWnd))
	{
		GetParent()->PostMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), GLN_KILLFOCUS), (LPARAM)m_hWnd);
	}
}

// Tool tip handler for grid toolbar buttons
BOOL CGridWnd::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)
{
	// only do this code if tip is for a grid toolbar

	if (!m_bParentIsDialog || m_pToolBar == NULL)
	{
		return FALSE;
	}

	ASSERT(pNMHDR->code == TTN_NEEDTEXTA || pNMHDR->code == TTN_NEEDTEXTW);

	// these should never use window handles instead of ids
	ASSERT (!(pNMHDR->code == TTN_NEEDTEXTA && (((TOOLTIPTEXTA*)pNMHDR)->uFlags & TTF_IDISHWND)));
	ASSERT (!(pNMHDR->code == TTN_NEEDTEXTW && (((TOOLTIPTEXTW*)pNMHDR)->uFlags & TTF_IDISHWND)));

	if (!theApp.m_bToolTips)
	{
		CTheApp::SetEmptyToolTip(pNMHDR);
	
		*pResult = 0;
		return TRUE;
	}

	UINT nIDFrom = pNMHDR->idFrom;

	ASSERT (nIDFrom == ID_GRD_NEW || nIDFrom == ID_GRD_DELETE || nIDFrom == ID_GRD_MOVEUP || nIDFrom == ID_GRD_MOVEDOWN);
	if (nIDFrom < ID_GRD_NEW || nIDFrom > ID_GRD_MOVEDOWN)
		return FALSE;

	TCHAR szFullText[256];
	CString strTipText;
	if (nIDFrom != 0) // will be zero on a separator
	{
		AfxLoadString(nIDFrom, szFullText);
			// this is the otherwise unused status line text, which contains the key names
		AfxExtractSubString(strTipText, szFullText, 0, '\n');
	}
	
	LPCTSTR szKey;
	if (strTipText.IsEmpty())
		szKey = "";
	else
		szKey = strTipText;

	return CTheApp::HandleToolTipText(nID, pNMHDR, pResult, szKey);
}


void CGridWnd::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CWnd::OnShowWindow(bShow, nStatus);
	
	// tie toolbar and static window visibility to grid
	if (m_pToolBar != NULL)
		m_pToolBar->ShowWindow(bShow);

	if (m_cstatVCenter.m_hWnd != NULL)
		m_cstatVCenter.ShowWindow(bShow);
}

void CGridWnd::OnEnable(BOOL bEnable) 
{
	CWnd::OnEnable(bEnable);
	
	// tie toolbar and static window enable state to grid
	if (m_pToolBar != NULL)
		m_pToolBar->EnableWindow(bEnable);

	if (m_cstatVCenter.m_hWnd != NULL)
		m_cstatVCenter.EnableWindow(bEnable);
}

////////////////////////////////////////////////////////////////////////////
// CGridControlWnd

CGridControlWnd::CGridControlWnd(int nColumns, BOOL bDisplayCaption)
	: CGridWnd(nColumns, bDisplayCaption )
{
	m_controlType = none;
	m_pControlWnd = NULL;
	m_nControlColumn = -1;
}

CGridControlWnd::~CGridControlWnd()
{
	if (m_pControlWnd != NULL)
	{
		delete m_pControlWnd;
		m_pControlWnd = NULL;
		m_controlType = none;
		m_nControlColumn = -1;
	}
}

afx_msg int CGridControlWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CGridWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}



BOOL CGridControlWnd::PreTranslateMessage(MSG* pMsg)
{
	return ProcessKeyboard(pMsg, TRUE);
}

BOOL CGridControlWnd::ProcessKeyboard(MSG* pMsg, BOOL bPreTrans /*= FALSE*/)
{
	// FUTURE: Clean up
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{
		case VK_TAB:
			// control-tab is mdi window switching
			if (GetKeyState(VK_CONTROL) < 0)
				break;

			// in a dialog tab pops us out of grid. Pretrans ignores, non pretrans cluses and posts
			if (bPreTrans && m_bParentIsDialog)
				break;

			if (!AcceptControl(FALSE))
				return TRUE;

			{ // BLOCK
			BOOL bDoTabInDialog = (!bPreTrans && m_bParentIsDialog);

			if (!bDoTabInDialog)
			{
				if (GetKeyState(VK_SHIFT) < 0)
					ActivatePrevControl();
				else
					ActivateNextControl();
			}
			else // (bDoTabInDialog)
			{
				CloseActiveElement();

				CWnd* pParent = GetParent();
				
				if (pParent != NULL)
				{
					pParent->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
				}
			}
			} // End Block

			return TRUE;
	
		case VK_ESCAPE:
			if (m_bDragRow) // Cancel the drag
			{
				CancelDrag();
			}
			else if (m_pActiveElement != NULL)
			{
				CancelControl();
			}
			else
			{
				ClearSelection();
				return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);
			}
			return TRUE;

		case VK_RETURN:
			if (m_pActiveElement != NULL && (GetKeyState(VK_CONTROL) >= 0))
			{
				AcceptControl();
				return TRUE;
			}
			if (GetKeyState(VK_MENU) < 0)
			{
				// if there's no active control, let the event be
				// handled by the ResView (which brings up prop page).
				return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);
			}
			if (GetKeyState(VK_CONTROL) < 0)
				return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);

		case VK_F2:
//		case VK_F3: (UNDONE) 05-15-96 [fabriced]: this is conflicting with
//					FindNext in the Version and String editors (in devres.pkg)
			if (m_selection.GetCount() != 1)
				MessageBeep(0);
			else
				SetActiveElement((CGridElement*)m_selection.GetHead(), 0);
			return TRUE;
		}
		if (bPreTrans)
		{
			switch (pMsg->wParam)
			{
//			case 'Z':
			case 'X':
			case 'C':
			case 'V':
				if (GetKeyState(VK_CONTROL) >= 0)
					break;
				// otherwise, fall through to translate/dispatch

			case VK_DELETE:
				// The key mapping code will steal these keys away, unless
				// we dispatch them here.
				if (!m_pActiveElement || !m_pControlWnd)
					break;
				TranslateMessage(pMsg);
				DispatchMessage(pMsg);
				return TRUE;
			}
		}
		break;

	case WM_KEYUP:	// if using the IME, I won't get a wm_char
	{
		if (!theIME.IsOpen() || !theIME.IsEnabled())
			break;
		// convert the VK to ascii, to weed out chars like VK_DOWN
		// and note if Ctrl or Alt is down (an additional check for printable char)
		//
		WORD wTransKey = 0;
		UINT oemScan = LOBYTE(HIWORD(pMsg->lParam));

		BYTE kbdState[256] = {0};
		GetKeyboardState(kbdState);

		int fAscii = ToAscii(pMsg->wParam, oemScan, kbdState, &wTransKey, 0);
		ASSERT(!(WORD)fAscii == !wTransKey);		// they should both be 0, or both non-0

		// If iconic, unprintable character, or in drag op, return.
		//
		if (IsIconic() || (GetCapture() != NULL) || (fAscii == 0) || (wTransKey <= ' '))
			break;

		// if there was a WM_MENUSELECT recently, ignore this
		int nKeyDelay = 251;
// FUTURE:		VERIFY( SystemParametersInfo( SPI_GETKEYBOARDDELAY, 0, &nKeyDelay, 0 ) );
		if ( theApp.m_dwMenuSelectTime + nKeyDelay > pMsg->time )
			break;

		// if it's a valid character, then fall through to the auto activation code
	}
	case WM_CHAR:
		// NOTE: removed VkKeyScan here because Chicago
		// returns back garbage for escape.	
		BOOL bEscape = pMsg->message == WM_CHAR ? 
					(LOBYTE(pMsg->wParam) == VK_ESCAPE) :
					(pMsg->wParam	== VK_ESCAPE);

		// Auto activation
		if (!m_pActiveElement && !bEscape)
		{
			if (m_selection.GetCount() != 1)
			{
				MessageBeep(0);
			}
			else
			{
				CGridElement *pElement = (CGridElement*)m_selection.GetHead();

				// make sure row is visible
				CGridRow* pRow = pElement->GetRow();
				ScrollIntoView( pRow );

				SetActiveElement(pElement, 0);
				BOOL bReturn = pMsg->message == WM_CHAR ?
					(LOBYTE(VkKeyScan((CHAR)pMsg->wParam)) == VK_RETURN) :
					(pMsg->wParam	== VK_RETURN);

				if (m_pControlWnd && !bReturn)
				{
					switch (m_controlType)
					{
					case edit:
						ASSERT( m_pControlWnd->IsKindOf( RUNTIME_CLASS( CEdit ) ) );
						((CEdit *)m_pControlWnd)->SetSel( 0, -1 );
						break;

					case editCombo:
						ASSERT( m_pControlWnd->IsKindOf( RUNTIME_CLASS( CComboBox ) ) );
						((CComboBox *)m_pControlWnd)->SetEditSel( 0, -1 );
						break;
				
					case listCombo:
						ASSERT( m_pControlWnd->IsKindOf( RUNTIME_CLASS( CComboBox ) ) );
						break;	// nothing to do

					default:
						ASSERT(FALSE);
					}
				}
				if (!bReturn)
				{
					HWND hwndChild = GetWindow(GW_CHILD)->GetSafeHwnd();
					if (hwndChild != NULL)
					{
						if (bPreTrans)
						{
							pMsg->hwnd = hwndChild;
						}
						else
						{
							::PostMessage(hwndChild, pMsg->message, pMsg->wParam, pMsg->lParam);
						}
					}
				}	
			}
		}

		break;
	}

	if (m_pControlWnd == NULL)
		return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);
	else
		return FALSE;
}

void CGridControlWnd::CancelDrag(void)
{
	m_bDragSelecting = FALSE;
	m_bDragRow = FALSE;
	if (m_pDropRow != NULL)
		InvalidateRect(m_rcDropInvalidate);
	m_pDropRow = NULL;
	m_pFirstSelect = NULL;
	ReleaseCapture();
	KillTimer(0);
}
 
LRESULT CGridControlWnd::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT nControlID;
	UINT nNotification;

	if (message == WM_COMMAND && m_pActiveElement != NULL)
	{
#ifdef _WIN32
		nControlID = LOWORD(wParam);
		nNotification =  HIWORD(wParam);
#else
		nControlID = (UINT) wParam;
		nNotification = (UINT) HIWORD(lParam); 
#endif

		if (!FGridToolBarCmd(nControlID, nNotification))
			m_pActiveElement->OnControlNotify(nControlID, nNotification);

		return 0;
	}

	return CGridWnd::WindowProc(message, wParam, lParam);
}

IMPLEMENT_DYNAMIC(CGridControlWnd, CGridWnd)

BEGIN_MESSAGE_MAP(CGridControlWnd, CGridWnd)
	//{{AFX_MSG_MAP(CGridControlWnd)
	ON_WM_SETFOCUS()
	ON_WM_CTLCOLOR()
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
	ON_WM_CHAR()
	ON_WM_LBUTTONDOWN()
	ON_WM_NCLBUTTONDOWN()
	ON_WM_CREATE()
	ON_COMMAND(ID_EDIT_CUT, OnCut)
	ON_COMMAND(ID_EDIT_COPY, OnCopy)
	ON_COMMAND(ID_EDIT_PASTE, OnPaste)
	ON_COMMAND(ID_EDIT_CLEAR, OnClear)
	ON_COMMAND(ID_EDIT_UNDO, OnUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdatePaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR, OnUpdateClear)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateRedo)
	ON_WM_SIZE()
	ON_WM_DESTROY()
	ON_WM_VSCROLL()
	ON_BN_CLICKED(ID_GRD_NEW, OnGridNew)
	ON_BN_CLICKED(ID_GRD_DELETE, OnGridDelete)
	ON_BN_CLICKED(ID_GRD_MOVEUP, OnGridMoveUp)
	ON_BN_CLICKED(ID_GRD_MOVEDOWN, OnGridMoveDown)


	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

afx_msg void CGridControlWnd::OnGridNew()  
{
}

afx_msg void CGridControlWnd::OnGridDelete()
{
}

afx_msg void CGridControlWnd::OnGridMoveUp()
{
}

afx_msg void CGridControlWnd::OnGridMoveDown()
{
}


void CGridControlWnd::OnDestroy()
{
	if (m_pActiveElement != NULL)
		CancelControl(); // close any open element without validation
}

void CGridControlWnd::OnSetFocus(CWnd* pOldWnd)
{
	if (m_pControlWnd != NULL)
	{
		m_pControlWnd->SetFocus();
		return;
	}
	CGridWnd::OnSetFocus(pOldWnd);
}

HBRUSH CGridControlWnd::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	static CBrush brush;
	static COLORREF color;
	COLORREF colorText = GetWindowTextColor();
	COLORREF colorBk = GetWindowColor();

	if (color != colorBk || brush.m_hObject == NULL)
	{
		color = colorBk;
		brush.DeleteObject();
		brush.CreateSolidBrush(colorBk);
	}

	if (nCtlColor == CTLCOLOR_LISTBOX && pWnd->GetWindow(GW_CHILD) != NULL)
	{
		return (HBRUSH)brush.m_hObject;
	}

	if (nCtlColor == CTLCOLOR_BTN)
	{
		static CBrush btnBrush;
		if (btnBrush.m_hObject == NULL)
			btnBrush.CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

		return (HBRUSH)btnBrush.m_hObject;
	}

	// FUTURE: This doesn't make any sense to me (the msgbox bit) but 
	// this is what the documentation says needs to be done.
	// Doc Error?
	if (nCtlColor == CTLCOLOR_EDIT || nCtlColor == CTLCOLOR_MSGBOX)
	{
		pDC->SetTextColor(colorText);
		if ( nCtlColor == CTLCOLOR_EDIT )
			pDC->SetBkColor(colorBk);

		return (HBRUSH)brush.m_hObject;
	}
		
	return CGridWnd::OnCtlColor(pDC, pWnd, nCtlColor);
}

void CGridControlWnd::ActivatePrevControl()
{
	POSITION pos;
	
	if (GetRowCount() == 0)
		return;

	int nPrevControlColumn = ((CGridControlRow*)GetRow(0))->GetPrevControlColumn(m_nControlColumn);
	
	if (m_pActiveElement == NULL)
	{
		if (m_selection.IsEmpty())
		{
			// FUTURE: This really should look for the last visible row!
			if (m_posTopVisibleRow == NULL)
			{
				MessageBeep(0);
				return;
			}
			
			pos = m_posTopVisibleRow;
		}
		else
		{
			pos = m_rows.Find(m_selection.GetHead());
		}
	}
	else if (m_nControlColumn > nPrevControlColumn)
	{
		SetActiveElement(m_pActiveElement, nPrevControlColumn);
		return;
	}
	else
	{
		pos = m_rows.Find(m_pActiveElement);
		m_rows.GetPrev(pos);
	}
	
	if (pos != NULL && pos != m_rows.GetHeadPosition())
	{
		CGridElement* pElement = (CGridElement*)m_rows.GetAt(pos);
		Select(pElement);
		SetActiveElement(pElement, nPrevControlColumn);
		m_posCurRow = pos;
	}
}

void CGridControlWnd::ActivateNextControl()
{
	POSITION pos;
	
	if (GetRowCount() == 0)
		return;

	int nNextControlColumn;
	if (m_pActiveElement != NULL)
		nNextControlColumn = ((CGridControlRow*)m_pActiveElement)->GetNextControlColumn(m_nControlColumn);
	else
		nNextControlColumn = ((CGridControlRow*)GetRow(0))->GetNextControlColumn(m_nControlColumn);
	
	if (m_pActiveElement == NULL)
	{
		if (m_selection.IsEmpty())
		{
			if (m_posTopVisibleRow == NULL)
			{
				MessageBeep(0);
				return;
			}
			
			pos = m_posTopVisibleRow;
		}
		else
		{
			pos = m_rows.Find(m_selection.GetHead());
		}
	}
	else if ((m_nControlColumn >= nNextControlColumn) || (nNextControlColumn == -1))
	{
		pos = m_rows.Find(m_pActiveElement);
		m_rows.GetNext(pos);
	}
	else
	{
		SetActiveElement(m_pActiveElement, nNextControlColumn);
		return;
	}
	
	if (pos != NULL)
	{
		CGridElement* pElement = (CGridElement*)m_rows.GetAt(pos);
		Select(pElement);
		SetActiveElement(pElement, nNextControlColumn);
		m_posCurRow = pos;
	}
}

void CGridControlWnd::CancelControl()
{
	SetActiveElement(NULL);
}

BOOL CGridControlWnd::AcceptControl(BOOL bDeactivate /*=TRUE*/)
{
	if (m_pActiveElement != NULL && (m_pActiveElement->GetRow() != GetCaptionRow()))
	{
		if (!((CGridControlRow*)m_pActiveElement)->OnAccept(m_pControlWnd))
			return FALSE;
	}

	// Dynamic row sizing
	// If the current control is an edit box, and the new text makes us wrap lines,
	// increase the size of the control.
	CGridControlRow *pCurRow = (CGridControlRow *) (m_posCurRow ? GetRowAt(m_posCurRow) : NULL);
	if ( pCurRow && m_controlType == edit )
	{
		int cyOldHeight = pCurRow->GetRowHeight();
		
		CClientDC dc(this);
		CFont* pOldFont = dc.SelectObject(GetFont());
		pCurRow->ResetSize(&dc);
		dc.SelectObject(pOldFont);
		
		if (pCurRow->GetRowHeight() != cyOldHeight)
		{
			Invalidate(FALSE);
			
			CRect rect;
			pCurRow->GetRect(rect);
			pCurRow->AdjustForMargins(rect, m_nControlColumn);
			// FUTURE: hacky numbers won't work for all sys fonts
			rect.left -= 4; 
			rect.top -= 4;
			rect.right += 4;
			rect.bottom += 4;
			m_pControlWnd->MoveWindow(rect);
		
			// Hack alert!  Since we have to have ES_AUTOSCROLL set to prevent the
			// edit from just beeping when the cursor is at the bottom-right and
			// the user types, the edit has auto-scrolled when we have to resize the
			// window.  Here we scroll it back...
			((CEdit*)m_pControlWnd)->LineScroll(-10, 0);

			// Adjust the topvisible row if needed (edit box shrinks, and the last
			// row is already visible)	
			if (m_posTopVisibleRow && (pCurRow->GetRowHeight() < cyOldHeight))
			{
				POSITION pos = m_rows.GetTailPosition();
				CRect rect;
				GetWindowRect( rect );
				int cy = rect.Width();
				ASSERT( pos );

				GetRowAt(pos)->GetRect( rect );
				if ( (rect.bottom < cy) &&
						 (m_posTopVisibleRow != m_rows.GetHeadPosition() ? TRUE : !m_cyScroll) )
				{
					POSITION posPrev = NULL;
					int y = GetCaptionRow()->GetRowHeight();
					int yThis;
					while (pos)
					{
						yThis = GetRowAt(pos)->GetRowHeight();
						if ((yThis + y) > cy)
						{
							pos = posPrev;
							break;
						}
						y += yThis;
						posPrev = pos;
						GetPrevRow( pos );
					}
					// adjust m_cyScroll
					if (pos)
					{
						if ((cy - y) > 0)
						{
							GetPrevRow(pos);
							if (pos)
								m_cyScroll = (y + GetRowAt(pos)->GetRowHeight()) - cy;
							else
								m_cyScroll = 0;
				 		}
						else
						{
							m_cyScroll = 0;
						}
					}
					if (pos)
						m_posTopVisibleRow = pos;
					else
						m_posTopVisibleRow = GetHeadRowPosition();
				}
			}
		
			// recalc the scroll bars
			ResetScrollBars();
		}
	}

	if (bDeactivate)
		SetActiveElement(NULL);

	// if the row just accepted is out of order, perform an insertion sort
	if (m_bAutoSort && m_posCurRow)
	{
		// Check if we need to sort (cur > next || cur < prev) (check m_bReverseSort)
		// Set fResort to -1 if we need to move up, 1 to move down, 0 do nothing
		int fResort = 0;
		POSITION pos;
		CGridRow *pCurRow = GetRowAt(m_posCurRow);

		// compare with prev
		if (m_posCurRow != GetHeadRowPosition())
		{
			pos = m_posCurRow;
			GetPrevRow(pos);
			ASSERT( pos );
			fResort = (pCurRow->Compare(GetRowAt(pos)) == (m_bReverseSort ? 1 : -1)) ? -1 : 0;
		}
		// compare with next
		if ((m_posCurRow != m_rows.GetTailPosition()) && (fResort == 0))
		{
			pos = m_posCurRow;
			GetNextRow(pos);
			ASSERT(pos);
			fResort = (pCurRow->Compare(GetRowAt(pos)) == (m_bReverseSort ? -1 : 1)) ? 1 : 0;
		}

		// sort if needed
		if (fResort != 0)
		{
			void *pRow = m_rows.GetAt(m_posCurRow);
			POSITION posCaption = m_rows.GetHeadPosition();
			pos = m_posCurRow;
			int fTest;

			if (fResort == -1) // move up
			{
				GetPrevRow(pos);
				m_rows.RemoveAt(m_posCurRow);
				fTest = (m_bReverseSort ? 1 : -1);
				while (pos != NULL && pos != posCaption && pCurRow->Compare(GetRowAt(pos)) == fTest)
					GetPrevRow(pos);
				if (pos)
					m_posCurRow = m_rows.InsertAfter(pos, pRow);
				else
					m_posCurRow = m_rows.AddHead( pRow );
			} else if (fResort == 1)	// move down
			{
				GetNextRow(pos);
				m_rows.RemoveAt(m_posCurRow);
				fTest = (m_bReverseSort ? -1 : 1);
				while (pos != NULL && pCurRow->Compare(GetRowAt(pos)) == fTest)
					GetNextRow(pos);
				if (pos)
					m_posCurRow = m_rows.InsertBefore(pos, pRow);
				else
					m_posCurRow = m_rows.AddTail( pRow );
			}

			// make sure row is visible
			ScrollIntoView( pCurRow );
			Invalidate();
		}
	}

	return TRUE;
}

BOOL CGridControlWnd::CloseActiveElement()
{
	return AcceptControl();
}

BOOL CGridControlWnd::FGridToolBarCmd(UINT nID, int nCode)
{
	if (nID == ID_GRD_NEW || nID == ID_GRD_DELETE || nID == ID_GRD_MOVEUP || nID == ID_GRD_MOVEDOWN)
		return TRUE;
	// let toolbar tooltip notifications through
	if (nCode == MAKELONG(TTN_NEEDTEXTA, WM_NOTIFY) || nCode == MAKELONG(TTN_NEEDTEXTW, WM_NOTIFY))
		return TRUE;
	
	return FALSE;
}


BOOL CGridControlWnd::OnCmdMsg( UINT nID, int nCode, void *pExtra, AFX_CMDHANDLERINFO *pHandlerInfo )
{
	// FUTURE:  HACK!!! This will only work if each cmd in the message map
	// should only be called if there is an active control
	// bobz added extra hack for toolbars
	if (m_pControlWnd->GetSafeHwnd() || FGridToolBarCmd(nID, nCode))
		return CGridWnd::OnCmdMsg( nID, nCode, pExtra, pHandlerInfo );
	return FALSE;
}

void CGridControlWnd::OnLButtonDown(UINT nFlags, CPoint point)
{
	g_pLastActive = m_pActiveElement;

	// turn this off if we lose focus before we are done in this routine. This
	// prevents us from starting a drag when we have lose the up click by a dialog.
	// the killfocus turn off and use of this flag are in CGridWnd
	// bobz  11/8/96
	m_bBtnDownValid = TRUE;

	if (! AcceptControl())
	{
		m_bBtnDownValid = FALSE;  // return to known state
		return;
	}

	CGridWnd::OnLButtonDown(nFlags, point);
	m_bBtnDownValid = FALSE;  // return to known state
}

afx_msg void CGridControlWnd::OnNcLButtonDown(UINT nHitTest, CPoint point) 
{
	if (AcceptControl())
		CGridWnd::OnNcLButtonDown(nHitTest, point);
}

afx_msg void CGridControlWnd::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ProcessKeyboard((MSG*)GetCurrentMessage());
}

afx_msg void CGridControlWnd::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	ProcessKeyboard((MSG*)GetCurrentMessage());
}

afx_msg void CGridControlWnd::OnCut()
{
	if (m_pControlWnd->GetSafeHwnd())
		m_pControlWnd->SendMessage( WM_CUT );
}

afx_msg void CGridControlWnd::OnCopy()
{
	if (m_pControlWnd->GetSafeHwnd())
		m_pControlWnd->SendMessage( WM_COPY );
}

afx_msg void CGridControlWnd::OnPaste()
{
	if (m_pControlWnd->GetSafeHwnd())
		m_pControlWnd->SendMessage( WM_PASTE );
}

afx_msg void CGridControlWnd::OnClear()
{
	if (m_pControlWnd->GetSafeHwnd())
		m_pControlWnd->SendMessage( WM_CLEAR );
}

afx_msg void CGridControlWnd::OnUndo()
{
	if (m_pControlWnd->GetSafeHwnd())
		CancelControl();
}

void CGridControlWnd::OnUpdateCut( CCmdUI *pCmdUI )
{
	pCmdUI->Enable( m_pControlWnd->GetSafeHwnd() != NULL );
}

void CGridControlWnd::OnUpdateCopy( CCmdUI *pCmdUI )
{
	pCmdUI->Enable( m_pControlWnd->GetSafeHwnd() != NULL );
}

void CGridControlWnd::OnUpdatePaste( CCmdUI *pCmdUI )
{
	pCmdUI->Enable( m_pControlWnd->GetSafeHwnd() != NULL );
}

void CGridControlWnd::OnUpdateClear( CCmdUI *pCmdUI )
{
	pCmdUI->Enable( m_pControlWnd->GetSafeHwnd() != NULL );
}

void CGridControlWnd::OnUpdateUndo( CCmdUI *pCmdUI )
{
	pCmdUI->Enable( (m_pControlWnd->GetSafeHwnd() ?
		m_pControlWnd->SendMessage( EM_CANUNDO ) : FALSE) );
}

void CGridControlWnd::OnUpdateRedo( CCmdUI *pCmdUI )
{
	pCmdUI->Enable( FALSE );
}

afx_msg void CGridControlWnd::OnSize(UINT nType, int cx, int cy)
{
	if (AcceptControl(FALSE))
		CGridWnd::OnSize(nType, cx, cy);
}

afx_msg void CGridControlWnd::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (AcceptControl())
		CGridWnd::OnVScroll(nSBCode, nPos, pScrollBar);
}


////////////////////////////////////////////////////////////////////////////
// Ctl3d helpers for the grid control
typedef BOOL (WINAPI *CTL3DUNSUBCLASSCTLPROC)(HWND);
class CGridCtl3dInterface
{
public:
	CGridCtl3dInterface();
	void Load();
	void Free();
	void UnsubclassCtl(HWND hWnd);

protected:
	HINSTANCE m_Ctl3d;
	CTL3DUNSUBCLASSCTLPROC m_lpfnUnsubclassCtl;
};
CGridCtl3dInterface g_GridCtl3dInterface;

CGridCtl3dInterface::CGridCtl3dInterface()
{
	m_Ctl3d = NULL;
	m_lpfnUnsubclassCtl = NULL;
}

void CGridCtl3dInterface::Load()
{
	if (m_lpfnUnsubclassCtl == NULL)
	{
		m_Ctl3d = ::LoadLibrary("ctl3d32");
		if (m_Ctl3d != NULL)
			m_lpfnUnsubclassCtl = (CTL3DUNSUBCLASSCTLPROC)::GetProcAddress(m_Ctl3d, "Ctl3dUnsubclassCtl");
	}
}

void CGridCtl3dInterface::Free()
{
	if (m_Ctl3d != NULL)
	{
		::FreeLibrary(m_Ctl3d);

		m_Ctl3d = NULL;
		m_lpfnUnsubclassCtl = NULL;
	}
}

void CGridCtl3dInterface::UnsubclassCtl(HWND hWnd)
{
	if (m_lpfnUnsubclassCtl != NULL)
		(*m_lpfnUnsubclassCtl)(hWnd);
}


////////////////////////////////////////////////////////////////////////////
// CStringListEdit
class CStringListEdit : public CEdit
{
// Construction
public:
	CStringListEdit();

// Attributes
public:
	CStringListGridWnd* m_pGrid;

// Implementation
public:
	virtual ~CStringListEdit();

protected:
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	DECLARE_MESSAGE_MAP()
};

CStringListEdit::CStringListEdit() : CEdit()
{
}

CStringListEdit::~CStringListEdit()
{
}

BEGIN_MESSAGE_MAP(CStringListEdit, CEdit)
	ON_WM_GETDLGCODE()
	ON_WM_KEYDOWN()
	ON_WM_CREATE()
END_MESSAGE_MAP()

UINT CStringListEdit::OnGetDlgCode()
{
	return CEdit::OnGetDlgCode() | DLGC_WANTTAB | DLGC_WANTARROWS | DLGC_WANTALLKEYS;
}

void CStringListEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	if ( nChar == VK_TAB || nChar == VK_RETURN || nChar == VK_ESCAPE || nChar == VK_F2)
		m_pGrid->ProcessKeyboard((MSG*)GetCurrentMessage());
	else
		CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

int CStringListEdit::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CEdit::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Un3D the edit control - note failure is ok
	g_GridCtl3dInterface.UnsubclassCtl(this->m_hWnd);
	return 0;
}

////////////////////////////////////////////////////////////////////////////
// CStringListGridRow
BOOL AFX_EXT_DATADEF CStringListGridRow::c_bIsMove;

CStringListGridRow::CStringListGridRow(CGridWnd* pGrid)
	: CGridControlRow(pGrid), m_dwUser(0), m_nGlyph(-1)
{
}

CStringListGridRow::~CStringListGridRow()
{
	// NOTE: This must be done here instead of in CGridRow::~CGridRow
	// so that CStringListGridRow::OnActivate() is called from RemoveRow,
	// instead of CGridElement::OnActivate().
	if (m_pGrid != NULL)
		m_pGrid->RemoveRow(this);
	m_pGrid = NULL;
}

void CStringListGridRow::GetColumnText(int nColumn, CString& rStr)
{
	ASSERT(nColumn == 0);

	if (IsNewRow())
		rStr.Empty();
	else
		rStr = m_str;
}

void CStringListGridRow::OnActivate(BOOL bActivate, int nColumn)
{
	CStringListGridWnd* pGrid = (CStringListGridWnd*) GetGrid();
	if (bActivate)
	{
		if (IsNewRow())
		{
			if (!pGrid->IsFlag(GRIDLIST_NOADD))
			{
				CreateControl(edit, 0);
			}
		}
		else if (!pGrid->IsFlag(GRIDLIST_NOCHANGE))
		{
			CreateControl(edit, 0);
		}
	}
	else
	{
		if (pGrid->m_pControlWnd != NULL)
			CreateControl(none, -1);
	}
}

BOOL CStringListGridRow::OnAccept(CWnd* pControlWnd)
{
	CStringListGridWnd* pGrid = (CStringListGridWnd*) GetGrid();
	if (pControlWnd != NULL)
	{
		CString strNew;
		pControlWnd->GetWindowText(strNew);

		if (IsNewRow())
		{
			CString strOld = m_str;
			m_str = strNew;

			ASSERT(!pGrid->IsFlag(GRIDLIST_NOADD));
			BOOL bRC = TRUE;
			if (m_str.IsEmpty() || !(bRC = pGrid->OnAddString(pGrid->GetRowIndex(this))))
				m_str = strOld;
			else
			{
				pGrid->AddNewRow(!c_bIsMove);
				CWnd* pParent = pGrid->GetParent();
				ASSERT_VALID(pParent);
				pParent->PostMessage(WM_COMMAND, MAKEWPARAM(pGrid->GetDlgCtrlID(), GLN_ADDSTRING), (LPARAM)pGrid->m_hWnd);
			}	

			Invalidate();
			return bRC;
		}
		else if (strNew.Compare(m_str))
		{
			CString strOld = m_str;
			m_str = strNew;

			ASSERT(!pGrid->IsFlag(GRIDLIST_NOCHANGE));
			BOOL bRC = pGrid->OnChange(pGrid->GetRowIndex(this));
			if (!bRC)
				m_str = strOld;

			return bRC;
		}
	}

	return TRUE;
}

void CStringListGridRow::OnSelect(BOOL bSelected)
{
	CGridControlRow::OnSelect(bSelected);

	CStringListGridWnd* pGrid = (CStringListGridWnd*) GetGrid();
	CWnd* pParent = pGrid->GetParent();
	ASSERT_VALID(pParent);

	// Notify owner of sel change
	if (!CStringListGridWnd::c_bSelChangeFromCode)
		pParent->PostMessage(WM_COMMAND,
			MAKEWPARAM(pGrid->GetDlgCtrlID(), GLN_SELCHANGE),
			(LPARAM)pGrid->m_hWnd);
}

void CStringListGridRow::DrawCell(CDC* pDC, const CRect& cellRect, int nColumn)
{
	if (IsNewRow())
	{
		CRect textRect = cellRect;
		AdjustForMargins(textRect, nColumn);

		pDC->ExtTextOut(textRect.left, textRect.top, ETO_CLIPPED | ETO_OPAQUE,
			cellRect, "", 0, NULL);

		textRect.right = textRect.left + textRect.Width() / 3;
		pDC->DrawFocusRect(textRect);
	}
	else
	{
		CGridControlRow::DrawCell(pDC, cellRect, nColumn);
	}

	// Now paint our glyph
	if (m_nGlyph != -1)
	{
		CPoint ptGlyph;
		CStringListGridWnd* pGrid = (CStringListGridWnd*)GetGrid();
		ptGlyph.x = (pGrid->m_cxSelectMargin / 2) - (pGrid->m_sizeGlyph.cx / 2);
		ptGlyph.y = cellRect.top + (cellRect.Height() / 2) - (pGrid->m_sizeGlyph.cy / 2);

		pGrid->DrawGlyph(pDC, m_nGlyph, ptGlyph, 0);
	}
}

void CStringListGridRow::ResetSize(CDC* pDC)
{
	CWindowDC dc(NULL);
	TEXTMETRIC tm;

	dc.GetTextMetrics(&tm);
	m_cyHeight = tm.tmHeight + tm.tmExternalLeading + 1;
}

CEdit* CStringListGridRow::NewEdit()
{
	CStringListEdit* pEdit = new CStringListEdit;
	pEdit->m_pGrid = (CStringListGridWnd *)m_pGrid;
	return pEdit;
}


////////////////////////////////////////////////////////////////////////////
// CStringListGridWnd
BOOL CStringListGridWnd::c_bSelChangeFromCode;
CStringListGridWnd::CStringListGridWnd(UINT nModeFlags /*= 0*/)
	: CGridControlWnd(1, FALSE), m_nFlags(nModeFlags), m_pNewRow(NULL), m_bRedraw(TRUE)
{
	// Configure the grid
	EnableAutoSort(FALSE);
	if (!IsFlag(GRIDLIST_MULTISEL))
		EnableMultiSelect(FALSE);

	m_bEnableDragRow = !IsFlag(GRIDLIST_NOORDER);
	m_bEnableEllipse = IsFlag(GRIDLIST_ELLIPSE);

	CStringListGridRow::c_bIsMove = FALSE;

	m_sizeGlyph.cx = m_sizeGlyph.cy = 0;

	g_GridCtl3dInterface.Load();
	c_bSelChangeFromCode = FALSE;

}

CStringListGridWnd::~CStringListGridWnd()
{
	g_GridCtl3dInterface.Free();
}

BEGIN_MESSAGE_MAP(CStringListGridWnd, CGridControlWnd)
	//{{AFX_MSG_MAP(CStringListGridWnd)
	ON_WM_CREATE()
	ON_WM_GETDLGCODE()
	ON_BN_CLICKED(ID_GRD_NEW, OnGridNew)
	ON_BN_CLICKED(ID_GRD_DELETE, OnGridDelete)
	ON_BN_CLICKED(ID_GRD_MOVEUP, OnGridMoveUp)
	ON_BN_CLICKED(ID_GRD_MOVEDOWN, OnGridMoveDown)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


afx_msg void CStringListGridWnd::OnGridNew() 
{
	if (m_pNewRow != NULL)
	{
		Select(m_pNewRow);
		SetActiveElement(m_pNewRow);
	}

	CGridControlWnd::OnGridNew();
}

afx_msg void CStringListGridWnd::OnGridDelete()
{
	if (m_pControlWnd == NULL && !IsFlag(GRIDLIST_NODELETE))
	{
		DoDelete();
	}
	CGridControlWnd::OnGridDelete();
}

afx_msg void CStringListGridWnd::OnGridMoveUp()
{
	POSITION posSel = GetHeadSelPosition();
	if (posSel != NULL)
	{
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posSel);
		if (!pSelRow->IsNewRow())
			MoveUpDown(TRUE /* fMoveUp */);
	}
	CGridControlWnd::OnGridMoveUp();
}

afx_msg void CStringListGridWnd::OnGridMoveDown()
{
	POSITION posSel = GetHeadSelPosition();
	if (posSel != NULL)
	{
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posSel);
		if (!pSelRow->IsNewRow())
			MoveUpDown(FALSE /* fMoveUp */);
	}

	CGridControlWnd::OnGridMoveDown();
}

int CStringListGridWnd::GetCount() const
{
	if (IsFlag(GRIDLIST_NOADD))
		return GetRowCount();
	else
		return GetRowCount() - 1;
}

int CStringListGridWnd::GetCurSel() const
{
	ASSERT(!IsFlag(GRIDLIST_MULTISEL));

	POSITION pos = GetHeadSelPosition();
	if (pos == NULL)
		return -1;

	CGridRow* pRow = (CGridRow*) GetNextSel(pos);
	return GetRowIndex(pRow);
}

BOOL CStringListGridWnd::SetCurSel(int nSelect)
{
	ASSERT(!IsFlag(GRIDLIST_MULTISEL));

	CGridRow* pRow = GetRow(nSelect);
	if (pRow != NULL)
	{
		c_bSelChangeFromCode = TRUE;
		Select(pRow);
		c_bSelChangeFromCode = FALSE;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/* FUTURE: NYI
int CStringListGridWnd::GetCaretIndex() const
{
}

BOOL CStringListGridWnd::SetCaretIndex(int nIndex, BOOL bScroll = TRUE)
{
}
*/

BOOL CStringListGridWnd::SetSel(int nIndex, BOOL bSelect /*= TRUE*/)
{
	ASSERT(IsFlag(GRIDLIST_MULTISEL));

	CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return FALSE;

	c_bSelChangeFromCode = TRUE;
	if (bSelect)
	{
		Select(pRow, TRUE);
	}
	else
	{
		Deselect(pRow);
	}
	c_bSelChangeFromCode = FALSE;

	return TRUE;
}

int CStringListGridWnd::GetSelCount() const
{
	ASSERT(IsFlag(GRIDLIST_MULTISEL));

	return m_selection.GetCount();
}

static int CompareInts(const void* p1, const void* p2)
{
	return (*(int*)p1) - (*(int*)p2);
}

int CStringListGridWnd::GetSelItems(int nMaxItems, LPINT rgIndex) const
{
	ASSERT(IsFlag(GRIDLIST_MULTISEL));

	POSITION posSel = GetHeadSelPosition();
	int cSel = GetSelCount();
	if (cSel == 0)
		return 0;

	LPINT rgTemp = new INT[cSel];
	int nSel;
	for (nSel = 0; nSel < cSel; nSel++)
	{
		ASSERT(posSel != NULL);

		CGridRow* pRow = (CGridRow*) GetNextSel(posSel);
		rgTemp[nSel] = GetRowIndex(pRow);
	}

	// Sort based on position in the grid
	qsort(rgTemp, cSel, sizeof(int), CompareInts);

	// Put them into the passed in buffer
	int nCopy = min(nMaxItems, cSel);
	memcpy(rgIndex, rgTemp, sizeof(int) * nCopy);

	delete[] rgTemp;

	return nCopy;
}

int CStringListGridWnd::AddString(LPCTSTR lpszItem)
{
	return InsertString(-1, lpszItem);
}

int CStringListGridWnd::DeleteString(int nIndex)
{
	CGridRow* pRow = GetRow(nIndex);

	if (pRow != NULL)
		RemoveRow(pRow);

	return GetCount();
}

int CStringListGridWnd::InsertString(int nIndex, LPCTSTR lpszItem)
{
	ASSERT(m_nSortColumn == -1);

	// Allocate a new row
	CStringListGridRow* pRow = NULL;
	NewRow(pRow);
	ASSERT(pRow != NULL);

	// Set it's text
	if (lpszItem != NULL)
		pRow->m_str = lpszItem;

	// Insert it in the correct location
	POSITION posBefore = NULL;
	if (nIndex != -1)
		posBefore = m_rows.FindIndex(nIndex + 1);

	if (posBefore != NULL)
	{
		m_rows.InsertBefore(posBefore, pRow);
	}
	else
	{
		if (m_pNewRow != NULL)
		{
			POSITION pos = m_rows.Find(m_pNewRow);
			ASSERT(pos != NULL);

			m_rows.InsertBefore(pos, pRow);
		}
		else
		{
			m_rows.AddTail(pRow);
		}
	}

	if (m_bRedraw)
	{
		AdjustTopVisible();
		ResetSize(); // INEFFICIENT
		Invalidate(FALSE); // INEFFICIENT
		ResetScrollBars();
	}

	return GetRowIndex(pRow);
}

void CStringListGridWnd::ResetContent()
{
	// can't reset midway thru a drag and expect the drag to continue.
	if(m_bDragRow)
	{
		CancelDrag();
	}

	// Clearing these speeds up row deletion
	m_selection.RemoveAll();
	m_posCurRow = NULL;
	m_posTopVisibleRow = NULL;
	m_cyScroll = 0;

	ASSERT(!m_bDestruct);
	m_bDestruct = TRUE;

	// Temporarily remove the caption
	CGridRow* pCaption = GetCaptionRow();
	while (!m_rows.IsEmpty())
	{
		CGridRow* pRow = (CGridRow*) m_rows.GetTail();
		if (pRow == pCaption)
			break;

		delete pRow;
	}

	m_bDestruct = FALSE;
	AddNewRow();
}

BOOL CStringListGridWnd::GetText(int nIndex, CString& rString) const
{
	const CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return FALSE;

	rString = pRow->m_str;
	return TRUE;
}

BOOL CStringListGridWnd::SetText(int nIndex, LPCTSTR lpszNew)
{
	CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return FALSE;

	pRow->m_str = lpszNew;
	return TRUE;
}

DWORD CStringListGridWnd::GetItemData(int nIndex) const
{
	const CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return (DWORD)-1;

	return pRow->m_dwUser;
}

BOOL CStringListGridWnd::SetItemData(int nIndex, DWORD dwItemData)
{
	CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return FALSE;

	pRow->m_dwUser = dwItemData;
	return TRUE;
}

void* CStringListGridWnd::GetItemDataPtr(int nIndex) const
{
	return (void*) GetItemData(nIndex);
}

BOOL CStringListGridWnd::SetItemDataPtr(int nIndex, void* pData)
{
	return SetItemData(nIndex, (DWORD)pData);
}

int CStringListGridWnd::GetItemGlyph(int nIndex) const
{
	const CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return -1;

	return pRow->m_nGlyph;
}

BOOL CStringListGridWnd::SetItemGlyph(int nIndex, int nGlyph)
{
	CStringListGridRow* pRow = GetRow(nIndex);
	if (pRow == NULL)
		return FALSE;

	pRow->m_nGlyph = nGlyph;
	return TRUE;
}

void CStringListGridWnd::SetGlyphSize(LONG cx, LONG cy)
{
	m_sizeGlyph.cx = cx;
	m_sizeGlyph.cy = cy;

	m_cxSelectMargin = max(cxSelectMargin, cx + 4);
}

void CStringListGridWnd::SetRedraw(BOOL bRedraw)
{
	// If turning on redraw, recalc stuff.
	if (!m_bRedraw && bRedraw)
	{
		AdjustTopVisible();
		ResetSize();
		Invalidate(FALSE);
		ResetScrollBars();
	}

	m_bRedraw = bRedraw;
}

BOOL CStringListGridWnd::OnChange(int nIndex)
{
	ASSERT(!IsFlag(GRIDLIST_NOCHANGE));

	return TRUE;
}

BOOL CStringListGridWnd::OnAddString(int nIndex)
{
	ASSERT(!IsFlag(GRIDLIST_NOADD));

	return TRUE;
}

BOOL CStringListGridWnd::OnDeleteString(int nIndex)
{
	ASSERT(!IsFlag(GRIDLIST_NODELETE));

	return TRUE;
}

BOOL CStringListGridWnd::OnMove(int nSrcIndex, int nDestIndex)
{
	ASSERT(!IsFlag(GRIDLIST_NOORDER));

	return TRUE;
}

void CStringListGridWnd::DrawGlyph(CDC *pDC, int nGlyph, CPoint ptGlyph, DWORD dwRop)
{
}

void CStringListGridWnd::NewRow(CStringListGridRow*& rpRow)
{
	rpRow = new CStringListGridRow(this);
}

int CStringListGridWnd::GetRowIndex(const CGridRow* pRow) const
{
	POSITION pos = GetHeadRowPosition();
	int nIndex = 0;
	while (pos != NULL)
	{
		if (GetNextRow(pos) == pRow)
			return nIndex;
		nIndex++;
	}

	return -1;
}

CStringListGridRow* CStringListGridWnd::GetRow(int nIndex)
{
	POSITION pos = nIndex == -1 ? NULL : m_rows.FindIndex(nIndex + 1);
	if (pos != NULL)
		return (CStringListGridRow*)m_rows.GetAt(pos);
	else
		return NULL;
}

const CStringListGridRow* CStringListGridWnd::GetRow(int nIndex) const
{
	POSITION pos = nIndex == -1 ? NULL : m_rows.FindIndex(nIndex + 1);
	if (pos != NULL)
		return (const CStringListGridRow*)m_rows.GetAt(pos);
	else
		return NULL;
}

void CStringListGridWnd::AddNewRow(BOOL bSelect /*= TRUE*/)
{
	if (!IsFlag(GRIDLIST_NOADD))
	{
		NewRow(m_pNewRow);
		AddRow(m_pNewRow);

		if (bSelect && !IsFlag(GRIDLIST_NONEWSELONADD))
		{
			c_bSelChangeFromCode = TRUE;
			Select(m_pNewRow);
			c_bSelChangeFromCode = FALSE;
		}
	}
}

void CStringListGridWnd::DoDelete()
{
	if (m_selection.IsEmpty())  // don't even try with empty grid
		return;

	POSITION posNewSel = NULL;
	while (!m_selection.IsEmpty())
	{
		POSITION posPrimary = GetHeadSelPosition();
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posPrimary);

		// Don't try to delete the caption row!
		if ((CGridRow*)pSelRow == (CGridRow*)GetCaptionRow())
		{
			Deselect(pSelRow);
			continue;
		}

		if (pSelRow != m_pNewRow)
		{
			// BLOCK: Pick the correct row to select
			{
				if (posPrimary != NULL)
				{
					CStringListGridRow* pSetSel = (CStringListGridRow*) m_selection.GetAt(posPrimary);
					posNewSel = m_rows.Find(pSetSel);
				}
				else
				{
					posNewSel = m_rows.Find(pSelRow);
					m_rows.GetNext(posNewSel);
				}
			}

			// Inform of the delete
			int nIndex = GetRowIndex(pSelRow);
			if (OnDeleteString(nIndex))
			{
				RemoveRow(pSelRow); // Remove the primary selection
				delete pSelRow;

				CStringListGridWnd* pGrid = this;
				CWnd* pParent = pGrid->GetParent();
				ASSERT_VALID(pParent);
				pParent->PostMessage(WM_COMMAND, MAKEWPARAM(pGrid->GetDlgCtrlID(), GLN_DELETESTRING), (LPARAM)pGrid->m_hWnd);

			}
			else
			{
				posNewSel = m_rows.Find(pSelRow);
				Deselect(pSelRow);
			}
		}
		else
		{
			posNewSel = m_rows.Find(pSelRow);
			Deselect(pSelRow);
		}
	}

	// Redraw
	Invalidate(FALSE);
	ResetScrollBars();

	// Default to the last row
	if (posNewSel == NULL)
		posNewSel = m_rows.GetTailPosition();

	// Set the selection
	CStringListGridRow* pSelRow = (CStringListGridRow*) m_rows.GetAt(posNewSel);

	if ((CGridRow*)pSelRow == (CGridRow*)GetCaptionRow())
		{
			Deselect(pSelRow);
		}
	else
		Select(pSelRow);
}

int CompareRowIDs(const void* p1, const void* p2)
{
	return ((SORTABLEROW*)p1)->m_nRow - ((SORTABLEROW*)p2)->m_nRow;
}

void CStringListGridWnd::DoMove(int nToIndex)
{
	ASSERT(!IsFlag(GRIDLIST_NOORDER));

	if (nToIndex >= GetCount())
		nToIndex = GetCount() - 1;

	if (nToIndex < 0)
		return;

	// Notify the grid owner of these moves
	SORTABLEROW* pSelRows;
	pSelRows = new SORTABLEROW[m_selection.GetCount()];
	int cMove = 0;

	POSITION posSel = GetHeadSelPosition();
	int nDest = nToIndex;
	while (posSel != NULL)
	{
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posSel);
		if (pSelRow->IsNewRow())
		{
			Deselect(pSelRow);
		}
		else
		{
			int nSrc = GetRowIndex(pSelRow);

			if (!OnMove(nSrc, nDest++))
			{
				Deselect(pSelRow);
				nDest--;
			}
			else
			{
				pSelRows[cMove].m_pRow = pSelRow;
				pSelRows[cMove++].m_nRow = nSrc;
			}
		}
	}

	// Remove the select rows
	posSel = GetHeadSelPosition();
	while (posSel != NULL)
	{
		CStringListGridRow* pSelRow = (CStringListGridRow*) GetNextSel(posSel);

		// Remove the row from the grid
		POSITION pos = m_rows.Find(pSelRow);
		ASSERT(pos != NULL);

		// Update m_posTopVisibleRow if needed
		if (m_posTopVisibleRow == pos)
		{
			GetPrevRow(m_posTopVisibleRow);
			if (m_posTopVisibleRow != NULL && (GetRowAt(m_posTopVisibleRow) == GetCaptionRow()))
			{
				m_posTopVisibleRow = NULL;
				m_cyScroll = 0;
			}
		}
		m_rows.RemoveAt(pos);
	}

	// Sort the row list
	qsort(pSelRows, cMove, sizeof(SORTABLEROW), CompareRowIDs);

	// Now move each row from our temp list into the grid's list of rows
	POSITION posTarget = NULL;
	for (int iCur = 0; iCur < cMove; iCur++)
	{
		// Where should we insert the row?
		if (posTarget == NULL)
		{
			if (nToIndex >= GetCount())
			{
				if (m_pNewRow != NULL)
					posTarget = m_rows.InsertBefore(m_rows.Find(m_pNewRow), pSelRows[iCur].m_pRow);
				else
					posTarget = m_rows.AddTail(pSelRows[iCur].m_pRow);
			}
			else if (nToIndex <= 0)
			{
				posTarget = m_rows.InsertAfter(m_rows.GetHeadPosition(), pSelRows[iCur].m_pRow);
			}
			else
			{
				posTarget = m_rows.InsertAfter(m_rows.FindIndex(nToIndex), pSelRows[iCur].m_pRow);
			}
		}
		else
		{
			posTarget = m_rows.InsertAfter(posTarget, pSelRows[iCur].m_pRow);
		}
	}
	delete [] pSelRows;

	AdjustTopVisible();
	ResetSize(); // INEFFICIENT
	Invalidate(FALSE); // INEFFICIENT
	ResetScrollBars();

	// Make sure the primary selection is still visible
	if (!m_selection.IsEmpty())
	{
		CGridElement* pSelElement = (CGridElement*)m_selection.GetHead();
		if (pSelElement != NULL)
		{
			CGridRow* pRow = pSelElement->GetRow();
			ASSERT(pRow != NULL);

			ScrollIntoView(pRow);
		}
	}
}



void CStringListGridWnd::MoveUpDown(BOOL fMoveUp)
{
	if (IsFlag(GRIDLIST_NOORDER))
		return;

	CStringListGridRow::c_bIsMove = TRUE;
	BOOL bAccepted = AcceptControl();
	CStringListGridRow::c_bIsMove = FALSE;

	if (bAccepted)
	{
		int iCurSel = -1;
		if (IsFlag(GRIDLIST_MULTISEL))
			GetSelItems(1, &iCurSel);
		else
			iCurSel = GetCurSel();

		DoMove(iCurSel + (fMoveUp ? -1 : 1));
	}

}


BOOL CStringListGridWnd::ProcessKeyboard(MSG* pMsg, BOOL bPreTrans /*= FALSE*/)
{
	switch (pMsg->message)
	{
	case WM_SYSKEYDOWN:
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{
		case VK_DELETE:
			if (m_pControlWnd == NULL && !IsFlag(GRIDLIST_NODELETE))
			{
				DoDelete();
				return TRUE;
			}
			break;

		case VK_UP:
		case VK_DOWN:
			if (GetKeyState(VK_MENU) < 0) 
			{
				MoveUpDown(pMsg->wParam == VK_UP);
				return TRUE;
			}

			break;

		case VK_F2:
			if (m_Ellipse.m_hWnd != NULL)
			{
				CWnd* pParent = GetParent();
				ASSERT_VALID(pParent);

				pParent->PostMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), GLN_ELLIPSE), (LPARAM)m_hWnd);
				return TRUE;
			}
			break;

		case VK_RETURN:
		case VK_ESCAPE:
			if (m_pControlWnd == NULL && !m_bDragRow)
			{
				CWnd* pParent = GetParent();
				if (pParent != NULL)
				{
					if (bPreTrans)
						pMsg->hwnd = pParent->m_hWnd;
					else
						pParent->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
				}

				// Need to skip CGridControlWnd, because it will reactivate the row
				return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);
			}
			break;

		case VK_TAB:

			// control-tab is mdi window switching
			if (GetKeyState(VK_CONTROL) < 0)
				break;
			
			// in a dialog tab pops us out of grid. Pretrans ignores, non pretrans cluses and posts
			if (bPreTrans && m_bParentIsDialog)
				break;

			if (!AcceptControl(FALSE))
				return TRUE;

			// BLOCK: Tab between elements, or dlg controls
			{
				CGridElement* pOldActive = m_pActiveElement;

				BOOL bDoTabInDialog = (!bPreTrans && m_bParentIsDialog);

				if (!bDoTabInDialog)
				{
					if (GetKeyState(VK_SHIFT) < 0)
						ActivatePrevControl();
					else
						ActivateNextControl();
				}

				if (bDoTabInDialog || pOldActive == m_pActiveElement)
				{
					// We must be at the last (or first) element in the grid or tabbing out in a dialog
					CloseActiveElement();

					CWnd* pParent = GetParent();
					if (pParent != NULL)
					{
						if (bPreTrans)
						{
							pMsg->hwnd = pParent->m_hWnd;
						}
						else
						{
							if (m_bParentIsDialog)
							{
								ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CDialog)));
								if (GetKeyState(VK_SHIFT) < 0)
									((CDialog *)pParent)->PrevDlgCtrl();	
								else
									((CDialog *)pParent)->NextDlgCtrl();
							}
							else
								pParent->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
						}
					}
					return CGridWnd::ProcessKeyboard(pMsg, bPreTrans); // must skip CGridControlWnd
				}

				return TRUE;
			}
		}
	}

	return CGridControlWnd::ProcessKeyboard(pMsg, bPreTrans);
}

void CStringListGridWnd::AdjustDropRow(CGridRow* &rpDropRow)
{
	ASSERT(rpDropRow != NULL);
	if (((CStringListGridRow*)rpDropRow)->IsNewRow())
	{
		POSITION pos = m_rows.GetTailPosition();
		if (pos != NULL)
			GetPrevRow(pos);

		if (pos == NULL)
			rpDropRow = NULL;
		else
			rpDropRow = GetPrevRow(pos);
	}
}

BOOL CStringListGridWnd::AcceptControl(BOOL bDeactivate /*= TRUE*/)
{
	// Call CGridControlRow::OnAccept()
	if (m_pActiveElement != NULL)
	{
		if (!((CGridControlRow*)m_pActiveElement)->OnAccept(m_pControlWnd))
			return FALSE;
	}

	// HACK!!! Set m_pActiveElement to NULL so that CGridControl::AcceptControl()
	// doesn't call CGridControlRow::OnAccept() again.
	CGridElement* pElement = m_pActiveElement;
	m_pActiveElement = NULL;

	// For dymanic row sizing:
	CGridControlWnd::AcceptControl(bDeactivate);

	// If the row is now empty, delete it
	m_pActiveElement = pElement;
	if (m_pActiveElement != NULL)
	{
		CStringListGridRow* pRow = (CStringListGridRow*) m_pActiveElement;
		if (pRow->m_str.IsEmpty() && !pRow->IsNewRow())
		{
			// Remove the row
			DoDelete();
		}
	}

	if (bDeactivate)
		SetActiveElement(NULL);

	return TRUE;
}

void CStringListGridWnd::DoDragDrop(CPoint point)
{
	CGridElement* pElement = ElementFromPoint(point);
	if (pElement == NULL)
	{
		CGridRow* pRow = (CGridRow*)m_rows.GetTail();
		if (pRow == NULL)
			return;

		pElement = pRow->ElementFromPoint(point);
	}

	ASSERT(pElement != NULL);
	CGridRow* pRow = pElement->GetRow();
	if (pRow == GetCaptionRow())
		return;

	POSITION posSelHead = GetHeadSelPosition();
	CGridRow* pSelRow = (posSelHead == NULL) ? NULL : (CGridRow*) GetNextSel(posSelHead);

	ASSERT(pRow != NULL);
	// don't try to drag the new row
	if (pRow != pSelRow )
	{
		DoMove(GetRowIndex(pRow));
	}
}

afx_msg int CStringListGridWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CGridControlWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	ResetContent();
	return 0;
}

afx_msg UINT CStringListGridWnd::OnGetDlgCode() 
{
	return CGridControlWnd::OnGetDlgCode() | DLGC_WANTARROWS | DLGC_WANTCHARS;
}

 
/////////////////////////////////////////////////////////////////////////////
// CStringListGlyphGridWnd
CStringListGlyphGridWnd::CStringListGlyphGridWnd(LONG cxGlyph, LONG cyGlyph, UINT nModeFlags /*= 0*/)
	: CStringListGridWnd(nModeFlags), m_pGlyphWell(NULL)
{
	SetGlyphSize(cxGlyph, cyGlyph);
}

CStringListGlyphGridWnd::~CStringListGlyphGridWnd()
{
	if (m_pGlyphWell != NULL)
		delete m_pGlyphWell;
}

BOOL CStringListGlyphGridWnd::LoadGlyphWell(UINT nIDWell)
{
	if (m_pGlyphWell == NULL)
		m_pGlyphWell = new CImageWell;

	if (!m_pGlyphWell->Load(nIDWell, m_sizeGlyph))
		return FALSE;
	return m_pGlyphWell->Open();
}

BOOL CStringListGlyphGridWnd::AttachGlyphWell(HBITMAP hWell)
{
	if (m_pGlyphWell == NULL)
		m_pGlyphWell = new CImageWell;

	if (!m_pGlyphWell->Attach(hWell, m_sizeGlyph))
		return FALSE;
	return m_pGlyphWell->Open();
}

void CStringListGlyphGridWnd::DrawGlyph(CDC *pDC, int nGlyph, CPoint ptGlyph, DWORD dwRop)
{
	if (nGlyph != -1)
		m_pGlyphWell->DrawImage(pDC, ptGlyph, nGlyph, dwRop);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\hsres.h ===
/*

	HSRES.H
	=======

	Copyright 1996, Microsoft Corp.

	The following are helpstring ids for the 
	automation methods and properties.
	See include\ids.h for more information...

*/

#define MIN_HELPSTRING_ID	10000 // Copied from ids.h
#define MAX_HELPSTRING_ID	11000

// Help string constants for IApplication
#define IDS_HS_APPLICATION							MIN_HELPSTRING_ID
#define IDS_HS_APPLICATION_HEIGHT					(IDS_HS_APPLICATION+1)
#define IDS_HS_APPLICATION_WIDTH					(IDS_HS_APPLICATION+2)
#define IDS_HS_APPLICATION_TOP						(IDS_HS_APPLICATION+3)
#define IDS_HS_APPLICATION_LEFT						(IDS_HS_APPLICATION+4)
#define IDS_HS_APPLICATION_NAME						(IDS_HS_APPLICATION+5)
#define IDS_HS_APPLICATION_TEXTEDITOR				(IDS_HS_APPLICATION+6)
#define IDS_HS_APPLICATION_VERSION					(IDS_HS_APPLICATION+7)
#define IDS_HS_APPLICATION_PATH						(IDS_HS_APPLICATION+8)
#define IDS_HS_APPLICATION_CURRENTDIRECTORY			(IDS_HS_APPLICATION+9)
#define IDS_HS_APPLICATION_FULLNAME					(IDS_HS_APPLICATION+10)
#define IDS_HS_APPLICATION_ACTIVEDOCUMENT			(IDS_HS_APPLICATION+11)
#define IDS_HS_APPLICATION_WINDOWS					(IDS_HS_APPLICATION+12)
#define IDS_HS_APPLICATION_DOCUMENTS				(IDS_HS_APPLICATION+13)
#define IDS_HS_APPLICATION_ACTIVEWINDOW				(IDS_HS_APPLICATION+14)
#define IDS_HS_APPLICATION_WINDOWSTATE				(IDS_HS_APPLICATION+15)
#define IDS_HS_APPLICATION_DEBUGGER					(IDS_HS_APPLICATION+16)
#define IDS_HS_APPLICATION_PROJECTS					(IDS_HS_APPLICATION+17)
#define IDS_HS_APPLICATION_DEFAULTCONFIGURATIONS	(IDS_HS_APPLICATION+18)
#define IDS_HS_APPLICATION_VISIBLE					(IDS_HS_APPLICATION+19)
#define IDS_HS_APPLICATION_ACTIVEPROJECT			(IDS_HS_APPLICATION+20)
#define IDS_HS_APPLICATION_ACTIVE					(IDS_HS_APPLICATION+21)
#define IDS_HS_APPLICATION_GETPACKAGEEXTENSION		(IDS_HS_APPLICATION+22)
#define IDS_HS_APPLICATION_QUIT						(IDS_HS_APPLICATION+23)
#define IDS_HS_APPLICATION_PRINTTOOUTPUTWINDOW		(IDS_HS_APPLICATION+24)
#define IDS_HS_APPLICATION_EXECUTECOMMAND			(IDS_HS_APPLICATION+25)
#define IDS_HS_APPLICATION_ADDCOMMANDBARBUTTON		(IDS_HS_APPLICATION+26)
#define IDS_HS_APPLICATION_ADDKEYBINDING			(IDS_HS_APPLICATION+27)
#define IDS_HS_APPLICATION_BUILD					(IDS_HS_APPLICATION+28)
#define IDS_HS_APPLICATION_REBUILDALL				(IDS_HS_APPLICATION+29)
#define IDS_HS_APPLICATION_SETADDININFO				(IDS_HS_APPLICATION+30)
#define IDS_HS_APPLICATION_ADDCOMMAND				(IDS_HS_APPLICATION+31)
#define IDS_HS_APPLICATION_ENABLEMODELESS			(IDS_HS_APPLICATION+32)
#define IDS_HS_APPLICATION_CLEAN					(IDS_HS_APPLICATION+33)
#define IDS_HS_APPLICATION_ERRORS					(IDS_HS_APPLICATION+34)
#define IDS_HS_APPLICATION_WARNINGS					(IDS_HS_APPLICATION+35)
#define IDS_HS_APPLICATION_ADDPROJECT				(IDS_HS_APPLICATION+36)
#define IDS_HS_APPLICATION_EXECUTE     				(IDS_HS_APPLICATION+37)
#define IDS_HS_APPLICATION_max						(IDS_HS_APPLICATION+38)


// Helpstring constants for IApplicationEvents
#define IDS_HS_APPLICATION_EVENTS							IDS_HS_APPLICATION_max
#define IDS_HS_APPLICATION_EVENTS_BEFOREBUILDSTART			(IDS_HS_APPLICATION_EVENTS+1)
#define IDS_HS_APPLICATION_EVENTS_BUILDFINISH				(IDS_HS_APPLICATION_EVENTS+2)
#define IDS_HS_APPLICATION_EVENTS_BEFOREAPPLICATIONSHUTDOWN	(IDS_HS_APPLICATION_EVENTS+3)
#define IDS_HS_APPLICATION_EVENTS_DOCUMENTOPEN				(IDS_HS_APPLICATION_EVENTS+4)
#define IDS_HS_APPLICATION_EVENTS_BEFOREDOCUMENTCLOSE		(IDS_HS_APPLICATION_EVENTS+5)
#define IDS_HS_APPLICATION_EVENTS_DOCUMENTSAVE				(IDS_HS_APPLICATION_EVENTS+6)
#define IDS_HS_APPLICATION_EVENTS_NEWDOCUMENT				(IDS_HS_APPLICATION_EVENTS+7)
#define IDS_HS_APPLICATION_EVENTS_WINDOWACTIVATE			(IDS_HS_APPLICATION_EVENTS+8)
#define IDS_HS_APPLICATION_EVENTS_WINDOWDEACTIVATE			(IDS_HS_APPLICATION_EVENTS+9)
#define IDS_HS_APPLICATION_EVENTS_WORKSPACEOPEN				(IDS_HS_APPLICATION_EVENTS+10)
#define IDS_HS_APPLICATION_EVENTS_WORKSPACECLOSE			(IDS_HS_APPLICATION_EVENTS+11)
#define IDS_HS_APPLICATION_EVENTS_NEWWORKSPACE				(IDS_HS_APPLICATION_EVENTS+12)
#define IDS_HS_APPLICATION_EVENTS_max						(IDS_HS_APPLICATION_EVENTS+13)

// Helpstring contants for IDocuments
#define IDS_HS_DOCUMENTS			IDS_HS_APPLICATION_EVENTS_max
#define IDS_HS_DOCUMENTS_COUNT		(IDS_HS_DOCUMENTS+1)
#define IDS_HS_DOCUMENTS_ITEM		(IDS_HS_DOCUMENTS+3)
#define IDS_HS_DOCUMENTS_SAVEALL	(IDS_HS_DOCUMENTS+4)
#define IDS_HS_DOCUMENTS_CLOSEALL	(IDS_HS_DOCUMENTS+5)
#define IDS_HS_DOCUMENTS_ADD		(IDS_HS_DOCUMENTS+6)
#define IDS_HS_DOCUMENTS_OPEN		(IDS_HS_DOCUMENTS+7)
#define IDS_HS_DOCUMENTS_max		(IDS_HS_DOCUMENTS+8)

// Helpstrings constants for IWindows
#define IDS_HS_WINDOWS				IDS_HS_DOCUMENTS_max
#define IDS_HS_WINDOWS_COUNT		(IDS_HS_WINDOWS+1)
#define IDS_HS_WINDOWS_ITEM			(IDS_HS_WINDOWS+2)
#define IDS_HS_WINDOWS_ARRANGE		(IDS_HS_WINDOWS+3)
#define IDS_HS_WINDOWS_CLOSEALL		(IDS_HS_WINDOWS+4)
#define IDS_HS_WINDOWS_max			(IDS_HS_WINDOWS+5)

// Helpstring constants for IWindowEvent
#define IDS_HS_WINDOW_EVENT				IDS_HS_WINDOWS_max
#define IDS_HS_WINDOW_EVENT_ACTIVATE	(IDS_HS_WINDOW_EVENT+1)
#define IDS_HS_WINDOW_EVENT_DEACTIVATE	(IDS_HS_WINDOW_EVENT+2)
#define IDS_HS_WINDOW_EVENT_max			(IDS_HS_WINDOW_EVENT+3)

// Helpstring constants for IProjects
#define IDS_HS_PROJECTS			IDS_HS_WINDOW_EVENT_max
#define IDS_HS_PROJECTS_COUNT	(IDS_HS_PROJECTS+1)
#define IDS_HS_PROJECTS_ITEM	(IDS_HS_PROJECTS+2)
#define IDS_HS_PROJECTS_max		(IDS_HS_PROJECTS+3)

// Helpstrings constants for Shell.ODL
#define IDS_HS_SHELL				IDS_HS_PROJECTS_max
#define IDS_HS_SHELL_TYPELIBRARY	(IDS_HS_SHELL+1)
#define IDS_HS_SHELL_max			(IDS_HS_SHELL+2)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\helpkey.cpp ===
////////////////////////////////////////////////////////////////////////////
// Help Keyboard...

#include "stdafx.h"
#include "resource.h"
#include "utilctrl.h"
#include "tap.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

extern HICON AfxLoadIcon(UINT nResourceID);
extern void RemoveAccel(CString& strMenu);

// Item sequencing
//
// In 4.x, the displayed version of the keyboard grid was qsort-ed purely on
// its primary key. The printed version was qsorted first on its group and secondly
// on its 'command name' (e.g. FileOpen). A copied text version would be copied in the
// reverse order in which it was selected.
//
// This (inconsistent) system causes several problems:
// 1) Orion bug 102
//    When the user selects some key items to copy, they are copied in the reverse order of
//    their selection.
// 2) Random printout order
//    Printouts occur in seemingly random order. The order is unrelated
//    to what is displayed on screen. This becomes particularly noticeable
//    when the user selects several rows, as they are shuffled. The logic behind
//    the sort order is not clear to the user as the 'command name' is not included
//    in the printout
// 3) Sorting by group
//    When the user chooses to sort by group (e.g. 'Dialog', 'Image', etc), the suborder
//    seems completely random. It is, in fact, indirectly connected to the previous order
//    the list was in.
//
// To solve these problems:
// In the copy code, I am creating an extra list of pointers, which I will sort the same way
// as the displayed/printed list. An alternative would be to modify the internal ordering of the CGrid
// class, but this seems too major a change.
// In the display and print code in Orion I am implementing primary and secondary sorting keys.
// Primary = Group (as now), secondary = Command Name
// The secondary will always be description. 
// For printouts, the primary will always be group. The print secondary will be the display 
// primary, unless the display primary was group, in which case the print secondary
// will be the display secondary.
//
// Aside from cases with the same command name, which should be impossible, this scheme will ensure that 
// the copied and printed order matches the displayed order.
// martynl 12Mar96

////////////////////////////////////////////////////////////////////////////

class CHelpKeyWnd : public CFrameWnd
{
public:
	CHelpKeyWnd();
	~CHelpKeyWnd();

	void FillGrid();
	void FillGridCmds(int nGroup);
	void AddKeymapToGrid(CGridWnd* pGrid, CKeymap* pKeymap, 
		const char* szCategory, const char* szPrefix, WORD kcPrefix);
	void EnumCmdTable(CGridWnd* pGrid, int nGroup);
	void InitGroupNames();

	virtual BOOL Create();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpCreateStruct, 
		CCreateContext* pCreateContext);
	void DeleteGridRows();
	void UpdateGrid(int nGroup);

	void ReadProfile();
	void WriteProfile();

	void OnHelp();
	void OnPrint();
	void OnCopy();

	CRect m_wndRect;
	int m_nSortColumn;
	BOOL m_bAllCmds;
	int m_nPrevSel;

	CAppToolGroups* m_pToolGroups;

	CToolBar m_toolBar;
	CComboBox m_cbGroup;


protected:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnClose();
	afx_msg void OnToggleAllCmds();
	afx_msg void OnUpdateToggleAllCmds(CCmdUI* pCmdUI);
	afx_msg void OnGroupSelect();

	DECLARE_MESSAGE_MAP()
};

class CHelpKeyGridRow : public CGridRow
{
public:
	CHelpKeyGridRow(CGridWnd* pGrid);

	virtual int Compare(const CGridRow* pCompareRow) const;
	virtual void DrawCell(CDC* pDC, const CRect& rect, int nColumn);
	virtual void ResetSize(CDC* pDC);
	virtual CSize GetCellSize(CDC* pDC, int nColumn) const;

	UINT m_nCmdID;
	CString m_cells [4];
};

class CHelpKeyGrid : public CGridWnd
{
public:
	CHelpKeyGrid(int nSortColumn);
};

////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CHelpKeyWnd, CFrameWnd)
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_CLOSE()
	ON_COMMAND(ID_FILE_PRINT, OnPrint)
	ON_COMMAND(ID_EDIT_COPY, OnCopy)
	ON_CBN_SELCHANGE(ID_HELP_KEY_CATEGORY_COMBO, OnGroupSelect)
//	ON_COMMAND(ID_HELP, OnHelp)
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////

static const char szGeneral [] = "General";
static const char szPosKey [] = "KeyboardWindowPos";
static const char szSortKey [] = "KeyboardWindowSort";

extern BOOL GetRegRect(const char* szSection, const char* szEntry, CRect& rect);
extern void WriteRegRect(const char* szSection, const char* szEntry, const CRect& rect);

void CHelpKeyWnd::ReadProfile()
{
	if (!GetRegRect(szGeneral, szPosKey, m_wndRect))
		m_wndRect.SetRect(30, 30, 30 + 550, 30 + 300);
	m_nSortColumn = GetRegInt(szGeneral, szSortKey, 0);
}

void CHelpKeyWnd::WriteProfile()
{
	WriteRegRect(szGeneral, szPosKey, m_wndRect);
	WriteRegInt(szGeneral, szSortKey, m_nSortColumn);
}

CHelpKeyWnd::CHelpKeyWnd()
: m_pToolGroups(CAppToolGroups::GetAppToolGroups()),
  m_nPrevSel(-1)
{
	m_bAllCmds = FALSE;

	ReadProfile();
}

CHelpKeyWnd::~CHelpKeyWnd()
{
	m_pToolGroups->ReleaseAppToolGroups();

	WriteProfile();
}

BOOL CHelpKeyWnd::Create()
{
	CString strHelpKeyCaption;
	CString str;
	VERIFY(strHelpKeyCaption.LoadString(IDS_HELP_KEY_CAPTION));

	int cxScreen = GetSystemMetrics(SM_CXSCREEN);
	int cyScreen = GetSystemMetrics(SM_CYSCREEN);

	if (m_wndRect.left >= cxScreen - 32)
		m_wndRect.OffsetRect(m_wndRect.left - cxScreen - 32, 0);

	if (m_wndRect.top >= cyScreen - 32)
		m_wndRect.OffsetRect(0, m_wndRect.top - cyScreen - 32);

	if (!CFrameWnd::Create(AfxRegisterWndClass(0, LoadCursor(NULL, IDC_ARROW),
		0, AfxLoadIcon(IDR_HELP_KEYBOARD)), strHelpKeyCaption, WS_VISIBLE | 
		WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME, m_wndRect, 
		AfxGetApp()->m_pMainWnd, NULL, NULL, NULL))
	{
		return FALSE;
	}

	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);

	VERIFY(str.LoadString(IDS_HELP_KEY_EDITOR));
	pGrid->SetColumnCaption(0, str);
	VERIFY(str.LoadString(IDS_HELP_KEY_COMMAND));
	pGrid->SetColumnCaption(1, str);
	VERIFY(str.LoadString(IDS_HELP_KEY_KEYS));
	pGrid->SetColumnCaption(2, str);
	VERIFY(str.LoadString(IDS_HELP_KEY_DESCRIPTION));
	pGrid->SetColumnCaption(3, str);

	m_bAllCmds = FALSE;
	UpdateGrid(-1);
	
	return TRUE;
}

UINT buttons [] =
{
	ID_FILE_PRINT,
	ID_SEPARATOR,
	ID_EDIT_COPY, 
	ID_SEPARATOR,
	ID_SEPARATOR
};

int CHelpKeyWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	CString str;
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_toolBar.Create(this, WS_CHILD | WS_VISIBLE | CBRS_TOP | CBRS_TOOLTIPS) ||
		!m_toolBar.LoadBitmap(IDR_HELP_KEYBOARD) ||
		!m_toolBar.SetButtons(buttons, sizeof (buttons) / sizeof (UINT)))
	{
		return -1;
	}

	CRect rect;
	m_toolBar.GetItemRect(4, &rect);
	rect.top++;
	rect.bottom = rect.top + 150;
	rect.right = rect.left + 120;
	if (!m_cbGroup.Create(CBS_DROPDOWNLIST|CBS_HASSTRINGS|WS_VISIBLE|WS_VSCROLL,
			rect, &m_toolBar, ID_HELP_KEY_CATEGORY_COMBO))
	{
		return FALSE;
	}
	m_cbGroup.SetFont(GetStdFont(font_Normal));
	m_cbGroup.SetExtendedUI();

	VERIFY(str.LoadString(IDS_HELP_KEY_BOUND));
	int index = m_cbGroup.AddString(str);
	m_cbGroup.SetItemData(index, (unsigned)-1);
	VERIFY(str.LoadString(IDS_HELP_KEY_ALL));
	index = m_cbGroup.AddString(str);
	m_cbGroup.SetItemData(index, (unsigned)-1);
	InitGroupNames();
	m_cbGroup.SetCurSel(0);
	m_nPrevSel = 0;
	
	AfxGetApp()->m_pMainWnd->EnableWindow(FALSE);
	EnableWindow(TRUE);
	
	return 0;
}

BOOL CHelpKeyWnd::OnCreateClient(LPCREATESTRUCT lpCreateStruct, 
	CCreateContext* pCreateContext)
{
	ModifyStyleEx(WS_EX_CLIENTEDGE, 0L, SWP_DRAWFRAME);

	CHelpKeyGrid* pGrid = new CHelpKeyGrid(m_nSortColumn);
	if (!pGrid->CreateEx(WS_EX_CLIENTEDGE, WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), this, 
		AFX_IDW_PANE_FIRST))
	{
		return FALSE;
	}

	return CFrameWnd::OnCreateClient(lpCreateStruct, pCreateContext);
}

void CHelpKeyWnd::OnSetFocus(CWnd* pOldWnd)
{
	GetDlgItem(AFX_IDW_PANE_FIRST)->SetFocus();
}

void CHelpKeyWnd::OnClose()
{
	DeleteGridRows();
	delete (CHelpKeyGrid*) GetDlgItem(AFX_IDW_PANE_FIRST);

	AfxGetApp()->m_pMainWnd->EnableWindow(TRUE);
	GetWindowRect(m_wndRect);
	CFrameWnd::OnClose();
}

BOOL CHelpKeyWnd::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN)
	{
		switch (pMsg->wParam)
		{
//		case VK_F1:
//		case VK_RETURN:
//			OnHelp();
//			return TRUE;

		case 'P':
			if (GetKeyState(VK_CONTROL) < 0)
			{
				OnPrint();
				return TRUE;
			}
			break;
			
		case 'C':
			if (GetKeyState(VK_CONTROL) < 0)
			{
				OnCopy();
				return TRUE;
			}
			break;
			
		case VK_ESCAPE:
			if (GetKeyState(VK_CONTROL) >= 0)
			{
				OnClose();
				return TRUE;
			}
			break;
		}
	}

	if (pMsg->message == WM_SYSKEYDOWN && ::IsChild(m_hWnd, pMsg->hwnd))
	{
		PostMessage(WM_SYSKEYDOWN, pMsg->wParam, pMsg->lParam);
		return TRUE;
	}

	if (CFrameWnd::PreTranslateMessage(pMsg))
		return TRUE;

	// Finally, prevent keyboard messages from being PreTranslated by the
	// parent of this window.  Otherwise, the user will be able to execute
	// keyboard commands on the main window.

	if (pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
	{
		::TranslateMessage(pMsg);
		::DispatchMessage(pMsg);
		return TRUE;
	}

	return FALSE;
}

void CHelpKeyWnd::OnHelp()
{
//	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);
//	POSITION pos = pGrid->GetHeadSelPosition();
//	if (pos == NULL)
//	{
//		MessageBeep(0);
//		return;
//	}
//	
//	CHelpKeyGridRow* pRow = (CHelpKeyGridRow*)pGrid->GetNextSel(pos);
//	theApp.HelpOnApplication(pRow->m_nCmdID - HID_BASE_COMMAND, HELPTYPE_COMMAND);
}

void CHelpKeyWnd::DeleteGridRows()
{
	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);
	POSITION pos = pGrid->GetHeadRowPosition();
	pGrid->m_selection.RemoveAll();
	pGrid->m_posCurRow = NULL;
	pGrid->m_posTopVisibleRow = NULL;
	while (pos != NULL)
	{
		POSITION posOld = pos;
		CGridRow* pRow = pGrid->GetNextRow(pos);
		pGrid->m_rows.RemoveAt(posOld);
		delete pRow;
	}
}

void CHelpKeyWnd::UpdateGrid(int nGroup)
{
	BeginWaitCursor();
	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);
	pGrid->CloseActiveElement();
	DeleteGridRows();

	if (m_bAllCmds)
		FillGridCmds(nGroup);
	else
		FillGrid();
	UpdateWindow();
	EndWaitCursor();
}

void CHelpKeyWnd::OnUpdateToggleAllCmds(CCmdUI* pCmdUI)
{
	pCmdUI->SetCheck(m_bAllCmds);
}

void CHelpKeyWnd::OnGroupSelect()
{

	int nSel = m_cbGroup.GetCurSel();
	if (nSel == -1)
		return;

	// only refresh if the selection changed
	if (nSel != m_nPrevSel) {
		m_nPrevSel = nSel;

		CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);
		CString str;

		if (nSel == 0) {
			m_bAllCmds = FALSE;
			VERIFY(str.LoadString(IDS_HELP_KEY_EDITOR));
			pGrid->SetColumnCaption(0, str);
		}
		else {
			m_bAllCmds = TRUE;
			VERIFY(str.LoadString(IDS_HELP_KEY_CATEGORY));
			pGrid->SetColumnCaption(0, str);
		}
		int nGroup = m_cbGroup.GetItemData(nSel);
		UpdateGrid(nGroup);
	}
}

static int CopyCompareRows(const void* p1, const void* p2)
{
	const CHelpKeyGridRow* pRow1 = *(const CHelpKeyGridRow**)p1;
	const CHelpKeyGridRow* pRow2 = *(const CHelpKeyGridRow**)p2;
	return pRow1->Compare(pRow2);
}

void CHelpKeyWnd::OnCopy()
{
	CWaitCursor waitCursor;
	
	HGLOBAL hGlobal;
	TCHAR* pch;
	BOOL bUseSelection=FALSE;
	CPtrArray *pSortedSelection=NULL;

	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);

	// if we're copying a selection, we need to go to the grid, get all the selections,
	// and sort them into the same order as they're displayed on screen. The grid would
	// return them in the reverse order they were selected, which is no use. martynl 12Mar96
	if(!pGrid->m_selection.IsEmpty())
	{
		bUseSelection=TRUE;

		// this ptrarry will contain all of the selected rows
		pSortedSelection=new CPtrArray;
		pSortedSelection->SetSize(pGrid->m_selection.GetCount());

		// copy rows from grid
		POSITION pos = pGrid->GetHeadSelPosition();
		int index=0;
		while (pos != NULL)
		{
			CHelpKeyGridRow* pRow = (CHelpKeyGridRow*)(pGrid->GetNextSel(pos));

			pSortedSelection->SetAt(index,pRow);

			++index;
		}

		// sort them
		if ( pSortedSelection->GetSize( ) > 0 )
		{
			qsort(&((*pSortedSelection)[0]), pSortedSelection->GetSize(), sizeof (void*), CopyCompareRows);
		}
	}
	
	for (int pass = 0; pass < 2; pass += 1)
	{
		int cb = 0;
		// this loop is has two possible iterators. If we're iterating over a selection,
		// we're iterating a CPtrArray with index. If we're iterating over the whole thing,
		// we're iterating a CPtrList with pos.
		POSITION pos=NULL;
		int index=0;
		if(!bUseSelection)
		{
			pos=pGrid->GetHeadRowPosition();
		}

		// ensure that the initial value is valid
		ASSERT(bUseSelection || pos!=NULL);

		while ((bUseSelection && index <pSortedSelection->GetSize()) ||
			   (!bUseSelection && pos != NULL))
		{
			CHelpKeyGridRow* pRow = NULL;
			if(bUseSelection)
			{
				pRow=(CHelpKeyGridRow*)((*pSortedSelection)[index]);
				++index;
			} 
			else
			{
				pRow=(CHelpKeyGridRow*)(pGrid->GetNextRow(pos));
			}

			// ensure that pRow was initialised somehow
			ASSERT(pRow!=NULL);

			CString str = pRow->m_cells[0];
			str += '\t';
			str += pRow->m_cells[1];
			str += '\t';
			str += pRow->m_cells[2];
			str += '\t';
			str += pRow->m_cells[3];
			str += "\r\n";

			if (pass == 0)
			{
				cb += str.GetLength();
			}
			else
			{
				_tcscpy(pch, str);
				pch += str.GetLength();
			}
		}

		if (pass == 0)
		{
			cb += 1; // for '\0' terminator

			hGlobal = GlobalAlloc(GMEM_SHARE, cb);
			if (hGlobal == NULL)
			{
				MessageBeep(0);
				return;
			}
			
			pch = (TCHAR*)GlobalLock(hGlobal);
		}
	}
	
	GlobalUnlock(hGlobal);

	if(bUseSelection)
	{
		pSortedSelection->RemoveAll();
		delete pSortedSelection;
	}
	
	if (!OpenClipboard() || !EmptyClipboard())
	{
		MessageBeep(0);
		GlobalFree(hGlobal);
		return;
	}
	
	SetClipboardData(CF_TEXT, hGlobal);
	CloseClipboard();
}

static int CompareRows(const void* p1, const void* p2)
{
	const CHelpKeyGridRow* pRow1 = *(const CHelpKeyGridRow**)p1;
	const CHelpKeyGridRow* pRow2 = *(const CHelpKeyGridRow**)p2;

	// Category is primary sort key...
	int cmp = pRow1->m_cells[0].Compare(pRow2->m_cells[0]);
	if (cmp != 0)
		return cmp;

	// the print secondary key is the primary sort, unless that would just
	// duplicate the above sort, in which case we use the command
	int nSortColumn=pRow1->GetGrid()->m_nSortColumn;
	int nSubKey= nSortColumn==0 ? 1 : nSortColumn;

	// Name is secondary sort key...
	return pRow1->m_cells[nSubKey].Compare(pRow2->m_cells[nSubKey]);
}

void CHelpKeyWnd::OnPrint()
{
	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);

	DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | 
		PD_NOPAGENUMS | PD_HIDEPRINTTOFILE;
	if (pGrid->m_selection.IsEmpty())
		dwFlags |= PD_NOSELECTION;
	CPrintDialog dlg(FALSE, dwFlags);

	if (dlg.DoModal() != IDOK)
		return;

	UpdateWindow();
	
	HDC hDC = dlg.GetPrinterDC();
	if (hDC == NULL)
	{
		AfxMessageBox(AFX_IDP_FAILED_TO_START_PRINT);
		return;
	}

	CWaitCursor waitCursor;

	CPtrArray rows;

	// BLOCK: Fill in local rows array and sort by category
	{
		int nRow = 0;
		if (dlg.PrintSelection())
		{
			rows.SetSize(pGrid->m_selection.GetCount());
			POSITION pos = pGrid->GetHeadSelPosition();
			while (pos != NULL)
				rows[nRow++] = pGrid->GetNextSel(pos);
		}
		else
		{
			rows.SetSize(pGrid->GetRowCount());
			POSITION pos = pGrid->GetHeadRowPosition();
			while (pos != NULL)
				rows[nRow++] = pGrid->GetNextRow(pos);
		}

		// CompareRows is hard-coded to sort first by group
		qsort(&rows[0], rows.GetSize(), sizeof (void*), CompareRows);
	}

	CDC dc;
	dc.CreateCompatibleDC(NULL);
	int nXPelsPerInchScreen = dc.GetDeviceCaps(LOGPIXELSX);
	dc.DeleteDC();

	dc.Attach(hDC);

	// Body text font
	LOGFONT logfont = *GetStdLogfont(font_Normal, &dc);
	logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	CFont font;
	font.CreateFontIndirect(&logfont);

	// Heading font
	logfont = *GetStdLogfont(font_Bold, &dc);
	logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	logfont.lfHeight = logfont.lfHeight * 3 / 2;
	CFont headingFont;
	headingFont.CreateFontIndirect(&logfont);

	// Header/footer font
	logfont = *GetStdLogfont(font_Italic, &dc);
	logfont.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	CFont headerFont;
	headerFont.CreateFontIndirect(&logfont);

	CFont* pOldFont = dc.SelectObject(&font);

	int nPageWidth = dc.GetDeviceCaps(HORZRES);
	int nPageHeight = dc.GetDeviceCaps(VERTRES);
	int nXPelsPerInch = dc.GetDeviceCaps(LOGPIXELSX);
	int nYPelsPerInch = dc.GetDeviceCaps(LOGPIXELSY);
	
	CRect pageRect;
	pageRect.left = nXPelsPerInch;
	pageRect.top = nYPelsPerInch;
	pageRect.right = nPageWidth - nXPelsPerInch;
	pageRect.bottom = nPageHeight - nYPelsPerInch;
	
	CString strTitle;
	VERIFY(strTitle.LoadString(IDS_HELP_KEY_PRINT_TITLE));

	CString strCopyright;
	VERIFY(strCopyright.LoadString(IDS_HELP_KEY_PRINT_CRIGHT));

	CString strFmtPage;
	VERIFY(strFmtPage.LoadString(IDS_HELP_KEY_PRINT_PAGE));

	CString strFooter;
	VERIFY(strFooter.LoadString(IDS_HELP_KEY_PRINT_FOOTER));
	int cxFooter = dc.GetTextExtent(strFooter).cx;

	DOCINFO docinfo;
	memset(&docinfo, 0, sizeof(DOCINFO));		// make sure all members are initialized
	docinfo.cbSize = sizeof(DOCINFO);
	docinfo.lpszDocName = strTitle;
	docinfo.lpszOutput = NULL;

	dc.StartDoc(&docinfo);

	char chEmm = 'M';
	CSize sizeEmm = dc.GetTextExtent(&chEmm, 1);

	int cxColumn1 = 0;
	if (m_bAllCmds)
	{
		for (int i = 0; i < rows.GetSize(); i += 1)
		{
			CHelpKeyGridRow* pRow = (CHelpKeyGridRow*)rows[i];

			CSize size = dc.GetTextExtent(pRow->m_cells[1]);
			if (size.cx > cxColumn1)
				cxColumn1 = size.cx;
		}
	}

	int cxColumn2 = 0;
	for (int i = 0; i < rows.GetSize(); i += 1)
	{
		CHelpKeyGridRow* pRow = (CHelpKeyGridRow*)rows[i];

		CSize size = dc.GetTextExtent(pRow->m_cells[2]);
		if (size.cx > cxColumn2)
			cxColumn2 = size.cx;
	}

	int xCategory = pageRect.left;
	int xColumn1 = pageRect.left + nXPelsPerInch / 8;
	int xColumn2 = xColumn1 + cxColumn1 + nXPelsPerInch / 8;
	int xColumn3 = xColumn2 + cxColumn2 + nXPelsPerInch / 8;
	int xCenterPage = pageRect.left + pageRect.Width() / 2;
	int yHeader = sizeEmm.cy;
	int yFooter = nPageHeight - 2 * sizeEmm.cy;
	int cySpaceItems = 2 * (nYPelsPerInch / 72);

	int y = pageRect.top;
	int nPage = 1;
	CString strCategory;
	BOOL bEndedPage = TRUE;

	for (i = 0; i < rows.GetSize(); i += 1)
	{
		CHelpKeyGridRow* pRow = (CHelpKeyGridRow*)rows[i];

		BOOL bStartNewCategory = strCategory.Compare(pRow->m_cells[0]) != 0;

		// Calculate the height of the potentially multi-line description...
		CRect descRect(xColumn3, y, pageRect.right, y);
		int cyDesc = dc.DrawText(pRow->m_cells[3], descRect, DT_CALCRECT | DT_NOPREFIX | DT_WORDBREAK);

		// Calculate the total height of this item (might include new heading)...
		int cyItem = cyDesc;
		if (bStartNewCategory)
			cyItem += 3 * sizeEmm.cy; // Need room for a new heading

		// See if we need to start a new page...
		if (y + cyItem > pageRect.bottom)
		{
			bEndedPage = TRUE;
			dc.EndPage();
			y = pageRect.top;
			descRect.top = y;
			nPage += 1;
		}

		// Print the header and footer first thing for each page...
		if (y == pageRect.top)
		{
			dc.StartPage();
			bEndedPage = FALSE;

			// Print Header
			CFont* pOldFont = dc.SelectObject(&headerFont);

			CSize size = dc.GetTextExtent(strTitle);
			dc.TextOut(xCenterPage - size.cx / 2, yHeader, strTitle);

			size = dc.GetTextExtent(strCopyright);
			dc.TextOut(xCenterPage - size.cx / 2, yHeader + size.cy, strCopyright);

			// Print Footer
			CString str;
			str.Format(strFmtPage, nPage);
			size = dc.GetTextExtent(str);
			dc.TextOut(xCenterPage - size.cx / 2, yFooter, str);

			dc.TextOut(pageRect.right - cxFooter, yFooter, strFooter);

			dc.SelectObject(pOldFont);
		}

		if (bStartNewCategory)
		{
			// Print a new heading since the category changed...

			// One blank line
			y += sizeEmm.cy;

			// Heading in larger bold font
			strCategory = pRow->m_cells[0];
			CFont* pOldFont = dc.SelectObject(&headingFont);
			dc.TextOut(xCategory, y, strCategory);
			y += dc.GetTextExtent(&chEmm, 1).cy;
			dc.SelectObject(pOldFont);

			// Line under the heading
			int cy = nYPelsPerInch / 72;
			dc.PatBlt(xCategory, y + cy, pageRect.right - xCategory, cy, BLACKNESS);
			y += cy * 3;
		}

		// This may have moved due to a new page or category starting...
		descRect.top = y;
		descRect.bottom = descRect.top + cyDesc;

		if (m_bAllCmds)
			dc.TextOut(xColumn1, y, pRow->m_cells[1]);
		dc.TextOut(xColumn2, y, pRow->m_cells[2]);
		dc.DrawText(pRow->m_cells[3], descRect, DT_NOPREFIX | DT_WORDBREAK);

		y += cyDesc + cySpaceItems;
	}

	if (!bEndedPage)
		dc.EndPage();
		
	dc.EndDoc();
	dc.SelectObject(pOldFont);
}

extern void AccelFromKc(ACCEL& acc, WORD kc, UINT nCmdID = 0);
extern void GetCmdDescription(UINT nCmdID, CString& str);

void CHelpKeyWnd::AddKeymapToGrid(CGridWnd* pGrid, CKeymap* pKeymap, 
	const char* szCategory, const char* szPrefix, WORD kcPrefix)
{
	POSITION pos = pKeymap->GetStartPosition();
	while (pos != NULL)
	{
		WORD kc;
		UINT nCmdID;
		CKeymap* pSubKeymap;
		pKeymap->GetNextKey(pos, kc, nCmdID, pSubKeymap);
		
		ACCEL acc;
		AccelFromKc(acc, kc, nCmdID);
		
		if (pSubKeymap == NULL)
		{
			LPCTSTR lpszCommand; 

			// Note: dynamic command strings are stored in a single global CString, so we don't
			// want to hold onto the return value of GetCOmmandString very long. In this case,
			// we copy it to a CString (m_cells) which lets us reuse the global cstring
			// bobz 7/96

			if (!theCmdCache.GetCommandString(nCmdID, STRING_COMMAND, &lpszCommand))
				continue;

			// olympus 12483
			// filter out unnamed commands
			// this needs to be fast, since filling the grid control
			// with all bound commands is already very slow
			if (lpszCommand[0] == _T('\0'))
				continue;

			CHelpKeyGridRow* pRow = new CHelpKeyGridRow(pGrid);
			pRow->m_nCmdID = nCmdID;
			pRow->m_cells[0] = szCategory;
			pRow->m_cells[1] = lpszCommand;	// this copies to a CString, so we are not really holding onto lpszCommand
			pRow->m_cells[2] = CString(szPrefix) + CTap::MakeAccelName(acc);
			GetCmdDescription(nCmdID, pRow->m_cells[3]);
			pGrid->AddRow(pRow, FALSE);
		}
		else
		{
			AddKeymapToGrid(pGrid, pSubKeymap, szCategory, 
				CTap::MakeAccelName(acc) + ", ", kc);
		}
	}
}

void CHelpKeyWnd::FillGrid()
{
	CWaitCursor waitCursor;

	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);
	
	ASSERT(pGrid->m_rows.GetCount() == 1);

	POSITION pos = CKeymap::c_keymaps.GetHeadPosition();
	while (pos != NULL)
	{
		CKeymap* pKeymap = (CKeymap*)(void*)CKeymap::c_keymaps.GetNext(pos);
		if (pKeymap->m_strName.IsEmpty())
			continue;
		AddKeymapToGrid(pGrid, pKeymap, pKeymap->m_strName, NULL, 0);
	}

	pGrid->ResetSize();
	pGrid->Invalidate(FALSE);
	pGrid->ResetScrollBars();

	pGrid->SizeColumnToFit(2);
	pGrid->SizeColumnToFit(1);
	pGrid->SizeColumnToFit(0);
}

void CHelpKeyWnd::InitGroupNames()
{
	for (int i = 0; i < m_pToolGroups->m_nGroups; i++)
	{
		if (m_pToolGroups->m_rgGroups[i].m_nCmds == 0)
			continue;

		int index = m_cbGroup.AddString(m_pToolGroups->m_rgGroups[i].m_strGroup);
		m_cbGroup.SetItemData(index, i);
	}
}

void CHelpKeyWnd::EnumCmdTable(CGridWnd* pGrid, int nGroup)
{
	CToolGroup* m_pGroup = &(m_pToolGroups->m_rgGroups[nGroup]);

	for (int i = 0; i < m_pGroup->m_nCmds; i++)
	{
		// get the command
		CTE* pCTE = (CTE*)m_pGroup->m_aCmds[i];
		// get the command's name
		LPCTSTR pszCmdName = pCTE->szCommand;

		// only add commands that have a name and are not marked NOKEY
		if (pszCmdName && pszCmdName[0]!=_T('\0') && !(pCTE->flags & CT_NOKEY)) {

			CHelpKeyGridRow* pRow = new CHelpKeyGridRow(pGrid);

			pRow->m_cells[0] = m_pToolGroups->m_rgGroups[nGroup].m_strGroup;
			pRow->m_nCmdID = pCTE->id;
			pRow->m_cells[1] = pszCmdName;
			GetCmdKeyStringAll(pCTE->id, pRow->m_cells[2]);
			GetCmdDescription(pCTE->id, pRow->m_cells[3]);
			pGrid->AddRow(pRow, FALSE);

		}
	}
}

void CHelpKeyWnd::FillGridCmds(int nGroup)
{
	CHelpKeyGrid* pGrid = (CHelpKeyGrid*)GetDlgItem(AFX_IDW_PANE_FIRST);

	// are we doing all groups?
	if (nGroup == -1) {
		for (int i = 0; i < m_pToolGroups->m_nGroups; i++) {
			if (m_pToolGroups->m_rgGroups[i].m_nCmds > 0) {
				EnumCmdTable(pGrid, i);
			}
		}
	}
	else {
		EnumCmdTable(pGrid, nGroup);
	}

	pGrid->ResetSize();
	pGrid->Invalidate(FALSE);
	pGrid->ResetScrollBars();

	pGrid->SizeColumnToFit(2);
	pGrid->SizeColumnToFit(1);
	pGrid->SizeColumnToFit(0);
}

////////////////////////////////////////////////////////////////////////////

CHelpKeyGridRow::CHelpKeyGridRow(CGridWnd* pGrid) : CGridRow(pGrid)
{
	m_cyHeight = pGrid->GetCaptionRow()->GetRowHeight();
}

int CHelpKeyGridRow::Compare(const CGridRow* pCompareRow) const
{
	int nPrimarySortColumn = GetGrid()->m_nSortColumn;
	int dif=m_cells[nPrimarySortColumn].Compare(((CHelpKeyGridRow*)pCompareRow)->m_cells[nPrimarySortColumn]);

	if(dif!=0) {
		return dif;
	}

	int nSecondarySortColumn = 1; // always command name
	return m_cells[nSecondarySortColumn].Compare(((CHelpKeyGridRow*)pCompareRow)->m_cells[nSecondarySortColumn]);
}

void CHelpKeyGridRow::DrawCell(CDC* pDC, const CRect& cellRect, int nColumn)
{
	CRect rect = cellRect;

	if (nColumn == 3)
	{
		CGridWnd* pGrid = GetGrid();
		
		rect.bottom -= 1; // adjust for separator line
		
		pDC->ExtTextOut(0, 0, ETO_OPAQUE, &rect, "", 0, NULL);

		rect.InflateRect(-1, -1);
		pDC->DrawText(m_cells[nColumn], m_cells[nColumn].GetLength(), rect, DT_NOPREFIX | (nColumn == 3 ? DT_WORDBREAK : 0));
		rect.InflateRect(1, 1);
	}
	else
	{	
		pDC->ExtTextOut(rect.left, rect.top, ETO_CLIPPED | ETO_OPAQUE,
			rect, m_cells[nColumn], m_cells[nColumn].GetLength(), NULL);
	}

	CBrush* pOldBrush = pDC->SelectObject(CDC::GetHalftoneBrush());
	pDC->PatBlt(cellRect.left, cellRect.bottom - 1, cellRect.Width(), 1, PATCOPY);
	pDC->SelectObject(pOldBrush);
}

void CHelpKeyGridRow::ResetSize(CDC* pDC)
{
	m_cyHeight = GetCellSize(pDC, 3).cy;
}

CSize CHelpKeyGridRow::GetCellSize(CDC* pDC, int nColumn) const
{
	int cxColumn = GetGrid()->GetColumnWidth(nColumn);
	CSize size;
	if (nColumn == 3 && cxColumn > 0)
	{
		CRect rect(0, 0, cxColumn, 0);
		pDC->DrawText(m_cells[nColumn], m_cells[nColumn].GetLength(), rect, DT_CALCRECT | DT_NOPREFIX | (nColumn == 3 ? DT_WORDBREAK : 0));
		size = rect.Size();
	}
	else
	{
		size = pDC->GetTextExtent(m_cells[nColumn]);
	}
	size.cx += 10;
	size.cy += 3;

	return size;
}

////////////////////////////////////////////////////////////////////////////

CHelpKeyGrid::CHelpKeyGrid(int nSortColumn) : CGridWnd(4, TRUE)
{
	m_nSortColumn = nSortColumn;
}

////////////////////////////////////////////////////////////////////////////

void CMainFrame::OnHelpKeyboard()
{
	CHelpKeyWnd* pHelpKeyWnd = new CHelpKeyWnd;
	pHelpKeyWnd->Create();

	// Deleted in CFrameWnd::PostNcDestroy().
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\iconlist.cpp ===
#include "stdafx.h"
#include "utilctrl.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////
// CIconList class

void CIconList::SetIcon(int nItem, HICON hIcon)
{
	SetItemData(nItem, (DWORD)hIcon);
}

HICON CIconList::GetIcon(int nItem)
{
	return (HICON)GetItemData(nItem);
}

BOOL CIconList::SubclassDlgItem(UINT nID, CWnd* pParent)
{
	if (!CWnd::SubclassDlgItem(nID, pParent))
		return FALSE;
	
	ASSERT((GetStyle() & (LBS_OWNERDRAWVARIABLE | LBS_HASSTRINGS)) == 
		(LBS_OWNERDRAWVARIABLE | LBS_HASSTRINGS) ||
	(GetStyle() & (LBS_OWNERDRAWFIXED | LBS_HASSTRINGS)) == 
		(LBS_OWNERDRAWFIXED | LBS_HASSTRINGS));
	
	return TRUE;
}

void CIconList::MeasureItem(LPMEASUREITEMSTRUCT lpmis)
{
	lpmis->itemHeight = 1 + 32 + 1;
	lpmis->itemWidth  = (UINT)-1;
}

void CIconList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CRect rect;
	rect.left = lpDrawItemStruct->rcItem.left;
	rect.top = lpDrawItemStruct->rcItem.top;
	rect.right = lpDrawItemStruct->rcItem.right;
	rect.bottom = lpDrawItemStruct->rcItem.bottom;
	
	if (lpDrawItemStruct->itemID >= 0 &&
		(lpDrawItemStruct->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) != 0)
	{
		BOOL fDisabled = !IsWindowEnabled();

		COLORREF newTextColor = fDisabled ? RGB(0x80, 0x80, 0x80) : GetSysColor(COLOR_WINDOWTEXT);	// light gray
		COLORREF oldTextColor = pDC->SetTextColor(newTextColor);

		COLORREF newBkColor = GetSysColor(COLOR_WINDOW);
		COLORREF oldBkColor = pDC->SetBkColor(newBkColor);

		if (newTextColor == newBkColor)
			newTextColor = RGB(0xC0, 0xC0, 0xC0);	// dark gray
		
		if (!fDisabled && ((lpDrawItemStruct->itemState & ODS_SELECTED) != 0))
		{
			pDC->SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
			pDC->SetBkColor(GetSysColor(COLOR_HIGHLIGHT));
		}

		CString strText; 
		GetText(lpDrawItemStruct->itemID, strText);
		CSize size = pDC->GetTextExtent(strText);
		pDC->ExtTextOut(rect.left + 1 + 32 + 4, rect.top + max(0, 1 + (32 - size.cy) / 2), 
				ETO_OPAQUE, rect, strText, strText.GetLength(), NULL);
		
		HICON hIcon = GetIcon(lpDrawItemStruct->itemID);
		if (hIcon != NULL)
			pDC->DrawIcon(rect.left + 1, rect.top + 1, hIcon);

		pDC->SetTextColor(oldTextColor);
		pDC->SetBkColor(oldBkColor);
	}
	
	if ((lpDrawItemStruct->itemAction & ODA_FOCUS) != 0)
		pDC->DrawFocusRect(rect);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\imeutil.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <winnls32.h>
#include <string.h>
#include <ime32.h>
#include "imeutil.h"

/*
**	FUNCTION:		imeMoveConvertWin
**
**	PURPOSE:		Move the IME conversion window.
**
**	NOTES:
*/

void imeMoveConvertWin (HWND hWnd, int xp, int yp)
{
	theIME.MoveConversionWin( CWnd::FromHandle(hWnd), xp, yp );
}

/*
**	FUNCTION:		imeFont
**
**	PURPOSE:		Notify the IME of a change in font.
**
**	NOTES:
*/

void imeChangeFont (HWND hWnd, HFONT hFont)
{
	theIME.SetFont( CWnd::FromHandle(hWnd), hFont );
}


/*
**	FUNCTION:		imeInit
**
**	PURPOSE:		
**
**	NOTES:		
*/

void imeInit ()
{
	// This is a no-op
}


/*
**	FUNCTION:		imeEnableIME
**
**	PURPOSE:		Enable/Disable the IME.
**
**	NOTES:		
*/

BOOL 
imeEnableIME (HWND hWnd, BOOL bEnable)
{
	return theIME.EnableIME( bEnable );
}


/*
**	FUNCTION:		imeFlush
**
**	PURPOSE:		Flush undermined string from the IME
**
**	NOTES:		
*/
void imeFlush( HWND hWnd )
{
	theIME.Flush( CWnd::FromHandle( hWnd ) );
}

BOOL imeIsOpen()
{
	return theIME.IsOpen();
}

BOOL imeIsEnabled()
{
	return theIME.IsEnabled();
}

BOOL imeIsActive()
{
	return theIME.IsActive();
}

// CIME:
CIME theIME;

CIME::CIME()
{
	if (_getmbcp() == 932)		// Japanese code page
	{
		m_hIMEData = GlobalAlloc( GMEM_MOVEABLE | GMEM_SHARE | GMEM_ZEROINIT, sizeof(IMESTRUCT) );
		m_pIMEData = (LPIMESTRUCT) GlobalLock( m_hIMEData );
		GlobalUnlock( m_hIMEData );
		m_hNLS = LoadLibrary( "USER32.DLL" );
		ASSERT( m_hNLS );

		m_lpfnSendIMEMessage = (WORD (FAR WINAPI *)(HWND, LONG))GetProcAddress(m_hNLS, "SendIMEMessageExA");
		m_lpfnEnableIME = (BOOL (FAR WINAPI *)(HWND, BOOL))GetProcAddress(m_hNLS, "WINNLSEnableIME");
		m_lpfnGetEnableStatus = (BOOL (FAR WINAPI *)(HWND))GetProcAddress(m_hNLS, "WINNLSGetEnableStatus");
	}
	else		// non-Japanese code pages may be DBCS-enabled, but are not IME-enabled
	{
		m_hIMEData = NULL;
		m_pIMEData = NULL;
		m_hNLS = NULL;
		m_lpfnSendIMEMessage = NULL;
		m_lpfnEnableIME = NULL;
		m_lpfnGetEnableStatus = NULL;
	}
}

CIME::~CIME()
{
	if (m_hNLS)
		FreeLibrary( m_hNLS);
	if (m_hIMEData)
		GlobalFree(m_hIMEData);
}

void CIME::MoveConversionWin( CWnd *pWnd, int x, int y )
{
	if (m_pIMEData != NULL)
	{
		m_pIMEData->fnc = IME_SETCONVERSIONWINDOW;
		m_pIMEData->wParam = ((x == -1) && (y == -1)) ? MCW_DEFAULT : MCW_WINDOW;
		m_pIMEData->lParam1 = MAKELONG(x, y);
		m_xPix = x;
		m_yPix = y;

		if (m_lpfnSendIMEMessage != NULL)
			(*(m_lpfnSendIMEMessage))(pWnd->GetSafeHwnd(), (LPARAM) m_hIMEData);
	}
}

void CIME::SetFont( CWnd *pWnd, HFONT hFont )
{
	LOGFONT lf;

	GetObject(hFont, sizeof(LOGFONT), &lf);
	if (lf.lfCharSet != SHIFTJIS_CHARSET)		// disable the ime
	{
		EnableIME( FALSE );
	}
	else
	{
		if (m_pIMEData != NULL)
		{
			HGLOBAL hlf;		// Need this for IME call!
			LOGFONT *plf;

			hlf = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, sizeof(LOGFONT));
			plf = (LOGFONT *)GlobalLock(hlf);
			memcpy((void *)plf, (void *)&lf, sizeof(LOGFONT));
			EnableIME( TRUE );			// make sure it's enabled
			m_pIMEData->fnc = IME_SETCONVERSIONFONTEX;
			m_pIMEData->lParam1 = (LPARAM)hlf;

			if (m_lpfnSendIMEMessage != NULL)
				(*(m_lpfnSendIMEMessage))( pWnd->GetSafeHwnd(), (LPARAM)m_hIMEData );

			GlobalUnlock(hlf);
			GlobalFree(hlf);
		}
	}
}

static BOOL g_bIMEEnabled = TRUE;
BOOL CIME::EnableIME( BOOL bEnable )
{
	g_bIMEEnabled = bEnable;
	if (m_lpfnEnableIME != NULL)
		return (*(m_lpfnEnableIME))(NULL, bEnable);
	else
		return FALSE;
}

void CIME::Flush( CWnd *pWnd )
{
	if (m_pIMEData != NULL)
	{
		m_pIMEData->fnc = IME_SENDVKEY;
		m_pIMEData->wParam = VK_DBE_FLUSHSTRING;

		if (m_lpfnSendIMEMessage != NULL)
			(*(m_lpfnSendIMEMessage))(pWnd->GetSafeHwnd(), (LPARAM)m_hIMEData);
	}
}

BOOL CIME::IsOpen()
{
	if (m_pIMEData != NULL)
	{
		m_pIMEData->fnc = IME_GETOPEN;

		if (m_lpfnSendIMEMessage != NULL)
			return ((*(m_lpfnSendIMEMessage))( ::GetFocus(), (LPARAM)m_hIMEData) != 0);
	}

	return FALSE;
}

BOOL CIME::IsEnabled()
{
	if (m_lpfnGetEnableStatus != NULL)
		return g_bIMEEnabled;
	else
		return FALSE;
}

BOOL CIME::IsActive()
{
	return IsOpen() && IsEnabled();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\imeutil.h ===
/*
**	FILE:	imeutil.h
*/

#ifndef __IMEUTIL_H
#define __IMEUTIL_H

#include "ime32.h"

// Prototypes
void imeInit (void);

// Class
class CIME
{
// Construction
public:
	CIME();
	~CIME();

// Attributes
protected:
	HANDLE m_hIMEData;
	LPIMESTRUCT m_pIMEData;
	HINSTANCE m_hNLS;
	WORD (FAR WINAPI *m_lpfnSendIMEMessage)(HWND, LONG);
	BOOL (FAR WINAPI *m_lpfnEnableIME)(HWND, BOOL);
	BOOL (FAR WINAPI *m_lpfnGetEnableStatus)(HWND);
public:
	int m_xPix;
	int m_yPix;

// Operations
public:
	void MoveConversionWin( CWnd *pWnd, int x, int y );
	void SetFont( CWnd *pWnd, HFONT hFont );
	BOOL EnableIME( BOOL );
	void Flush( CWnd *pWnd );
	BOOL IsOpen();
	BOOL IsEnabled();
	BOOL IsActive();
};

extern CIME theIME;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\imgwell.cpp ===
#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define DSx		0x00660046L
#define DSna	0x00220326L

CImageWell::CImageWell() 
	: m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(0, 0)
{
	m_nBitmapID = 0;
	m_pbitmap = NULL;
}


CImageWell::CImageWell(UINT nBitmapID, CSize imageSize) 
	: m_bitmap(), m_dc(), m_mask(), m_maskDC(), m_imageSize(imageSize)
{
	m_nBitmapID = nBitmapID;
	m_pbitmap = NULL;
}


CImageWell::~CImageWell()
{
	// Destructor needed to ensure the DC is deleted before the bitmap
	m_dc.DeleteDC();
	m_bitmap.DeleteObject();
	m_maskDC.DeleteDC();
	m_mask.DeleteObject();
}

void CImageWell::SetBitmap(CBitmap *pBitmap, CSize imageSize) 
{
	m_imageSize =imageSize;
	m_pbitmap = pBitmap;
}


BOOL CImageWell::Load(UINT nBitmapID, CSize imageSize)
{
	if(m_bitmap.m_hObject)
	{
		Unload();
	}

	ASSERT(m_bitmap.m_hObject == NULL);

	HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapID), RT_BITMAP); 
	HINSTANCE hOldInst = AfxGetResourceHandle();

	AfxSetResourceHandle(hInst);
	if (!m_bitmap.LoadBitmap(nBitmapID))
	{
		TRACE1("Could not load image well %d\n", nBitmapID);
		return FALSE;
	}
	AfxSetResourceHandle(hOldInst);
	
	m_nBitmapID = nBitmapID;
	m_imageSize = imageSize;

	m_pbitmap = &m_bitmap;	
	return TRUE;
}

/* LoadSysColor
 *	Loads the bitmap containing the image well using AfxLoadSysColorBitmap,
 *	which will convert black, grays and white to the current system colors for buttons.
 */
BOOL CImageWell::LoadSysColor(UINT nBitmapID, CSize imageSize)
{
	ASSERT(m_bitmap.m_hObject == NULL);

	HINSTANCE hInst = AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapID), RT_BITMAP); 
	HINSTANCE hOldInst = AfxGetResourceHandle();

	AfxSetResourceHandle(hInst);

	HRSRC hRes = ::FindResource(hInst, MAKEINTRESOURCE(nBitmapID), RT_BITMAP);
	HBITMAP hBitmap = AfxLoadSysColorBitmap(hInst, hRes);
	if( hBitmap == NULL )
	{
		TRACE1("Could not load image well %d\n", nBitmapID);
		return FALSE;
	}

	AfxSetResourceHandle(hOldInst);

	m_nBitmapID = 0;
	m_imageSize = imageSize;
	m_bitmap.Attach(hBitmap);
	m_pbitmap = &m_bitmap;
	return TRUE;
}

BOOL CImageWell::Attach(HBITMAP hBitmap, CSize imageSize)
{
	ASSERT(m_bitmap.m_hObject == NULL);
	ASSERT(hBitmap != NULL);

	if (!m_bitmap.Attach(hBitmap))
	{
		TRACE0("Could not attach image well\n");
		return FALSE;
	}

	m_nBitmapID = 0;
	m_imageSize = imageSize;

	m_pbitmap = &m_bitmap;	
	return TRUE;
}

HBITMAP CImageWell::Detach()
{
	m_pbitmap = NULL;
	m_nBitmapID = 0;

	return (HBITMAP)m_bitmap.Detach();
}

void CImageWell::Unload()
{
	ASSERT(m_dc.m_hDC == NULL); // can't unload if it's open!
	ASSERT(m_maskDC.m_hDC == NULL);
	ASSERT(m_bitmap.m_hObject != NULL);
	
	m_bitmap.DeleteObject();
	m_mask.DeleteObject();
}


BOOL CImageWell::CalculateMask()
{
	ASSERT(m_maskDC.m_hDC == NULL);
	ASSERT(m_dc.m_hDC != NULL);
	ASSERT(m_pbitmap->m_hObject != NULL);
	
	if (!m_maskDC.CreateCompatibleDC(NULL))
		return FALSE;
	
	if (m_mask.m_hObject != NULL)
	{
		VERIFY(m_maskDC.SelectObject(&m_mask) != NULL);
		return TRUE;
	}
		
	BITMAP bmp;
	m_pbitmap->GetObject(sizeof (BITMAP), &bmp);
	
	if (!m_mask.CreateBitmap(bmp.bmWidth, bmp.bmHeight, 1, 1, NULL))
	{
		m_maskDC.DeleteDC();
		return FALSE;
	}

	VERIFY( m_maskDC.SelectObject(&m_mask) != NULL);
	
	COLORREF oldBkColor = m_dc.SetBkColor(m_dc.GetPixel(0, 0));
	m_maskDC.BitBlt(0, 0, bmp.bmWidth, bmp.bmHeight, 
		&m_dc, 0, 0, NOTSRCCOPY);
	m_dc.SetBkColor(oldBkColor);
	return TRUE;
}


BOOL CImageWell::Open()
{
	ASSERT(m_dc.m_hDC == NULL); // make sure this is not already open
	ASSERT(m_nBitmapID != 0 || m_pbitmap != NULL);
		
	if (m_pbitmap == NULL && !Load(m_nBitmapID, m_imageSize))
		return FALSE;
	
	if (!m_dc.CreateCompatibleDC(NULL))
		return FALSE;
	
	VERIFY(m_dc.SelectObject(m_pbitmap));
	
	return TRUE;
}


void CImageWell::Close()
{
	ASSERT(m_dc.m_hDC != NULL);
	
	m_dc.DeleteDC();
	m_maskDC.DeleteDC();
}

BOOL CImageWell::DrawImage(CDC* pDestDC, CPoint destPoint, 
	UINT nImage, DWORD rop)
{
	BOOL bClose = FALSE;
	if (m_dc.m_hDC == NULL)
	{
		ASSERT(rop != NULL); // must open first and calc mask for rop==0!
		
		if (!Open())
		{
			TRACE("Could not open image well!\n");
			return FALSE;
		}
		
		bClose = TRUE;
	}
	
	if (rop == 0)
	{
		if (m_maskDC.m_hDC == NULL && !CalculateMask())
			return FALSE;
		
		COLORREF oldBkColor = pDestDC->SetBkColor(RGB(255, 255, 255));
		COLORREF oldTextColor = pDestDC->SetTextColor(RGB(0, 0, 0));

		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			m_imageSize.cx, m_imageSize.cy,
			&m_dc, m_imageSize.cx * nImage, 0, DSx);
		
		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			m_imageSize.cx, m_imageSize.cy,
			&m_maskDC, m_imageSize.cx * nImage, 0, DSna);
		
		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			m_imageSize.cx, m_imageSize.cy,
			&m_dc, m_imageSize.cx * nImage, 0, DSx);
		pDestDC->SetBkColor(oldBkColor);
		pDestDC->SetTextColor(oldTextColor);
	}
	else
	{
		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			m_imageSize.cx, m_imageSize.cy,
			&m_dc, m_imageSize.cx * nImage, 0, rop);
	}
	
	if (bClose)
		Close();
	
	return TRUE;
}

BOOL CImageWell::DrawImage(CDC* pDestDC, CPoint destPoint, 
	UINT nImage, CSize sizeOverride, DWORD rop)
{
	BOOL bClose = FALSE;
	if (m_dc.m_hDC == NULL)
	{
		ASSERT(rop != NULL); // must open first and calc mask for rop==0!
		
		if (!Open())
		{
			TRACE("Could not open image well!\n");
			return FALSE;
		}
		
		bClose = TRUE;
	}
	
	if (rop == 0)
	{
		if (m_maskDC.m_hDC == NULL && !CalculateMask())
			return FALSE;
		
		COLORREF oldBkColor = pDestDC->SetBkColor(RGB(255, 255, 255));
		COLORREF oldTextColor = pDestDC->SetTextColor(RGB(0, 0, 0));

		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			sizeOverride.cx, sizeOverride.cy,
			&m_dc, m_imageSize.cx * nImage, 0, DSx);
		
		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			sizeOverride.cx, sizeOverride.cy,
			&m_maskDC, m_imageSize.cx * nImage, 0, DSna);
		
		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			sizeOverride.cx, sizeOverride.cy,
			&m_dc, m_imageSize.cx * nImage, 0, DSx);
		pDestDC->SetBkColor(oldBkColor);
		pDestDC->SetTextColor(oldTextColor);
	}
	else
	{
		pDestDC->BitBlt(destPoint.x, destPoint.y, 
			sizeOverride.cx, sizeOverride.cy,
			&m_dc, m_imageSize.cx * nImage, 0, rop);
	}
	
	if (bClose)
		Close();
	
	return TRUE;
}

BOOL CImageWell::DrawMask(CDC* pDestDC, CPoint destPoint, 
	UINT nImage, DWORD rop)
{
	ASSERT(m_maskDC.m_hDC != NULL); // must open first and calc mask
	
	pDestDC->BitBlt(destPoint.x, destPoint.y, 
		m_imageSize.cx, m_imageSize.cy,
		&m_maskDC, m_imageSize.cx * nImage, 0, rop);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\intrnlap.cpp ===
#include "stdafx.h"

#include "shell.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CBuilderWizardManager *CInternalApp::GetBuilderWizardManager()
{
	return &m_builderWizardManager;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcfrmhk.cpp ===
// ipcfrmhk.cpp : implementation of the CIPCompFrameHook class
//

#include "stdafx.h"
#pragma hdrstop

#include <stdidcmd.h>
#include <docobj.h>
#include <oleipcid.h>
#include "shldocs_.h"
#include "ipcmpctr.h"
#include "ipcfrmhk.h"
#include "ipchost.h"
#include "resource.h"
#include <cmguids.h>

#include <shlmenu.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

UINT WM_RESETCOMMANDTARGET = RegisterMessage(_T("Reset Command Target"));

/////////////////////////////////////////////////////////////////////////////
// CIPCompFrameHook implementation

BEGIN_INTERFACE_MAP(CIPCompFrameHook, COleFrameHook )
	INTERFACE_PART(CIPCompFrameHook, IID_IOleComponentUIManager, OleCompUIMgr)
	INTERFACE_PART(CIPCompFrameHook, IID_IOleInPlaceComponentUIManager, OleIPCompUIMgr)
	INTERFACE_PART(CIPCompFrameHook, IID_IServiceProvider, ServiceProvider)
END_INTERFACE_MAP()

CIPCompFrameHook::CIPCompFrameHook(CFrameWnd* pFrameWnd, CFrameWnd* pDocFrameWnd, COleClientItem* pItem)
	:COleFrameHook(pFrameWnd, pItem)
{
	m_fEnteringState = FALSE;
	m_fTopLevelContext = FALSE;
	ASSERT((CWnd *)pFrameWnd == AfxGetMainWnd());
	((CMainFrame *)AfxGetMainWnd())->AddIPCompFrameHook(this);
	
	m_pDocFrameWnd = pDocFrameWnd;
	if (pDocFrameWnd)
	{
		ASSERT(pDocFrameWnd->m_pNotifyHook == NULL); //since we are inplace component
		pDocFrameWnd->m_pNotifyHook = this;    // assume start out hooked
	}
}

CIPCompFrameHook::~CIPCompFrameHook()
{
}

IOleComponentUIManager * CIPCompFrameHook::GetIOleComponentUIManager()
{
	return &m_xOleCompUIMgr;
}

IOleInPlaceComponentUIManager * CIPCompFrameHook::GetIOleInPlaceComponentUIManager()
{
	return &m_xOleIPCompUIMgr;
}

BOOL CIPCompFrameHook::OnCompCmdMsg(GUID *pguid, DWORD cmdid, DWORD rgf,
		int nCode, void* pExtra)
{
	BOOL fHandled = FALSE;

	// The in-place component spec describes how commands are to be
	// routed.	Commands are divided into two categories, Active Object
	// commands and Container commands.  In addition, the main hardwired
	// component can request that Active Object commands be routed as
	// Container commands by returning the OLECOMPFLAG_ROUTEACTIVEASCNTRCMD
	// from IOleInPlaceComponent::UseComponentUIManager in the pgrf
	// parameter.
	//
	// This gives three possibilities for routing:
	//
	// 1. Active Object command:
	//		Active component control (if any)
	//		shell
	//		main hardwired component
	//		shell
	//
	// 2. Container command:
	//		shell
	//		main hardwired component
	//		shell
	//
	// 3. Active Object command routed as Container command:
	//		shell
	//		main hardwired component
	//		active object
	//		shell
	//
	// Normally, the shell does not take advantage of its first
	// opportunity to handle a command.  However, if the command
	// is marked with the OLECMDROUTEFLAG_SHELLFIRST flag, then the
	// shell does exploit this opportunity.
	//
	// Merged together, these give the following sequence:
	//
	//		Active component control (if neither container command
	//			nor routed as container command)
	//		Shell (if shell-first container command)
	//		Main hardwired component
	//		Active component control (if active object command
	//			routed as container command)
	//		Shell (if not shell-first container command)
	//
	// The Shell responsibilities are handled by the view; this
	// object is only responsible for communication with the component.
	//
	// Note that while we are displaying a context menu associated
	// with a top-level component, commands are not routed to the
	// main in-place component.
	//
	if (nCode == CN_COMMAND)
	{
		// Execute the command.
		//
		//$CONSIDER -- we don't want to route commands if the
		// main component is not active.  However, in that
		// case, we should not have any command targets, so
		// it's only an optimization.
		//
		if (m_srpMainComp != NULL)
		{
			// Note that the first and third clauses below are
			// mutually exclusive.
			//
			if (!(rgf & OLECMDROUTEFLAG_CONTAINER) &&
				!(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD) &&
				m_srpActiveCmdTrgt != NULL)
			{
				fHandled = ExecCmd(m_srpActiveCmdTrgt, pguid, cmdid);
			}

			if (!m_fTopLevelContext && !fHandled && m_srpMainCmdTrgt != NULL)
			{
				fHandled = ExecCmd(m_srpMainCmdTrgt, pguid, cmdid);
			}

			if (!fHandled &&
				!(rgf & OLECMDROUTEFLAG_CONTAINER) &&
				(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD) &&
				m_srpActiveCmdTrgt != NULL)
			{
				fHandled = ExecCmd(m_srpActiveCmdTrgt, pguid, cmdid);
			}
		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		// Determine the appropriate state of this command.
		// pExtra is the CCmdUI object.
		//
		ASSERT(pExtra != NULL);
		CCmdUI *pCmdUI = (CCmdUI *)pExtra;

		//$CONSIDER -- we don't want to route commands if the
		// main component is not active.  However, in that
		// case, we should not have any command targets, so
		// it's only an optimization.
		//
		if (m_srpMainComp != NULL)
		{
			// Note that the first and third clauses below are
			// mutually exclusive.
			//
			if (!(rgf & OLECMDROUTEFLAG_CONTAINER) &&
				!(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD) &&
				m_srpActiveCmdTrgt != NULL)
			{
				fHandled = QueryCmdStatus(m_srpActiveCmdTrgt, pguid, cmdid, pCmdUI, rgf);
			}

			if (!m_fTopLevelContext && !fHandled && m_srpMainCmdTrgt != NULL)
			{
				fHandled = QueryCmdStatus(m_srpMainCmdTrgt, pguid, cmdid, pCmdUI, rgf);
			}

			if (!fHandled &&
				!(rgf & OLECMDROUTEFLAG_CONTAINER) &&
				(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD) &&
				m_srpActiveCmdTrgt != NULL)
			{
				fHandled = QueryCmdStatus(m_srpActiveCmdTrgt, pguid, cmdid, pCmdUI, rgf);
			}
		}
	}

	return fHandled;
}

BOOL CIPCompFrameHook::QueryCmdStatus(IMsoCommandTarget *pCmdTrgt,
		GUID *pguid, UINT cmdid, CCmdUI *pCmdUI, DWORD rgf)
{
	//$UNDONE -- numeric constant.
	//
	BYTE rgbCmdTextBuf[sizeof(OLECMDTEXT)+255*sizeof(WCHAR)];
	OLECMDTEXT *pcmdtext = NULL;
	OLECMD msocmd;
	BOOL fIsMenu;

	msocmd.cmdID = (ULONG)cmdid;
	msocmd.cmdf = 0;

	fIsMenu = ::IsMenu(pCmdUI);

	if (fIsMenu)
	{
		// This is a menu item; give the component the
		// opportunity to change its text.
		//
		pcmdtext = (OLECMDTEXT *)((PVOID)rgbCmdTextBuf);
		pcmdtext->cmdtextf = OLECMDTEXTF_NAME;
		pcmdtext->cwActual = 0;
		pcmdtext->cwBuf = 255;
		pcmdtext->rgwz[0] = 0;
	}

	HRESULT hr = pCmdTrgt->QueryStatus(pguid, 1, &msocmd, pcmdtext);
	BOOL fRet = FALSE;

	if (SUCCEEDED(hr) && (msocmd.cmdf & OLECMDF_SUPPORTED))
	{
		// The component recognizes & supports this command.
		// Add a terminating null to the label string.
		//
		if (pcmdtext != NULL)
		{
			pcmdtext->rgwz[pcmdtext->cwActual] = 0;
		}

		pCmdUI->Enable((msocmd.cmdf & OLECMDF_ENABLED) ? TRUE : FALSE);

		if (!(rgf & OLECMDROUTEFLAG_SINGLESTATE))
			pCmdUI->SetCheck((msocmd.cmdf & OLECMDF_LATCHED) ? 1 : 0);

		USES_CONVERSION;
		if (pcmdtext != NULL && pcmdtext->cwActual != 0)
			pCmdUI->SetText(OLE2T(pcmdtext->rgwz));

		// If the command is enabled and the document has requested
		// an opportunity for further command UI processing (indicated
		// by OLECMDROUTEFLAG_PACKAGEUPDATE in the routing flags), give
		// it that opportunity now.
		//
		if ( (rgf & OLECMDROUTEFLAG_PACKAGEUPDATE) &&
			 (msocmd.cmdf & OLECMDF_ENABLED) &&
			 (m_pActiveItem != NULL))
		{
			CIPCompDoc *pDoc;

			ASSERT(m_pActiveItem->IsKindOf(RUNTIME_CLASS(CIPCompContainerItem)));
			pDoc = ((CIPCompContainerItem *)(m_pActiveItem))->GetDocument();

			if (pDoc != NULL)
			{
				pDoc->UpdateIPCToolbarControl(pguid, cmdid, rgf);
			}
		}

		//$CONSIDER -- treating all supported commands as handled
		// prevents a later contributor to the chain from enabling
		// a command.  Is this a good thing or a bad thing?
		//
		fRet = TRUE;
	}

	return fRet;
}

BOOL CIPCompFrameHook::ExecCmd(IMsoCommandTarget *pCmdTrgt, GUID *pguid, UINT cmdid)
{
	HRESULT hr = pCmdTrgt->Exec(pguid, cmdid, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

#ifndef DOCOBJ_CHANGE
	BOOL fRet = (hr == S_OK);
#else
	BOOL fRet = (hr != OLECMDERR_E_NOTSUPPORTED &&
			hr != OLECMDERR_E_UNKNOWNGROUP &&
			hr != E_NOTIMPL);
#endif
	return fRet;
}

IMsoCommandTarget * CIPCompFrameHook::GetSupportingTarget(GUID * pguid, DWORD cmdid, DWORD rgf)
{
	OLECMD msocmd;
	IMsoCommandTarget *pCmdTrgt = NULL;
	HRESULT hr;

	msocmd.cmdID = (ULONG)cmdid;
	msocmd.cmdf = 0;

	if (!(rgf & OLECMDROUTEFLAG_CONTAINER) &&
		!(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD) &&
		m_srpActiveCmdTrgt != NULL)
	{
		hr = m_srpActiveCmdTrgt->QueryStatus(pguid, 1, &msocmd, NULL);
		if (SUCCEEDED(hr) &&
			(msocmd.cmdf & OLECMDF_SUPPORTED) &&
			(msocmd.cmdf & OLECMDF_ENABLED))
		{
			pCmdTrgt = m_srpActiveCmdTrgt;
		}
	}

	if (pCmdTrgt == NULL && m_srpMainCmdTrgt != NULL)
	{
		hr = m_srpMainCmdTrgt->QueryStatus(pguid, 1, &msocmd, NULL);
		if (SUCCEEDED(hr) &&
			(msocmd.cmdf & OLECMDF_SUPPORTED) &&
			(msocmd.cmdf & OLECMDF_ENABLED))
		{
			pCmdTrgt = m_srpMainCmdTrgt;
		}
	}

	if (pCmdTrgt == NULL &&
		!(rgf & OLECMDROUTEFLAG_CONTAINER) &&
		(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD) &&
		m_srpActiveCmdTrgt != NULL)
	{
		hr = m_srpActiveCmdTrgt->QueryStatus(pguid, 1, &msocmd, NULL);
		if (SUCCEEDED(hr) &&
			(msocmd.cmdf & OLECMDF_SUPPORTED) &&
			(msocmd.cmdf & OLECMDF_ENABLED))
		{
			pCmdTrgt = m_srpActiveCmdTrgt;
		}
	}

	// Note that this is not an add-ref'd pointer.
	//
	return pCmdTrgt;
}

void CIPCompFrameHook::SetIPCComboEditText(CComboBox * pcombo,
		GUID * pguid, DWORD cmdid, DWORD rgf)
{
	// First, determine whether to ask the main component or
	// the active control.
	//
	IMsoCommandTarget *pCmdTrgt = GetSupportingTarget(pguid, cmdid, rgf);

	if (pCmdTrgt == NULL)
	{
		// Nobody is willing to update this command.
		//
		return;
	}

	if (CMDSETID_StandardCommandSet97 == *pguid)
	{
		switch (cmdid)
		{
			case cmdidZoomPercent:
			{
				// Ask the component for the current zoom value.
				//
				HRESULT hr;
				VARIANT var;
				::VariantInit(&var);
				V_VT(&var) = VT_I4;

				CString strZoom, strCur;
				hr = pCmdTrgt->Exec(pguid,
									cmdid,
									OLECMDEXECOPT_DODEFAULT,
									NULL,
									&var);

				if (SUCCEEDED(hr) &&
					V_VT(&var) == VT_I4 &&
					V_I4(&var) > 0)
				{
					strZoom.Format(TEXT("%d%%"), V_I4(&var));
				}

				::VariantClear(&var);

				pcombo->GetWindowText(strCur);

				if (strCur != strZoom)
					pcombo->SetWindowText(strZoom);

			}
			return;

			case cmdidFontName:
			{
				// Ask the component for the current font name
				//
				HRESULT hr;
				VARIANT var;
				::VariantInit(&var);
				V_VT(&var) = VT_BSTR;

				CString strItem, strCur;
				hr = pCmdTrgt->Exec(pguid,
									cmdid,
									OLECMDEXECOPT_DODEFAULT,
									NULL,
									&var);
				if(SUCCEEDED(hr) && V_VT(&var) == VT_BSTR && V_BSTR(&var) != NULL)
				{
					strItem = V_BSTR(&var);
					::SysFreeString(V_BSTR(&var));
				}

				::VariantClear(&var);

				// Setting an empty Item empties the combo
				if(!strItem.IsEmpty())
				{
					pcombo->GetWindowText(strCur);
					// Only change text if Font Name differs from current selection.
					if(strCur != strItem)
						pcombo->SetWindowText(strItem);
				}
			}
			return;

			case cmdidFontSize:
			{
				// Ask the component for the current font size
				//
				HRESULT hr;
				VARIANT var;
				::VariantInit(&var);
				V_VT(&var) = VT_I4;

				CString strItem, strCur;
				hr = pCmdTrgt->Exec(pguid,
									cmdid,
									OLECMDEXECOPT_DODEFAULT,
									NULL,
									&var);
				if(SUCCEEDED(hr) && V_VT(&var) == VT_I4)
				{
					strItem.Format(_T("%d"), V_I4(&var));
				}

				::VariantClear(&var);

				// Setting an empty Item empties the combo
				if(!strItem.IsEmpty())
				{
					pcombo->GetWindowText(strCur);
					// Only change text if Font Name differs from current selection.
					if(strCur != strItem)
						pcombo->SetWindowText(strItem);
				}
			}
			return;

			default:
				// Unrecognized.
				break;
		}
	}
}

void CIPCompFrameHook::FillZoomCombo(CComboBox * pcombo, IMsoCommandTarget *pCmdTrgt)
{
	CString str;
	VARIANT var;
	HRESULT hr;
	long i, iLow, iHigh;
	int cCur;
	UINT sid;

	::VariantInit(&var);
	V_VT(&var) = VT_ARRAY | VT_I4;

	hr = pCmdTrgt->Exec(&CMDSETID_StandardCommandSet97,
						cmdidGetZoom,
						OLECMDEXECOPT_DODEFAULT,
						NULL,
						&var);

	if (SUCCEEDED(hr) && V_VT(&var) == (VT_ARRAY | VT_I4))
	{
		SafeArrayGetLBound(V_ARRAY(&var), 1, &iLow);
		SafeArrayGetUBound(V_ARRAY(&var), 1, &iHigh);
		HRESULT hr2 = NOERROR;

		for (i = iLow; i <= iHigh && SUCCEEDED(hr2); i++)
		{
			hr2 = SafeArrayGetElement(V_ARRAY(&var), &i, &cCur);
			if (FAILED(hr2))
				break;

			if (cCur >= 0)
			{
				str.Format(TEXT("%d%%"), cCur);
			}
			else
			{
				// This is a special string.  Fetch it as a resource.
				//
				switch(cCur)
				{
				case CMD_ZOOM_PAGEWIDTH:
					sid = IDS_ZOOM_PAGE_WIDTH;
					break;
				case CMD_ZOOM_ONEPAGE:
					sid = IDS_ZOOM_ONE_PAGE;
					break;
				case CMD_ZOOM_TWOPAGES:
					sid = IDS_ZOOM_TWO_PAGES;
					break;
				case CMD_ZOOM_SELECTION:
					sid = IDS_ZOOM_SELECTION;
					break;
				case CMD_ZOOM_FIT:
					sid = IDS_ZOOM_FIT;
					break;
				default:
					// Unrecognized negative number--skip this one.
					//
					continue;
				}

				str.Format(sid);
			}

			pcombo->SetItemData(pcombo->AddString(str), cCur);
		}
	}

	if (SUCCEEDED(hr))
	{
		::VariantClear(&var);
	}
}

int CALLBACK EnumFontNamesCallBack
(
	const ENUMLOGFONT*		pEnumLogFont,
	const NEWTEXTMETRIC*	pTextMetric,
	int						fontType,
	LPARAM					lParam
) 
{
	ASSERT(pEnumLogFont != NULL);
	ASSERT(pTextMetric != NULL);
	ASSERT(lParam != NULL);

	// ComboBox in lParam
	CComboBox* pComboBox = (CComboBox*)lParam;

	// Add the font name to Combo Box
	ASSERT(pEnumLogFont->elfLogFont.lfFaceName != NULL);

	int iRet = pComboBox->AddString(pEnumLogFont->elfLogFont.lfFaceName);
	ASSERT(iRet >= 0);

	// returns TRUE if String added successfully, FALSE otherwise
	return (iRet >= 0);
}


// Gets the list of Fonts and populates the list
void CIPCompFrameHook::FillFontNameCombo(CComboBox* pComboBox, IMsoCommandTarget *pCmdTrgt)
{
	ASSERT(pComboBox != NULL);
	ASSERT(pCmdTrgt != NULL);

	// REVIEW(cgomes): Should I check if the combo box has already been filled?
	// I could just remove all items.  Fonts could be added while the combo is up!!!!
	// Skip this step if Fonts already in ComboBox
	int nFontNames = pComboBox->GetCount();
	ASSERT(nFontNames != CB_ERR);
	if(nFontNames == CB_ERR || nFontNames > 0)
		return;

	// Get DC for EnumFontFamiliess
	CWnd* pWnd = ::AfxGetMainWnd();
	ASSERT(pWnd != NULL);
	ASSERT_KINDOF(CWnd, pWnd);

	CDC* pDC = pWnd->GetDC();
	ASSERT(pDC != NULL);
	ASSERT(pDC->m_hDC);

	// Enum Fonts via Call Back
	// The Call Back will add the Fonts to the ComboBox
	VERIFY(EnumFontFamilies(pDC->m_hDC, NULL, (FONTENUMPROC)EnumFontNamesCallBack, 
							(LPARAM)pComboBox));

	pWnd->ReleaseDC(pDC);
}

// HACK! EnumFontSizesCallBack needs this
static int s_nPixPerInchY;

int CALLBACK EnumFontSizesCallBack
(
	const ENUMLOGFONT*		pEnumLogFont,
	const NEWTEXTMETRIC*	pTextMetric,
	int						fontType,
	LPARAM					lParam
) 
{
	if (fontType & TRUETYPE_FONTTYPE) 
		return TRUETYPE_FONTTYPE;
	else
	{
		UINT nCharSet = theApp.GetCharSet();
		if ((nCharSet == DEFAULT_CHARSET || nCharSet == pTextMetric->tmCharSet || pTextMetric->tmCharSet == OEM_CHARSET))
		{
			// ComboBox in lParam
			CComboBox* pComboBox = (CComboBox*)lParam;

			CString strItem;
			strItem.Format(_T("%d"), MulDiv(pTextMetric->tmHeight - pTextMetric->tmInternalLeading,72,s_nPixPerInchY));
			pComboBox->AddString(strItem);
		}
		return RASTER_FONTTYPE;
	}
}

// True Type Font sizes
static DWORD s_rgTTSizes[] = { 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72 };

// Gets the Current Font, then Enumerates size for that font
void CIPCompFrameHook::FillFontSizeCombo(CComboBox* pComboBox, LPCTSTR pszFontName)
{
	ASSERT(pComboBox != NULL);
	ASSERT(pszFontName != NULL);

	// REVIEW(cgomes): Should I check if the combo box has already been filled?
	// I could just remove all items.  Fonts could be added while the combo is up!!!!
	// Skip this step if Fonts already in ComboBox
	int nFontSizes = pComboBox->GetCount();
	ASSERT(nFontSizes != CB_ERR);
	if(nFontSizes == CB_ERR || nFontSizes > 0)
		return;

	// Get DC for EnumFontFamiliess
	CWnd* pWnd = ::AfxGetMainWnd();
	ASSERT(pWnd != NULL);
	ASSERT_KINDOF(CWnd, pWnd);

	CDC* pDC = pWnd->GetDC();
	ASSERT(pDC != NULL);
	ASSERT(pDC->m_hDC);

	// Set s_nPixPerInchY for EnumFontSizesCallBack
	s_nPixPerInchY = pDC->GetDeviceCaps(LOGPIXELSY);

	// Enum Font Sizes via Call Back
	// If the Font is not a TrueType font then 
	//		the Call Back will add the Sizes to the ComboBox
	int nType = EnumFontFamilies(pDC->m_hDC, pszFontName, 
							(FONTENUMPROC)EnumFontSizesCallBack, (LPARAM)pComboBox);
	if(nType == TRUETYPE_FONTTYPE)
	{
		CString strItem;
		for (int i = 0; i < sizeof(s_rgTTSizes) / sizeof (s_rgTTSizes[0]); i++)
		{
			strItem.Format(_T("%d"), s_rgTTSizes[i]);
			pComboBox->AddString(strItem);
		}
	}
	pWnd->ReleaseDC(pDC);
}

void CIPCompFrameHook::FillIPCCombo(CComboBox * pcombo, GUID * pguid,
		DWORD cmdid, DWORD rgf)
{
	// Extract the current value, so we can set the current selection.
	//
	CString strCur;
	pcombo->GetWindowText(strCur);

	// Clean out the old strings.  Note that ResetContent would
	// also clear the edit box, which we don't want.
	//
	while (pcombo->DeleteString(0) != CB_ERR);

	// First, determine whether to ask the main component or
	// the active control.
	//
	IMsoCommandTarget *pCmdTrgt = GetSupportingTarget(pguid, cmdid, rgf);

	if (pCmdTrgt == NULL)
	{
		// Nobody is willing to update this command.
		//
		return;
	}

	if (CMDSETID_StandardCommandSet97 == *pguid)
	{
		if(cmdid == cmdidZoomPercent)
		{
			// Zoom has special semantics.
			//
			FillZoomCombo(pcombo, pCmdTrgt);
		}
		else if(cmdid == cmdidFontName)
		{
			FillFontNameCombo(pcombo, pCmdTrgt);
		}
		else if(cmdid == cmdidFontSize)
		{
			// Ask the component for the current font name
			//
			HRESULT hr;
			VARIANT var;
			::VariantInit(&var);
			V_VT(&var) = VT_BSTR;

			hr = pCmdTrgt->Exec(pguid, cmdidFontName, OLECMDEXECOPT_DODEFAULT,
								NULL, &var);
			if(SUCCEEDED(hr) && V_VT(&var) == VT_BSTR && V_BSTR(&var) != NULL)
			{
				USES_CONVERSION;
				// Fill Font Size using current font name
				FillFontSizeCombo(pcombo, OLE2T(V_BSTR(&var)));
				::SysFreeString(V_BSTR(&var));
			}
			::VariantClear(&var);
		}
		else
		// Unrecognized.
		//
		//$CONSIDER -- we could support the standard contract here
		//(call Exec to retrieve the list of strings that go into
		// the combo box).
		return;
	} 
	else 
	{

		// Unrecognized.
		//
		//$CONSIDER -- we could support the standard contract here
		//(call Exec to retrieve the list of strings that go into
		// the combo box).
		return;
	}

	// We've filled the list box; now set the initial selection.
	//
	int i = pcombo->FindStringExact(-1, strCur);

	if (i != CB_ERR)
	{
		pcombo->SetCurSel(i);
	}

}

void CIPCompFrameHook::OnIPCComboSelect(CComboBox * pcombo, GUID * pguid,
		DWORD cmdid, DWORD rgf)
{
	// The user selected an item from the combo box's list.

	// First, determine whether to ask the main component or
	// the active control.
	//
	IMsoCommandTarget *pCmdTrgt = GetSupportingTarget(pguid, cmdid, rgf);

	if (pCmdTrgt == NULL)
	{
		// Nobody is willing to update this command.
		//
		return;
	}

	if (pguid == NULL)
	{
		// Not supported.
		return;
	}

	CString strCur;
	VARIANT varNew, varResult;
	::VariantInit(&varNew);
	::VariantInit(&varResult);

	if (CMDSETID_StandardCommandSet97 == *pguid)
	{
		switch (cmdid)
		{
		case cmdidZoomPercent:
			{
				HRESULT hr;

				//$CONSIDER -- common worker for this function
				// and OnIPCComboEnter?

				V_VT(&varNew) = VT_I4;
				V_I4(&varNew) = pcombo->GetItemData(pcombo->GetCurSel());

				hr = pCmdTrgt->Exec(pguid,
									cmdid,
									OLECMDEXECOPT_DODEFAULT,
									&varNew,
									&varResult);

				//$CONSIDER -- use varResult to update the edit box.
				//Can we count on all commands updating the same way,
				//and eliminate the call to UpdateIPCToolbarControl
				//from the CBN_SELENDOK handler?
			}

			break;

		case cmdidFontSize:

			// Since the shell didn't fill this combo box, it can't
			// rely on item data and has to use strings.
			//
			pcombo->GetLBText(pcombo->GetCurSel(), strCur);

			if (!strCur.IsEmpty())
			{
				float fp;
				int cch;
				const int cTwipsPerPoint = 20;

				sscanf((LPCSTR)strCur, TEXT("%f%n"), &fp, &cch);
				if (cch != strCur.GetLength())
				{
					// Let the component display the error.
					fp = (float)(0.0);
				}

				int cTwips = (int)(fp * cTwipsPerPoint + 0.5);

				V_VT(&varNew) = VT_I4;
				V_I4(&varNew) = cTwips;

				HRESULT hr = pCmdTrgt->Exec(pguid,
											cmdid,
											OLECMDEXECOPT_DODEFAULT,
											&varNew,
											&varResult);

				//$CONSIDER -- update the edit box with the result.
			}

			break;

		case cmdidFontName:
			// Since the shell didn't fill this combo box, it can't
			// rely on item data and has to use strings.
			//
			pcombo->GetLBText(pcombo->GetCurSel(), strCur);
			if(!strCur.IsEmpty())
			{
				V_VT(&varNew)		= VT_BSTR;
				V_BSTR(&varNew)		= strCur.AllocSysString();
				V_VT(&varResult)	= VT_BSTR;

				HRESULT hr = pCmdTrgt->Exec(pguid,
											cmdid,
											OLECMDEXECOPT_DODEFAULT,
											&varNew,
											&varResult);
				if(SUCCEEDED(hr) && V_VT(&varResult)==VT_BSTR && 
					V_BSTR(&varResult) != NULL)
				{
					// REVIEW(cgomes): what to do with result???
					::SysFreeString(V_BSTR(&varResult));
				}

			}
			break;

		default:
			// Drop through into standard contract.
			//
			break;
		}
	}

	// Cleanup
	::VariantClear(&varNew);
	::VariantClear(&varResult);
}

void CIPCompFrameHook::OnIPCComboEnter(CComboBox * pcombo, GUID * pguid,
		DWORD cmdid, DWORD rgf)
{
	// The user pressed Enter in a combo box; take the contents of
	// the edit control as the new value.

	// First, determine whether to ask the main component or
	// the active control.
	//
	IMsoCommandTarget *pCmdTrgt = GetSupportingTarget(pguid, cmdid, rgf);

	if (pCmdTrgt == NULL)
	{
		// Nobody is willing to update this command.
		//
		return;
	}

	CString strCur;
	VARIANT varNew, varResult;
	::VariantInit(&varNew);
	::VariantInit(&varResult);

	if (CMDSETID_StandardCommandSet97 == *pguid)
	{
		switch (cmdid)
		{
		case cmdidZoomPercent:
			{
				int cZoom;

				// If the user selected a string that is in the
				// list, then we can just use the corresponding
				// value.  Otherwise we have to fetch a number
				// from the string.
				//
				pcombo->GetWindowText(strCur);
				int i = pcombo->FindStringExact(-1, strCur);

				if (i != CB_ERR)
				{
					cZoom = pcombo->GetItemData(i);

				} else {

					int cch = 0;
					float fp;

					sscanf((LPCSTR)strCur, TEXT("%f%n"), &fp, &cch);

					if (cch != strCur.GetLength())
					{
						sscanf((LPCSTR)strCur, TEXT("%f%%%n"), &fp, &cch);
						if (cch != strCur.GetLength())
						{
							// Get the component to display the error
							// for us.
							fp = (float)(0.0);
						}
					}

					cZoom = (int)(fp + 0.5);
				}

				V_VT(&varNew) = VT_I4;
				V_I4(&varNew) = cZoom;

				pCmdTrgt->Exec(pguid,
								cmdid,
								OLECMDEXECOPT_DODEFAULT,
								&varNew,
								&varResult);

				//$CONSIDER -- use varResult to update the edit box.
				//Can we count on all commands updating the same way,
				//and eliminate the call to UpdateIPCToolbarControl
				//from the CBN_SELENDOK handler?
			}

			break;

		case cmdidFontSize:
			// Since the shell didn't fill this combo box, it can't
			// rely on item data and has to use strings.
			//
			pcombo->GetWindowText(strCur);
			if (strCur.GetLength() != 0)
			{
				float fp;
				int cch;
				const int cTwipsPerPoint = 20;

				sscanf((LPCSTR)strCur, TEXT("%f%n"), &fp, &cch);
				if (cch != strCur.GetLength())
				{
					// Let the component display the error.
					fp = (float)(0.0);
				}

				int cTwips = (int)(fp * cTwipsPerPoint + 0.5);

				V_VT(&varNew) = VT_I4;
				V_I4(&varNew) = cTwips;

				pCmdTrgt->Exec(pguid,
								cmdid,
								OLECMDEXECOPT_DODEFAULT,
								&varNew,
								&varResult);

				//$CONSIDER -- update the edit box with the result.
			}

			break;

		case cmdidFontName:
			// Since the shell didn't fill this combo box, it can't
			// rely on item data and has to use strings.
			//
			pcombo->GetLBText(pcombo->GetCurSel(), strCur);
			if(!strCur.IsEmpty())
			{
				V_VT(&varNew)		= VT_BSTR;
				V_BSTR(&varNew)		= strCur.AllocSysString();
				V_VT(&varResult)	= VT_BSTR;

				HRESULT hr = pCmdTrgt->Exec(pguid,
											cmdid,
											OLECMDEXECOPT_DODEFAULT,
											&varNew,
											&varResult);
				if(SUCCEEDED(hr) && V_VT(&varResult)==VT_BSTR && 
					V_BSTR(&varResult) != NULL)
				{
					// REVIEW(cgomes): what to do with result???
					::SysFreeString(V_BSTR(&varResult));
				}

			}
			break;


		default:
			// Unrecognized.
			break;
		}
	}
	::VariantClear(&varNew);
	::VariantClear(&varResult);
}


/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleComponentUIManager

HRESULT CIPCompFrameHook::XOleCompUIMgr::GetPredefinedStrings(DISPID dispid,
						CALPOLESTR *pcaStringsOut, CADWORD *pcaCookiesOut)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	return E_NOTIMPL;
}

HRESULT CIPCompFrameHook::XOleCompUIMgr::GetPredefinedValue(DISPID dispid,
						DWORD dwCookie,	VARIANT *pvarOut)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	return E_NOTIMPL;
}

void CIPCompFrameHook::XOleCompUIMgr::OnUIEvent(DWORD dwCompRole,
						REFCLSID rclsidComp, const GUID *pguidUIEventGroup,
						DWORD nUIEventId, DWORD dwUIEventStatus,
						DWORD dwEventFreq, RECT *prcEventRegion,
						VARIANT *pvarEventArg)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	return;
}

HRESULT CIPCompFrameHook::XOleCompUIMgr::OnUIEventProgress(DWORD *pdwCookie,
						BOOL fInProgress, LPOLESTR pwszLabel, ULONG nComplete,
						ULONG nTotal)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	return E_NOTIMPL;
}

HRESULT CIPCompFrameHook::XOleCompUIMgr::SetStatus(LPCOLESTR pwszStatusText,
						DWORD dwReserved)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	return pThis->m_xOleInPlaceFrame.SetStatusText(pwszStatusText);
}

#if 0
// Had to pull this out b/c Forms Opens an Undo Record on the RBUTTONDOWN 
// that initiates the context menu.  This has the affect of causing the 
// Undo command to fail b/c there is an open undo record.
//
//	Description:
//		On return from this function the active IMsoCommandTarget will get reset.  
//		By default TrackPopupMenu will use PostMessage to route the selected 
//		command.  By the time the command gets handled the IMsoCommandTarget has
//		already been reset.  To fix this we need to ensure that the command gets
//		handled before the IMsoCommandTarget is reset.  Using the TPM_RETURNCMD
//		flag we can get the selected command.  Then use SendMessage to route the
//		command immediately.  Since SendMessage is synchronous IMsoCommandTarget
//		will not be reset before the command is handled.
//
static void DoContextPopupMenu(POPDESC* ppop, CPoint pt)
{
	CMainFrame* pWndCommand = (CMainFrame*) AfxGetMainWnd();
	ASSERT_VALID(pWndCommand);

	CBContextPopupMenu menuPopup;
	menuPopup.Create(ppop);

	// Call TrackPopup with the TPM_RETURNCMD to return the command. 
	int iCmdID = menuPopup.TrackPopup(TPM_LEFTALIGN | TPM_RIGHTBUTTON | 
									TPM_RETURNCMD, pt.x, pt.y, pWndCommand);

	// Use SendMessage to immediately route the command
	if(iCmdID != FALSE)
		// Send message
		::AfxGetMainWnd()->SendMessage(WM_COMMAND, iCmdID);
}
#endif
HRESULT CIPCompFrameHook::XOleCompUIMgr::ShowContextMenu(DWORD dwCompRole,
						REFCLSID rclsidActive, LONG nMenuId, POINTS &pos,
						IMsoCommandTarget *pCmdTrgtActive)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	// Before the context menu takes over, make sure the appropriate
	// command bars are visible.
	//
	if (theApp.m_bMenuDirty)
	{		
		DkUpdateAvailableWnds(TRUE);
	}

	CIPCompDoc *pDoc = NULL;

	if (pThis->m_pActiveItem != NULL)
	{
		ASSERT(pThis->m_pActiveItem->IsKindOf(RUNTIME_CLASS(CIPCompContainerItem)));
		pDoc = ((CIPCompContainerItem *)(pThis->m_pActiveItem))->GetDocument();
	}

	if (pThis->m_srpMainComp == NULL || pDoc == NULL)
		return E_UNEXPECTED;

	HRESULT hr = S_OK;
	
	// While the context menu is being processed, the command target
	// supplied as a parameter to this method is used in place of
	// the active object's command target.  Remember the current
	// active command target, so we can restore it later.
	// Note that the temporary holder for the command target is
	// _not_ a smart reference, because we will restore it before
	// we return.  (And we never throw out of this function.)
	//
	//
	IMsoCommandTarget * pOldCmdTrgt = pThis->m_srpActiveCmdTrgt.Disown();

	// If the component displaying the context menu is a top level
	// component, set a flag which inhibits routing commands to the
	// main in-place component.
	//
	if (dwCompRole == OLEROLE_TOPLEVELCOMPONENT)
	{
		pThis->m_fTopLevelContext = TRUE;
	}

	pThis->m_srpActiveCmdTrgt = pCmdTrgtActive;
	ASSERT(pCmdTrgtActive != NULL);
	pThis->m_srpActiveCmdTrgt->AddRef();

	POPDESC *ppopCntr = NULL;
	POPDESC *ppopActive = NULL;
	
	if (dwCompRole == OLEROLE_MAINCOMPONENT)
		{
		// Context menus from the main component never need to be merged.
		//
		ppopCntr = pDoc->PopupDescFromGuidId(rclsidActive, nMenuId);
		}
	else
		{
		CLSID clsidCntr = CLSID_NULL;
		OLEMENUID menuidCntr = {0, 0, NULL};
		DWORD rgf = 0;

		hr = pThis->m_srpMainComp->GetCntrContextMenu(dwCompRole, rclsidActive,
						nMenuId, pos, &clsidCntr, &menuidCntr, &rgf);

		// Note that the main component will return S_FALSE to
		// prevent any menu from being displayed.

		if (SUCCEEDED(hr) && hr != S_FALSE)
			{
			//$UNDONE - context menus can be specified by name
			// (indicated by -1 for menuidCntr.nMenuId).
			//
			ASSERT(menuidCntr.nMenuId != -1);

			if (rgf & OLEMENU_MENUMERGE)
				{
				// The main component has requested that we merge
				// the active component's context menu into the
				// main component's menu.
				//
				ppopCntr = pDoc->PopupDescFromGuidId(clsidCntr, menuidCntr.nMenuId);
				ppopActive = pDoc->PopupDescFromGuidId(rclsidActive, nMenuId);
				}
			else if (rgf & OLEMENU_CNTRMENUONLY)
				{
				// The main component wants to suppress the active
				// component control's context menu in favor of its own.
				//
				ppopCntr = pDoc->PopupDescFromGuidId(clsidCntr, menuidCntr.nMenuId);
				}
			else if (rgf & OLEMENU_OBJECTMENUONLY)
				{
				// The main component doesn't have anything to contribute;
				// just display the active component control's context menu.
				//
				ppopActive = pDoc->PopupDescFromGuidId(rclsidActive, nMenuId);
				}
			}
		}

	CPoint pt(pos.x, pos.y);

	if (ppopCntr == NULL && ppopActive == NULL)
	{
		hr = E_UNEXPECTED;
	}else if (ppopCntr == NULL)
	{
		//DoContextPopupMenu(ppopActive, pt);
		//::ShowContextPopupMenu(ppopActive, pt);
		::CBShowContextPopupMenu(ppopActive, pt);
		
	}else if (ppopActive == NULL)
	{
		//DoContextPopupMenu(ppopCntr, pt);
		//::ShowContextPopupMenu(ppopCntr, pt);
		::CBShowContextPopupMenu(ppopCntr, pt);
	}else
	{
		//$UNDONE -- Need to merge--I'm not ready to deal with this yet.
		//
		ASSERT(FALSE);
	}
#if 0
	// restore the active object command target and reset the
	// top-level-context-menu flag.
	//
	pThis->m_srpActiveCmdTrgt.SRelease();
	pThis->m_srpActiveCmdTrgt = pOldCmdTrgt;
#else
	// Defer resetting the ActiveCmdTrgt since the context menu command
	// is routed with a PostMessage.  
	// CmdTrgt will be reset when the view recieves a WM_RESETCOMMANDTARGET
	// The view will then call CIPCompFrameHook->ResetCommandTarget();
	// m_srpPreContextMenuCmdTrgt holds pOldCmdTrgt
	// UIActivateForMe can block the resetting of the CommandTarget.
	CView* pView = pThis->m_pDocFrameWnd->GetActiveView();
	ASSERT(NULL != pView);
	ASSERT(pThis->m_srpPreContextMenuCmdTrgt == NULL);
	pThis->m_srpPreContextMenuCmdTrgt = pOldCmdTrgt;
	pView->PostMessage(WM_RESETCOMMANDTARGET, 0, 0);
#endif

	pThis->m_fTopLevelContext = FALSE;

	return hr;
}

HRESULT CIPCompFrameHook::XOleCompUIMgr::ShowHelp(DWORD dwCompRole,
						REFCLSID rclsidComp,
						POINT posMouse, DWORD dwHelpCmd,
						LPOLESTR pwszHelpFile, DWORD dwData)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)

	CIPCompDoc *pDoc = NULL;

	if (pThis->m_pActiveItem != NULL)
	{
		ASSERT(pThis->m_pActiveItem->IsKindOf(RUNTIME_CLASS(CIPCompContainerItem)));
		pDoc = ((CIPCompContainerItem *)(pThis->m_pActiveItem))->GetDocument();
	}

	if (pThis->m_srpMainComp == NULL || pDoc == NULL)
		return E_UNEXPECTED;

	COleStrPtr srpwszNewHelpFile;
	CLSID clsid = rclsidComp;
	DWORD dwNewData = dwData;
	HRESULT hr = S_OK;

	// need to call main component's GetCntrHelp() method to see if the
	// main component want to override anything about the help.
	if (dwCompRole != OLEROLE_MAINCOMPONENT	&& dwCompRole != OLEROLE_COMPONENTHOST)
	{
		hr = pThis->m_srpMainComp->GetCntrHelp(&dwCompRole, &clsid,
					posMouse, dwHelpCmd, pwszHelpFile, &srpwszNewHelpFile,
					dwData, &dwNewData);

		// Note that the main component will return S_FALSE to
		// prevent any message from being displayed.

		//$CONSIDER -- if GetCntrMessage returns an error, should we
		// proceed and show the active object's message, or what?
		//
		if(hr == S_FALSE)
		{
			ASSERT(srpwszNewHelpFile == NULL);
			return S_FALSE;		// message suppressed by the MainComponent
		}
		else if (FAILED(hr))
		{
			return hr;
		} else {
			// check if MainComponent overrode the help file name or the data.
			if (srpwszNewHelpFile != NULL)
				pwszHelpFile = srpwszNewHelpFile;
			if (dwNewData != dwData)
				dwData = dwNewData;
		}
	}

	return pDoc->ShowIPCHelp(dwCompRole, rclsidComp, posMouse, dwHelpCmd, pwszHelpFile, dwData);
}

HRESULT CIPCompFrameHook::XOleCompUIMgr::ShowMessage(DWORD dwCompRole,
						REFCLSID rclsidComp, LPOLESTR pwszTitle, LPOLESTR pwszText,
						LPOLESTR pwszHelpFile, DWORD dwHelpContextID,
						OLEMSGBUTTON msgbtn, OLEMSGDEFBUTTON msgdefbtn,
						OLEMSGICON msgicon, BOOL fSysAlert, LONG *pnResult)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleCompUIMgr)
	USES_CONVERSION;

	*pnResult = 0;
	ASSERT(pThis->m_srpMainComp != NULL);
	
	COleStrPtr srpwszNewTitle;
	COleStrPtr srpwszNewText;
	COleStrPtr srpwszNewHelpFile;
	CLSID clsid = rclsidComp;
	HRESULT hr = S_OK;

	// need to call main component's GetCntrMessage() method to see if the
	// main component want to override anything about the message.
	if (dwCompRole != OLEROLE_MAINCOMPONENT	&& dwCompRole != OLEROLE_COMPONENTHOST)
	{
		hr = pThis->m_srpMainComp->GetCntrMessage(&dwCompRole, &clsid,
					pwszTitle, pwszText, pwszHelpFile,
					&srpwszNewTitle, &srpwszNewText, &srpwszNewHelpFile,
					&dwHelpContextID, &msgbtn, &msgdefbtn, &msgicon,
					&fSysAlert);

		// Note that the main component will return S_FALSE to
		// prevent any message from being displayed.

		//$CONSIDER -- if GetCntrMessage returns an error, should we
		// proceed and show the active object's message, or what?
		//
		if(hr == S_FALSE)
		{
			ASSERT(srpwszNewTitle == NULL);
			ASSERT(srpwszNewText == NULL);
			ASSERT(srpwszNewHelpFile == NULL);
			return S_FALSE;		// message suppressed by the MainComponent
		}
		else
		{
			// check if MainComponent overrode any of the strings.
			if (srpwszNewTitle != NULL)
				pwszTitle = srpwszNewTitle;
			if (srpwszNewText != NULL)
				pwszText = srpwszNewText;
			if (srpwszNewHelpFile != NULL)
				pwszHelpFile = srpwszNewHelpFile;
		}
	}

	// need to translate our OLEMSGBTN to MB_xxx, and do W2A (OLESTR2TCHAR - see ScotG if this function
	// is not there), then call theApp.DoMessageBox
	// buttons:
	//
	UINT dwStyle = 0;
	const UINT cchMsgMax = 2000;
	TCHAR szPrompt[cchMsgMax];

	switch (msgbtn)
	{
	case OLEMSGBUTTON_OK:
		dwStyle = MB_OK;
		break;
	case OLEMSGBUTTON_OKCANCEL:
		dwStyle = MB_OKCANCEL;
		break;
	case OLEMSGBUTTON_ABORTRETRYIGNORE:
		dwStyle = MB_ABORTRETRYIGNORE;
		break;
	case OLEMSGBUTTON_YESNOCANCEL:
		dwStyle = MB_YESNOCANCEL;
		break;
	case OLEMSGBUTTON_YESNO:
		dwStyle = MB_YESNO;
		break;
	case OLEMSGBUTTON_RETRYCANCEL:
		dwStyle = MB_RETRYCANCEL;
		break;
	case OLEMSGBUTTON_YESALLNOCANCEL:
		ASSERT(FALSE);
		dwStyle = MB_YESNOCANCEL;
		break;
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	switch (msgdefbtn)
	{
	case OLEMSGDEFBUTTON_FIRST:
		dwStyle |= MB_DEFBUTTON1;
		break;
	case OLEMSGDEFBUTTON_SECOND:
		dwStyle |= MB_DEFBUTTON2;
		break;
	case OLEMSGDEFBUTTON_THIRD:
		dwStyle |= MB_DEFBUTTON3;
		break;
	case OLEMSGDEFBUTTON_FOURTH:
		ASSERT(FALSE);
		dwStyle |= MB_DEFBUTTON3;
		break;
	}

	switch (msgicon)
	{
	case OLEMSGICON_NOICON:
		break;
	case OLEMSGICON_CRITICAL:
		dwStyle |= MB_ICONSTOP;
		break;
	case OLEMSGICON_QUERY:
		dwStyle |= MB_ICONQUESTION;
		break;
	case OLEMSGICON_WARNING:
		dwStyle |= MB_ICONEXCLAMATION;
		break;
	case OLEMSGICON_INFO:
		dwStyle |= MB_ICONINFORMATION;
		break;
	}

	if (pwszTitle == NULL)
		{
		return E_INVALIDARG;
		}

	lstrcpyn(szPrompt, OLE2T(pwszTitle), cchMsgMax);

	if (pwszText != NULL)
		{
		ASSERT(cchMsgMax > (lstrlen(szPrompt) + 2 + lstrlen(OLE2T(pwszText))));
		lstrcat(szPrompt, TEXT("\n\n"));
		lstrcat(szPrompt, OLE2T(pwszText));
		}

	*pnResult = AfxMessageBox(szPrompt, dwStyle);

	return S_OK;
}

IMPLEMENT_ADDREF		(CIPCompFrameHook, OleCompUIMgr)
IMPLEMENT_RELEASE		(CIPCompFrameHook, OleCompUIMgr)
IMPLEMENT_QUERYINTERFACE(CIPCompFrameHook, OleCompUIMgr)

/////////////////////////////////////////////////////////////////////////////
// Implementation of IOleInplaceComponentUIManager

HRESULT CIPCompFrameHook::XOleIPCompUIMgr::UIActivateForMe(DWORD dwCompRole,
						REFCLSID rclsidActive, IOleInPlaceActiveObject *pIPActObj,
						IMsoCommandTarget *pCmdTrgtActive,
	        			ULONG cCmdGrpId, LONG *rgnCmdGrpId)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr)

#ifdef UNDONE
	// Remove custom commandbars for current active object
	if (m_cCmdGrpId > 0)
	{
		ShowCustomCommandbars(FALSE);

		m_cCmdGrpId = 0;
		Assert(m_prgnCmdGrpId != NULL);
		delete m_prgnCmdGrpId;
		m_prgnCmdGrpId = NULL;
	}
#endif

	// clear everything first
	pThis->m_dwCompRole = OLEROLE_UNKNOWN;
	pThis->m_srpActiveCmdTrgt.SRelease();
//	m_cmdActive.SetCmdTrgt(NULL);

	pThis->m_xOleInPlaceFrame.SetActiveObject(pIPActObj, NULL);

	ASSERT(dwCompRole != OLEROLE_COMPONENTHOST &&
		   dwCompRole != OLEROLE_UNKNOWN);

	// let's be robust in case a stupid component is confused
	// to think that it is a host or unknown. we will treat them
	// as a component control. (this is prompted by IStudio bug #5243)
	if(!(dwCompRole != OLEROLE_COMPONENTHOST &&
		   dwCompRole != OLEROLE_UNKNOWN))
		dwCompRole = OLEROLE_COMPONENTCONTROL;
	
	pThis->m_dwCompRole = dwCompRole;
	pThis->m_clsidActive = rclsidActive;
	pThis->m_srpActiveCmdTrgt = pCmdTrgtActive;
	if (pThis->m_srpActiveCmdTrgt != NULL)
		pThis->m_srpActiveCmdTrgt->AddRef();
	//
	// If invoked from a context menu then the Pre ContextMenu CmdTrgt, is
	// no longer valid.  We need to prevent the pending WM_RESETCOMMANDTARGET
	// from reseting to the invalid pre-ContextMenu CmdTrgt.  This is done
	// by Releasing m_srpPreContextMenuCmdTrgt
	pThis->m_srpPreContextMenuCmdTrgt.SRelease();

//	m_cmdActive.SetCmdTrgt(m_srpActiveCmdTrgt);

#ifdef UNDONE
	// Show custom commandbars for active object
	if (m_srpActiveObject &&
		(m_dwCompRole == OLEROLE_MAINCOMPONENT ||
		 !(m_grfComp & OLECOMPFLAG_INHIBITNESTEDCOMPUI)))
		{
		// Either this is the main component, or the main
		// component has not prohibited subcomponents from
		// putting up custom menus and toolbars.

		// commandbars are cached to track activation changes.
		Assert(m_cCmdGrpId==0);
		Assert(m_prgnCmdGrpId==NULL);
		if (cCmdGrpId >0)
			{
			Try
				m_cCmdGrpId = cCmdGrpId;
				m_prgnCmdGrpId = new LONG[m_cCmdGrpId];
				PvCpyPvCb(m_prgnCmdGrpId, rgnCmdGrpId, (sizeof(LONG)*m_cCmdGrpId));
				
				ShowCustomCommandbars(TRUE);
			CatchCuexNull
				m_cCmdGrpId = 0;
				m_prgnCmdGrpId = NULL;
			EndCatch
			}
		}
	//$UNDONE only the success case should return NOERROR.
#endif

	theApp.m_bMenuDirty = TRUE;
	return S_OK;
}

HRESULT CIPCompFrameHook::XOleIPCompUIMgr::UpdateUI(DWORD dwCompRole, BOOL fImmediateUpdate,
						DWORD dwReserved)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr);

	//$UNDONE -- what about fImmediate
	theApp.m_bMenuDirty = TRUE;
	return NOERROR;
}

HRESULT CIPCompFrameHook::XOleIPCompUIMgr::SetActiveUI(DWORD dwCompRole, REFCLSID rclsid,
						ULONG cCmdGrpId, LONG *rgnCmdGrpId)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr)

	if ((pThis->m_dwCompRole == OLEROLE_MAINCOMPONENT ||
		 !(pThis->m_grfComp & OLECOMPFLAG_INHIBITNESTEDCOMPUI)))
	{
		// Either this is the main component, or the main
		// component has not prohibited subcomponents from
		// putting up custom menus and toolbars.
		//
		//$UNDONE - install the custom menus and toolbars.
		
		//$UNDONE only the success case should return NOERROR.
			
	}
	return S_OK;
}

void CIPCompFrameHook::XOleIPCompUIMgr::OnUIComponentEnterState(DWORD dwCompRole,
						DWORD dwStateId, DWORD dwReserved)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr)

	if (pThis->m_fEnteringState)
		return;

	pThis->m_fEnteringState = TRUE;
	pThis->m_dwRoleEnteringState = dwCompRole;
	
	// Announce the state change to the component manager.
	CMainFrame * pMainFrm = (CMainFrame*) AfxGetMainWnd();
	ASSERT(pMainFrm != NULL);
	if (pMainFrm->GetComponentMgr() != NULL)
		pMainFrm->GetComponentMgr()->OnComponentEnterState(pMainFrm->GetComponentID(),
			dwStateId, msoccontextAll, 0, NULL, 0);

	ASSERT(pMainFrm->m_pIPCmpMainFrm != NULL);
	IMsoComponent * pMsoComp = pMainFrm->m_pIPCmpMainFrm->GetIMsoComponent();
	ASSERT(pMsoComp != NULL);
	pMsoComp->OnEnterState(dwStateId, TRUE);
	pThis->m_fEnteringState = FALSE;
}

BOOL CIPCompFrameHook::XOleIPCompUIMgr::FOnUIComponentExitState(DWORD dwCompRole,
						DWORD dwStateId, DWORD dwReserved)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr);

	BOOL fRet = FALSE;
	// Announce the state change to the component manager.
	CMainFrame * pMainFrm = (CMainFrame*) AfxGetMainWnd();
	if (pMainFrm->GetComponentMgr() != NULL)
	{
		fRet = pMainFrm->GetComponentMgr()->FOnComponentExitState(pMainFrm->GetComponentID(),
			dwStateId, msoccontextAll, 0, NULL);

		if (!fRet)
		{
			ASSERT(pMainFrm->m_pIPCmpMainFrm != NULL);
			IMsoComponent * pMsoComp = pMainFrm->m_pIPCmpMainFrm->GetIMsoComponent();
			ASSERT(pMsoComp != NULL);
			pMsoComp->OnEnterState(dwStateId, FALSE);
		}
	}
	return fRet;
}

BOOL CIPCompFrameHook::XOleIPCompUIMgr::FUIComponentInState(DWORD dwStateId)
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr);

	BOOL fRet = FALSE;

	CMainFrame * pMainFrm = (CMainFrame*) AfxGetMainWnd();
	if (pMainFrm->GetComponentMgr() != NULL)
	{
		fRet = pMainFrm->GetComponentMgr()->FInState(dwStateId, NULL);
	}

	return fRet;
}

BOOL CIPCompFrameHook::XOleIPCompUIMgr::FContinueIdle()
{
	METHOD_PROLOGUE(CIPCompFrameHook, OleIPCompUIMgr);

	BOOL fRet = FALSE;

	CMainFrame * pMainFrm = (CMainFrame*) AfxGetMainWnd();
	if (pMainFrm->GetComponentMgr() != NULL)
	{
		fRet = pMainFrm->GetComponentMgr()->FContinueIdle();
	}

	return fRet;
}

IMPLEMENT_ADDREF		(CIPCompFrameHook, OleIPCompUIMgr)
IMPLEMENT_RELEASE		(CIPCompFrameHook, OleIPCompUIMgr)
IMPLEMENT_QUERYINTERFACE(CIPCompFrameHook, OleIPCompUIMgr)

/////////////////////////////////////////////////////////////////////////////

HRESULT CIPCompFrameHook::SetInPlaceComponent(IUnknown * punkIPComp)	// IUnknown from which to QI for the in-place component
{
	HRESULT hr = NOERROR;
	ASSERT(punkIPComp != NULL);

	//$UNDONE 4.5 -- if we are reactivating a deactivated component, we already have m_srpMainComp.
	// Should we continue to use the same one, or get a new?
	//
	m_srpMainComp.SRelease();
	m_srpMainCmdTrgt.SRelease();

	COleRef<IMsoCommandTarget> srpMainCmdTrgt;
	// we purposely use the real data member rather than a temp variable, because Davinci wants to
	// call us back during UseComponentUIManager to display a warning (if necessary).  If we don't 
	// setup the m_srpMainComp, our ShowMessage code won't work.
	if (FAILED(hr = punkIPComp->QueryInterface(IID_IOleInPlaceComponent,(void **)&m_srpMainComp)))
		goto ErrRtn;

	//	m_iguidMain = iguid;
	// Initialize the component flags, in case the component neglects to do so.
	//
	m_grfComp = 0;

	if (FAILED(hr = m_srpMainComp->UseComponentUIManager(OLEROLE_MAINCOMPONENT,
										 &m_grfComp, &m_xOleCompUIMgr,
										 ((CIPCompContainerItem *)m_pActiveItem)->GetIOleInPlaceComponentSite())))
		goto ErrRtn;

	// Now fetch the command target.  Note that we don't want to get the
	// command target until after we've called UseComponentUIManager, to
	// make sure we don't use that command target until the component
	// has finished initializing.
	//
	if (FAILED(hr = punkIPComp->QueryInterface(IID_IMsoCommandTarget,(void **)&srpMainCmdTrgt)))
		goto ErrRtn;

//	m_cmdMain.SetCmdTrgt(m_scrpMainCmdTrgt);
	m_srpMainCmdTrgt = srpMainCmdTrgt.Disown();
	
ErrRtn:
	if (FAILED(hr))
		m_srpMainComp.SRelease();
		
	return hr;
	}


void CIPCompFrameHook::DoClose()
{
	m_srpMainComp.SRelease();
	m_srpMainCmdTrgt.SRelease();
	m_srpActiveCmdTrgt.SRelease();
	// remove the object from the mainframe list
	((CMainFrame *)AfxGetMainWnd())->RemoveIPCompFrameHook(this);
}


BOOL CIPCompFrameHook::OnPreTranslateMessage(MSG* pMsg)
{
	// An hardwired in-place component gets a chance at accelerators.
	// If it returned the OLECOMPFLAG_ROUTEACTIVEASCNTRCMD flag from
	// UseComponentUIManager, it gets accelerators before the active
	// object; otherwise, it gets them after.
	//
	//$CONSIDER -- if the active object is the main component or a
	// subcomponent, we can omit calling the parent class (which
	// calls the active object's TranslateAccelerator method).
	// Is m_dwCompRole a reliable indicator--i.e. is it set to
	// OLEROLE_UNKNOWN when a non-component activates?
	//
	BOOL fHandled = FALSE;

	if (m_srpMainComp != NULL && (m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD))
	{
		fHandled = (m_srpMainComp->TranslateCntrAccelerator(pMsg) == NOERROR);
	}

	if (!fHandled)
	{
		fHandled = COleFrameHook::OnPreTranslateMessage(pMsg);
	}

	if (!fHandled && m_srpMainComp != NULL && !(m_grfComp & OLECOMPFLAG_ROUTEACTIVEASCNTRCMD))
	{
		fHandled = (m_srpMainComp->TranslateCntrAccelerator(pMsg) == NOERROR);
	}


	return fHandled;
}

BOOL CIPCompFrameHook::OnDocActivate(BOOL bActivate)
{
	ASSERT_VALID(this);

//	m_cmdMain.Invalidate();
//	m_cmdActive.Invalidate();

	// Notify the hardwired component and the active object
	// (if either is present).	Note that if the active
	// object is a main or sub-component, we omit the
	// call to OnDocWindowActivate; that call is only made
	// for OLE objects or component controls.
	//

	if (m_srpMainComp != NULL)
		m_srpMainComp->OnWindowActivate(OLEACTIVATE_DOCWINDOW, bActivate);

	if (m_lpActiveObject != NULL &&
		(m_srpMainComp == NULL ||
		 m_dwCompRole == OLEROLE_COMPONENTCONTROL ||
		 m_dwCompRole == OLEROLE_UNKNOWN))
		m_lpActiveObject->OnDocWindowActivate(bActivate);

	// remove/install the Active HookNotify on the main MDI app frame.
	// it is the responsibility of the container to manage the frame-level
	// ActiveObject pointer through MDI child window activation changes.
	//
	ASSERT_VALID(m_pFrameWnd);
	// make sure window caption gets updated later
	CIPCompFrameHook* pNotifyHook = (CIPCompFrameHook *)m_pActiveItem->m_pInPlaceFrame;
	pNotifyHook->m_pFrameWnd->DelayUpdateFrameTitle();

	// let the document know about our activatation state
	ASSERT(m_pActiveItem->IsKindOf(RUNTIME_CLASS(CIPCompContainerItem)));
	CIPCompDoc *pDoc = ((CIPCompContainerItem *)(m_pActiveItem))->GetDocument();
	if(pDoc != NULL)
		pDoc->OnDocActivate(bActivate);

	
	if (!bActivate)
	{
		// if we're the hook installed on the top-level frame, unhook ourselves.
		// (Because of the ordering, when a new in-place component is created,
		// it registers itself as the top-level hook before it gets MDI activated.)
		//
		if (pNotifyHook->m_pFrameWnd->m_pNotifyHook == this)
		{
			pNotifyHook->m_pFrameWnd->m_pNotifyHook = NULL;
			((CMainFrame *)AfxGetMainWnd())->RemoveIPCompFrameHook(pNotifyHook);
		}
	}
	else
	{
		// rehook top-level frame if necessary (no effect if top-level == doc-level)
		pNotifyHook->m_pFrameWnd->m_pNotifyHook = pNotifyHook;
		// the following will move the pNotifyHook to the head of the Hook list
		((CMainFrame *)AfxGetMainWnd())->RemoveIPCompFrameHook(pNotifyHook);
		((CMainFrame *)AfxGetMainWnd())->AddIPCompFrameHook(pNotifyHook);
	}

	// so the menu will always be rebuilt in CMDIChildWnd::OnMDIActivate
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// IServiceProvider methods implementation

HRESULT CIPCompFrameHook::XServiceProvider::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
	METHOD_PROLOGUE(CIPCompFrameHook, ServiceProvider)

	if (ppvObj == NULL)
		return E_INVALIDARG;

	*ppvObj = NULL;
	
	ASSERT(pThis->m_pActiveItem != NULL);
	ASSERT(pThis->m_pActiveItem->IsKindOf(RUNTIME_CLASS(CIPCompContainerItem)));
	
	return ((CIPCompContainerItem *)(pThis->m_pActiveItem))->GetIServiceProvider()
				->QueryService(guidService, riid, ppvObj);
}

IMPLEMENT_ADDREF		(CIPCompFrameHook, ServiceProvider)
IMPLEMENT_RELEASE		(CIPCompFrameHook, ServiceProvider)
IMPLEMENT_QUERYINTERFACE(CIPCompFrameHook, ServiceProvider)

/////////////////////////////////////////////////////////////////////////////
// Component Manager related methods implementation
void CIPCompFrameHook::OnEnterState(ULONG dwStateId, BOOL fEnter)
{
	// if this object didn't start the transition, notify
	// both the active object and the hardwired component.
	// If this object did start the transition,
	if (m_srpMainComp != NULL &&
		(!m_fEnteringState || m_dwRoleEnteringState != OLEROLE_MAINCOMPONENT))
	{
		m_srpMainComp->OnEnterState(dwStateId, fEnter);
	}
}

void CIPCompFrameHook::OnActiveEnableModelss(ULONG dwStateId, BOOL fEnter)
{
	// if this active view holds an active object,
	// and it isn't responsible for starting the transition, then
	// notify active object.  The active object only cares about modal
	// state.
	//
	if (m_lpActiveObject != NULL &&
		dwStateId == msocstateModal &&
		(!m_fEnteringState || m_dwRoleEnteringState != OLEROLE_COMPONENTCONTROL))
	{
		m_lpActiveObject->EnableModeless(!fEnter);
	}
}

void CIPCompFrameHook::OnFrameActivate(BOOL fActivate)
{
	if (m_srpMainComp != NULL)
		m_srpMainComp->OnWindowActivate(OLEACTIVATE_FRAMEWINDOW, fActivate);

	// If this view has an active object that isn't the main hard-
	// wired component, notify it, too.
	//
	if (m_lpActiveObject != NULL && m_dwCompRole != OLEROLE_MAINCOMPONENT)
		m_lpActiveObject->OnFrameWindowActivate(fActivate);
}

BOOL CIPCompFrameHook::FDoIdle(DWORD grfidlef)
{
	if (m_pDocFrameWnd)
	{
		ASSERT_VALID(m_pDocFrameWnd);
		ASSERT(m_pDocFrameWnd->IsKindOf(RUNTIME_CLASS(CPartFrame)));
		m_pDocFrameWnd->OnUpdateFrameTitle(TRUE);	//will put * on any document that's dirty
	}
	
	if (m_srpMainComp != NULL)
		return m_srpMainComp->FDoIdle(grfidlef);

	return FALSE;
}

BOOL CIPCompFrameHook::FQueryClose(BOOL fPromptUser)
{
	BOOL fRet = TRUE;

	if (m_srpMainComp != NULL)
		fRet = m_srpMainComp->FQueryClose(fPromptUser);

	return fRet;
}

//
//
//	BOOL CIPCompFrameHook::ResetCommandTarget
//
//	Description:
//		Should only be called in response to WM_RESETCOMMANDTARGET message
//		Used to reset the command target after the message from a context
//		menu has been handled.
//
//	Arguments:
//		void
//
//	Return (BOOL): TRUE if command target is reset
//
BOOL CIPCompFrameHook::ResetCommandTarget()
{
	// Reset command target iff PreContextMenu CmdTrgt is valid
	if(m_srpPreContextMenuCmdTrgt != NULL)
	{
		// Release current command target and set the new one
		m_srpActiveCmdTrgt.SRelease();
		m_srpActiveCmdTrgt = m_srpPreContextMenuCmdTrgt.Disown();
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\initexit.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Application initialization and termination code
//

#include "stdafx.h"
#include <windowsx.h>
#include "locale.h"
#include "imeutil.h"
#include "about.h"
#include "shell.h"
#include "cmdcache.h"
#include "toolexpt.h"
#include "resource.h"
#include "ipchost.h"

#include <prjapi.h>
#include <prjguid.h>
#include <bldapi.h>
#include <bldguid.h>

#define DEBUG_CLSID
#include <utilauto.h>
#undef DEBUG_CLSID

#include <cmguids.h>
#include <shlapi_.h>
#include <shellrec.h>
#include <aut1guid.h>
#include "utilauto.h"
#include "autostat.h"
#include <io.h>
#include <fcntl.h>
#include "atlbase.h"

#define VERSION_CHECK_ONLY
#include "afxdllxx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////////////////

static const TCHAR** g_packages;
static int g_nPackages;
static const TCHAR * rgszMakePackages[] = {
#ifdef _DEBUG
	// _T("deveditd"),	// FUTURE: get rid of this one
	_T("devprjd"),
	_T("ided\\devbldd"),
	_T("ided\\devfx86d"),
	_T("ided\\devtoold"),
	_T("ided\\devxboxd") };
#else
	// _T("devedit"),	// FUTURE: get rid of this one
	_T("devprj"),
	_T("ide\\devbld"),
	_T("ide\\devfx86"),
	_T("ide\\devtool"),
	_T("ide\\devxbox") };
#endif

BOOL bEnable3dControls;
BOOL InitOle(); //replaces AfxOleInit to supply our own MessageFilter

#ifdef _MTTF
BOOL IsMTTFEnabled(void);
#endif

static BOOL g_bConsoleCreated = FALSE;
BOOL g_bInvokedHelp = FALSE;
HANDLE g_hStdIn = NULL;

/////////////////////////////////////////////////////////////////////////////
// CTheApp construction

extern const TCHAR g_szKeyRoot[]     = _TEXT("Software");
extern const TCHAR g_szCompanyName[] = _TEXT("Microsoft");
#ifdef _DEBUG
static const TCHAR szShellDLL[]                 = _T("DEVSHLD.DLL");
#else
static const TCHAR szShellDLL[]                 = _T("DEVSHL.DLL");
#endif //_DEBUG
static const TCHAR szGeneralKey[]               = _T("General");
static const TCHAR szPackageCountKey[]  = _T("PackageCount");

CTheApp::CTheApp(const TCHAR** rgszPackages, int nPackages):m_RepeatableCmds(10)
{
#ifdef _EXPORT_LAYOUT
        m_bExportLayout = FALSE;
        m_pszLayoutFilePath = NULL;
#endif
        m_pszRegKeyName = NULL;
        m_pActivePacket = NULL;
        m_pMDIActivePacket = NULL;
        m_bMaximizeApp = FALSE;
        m_bMaximizeDoc = FALSE;
        m_bCompressMak = FALSE;
        m_bStatusbar = TRUE;
        m_bMenuDirty = TRUE;
        m_bProjectCommandsDirty=TRUE;
        m_bMenuDead = FALSE;
        m_wHookDialogs = DHF_CENTER | DHF_3DCONTROLS;
        m_nLockRecentFileList = 0;
        m_bOpenedFromMRU = FALSE;
        m_bOpenedFromDrop = FALSE;
        m_bOpenedFromLastLoad = FALSE;
        m_fVCPPIsActive = TRUE;
        m_fVerbose = TRUE;
        m_cCmdRepeat = 1;
        m_RepeatableCmds.InitHashTable(17);
        m_SettingRepeatCount = DoneRepeating;
        m_pAppCmpHost = NULL;
        m_bHideMicrosoftWebMenu=TRUE;
		m_fRunningMacro = FALSE;

#ifndef NO_VBA
        m_fOleAutomation = FALSE;       // suppress OLE automation until a package turns it on
#endif  // NO_VBA

#ifdef _WIN32
        // set flag if running on Chicago.  Detecting Chicago is a bit weird.  GetVersion
        // returns the "Win32s" bit, but returns version 4 or greater
        DWORD dwVersion = ::GetVersion();
        m_bOnChicago = (dwVersion & 0x80000000) && (LOBYTE(dwVersion) > 3);

        m_bWin4 = LOBYTE(dwVersion) > 3;
        m_bWin95 = m_bWin4 && (dwVersion & 0x80000000) != 0;
		m_bWin5 = LOBYTE(dwVersion) > 4;
#endif

        m_dwMenuSelectTime = 0;
        m_pRecentProjectList = NULL;

        m_bEnableWorkspaceLoad = TRUE;
        m_bPkgChk = TRUE; // enabled by default

        g_packages = rgszPackages;
        g_nPackages = nPackages;
        m_bActivated = FALSE;
        m_pAutoApp = NULL;
        m_bQuitting = FALSE;

        // Macro recording.
        m_nRecordState = RecordOff;
        m_bShouldRecordText = FALSE;

        m_nAsyncCmdLevel = 0;

	m_bInvokedCommandLine = FALSE;
	m_hLogFile = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CTheApp destruction

CTheApp::~CTheApp()
{
        // free recent project list
        if (m_pRecentProjectList != NULL)
                delete m_pRecentProjectList;
        if (m_pszRegKeyName != NULL)
                free((void*) m_pszRegKeyName);
#ifdef _EXPORT_LAYOUT
        if (m_pszLayoutFilePath != NULL)
                free((void*) m_pszLayoutFilePath);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// CTheApp initialization

static BOOL GetCmdLineProfile (LPCTSTR lpszProfileName, CStringList& argList, POSITION posInsertAfter);
static BOOL InitJIT();
static BOOL FFindOtherJitDebugger(CJit* pjit);
static UINT ErrGetJITInfo(CStringList* pArgList, CJit* pjit);
extern void SushiRestoreKey(HKEY hKey, const CString& str);

#ifdef _DEBUG
BOOL AFXAPI  OurAllocHook (size_t nSize, BOOL bObject, LONG lRequestNumber);
AFX_ALLOC_HOOK pfnNextHook;
#endif

extern HINSTANCE GetResourceHandle();

CVshellPackage::CVshellPackage()
: CPackage(GetResourceHandle(), PACKAGE_SUSHI, PKS,
                   MAKEINTRESOURCE(IDCT_SHELLPACKAGE),
                   MAKEINTRESOURCE(IDB_MAINTOOLS),
                   MAKEINTRESOURCE(IDR_MAINFRAME),
                   MAKEINTRESOURCE(IDB_MAINLARGETOOLS))
{
        // also need to add command table from exe
        theCmdCache.AddCommandResource(this, MAKEINTRESOURCE(IDCT_MAINEXE), TRUE);
}

CVshellPackage::~CVshellPackage()
{
        // Delete Named Item list
        while (!m_ptrlAutomationItems.IsEmpty())
        {
                CAutomationItem* pAutomationItem = m_ptrlAutomationItems.RemoveHead();
                delete pAutomationItem;
        }
}

//#define TIMEBOMB
#ifdef TIMEBOMB
#include <timebomb.h>
#pragma comment(lib, "timebomb")

extern "C" static void __cdecl MsvcTBCallBack(FC fc, const char *szMsg)
{
        // Default GUI style callback, bombs out on any error
        char szExe[_MAX_PATH];
        ::GetModuleFileName(NULL, szExe, sizeof(szExe));
        MessageBox(NULL, szMsg, szExe, MB_OK | MB_SYSTEMMODAL | MB_SETFOREGROUND);
}

#endif


#ifdef _DEBUG
#define APP_CLSID CLSID_ApplicationDebug
#else
#define APP_CLSID CLSID_Application
#endif

static void UnregisterPackageTypeLib(LPCTSTR strFileName)
{
	// See if the package has a type library.  If it does, register it
	//	and remember the TLID in case the package provides a top-level
	//	object.
	USES_CONVERSION;
	ITypeLib* pTypeLib = NULL;
	if (SUCCEEDED(LoadTypeLib(T2W(strFileName), &pTypeLib)) && pTypeLib != NULL)
	{
		TLIBATTR* pTlibAttr = NULL;
		if (SUCCEEDED(pTypeLib->GetLibAttr(&pTlibAttr)) && pTlibAttr != NULL)
		{
			// Register type lib
			::UnRegisterTypeLib(pTlibAttr->guid,
								pTlibAttr->wMajorVerNum, pTlibAttr->wMinorVerNum,
								pTlibAttr->lcid, pTlibAttr->syskind);
			pTypeLib->ReleaseTLibAttr(pTlibAttr);
		}
		pTypeLib->Release();
		pTypeLib = NULL;
	}
}




////////////////////////////////////////////////////////////////////////////
//
// Command Line Log file utility
//

BOOL CTheApp::WriteLog(LPCTSTR szOut, BOOL bAppendCRLF /* = FALSE */)
{
	if (m_hLogFile == NULL)
		return FALSE;

	// NULL means close stdout
	if (szOut == NULL)
	{
		::CloseHandle(m_hLogFile);
		m_hLogFile = NULL;
		return TRUE;
	}

	CString strOut = szOut;
	strOut.AnsiToOem();
	szOut = strOut;

	int len;
	DWORD nBytes;
	LPCTSTR pszC = szOut;
	while ((pszC = _tcschr(szOut, _T('\n'))) != NULL)
	{
		len = pszC - szOut;
		if (len > 0)
		{
			nBytes = (DWORD)len;
			WriteFile(m_hLogFile, szOut, (DWORD)len, &nBytes, NULL);

			// check for bogus \r in calling code
			ASSERT(*_tcsdec(szOut, pszC) != _T('\r'));
		}

		WriteFile(m_hLogFile, _T("\r\n"), 2, &nBytes, NULL);
		szOut = ++pszC;
	}

	// check for any remainder
	len = _tcslen(szOut);
	if (len > 0)
	{
		nBytes = (DWORD)len;
		WriteFile(m_hLogFile, szOut, (DWORD)len, &nBytes, NULL);
	}

	if (bAppendCRLF)
	{
		WriteFile(m_hLogFile, _T("\r\n"), 2, &nBytes, NULL);
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////
//
// Command Line Processing
//

inline BOOL IsSwitch(TCHAR ch)
{
        return (ch == '/' || ch == '-');
}

// Scan the command line for /szSwitch or -szSwitch.  Return TRUE if it's found
// or FALSE if it's not.  If pstrArg is not NULL, then copy the parameter right
// after the switch into it.  If bRemove is TRUE remove the switch and optional
// argument from the command line.
//
BOOL CTheApp::ScanCommandLine(const TCHAR* szSwitch, CString* pstrArg, BOOL bRemove)
{
	POSITION pos = theApp.m_argList.GetHeadPosition();
	POSITION posThis;

	while ((posThis = pos) != 0)
	{
		const TCHAR* szArg = theApp.m_argList.GetNext(pos);

		if (IsSwitch(szArg[0]) && _tcsicmp(szArg + 1, szSwitch) == 0)
		{
			if (pstrArg != NULL)
			{
				if (pos != NULL)
				{
			      	*pstrArg = theApp.m_argList.GetAt(pos);

					// make sure we don't return a switch as an argument
					if (IsSwitch((*pstrArg)[0]))
					{
						// return no argument
						*pstrArg = _T("");
						pos = NULL; // don't remove a switch
					}
				}
				else
				{
					// return no argument
					*pstrArg = _T("");
				}
			}

			if (bRemove)
			{
				theApp.m_argList.RemoveAt(posThis);
				if (pstrArg != NULL && pos != NULL)
					theApp.m_argList.RemoveAt(pos);
			}

			return TRUE;
		}
	}

	return FALSE;
}

////////////////////////////////////////////////////////////////////////////

void CTheApp::ShowSplashScreen(BOOL bShow)
{
        ::ShowSplashScreen(bShow);
}

#ifdef PKG_LOAD_TIME
#define MAX_PACKAGE_NUMBER      40
DWORD dwaPkgLoadLibraryTime[MAX_PACKAGE_NUMBER];
DWORD dwaPkgTypeLibTime[MAX_PACKAGE_NUMBER];
DWORD dwaPkgInitPackageTime[MAX_PACKAGE_NUMBER];
DWORD dwaPkgOnInit[MAX_PACKAGE_NUMBER];
CString straPkgName[MAX_PACKAGE_NUMBER];
int nPkg = 0;
#endif  // PKG_LOAD_TIME
#ifdef METER_IDLE_TIME
BOOL s_bIdleTime = FALSE;
#endif  // METER_IDLE_TIME

BOOL ShouldRegisterTypeLibsOnStartup(int cPackagesLoaded, BOOL& rbForceFullRegistration);
BOOL CTheApp::InitInstance()
{
#ifdef PKG_LOAD_TIME
	DWORD dwInitInstance = ::GetTickCount();
#endif  // PKG_LOAD_TIME
	BOOL fUnregisterAndQuit = FALSE;

	m_pszProfileName = _tcsdup(GetExeString(DefaultRegKeyName));
	m_bRunInvisibly = RunAutomated() || RunEmbedded();
	m_bInvokedCommandLine = FALSE;

	if (!m_bWin4)
	{
		CString strTitle, strMsg;
		VERIFY(strTitle.LoadString(AFX_IDS_APP_TITLE));
		VERIFY(strMsg.LoadString(IDS_NOT_WINDOWS4));
		::MessageBox(NULL, strMsg, strTitle, MB_OK | MB_ICONSTOP);
		return FALSE;
	}

	DWORD dwVersion = ::GetVersion();
	if ((dwVersion & 0x80000000) != 0 && (BYTE)dwVersion <= 3)
	{
        CString strTitle, strMsg;
        VERIFY(strTitle.LoadString(AFX_IDS_APP_TITLE));
        VERIFY(strMsg.LoadString(IDS_NOT_WIN32S));
        ::MessageBox(NULL, strMsg, strTitle, MB_OK | MB_ICONSTOP);
        return FALSE;
	}


	char szBuff[_MAX_PATH+1];

	{ CToolBar tb; }        // Sleazy hack to initialize MFC library's toolbar
			// drawing code, prior to ReloadBitmaps calls

	// BLOCK: Stolen from CWinApp::EnableShellOpen, but different...
	{
		// This enabled the App Wiz to talk to us...
		m_atomApp = ::GlobalAddAtom("MSDEV");
		m_atomSystemTopic = ::GlobalAddAtom("system");
	}

	// Figure out what code page we're running under (based on c-runtimes)
	m_codePage = _getmbcp();
	// HACK: old behavior for the code page: m_codePage = 0 for the standard code page.
	if(m_codePage == 1252) // 1252 is the code page for the US and Western Europe
		m_codePage = 0;
	m_fOEM_MBCS = (m_codePage != 0); 

	// Set the c-runtimes locale to be the same as the O.S. locale.
	setlocale(LC_ALL, "");

	if (m_fOEM_MBCS)
		imeInit();

	// Put all command line arguments into m_argList
	for (int i = 1; i < __argc; i++)
		m_argList.AddTail(__argv[i]);

#ifdef TIMEBOMB
#pragma message("WARNING!: TimeBomb is ENABLED!")
	// Block
	{
		FC fc = FcCheckVerDate ( 528, &ctmOpenBy, &ctmCloseBy, MsvcTBCallBack );
		if ( fc == fcPastEndDate || fc == fcDateDecremented )
		{
			return FALSE;
		}
	}
#endif

	g_bInvokedHelp =  ( /* ScanCommandLine("help, NULL, FALSE") || */ ScanCommandLine("?", NULL, FALSE));

	CString strOutFile;
	BOOL bOutSpecified = (ScanCommandLine("out", &strOutFile, TRUE));
	if ((ScanCommandLine("make", NULL, g_bInvokedHelp)) || (g_bInvokedHelp))
	{
		m_bRunInvisibly = TRUE;
		m_bInvokedCommandLine = TRUE;
		{
			g_packages = rgszMakePackages;
			g_nPackages = sizeof(rgszMakePackages) / sizeof(const TCHAR *); // 3
		}

		// make sure we have console output
		// g_hStdIn = ::GetStdHandle(STD_INPUT_HANDLE);
		HANDLE hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
		// HANDLE hStdErr = ::GetStdHandle(STD_ERROR_HANDLE);
		HANDLE hFile;
		if (bOutSpecified)
		{
			if ((!strOutFile.IsEmpty()) && (!IsSwitch(strOutFile[0])))
			{
				 // REVIEW: further validation?
				if (((hFile = CreateFile(strOutFile, GENERIC_WRITE, FILE_SHARE_READ, NULL /* REVIEW */, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE) && (hFile != NULL) && (hFile != (void *)-1))
				{
					m_hLogFile = hFile;
					if (SetStdHandle(STD_OUTPUT_HANDLE, hFile))
					{
						// force stdout to use specified filename
						::CloseHandle(hStdOut);
						hStdOut = hFile;
						int hCHandle = _open_osfhandle((long)hFile, _O_TEXT);
						FILE * hCStream = _fdopen(hCHandle, "wt");
						ASSERT(hCHandle != -1);
						if (hCHandle != -1)
						{
							if (_fileno(stdout)==-1)
							{
								stdout->_file = 1;
								stdout->_flag = _IOWRT;
							}

							int hRet;
							if ((hRet = _dup2(hCHandle,  1 /* _fileno(stdout) */))!=0)
							{
								// fprintf(hCStream, "errno = %d %x\n", errno, errno);
								ASSERT(0);
							}
						}
						else
						{
							// error: stdout could not be redirected
							// SetStdHandle(STD_OUTPUT_HANDLE, hStdOut);
							// CloseHandle(hFile);
						}
					} 
					else
					{
						// error: stdout could not be redirected
						// CloseHandle(hFile);
					}
				}
				else
				{
					// error: file could not be created
					if ((hStdOut != INVALID_HANDLE_VALUE) && (hStdOut != NULL))
					{
						// syntax error or read-only file
						CString str, strOut;
						m_hLogFile = hStdOut;

						MsgText(str, IDS_ERR_OUT_ARG, (LPCTSTR)strOutFile);

						// REVIEW: give more detailed error info
						strOut.LoadString(IDS_INVALID_FILENAME);
						strOut += _T('\n');
						WriteLog(str, TRUE);
						WriteLog(strOut, TRUE);
					}
				}
			}
			else
			{
				if ((hStdOut != INVALID_HANDLE_VALUE) && (hStdOut != NULL))
				{
					m_hLogFile = hStdOut;
				}
			}
		}
		if ((!m_hLogFile) && ((hStdOut == INVALID_HANDLE_VALUE) || (hStdOut == NULL) || ((hStdOut == (HANDLE)7) && (!m_bWin95)))) // REVIEW
		{
			if (::AllocConsole())
			{
				g_bConsoleCreated = TRUE;
				// g_hStdIn = ::GetStdHandle(STD_INPUT_HANDLE);
				hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
				// hStdErr = ::GetStdHandle(STD_ERROR_HANDLE);
				ASSERT(hStdOut != INVALID_HANDLE_VALUE);

#if 0
				int hCHandle = _open_osfhandle((long)hStdOut, _O_TEXT);
				ASSERT(hCHandle != -1);
				if (hCHandle != -1)
				{
					FILE * hCStream = _fdopen(hCHandle, "wt");
					if (_fileno(stdout)==-1)
					{
						stdout->_file = 1;
						stdout->_flag = _IOWRT;
						ASSERT(0);
					}

					VERIFY(!_dup2(hCHandle, 1 /* _fileno(stdout) */));
				}
				else
				{
					ASSERT(0);
				}
#endif

				if (!m_hLogFile)
					m_hLogFile = hStdOut;
				else
					::CloseHandle(hStdOut);
			}
			else
			{
				// error: could not alloc console
				// ASSERT(0);
			}
		}
		else
		{
                     // ASSERT(hStdOut != (void *)7);
			// should be okay
			if (!m_hLogFile)
			{
				m_hLogFile = hStdOut;
#if 0
				int hCHandle = _open_osfhandle((long)hStdOut, _O_TEXT);
				ASSERT(hCHandle != -1);
				if (hCHandle != -1)
				{
					FILE * hCStream = _fdopen(hCHandle, "wt");
					if (_fileno(stdout)==-1)
					{
						stdout->_file = 1;
						stdout->_flag = _IOWRT;
						ASSERT(0);
					}

					VERIFY(!_dup2(hCHandle, _fileno(stdout) /* _fileno(stdout) */));
				}
#endif
			}
		}
	}
#ifndef _SHIP
	if (ScanCommandLine("visible", NULL, TRUE))
	{
		m_bRunInvisibly = FALSE;
	}
#endif
	if (g_bInvokedHelp)
	{
		CString strOut;
		strOut.LoadString(IDS_SHL_HLP_USAGE);
		WriteLog(strOut);
		strOut.LoadString(IDS_SHL_HLP_USAGE2);
		WriteLog(strOut);

		strOut.LoadString(IDS_SHL_HLP_HELP);
		WriteLog(strOut);

		strOut.LoadString(IDS_AUT_HLP_EX);
		WriteLog(strOut);

		strOut.LoadString(IDS_SHL_HLP_OUT);
		WriteLog(strOut);
	}

	InitMsgBoxes();
	InitMetrics();


	// check the CRTs are correct as certain programs (Win98, Symantec CAFE)
	// downgrade the DLL to the V5 one. This hoses us as the Disasm DLL uses
	// MSVCP60 which needs the V6 CRT DLL
	char *szCRTName, *szCIRTName, *szMFCName;
	char szPath[ _MAX_PATH ];
#ifdef _DEBUG
	szCRTName = "MSVCRTD.DLL";
	szMFCName = "MFC42D.DLL";
#else
	szCRTName = "MSVCRT.DLL";
	szMFCName = "MFC42.DLL";
#endif

	HMODULE hMod = ::GetModuleHandle( szCRTName );
	if (hMod && ::GetModuleFileName( hMod, szPath, sizeof(szPath) ))
	{
		BYTE verBuf[1024];
		if (GetFileVersionInfo( (char*)szPath, 0, sizeof(verBuf), &verBuf ))
		{
			VS_FIXEDFILEINFO *pVersion;
			UINT cSize;
			if (VerQueryValue( verBuf, TEXT("\\"), (LPVOID*)&pVersion, &cSize ))
			{
				if (pVersion->dwFileVersionMS < 0x60000)
				{
					// CRT is too old, so warn about it
					CString strTitle, strMsg;
					strTitle.LoadString(AFX_IDS_APP_TITLE);
					strMsg.LoadString(IDS_BAD_CRT_VER);
					::MessageBox(NULL, strMsg, strTitle, MB_OK | MB_ICONEXCLAMATION);
				}
			}
		}
	}
	hMod = ::GetModuleHandle( szMFCName );
	if (hMod && ::GetModuleFileName( hMod, szPath, sizeof(szPath) ))
	{
		BYTE verBuf[1024];
		if (GetFileVersionInfo( (char*)szPath, 0, sizeof(verBuf), &verBuf ))
		{
			VS_FIXEDFILEINFO *pVersion;
			UINT cSize;
			if (VerQueryValue( verBuf, TEXT("\\"), (LPVOID*)&pVersion, &cSize ))
			{
				if (pVersion->dwFileVersionMS < 0x60000)
				{
					// MFC is too old, so warn about it
					CString strTitle, strMsg;
					strTitle.LoadString(AFX_IDS_APP_TITLE);
					strMsg.LoadString(IDS_BAD_MFC42_VER);
					::MessageBox(NULL, strMsg, strTitle, MB_OK | MB_ICONEXCLAMATION);
				}
			}
		}
	}




	// BEFORE the splash screen goes up, and before any time-consuming
	// DLL loads are done, see if we were spawned as a just-in-time
	// debugger, and there's already an MSVC running in the system
	// which wants to be the JIT debugger.  If so, just get out.
	if (!InitJIT())
		return FALSE;

	// we need to instantiate our message filter which support IServiceProvider.
	// overwrite AfxOleInit() which initialize OLE 2.0 libraries
	if (!InitOle())
	{
		//              AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	// By default OLE applications are enabled for Compound Files
	//      COleDocument::EnableDocFile();
	AfxEnableControlContainer();

	// Read command line settings.
#ifdef _WIN32
        // FUTURE:  The autosaver will go away from the command line when it goes
        //                       into the options dialogue box.  [w-amilt]

#ifdef AUTOSAVE_ON_COMMAND_LINE
	BOOL fEnableAutosaver = FALSE;
	int nAutosaveTime;
#endif  // AUTOSAVE_ON_COMMAND_LINE
	CString strRestoreFile;
	BOOL fNoLogo = FALSE;
	BOOL bCreateNewProject = FALSE;
	POSITION pos, posCur;
	CPath path;
	CString strExe = ".exe";
	CString strTarg = "";

#ifdef _MTTF
	m_bMTTF = TRUE;
#endif

#ifdef _CMDLOG
#ifdef _SHIP
	m_bCmdLog = FALSE;
#else
	m_bCmdLog = FALSE; // default to OFF for now
#endif // _SHIP
#endif // _CMDLOG

	m_bEncPerfLog = FALSE;

#ifdef _ENCLOG
	m_bEncLog = TRUE;
#endif

#ifdef PKG_LOAD_TIME
	BOOL s_bLoadTime = FALSE;
#endif  // PKG_LOAD_TIME
#ifdef PERF_MEASUREMENTS
	///////////////// Testing code for V4 perf release (fabriced)
	m_bPerfQA_AutoRun = FALSE;
	m_bPerfQA_WorkSet = FALSE;
	m_bPerfQA_Workspace = FALSE;
	m_szPerfQA_Project = NULL;
                /////////////////////////////////////////////////////////////
#endif  // PERF_MEASUREMENTS

#ifdef _IDELOG
#ifdef _SHIP
	m_bIDELog = FALSE;
#else
	m_bIDELog = FALSE; // default to OFF for now
#endif // _SHIP
#endif // _IDELOG

	// initialize m_bRestoreKey to FALSE
	// flag is set if /RESTORE command line is specified.
	// If it is set, then vproj will not prepend the default
	// environment setting for msvc
	m_bRestoreKey = FALSE ;

	// iterate through args
	//
	pos = m_argList.GetHeadPosition();

			BOOL bForceFullRegistration = FALSE;                    // -REGISTER on cmdline?
	CString strCommand;                             // -EXECUTE Command passed on the command line?
	while ((posCur = pos) != 0)
	{
		CString strArg = m_argList.GetNext(pos);

		// see if option
		//
		if(IsSwitch(strArg[0]) && strArg.GetLength() >= 2)
		{
			TCHAR	tch = strArg[1];
			LPCTSTR tsz = strArg;
			BOOL	fRemoveArg = FALSE;

			CharUpperBuff(&tch, 1);
			int nSwitchLength = _tcslen((LPCTSTR) &tsz[1]);
			switch(tch)
			{
				case 'T':
					if( _tcsicmp(&tsz[1], "TARG") == 0 )
					{
							POSITION posLast = pos;
							strTarg = m_argList.GetNext(pos);
							// HACK need to remove the current
							// and next arg
							fRemoveArg = FALSE;
							m_argList.RemoveAt(posCur);
							m_argList.RemoveAt(posLast);
					}
					break;
#ifdef _EXPORT_LAYOUT
				case 'X':
						if( _tcsicmp(&tsz[1], "XPORT_LAYOUT") == 0 )
						{
								fRemoveArg = TRUE;
								m_bExportLayout = TRUE;
						}
						break;
#endif

#ifdef AUTOSAVE_ON_COMMAND_LINE
				// 11/19/93 [patbr] autosave now has UI, so
				// command-line interface no longer necessary
				case 'A':
					// Autosave?
					if (_tcsnicmp(&tsz[1], "AUTOSAVE", 8) == 0 )
					{
						// Yes.  Check for a ':<time>' suffix
						fRemoveArg = TRUE;
						fEnableAutosaver = TRUE;
						if (tsz[9] == ':')
						{
							if ((nAutosaveTime = atoi(&tsz[10])) < 0)
							{
								ErrorBox(IDS_AUTOSAVE_BAD_INTERVAL,
										nAutosaveTime, gAutosaver.GetInterval());
								nAutosaveTime = (int) gAutosaver.GetInterval();
							}
						}
						else
							nAutosaveTime = (int) gAutosaver.GetInterval();
					}
					break;
#endif	// AUTOSAVE_ON_COMMAND_LINE

#ifdef _CMDLOG
#ifdef _SHIP
				case 'C':
					if (_tcsicmp(&tsz[1], "CMDLOG") == 0)
					{
						fRemoveArg = TRUE;
						m_bCmdLog = TRUE;
					}
					break;
#endif // _SHIP
#endif // _CMDLOG

				case 'I':
#ifdef	_IDELOG
#ifndef _SHIP
					if ( _tcsicmp(&tsz[1],"IDELOG") == 0 )
					{
							fRemoveArg = TRUE;
							m_bIDELog = TRUE;
							break;
					}
#endif // _SHIP
#endif // _IDELOG
					// Key name.
					fRemoveArg = TRUE;

					lstrcpy(szBuff, m_pszProfileName);
					lstrcat(szBuff, &tsz[2]);

					{
							// We now allocate m_pszProfileName, so we need to free it
							// here to avoid leaks (fabriced 22May96).
							free((void *) m_pszProfileName);
							m_pszProfileName = _tcsdup(szBuff);
					}
					break;

				case 'N':
					if (_tcsicmp(&tsz[1], "NEWPROJ") == 0)
					{
							bCreateNewProject = TRUE;
							fNoLogo = TRUE; // implied
							fRemoveArg = TRUE;
					}
					else if (_tcsicmp(&tsz[1], "NOLOGO") == 0)
					{
							fRemoveArg = TRUE;
							fNoLogo = TRUE;
					}
#ifdef _MTTF
					else if ( _tcsicmp(&tsz[1],"NOMTTF") == 0 )
					{
							fRemoveArg = TRUE;
							m_bMTTF = FALSE;
					}
#endif
#ifdef _ENCLOG
					else if ( _tcsicmp(&tsz[1],"NOENCNETLOG") == 0 )
					{
							fRemoveArg = TRUE;
							m_bEncLog = FALSE;
					}
#endif
#ifdef	_CMDLOG
#ifndef _SHIP
					else if ( _tcsicmp(&tsz[1],"NOCMDLOG") == 0 )
					{
							fRemoveArg = TRUE;
							m_bCmdLog = FALSE;
					}
#endif // _SHIP
#endif // _CMDLOG
#ifdef	_IDELOG
#ifndef _SHIP
					else if ( _tcsicmp(&tsz[1],"NOIDELOG") == 0 )
					{
							fRemoveArg = TRUE;
							m_bIDELog = FALSE;
					}
#endif // _SHIP
#endif // _IDELOG
#ifndef _SHIP
					else if ( _tcsicmp(&tsz[1],"NOLOG") == 0 )
					{
						// Turn off all types of logging
#ifdef	_IDELOG
						m_bIDELog = FALSE;
#endif
#ifdef	_CMDLOG
						m_bCmdLog = FALSE;
#endif
#ifdef _MTTF
						m_bMTTF = FALSE;
#endif
#ifdef _ENCLOG
						m_bEncLog = FALSE;
#endif
					}
#endif // _SHIP
					break;

				case 'P':
					if (_tcsicmp(&tsz[1], "PROFILE") == 0 )
					{
							fRemoveArg = TRUE;

							// Make sure we have a next arg
							if (pos == NULL)
							{
									TRACE0("/PROFILE: No profile name specified with switch.");
									break;
							}

							// Get the next arg, which should be the profile name
							POSITION posLast = posCur;
							posCur = pos;
							strTarg = m_argList.GetNext(pos);

							// Get the cmd line args from the registry for the specified profile
							if (GetCmdLineProfile(strTarg, m_argList, posCur) == FALSE)
							{
									TRACE1("/PROFILE: Could not find specified profile '%s'", strTarg);
									break;
							}

							// Set pointer correctly to next arg, since list may have changed
							pos = posCur;
							m_argList.GetNext(pos);

							// Manually remove current and last args
							fRemoveArg = FALSE;
							m_argList.RemoveAt(posCur);
							m_argList.RemoveAt(posLast);
					}
#ifdef PKG_LOAD_TIME
					else if(_tcsicmp(&tsz[1], "PKGLOADTIME") == 0 )
					{
							s_bLoadTime = TRUE;
					}
#endif	// PKG_LOAD_TIME
#ifdef METER_IDLE_TIME
					else if(_tcsicmp(&tsz[1], "PERFIDLETIME") == 0 )
					{
							s_bIdleTime = TRUE;
					}
#endif	// METER_IDLE_TIME
#ifdef PERF_MEASUREMENTS
					///////////////// Testing code for V4 perf release (fabriced)
					else if(_tcsicmp(&tsz[1], "PERFQA") == 0 )
					{
							m_bPerfQA_AutoRun = TRUE;
							fRemoveArg = TRUE;
					}
					else if(_tcsicmp(&tsz[1], "PERFWORKSET") == 0 )
					{
							m_bPerfQA_WorkSet = TRUE;
							fRemoveArg = TRUE;
					}
					else if(_tcsicmp(&tsz[1], "PERFWORKSPACE") == 0 )
					{
							m_bPerfQA_Workspace = TRUE;
							fRemoveArg = TRUE;
					}
					/////////////////////////////////////////////////////////////
#endif	// PERF_MEASUREMENTS
					break;
				case 'U':
					if (_tcsicmp(&tsz[1], "UNREGISTER") == 0 )
					{
#ifdef _DEBUG
						UnregisterPackageTypeLib("ided\\devbldd.pkg");
						UnregisterPackageTypeLib("ided\\devdbgd.pkg");
						UnregisterPackageTypeLib("deveditd.pkg");
						UnregisterPackageTypeLib("devshld.dll");
						TCHAR *szObject = "MSDEVD.APPLICATION";
#else
						UnregisterPackageTypeLib("ide\\devbld.pkg");
						UnregisterPackageTypeLib("ide\\devdbg.pkg");
						UnregisterPackageTypeLib("devedit.pkg");
						UnregisterPackageTypeLib("devshl.dll");
						TCHAR *szObject = "MSDEV.APPLICATION";
#endif
						CRegKey key;
						if(key.Open(HKEY_CLASSES_ROOT, NULL) == ERROR_SUCCESS)
						{
							key.RecurseDeleteKey(szObject);
							if(key.Open(key, "CLSID")== ERROR_SUCCESS)
							{
								COleMalloc<OLECHAR>	wsz;
								if(StringFromCLSID(APP_CLSID, &wsz)== S_OK)
								{
									USES_CONVERSION;
									key.RecurseDeleteKey(OLE2T(wsz));
								}

							}
						}
						fUnregisterAndQuit = TRUE;	// Do not continue.
					}
					break;

				case 'R':
					// Restore?
					if (_tcsicmp(&tsz[1], "RESTORE") == 0 )
					{
							// get path of executable
							static char BASED_CODE szLyt[] = ".KEY";

							fRemoveArg = TRUE;
							VERIFY(::GetModuleFileName(m_hInstance, szBuff, _MAX_PATH));
							int nLen = lstrlen(szBuff);
							ASSERT(nLen > 4 && szBuff[nLen-4] == '.');	// must end in .EXE
							nLen -= 4;
							szBuff[nLen] = '\0';		// no suffix
							lstrcat(szBuff, szLyt);
							strRestoreFile = szBuff;
					}
					else if (_tcsicmp(&tsz[1], "REGISTER") == 0 )
					{
							bForceFullRegistration = TRUE;
					}
#ifdef RAD_DEMO
					else if (_tcsicmp(&tsz[1], "RAD") == 0 )
					{
						_spawnl(_P_WAIT, "CreateProj.bat", "CreateProj.bat", NULL);
					}
#endif // RAD_DEMO
					break;

				case 'E':
					// Execute command (macro, e.g.)
					if (nSwitchLength > 1			// 'e' is used for JIT
							&& _tcsnicmp(&tsz[1], "EXECUTE", nSwitchLength) == 0 )
					{
							POSITION posLast = pos;
							if(pos)
							{
								strCommand = m_argList.GetNext(pos);
								// need to remove the current
								//	and next arg.  Manually remove -EXECUTE and
								//	command name here, rather than auto-remove
								//	arg later
								fRemoveArg = FALSE;
								m_argList.RemoveAt(posCur);
								m_argList.RemoveAt(posLast);
							}
					}
					else if (_tcsicmp(&tsz[1], "ENCPERFLOG") == 0 )
					{
							fRemoveArg = TRUE;
							m_bEncPerfLog = TRUE;
					}

					break;

			}	// End switch

			if (fRemoveArg)
				m_argList.RemoveAt(posCur);
		}
		else
		{

#ifdef PERF_MEASUREMENTS
			///////////////// Testing code for V4.x perf release (konradt)
			if(m_bPerfQA_AutoRun)
			{
					if ((strArg.Find(".mdp") != -1) || (strArg.Find(".MDP") != -1))
					{
							m_szPerfQA_Project = new char[strArg.GetLength() + 1];
							strcpy(m_szPerfQA_Project, (LPCTSTR)strArg);
							m_argList.RemoveAt(posCur);
					}
			}
			/////////////////////////////////////////////////////////////
#endif	// PERF_MEASUREMENTS

			// if we see an exe on the command line, the entire remainder
			// of the command line consists of the command line to be
			// passed to that exe, rather than options for MSVC.
			//
			// FUTURE: can't go checking name extensions (might not be .EXE)!
			if (path.Create(strArg) &&
					strExe.CompareNoCase(path.GetExtension()) == 0)
			{
					break;
			}
		}
	}

	// Prime MFC reg DB info.
	m_pszRegKeyName = _tcsdup(m_pszProfileName);	 // Save the profile name.
	SetRegistryKey(g_szCompanyName);		  // SetCompanyName() resets the profile.
	free((void *)m_pszProfileName);
	m_pszProfileName = m_pszRegKeyName;

	// Build full version of the application's root key name.
	lstrcpy(szBuff, g_szKeyRoot);
	*(szBuff + sizeof(g_szKeyRoot) - 1) = chKeySep;
	lstrcpy(szBuff + sizeof(g_szKeyRoot), g_szCompanyName);
	*(szBuff + sizeof(g_szKeyRoot) + sizeof(g_szCompanyName) - 1) = chKeySep;
	lstrcpy(szBuff + sizeof(g_szKeyRoot) + sizeof(g_szCompanyName), m_pszProfileName);
	m_pszRegKeyName = _tcsdup(szBuff);

	// restore the registration DB key
	if (!strRestoreFile.IsEmpty())
	{
		DWORD dwDisp;
		HKEY hKeyMain;
		VERIFY(RegCreateKeyEx(HKEY_CURRENT_USER, GetRegistryKeyName(),
				0, "", REG_OPTION_NON_VOLATILE, KEY_WRITE | KEY_READ, NULL,
				&hKeyMain, &dwDisp) 	== ERROR_SUCCESS);

		SushiRestoreKey(hKeyMain, strRestoreFile);
		RegCloseKey(hKeyMain);
		m_bRestoreKey = TRUE ;
	}

	// Init message boxes early in case anything fails
	{
		BOOL bUseCtl3d;
		// CTL3D32 causes many problems on NT-J 3.1...
		if (m_fOEM_MBCS && (LOBYTE(LOWORD(dwVersion)) == 0x03) &&
			(HIBYTE(LOWORD(dwVersion)) < 0x32))
			bUseCtl3d = FALSE;
		else
			bUseCtl3d = TRUE;

		if (GetRegInt(szGeneralKey, "Enable3d", bUseCtl3d))
			bEnable3dControls = m_bWin4 || Enable3dControls();
		else
			bEnable3dControls = FALSE;
	}
	if (!bEnable3dControls)
		SetDialogBkColor(); 	// button face dialogs.

#endif	// _WIN32
	if(fUnregisterAndQuit)
		return FALSE;
#ifdef _EXPORT_LAYOUT
	//BLOCK:
	{
		// get path of executable
		VERIFY(::GetModuleFileName(m_hInstance, szBuff, _MAX_PATH));
		int nLen = lstrlen(szBuff);
		ASSERT(nLen > 4 && szBuff[nLen-4] == '.');	// must end in .EXE
		nLen -= 4;
		szBuff[nLen] = '\0';		// no suffix

		// get path of .LYT file
		if (m_pszLayoutFilePath == NULL)
		{
			static char BASED_CODE szLyt[] = "%d.LYT";		// Used in wsprintf.
			lstrcat(szBuff, szLyt);
			m_pszLayoutFilePath = _tcsdup(szBuff);
		}
	}
#endif

	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	m_pMainWnd = pMainFrame;

	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
	{
		m_pMainWnd = NULL;
		return FALSE;
	}

	LoadPrivateProfileSettings();

	// Determine how we will show our main window.
#ifdef _WIN32
	if (m_nCmdShow == SW_SHOWDEFAULT)
	{
		STARTUPINFO si = {sizeof(si)};
		GetStartupInfo(&si);

		if (si.dwFlags & STARTF_USESHOWWINDOW)
			m_nCmdShow = si.wShowWindow;
	}
#endif

	if (theApp.m_bMaximizeApp &&
					(m_nCmdShow == SW_SHOWNORMAL ||
					m_nCmdShow == SW_SHOW ||
					m_nCmdShow == SW_SHOWDEFAULT))
	{
		m_nCmdShow = SW_SHOWMAXIMIZED;
	}
	if (m_bRunInvisibly)
		m_nCmdShow = SW_HIDE;

	InitProductId(NULL); // init product id info from exe's PID resource





	//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	// NOTE: Show splash screen as soon after we create main window
	// as possible.  Try not to add code above here.

	// show spash screen after we have created the main window so
	// we can parent it to the main window.  otherwise it will be
	// hidden when we show the main window. -bm
	//
	if (!m_bRunInvisibly && !fNoLogo && m_nCmdShow != SW_MINIMIZE && m_nCmdShow != SW_SHOWMINIMIZED)
	{
		ShowSplashScreen(TRUE);
	}


#ifdef _CMDLOG
	InitCmdLog();
#endif

#ifdef _IDELOG
	if (m_bIDELog)
	{
		InitIDEstartupLog();
	}
#endif

	pMainFrame->InitKeymap();

#ifdef _WIN32
	// 11/19/93 [patbr]
	// install autosaver before restoring profile settings
#ifdef ENABLE_FILE_AUTOSAVES
	gAutosaver.Install(pMainFrame->m_hWnd);
#endif	// ENABLE_FILE_AUTOSAVES
	LoadPrivateAutosaveSettings();
#endif

	CPackage* pPackage = new CVshellPackage();
	VERIFY(RegisterPackage(pPackage));

#ifndef NOIPCOMP
	//		(this is separate from calling InitStdCompMgr because this inits the
	//		library itself, not the manager object
	//		-- equivalent to DLL_PROCESS_ATTACH for the library).
	CMLibInit(AfxGetInstanceHandle());

	// initialize Office's StdComponentManager after the main frame has been
	// created, but before we instantiate any components or packages that use it.
	if (!InitStdCompMgr())
		return FALSE;
#endif

	// Register all programmable objects which currently exist.
	COleObjectFactory::RegisterAll();				// current state of OLE DLL's

	// Update the persistent registry with info on our object factories.
	COleObjectFactory::UpdateRegistryAll(); // persistent registry state

	// Before we load the packages (particularly the vba package), create
	//	our OLE automation Application object.
	if ((m_pAutoApp = CApplication::Create()) == NULL)
	{
		TRACE("BAD ERROR: CTheApp::InitInstance: Failed to create application object!\n");
		return FALSE;
	}
	
	int cPackagesLoaded=0;
	BOOL bPackageLoadSuccess=LoadPackages(&cPackagesLoaded);
	if (!bPackageLoadSuccess)
	{
		theApp.m_pAutoApp->Zombify();
		theApp.m_pAutoApp->Destroy();
		pMainFrame->DestroyWindow();
		return FALSE;
	}

	// For an explanation of all of this, see the comments on CPackage::GetPackageProperty()
	if(GetExecutableProperty(030370)==0x6d736c)
	{
			m_bHideMicrosoftWebMenu=FALSE;
	}
	else
	{
			// Determine if we should show the microsoft on the web menu
			CPackage* pPackageEnum;
			pos = m_packages.GetHeadPosition();

			while (pos != NULL)
			{
					pPackageEnum = (CPackage*) m_packages.GetNext(pos);
					if(pPackageEnum)
					{
							if(pPackageEnum->GetPackageProperty(030370)==0x6d736c)
							{
									m_bHideMicrosoftWebMenu=FALSE;
									break;
							}
					}
			}
	}

	if (!(m_bRunInvisibly && m_bInvokedCommandLine)) // REVIEW
		LoadMRUList();  // Loads CRuntimeClasses which reside in packages.

	// allow packages to initialise after all of the other packages
	// have been loaded (they might depend on this fact) - done before InitAfterRegistration
	// to avoid CDockManager repainting before the source windows have their coloring information
	CPackage* pPackageEnum;
	pos = m_packages.GetHeadPosition();

#ifdef PKG_LOAD_TIME
	nPkg = -1; // Vshell is first package so we will skip this one
#endif	// PKG_LOAD_TIME

	while (pos != NULL)
	{
#ifdef PKG_LOAD_TIME
		if( nPkg >=0 )
				dwaPkgOnInit[nPkg] = ::GetTickCount();
#endif	// PKG_LOAD_TIME
		pPackageEnum = (CPackage*) m_packages.GetNext(pos);
		if ((pPackageEnum->m_flags & PKS_INIT) != 0)
		{
			if (!pPackageEnum->OnInit())
			{
				// The package whose initialization failed should provide a meaningful
				// error message explaining with more detail WHY initialization failed.

				// The shell simply issues a more generic message just in case this is
				// the only message the user sees before the application exits.

				// due to Win95J limit, error message is broken into 3 resource strings.
				CString strErrorMsg, strErrorMsg2, strErrorMsg3;
				VERIFY(strErrorMsg.LoadString(IDS_PACKAGEINITFAILED));
				VERIFY(strErrorMsg2.LoadString(IDS_PACKAGEINITFAILED2));
				VERIFY(strErrorMsg3.LoadString(IDS_PACKAGEINITFAILED3));
				strErrorMsg += strErrorMsg2;
				strErrorMsg += strErrorMsg3;

				MsgBox(Error, strErrorMsg);
				theApp.m_pAutoApp->Zombify();
				theApp.m_pAutoApp->Destroy();
				pMainFrame->DestroyWindow();
				return FALSE;
			}
		}
#ifdef PKG_LOAD_TIME
		if( nPkg >=0 )
			dwaPkgOnInit[nPkg] = ::GetTickCount() - dwaPkgOnInit[nPkg];
		nPkg++;
#endif	// PKG_LOAD_TIME
	}

	// Should we load the typelibs now?  And if so, should we force
	//	full registration of them all?
	if (bForceFullRegistration ||
			ShouldRegisterTypeLibsOnStartup(cPackagesLoaded, bForceFullRegistration))
	{
			((CVshellPackage*) pPackage)->RegisterTypeLibsIfNecessary(bForceFullRegistration);
	}

	pMainFrame->m_keymap.GetReg();

	// Initialization for cached interfaces
	g_IdeInterface.Initialize();

	// This now depends on OnInit having been called in CVcppPackage
	LoadToolListSetting();

	// Figure out which commands should be repeatable and initialize
	// our table.
	InitRepeatableCommands();

	// Initialize our macro recording infrastructure

	CShellRecorder::m_pMacroRecorder = 0;
	theApp.FindInterface(IID_IMacroRecorder, reinterpret_cast<void**>(&CShellRecorder::m_pMacroRecorder));

	// The automation Application object needs to know whether the mainfrm
	//	was last in a maximized state before the mainfrm became invisible.
	//	It uses this when a controller then makes the mainfrm visible
	//	via Application.Visible = True.  CApplication can NOT just use
	//	theApp.m_bMaximizeApp, since this value becomes FALSE when the
	//	mainfrm is later made invisible.
	m_pAutoApp->m_bMaximizeApp = theApp.m_bMaximizeApp;

	if (!(m_bRunInvisibly && m_bInvokedCommandLine)) // REVIEW
	{
	// haven't loaded a project on the command line.
	pMainFrame->InitAfterRegistration();
	pMainFrame->DragAcceptFiles();

	// notify all packages that the dockmgr is inited
	theApp.NotifyPackages(PN_DOCKMGR_LOADED);

	// Show the MRU menuitems if the relevant recent file list was loaded.
	// This is done after InitAfterRegistration, because the command tables
	// get initialized in that call.
	if (m_pRecentFileList == NULL)
		pPackage->SetVisibleMenuItem(ID_FILE_MRU_FILE1, FALSE);
	if (m_pRecentProjectList == NULL)
		pPackage->SetVisibleMenuItem(ID_PROJ_MRU_FILE1, FALSE);

	}
	// now, finish up the command line processing by opening all files on the
	// command line.
	CString strArg;
	CStringArray astrDocumentNames;
	int iProj = -1;

	CString strFilter;
	CPtrArray paWorkspaceEditors;
	BuildFilterList(strFilter, &paWorkspaceEditors,
					CPackage::GODI_WORKSPACEOPEN);

	LPPROJECTWORKSPACE pProjSysIFace = g_IdeInterface.GetProjectWorkspace();

	CPartFrame::LockWorkspace(TRUE);

	// ensure UI disabled if running from command line before opening doc
	if (m_bRunInvisibly && m_bInvokedCommandLine) // REVIEW
	{
		g_AutomationState.DisableUI();
		g_AutomationState.SetSaveChanges(FALSE);
	}

	LPBUILDSYSTEM pBldSysIFace;
	if (FAILED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace)))
		pBldSysIFace = NULL;
	for (pos = m_argList.GetHeadPosition(); pos != NULL;)
	{
		strArg = m_argList.GetNext(pos);

		if (IsSwitch(strArg[0]))
		{
				// FUTURE :UNDONE [dans 10-Oct-1993]
				// need error here about bad switch
		}
		else
		{
			// leave a trail because open exe as proj from cmd line requires
			// us to find an occurence of this arg in the raw command line
			// in order to give the rest of the args to the child correctly.
			m_strCurArg = strArg;

			// Do the same existence check the FileDialog does.
			if (!FileExists(strArg))
			{
				// "File does not exist"
				ErrorBox(ERR_File_NoExist, (LPCTSTR)strArg);
				continue;
			}

			// Convert it to a long file name version
			CString strLongArg=strArg;

			if(!::GetActualFileCase(strLongArg))
			{
					strLongArg=strArg;
			}

			CDocument *pDoc = OpenDocumentFile(strLongArg);
			if (pDoc == NULL)
					continue;

			astrDocumentNames.Add(pDoc->GetPathName());

			// check to see if it is a proj doc, if so, if it is an
			// exe from the command line, it gets the rest of the args
			// and we are done here.

			if (pBldSysIFace != NULL && pProjSysIFace != NULL &&
					(pProjSysIFace->IsWorkspaceDocument(pDoc) == S_OK))
			{
				iProj = astrDocumentNames.GetSize() - 1;
				int iType;
				pBldSysIFace->GetBuilderType(ACTIVE_BUILDER, &iType);
				if (iType == ExeBuilder)
				{
						if(!strTarg.IsEmpty())
								pBldSysIFace->SetRemoteTargetFileName(ACTIVE_BUILDER, strTarg);

						break;	// get out of the loop, we are done
				}
			}
		}
	}

	if (pBldSysIFace != NULL)
		pBldSysIFace->Release();

	if (pProjSysIFace != NULL)
	{
		if (pProjSysIFace->IsWorkspaceInitialised() == S_OK)
		{
			m_bEnableWorkspaceLoad = FALSE;
			bCreateNewProject = FALSE;
		}
	}

	// leave the arg list empty as a signal we are done with command
	// line processing
	m_strCurArg.Empty();
	m_argList.RemoveAll();

	CPartFrame::LockWorkspace(FALSE);

	if (bCreateNewProject)
		m_bEnableWorkspaceLoad = FALSE;

	// Unless it has been disabled (e.g. by JIT, specifying a project on the
	// command line, or by a package like RLTools), load the last workspace...
	if (m_bEnableWorkspaceLoad)
	{
		ASSERT(!m_jit.GetActive());
		ASSERT(iProj == -1);

		LoadLastProject();
	}

	// Move the files loaded from the command line to the front of the workspace [marklam]
	// The list is stepped from the tail (1st file loaded) along the list until the loaded
	//	 project is found or the head is reached. The list is then stepped in reverse order
	//	 placing each document's window on top of the others.
	// The document from the head of the list (last loaded) is then placed at the bottom, and
	//	 all the document windows between that and the active project are placed on top of that.
	// Any document could have disappeared, so names are used in the list which are looked up.

	if (astrDocumentNames.GetSize() != 0)
	{
		pMainFrame->m_pWndMDIClient->ShowWindow(SW_HIDE);

		CDocTemplate* pOpenTemplate;
		CDocument* pOpenDoc;
		CPartFrame* pFrame;

		HWND hwndAfter = HWND_TOP;
		HDWP hdwp = BeginDeferWindowPos(astrDocumentNames.GetSize());

		for (int i = 0; i < astrDocumentNames.GetSize(); i++)
		{
			pFrame = GetOpenFrame(astrDocumentNames[i],
					pOpenTemplate, pOpenDoc);

			if (pFrame != NULL)
			{
				if ((pFrame->GetStyle() & WS_VISIBLE) == 0)
				{
						pFrame->ShowWindow(SW_SHOWNOACTIVATE);
						hdwp = DeferWindowPos(hdwp, pFrame->m_hWnd,
								hwndAfter, 0, 0, 0, 0,
								SWP_NOSIZE | SWP_NOMOVE);
				}

				pOpenDoc->UpdateFrameCounts();
				pFrame->OnUpdateFrameTitle(TRUE);

				pFrame->SendMessageToDescendants(WM_INITIALUPDATE, 0, 0, TRUE);

				hwndAfter = pFrame->m_hWnd;
			}

			if (i == iProj)
				hwndAfter = HWND_BOTTOM;
		}

		ASSERT(hdwp != NULL);	// Could not move docs due to lack of system resources
		if (hdwp != NULL)
			VERIFY(EndDeferWindowPos(hdwp));

		if (theApp.m_bMaximizeDoc)
		{
			pFrame = (CPartFrame*) pMainFrame->MDIGetActive();
			if (pFrame != NULL && pFrame->IsKindOf(RUNTIME_CLASS(CPartFrame)))
				pFrame->ShowWindow(SW_SHOWMAXIMIZED);
		}

		pMainFrame->m_pWndMDIClient->ShowWindow(SW_SHOWNA);
		pMainFrame->m_pWndMDIClient->UpdateWindow();
	}

	// If -EXECUTE Command was passed on the command line, then we have to
	//	execute that command
	if (!strCommand.IsEmpty())
	{
		// Convert strCommand name to command ID
		UINT nIDCommand;
		if (theCmdCache.GetCommandID(strCommand, &nIDCommand))
		{
			m_pMainWnd->PostMessage(WM_COMMAND, nIDCommand, 0L);
		}
		else
		{
			ErrorBox(IDS_ERR_BAD_CMD, (LPCTSTR)strCommand);
		}
		m_fRunningMacro = TRUE;
		strCommand.Empty();
	}

	// Unload any package bitmaps that were loaded to help us build the menu structure or toolbars
	// These won't be referenced until customization begins (if ever), so they're just wasted memory
	UnloadPackageBitmaps();

	// NOTE: This needs to be done last, since any message boxes or
	//				 releasing of the CPU after this will cause us to crash.
	// FUTURE: move to MSVCSRC in OnInitPackage (which is last part of init)...
	if (m_jit.GetActive())
	{
		// Post a message to ourselves, so that
		// when the IDE is done initializing, it will
		// simulate an F5 (Go) command from the user.
		m_pMainWnd->PostMessage(
				WM_COMMAND,
				GET_WM_COMMAND_MPS(IDM_RUN_JIT_GO, 0, 0));
	}

	// If /NEWPROJ was specified on the command line and we did not load a
	// project for some reason already, create a new project now...
	if (bCreateNewProject)
	{
		CDocTemplate* pTemplate = GetTemplate(CLSID_WorkspaceDocument);
		if (pTemplate != NULL)
			pTemplate->OpenDocumentFile(NULL);
	}

#ifdef PKG_LOAD_TIME
	dwInitInstance = ::GetTickCount() - dwInitInstance;
	if(s_bLoadTime)
	{
		FILE *outfile = fopen("time.log", "w");

		DWORD dwPkgsLoadLibraryTime = 0;
		DWORD dwPkgsTypeLibTime = 0;
		DWORD dwPkgsInitPackageTime = 0;
		DWORD dwPkgsOnInit = 0;
		DWORD dwPkgsTotal = 0;

		fprintf(outfile, "Package   \tLoadLib\tTypeLib\tInitPkg\tOnInit\tTotal\n");
		for(i=0; i<nPkg; i++) {
			DWORD dwPkgTotal = dwaPkgLoadLibraryTime[i] + dwaPkgTypeLibTime[i] + dwaPkgInitPackageTime[i] + dwaPkgOnInit[i];
			fprintf(outfile, "%-10s\t%d\t%d\t%d\t%d\t%d\n", straPkgName[i],
					dwaPkgLoadLibraryTime[i], dwaPkgTypeLibTime[i], dwaPkgInitPackageTime[i], dwaPkgOnInit[i], dwPkgTotal );
			dwPkgsLoadLibraryTime += dwaPkgLoadLibraryTime[i];
			dwPkgsTypeLibTime	  += dwaPkgTypeLibTime[i];
			dwPkgsInitPackageTime += dwaPkgInitPackageTime[i];
			dwPkgsOnInit		  += dwaPkgOnInit[i];
			dwPkgsTotal 		  += dwPkgTotal;
		}
#ifdef _DEBUG
		fprintf(outfile, "devshld   \t0\t0\t0\t0\t%d\n", dwInitInstance - dwPkgsTotal);
#else
		fprintf(outfile, "devshl    \t0\t0\t0\t0\t%d\n", dwInitInstance - dwPkgsTotal);
#endif
		fprintf(outfile, "Total     \t%d\t%d\t%d\t%d\t%d\n",
				dwPkgsLoadLibraryTime, dwPkgsTypeLibTime, dwPkgsInitPackageTime, dwPkgsOnInit, dwInitInstance);
		fclose(outfile);
	}
#endif	// PKG_LOAD_TIME

#ifdef _MTTF
	// Run	MTTF only if the MTTF/Enable regkey is set to 1
	if(IsMTTFEnabled())
	{
	  InitMTTF( );
	}
#endif


	return TRUE;
}

////////////////////////////////////////////////////////////////////////////
// Just-In-Time debugging support
//
// FUTURE: see if this can be moved to MSVCSRC...  Note: for perf-
// ormance reasons, we might need to keep it here; in the case where we find
// some other instance to pass things off to, we don't want to waste time on
// loading MSVCSRC...  Perhaps this stuff can go in MSVC.EXE!
//
static BOOL InitJIT()
{
        // Note, this function returns non-zero if there is an error
        // loading JIT (command line arg errors).  This value is a resource
        // string ID so that we can display an error.  We cannot use
        // AfxMessageBox since we have no main frame yet.
        UINT errJit = ErrGetJITInfo(&theApp.m_argList, &theApp.m_jit);

        // Error with JIT command line.  Display error and bail
        if (errJit != 0)
        {
                CString strErr;
                CString strApp;

                strErr.LoadString(errJit);
                strApp.LoadString(AFX_IDS_APP_TITLE);
                ::MessageBox(NULL, strErr, strApp, MB_OK | MB_ICONEXCLAMATION);
                return FALSE;
        }

        // Note, we're checking GetEvent() here because GetActive() will
        // be set even if the user just did "msvc -p xxx", which is regular
        // attach-to-active-process debugging rather than just-in-time
        // debugging.
        if (theApp.m_jit.GetActive() && theApp.m_jit.GetEvent() && FFindOtherJitDebugger(&theApp.m_jit))
        {
                // We could return FALSE instead of calling exit() ourselves,
                // but that has the mildly undesirable effect of causing Sushi
                // to return a nonzero exit code.
                exit(0);
        }

        return TRUE;
}

BOOL IsMSVCWindow(HWND hwnd)
{
        // Is the passed HWND an MSVC main frame?
        char szClass[256];
        return (GetClassName(hwnd, szClass, sizeof(szClass)) != 0 &&
                lstrcmp(_T("MSVCDBG50"), szClass) == 0);
}

// JitEnumWindows
//
// EnumWindows callback function to look for a just-in-time
// debugger.
//
// NOTE: This routine should NOT put up any error messages!
// When it gets called, very little if any initialization has
// been done.  If anything goes wrong, it should just return
// TRUE (meaning to continue enumerating).

static BOOL CALLBACK JitEnumWindows(HWND hwnd, LPARAM lparam)
{
        static UINT     WU_QUERYJIT = RegisterMessage("QueryJit");
        static UINT     WU_BEGINJIT = RegisterMessage("BeginJit");
        CJit *          pjit = (CJit *) lparam;
        HANDLE          hProcess;
        HANDLE          hEventDup;
        DWORD           pidMSVC;
        DWORD           dwSendResult = 0;

        // Is the passed HWND an MSVC main frame?
        if (!IsMSVCWindow(hwnd))
                return TRUE;    // no: keep enumerating windows

        // Does the other process want to be the just-in-time debugger?
        if (!SendMessageTimeout(hwnd, WU_QUERYJIT, pjit->GetPid(), 0,
                SMTO_ABORTIFHUNG, 2000, &dwSendResult)
                || !dwSendResult)
        {
                return TRUE;    // no: keep enumerating windows
        }

        if (!GetWindowThreadProcessId(hwnd, &pidMSVC))
        {
                // perhaps the window just died or something
                return TRUE;    // okay fine, keep enumerating windows
        }

        // Try to get a handle to the other process
        if (!(hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pidMSVC)))
        {
                // OpenProcess failed, don't know why (security perhaps)
                return TRUE;    // okay fine, keep enumerating windows
        }

        if (!DuplicateHandle(GetCurrentProcess(), pjit->GetEvent(), hProcess,
                &hEventDup, 0, FALSE, DUPLICATE_SAME_ACCESS))
        {
                // couldn't duplicate handle for some strange reason
                return TRUE;    // okay fine, keep enumerating windows
        }

        if (!SendMessage(hwnd, WU_BEGINJIT, pjit->GetPid(), (LPARAM) hEventDup))
        {
                // the other process rejected the WU_BEGINJIT for some reason
                return TRUE;    // okay fine, keep enumerating windows
        }

        // The other process has now begun debugging.  We can close our copy
        // of the event handle and disable just-in-time debugging.
        CloseHandle(pjit->GetEvent());

        return FALSE;           // stop enumerating windows
}

// FFindotherJitDebugger
//
// See if there are command line arguments for just-in-time
// debugging, and if so, see also if there is another copy of
// MSVC already running which would like to be the debugger
// for the specified process.  If these conditions are met,
// we will tell that other copy of MSVC to begin debugging,
// and then this new copy will just exit.
//
// NOTE: This routine should NOT put up any error messages!
// When it gets called, very little if any initialization has
// been done.  If anything goes wrong, it should just return
// FALSE.

static BOOL FFindOtherJitDebugger(CJit* pjit)
{
        return !EnumWindows(JitEnumWindows, (LPARAM) pjit);
}

static UINT ErrGetJITInfo(CStringList* pArgList, CJit* pjit)
{
        CPath           path;
        CString         strExe = ".exe";
        POSITION        pos, posCur;

        // "/P xxxxx [/E yyyyy]" is for just-in-time debugging:
        // xxxxx is the (decimal) Process Id, and yyyyy is the
        // (decimal) event handle (see NT's post-mortem debugging
        // documentation).  (This command-line syntax was chosen
        // because it is consistent with NTSD and DRWTSN32.)

        // iterate through args
        //
        pos = pArgList->GetHeadPosition();
        while ((posCur = pos) != 0)
        {
                CString strArg = pArgList->GetNext(pos);

                if (IsSwitch(strArg[0]) && strArg.GetLength() >= 2)
                {
                        BOOL    fRemoveArg = FALSE;

                        TCHAR   tch = strArg[1];
                        CString strT = strArg.Right(strArg.GetLength() - 1);
                        CharUpperBuff ( &tch, 1 );

                        switch (tch)
                        {
                        case 'E':
                                if (strT.GetLength() == 1 || _istdigit(strT[1]))
                                {
                                        // "/P xxxxx [/E yyyyy]" is for Application Error
                                        // (post-mortem) debugging: xxxxx is the (decimal)
                                        // Process Id, and yyyyy is the (decimal) event handle
                                        // (see post-mortem debugging docs).  (This syntax was
                                        // chosen because it is consistent with NTSD and DRWTSN32.)

                                        // always remove the arg--we give the errors
                                        fRemoveArg = TRUE;

                                        // /E eventid already specified?
                                        if( pjit->GetEvent() != 0 )
                                        {
                                                // Two '/E' parameters
                                                return ERR_Switch_TwiceE;
                                        }

                                        if (strT.GetLength() == 1)
                                        {
                                                // remove this arg and get the next one
                                                if (pos != NULL)
                                                {
                                                        pArgList->RemoveAt(posCur);
                                                        posCur = pos;
                                                        strT = pArgList->GetNext(pos);
                                                }
                                                else
                                                {
                                                        return ERR_SlashE_NoEventNumber;
                                                }
                                        }
                                        else
                                        {
                                                // skip past 'E' to get to event id
                                                strT = strT.Right(strT.GetLength() - 1);
                                        }

                                        const TCHAR * ptch = strT;

                                        // Important: the use of _tcstoul() is good because
                                        // it allows the user to enter either a decimal
                                        // number or a hex number (if preceded by "0x")
                                        HANDLE hEvent = (HANDLE) _tcstoul(ptch, (char **)&ptch, 0);
                                        if (hEvent == 0 || *ptch != '\0')
                                        {
                                                return ERR_SlashE_NoEventNumber;
                                        }

                                        // set JIT elements
                                        pjit->SetEvent(hEvent);
                                }
                                break;

                        case 'P':
                                if (strT.GetLength() == 1 || _istdigit(strT[1]))
                                {
                                        // "/P xxxxx [/E yyyyy]" is for Application Error
                                        // (post-mortem) debugging: xxxxx is the (decimal)
                                        // Process Id, and yyyyy is the (decimal) event handle
                                        // (see post-mortem debugging docs).  (This syntax was
                                        // chosen because it is consistent with NTSD and DRWTSN32.)

                                        // always remove the arg--we give the errors
                                        fRemoveArg = TRUE;

                                        if (pjit->GetPid() != 0)
                                        {
                                                // Two '/P' parameters
                                                return ERR_Switch_TwiceP;
                                        }

                                        if (strT.GetLength() == 1)
                                        {
                                                // remove this arg and get the next one
                                                if (pos != NULL)
                                                {
                                                        pArgList->RemoveAt(posCur);
                                                        posCur = pos;
                                                        strT = pArgList->GetNext(pos);
                                                }
                                                else
                                                {
                                                        return ERR_SlashP_NoPidNumber;
                                                }
                                        }
                                        else
                                        {
                                                // skip past 'P' to get to pid
                                                strT = strT.Right(strT.GetLength() - 1);
                                        }

                                        const TCHAR * ptch = strT;

                                        // Important: the use of _tcstoul() is good because
                                        // it allows the user to enter either a decimal
                                        // number or a hex number (if preceded by "0x")
                                        DWORD pid = (DWORD) _tcstoul(ptch, (char **)&ptch, 0);
                                        if (pid == 0 || *ptch != '\0')
                                        {
                                                return ERR_SlashP_NoPidNumber;
                                        }

                                        // set JIT elements
                                        pjit->SetPid(pid);
                                        VERIFY(pjit->FSetPath("UNKNOWN.EXE", FALSE));
                                }
                                break;
                        }

                        if (fRemoveArg)
                                                        pArgList->RemoveAt(posCur);
                }
                else
                {
#if 0
                                        // if we see an exe on the command line, the entire remainder
                                        // of the command line consists of the command line to be
                                        // passed to that exe, rather than options for MSVC.
                                        //
                                        if (path.Create(strArg) &&
                                                strExe.CompareNoCase(path.GetExtension()) == 0)
                                        {
                                                break;
                                        }
#else // 0
                                        // If the argument is NOT a command line-switch, stop processing
                                        // immediately since there may be an exe/makefile which the
                                        // user is passing args to.  (Basically, they're not intended
                                        // for JIT!)
                                        if (!IsSwitch(strArg[0]))
                                        {
                                                break;
                                        }
#endif // 0
                }
        }

        // Did user specify /E without /P?

        if (pjit->GetEvent() && !pjit->GetPid())
        {
                        return ERR_Missing_Jit_SwitchP;
        }

        // If /P specified, activate just-in-time debugging
        if (pjit->GetPid() != 0)
        {
                        pjit->SetActive(TRUE);
                        theApp.m_bEnableWorkspaceLoad = FALSE;
        }

        return 0;
}

int CTheApp::ExitInstance()
{
        while (!m_packets.IsEmpty())
        {
                CPacket* pPacket = (CPacket*) m_packets.RemoveHead();
                delete pPacket;
        }

        g_IdeInterface.Terminate();

        {
                if (CShellRecorder::m_pMacroRecorder)
                        CShellRecorder::m_pMacroRecorder -> Release();
        }

        // This is a hack.  W/o this we assert in debug mode while
        // unloading the edit package because too many references are
        // being held
        if (!m_bInvokedCommandLine)
        {
            UnloadPackages();


        // uninit Office's StdComponentManager library after all packages that
        //      might be using it have been unloaded. (this is separate from calling
        //      TermStdCompMgr because this releases the library, not the manager
        //      itself -- equivalent to DLL_PROCESS_DETACH cleanup).
#ifndef NOIPCOMP
            CMLibTerm();
#endif
        }

#ifdef _MTTF
        // Run  MTTF only if the MTTF/Enable regkey is set to 1
        if(IsMTTFEnabled())
        {
          MTTFOnExit( );
        }
#endif

#ifdef _CMDLOG
        CmdLogOnExit( );
#endif
	if (m_hLogFile != NULL)
	{
		CloseHandle(m_hLogFile);
		m_hLogFile = NULL;
	}

        // If invoked via the command line then pause a bit so the
        // user can view the output results
        if (m_bInvokedCommandLine && g_bConsoleCreated)
        {
            Sleep(10000);
        }

        return m_msgCur.wParam; // Returns the value from PostQuitMessage
}

#ifdef _MTTF

/////////////////////////////////////////////////////////////////////////////
// Mean time to failure hanlding

// FFindAnotherMSVC : Look for another copy of msvc[d].exe in the system.
// Returns TRUE if one is found, FALSE otherwise.

static BOOL CALLBACK MTTFEnumWndProc(HWND hwnd, LPARAM lParam)
{
        ASSERT(lParam == 0);

        return !IsMSVCWindow(hwnd);
}

static BOOL FFindAnotherMSVC( )
{
        return !EnumWindows(MTTFEnumWndProc, 0);
}

static char BASED_CODE szMTTF[] = "MTTF" ;
static char BASED_CODE szAbnormalTermination[] = "AbnormalTermination" ;
static char BASED_CODE szTimeSinceLastFailure[] = "TimeSinceLastFailure" ;
static char BASED_CODE szTimeCurSession[] = "TimeCurSession" ;
static char BASED_CODE szVersion[] = "VersionNo";
static char BASED_CODE szTestRun[] = "AUTO" ;
static char BASED_CODE szDoMTTF[] = "EnableMTTF";
static char BASED_CODE szMTTFEnable[] = "Enable";
static int  tickMinutes = 5;  // Update info every 5 minutes.
static int  timeUpdate = tickMinutes * 60 * 1000  ; // convert to milliseconds.

static int      terminatedNormally = 0 ;
static int      terminatedAbnormally = 1 ;
static int  noPrevEntry = 2 ;


BOOL IsMTTFEnabled(void)  // return true if the MTTF regkey Enable == 1
{
  if(GetRegInt(szMTTF,szMTTFEnable,0) == 1)
   return TRUE;
  return FALSE;
}


VOID CALLBACK MTTFTimerProc(HWND, UINT, UINT, DWORD)
{

        static BOOL  bCurrentlyInTimerCallBack = FALSE;

        if(bCurrentlyInTimerCallBack) return;
        bCurrentlyInTimerCallBack = TRUE;

        //  AFX_MANAGE_STATE(AfxGetModuleState());
        // IStudio bug #5479
        // when one of our COM servers has modal UI displayed and the
        // timer callback is fired, we need to get the app's module
        // state and not the active module's module state.
        AFX_MANAGE_STATE(AfxGetAppModuleState());

        ASSERT( _tcsicmp(_T(theApp.m_pszAppName), _T("Microsoft Visual C++")) == 0 );


        ASSERT( ((CTheApp *)AfxGetApp( ))->m_bMTTF );

        int timeSinceLastFailure = GetRegInt(szMTTF, szTimeSinceLastFailure, 0);
        int timeCurSession = GetRegInt(szMTTF, szTimeCurSession,0);

        ASSERT(timeCurSession <= timeSinceLastFailure);

        // Increment the counts by 1 to indicate a timer tick.

        VERIFY( WriteRegInt(szMTTF, szTimeCurSession, timeCurSession + 1 ));
        VERIFY( WriteRegInt(szMTTF, szTimeSinceLastFailure, timeSinceLastFailure + 1));

        bCurrentlyInTimerCallBack = FALSE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// CMTTFDialog dialog

class CMTTFDialog : public CDialog
{
        // Construction
public:
        CMTTFDialog(CWnd* pParent = NULL);   // standard constructor
        ~CMTTFDialog(void);                                     // dtor
        // Dialog Data
        //{{AFX_DATA(CMTTFDialog)
        enum { IDD = IDD_MTTF };
        // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA

        BOOL m_bExpected;
        BOOL m_bFeatureSelected;
        BOOL m_bFailureCauseSelected;
        CListBox areaCombo ;
        int areaIndex ;

        CEdit   infoEdit ;
        enum {LIMIT_INFO_TEXT = 512 };
        CString strInformation ;

        enum CauseOfFailure { mttfAssertion, mttfException, mttfHang, mttfOther,mttfRepro,mttfError,mttfOrdinal };
        CauseOfFailure failureType ;
        CString strFailureType;


        // Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CMTTFDialog)
protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

        // Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CMTTFDialog)
        virtual BOOL OnInitDialog();
        virtual void OnOK();
        virtual void OnCancel();
        afx_msg void OnSelchangeList1();
        afx_msg void OnRadioAssert();
        afx_msg void OnRadioException();
        afx_msg void OnRadioHang();
        afx_msg void OnRadioOther();
        afx_msg void OnRadioRepro();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
private:
        void AttemptEnableOKFromRadioButton(int nID);
};

// CMTTFDialog dialog


CMTTFDialog::CMTTFDialog(CWnd* pParent /*=NULL*/)
: CDialog(CMTTFDialog::IDD, pParent),m_bExpected(FALSE),
m_bFailureCauseSelected(FALSE),m_bFeatureSelected(FALSE)
{
        //{{AFX_DATA_INIT(CMTTFDialog)
        // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


CMTTFDialog::~CMTTFDialog(void)
{
        infoEdit.Detach();
        areaCombo.Detach();
}


void CMTTFDialog::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CMTTFDialog)
        // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMTTFDialog, CDialog)
//{{AFX_MSG_MAP(CMTTFDialog)
ON_LBN_SELCHANGE(IDC_FEATURE, OnSelchangeList1)
ON_BN_CLICKED(IDC_ASSERT, OnRadioAssert)    // assertion
ON_BN_CLICKED(IDC_EXCEPTION, OnRadioException)    // exception
ON_BN_CLICKED(IDC_HANG, OnRadioHang)    // hang
ON_BN_CLICKED(IDC_OTHER, OnRadioOther)    // other
ON_BN_CLICKED(IDD_MTTF, OnRadioRepro)    // repro
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMTTFDialog message handlers


static char *aszFeature[] =
{
        "Accel Edit",
        "Automation",
        "ActiveX Layout Control",
        "Binary Edit",
        "Browser",
        "Build System",
        "ClassView",
        "Code Edit",
        "Component Gallery",
        "Config",
        "DataTools (daVinci)",
        "Debugger",
        "Denali",
        "Designer Controls",
        "Dialog Edit",
        "File I/O",
        "Global",
        "Image Edit",
        "InfoViewer",
        "Menu Edit",
        "Menus / Toolbars",
        "Multimedia Tools",
        "Other",
        "Project Edit",
        "Res Browser",
        "Res Symbols",
        "Script Editor",
        "Shell",
        "SQL Data Thang",
        "SQL Debugging",
        "String Edit",
        "Trident",
        "Unknown",
        "Version Edit",
        "Web Project Editor",
        "WebScope (daVinci)",
        "WizardBar",
        "Wizards"
};

static char *aszCause[CMTTFDialog::mttfOrdinal] =
{
        "Assertion",
        "Exception",
        "Hang",
        "Other",
        "Repro",
        "Error"
};



BOOL CMTTFDialog::OnInitDialog()
{
        // attach combobox, and add elements
        areaCombo.Attach(GetDlgItem(IDC_FEATURE)->GetSafeHwnd()) ;
        int cItems = sizeof(aszFeature)/sizeof(aszFeature[0]) ;
        for ( int i = 0 ; i < cItems ; i++ ) areaCombo.AddString(aszFeature[i]);

        // Limit the text in the information edit box.
        infoEdit.Attach(GetDlgItem(IDC_INFORMATION)->GetSafeHwnd());
        infoEdit.LimitText(LIMIT_INFO_TEXT);

        // disable OK until user selects failure type and area
        GetDlgItem(IDOK)->EnableWindow( FALSE );

        return CDialog::OnInitDialog( );
}

void CMTTFDialog::OnOK()
{

        m_bExpected = FALSE ;

        // get failure type
        //  int nFailureType = GetCheckedRadioButton(IDC_ASSERT,IDC_OTHER);
        int nFailureType = GetCheckedRadioButton(IDD_MTTF,IDC_OTHER);
        switch(nFailureType)
        {
    case IDC_ASSERT:    failureType = mttfAssertion; break;
    case IDC_EXCEPTION: failureType = mttfException; break;
    case IDC_HANG:      failureType = mttfHang; break;
    case IDC_OTHER:     failureType = mttfOther; break;
    case IDD_MTTF:      failureType = mttfRepro; break;
    default:            failureType = mttfError; break;
        }

    // get failure area: Which part of the product caused the problem.
        areaIndex = areaCombo.GetCurSel();
        ASSERT(areaIndex != CB_ERR);
        strFailureType = aszFeature[areaIndex];

    // get the additional information that the user might have typed in.
        infoEdit.GetWindowText(strInformation);

    // call parent class
        CDialog::OnOK();
}


void CMTTFDialog::OnCancel()
{
        return;   // force the user to input a failure type and feature
}

void CMTTFDialog::OnSelchangeList1()
{
        m_bFeatureSelected = TRUE;
        if(m_bFailureCauseSelected)                   // is failure type selected
                GetDlgItem(IDOK)->EnableWindow( TRUE );      // enable OK to exit dialog
}

void CMTTFDialog::AttemptEnableOKFromRadioButton(int nRadioButtonID)
{                                               // is failure type selected
        if(((CButton*)GetDlgItem(nRadioButtonID))->GetCheck() == 1)
        {
                m_bFailureCauseSelected      = TRUE;
                if(m_bFeatureSelected)                      // is failure area selected
                        GetDlgItem(IDOK)->EnableWindow( TRUE );    // enable OK to exit dialog
        }
}

void CMTTFDialog::OnRadioAssert()
{
        AttemptEnableOKFromRadioButton(IDC_ASSERT);
}

void CMTTFDialog::OnRadioException()
{
        AttemptEnableOKFromRadioButton(IDC_EXCEPTION);
}

void CMTTFDialog::OnRadioHang()
{
        AttemptEnableOKFromRadioButton(IDC_HANG);
}
void CMTTFDialog::OnRadioOther()
{
        AttemptEnableOKFromRadioButton(IDC_OTHER);
}

void CMTTFDialog::OnRadioRepro()
{
        AttemptEnableOKFromRadioButton(IDD_MTTF);
}

////////////////////////////////////////////////////////////////////////////////////////////////////

static void TransportMTTFInfo( const CMTTFDialog *pDlg, int elapsedTime,
                                                          int timeSinceFailure, const CString& strVerNo)
{
        // Send the MTTF information over the net to the database.
        // Just use a hard-coded file name as this is completely
        // internal.
#if defined(TARGMAC68K) || defined(TARGMACPPC)
        //        static char szLogFileName[] = "\\\\dtqalogs\\db\\vcemttf\\mttf.dat";
        static char szLogFileName[] = "\\\\lang1\\VCQALOGS\\mttfmac.dat";
        static char szLocalLogFileName[] = "mttfmac.dat";
#else
        //        static char szLogFileName[] = "\\\\dtqalogs\\db\\mttf\\mttf.dat";
        static char szLogFileName[] = "\\\\lang1\\VCQALOGS\\mttf.dat";
        static char szLocalLogFileName[] = "mttf.dat";
#endif
        const int maxRetries = 1;
        HANDLE hFile ;

        if ( pDlg->m_bExpected )
                return ; // The failure was expected => no log entry.

        {

                HWND hwnd;

                hwnd = ::CreateWindow(
                        "Button",  // pointer to registered class name
                        "Looking for MTTF Log File on the Network...",     // pointer to window name
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,     // window style
            (::GetSystemMetrics(SM_CXSCREEN) - 340)/2,    // horizontal position of window
            (::GetSystemMetrics(SM_CYSCREEN)-100)/2,        // vertical position of window
            340,   // window width
            100,       // window height
            ::GetDesktopWindow(),  // handle to parent or owner window
            NULL,      // handle to menu or child-window identifier
            AfxGetInstanceHandle(),        // handle to application instance
            NULL       // pointer to window-creation data
                        );

        if(hwnd != NULL)
        {
                        VERIFY(::SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW));
                        VERIFY(::UpdateWindow(hwnd));
        }
                //Sleep(10000);

        //try to open file on network drive
        if ( (hFile = CreateFile(szLogFileName,GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,NULL,OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,NULL)
                        ) == INVALID_HANDLE_VALUE )
        {  // try to open file on local drive
                        if(hwnd !=NULL) ::SetWindowText(hwnd, "Looking for MTTF Log File on a Local Drive...");

                        CString szFullPath;
                        LPTSTR  szFullPathBuffer = szFullPath.GetBufferSetLength(MAX_PATH);
                        GetModuleFileName(NULL, szFullPathBuffer, (MAX_PATH-(strlen(szLocalLogFileName)+1)));
                        szFullPath.ReleaseBuffer();
                        int nEndPos = szFullPath.ReverseFind('\\');
                        CString szFileName(szFullPath.Left(nEndPos + 1) + szLocalLogFileName);

                        if ( (hFile = CreateFile(szFileName,GENERIC_READ|GENERIC_WRITE,
                                FILE_SHARE_READ,NULL,OPEN_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,NULL)
                                ) == INVALID_HANDLE_VALUE )
                        {
                                return;  // failed so just bail
                        }

                        if(hwnd !=NULL)
                        {
                                ::SetWindowText(hwnd, "Logging MTTF data to Local Drive...");
                                Sleep(2000);
                        }
        }
        else
        {
                        if(hwnd !=NULL)
                        {
                                ::SetWindowText(hwnd, "Logging MTTF data to the Network...");
                                Sleep(2000);
                        }
        }
                if(hwnd != NULL) ::DestroyWindow(hwnd);
        }

        // these are commented out for the change above and need to be left in if the create window code from above is removed
        //        for (int i = 0; i < maxRetries ; i++ )
        //        {
        //                if ( (hFile = CreateFile(szLogFileName,GENERIC_READ|GENERIC_WRITE,
        //                                                                FILE_SHARE_READ,NULL,OPEN_ALWAYS,
        //                                                                FILE_ATTRIBUTE_NORMAL,NULL)
        //                          ) != INVALID_HANDLE_VALUE )
        //                {
        //                        break;
        //                }
        //                Sleep(300); // wait 0.3 seconds if it failed.
        //        }
        //        if ( i == maxRetries )
        //                return ; // No luck couldn't open the file.

        // Start writing from the end of the file.
        SetFilePointer(hFile,0,NULL,FILE_END);

        // Write out the relevant information to the file in the
        // following format.
        // 10/6/93,2.00.3278,SANJAYS2,Time Since last failure,
        // time in last session,Cause,Feature,"Comments"
        const DWORD MAX_SIZE = 512;
        char buffer[MAX_SIZE]; // Buffer to hold intermediate values.
        char logString[MAX_SIZE * 2]; // Complete string.
        DWORD  cBytesWritten ;
        //      char *pchQuote;                 // pointer used to strip quotes from additional info

        _strdate(logString); // get current date in mm/dd/yy form.
        lstrcat(logString,",");


        // Write out the version No next.
        lstrcat(logString,strVerNo);
        lstrcat(logString,",");

        // Computer name.
        GetComputerName(buffer,(LPDWORD)&MAX_SIZE);
        lstrcat(logString,buffer);
        lstrcat(logString,",");


        // time since last failure and elapsed time in last session.
        wsprintf(buffer,"%d,%d,",timeSinceFailure,elapsedTime);
        lstrcat(logString,buffer);

        //      Cause of failure.
        wsprintf(buffer,"%s,",aszCause[pDlg->failureType]);
        lstrcat(logString,buffer);

        // Component area where the failure happened.
        wsprintf(buffer,"%s,",aszFeature[pDlg->areaIndex]);
        lstrcat(logString,buffer);

        // Finally the string which holds the additional information.
        int ich;
        while ( (ich = pDlg->strInformation.Find( '\"' )) != -1 )// convert quotes to inquotes
                ((CString )pDlg->strInformation).SetAt( ich, '\'' );

        wsprintf(buffer,"\"%.150s\"\n",pDlg->strInformation);
        lstrcat(logString,buffer);

        WriteFile(hFile,logString, lstrlen(logString),&cBytesWritten,NULL);

        // We are all done, close the file.
        CloseHandle(hFile);
}

// This constant should change for each version
static const TCHAR  * pctcMTTFSemName= "MTTFSem5.0";

static
BOOL
bIsOnlyInstanceRunning(void)
{
        HANDLE hSem;

        // Try to Create or open a named semaphore.
        hSem = CreateSemaphore(
        NULL,          // security attributes
        0,             // initial count
        1,             // maximum count
        pctcMTTFSemName); // semaphore name

        // Close handle and return FALSE if existing semaphore was opened.
        if (hSem != NULL && GetLastError() == ERROR_ALREADY_EXISTS)
        {
                CloseHandle(hSem);
                return FALSE; // another instance is running
        }
        // note: This code depends on the OS to clean up the open semaphore when the program exits.
        return  TRUE ;
}


void CTheApp::InitMTTF( )
{
        CString str = GetRegistryKeyName( );

        // Special check to ensure that sniff test runs,
        // do not contribute to the MTTF numbers.
        // We just check to see if the last four chars
        // are the string specified by szTestRun.

        if ( str.Right(lstrlen(szTestRun)) == szTestRun )
                m_bMTTF = FALSE ;

        // If we have two copies of MSVC running simultaneously,
        // don't do the update stuff this time around.

        // determine if we are running
        //    if ( FFindAnotherMSVC( ) ) m_bMTTF = FALSE;

        if (! bIsOnlyInstanceRunning( ) ) m_bMTTF = FALSE;

#if 0   // fully re-enable MTTF for retail builds (temporary) [waltcr]
#ifndef _DEBUG

        // If this is a retail build and the szDoMTTF key is not set to true,
        // disable MTTF [stevesk]
        if( m_bMTTF )
        {
                const NOMTTF = 0;

                int doMTTF = GetRegInt( szMTTF, szDoMTTF, 0 );

                if( doMTTF == NOMTTF )
                        m_bMTTF = FALSE;
        }
#endif // _DEBUG
#endif // 0

        if ( m_bMTTF )
        {
                int bPrevEntry = GetRegInt(szMTTF, szAbnormalTermination, noPrevEntry);


                if ( bPrevEntry == terminatedAbnormally )
                {
                        // It didn't work the last time over.
                        // Put up the dialog box asking the user
                        // about the failure.
                        CMTTFDialog dlg ;

                        // NOTE: Chicago Build 86 has problems with certain dialog boxes.
                        // Stub this one out since we hit it all the time.
                        // VERIFY ( dlg.DoModal( ) == IDOK );
                        //#pragma message("Remove Chicago hack after Build 87.")
                        dlg.DoModal();

                        int timeCurSession = GetRegInt(szMTTF, szTimeCurSession, 0);
                        int timeSinceLastFailure = GetRegInt(szMTTF, szTimeSinceLastFailure, 0);

                        CString strVerNo = GetRegString(szMTTF, szVersion,"0.00.0000");

                        TransportMTTFInfo(&dlg, (timeCurSession * tickMinutes),
                                (timeSinceLastFailure * tickMinutes),strVerNo );

                        // If the failure was an unexpected one, then
                        // start over counting the timeSinceLastFailure.
                        if ( !dlg.m_bExpected )
                                VERIFY(WriteRegInt(szMTTF, szTimeSinceLastFailure, 0 ));
                }
                else if ( bPrevEntry == noPrevEntry )
                {
                        // Set the elapsed time without failure to 0 as well, if
                        // this is the first time an MTTF entry is being made.
                        VERIFY(WriteRegInt(szMTTF, szTimeSinceLastFailure, 0 ));
                }

                VERIFY(WriteRegInt(szMTTF, szAbnormalTermination, terminatedAbnormally));
                VERIFY(WriteRegInt(szMTTF, szTimeCurSession, 0));

                // Write the version no. of apstudio as a string to the registry.
                {
                        TCHAR   rgchModName[_MAX_PATH];
                        DWORD   dwHandle, dwVerInfoSize;
                        unsigned int dwValueSize;
                        VOID *  pvVerInfo;
                        VOID *  pvValue;

                        GetModuleFileName(NULL, rgchModName, sizeof(rgchModName) / sizeof(TCHAR));

                        if (dwVerInfoSize = GetFileVersionInfoSize(rgchModName, &dwHandle))
                        {
                                pvVerInfo = new TCHAR[dwVerInfoSize];
                                if (GetFileVersionInfo(rgchModName, dwHandle, dwVerInfoSize, pvVerInfo))
                                {
                                        if (VerQueryValue(      pvVerInfo,
                                                "\\StringFileInfo\\040904b0\\FileVersion", // "\\StringFileInfo\\040904E4\\FileVersion",
                                                &pvValue,
                                                &dwValueSize))
                                        {
                                                wsprintf(str.GetBufferSetLength(64),
                                                        "%s", pvValue);
                                                str.ReleaseBuffer();
                                        }
                                }

                                delete [] pvVerInfo;
                        }
                }

                VERIFY(WriteRegString(szMTTF, szVersion, str));

                if ( (m_timerMTTF = ::SetTimer(NULL,0,timeUpdate, MTTFTimerProc)) == 0 )
                {
                        // Could not set a timer succesfully.
                        m_bMTTF = FALSE;
                }
        }
}

void CTheApp::MTTFOnExit ()
{
        if ( m_bMTTF )
        {
                // Update the registry entry to indicate that we succesfully
                // terminated sushi.
                VERIFY(WriteRegInt(szMTTF, szAbnormalTermination, terminatedNormally));

                ::KillTimer(NULL, m_timerMTTF);
        }
}


#endif // _MTTF


#ifdef _CMDLOG

static int  tickCmdLogMinutes = 5;  // Update info every 5 minutes.
static int  timeCmdLogUpdate = tickCmdLogMinutes * 60 * 1000; // convert to milliseconds.

VOID CALLBACK CmdLogTimerProc(HWND, UINT, UINT, DWORD)
{
        ASSERT(((CTheApp *)AfxGetApp())->m_bCmdLog);

        ((CTheApp *)AfxGetApp())->UpdateCmdLog();
}

void CTheApp::InitCmdLog()
{
        if(m_bCmdLog)
        {
                if ( (m_timerCmdLog = ::SetTimer(NULL, 0, timeCmdLogUpdate, CmdLogTimerProc)) == 0 )
                {
                        // Could not set a timer succesfully.
                        m_bCmdLog = FALSE;
                }
        }
}

void CTheApp::CmdLogOnExit()
{
        if(m_bCmdLog)
        {
                ::KillTimer(NULL, m_timerCmdLog);
                UpdateCmdLog();
        }
}

void CTheApp::UpdateCmdLog()
{
        // Write the command log to disk.  The log maintained in memory is a delta since
        // the last disk update.  The log is thus read from the disk first, and then written
        // back out with the deltas added.

        ASSERT(m_bCmdLog);

        CString szFullPath;
        LPTSTR  szFullPathBuffer = szFullPath.GetBufferSetLength(MAX_PATH);
        GetModuleFileName(NULL, szFullPathBuffer, MAX_PATH);
        szFullPath.ReleaseBuffer();
        int nEndPos = szFullPath.ReverseFind('\\');

        CString szFileName(szFullPath.Left(nEndPos + 1) + "command.log");

        CFileSaver saver(szFileName);
    if (!saver.CanSave())
                return;     // Don't bother if we can't save.

        const int               nMaxRetries = 5;
        CFile                   cmdLog;
        CFileException  Error;
        int                             i;

        // Command log file is opened in exclusive mode to lock out other instances temporarily.
        // FUTURE: Is 10 retries enough?  Too much?
        for (i = 0; !cmdLog.Open(szFileName, CFile::modeRead /*| CFile::shareExclusive*/, &Error) && (i < nMaxRetries); i++)
                Sleep(250);

        BOOL            bLogOpen = (i < nMaxRetries);
        CCmdMap         cmdTableTemp;
        CCmdMap*        pCmdTable = &cmdTableTemp;

        TRY
        {
                if(bLogOpen)
                {
                        CArchive arLoad(&cmdLog, CArchive::load | CArchive::bNoFlushOnDelete);
                        cmdTableTemp.Serialize(arLoad);
                        arLoad.Close();

                        for( POSITION pos = m_cmdTable.GetStartPosition(); pos != NULL; )
                        {
                                WORD            key;
                                CObject*        value;

                                m_cmdTable.GetNextAssoc( pos, key, value );
                                cmdTableTemp.Update(key, (DWORD)value);
                        }
                }
                else
                {
                        if (Error.m_cause != CFileException::fileNotFound)
                                return;
                        else
                                pCmdTable= &m_cmdTable;
                }
        }
        CATCH (CFileException, e)
        {
                cmdLog.Abort();
                return;
        }
        CATCH (CArchiveException, e)
        {
                cmdLog.Abort();
                pCmdTable = &m_cmdTable;
        }
        END_CATCH

        CFile tempLog;

        TRY
        {
                if(!tempLog.Open(saver.GetSafeName(), CFile::modeCreate | CFile::modeWrite ))
                        AfxThrowFileException(CFileException::generic);

                CArchive arStore(&tempLog, CArchive::store | CArchive::bNoFlushOnDelete);
                pCmdTable->Serialize(arStore);
                arStore.Close();
                tempLog.Close();

                if(bLogOpen)
                        cmdLog.Close();

                if(saver.Finish())
                        m_cmdTable.RemoveAll();
        }
        CATCH (CException, e)
        {
                if(e->IsKindOf(RUNTIME_CLASS(CFileException)) || e->IsKindOf(RUNTIME_CLASS(CArchiveException)))
                {
                        cmdLog.Abort();  // Need to unlock file.
                        tempLog.Abort();
                }
                else
                {
                        THROW_LAST();
                }
        }
        END_CATCH
}

void CCmdMap::Update(WORD wKey, DWORD nNewCount)
{
        CObject*        nOldCount;

        if(!Lookup(wKey, nOldCount))
                nOldCount = (CObject*)0;
        SetAt(wKey, (CObject*)((DWORD)nOldCount + nNewCount));
}

void CCmdMap::Serialize(CArchive& ar)
{
        ASSERT_VALID(this);

        CObject::Serialize(ar);

        if (ar.IsStoring())
        {
                ar << (WORD) m_nCount;
                if (m_nCount == 0)
                        return;  // nothing more to do

                POSITION        pos;
                WORD            key;
                CObject*        value;

                for( pos = GetStartPosition(); pos != NULL; )
                {
                        GetNextAssoc( pos, key, value );
                        ar << key;
                        ar << (DWORD)value;
                        //                      SetAt(key, (CObject*)0);
                }

                //              FUTURE: The code below is more efficient, but relies on the underlying implementation,
                //                                              which may change.  Do we want to use it anyway?
                //              ASSERT(m_pHashTable != NULL);
                //              for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
                //              {
                //                      CAssoc* pAssoc;
                //                      for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                //                        pAssoc = pAssoc->pNext)
                //                      {
                //                              ar << pAssoc->key;
                //                              ar << (DWORD)pAssoc->value;
                //                              pAssoc->value = (CObject*)0;
                //                      }
                //              }
        }
        else
        {
                WORD wNewCount;
                ar >> wNewCount;

                WORD newKey;
                DWORD newValue;
                //              CObject* oldValue;
                while (wNewCount--)
                {
                        ar >> newKey;
                        ar >> newValue;
                        //                      if(Lookup(newKey, oldValue))
                        //                              newValue = (DWORD)oldValue + newValue;
                        SetAt(newKey, (CObject*)newValue);
                }
        }
}

#endif // _CMDLOG


/////////////////////////////////////////////////////////////////////////////
// Package handling

extern "C" typedef BOOL (FAR PASCAL* INITPACKAGEPROC)(HWND hShellWnd);

CStringList g_strlstPkgsLoaded;

#ifdef _DEBUG
LPCTSTR StringFromError(
                                                DWORD dwLastError   // last error value associated with API
                                                )
{
    LPTSTR MessageBuffer = NULL;
    DWORD dwBufferLength;
    dwBufferLength=FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwLastError,
                LANG_NEUTRAL,
                (LPTSTR) &MessageBuffer,
                0,
                NULL);
        return MessageBuffer;
}
#endif

//      IsShellDefFileVersion
//              This function must be called in every package's rawDllMain()
//              to ensure it is compatible with the current shell.

static BOOL bPackageCompatible;
#ifdef _DEBUG
static BOOL bPackageChecked;
#endif

BOOL IsShellDefFileVersion(DWORD dwVersion)
{
        bPackageCompatible &= ((!theApp.m_bPkgChk) || (dwVersion == SHELL_DEFFILE_VERSION));
#ifdef _DEBUG
        // set flag indicating that package performed shell compatibility check
        bPackageChecked = TRUE;
#endif
        return(bPackageCompatible);
}

BOOL GetVersionOfFile(LPSTR, CString &, CString &);

static TCHAR szPackageExt[] = "pkg";

static BOOL LoadPackage(LPCTSTR szPackage, CStringList& strlstPkgsNot,
                                                BOOL bIDEDir, BOOL bRequired)
{
        // set package compatibility default
        bPackageCompatible = TRUE;

#ifdef _DEBUG
        // reset flag indicating that package performed shell compatibility check
        bPackageChecked = FALSE;
#endif
	
        // make sure we don't attempt to load a package more than once
        CString strPkg(szPackage);
        // lower case, file sys is case insensitive
        strPkg.MakeLower();

        if (strlstPkgsNot.Find(strPkg) != (POSITION)NULL)
        {
                TRACE("::LoadPackage: Not loading package %s\n", (const TCHAR *)strPkg);
                return -1;    // just skip, FALSE indicates 'missing file'!
        }
        if (g_strlstPkgsLoaded.Find(strPkg) != (POSITION)NULL)
        {
                TRACE("::LoadPackage: Already loaded package %s\n", (const TCHAR *)strPkg);
                return -1;    // already loaded, FALSE indicates 'missing file'!
        }

        TRACE("::LoadPackage: Loading package %s\n", (LPCTSTR) strPkg);

        HINSTANCE hInst;
        DWORD dwLastError;
        TCHAR szDLL[_MAX_PATH];

        if (!bIDEDir)
        {
                // Default packages
                wsprintf(szDLL, _TEXT("%s.%s"), (LPCTSTR) strPkg, szPackageExt);
        }
        else
        {
                LPCTSTR lpszExtensionDir = theApp.GetExeString(DefaultExtensionDir);
                if (lstrlen(lpszExtensionDir) > 0)
                {
                        TCHAR szIDEDir[_MAX_PATH];

                        {
                                TCHAR szPath [_MAX_PATH];
                                TCHAR szDir [_MAX_DIR];
                                GetModuleFileName(NULL, szPath, _MAX_PATH);
                                _tsplitpath(szPath, szIDEDir, szDir, NULL, NULL);
                                _tcscat(szIDEDir, szDir);
                        }

                        wsprintf(szDLL, _TEXT("%s%s\\%s.%s"), szIDEDir,
                                lpszExtensionDir, (LPCTSTR) strPkg, szPackageExt);
                }

        }

#ifdef PKG_LOAD_TIME
        dwaPkgLoadLibraryTime[nPkg] = ::GetTickCount();
        straPkgName[nPkg] = szPackage;
#endif  // PKG_LOAD_TIME

        int nOldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);
        hInst = LoadLibrary(szDLL);
        SetErrorMode(nOldMode);
        dwLastError = GetLastError();

#ifdef PKG_LOAD_TIME
        dwaPkgLoadLibraryTime[nPkg] = ::GetTickCount() - dwaPkgLoadLibraryTime[nPkg];
#endif  // PKG_LOAD_TIME

        if (hInst < (HINSTANCE)HINSTANCE_ERROR)
        {
                if (!bPackageCompatible)
                {
                        CString strOut;
                        strOut.LoadString(IDS_ERR_CANT_LOAD_PKG_VER);
                        wsprintf(szDLL, (const TCHAR *)strOut, (const TCHAR *)strPkg);
#ifndef _DEBUG
                        AfxMessageBox(szDLL, MB_OK | MB_ICONEXCLAMATION);
                        return FALSE;
#else
                        if (!bRequired)
                        {
                                return(AfxMessageBox(szDLL, MB_YESNO | MB_ICONEXCLAMATION) == IDYES);
                        }
                        else
                        {
                                AfxMessageBox(szDLL, MB_OK | MB_ICONEXCLAMATION);
                                return FALSE;
                        }
#endif // _DEBUG
                }
                else
                {
                        // if package load failed for reason other than version check failure, then
                        // set error mode so that "missing DLL" message will be displayed and retry.
                        // this way the user gets a clue as to why the package failed to load.
                        nOldMode = SetErrorMode(0);
                        hInst = LoadLibrary(szDLL);
                        SetErrorMode(nOldMode);
                        ASSERT(dwLastError == GetLastError());
#ifndef _DEBUG
                        // ReportMissingFile will issue message to user.
                        return FALSE;
#else
                        if (bRequired)
                        {
                                // if package is required, then just return FALSE without
                                // asking user if continuing without the package is acceptable.
                                // ReportMissingFile will issue message to user.
                                return FALSE;
                        }
                        else
                        {
                                CString strOut;
                                LPCTSTR szMsg;
                                szMsg = StringFromError(dwLastError);
                                TRACE("  package load failed!\n");
                                TRACE("    error = %lu (0x%08lx) %s\n", dwLastError, dwLastError, szMsg ? szMsg : "");
                                if (szMsg)
                                        ::LocalFree((void*)szMsg);

                                strOut.LoadString(IDS_ERR_CANT_LOAD_PKG);
                                wsprintf(szDLL, (const TCHAR *)strOut, (const TCHAR *)strPkg, dwLastError);
                                return (AfxMessageBox(szDLL, MB_YESNO | MB_ICONEXCLAMATION) == IDYES);
                        }
#endif // _DEBUG
                }
        }

        static char BASED_CODE szInitPackage[] = _TEXT("InitPackage");

        INITPACKAGEPROC lpproc = (INITPACKAGEPROC)GetProcAddress(hInst, szInitPackage);
        if (lpproc == NULL)
        {
                TRACE("  package does not have a InitPackage procedure\n");
                FreeLibrary(hInst);
                return FALSE;
        }

#ifdef PKG_LOAD_TIME
        dwaPkgTypeLibTime[nPkg] = ::GetTickCount();
#endif  // PKG_LOAD_TIME

#ifdef PKG_LOAD_TIME
        dwaPkgTypeLibTime[nPkg] = ::GetTickCount() - dwaPkgTypeLibTime[nPkg];
#endif  // PKG_LOAD_TIME

#ifdef _DEBUG
        // check flag indicating that package performed shell compatibility check
        ASSERT(bPackageChecked);        // every package must perform version check!
#endif

        // we loaded this package, make a note of it
        g_strlstPkgsLoaded.AddTail(strPkg);

#ifdef PKG_LOAD_TIME
        dwaPkgInitPackageTime[nPkg] = ::GetTickCount();
#endif  // PKG_LOAD_TIME

        BOOL bInitSucceeded=(*lpproc)(theApp.m_pMainWnd->m_hWnd);

#ifdef PKG_LOAD_TIME
        dwaPkgInitPackageTime[nPkg] = ::GetTickCount() - dwaPkgInitPackageTime[nPkg];
        nPkg++;
#endif  // PKG_LOAD_TIME

#ifdef _DEBUG
        if(!bInitSucceeded)
        {
                TRACE("::LoadPackage: package returned failure from InitPackage\n");
                FreeLibrary(hInst);

                CString strOut;
                LPCTSTR szMsg;
                szMsg = StringFromError(dwLastError);
                TRACE("::LoadPackage: package initialise failed!\n");
                TRACE("::LoadPackage: error = %lu (0x%08lx) %s\n", dwLastError, dwLastError, szMsg ? szMsg : "");
                if (szMsg)
                        ::LocalFree((void*)szMsg);

                strOut.LoadString(IDS_ERR_CANT_INIT_PKG);
                wsprintf(szDLL, (const TCHAR *)strOut, (const TCHAR *)strPkg, dwLastError);
                bInitSucceeded=(AfxMessageBox(szDLL, MB_YESNO | MB_ICONEXCLAMATION) == IDYES);
        }
#endif
        return bInitSucceeded;
}

// Check for existence of
//  HKEY_CLASSES_ROOT\TypeLib\tlid\MajorVer.MinorVer
static BOOL IsTypeLibRegistered(const GUID& tlid, WORD wMajor, WORD wMinor)
{
        OLECHAR swzTlid[64];
        VERIFY(StringFromGUID2(tlid, swzTlid, 64) != 0);

        TCHAR szRegString[256];
        sprintf(szRegString, "TypeLib\\%S\\%d.%d", swzTlid, wMajor, wMinor);

        LONG lSize;
        return (RegQueryValue(HKEY_CLASSES_ROOT, szRegString, NULL, &lSize)
                == ERROR_SUCCESS);
}

// Check for existence of
//  HKEY_CLASSES_ROOT\TypeLib\ShellTLID\MajorVer.MinorVer
static BOOL IsShellTLIDRegistered()
{
        LONG lSize;
        return (RegQueryValue(HKEY_CLASSES_ROOT, LIBID_Shell_STRING, NULL, &lSize)
                == ERROR_SUCCESS);
}


// Compare against registry's 5.0\General\PackageCount.
//  If they're different, store the new value there and return TRUE
static BOOL IsPackageSetDifferent(int cPackagesLoaded)
{
        if (GetRegInt(szGeneralKey, szPackageCountKey, -1) == cPackagesLoaded)
                return FALSE;

        VERIFY(WriteRegInt(szGeneralKey, szPackageCountKey, cPackagesLoaded));
        return TRUE;
}


// Type libraries should be registered on startup as specified in this table:
//
//              CONDITION                                                                               REGISTER
//              ---------                                                                               --------
//              Set of pkgs loaded different than last time             YES
//              /REGISTER cmdline flag                                                  YES (FULL) [tested for in InitInstance]
//              LIBID_Shell not registered                                              YES (FULL)
//              Otherwise                                                                               NO
//
// Typical registration simply involves loading typelibs, getting application
//  extensions from packages, and calling RegisterTypeLib if the typelib "appears"
//  not to be registered.  FULL registration does all this and calls RegisterTypeLib
//  regardless of whether the typelib appears registered.
//
BOOL ShouldRegisterTypeLibsOnStartup(int cPackagesLoaded, BOOL& rbForceFullRegistration)
{
        // If /REGISTER is passed on cmdline, this isn't even called, since
        //  the shell knows it must register all typelibs.  We still
        //  want to force full registration if the app's CLSID isn't
        //  registered, though.

        if (!IsShellTLIDRegistered())
        {
                rbForceFullRegistration = TRUE;
                return TRUE;
        }

        rbForceFullRegistration = FALSE;

        if (IsPackageSetDifferent(cPackagesLoaded))
                return TRUE;

        return FALSE;
}

// This is called after all the packages have been loaded, and either
//      (A) On startup because package set is different,
//              LIBID_Shell not registered, or /REGISTER cmdline flag passed, OR
//  (B) The first time a macro file is loaded
void CVshellPackage::RegisterTypeLibsIfNecessary(BOOL bForceFullRegistration /* = FALSE */)
{
        static BOOL bTypeLibsLoaded = FALSE;

        // Only load/register once, unless the caller really really
        //  wants us to register them all (i.e., /REGISTER cmdline)
        if (bTypeLibsLoaded && !bForceFullRegistration)
                return;

        // Optimization: This DLL is loaded for each typelib we register, so
        //  load it once now to avoid its loading/unloading/loading/unloading/etc.
#ifdef _DEBUG
        HINSTANCE hinst = LoadLibrary("DevTLDcD.dll");
#else
        HINSTANCE hinst = LoadLibrary("DevTLDc.dll");
#endif

        POSITION pos = theApp.m_packages.GetHeadPosition();
        while (pos != NULL)
        {
                CPackage* pPackage = (CPackage*) theApp.m_packages.GetNext(pos);
                RegisterTypeLib(pPackage, bForceFullRegistration, !bTypeLibsLoaded);
        }

        if (hinst != NULL)
                FreeLibrary(hinst);
        bTypeLibsLoaded = TRUE;
}

// Little helper used in GetAllApplicationExtensions below.
void CVshellPackage::AddNewAutoItem(const GUID* pTlid, WORD wMajorVersion, WORD wMinorVersion,
                                                                        LPCTSTR szName, const CLSID* pClsid)
{
        CAutomationItem* pAutomationItem = new CAutomationItem;

        // Tlid entry stuff
        memcpy(&(pAutomationItem->m_tlid), pTlid, sizeof(GUID));
        pAutomationItem->m_wMajorVersion = wMajorVersion;
        pAutomationItem->m_wMinorVersion = wMinorVersion;

        // SApplicationExtension stuff (name & clsid)
        ASSERT (strlen(szName) < MAX_LENGTH_NAMED_ITEM);
        _tcsncpy(pAutomationItem->m_szName, szName, MAX_LENGTH_NAMED_ITEM-1);
        (pAutomationItem->m_szName)[MAX_LENGTH_NAMED_ITEM-1] = '\0';
        memcpy(&(pAutomationItem->m_clsid), pClsid, sizeof(CLSID));

        // Add it to the list.
        m_ptrlAutomationItems.AddTail(pAutomationItem);
}

// This loads & registers a single package's typelibrary.  It then calls
//  CPackage::GetApplicationExtension to get the names
//  of any top-level named items for VBS, and adds that info to
//  CVshellPackage::m_ptrlAutomationItems.  This list is later used to
//  implement IAutomationItems, which is used exclusively by devaut1 to add named
//  items to VBS.
void CVshellPackage::RegisterTypeLib(CPackage* pPackage, BOOL bForceFullRegistration,
                                                                         BOOL bGetApplicationExtensions)
{
        USES_CONVERSION;

        TCHAR szDLL[MAX_PATH];
        ::GetModuleFileName(pPackage->HInstance(), szDLL, MAX_PATH);

        // SPECIAL CASE:  Skip devres(d).pkg since it has a type library
        //  but not for automation-- it's for doing funky stuff with
        //  data bound controls.  Ignore it.
        if (!_tcsicmp(_tcsrchr(szDLL, '\\'),
#ifdef _DEBUG
                "\\devresd.pkg"))
#else
                "\\devres.pkg"))
#endif
                return;

        // See if the package has a type library.  If it does, register it
        //  and remember the TLID in case the package provides a top-level
        //  object.
        ITypeLib* pTypeLib = NULL;
        if (SUCCEEDED(LoadTypeLib(A2W(szDLL), &pTypeLib)) && pTypeLib != NULL)
        {
                TLIBATTR* pTlibAttr = NULL;
                if (SUCCEEDED(pTypeLib->GetLibAttr(&pTlibAttr)) && pTlibAttr != NULL)
                {
                        // Register type lib
                        if (bForceFullRegistration || !IsTypeLibRegistered(pTlibAttr->guid,
                                                pTlibAttr->wMajorVerNum, pTlibAttr->wMinorVerNum))
                        {
                                VERIFY(SUCCEEDED(::RegisterTypeLib(pTypeLib, A2W(szDLL), NULL)));
                        }

                        // See if this package has any application extensions to offer.
                        if (bGetApplicationExtensions && (pPackage->m_flags & PKS_AUTOMATION))
                        {
                                // Does this package supply any application extensions?
                                SApplicationExtension* pAppExts;
                                int cExts = pPackage->GetApplicationExtensions(&pAppExts);
                                for (int i=0; i < cExts; i++)
                                {
                                        // For each SApplicationExtension, create a CAutomationItem
                                        //  structure in our list
                                        AddNewAutoItem(&pTlibAttr->guid,
                                                pTlibAttr->wMajorVerNum, pTlibAttr->wMinorVerNum,
                                                pAppExts[i].szName, &pAppExts[i].clsid);
                                }

                                if (cExts == 0)
                                {
                                        // For this typelib, the package doesn't provide
                                        //  any application extensions, so create an entry
                                        //  in the list which devaut1 can use just to add the
                                        //  type lib to VBS (and not call AddNamedItem on).
                                        // However, there may be no extension because this is
                                        //  the application object.  If so, be sure to provide
                                        //  the right CLSID
                                        const CLSID* pClsid = (pTlibAttr->guid == LIBID_Shell) ?
                                                &APP_CLSID : &CLSID_NULL;

                                        AddNewAutoItem(&pTlibAttr->guid,
                                                pTlibAttr->wMajorVerNum, pTlibAttr->wMinorVerNum, "", pClsid);
                                }
                        }
                        pTypeLib->ReleaseTLibAttr(pTlibAttr);
                }
                pTypeLib->Release();
                pTypeLib = NULL;
        }
}


BOOL CTheApp::LoadPackages(int *pnPackagesLoaded)
{
        // Load packages used by this type of project shell
        // Errors prevent the IDE from loading...

	// Count # packages we successfully load.  This is our heuristic for knowing
	//  if "new" packages appeared since our last startup, indicating that we
	//  need to try and load & register their typelibs.
	*pnPackagesLoaded = 0;
	
#ifndef _SHIP
        m_bPkgChk = !ScanCommandLine("NoPkgChk");       // optionally disable shell compatibility check
#endif
	
	CString str;
	CStringList strlstPkgsNot;
	while (ScanCommandLine("NotPkg", &str))
	{
		str.MakeLower();
		strlstPkgsNot.AddTail(str);
	}

	BOOL bNoExtraPackages = (g_packages == rgszMakePackages);
	
	BOOL bNoPackages = ScanCommandLine("NoPackages");
	if (!bNoPackages)
	{
		for (int n = 0; n < g_nPackages; n += 1)
		{
			BOOL retval;
			// don't report missing packages for command line build (needed for fortran)
			if (!(retval = LoadPackage(g_packages[n], strlstPkgsNot, FALSE, TRUE)) && !m_bInvokedCommandLine)
			{
				ReportMissingFile(CString(g_packages[n]) + "." + szPackageExt);
				return FALSE;
			}
			else if (retval == TRUE)
				(*pnPackagesLoaded)++;
		}
		
	  if (!bNoExtraPackages)
	  {
		// Scan the IDE directory for *.PKG files and load them as packages
		// Errors prevent the IDE from loading...
		
		LPCTSTR lpszExtensionDir = GetExeString(DefaultExtensionDir);
		if (lstrlen(lpszExtensionDir) > 0)
		{
			TCHAR szIDEDir [_MAX_PATH];
			
			// Get the directory of the IDE executable
			{
				TCHAR szPath [_MAX_PATH];
				TCHAR szDir [_MAX_DIR];
				GetModuleFileName(NULL, szPath, _MAX_PATH);
				_tsplitpath(szPath, szIDEDir, szDir, NULL, NULL);
				_tcscat(szIDEDir, szDir);
			}
			
			WIN32_FIND_DATA findData;
			HANDLE hFindFile;
			_tcscat(szIDEDir, lpszExtensionDir);
#if 1           // hack to fix the build be ensuring proper load ordering
			// REVIEW: make sure we load the BLD pkg first if present
			TCHAR szBldPath [_MAX_PATH];
			_tcscpy(szBldPath, szIDEDir);
			_tcscat(szBldPath, _TEXT("\\DEVBLD*.PKG"));
			hFindFile = FindFirstFile(szBldPath, &findData);
			if (hFindFile != INVALID_HANDLE_VALUE)
			{
				TCHAR szFName [_MAX_FNAME];
				_tsplitpath(findData.cFileName, NULL, NULL, szFName, NULL);
				if ((szFName[0] != '\0') && (!LoadPackage(szFName, strlstPkgsNot, TRUE, FALSE)))
				{
					FindClose(hFindFile);
					ReportMissingFile(szFName);
					return FALSE;
				}
				(*pnPackagesLoaded)++;
				FindClose(hFindFile);
			}
#endif  // 1
			_tcscat(szIDEDir, _TEXT("\\*.PKG"));
			
			hFindFile = FindFirstFile(szIDEDir, &findData);
			if (hFindFile != INVALID_HANDLE_VALUE)
			{
				do
				{
					TCHAR szFName [_MAX_FNAME];
					_tsplitpath(findData.cFileName, NULL, NULL, szFName, NULL);
					if (szFName[0] == '\0')
						break;
					if (!LoadPackage(szFName, strlstPkgsNot, TRUE, FALSE))
					{
						FindClose(hFindFile);
						ReportMissingFile(szFName);
						return FALSE;
					}
					(*pnPackagesLoaded)++;
				}
				while (FindNextFile(hFindFile, &findData));
				FindClose(hFindFile);
			}
		}
	  }
	}
	
	// Scan the command line for /PKG and /IDEPKG switches to load
	// Errors prevent the retail IDE from loading...
	
	for (int i = 0; i < 2; i++)
	{
		static LPCTSTR aszSwitch[2] = { "PathPkg", "IDEPkg" };
		
		while (ScanCommandLine(aszSwitch[i], &str))
		{
			if (!str.IsEmpty())
			{
				if (!LoadPackage(str, strlstPkgsNot, i, FALSE))
				{
					ReportMissingFile(str + "." + szPackageExt);
					return FALSE;
				}
				*(pnPackagesLoaded)++;
				str.Empty();
			}
		}
	}
	
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//      Resource Range Validating Routines
//

struct SPkgIdRanges
{
        DWORD dwPkgId;
        WORD wMinResource, wMaxResource;
        WORD wMinString, wMaxString;
        WORD wMinCommand, wMaxCommand;
        //      WORD wMinWindow, wMinWindow;
};

BASED_CODE SPkgIdRanges g_aPkgIdRanges[] =
{
        // TODO(judithm): shell is stealing from shared and exe resource ranges
        { PACKAGE_SUSHI, MIN_SHARED_RESOURCE_ID, MAX_SHELL_RESOURCE_ID,
                        MIN_SHARED_RESOURCE_ID, MAX_SHELL_RESOURCE_ID,
                        MIN_SHELL_COMMAND_ID, MAX_SHELL_COMMAND_ID, },
        { PACKAGE_VCPP, MIN_EDIT_RESOURCE_ID, MAX_EDIT_RESOURCE_ID,
                MIN_EDIT_RESOURCE_ID, MAX_EDIT_RESOURCE_ID,
                MIN_SOURCE_COMMAND_ID, MAX_SOURCE_COMMAND_ID, },
        { PACKAGE_VRES, MIN_RES_RESOURCE_ID, MAX_RES_RESOURCE_ID,
                MIN_RES_RESOURCE_ID, MAX_RES_RESOURCE_ID,
                MIN_RES_COMMAND_ID, MAX_RES_COMMAND_ID, },
        { PACKAGE_VPROJ, MIN_BUILD_RESOURCE_ID, MAX_BUILD_RESOURCE_ID,
                MIN_BUILD_RESOURCE_ID, MAX_BUILD_RESOURCE_ID,
                MIN_BUILD_COMMAND_ID, MAX_BUILD_COMMAND_ID, },
        { PACKAGE_PRJSYS, MIN_WORKSPACE_RESOURCE_ID, MAX_WORKSPACE_RESOURCE_ID,
                MIN_WORKSPACE_RESOURCE_ID, MAX_WORKSPACE_RESOURCE_ID,
                MIN_WORKSPACE_COMMAND_ID, MAX_WORKSPACE_COMMAND_ID},
        { PACKAGE_IV, MIN_IV_RESOURCE_ID, MAX_IV_RESOURCE_ID,
                MIN_IV_RESOURCE_ID, MAX_IV_RESOURCE_ID,
                MIN_IV_COMMAND_ID, MAX_IV_COMMAND_ID},
        { PACKAGE_LANGCPP, MIN_CPP_RESOURCE_ID, MAX_CPP_RESOURCE_ID,
                MIN_CPP_RESOURCE_ID, MAX_CPP_RESOURCE_ID,
                0,0,},
        { PACKAGE_LANGFOR, MIN_FORTRAN_RESOURCE_ID, MAX_FORTRAN_RESOURCE_ID,
                MIN_FORTRAN_RESOURCE_ID, MAX_FORTRAN_RESOURCE_ID,
                MIN_FORTRAN_COMMAND_ID, MAX_FORTRAN_COMMAND_ID,},
        { PACKAGE_GALLERY, MIN_GALLERY_RESOURCE_ID, MAX_GALLERY_RESOURCE_ID,
                MIN_GALLERY_RESOURCE_ID, MAX_GALLERY_RESOURCE_ID,
                0,0,},
        { PACKAGE_LANGMST, MIN_TEST_RESOURCE_ID, MAX_TEST_RESOURCE_ID,
                MIN_TEST_RESOURCE_ID, MAX_TEST_RESOURCE_ID,
                MIN_TEST_COMMAND_ID, MAX_TEST_COMMAND_ID,},
        { PACKAGE_CLASSVIEW, MIN_CLSVIEW_RESOURCE_ID, MAX_CLSVIEW_RESOURCE_ID,
                MIN_CLASSVIEW_STRING_ID, MAX_CLASSVIEW_STRING_ID,
                MIN_CLASSVIEW_COMMAND_ID,MAX_CLASSVIEW_COMMAND_ID,},
        { PACKAGE_ENT, MIN_ENT_RESOURCE_ID, MAX_ENT_RESOURCE_ID,
                MIN_ENT_RESOURCE_ID, MAX_ENT_RESOURCE_ID,
                MIN_ENT_COMMAND_ID, MAX_ENT_COMMAND_ID,},
        { PACKAGE_LANGHTML, MIN_HTML_RESOURCE_ID, MAX_HTML_RESOURCE_ID,
                MIN_HTML_RESOURCE_ID, MAX_HTML_RESOURCE_ID,
                MIN_HTML_COMMAND_ID, MAX_HTML_COMMAND_ID,},
        { PACKAGE_BIN, MIN_BIN_RESOURCE_ID, MAX_BIN_RESOURCE_ID,
                MIN_BIN_RESOURCE_ID, MAX_BIN_RESOURCE_ID,
                MIN_BIN_COMMAND_ID, MAX_BIN_COMMAND_ID,},
        { PACKAGE_IMG, MIN_IMG_RESOURCE_ID, MAX_IMG_RESOURCE_ID,
                MIN_IMG_RESOURCE_ID,MAX_IMG_RESOURCE_ID,
                MIN_IMG_COMMAND_ID,MAX_IMG_COMMAND_ID, },
        { PACKAGE_NUMEGA, MIN_NUMEGA_RESOURCE_ID, MAX_NUMEGA_RESOURCE_ID,
                MIN_NUMEGA_RESOURCE_ID, MAX_NUMEGA_RESOURCE_ID,
                MIN_NUMEGA_COMMAND_ID, MAX_NUMEGA_COMMAND_ID,},
        { PACKAGE_SIMPLE, MIN_SAMPLE_RESOURCE_ID, MAX_SAMPLE_RESOURCE_ID,
                MIN_SAMPLE_RESOURCE_ID, MAX_SAMPLE_RESOURCE_ID,
                MIN_SAMPLE_COMMAND_ID, MAX_SAMPLE_COMMAND_ID , },
        { PACKAGE_HTMLEX, 0, 0,
                MIN_HTMLEX_STRING_ID, MAX_HTMLEX_STRING_ID,
                0, 0 },
        { PACKAGE_IATOOL, MIN_IATOOL_RESOURCE_ID, MAX_IATOOL_RESOURCE_ID,
                MIN_IATOOL_STRING_ID, MAX_IATOOL_STRING_ID,
                MIN_IATOOL_COMMAND_ID, MAX_IATOOL_COMMAND_ID },
        { PACKAGE_NCB, MIN_NCB_RESOURCE_ID, MAX_NCB_RESOURCE_ID,
                MIN_NCB_STRING_ID, MAX_NCB_STRING_ID,
                MIN_NCB_COMMAND_ID, MAX_NCB_COMMAND_ID },
        { PACKAGE_IST, MIN_IST_RESOURCE_ID, MAX_IST_RESOURCE_ID,
                MIN_IST_STRING_ID, MAX_IST_STRING_ID,
                MIN_IST_COMMAND_ID, MAX_IST_COMMAND_ID },
        { PACKAGE_LANGJVA, MIN_LANGJVA_RESOURCE_ID, MAX_LANGJVA_RESOURCE_ID,
                MIN_LANGJVA_STRING_ID, MAX_LANGJVA_STRING_ID,
                MIN_LANGJVA_COMMAND_ID, MAX_LANGJVA_COMMAND_ID },
        { PACKAGE_JVA, MIN_JVA_RESOURCE_ID, MAX_JVA_RESOURCE_ID,
                0,0,
                0,0},
        { PACKAGE_AUT1, MIN_AUT1_RESOURCE_ID, MAX_AUT1_RESOURCE_ID,
                0,0,
                MIN_AUT1_COMMAND_ID, MAX_AUT1_COMMAND_ID },
        { PACKAGE_DEBUG, MIN_DEBUG_RESOURCE_ID, MAX_DEBUG_RESOURCE_ID,          // REVIEW(davidga)
                MIN_DEBUG_RESOURCE_ID, MAX_DEBUG_RESOURCE_ID,                                   // this is the same range as the edit package (VCPP)
                MIN_SOURCE_COMMAND_ID, MAX_SOURCE_COMMAND_ID, },
        { PACKAGE_ODL, MIN_ODL_RESOURCE_ID, MAX_ODL_RESOURCE_ID,
                MIN_ODL_STRING_ID, MAX_ODL_STRING_ID,
                MIN_ODL_COMMAND_ID, MAX_ODL_COMMAND_ID },
        { PACKAGE_AUT2, MIN_AUT2_RESOURCE_ID, MAX_AUT2_RESOURCE_ID,
                0,0,
                MIN_AUT2_COMMAND_ID, MAX_AUT2_COMMAND_ID },
        { PACKAGE_HTM, MIN_HTM_RESOURCE_ID, MAX_HTM_RESOURCE_ID,
                MIN_HTM_STRING_ID, MAX_HTM_STRING_ID,
                MIN_HTM_COMMAND_ID, MAX_HTM_COMMAND_ID },
        { PACKAGE_DTG, MIN_DTG_RESOURCE_ID, MAX_DTG_RESOURCE_ID,
                MIN_DTG_STRING_ID, MAX_DTG_STRING_ID,
                MIN_DTG_COMMAND_ID, MAX_DTG_COMMAND_ID },
        { PACKAGE_DDK, MIN_DDK_RESOURCE_ID, MAX_DDK_RESOURCE_ID,
                MIN_DDK_STRING_ID, MAX_DDK_STRING_ID,
                MIN_DDK_COMMAND_ID, MAX_DDK_COMMAND_ID },
};

DWORD CPackage::GetIdRange(RANGE_TYPE rt)
{
        UINT nPkgLoc;
        for(nPkgLoc=0; nPkgLoc < sizeof(g_aPkgIdRanges) / sizeof(SPkgIdRanges);
        nPkgLoc++)
        {
                if(g_aPkgIdRanges[nPkgLoc].dwPkgId == m_id)
                {
                        switch (rt)
                        {
                        case MIN_RESOURCE:
                                return g_aPkgIdRanges[nPkgLoc].wMinResource;

                        case MAX_RESOURCE:
                                return g_aPkgIdRanges[nPkgLoc].wMaxResource;

                        case MIN_STRING:
                                return g_aPkgIdRanges[nPkgLoc].wMinString;

                        case MAX_STRING:
                                return g_aPkgIdRanges[nPkgLoc].wMaxString;

                        case MIN_COMMAND:
                                return g_aPkgIdRanges[nPkgLoc].wMinCommand;

                        case MAX_COMMAND:
                                return g_aPkgIdRanges[nPkgLoc].wMaxCommand;

                        case MIN_WINDOW:
                                return 0;       // derived package should override to change

                        case MAX_WINDOW:
                                return 0;       // derived package should override to change

                        default:
                                ASSERT(FALSE);
                                return 0;
                        }
                }
        }
        return 0;

}

#ifdef _DEBUG
struct SResIdCheckInfo
{
        WORD wMinRes;
        WORD wMaxRes;
        WORD wMinStr;
        WORD wMaxStr;
        //      UINT nPackageId;
        LPCSTR szFilename;
        int nResRangeUsed;
        int nStrRangeUsed;
};

LPCTSTR ResTypeFromRT(LPCTSTR szType)
{
        if( (DWORD)szType > 0x0000FFFF )
                return szType;
        switch( (DWORD)szType )
        {
        case RT_CURSOR:
                return "Cursor";
        case RT_BITMAP:
                return "Bitmap";
        case RT_ICON:
                return "Icon";
        case RT_MENU:
                return "Menu";
        case RT_DIALOG:
                return "Dialog";
        case RT_STRING:
                return "StringSegment";
        case RT_FONTDIR:
                return "FontDir";
        case RT_FONT:
                return "Font";
        case RT_ACCELERATOR:
                return "Accelerator";
        case RT_RCDATA:
                return "RCData";
        case RT_MESSAGETABLE:
                return "MessageTable";
        case RT_GROUP_CURSOR:
                return "CursorGroup";
        case RT_GROUP_ICON:
                return "IconGroup";
        case RT_VERSION:
                return "Version";
        case RT_DLGINCLUDE:
                return "DlgInclude";
        case RT_PLUGPLAY:
                return "PlugPlay";
        case RT_VXD:
                return "VXD";
        }

        static char acResType[32];
        wsprintf(acResType, "0x%X", (DWORD)szType);
        return acResType;
}

BOOL WINAPI EnumPkgResNames(HINSTANCE hModule, LPCTSTR szType, LPTSTR szName,
                                                        LONG lParam)
{
        SResIdCheckInfo* pricInfo = (SResIdCheckInfo*)lParam;

        if( (DWORD)szName > 0x0000ffff )        // all string IDs are valid
        {
                pricInfo->nResRangeUsed++;              // count number of this resource type used by this package
                return TRUE;
        }

        WORD wName = (WORD)(DWORD)szName;

        if( szType == RT_STRING )
        {
                WORD wString0 = (wName - 1) << 4;
                if( wString0 >= 0xE000 )
                        return TRUE;    // ignore MFC overrides

                if(     !((wString0 >= MIN_HELPSTRING_ID)               && ((wString0 + 15) <= MAX_HELPSTRING_ID)) &&
                        !((wString0 >= MIN_SHARED_RESOURCE_ID)  && ((wString0 + 15) <= MAX_SHARED_RESOURCE_ID))
                        )
                {
                        if( ((wString0 < pricInfo->wMinStr) || ((wString0 + 15) > pricInfo->wMaxStr))
                                )
                        {
                                pricInfo->nStrRangeUsed += 16;          // count number of strings used by this package,
                                // provided that this isn't in a special range
                        }
                        if( ((wString0 < pricInfo->wMinRes) || ((wString0 + 15) > pricInfo->wMaxRes))
                                && ((wString0 < pricInfo->wMinStr) || ((wString0 + 15) > pricInfo->wMaxStr))
                                )
                        {
                                char acBuf[512];
                                wsprintf(acBuf, "::EnumPkgResNames: Resource Range Error: String segment out of range in package '%s'.\n"
                                        "\tSegment is strings %d - %d.  Valid range is from %d to %d, and %d to %d.\n",
                                        pricInfo->szFilename, wString0, wString0 + 15,
                                        pricInfo->wMinRes, pricInfo->wMaxRes, pricInfo->wMinStr, pricInfo->wMaxStr);
                                TRACE0(acBuf);
                                //                      return (AfxMessageBox(acBuf, MB_YESNO | MB_ICONEXCLAMATION) == IDYES);
                                ASSERT( FALSE );                // hitting this assert means your package has a string where it shouldn't be
                                        }                                                       // note that empty string can cause this
                }
        }
        else
        {
                pricInfo->nResRangeUsed++;              // count number of this resource type used by this package
                if( ((wName < pricInfo->wMinRes) || (wName > pricInfo->wMaxRes)) &&
                        !((wName >= MIN_SHARED_RESOURCE_ID) && (wName <= MAX_SHARED_RESOURCE_ID))
                        && !((szType == RT_VERSION) && (wName == 0x1)) )
                {
                        char acBuf[512];
                        wsprintf(acBuf, "Resource Range Error in package '%s'.\n"
                                "\tType == %s,  ID == %d.  Valid range is from %d to %d.\n",
                                pricInfo->szFilename, ResTypeFromRT(szType), wName,
                                pricInfo->wMinRes, pricInfo->wMaxRes);
                        TRACE0(acBuf);
                        //                      return (AfxMessageBox(acBuf, MB_YESNO | MB_ICONEXCLAMATION) == IDYES);
                        ASSERT( FALSE );                // hitting this assert means your package has a resource where it shouldn't be
                }
        }

        return TRUE;
}

BOOL WINAPI EnumPkgResTypes(HINSTANCE hModule, LPTSTR szType, LONG lParam)
{
        ASSERT( lParam != NULL );
        if( ((DWORD)szType > 0xffff) || (szType == RT_ICON) || (szType == RT_CURSOR) )          // don't need to scan these
                return TRUE;                                                                            // as the IDs are always 1,2,3...

        SResIdCheckInfo* pricInfo = (SResIdCheckInfo*)lParam;
        int nRangeOld = pricInfo->nResRangeUsed;        // note biggest range so far
        pricInfo->nResRangeUsed = 0;
        if( !EnumResourceNames(hModule, szType, EnumPkgResNames, lParam) )
                return FALSE;

        if( pricInfo->nResRangeUsed < nRangeOld )       // store biggest range of any type
                pricInfo->nResRangeUsed = nRangeOld;

        return TRUE;
}
#endif  // _DEBUG
//////////////////////////////////////////////////////////////////////////////

void CTheApp::UnloadPackages()
{
        // Unload all registered packages
        while (!m_packages.IsEmpty())
        {
                CPackage *pPackage = (CPackage*) m_packages.RemoveHead();
                delete pPackage;
        }
}

BOOL CTheApp::RegisterPackage(CPackage* pPackage)
{
        if (pPackage == NULL)
        {
                ASSERT(FALSE);
                return FALSE;
        }

        m_packages.AddTail(pPackage);
        m_bMenuDirty = TRUE;
        m_bProjectCommandsDirty=TRUE;

#ifdef _DEBUG
        // debug check to make sure all resources in package are valid
        SResIdCheckInfo ricInfo;
        ricInfo.wMinRes = (WORD)pPackage->GetIdRange(CPackage::MIN_RESOURCE);
        ricInfo.wMaxRes = (WORD)pPackage->GetIdRange(CPackage::MAX_RESOURCE);
        ricInfo.wMinStr = (WORD)pPackage->GetIdRange(CPackage::MIN_STRING);
        ricInfo.wMaxStr = (WORD)pPackage->GetIdRange(CPackage::MAX_STRING);
        //      ricInfo.nPackageId = pPackage->PackageID();     // since we can't get the filename
        char acPkgFileName[256];
        GetModuleFileName(pPackage->HInstance(), acPkgFileName, 255);
        ricInfo.szFilename = acPkgFileName;
        ricInfo.nResRangeUsed = 0;
        ricInfo.nStrRangeUsed = 0;

        if( !EnumResourceTypes(pPackage->HInstance(), EnumPkgResTypes, (LPARAM)&ricInfo) )
        {
                TRACE1("Resource Range Check Error: Could not enumerate resources in package '%s'.\n",
                        ricInfo.szFilename);
                return FALSE;
        }

        // martynl: Only display this message if the usage is bad. These shouldn't fail, because the above should fail first
        if(ricInfo.nResRangeUsed > ricInfo.wMaxRes - ricInfo.wMinRes + 1)
        {
                TRACE3("CTheApp::RegisterPackage: Bad Resource Range Usage: Package '%s' uses %d slots out of its ID range of %d slots.\n",
                        ricInfo.szFilename, ricInfo.nResRangeUsed, ricInfo.wMaxRes - ricInfo.wMinRes + 1);
                ASSERT(FALSE);
        }

        if(ricInfo.nStrRangeUsed > ricInfo.wMaxStr - ricInfo.wMinStr + 1)
        {
                TRACE3("CTheApp::RegisterPackage: Bad Resource Range Usage: Package '%s' uses %d string slots out of its String ID range of %d slots.\n",
                        ricInfo.szFilename, ricInfo.nStrRangeUsed, ricInfo.wMaxStr - ricInfo.wMinStr + 1);
                ASSERT(FALSE);
        }
#endif // _DEBUG

        return TRUE;
}

BOOL CTheApp::RegisterPacket(CPacket* pPacket)
{
#ifdef _DEBUG
        if (pPacket == NULL)
        {
                ASSERT(FALSE);
                return FALSE;
        }

        ASSERT(pPacket->PacketID() > 0);

        // There better not be any Packets with identical ids
        CPackage* pPackage = GetPackage(pPacket->PackageID());
        if ((GetPacket(pPacket->PackageID(), pPacket->PacketID()) != NULL)
                || (pPackage == NULL))
        {
                ASSERT(FALSE);
                return FALSE;
        }
#endif

        m_packets.AddTail(pPacket);

        ASSERT(GetPacket(pPacket->PackageID(), pPacket->PacketID()) != NULL);

        m_bMenuDirty = TRUE;
        m_bProjectCommandsDirty=TRUE;

        return TRUE;
}

CPackage* CTheApp::GetPackage(UINT id)
{
        POSITION pos = m_packages.GetHeadPosition();
        while (pos != NULL)
        {
                CPackage* pPackage = (CPackage*) m_packages.GetNext(pos);
                if (pPackage->PackageID() == id)
                        return pPackage;
        }

        return NULL;
}

///////////////////////////////////////////////////////////////////////////////
BOOL GetVersionOfFile(LPSTR pszFileName, CString & strVersion, CString & strDescription)
{
        BOOL retval = FALSE;
        DWORD   dwHandle, dwVerInfoSize;
        unsigned int dwValueSize;
        VOID *  pvVerInfo = NULL;
        VOID *  pvValue = NULL;

        if (dwVerInfoSize = GetFileVersionInfoSize(pszFileName, &dwHandle))
        {
                pvVerInfo = new char[dwVerInfoSize];
                if (GetFileVersionInfo(pszFileName, dwHandle, dwVerInfoSize, pvVerInfo))
                {
                        if (VerQueryValue(      pvVerInfo,
                                "\\StringFileInfo\\040904B0\\FileVersion",
                                &pvValue,
                                &dwValueSize))
                        {
                                if (dwValueSize < (UINT)256)
                                {
                                        ASSERT(_tcslen((LPCSTR)pvValue) <= dwValueSize);
                                        strVersion = (LPCSTR)pvValue;
                                        retval = TRUE;
                                }
                        }
                        if (VerQueryValue(      pvVerInfo,
                                "\\StringFileInfo\\040904B0\\FileDescription",
                                &pvValue,
                                &dwValueSize))
                        {
                                if (dwValueSize < (UINT)256)
                                {
                                        ASSERT(_tcslen((LPCSTR)pvValue) <= dwValueSize);
                                        strDescription = (LPCSTR)pvValue;
                                }
                        }
                        else if (retval)
                        {
                                ASSERT(0);  // no description for this package
                                // retval = FALSE;
                        }
                }

                delete [] pvVerInfo;
        }
        return retval;
}

///////////////////////////////////////////////////////////////////////////////
// Log IDE startup to remote server
//
#ifdef _IDELOG
//#pragma message ("ALERT! : initexit.cpp : Including IDE startup logging for QA...")
void CTheApp::InitIDEstartupLog()
{
        // Send the IDE startup over the net to the database.
        // Just use a hard-coded file name as this is completely
        // internal.
        static char szLogFileName[] = "\\\\dtqalogs\\db\\editgo\\idestart.dat";
        const int maxRetries = 1;
        HANDLE hFile ;

        for (int i = 0; i < maxRetries ; i++ )
        {
                if ( (hFile = CreateFile(szLogFileName,GENERIC_READ|GENERIC_WRITE,
                        FILE_SHARE_READ,NULL,OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,NULL)
                        ) != INVALID_HANDLE_VALUE )
                {
                        break;
                }
                Sleep(300); // wait 0.3 seconds if it failed.
        }
        if ( i == maxRetries )
                return ; // No luck couldn't open the file.

        // Start writing from the end of the file.
        SetFilePointer(hFile,0,NULL,FILE_END);

        // Write out the relevant information to the file in the
        // following format.
        // 10/6/93, COLINT3, Debug or Release IDE, Chicago or Daytona,
        // Elapsed build time
        const DWORD MAX_SIZE = 512;
        char buffer[MAX_SIZE]; // Buffer to hold intermediate values.
        char logString[MAX_SIZE * 2]; // Complete string.
        DWORD  cBytesWritten ;

        logString[0] = '\n';
        _strdate(logString + 1); // get current date in mm/dd/yy form.
        lstrcat(logString,",");

        _strtime(logString + lstrlen(logString));
        lstrcat(logString,",");

        // Computer name.
        GetComputerName(buffer,(LPDWORD)&MAX_SIZE);
        lstrcat(logString,buffer);
        lstrcat(logString,",");

#ifdef _DEBUG
        lstrcat(logString, "Debug IDE,");
#else
        lstrcat(logString, "Release IDE,");
#endif

        if (theApp.m_bWin95)
                lstrcat(logString, "Chicago,");
        else
                lstrcat(logString, "Daytona,");

        if (theApp.m_fOEM_MBCS)
                lstrcat(logString, "Multi-byte OS");
        else
                lstrcat(logString, "Single-byte OS");


        WriteFile(hFile,logString, lstrlen(logString),&cBytesWritten,NULL);

        // We are all done, close the file.
        CloseHandle(hFile);
}
#endif // _IDELOG

BOOL CTheApp::InitStdCompMgr()
{
    BOOL fRet = FALSE;
    COleRef<IMsoStdComponentMgr>  srpStdCompMgr;
    COleRef<IMsoComponentManager>  srpMsoCompMgr;

        ASSERT(m_pAppCmpHost == NULL);
        m_pAppCmpHost = new CIPCompHostApp;
        ASSERT(m_pAppCmpHost != NULL);

    // Create a standard Component Manager and register it
    // as the thread Component Manager.  Then hand its
    // IMsoComponentManager interface to the main window.
    //
        if (MsoFCreateStdComponentManager(NULL,
                m_pAppCmpHost->GetIMsoComponentHost(),
                TRUE,
                IID_IMsoStdComponentMgr,
                (void **)&srpStdCompMgr) &&
        SUCCEEDED(srpStdCompMgr->QueryInterface(IID_IMsoComponentManager, (void **)&srpMsoCompMgr)))
    {
                ASSERT(m_pMainWnd);
                ASSERT(m_pMainWnd->IsKindOf(RUNTIME_CLASS(CMainFrame)));
                fRet = ((CMainFrame *)m_pMainWnd)->SetComponentManager(srpMsoCompMgr);

        if (fRet)
                        m_pMsoStdCompMgr = srpStdCompMgr.Disown();
        }
        return fRet;
}

void CTheApp::TermStdCompMgr()
{
        if (m_pAppCmpHost)
                m_pAppCmpHost->InternalRelease();

        if (m_pMsoStdCompMgr)
        {
                m_pMsoStdCompMgr->Terminate(TRUE);
                MsoFSetComponentManager(NULL);
                OleRelease(m_pMsoStdCompMgr);
        }
}


/////////////////////////////////////////////////////////////////////////////
// Implementation of IMsoComponentHost

BEGIN_INTERFACE_MAP(CIPCompHostApp, CCmdTarget)
INTERFACE_PART(CIPCompHostApp, IID_IMsoComponentHost, MsoComponentHost)
END_INTERFACE_MAP()

CIPCompHostApp::CIPCompHostApp()
{
}

HRESULT CIPCompHostApp::XMsoComponentHost::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)

        *ppvObj = NULL;
        return theApp.GetService(guidService, riid, ppvObj);
}

STDMETHODIMP_(BOOL) CIPCompHostApp::XMsoComponentHost::FDebugMessage(HMSOINST hinst, UINT message,
                                                                                                                                         WPARAM wParam, LPARAM lParam)
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
        return TRUE;
}

MSOMETHODIMP_(void) CIPCompHostApp::XMsoComponentHost::OnComponentActivate(IMsoComponent *pic,
                                                                                                                                                   const MSOCRINFO *pcrinfo, BOOL fTracking)
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
                // Since there's always an active component (the MDI frame),
                // this doesn't need to keep track of whether there is an
                // active component.
}

MSOMETHODIMP_(void) CIPCompHostApp::XMsoComponentHost::OnComponentEnterState(ULONG uStateId, BOOL fEnter)
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
        //$UNDONE, disable/enable non-component top-level modeless windows

}

MSOMETHODIMP_(BOOL) CIPCompHostApp::XMsoComponentHost::FContinueIdle()
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)

        MSG msg;
        return(!::PeekMessage(&msg, NULL, NULL, NULL, PM_NOREMOVE));
}

MSOMETHODIMP_(BOOL) CIPCompHostApp::XMsoComponentHost::FPushMessageLoop(ULONG uReason)
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
                return ((CTheApp *)AfxGetApp())->MainLoop(NULL, TRUE, uReason);
}

ULONG CIPCompHostApp::XMsoComponentHost::AddRef()
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
        return pThis->ExternalAddRef();
}

ULONG CIPCompHostApp::XMsoComponentHost::Release()
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
        return pThis->ExternalRelease();
}

HRESULT CIPCompHostApp::XMsoComponentHost::QueryInterface(REFIID riid, void **ppvObj)
{
        METHOD_PROLOGUE(CIPCompHostApp, MsoComponentHost)
        return pThis->ExternalQueryInterface(&riid, ppvObj);
}

/////////////////////////////////////////////////////////////////////////////
// Implementation of CIPCompMessageFilter

BEGIN_INTERFACE_MAP(CIPCompMessageFilter, COleMessageFilter)
INTERFACE_PART(CIPCompMessageFilter, IID_IServiceProvider, ServiceProvider)
END_INTERFACE_MAP()

CIPCompMessageFilter::CIPCompMessageFilter()
{
}

ULONG CIPCompMessageFilter::XServiceProvider::AddRef()
{
        METHOD_PROLOGUE(CIPCompMessageFilter, ServiceProvider)
        return pThis->ExternalAddRef();
}

ULONG CIPCompMessageFilter::XServiceProvider::Release()
{
        METHOD_PROLOGUE(CIPCompMessageFilter, ServiceProvider)
        return pThis->ExternalRelease();
}

HRESULT CIPCompMessageFilter::XServiceProvider::QueryInterface(REFIID riid, void **ppvObj)
{
        METHOD_PROLOGUE(CIPCompMessageFilter, ServiceProvider)
        return pThis->ExternalQueryInterface(&riid, ppvObj);
}

HRESULT CIPCompMessageFilter::XServiceProvider::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
        METHOD_PROLOGUE(CIPCompMessageFilter, ServiceProvider)

        *ppvObj = NULL;
        return theApp.GetService(guidService, riid, ppvObj);
}

BOOL InitOle()
{
        _AFX_THREAD_STATE* pState = AfxGetThreadState();
        ASSERT(!pState->m_bNeedTerm);    // calling it twice?

        // first, initialize OLE
        SCODE sc = ::OleInitialize(NULL);
        if (FAILED(sc))
        {
                // warn about non-NULL success codes
                TRACE1("Warning: OleInitialize returned scode = %s.\n",
                        AfxGetFullScodeString(sc));
                goto InitFailed;
        }
        // termination required when OleInitialize does not fail
        pState->m_bNeedTerm = TRUE;

        // hook idle time and exit time for required OLE cleanup
        CWinThread* pThread; pThread = AfxGetThread();
        pThread->m_lpfnOleTermOrFreeLib = AfxOleTermOrFreeLib;

        // allocate and initialize default message filter
        if (pThread->m_pMessageFilter == NULL)
        {
                pThread->m_pMessageFilter = new CIPCompMessageFilter;
                ASSERT(AfxOleGetMessageFilter() != NULL);
                AfxOleGetMessageFilter()->Register();
        }

        return TRUE;

InitFailed:
        AfxOleTerm();
        return FALSE;
}

static BOOL GetCmdLineProfile (LPCTSTR lpszProfileName, CStringList& argList, POSITION posInsertAfter)
{
        // Parameter validation
        if (lpszProfileName == NULL || posInsertAfter == NULL)
        {
                ASSERT(FALSE);
                return FALSE;
        }

        POSITION        pos             = posInsertAfter;
        HKEY            hKey    = NULL;

        // Construct the reg path
        CString         strRegPath;
        strRegPath.Format(_T("%s\\%s\\%s\\Profiles\\%s\\Args"), g_szKeyRoot,
                g_szCompanyName, theApp.GetExeString(DefaultRegKeyName), lpszProfileName);

        // Open the reg key
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, strRegPath, 0, KEY_READ, &hKey)
                == ERROR_SUCCESS)
        {
                // Get the length of the longest value
                DWORD           cbMaxValueLen;

                if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                        NULL, NULL, &cbMaxValueLen, NULL, NULL)
                        == ERROR_SUCCESS)
                {
                        // Loop through the Arg# entries under the specified profile key
                        CString         strValue;
                        CString         strArg;
                        DWORD           dwType;
                        DWORD           cbBuffer;

                        for (int iArg = 0; ; iArg++)
                        {
                                // Get the next arg
                                strValue.Format(_T("Arg%d"), iArg);
                                cbBuffer = cbMaxValueLen + sizeof(TCHAR);

                                if (RegQueryValueEx(hKey, strValue, NULL, &dwType,
                                        (LPBYTE) strArg.GetBuffer(cbBuffer/sizeof(TCHAR)), &cbBuffer)
                                        != ERROR_SUCCESS)
                                {
                                        break;
                                }
                                strArg.ReleaseBuffer();

                                // If string and non-empty, add arg to master list
                                if (dwType == REG_SZ && !strArg.IsEmpty())
                                {
                                        pos = argList.InsertAfter(pos, strArg);
                                }
                        }
                }
        }

        // If the position hasn't changed, we didn't find the profile
        return (pos != posInsertAfter);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcfrmhk.h ===
// ipcfrmhk.h : interface of the CIPCompFrameHook class
//

#ifndef __IPCFRMHK_H__
#define __IPCFRMHK_H__

#include <oleipc.h>

extern UINT WM_RESETCOMMANDTARGET; // registered message sent to CIPCmpView

class CIPCompContainerItem;

/////////////////////////////////////////////////////////////////////////////
// CIPCompFrameHook 

class CIPCompFrameHook : public COleFrameHook
{

public:
	CIPCompFrameHook(CFrameWnd* pFrameWnd, CFrameWnd* pDocFrame, COleClientItem* pItem);
	~CIPCompFrameHook();

	virtual BOOL OnCompCmdMsg(GUID *pguid, DWORD cmdid, DWORD rgf,
		int nCode, void* pExtra);

	CFrameWnd *		m_pDocFrameWnd;
	
	IMsoCommandTarget * GetSupportingTarget(GUID * pguid, DWORD cmdid, DWORD rgf);
	void SetIPCComboEditText(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	void FillIPCCombo(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	void OnIPCComboSelect(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);
	void OnIPCComboEnter(CComboBox * pcombo, GUID * pguid, DWORD cmdid, DWORD rgf);

protected:
	COleRef<IOleInPlaceComponent> 	m_srpMainComp;
	COleRef<IMsoCommandTarget>		m_srpMainCmdTrgt;
	COleRef<IMsoCommandTarget>		m_srpActiveCmdTrgt;
	COleRef<IMsoCommandTarget>		m_srpPreContextMenuCmdTrgt;
	BOOL			m_fEnteringState;
	BOOL			m_fTopLevelContext;
	DWORD			m_dwCompRole;
	DWORD			m_dwRoleEnteringState;
	DWORD			m_grfComp;
	CLSID			m_clsidActive;
	
	//$UNDONE billmc -- only buttons supported so far, and no command
	// caching.
	//
	BOOL QueryCmdStatus(IMsoCommandTarget *pCmdTrgt, GUID *pguid, UINT cmdid, CCmdUI *pCmdUI, DWORD rgf);
	BOOL ExecCmd(IMsoCommandTarget *pCmdTrgt, GUID *pguid, UINT cmdid);
	void FillZoomCombo(CComboBox * pcombo, IMsoCommandTarget *pCmdTrgt);
	void FillFontNameCombo(CComboBox* pComboBox, IMsoCommandTarget* pCmdTrgt);
	void FillFontSizeCombo(CComboBox* pComboBox, LPCTSTR pszFontName);

protected:
	DECLARE_INTERFACE_MAP()

	// in addition, we need to implement IOleComponentUIManager, IOleInplaceComponentUIManager.
	BEGIN_INTERFACE_PART(OleCompUIMgr, IOleComponentUIManager)
		STDMETHOD(GetPredefinedStrings)(DISPID dispid, 
						CALPOLESTR *pcaStringsOut, CADWORD *pcaCookiesOut);
		STDMETHOD(GetPredefinedValue)(DISPID dispid, DWORD dwCookie, 
						VARIANT *pvarOut);
		STDMETHOD_(void, OnUIEvent)(DWORD dwCompRole, REFCLSID rclsidComp, 
						const GUID *pguidUIEventGroup, DWORD nUIEventId,
						DWORD dwUIEventStatus, 
						DWORD dwEventFreq, RECT *prcEventRegion, 
						VARIANT *pvarEventArg);
		STDMETHOD(OnUIEventProgress)(DWORD *pdwCookie, BOOL fInProgress,
						LPOLESTR pwszLabel, ULONG nComplete, ULONG nTotal);
		STDMETHOD(SetStatus)(LPCOLESTR pwszStatusText, 
						DWORD dwReserved);
		STDMETHOD(ShowContextMenu)(DWORD dwCompRole, REFCLSID rclsidActive,
	        			LONG nMenuId, POINTS &pos, 
						IMsoCommandTarget *pCmdTrgtActive);
		STDMETHOD(ShowHelp)(DWORD dwCompRole, REFCLSID rclsidComp,
						POINT posMouse, DWORD dwHelpCmd,
						LPOLESTR pszHelpFile, DWORD dwData);
		STDMETHOD(ShowMessage)(DWORD dwCompRole, REFCLSID rclsidComp,
						LPOLESTR pszTitle, LPOLESTR pszText,
						LPOLESTR pszHelpFile, DWORD dwHelpContextID,
						OLEMSGBUTTON msgbtn, OLEMSGDEFBUTTON msgdefbtn,
						OLEMSGICON msgicon, BOOL fSysAlert, LONG *pnResult);
	END_INTERFACE_PART(OleCompUIMgr)
	
	BEGIN_INTERFACE_PART(OleIPCompUIMgr, IOleInPlaceComponentUIManager)
	    STDMETHOD(UIActivateForMe)(DWORD dwCompRole, REFCLSID rclsidActive,
	        			IOleInPlaceActiveObject *pIPActObj, 
						IMsoCommandTarget *pCmdTrgtActive,
	        			ULONG cCmdGrpId, LONG *rgnCmdGrpId);
		STDMETHOD(UpdateUI)(DWORD dwCompRole, BOOL fImmediateUpdate, 
						DWORD dwReserved);
	    STDMETHOD(SetActiveUI)(DWORD dwCompRole, REFCLSID rclsid,
						ULONG cCmdGrpId, LONG *rgnCmdGrpId);
		STDMETHOD_(void,OnUIComponentEnterState)(DWORD dwCompRole, 
						DWORD dwStateId, DWORD dwReserved);
		STDMETHOD_(BOOL,FOnUIComponentExitState)(DWORD dwCompRole, 
						DWORD dwStateId, DWORD dwReserved);
		STDMETHOD_(BOOL,FUIComponentInState)(DWORD dwStateId);
		STDMETHOD_(BOOL,FContinueIdle)(THIS);
	END_INTERFACE_PART(OleIPCompUIMgr)
	
	BEGIN_INTERFACE_PART(ServiceProvider, IServiceProvider)
		STDMETHOD(QueryService) (REFGUID guidService, REFIID iid, void ** ppvObj);
	END_INTERFACE_PART(ServiceProvider)

public:
	virtual BOOL OnPreTranslateMessage(MSG* pMsg);
	virtual BOOL OnDocActivate(BOOL bActive);	// for OnDocWindowActivate
	
	IOleComponentUIManager * CIPCompFrameHook::GetIOleComponentUIManager();
	IOleInPlaceComponentUIManager * CIPCompFrameHook::GetIOleInPlaceComponentUIManager ();
	HRESULT SetInPlaceComponent(IUnknown * punkIPComp);
	void DoClose();

	// component manager related methods
	void OnEnterState(ULONG uStateId, BOOL fEnter);
	void OnActiveEnableModelss(ULONG uStateId, BOOL fEnter);
	void OnFrameActivate(BOOL fActivate);
	BOOL FDoIdle(DWORD grfidlef);
	BOOL FQueryClose(BOOL fPromptUser);

	BOOL ResetCommandTarget();
	
protected:
	//{{AFX_MSG(CIPCompFrameHook)
	//}}AFX_MSG
};

#endif	// __IPCFRMHK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipchost.h ===
// ipchost.h : main header file IMsoComponent and IMsoComponentHost
//

#ifndef __IPCHOST_H__
#define __IPCHOST_H__

#include <cmpmgr.h>

class CIPCompMainFrame : public CCmdTarget
{
public:
	CIPCompMainFrame();
	BOOL SetComponentManager(IMsoComponentManager * pCmpMgr);
	void ReleaseComponentManager();
	IMsoComponent * CIPCompMainFrame::GetIMsoComponent()
		{return &m_xMsoComponent; }

	DECLARE_INTERFACE_MAP()

	BEGIN_INTERFACE_PART(MsoComponent, IMsoComponent)
	    MSODEBUGMETHODIMP
		MSOMETHOD_(BOOL, FPreTranslateMessage) (MSG *pMsg);
		MSOMETHOD_(void, OnEnterState) (ULONG uStateId, BOOL fEnter);
		MSOMETHOD_(void, OnAppActivate) (BOOL fActivate, DWORD dwOtherThreadID);
		MSOMETHOD_(void, OnLoseActivation) ();
		MSOMETHOD_(void, OnActivationChange) (
							IMsoComponent *pic, 
							BOOL fSameComponent,
							const MSOCRINFO *pcrinfo,
							BOOL fHostIsActivating,
							const MSOCHOSTINFO *pchostinfo,
							DWORD dwReserved);
		MSOMETHOD_(BOOL, FDoIdle) (DWORD grfidlef);
		MSOMETHOD_(BOOL, FContinueMessageLoop) (
							ULONG uReason,
							void* pvLoopData,
							MSG *pMsgPeeked);
		MSOMETHOD_(BOOL, FQueryTerminate) (BOOL fPromptUser);
		MSOMETHOD_(void, Terminate) ();
		MSOMETHOD_(HWND, HwndGetWindow) (DWORD dwWhich, DWORD dwReserved);
	END_INTERFACE_PART(MsoComponent)

public:
	COleRef<IMsoComponentManager> m_srpMsoCompMgr;
	DWORD m_dwComponentID;
};

class CIPCompHostApp : public CCmdTarget
{
	DECLARE_INTERFACE_MAP()

	BEGIN_INTERFACE_PART(MsoComponentHost, IMsoComponentHost)
		MSOMETHOD(QueryService) (REFGUID guidService, REFIID iid, void **ppvObj);

		MSODEBUGMETHODIMP
		MSOMETHOD_(void, OnComponentActivate) (IMsoComponent *pic, 
							const MSOCRINFO *pcrinfo, BOOL fTracking);
		MSOMETHOD_(void, OnComponentEnterState) (ULONG uStateId, BOOL fEnter);
		MSOMETHOD_(BOOL, FContinueIdle) ();
		MSOMETHOD_(BOOL, FPushMessageLoop) (ULONG uReason);
	END_INTERFACE_PART(MsoComponentHost)

public:
	CIPCompHostApp();
	IMsoComponentHost * CIPCompHostApp::GetIMsoComponentHost()
		{return &m_xMsoComponentHost; }
};

class CIPCompMessageFilter : public COleMessageFilter
{
	DECLARE_INTERFACE_MAP()

	BEGIN_INTERFACE_PART(ServiceProvider, IServiceProvider)
		STDMETHOD(QueryService) (REFGUID guidService, REFIID iid, void ** ppvObj);
	END_INTERFACE_PART(ServiceProvider)

public:
	CIPCompMessageFilter();
};

#endif //__IPCHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcits.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.45 */
/* at Thu Sep 12 18:04:33 1996
 */
/* Compiler settings for ipcits.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ipcits_h__
#define __ipcits_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IInternalTrackSelection_FWD_DEFINED__
#define __IInternalTrackSelection_FWD_DEFINED__
typedef interface IInternalTrackSelection IInternalTrackSelection;
#endif 	/* __IInternalTrackSelection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Sep 12 18:04:33 1996
 * using MIDL 3.00.45
 ****************************************/
/* [local] */ 


//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1996.
//
//--------------------------------------------------------------------------


//----------------------------------------------------------------
// IInternalTrackSelection interface
//----------------------------------------------------------------
// {BBB459C0-FF27-11cf-A1E4-00AA00C09209}
DEFINE_GUID(IID_IInternalTrackSelection, 
0xbbb459c0, 0xff27, 0x11cf, 0xa1, 0xe4, 0x0, 0xaa, 0x0, 0xc0, 0x92, 0x9);


extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IInternalTrackSelection_INTERFACE_DEFINED__
#define __IInternalTrackSelection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IInternalTrackSelection
 * at Thu Sep 12 18:04:33 1996
 * using MIDL 3.00.45
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IInternalTrackSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IInternalTrackSelection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsExternalSelectChange( 
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbReturn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnInternalSelectChange( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInternalSelectList( 
            /* [out] */ CALPOLESTR __RPC_FAR *pcaStringsOut,
            /* [out] */ CADWORD __RPC_FAR *pcaCookiesOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInternalTrackSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInternalTrackSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInternalTrackSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsExternalSelectChange )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [out] */ VARIANT_BOOL __RPC_FAR *pbReturn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnInternalSelectChange )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInternalSelectList )( 
            IInternalTrackSelection __RPC_FAR * This,
            /* [out] */ CALPOLESTR __RPC_FAR *pcaStringsOut,
            /* [out] */ CADWORD __RPC_FAR *pcaCookiesOut);
        
        END_INTERFACE
    } IInternalTrackSelectionVtbl;

    interface IInternalTrackSelection
    {
        CONST_VTBL struct IInternalTrackSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInternalTrackSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInternalTrackSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInternalTrackSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInternalTrackSelection_IsExternalSelectChange(This,pbReturn)	\
    (This)->lpVtbl -> IsExternalSelectChange(This,pbReturn)

#define IInternalTrackSelection_OnInternalSelectChange(This,dwCookie)	\
    (This)->lpVtbl -> OnInternalSelectChange(This,dwCookie)

#define IInternalTrackSelection_GetInternalSelectList(This,pcaStringsOut,pcaCookiesOut)	\
    (This)->lpVtbl -> GetInternalSelectList(This,pcaStringsOut,pcaCookiesOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInternalTrackSelection_IsExternalSelectChange_Proxy( 
    IInternalTrackSelection __RPC_FAR * This,
    /* [out] */ VARIANT_BOOL __RPC_FAR *pbReturn);


void __RPC_STUB IInternalTrackSelection_IsExternalSelectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalTrackSelection_OnInternalSelectChange_Proxy( 
    IInternalTrackSelection __RPC_FAR * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IInternalTrackSelection_OnInternalSelectChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInternalTrackSelection_GetInternalSelectList_Proxy( 
    IInternalTrackSelection __RPC_FAR * This,
    /* [out] */ CALPOLESTR __RPC_FAR *pcaStringsOut,
    /* [out] */ CADWORD __RPC_FAR *pcaCookiesOut);


void __RPC_STUB IInternalTrackSelection_GetInternalSelectList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInternalTrackSelection_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcmpvw.cpp ===
// ipcmpvw.cpp : implementation of the CIPCompView class
//

#include "stdafx.h"
#pragma hdrstop

#include <afxodlgs.h>

#include "shldocs_.h"
#include "ipcmpctr.h"
#include "ipcmpvw.h"

IMPLEMENT_DYNCREATE(CIPCompView, CDocObjectView)

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// These are defined in undoctl.cpp.
extern UINT WM_GETUNDOSTRING;
extern UINT WM_GETREDOSTRING;

/////////////////////////////////////////////////////////////////////////////
// CIPCompView


BEGIN_MESSAGE_MAP(CIPCompView, CDocObjectView)
	//{{AFX_MSG_MAP(CIPCompView)

    ON_WM_WINDOWPOSCHANGED()

	ON_MESSAGE(WM_HELP, OnWmHelp)
	ON_REGISTERED_MESSAGE(WM_GETUNDOSTRING, OnGetUndoString)
	ON_REGISTERED_MESSAGE(WM_GETREDOSTRING, OnGetRedoString)
	ON_REGISTERED_MESSAGE(WM_RESETCOMMANDTARGET, OnResetCommandTarget)

	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIPCompView construction

CIPCompView::CIPCompView()
{
}

/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
CIPCompDoc * CIPCompView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CIPCompDoc )));
	return((CIPCompDoc *)m_pDocument);
}
#endif

BOOL CIPCompView::PreTranslateMessage(MSG* pMsg)
{
	// prevent CSlobWnd from grabbing shift-F10 away from the component.
	//
	if (((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
		  (pMsg->wParam == VK_F10) &&		// it's F10
		  (GetKeyState(VK_SHIFT) & ~1) &&   //   and Shift is down
		  !(GetKeyState(VK_CONTROL) & ~1) ) //   but not Ctrl (DevStudio96 #7532)
		  ||                                // OR
		 (pMsg->message == WM_CONTEXTMENU)  //   Natural keyboard key
		)
	{
		return FALSE;
	}

	return CDocObjectView::PreTranslateMessage(pMsg);

}


void CIPCompView::OnInitialUpdate()
{
	CPartView::OnInitialUpdate();
}

HRESULT CIPCompView::OnActivateDocObjectView()
{
	// The document should contain exactly 1 OLE container item (otherwise the
	// doc shouldn't have been created successfully).  Get a pointer to the item.
	CIPCompDoc *pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	POSITION position = pDoc->GetStartPosition();
	CIPCompContainerItem *pItem = (CIPCompContainerItem *)pDoc->GetNextClientItem(position);
	ASSERT(pItem != NULL && pItem->IsKindOf(RUNTIME_CLASS(CIPCompContainerItem)) &&
		   pDoc->GetNextClientItem(position) == NULL);	// should be 1 and only 1 client item

	HRESULT hr = E_FAIL;
	if (pItem->GetOleDocument())
		hr = pItem->ActivateDocObjectView(this);

	if (SUCCEEDED(hr))
		pDoc->SetDocObjViewActivate(TRUE);
		
	return hr;
}


BOOL CIPCompView::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	GUID * pguid;
	DWORD cmdid, rgf;
	BOOL fHandled = FALSE, fRoutedToShell = FALSE;;

	CIPCompDoc *pDoc = (CIPCompDoc *)GetDocument();

	if (pHandlerInfo == NULL &&
		pDoc &&
		pDoc->IsKindOf(RUNTIME_CLASS(CIPCompDoc)) &&
		pDoc->m_pItem != NULL &&
		pDoc->OleCmdFromId(nID, &pguid, &cmdid, &rgf))

	{
		if (rgf & OLECMDROUTEFLAG_SHELLFIRST)
		{
			fHandled = CDocObjectView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
		}

		if (!fHandled)
		{
			fHandled = pDoc->m_pItem->OnCompCmdMsg(pguid, cmdid, rgf,
				nCode, pExtra);
		}
	}

	if (!fHandled && !fRoutedToShell)
		fHandled = CDocObjectView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);

	return fHandled;
}

CSlob* CIPCompView::GetSelection()
{
	CIPCompDoc* pDoc = (CIPCompDoc*)GetDocument();
	if(NULL != pDoc)
		return pDoc->GetSlob();
	return NULL;
}

LRESULT
CIPCompView::OnGetUndoString(WPARAM nLevel, LPARAM lpstr)
{
	CIPCompDoc* pDoc = (CIPCompDoc*)GetDocument();

	if (NULL != pDoc)
		return pDoc->GetUndoRedoString(nLevel, lpstr, 256, TRUE);
	else
		return FALSE;
}

LRESULT CIPCompView::OnWmHelp(WPARAM, LPARAM)
{
	// If the in-place component didn't handle the WM_HELP message,
	// there's not much the shell can do about it, so we intercept
	// this message here.  (The default window proc passes the WM_HELP
	// on to the parent window.)
	//
	return TRUE;
}

LRESULT
CIPCompView::OnGetRedoString(WPARAM nLevel, LPARAM lpstr)
{
	CIPCompDoc* pDoc = (CIPCompDoc*)GetDocument();

	if (NULL != pDoc)
		return pDoc->GetUndoRedoString(nLevel, lpstr, 256, FALSE);
	else
		return FALSE;
}


afx_msg void CIPCompView::OnHelp()
{
	// This function is just here to save us from having to change
	// the shell's exports & relink the world.
}

void CIPCompView::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)
{
	CIPCompDoc* pDoc = (CIPCompDoc*)GetDocument();
	if (pDoc != NULL)
	{
		ASSERT_KINDOF(CIPCompDoc, pDoc);
		pDoc->OnWindowPosChanged(lpwndpos);
	}
	
	CDocObjectView::OnWindowPosChanged(lpwndpos);
}

void CIPCompView::ShowContextPopupMenu(CPoint pt)
{
	CIPCompDoc* pDoc = (CIPCompDoc*)GetDocument();
	if (pDoc != NULL)
	{
		ASSERT_KINDOF(CIPCompDoc, pDoc);
		pDoc->ShowContextPopupMenu(pt);
	}
}

//
//
//	LRESULT CIPCompView::OnResetCommandTarget
//
//	Description:
//		Used to reset command target after Context Menu command has been
//		handled.  Calls CIPCFrameHook::ResetCommandTarget to do the reset.
//
//	Arguments:
//		WPARAM nUnUsed:
//
//		LPARAM lUnUsed:
//
//	Return (LRESULT): TRUE
//
LRESULT CIPCompView::OnResetCommandTarget(WPARAM nUnUsed, LPARAM lUnUsed)
{
	CIPCompDoc* pDoc = (CIPCompDoc*)GetDocument();
	ASSERT_KINDOF(CIPCompDoc, pDoc);
	if (NULL != pDoc && NULL != pDoc->m_pItem)
	{
		CIPCompFrameHook*	pFrameHook;
		pFrameHook = (CIPCompFrameHook*)(pDoc->m_pItem->m_pInPlaceFrame);
		if(NULL != pFrameHook)
		{
			pFrameHook->ResetCommandTarget();
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\shell\ipcmpdoc.cpp ===
// ipcmpdoc.cpp : implementation of the CIPCompDoc class
//

#include "stdafx.h"
#pragma hdrstop

#include <afxodlgs.h>
#include <ocdevo.h>
#include "shldocs_.h"
#include "ipcmpctr.h"
#include "ipcfrmhk.h"
#include "ipcmpvw.h"
#include "ipcslob.h"
#include "ipcundo.h"
#include "docobfrm.h"
#include "resource.h"

IMPLEMENT_DYNCREATE(CIPCompDoc, CPartDoc)
IMPLEMENT_DYNAMIC(CIPCompDocTemplate, CPartTemplate)

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIPCompDoc


BEGIN_MESSAGE_MAP(CIPCompDoc, CPartDoc)
	//{{AFX_MSG_MAP(CIPCompDoc)

	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)

	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)

	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIPCompDoc construction/destruction

CIPCompDoc::CIPCompDoc()
{
	m_pIpCompSlob = NULL;
	m_pItem = NULL;
	m_fDocObjViewUIActive = FALSE;
	m_clsid = GUID_NULL;
}

CIPCompDoc::~CIPCompDoc()
{
	ASSERT_VALID(this);
	if(NULL != m_pIpCompSlob)
	{
		delete m_pIpCompSlob;
		m_pIpCompSlob = NULL;
	}
}

BOOL CIPCompDoc::NewOrLoadStorage(LPCTSTR pszPathName, IStorage ** ppStg, BOOL fNew)
{
	BOOL fRet = TRUE;
	if (fNew)
	{
		if (FAILED(StgCreateDocfile(NULL, STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
									 0, ppStg)))
			fRet = FALSE;
	}
	else
	{
		USES_CONVERSION;
		ASSERT(pszPathName != NULL);
		if (FAILED(StgOpenStorage(T2W(pszPathName), NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
									 NULL, 0, ppStg)))
			fRet = FALSE;
	}
	return fRet;
}

BOOL CIPCompDoc::NewDocumentHook()
{
	ASSERT(m_clsid != GUID_NULL);

	// IS Bug 6274 (to update SaveAll UI status)
	if (!CPartDoc::NewDocumentHook())
		return FALSE;

	CWaitCursor wc;
	COleRef<IStorage> srpStorage;
	NewOrLoadStorage(NULL, &srpStorage, TRUE);
		
	m_srpUndoMgr = new COleUndoManager;
	m_pItem = new CIPCompContainerItem(this);
	m_pIpCompSlob = new CIPCompSlob(this);
	BOOL fRet = FALSE;

	if(m_pItem && m_srpUndoMgr && m_pIpCompSlob && m_pIpCompSlob->Create() &&
		m_pItem->CreateNewFromClsid(m_clsid, srpStorage))
		fRet = InitOrLoadPersistence(srpStorage, TRUE);

	// it didn't work ... clean up
	if(!fRet)
	{
		::AfxMessageBox(IDS_ERROR_CANT_CREATE_IPCMPDOC);
		DoClose();
	}

	return fRet;
}

BOOL CIPCompDoc::OpenDocumentHook(LPCTSTR lpszPathName)
{
	ASSERT(m_clsid != GUID_NULL);

	CWaitCursor wc;
	// Note that COleUndoManager's constructor sets the
	// object's reference count to 1.
	//
	COleRef<IStorage> srpStorage;
	BOOL fRet = FALSE;

	if (!NewOrLoadStorage(lpszPathName, &srpStorage, FALSE))
	{
		// NewOrLoadStorage may not display the error.
		//
		::AfxMessageBox(IDS_ERROR_CANT_CREATE_IPCMPDOC);
	}
	else
	{
		m_srpUndoMgr = new COleUndoManager;
		m_pItem = new CIPCompContainerItem(this);
		m_pIpCompSlob = new CIPCompSlob(this);
	
		if(m_pItem && m_srpUndoMgr && m_pIpCompSlob && m_pIpCompSlob->Create() &&
			m_pItem->CreateNewFromClsid(m_clsid, srpStorage))
		{
			// If this fails, it will display an error message of its own
			//
			fRet = InitOrLoadPersistence(srpStorage, FALSE);
		}
		else
		{
			// CreateNewFromClsid doesn't display errors
			//
			::AfxMessageBox(IDS_ERROR_CANT_CREATE_IPCMPDOC);
		}
	}

	// it didn't work ... clean up
	if (!fRet)
	{
		DoClose();
	}
	else //$UNDONE, this is added because CPartTemplate incorrectly left it out.  
	{
		// Set Beautified path name
		CString strPathName(lpszPathName);
		GetActualFileCase(strPathName);
		SetPathName(strPathName);

		// IS Bug 6274 (to update SaveAll UI status)
		if (!CPartDoc::OpenDocumentHook(lpszPathName))
			return FALSE;

		// Check for ReadOnly file
		DWORD dwAttrib = GetFileAttributes(lpszPathName);
		if(-1 != dwAttrib && (dwAttrib & FILE_ATTRIBUTE_READONLY))
			// File is ReadOnly so set the flag
			SetReadOnlyOnDisk(TRUE);
	}

	return fRet;
}

void CIPCompDoc::CloseDocumentHook()
{
	// delete the contained item if any...this will close the doc object view.
	DoClose();
	CPartDoc::CloseDocumentHook();
}

void CIPCompDoc::DoClose()
{
	m_fDocObjViewUIActive = FALSE;
	
	if (m_pItem != NULL)
	{
		m_pItem->DoClose();
		CIPCompContainerItem * pTempItem = m_pItem;
		m_pItem = NULL;
		pTempItem->InternalRelease();
		OleRelease(m_lpRootStg);
	}
}


BOOL CIPCompDoc::CanCloseFrame(CFrameWnd *pFrame)
{
	BOOL fRet = TRUE;
	// if pFrame is NULL, only check whether we can close the container item,
	// do NOT call CanCloseFrame which will cause prompting to the user
	if (pFrame && m_fDocObjViewUIActive)
		fRet = COleDocument::CanCloseFrame(pFrame);

	if (fRet && m_pItem != NULL)
		fRet = m_pItem->CanClose();

	return fRet;
}

BOOL CIPCompDoc::InitOrLoadPersistence(IStorage * pStg, BOOL fNew)
{
	ASSERT(m_pItem != NULL);
	ASSERT(m_pItem->m_lpObject != NULL);
	
	BOOL fRet = FALSE;
	if (m_pItem && m_pItem->m_lpObject)
	{
		COleRef<IPersistStorage> srpPersistStorage;
		
		if (SUCCEEDED(m_pItem->m_lpObject->QueryInterface(IID_IPersistStorage,
					(void **)&srpPersistStorage)))
		{
			ASSERT(srpPersistStorage != NULL);
			HRESULT hr = E_FAIL;
			
			// Initialize the storage
			if (fNew)
				hr = srpPersistStorage->InitNew(pStg);
			else
				hr = srpPersistStorage->Load(pStg);
				
			if (SUCCEEDED(hr))
				fRet = TRUE;
		}
	}

	return fRet;
}

// OleCmdFromId maps an MFC command ID (i.e. command ID's routed
// to OnCmdMsg) to a (Guid, cmdid) pair recognized by IMsoCommandTarget.
// Derived classes should override this function to give access to
// the commands recognized by the components they host.
//
BOOL CIPCompDoc::OleCmdFromId(UINT, GUID **, DWORD *, DWORD *)
{
	// Base class implementation doesn't have any mapping information.
	//
	return FALSE;
}

// PopupDescFromGuidId maps a (Guid, MenuId) pair (as used by
// IOleComponentUIManager::ShowContextMenu) to a popup-menu
// description which can be passed to ::ShowContextPopupMenu.
// Derived classes should override this function using their
// hardwired knowledge about the components they host.
//
POPDESC * CIPCompDoc::PopupDescFromGuidId(REFGUID rguid, UINT nMenuId)
{
	// Base class implementation doesn't have any mapping information.
	//
	