  }
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    if ((this.CommandCollection[i] != null)) {
                        ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[i])).Connection = value;
                    }
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal global::System.Data.SqlClient.SqlTransaction Transaction {
            get {
                return this._transaction;
            }
            set {
                this._transaction = value;
                for (int i = 0; (i < this.CommandCollection.Length); i = (i + 1)) {
                    this.CommandCollection[i].Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.DeleteCommand != null))) {
                    this.Adapter.DeleteCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.InsertCommand != null))) {
                    this.Adapter.InsertCommand.Transaction = this._transaction;
                }
                if (((this.Adapter != null) 
                            && (this.Adapter.UpdateCommand != null))) {
                    this.Adapter.UpdateCommand.Transaction = this._transaction;
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.SqlClient.SqlCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool ClearBeforeFill {
            get {
                return this._clearBeforeFill;
            }
            set {
                this._clearBeforeFill = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitAdapter() {
            this._adapter = new global::System.Data.SqlClient.SqlDataAdapter();
            global::System.Data.Common.DataTableMapping tableMapping = new global::System.Data.Common.DataTableMapping();
            tableMapping.SourceTable = "Table";
            tableMapping.DataSetTable = "GetSummaryEvents";
            tableMapping.ColumnMappings.Add("TotalErrors", "TotalErrors");
            tableMapping.ColumnMappings.Add("MachineName", "MachineName");
            tableMapping.ColumnMappings.Add("TotalWarnings", "TotalWarnings");
            tableMapping.ColumnMappings.Add("TotalCriticals", "TotalCriticals");
            tableMapping.ColumnMappings.Add("TotalInformational", "TotalInformational");
            this._adapter.TableMappings.Add(tableMapping);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitConnection() {
            this._connection = new global::System.Data.SqlClient.SqlConnection();
            this._connection.ConnectionString = global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.SqlClient.SqlCommand[2];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[0].Connection = this.Connection;
            this._commandCollection[0].CommandText = "dbo.GetSummaryEvents";
            this._commandCollection[0].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@sDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@eDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceNameOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventType", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageId", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageIdOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SortKey", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[0].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Ascending", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1] = new global::System.Data.SqlClient.SqlCommand();
            this._commandCollection[1].Connection = this.Connection;
            this._commandCollection[1].CommandText = "dbo.GetSummaryEvents";
            this._commandCollection[1].CommandType = global::System.Data.CommandType.StoredProcedure;
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@sDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@eDate", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MachineOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceName", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SourceNameOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@EventType", global::System.Data.SqlDbType.NVarChar, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageId", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@MessageIdOp", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@SortKey", global::System.Data.SqlDbType.NVarChar, 100, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            this._commandCollection[1].Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@Ascending", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.Input, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Fill, true)]
        public virtual int Fill(DiagnosticDBDataSet.GetSummaryEventsDataTable dataTable, string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, string SortKey, global::System.Nullable<int> Ascending) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((sDate == null)) {
                this.Adapter.SelectCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                this.Adapter.SelectCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                this.Adapter.SelectCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                this.Adapter.SelectCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                this.Adapter.SelectCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((SortKey == null)) {
                this.Adapter.SelectCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[10].Value = ((string)(SortKey));
            }
            if ((Ascending.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[11].Value = ((int)(Ascending.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            if ((this.ClearBeforeFill == true)) {
                dataTable.Clear();
            }
            int returnValue = this.Adapter.Fill(dataTable);
            return returnValue;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, true)]
        public virtual DiagnosticDBDataSet.GetSummaryEventsDataTable GetSummaryEvents(string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, string SortKey, global::System.Nullable<int> Ascending) {
            this.Adapter.SelectCommand = this.CommandCollection[0];
            if ((sDate == null)) {
                this.Adapter.SelectCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                this.Adapter.SelectCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                this.Adapter.SelectCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                this.Adapter.SelectCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                this.Adapter.SelectCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((SortKey == null)) {
                this.Adapter.SelectCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[10].Value = ((string)(SortKey));
            }
            if ((Ascending.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[11].Value = ((int)(Ascending.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            DiagnosticDBDataSet.GetSummaryEventsDataTable dataTable = new DiagnosticDBDataSet.GetSummaryEventsDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        [global::System.ComponentModel.DataObjectMethodAttribute(global::System.ComponentModel.DataObjectMethodType.Select, false)]
        public virtual DiagnosticDBDataSet.GetSummaryEventsDataTable SummaryEventsEx(string sDate, string eDate, string MachineName, global::System.Nullable<int> MachineOp, string SourceName, global::System.Nullable<int> SourceNameOp, string EventType, global::System.Nullable<int> MessageId, global::System.Nullable<int> MessageIdOp, string SortKey, global::System.Nullable<int> Ascending) {
            this.Adapter.SelectCommand = this.CommandCollection[1];
            if ((sDate == null)) {
                this.Adapter.SelectCommand.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[1].Value = ((string)(sDate));
            }
            if ((eDate == null)) {
                this.Adapter.SelectCommand.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[2].Value = ((string)(eDate));
            }
            if ((MachineName == null)) {
                this.Adapter.SelectCommand.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[3].Value = ((string)(MachineName));
            }
            if ((MachineOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[4].Value = ((int)(MachineOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[4].Value = global::System.DBNull.Value;
            }
            if ((SourceName == null)) {
                this.Adapter.SelectCommand.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[5].Value = ((string)(SourceName));
            }
            if ((SourceNameOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[6].Value = ((int)(SourceNameOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[6].Value = global::System.DBNull.Value;
            }
            if ((EventType == null)) {
                this.Adapter.SelectCommand.Parameters[7].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[7].Value = ((string)(EventType));
            }
            if ((MessageId.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[8].Value = ((int)(MessageId.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[8].Value = global::System.DBNull.Value;
            }
            if ((MessageIdOp.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[9].Value = ((int)(MessageIdOp.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[9].Value = global::System.DBNull.Value;
            }
            if ((SortKey == null)) {
                this.Adapter.SelectCommand.Parameters[10].Value = global::System.DBNull.Value;
            }
            else {
                this.Adapter.SelectCommand.Parameters[10].Value = ((string)(SortKey));
            }
            if ((Ascending.HasValue == true)) {
                this.Adapter.SelectCommand.Parameters[11].Value = ((int)(Ascending.Value));
            }
            else {
                this.Adapter.SelectCommand.Parameters[11].Value = global::System.DBNull.Value;
            }
            DiagnosticDBDataSet.GetSummaryEventsDataTable dataTable = new DiagnosticDBDataSet.GetSummaryEventsDataTable();
            this.Adapter.Fill(dataTable);
            return dataTable;
        }
    }
    
    /// <summary>
    ///Represents the connection and commands used to retrieve and save data.
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DataObjectAttribute(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterDesigner, Microsoft.VSDesigner" +
        ", Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
    public partial class QueriesTableAdapter : global::System.ComponentModel.Component {
        
        private global::System.Data.IDbCommand[] _commandCollection;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected global::System.Data.IDbCommand[] CommandCollection {
            get {
                if ((this._commandCollection == null)) {
                    this.InitCommandCollection();
                }
                return this._commandCollection;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitCommandCollection() {
            this._commandCollection = new global::System.Data.IDbCommand[1];
            this._commandCollection[0] = new global::System.Data.SqlClient.SqlCommand();
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Connection = new global::System.Data.SqlClient.SqlConnection(global::Wgx.Services.Monitoring.Properties.Settings.Default.EventAggregatorConnectionString);
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).CommandText = "dbo.usp_Send";
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).CommandType = global::System.Data.CommandType.StoredProcedure;
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@RETURN_VALUE", global::System.Data.SqlDbType.Int, 4, global::System.Data.ParameterDirection.ReturnValue, 10, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@fromService", global::System.Data.SqlDbType.NVarChar, 128, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@toService", global::System.Data.SqlDbType.NVarChar, 128, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@onContract", global::System.Data.SqlDbType.NVarChar, 128, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@messageType", global::System.Data.SqlDbType.NVarChar, 128, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
            ((global::System.Data.SqlClient.SqlCommand)(this._commandCollection[0])).Parameters.Add(new global::System.Data.SqlClient.SqlParameter("@messageBody", global::System.Data.SqlDbType.Xml, 2147483647, global::System.Data.ParameterDirection.Input, 0, 0, null, global::System.Data.DataRowVersion.Current, false, null, "", "", ""));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapter")]
        public virtual object SendEventToAggregator(string fromService, string toService, string onContract, string messageType, object messageBody) {
            global::System.Data.SqlClient.SqlCommand command = ((global::System.Data.SqlClient.SqlCommand)(this.CommandCollection[0]));
            if ((fromService == null)) {
                command.Parameters[1].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[1].Value = ((string)(fromService));
            }
            if ((toService == null)) {
                command.Parameters[2].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[2].Value = ((string)(toService));
            }
            if ((onContract == null)) {
                command.Parameters[3].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[3].Value = ((string)(onContract));
            }
            if ((messageType == null)) {
                command.Parameters[4].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[4].Value = ((string)(messageType));
            }
            if ((messageBody == null)) {
                command.Parameters[5].Value = global::System.DBNull.Value;
            }
            else {
                command.Parameters[5].Value = ((object)(messageBody));
            }
            global::System.Data.ConnectionState previousConnectionState = command.Connection.State;
            if (((command.Connection.State & global::System.Data.ConnectionState.Open) 
                        != global::System.Data.ConnectionState.Open)) {
                command.Connection.Open();
            }
            object returnValue;
            try {
                returnValue = command.ExecuteScalar();
            }
            finally {
                if ((previousConnectionState == global::System.Data.ConnectionState.Closed)) {
                    command.Connection.Close();
                }
            }
            if (((returnValue == null) 
                        || (returnValue.GetType() == typeof(global::System.DBNull)))) {
                return null;
            }
            else {
                return ((object)(returnValue));
            }
        }
    }
    
    /// <summary>
    ///TableAdapterManager is used to coordinate TableAdapters in the dataset to enable Hierarchical Update scenarios
    ///</summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.ComponentModel.DesignerAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterManagerDesigner, Microsoft.VSD" +
        "esigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.TableAdapterManager")]
    public partial class TableAdapterManager : global::System.ComponentModel.Component {
        
        private UpdateOrderOption _updateOrder;
        
        private ListenerFilterTableAdapter _listenerFilterTableAdapter;
        
        private TraceConfigurationSettingsTableAdapter _traceConfigurationSettingsTableAdapter;
        
        private EventsXmlTableAdapter _eventsXmlTableAdapter;
        
        private EventsTableAdapter _eventsTableAdapter;
        
        private bool _backupDataSetBeforeUpdate;
        
        private global::System.Data.IDbConnection _connection;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public UpdateOrderOption UpdateOrder {
            get {
                return this._updateOrder;
            }
            set {
                this._updateOrder = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.EditorAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterManagerPropertyEditor, Microso" +
            "ft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
            "", "System.Drawing.Design.UITypeEditor")]
        public ListenerFilterTableAdapter ListenerFilterTableAdapter {
            get {
                return this._listenerFilterTableAdapter;
            }
            set {
                this._listenerFilterTableAdapter = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.EditorAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterManagerPropertyEditor, Microso" +
            "ft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
            "", "System.Drawing.Design.UITypeEditor")]
        public TraceConfigurationSettingsTableAdapter TraceConfigurationSettingsTableAdapter {
            get {
                return this._traceConfigurationSettingsTableAdapter;
            }
            set {
                this._traceConfigurationSettingsTableAdapter = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.EditorAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterManagerPropertyEditor, Microso" +
            "ft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
            "", "System.Drawing.Design.UITypeEditor")]
        public EventsXmlTableAdapter EventsXmlTableAdapter {
            get {
                return this._eventsXmlTableAdapter;
            }
            set {
                this._eventsXmlTableAdapter = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.EditorAttribute("Microsoft.VSDesigner.DataSource.Design.TableAdapterManagerPropertyEditor, Microso" +
            "ft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" +
            "", "System.Drawing.Design.UITypeEditor")]
        public EventsTableAdapter EventsTableAdapter {
            get {
                return this._eventsTableAdapter;
            }
            set {
                this._eventsTableAdapter = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public bool BackupDataSetBeforeUpdate {
            get {
                return this._backupDataSetBeforeUpdate;
            }
            set {
                this._backupDataSetBeforeUpdate = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        public global::System.Data.IDbConnection Connection {
            get {
                if ((this._connection != null)) {
                    return this._connection;
                }
                if (((this._listenerFilterTableAdapter != null) 
                            && (this._listenerFilterTableAdapter.Connection != null))) {
                    return this._listenerFilterTableAdapter.Connection;
                }
                if (((this._traceConfigurationSettingsTableAdapter != null) 
                            && (this._traceConfigurationSettingsTableAdapter.Connection != null))) {
                    return this._traceConfigurationSettingsTableAdapter.Connection;
                }
                if (((this._eventsXmlTableAdapter != null) 
                            && (this._eventsXmlTableAdapter.Connection != null))) {
                    return this._eventsXmlTableAdapter.Connection;
                }
                if (((this._eventsTableAdapter != null) 
                            && (this._eventsTableAdapter.Connection != null))) {
                    return this._eventsTableAdapter.Connection;
                }
                return null;
            }
            set {
                this._connection = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        public int TableAdapterInstanceCount {
            get {
                int count = 0;
                if ((this._listenerFilterTableAdapter != null)) {
                    count = (count + 1);
                }
                if ((this._traceConfigurationSettingsTableAdapter != null)) {
                    count = (count + 1);
                }
                if ((this._eventsXmlTableAdapter != null)) {
                    count = (count + 1);
                }
                if ((this._eventsTableAdapter != null)) {
                    count = (count + 1);
                }
                return count;
            }
        }
        
        /// <summary>
        ///Update rows in top-down order.
        ///</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private int UpdateUpdatedRows(DiagnosticDBDataSet dataSet, global::System.Collections.Generic.List<global::System.Data.DataRow> allChangedRows, global::System.Collections.Generic.List<global::System.Data.DataRow> allAddedRows) {
            int result = 0;
            if ((this._eventsTableAdapter != null)) {
                global::System.Data.DataRow[] updatedRows = dataSet.Events.Select(null, null, global::System.Data.DataViewRowState.ModifiedCurrent);
                updatedRows = this.GetRealUpdatedRows(updatedRows, allAddedRows);
                if (((updatedRows != null) 
                            && (0 < updatedRows.Length))) {
                    result = (result + this._eventsTableAdapter.Update(updatedRows));
                    allChangedRows.AddRange(updatedRows);
                }
            }
            if ((this._listenerFilterTableAdapter != null)) {
                global::System.Data.DataRow[] updatedRows = dataSet.ListenerFilter.Select(null, null, global::System.Data.DataViewRowState.ModifiedCurrent);
                updatedRows = this.GetRealUpdatedRows(updatedRows, allAddedRows);
                if (((updatedRows != null) 
                            && (0 < updatedRows.Length))) {
                    result = (result + this._listenerFilterTableAdapter.Update(updatedRows));
                    allChangedRows.AddRange(updatedRows);
                }
            }
            if ((this._eventsXmlTableAdapter != null)) {
                global::System.Data.DataRow[] updatedRows = dataSet.EventsXml.Select(null, null, global::System.Data.DataViewRowState.ModifiedCurrent);
                updatedRows = this.GetRealUpdatedRows(updatedRows, allAddedRows);
                if (((updatedRows != null) 
                            && (0 < updatedRows.Length))) {
                    result = (result + this._eventsXmlTableAdapter.Update(updatedRows));
                    allChangedRows.AddRange(updatedRows);
                }
            }
            if ((this._traceConfigurationSettingsTableAdapter != null)) {
                global::System.Data.DataRow[] updatedRows = dataSet.TraceConfigurationSettings.Select(null, null, global::System.Data.DataViewRowState.ModifiedCurrent);
                updatedRows = this.GetRealUpdatedRows(updatedRows, allAddedRows);
                if (((updatedRows != null) 
                            && (0 < updatedRows.Length))) {
                    result = (result + this._traceConfigurationSettingsTableAdapter.Update(updatedRows));
                    allChangedRows.AddRange(updatedRows);
                }
            }
            return result;
        }
        
        /// <summary>
        ///Insert rows in top-down order.
        ///</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private int UpdateInsertedRows(DiagnosticDBDataSet dataSet, global::System.Collections.Generic.List<global::System.Data.DataRow> allAddedRows) {
            int result = 0;
            if ((this._eventsTableAdapter != null)) {
                global::System.Data.DataRow[] addedRows = dataSet.Events.Select(null, null, global::System.Data.DataViewRowState.Added);
                if (((addedRows != null) 
                            && (0 < addedRows.Length))) {
                    result = (result + this._eventsTableAdapter.Update(addedRows));
                    allAddedRows.AddRange(addedRows);
                }
            }
            if ((this._listenerFilterTableAdapter != null)) {
                global::System.Data.DataRow[] addedRows = dataSet.ListenerFilter.Select(null, null, global::System.Data.DataViewRowState.Added);
                if (((addedRows != null) 
                            && (0 < addedRows.Length))) {
                    result = (result + this._listenerFilterTableAdapter.Update(addedRows));
                    allAddedRows.AddRange(addedRows);
                }
            }
            if ((this._eventsXmlTableAdapter != null)) {
                global::System.Data.DataRow[] addedRows = dataSet.EventsXml.Select(null, null, global::System.Data.DataViewRowState.Added);
                if (((addedRows != null) 
                            && (0 < addedRows.Length))) {
                    result = (result + this._eventsXmlTableAdapter.Update(addedRows));
                    allAddedRows.AddRange(addedRows);
                }
            }
            if ((this._traceConfigurationSettingsTableAdapter != null)) {
                global::System.Data.DataRow[] addedRows = dataSet.TraceConfigurationSettings.Select(null, null, global::System.Data.DataViewRowState.Added);
                if (((addedRows != null) 
                            && (0 < addedRows.Length))) {
                    result = (result + this._traceConfigurationSettingsTableAdapter.Update(addedRows));
                    allAddedRows.AddRange(addedRows);
                }
            }
            return result;
        }
        
        /// <summary>
        ///Delete rows in bottom-up order.
        ///</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private int UpdateDeletedRows(DiagnosticDBDataSet dataSet, global::System.Collections.Generic.List<global::System.Data.DataRow> allChangedRows) {
            int result = 0;
            if ((this._traceConfigurationSettingsTableAdapter != null)) {
                global::System.Data.DataRow[] deletedRows = dataSet.TraceConfigurationSettings.Select(null, null, global::System.Data.DataViewRowState.Deleted);
                if (((deletedRows != null) 
                            && (0 < deletedRows.Length))) {
                    result = (result + this._traceConfigurationSettingsTableAdapter.Update(deletedRows));
                    allChangedRows.AddRange(deletedRows);
                }
            }
            if ((this._eventsXmlTableAdapter != null)) {
                global::System.Data.DataRow[] deletedRows = dataSet.EventsXml.Select(null, null, global::System.Data.DataViewRowState.Deleted);
                if (((deletedRows != null) 
                            && (0 < deletedRows.Length))) {
                    result = (result + this._eventsXmlTableAdapter.Update(deletedRows));
                    allChangedRows.AddRange(deletedRows);
                }
            }
            if ((this._listenerFilterTableAdapter != null)) {
                global::System.Data.DataRow[] deletedRows = dataSet.ListenerFilter.Select(null, null, global::System.Data.DataViewRowState.Deleted);
                if (((deletedRows != null) 
                            && (0 < deletedRows.Length))) {
                    result = (result + this._listenerFilterTableAdapter.Update(deletedRows));
                    allChangedRows.AddRange(deletedRows);
                }
            }
            if ((this._eventsTableAdapter != null)) {
                global::System.Data.DataRow[] deletedRows = dataSet.Events.Select(null, null, global::System.Data.DataViewRowState.Deleted);
                if (((deletedRows != null) 
                            && (0 < deletedRows.Length))) {
                    result = (result + this._eventsTableAdapter.Update(deletedRows));
                    allChangedRows.AddRange(deletedRows);
                }
            }
            return result;
        }
        
        /// <summary>
        ///Remove inserted rows that become updated rows after calling TableAdapter.Update(inserted rows) first
        ///</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private global::System.Data.DataRow[] GetRealUpdatedRows(global::System.Data.DataRow[] updatedRows, global::System.Collections.Generic.List<global::System.Data.DataRow> allAddedRows) {
            if (((updatedRows == null) 
                        || (updatedRows.Length < 1))) {
                return updatedRows;
            }
            if (((allAddedRows == null) 
                        || (allAddedRows.Count < 1))) {
                return updatedRows;
            }
            global::System.Collections.Generic.List<global::System.Data.DataRow> realUpdatedRows = new global::System.Collections.Generic.List<global::System.Data.DataRow>();
            for (int i = 0; (i < updatedRows.Length); i = (i + 1)) {
                global::System.Data.DataRow row = updatedRows[i];
                if ((allAddedRows.Contains(row) == false)) {
                    realUpdatedRows.Add(row);
                }
            }
            return realUpdatedRows.ToArray();
        }
        
        /// <summary>
        ///Update all changes to the dataset.
        ///</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public virtual int UpdateAll(DiagnosticDBDataSet dataSet) {
            if ((dataSet == null)) {
                throw new global::System.ArgumentNullException("dataSet");
            }
            if ((dataSet.HasChanges() == false)) {
                return 0;
            }
            if (((this._listenerFilterTableAdapter != null) 
                        && (this.MatchTableAdapterConnection(this._listenerFilterTableAdapter.Connection) == false))) {
                throw new global::System.ArgumentException("All TableAdapters managed by a TableAdapterManager must use the same connection s" +
                        "tring.");
            }
            if (((this._traceConfigurationSettingsTableAdapter != null) 
                        && (this.MatchTableAdapterConnection(this._traceConfigurationSettingsTableAdapter.Connection) == false))) {
                throw new global::System.ArgumentException("All TableAdapters managed by a TableAdapterManager must use the same connection s" +
                        "tring.");
            }
            if (((this._eventsXmlTableAdapter != null) 
                        && (this.MatchTableAdapterConnection(this._eventsXmlTableAdapter.Connection) == false))) {
                throw new global::System.ArgumentException("All TableAdapters managed by a TableAdapterManager must use the same connection s" +
                        "tring.");
            }
            if (((this._eventsTableAdapter != null) 
                        && (this.MatchTableAdapterConnection(this._eventsTableAdapter.Connection) == false))) {
                throw new global::System.ArgumentException("All TableAdapters managed by a TableAdapterManager must use the same connection s" +
                        "tring.");
            }
            global::System.Data.IDbConnection workConnection = this.Connection;
            if ((workConnection == null)) {
                throw new global::System.ApplicationException("TableAdapterManager contains no connection information. Set each TableAdapterMana" +
                        "ger TableAdapter property to a valid TableAdapter instance.");
            }
            bool workConnOpened = false;
            if (((workConnection.State & global::System.Data.ConnectionState.Broken) 
                        == global::System.Data.ConnectionState.Broken)) {
                workConnection.Close();
            }
            if ((workConnection.State == global::System.Data.ConnectionState.Closed)) {
                workConnection.Open();
                workConnOpened = true;
            }
            global::System.Data.IDbTransaction workTransaction = workConnection.BeginTransaction();
            if ((workTransaction == null)) {
                throw new global::System.ApplicationException("The transaction cannot begin. The current data connection does not support transa" +
                        "ctions or the current state is not allowing the transaction to begin.");
            }
            global::System.Collections.Generic.List<global::System.Data.DataRow> allChangedRows = new global::System.Collections.Generic.List<global::System.Data.DataRow>();
            global::System.Collections.Generic.List<global::System.Data.DataRow> allAddedRows = new global::System.Collections.Generic.List<global::System.Data.DataRow>();
            global::System.Collections.Generic.List<global::System.Data.Common.DataAdapter> adaptersWithAcceptChangesDuringUpdate = new global::System.Collections.Generic.List<global::System.Data.Common.DataAdapter>();
            global::System.Collections.Generic.Dictionary<object, global::System.Data.IDbConnection> revertConnections = new global::System.Collections.Generic.Dictionary<object, global::System.Data.IDbConnection>();
            int result = 0;
            global::System.Data.DataSet backupDataSet = null;
            if (this.BackupDataSetBeforeUpdate) {
                backupDataSet = new global::System.Data.DataSet();
                backupDataSet.Merge(dataSet);
            }
            try {
                // ---- Prepare for update -----------
                //
                if ((this._listenerFilterTableAdapter != null)) {
                    revertConnections.Add(this._listenerFilterTableAdapter, this._listenerFilterTableAdapter.Connection);
                    this._listenerFilterTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(workConnection));
                    this._listenerFilterTableAdapter.Transaction = ((global::System.Data.SqlClient.SqlTransaction)(workTransaction));
                    if (this._listenerFilterTableAdapter.Adapter.AcceptChangesDuringUpdate) {
                        this._listenerFilterTableAdapter.Adapter.AcceptChangesDuringUpdate = false;
                        adaptersWithAcceptChangesDuringUpdate.Add(this._listenerFilterTableAdapter.Adapter);
                    }
                }
                if ((this._traceConfigurationSettingsTableAdapter != null)) {
                    revertConnections.Add(this._traceConfigurationSettingsTableAdapter, this._traceConfigurationSettingsTableAdapter.Connection);
                    this._traceConfigurationSettingsTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(workConnection));
                    this._traceConfigurationSettingsTableAdapter.Transaction = ((global::System.Data.SqlClient.SqlTransaction)(workTransaction));
                    if (this._traceConfigurationSettingsTableAdapter.Adapter.AcceptChangesDuringUpdate) {
                        this._traceConfigurationSettingsTableAdapter.Adapter.AcceptChangesDuringUpdate = false;
                        adaptersWithAcceptChangesDuringUpdate.Add(this._traceConfigurationSettingsTableAdapter.Adapter);
                    }
                }
                if ((this._eventsXmlTableAdapter != null)) {
                    revertConnections.Add(this._eventsXmlTableAdapter, this._eventsXmlTableAdapter.Connection);
                    this._eventsXmlTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(workConnection));
                    this._eventsXmlTableAdapter.Transaction = ((global::System.Data.SqlClient.SqlTransaction)(workTransaction));
                    if (this._eventsXmlTableAdapter.Adapter.AcceptChangesDuringUpdate) {
                        this._eventsXmlTableAdapter.Adapter.AcceptChangesDuringUpdate = false;
                        adaptersWithAcceptChangesDuringUpdate.Add(this._eventsXmlTableAdapter.Adapter);
                    }
                }
                if ((this._eventsTableAdapter != null)) {
                    revertConnections.Add(this._eventsTableAdapter, this._eventsTableAdapter.Connection);
                    this._eventsTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(workConnection));
                    this._eventsTableAdapter.Transaction = ((global::System.Data.SqlClient.SqlTransaction)(workTransaction));
                    if (this._eventsTableAdapter.Adapter.AcceptChangesDuringUpdate) {
                        this._eventsTableAdapter.Adapter.AcceptChangesDuringUpdate = false;
                        adaptersWithAcceptChangesDuringUpdate.Add(this._eventsTableAdapter.Adapter);
                    }
                }
                // 
                //---- Perform updates -----------
                //
                if ((this.UpdateOrder == UpdateOrderOption.UpdateInsertDelete)) {
                    result = (result + this.UpdateUpdatedRows(dataSet, allChangedRows, allAddedRows));
                    result = (result + this.UpdateInsertedRows(dataSet, allAddedRows));
                }
                else {
                    result = (result + this.UpdateInsertedRows(dataSet, allAddedRows));
                    result = (result + this.UpdateUpdatedRows(dataSet, allChangedRows, allAddedRows));
                }
                result = (result + this.UpdateDeletedRows(dataSet, allChangedRows));
                // 
                //---- Commit updates -----------
                //
                workTransaction.Commit();
                if ((0 < allAddedRows.Count)) {
                    global::System.Data.DataRow[] rows = new System.Data.DataRow[allAddedRows.Count];
                    allAddedRows.CopyTo(rows);
                    for (int i = 0; (i < rows.Length); i = (i + 1)) {
                        global::System.Data.DataRow row = rows[i];
                        row.AcceptChanges();
                    }
                }
                if ((0 < allChangedRows.Count)) {
                    global::System.Data.DataRow[] rows = new System.Data.DataRow[allChangedRows.Count];
                    allChangedRows.CopyTo(rows);
                    for (int i = 0; (i < rows.Length); i = (i + 1)) {
                        global::System.Data.DataRow row = rows[i];
                        row.AcceptChanges();
                    }
                }
            }
            catch (global::System.Exception ex) {
                workTransaction.Rollback();
                // ---- Restore the dataset -----------
                if (this.BackupDataSetBeforeUpdate) {
                    global::System.Diagnostics.Debug.Assert((backupDataSet != null));
                    dataSet.Clear();
                    dataSet.Merge(backupDataSet);
                }
                else {
                    if ((0 < allAddedRows.Count)) {
                        global::System.Data.DataRow[] rows = new System.Data.DataRow[allAddedRows.Count];
                        allAddedRows.CopyTo(rows);
                        for (int i = 0; (i < rows.Length); i = (i + 1)) {
                            global::System.Data.DataRow row = rows[i];
                            row.AcceptChanges();
                            row.SetAdded();
                        }
                    }
                }
                throw ex;
            }
            finally {
                if (workConnOpened) {
                    workConnection.Close();
                }
                if ((this._listenerFilterTableAdapter != null)) {
                    this._listenerFilterTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(revertConnections[this._listenerFilterTableAdapter]));
                    this._listenerFilterTableAdapter.Transaction = null;
                }
                if ((this._traceConfigurationSettingsTableAdapter != null)) {
                    this._traceConfigurationSettingsTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(revertConnections[this._traceConfigurationSettingsTableAdapter]));
                    this._traceConfigurationSettingsTableAdapter.Transaction = null;
                }
                if ((this._eventsXmlTableAdapter != null)) {
                    this._eventsXmlTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(revertConnections[this._eventsXmlTableAdapter]));
                    this._eventsXmlTableAdapter.Transaction = null;
                }
                if ((this._eventsTableAdapter != null)) {
                    this._eventsTableAdapter.Connection = ((global::System.Data.SqlClient.SqlConnection)(revertConnections[this._eventsTableAdapter]));
                    this._eventsTableAdapter.Transaction = null;
                }
                if ((0 < adaptersWithAcceptChangesDuringUpdate.Count)) {
                    global::System.Data.Common.DataAdapter[] adapters = new System.Data.Common.DataAdapter[adaptersWithAcceptChangesDuringUpdate.Count];
                    adaptersWithAcceptChangesDuringUpdate.CopyTo(adapters);
                    for (int i = 0; (i < adapters.Length); i = (i + 1)) {
                        global::System.Data.Common.DataAdapter adapter = adapters[i];
                        adapter.AcceptChangesDuringUpdate = true;
                    }
                }
            }
            return result;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected virtual void SortSelfReferenceRows(global::System.Data.DataRow[] rows, global::System.Data.DataRelation relation, bool childFirst) {
            global::System.Array.Sort<global::System.Data.DataRow>(rows, new SelfReferenceComparer(relation, childFirst));
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected virtual bool MatchTableAdapterConnection(global::System.Data.IDbConnection inputConnection) {
            if ((this._connection != null)) {
                return true;
            }
            if (((this.Connection == null) 
                        || (inputConnection == null))) {
                return true;
            }
            if (string.Equals(this.Connection.ConnectionString, inputConnection.ConnectionString, global::System.StringComparison.Ordinal)) {
                return true;
            }
            return false;
        }
        
        /// <summary>
        ///Update Order Option
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public enum UpdateOrderOption {
            
            InsertUpdateDelete = 0,
            
            UpdateInsertDelete = 1,
        }
        
        /// <summary>
        ///Used to sort self-referenced table's rows
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        private class SelfReferenceComparer : object, global::System.Collections.Generic.IComparer<global::System.Data.DataRow> {
            
            private global::System.Data.DataRelation _relation;
            
            private int _childFirst;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal SelfReferenceComparer(global::System.Data.DataRelation relation, bool childFirst) {
                this._relation = relation;
                if (childFirst) {
                    this._childFirst = -1;
                }
                else {
                    this._childFirst = 1;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private bool IsChildAndParent(global::System.Data.DataRow child, global::System.Data.DataRow parent) {
                global::System.Diagnostics.Debug.Assert((child != null));
                global::System.Diagnostics.Debug.Assert((parent != null));
                global::System.Data.DataRow newParent = child.GetParentRow(this._relation, global::System.Data.DataRowVersion.Default);
                for (
                ; ((newParent != null) 
                            && ((object.ReferenceEquals(newParent, child) == false) 
                            && (object.ReferenceEquals(newParent, parent) == false))); 
                ) {
                    newParent = newParent.GetParentRow(this._relation, global::System.Data.DataRowVersion.Default);
                }
                if ((newParent == null)) {
                    for (newParent = child.GetParentRow(this._relation, global::System.Data.DataRowVersion.Original); ((newParent != null) 
                                && ((object.ReferenceEquals(newParent, child) == false) 
                                && (object.ReferenceEquals(newParent, parent) == false))); 
                    ) {
                        newParent = newParent.GetParentRow(this._relation, global::System.Data.DataRowVersion.Original);
                    }
                }
                if (object.ReferenceEquals(newParent, parent)) {
                    return true;
                }
                return false;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int Compare(global::System.Data.DataRow row1, global::System.Data.DataRow row2) {
                if (object.ReferenceEquals(row1, row2)) {
                    return 0;
                }
                if ((row1 == null)) {
                    return -1;
                }
                if ((row2 == null)) {
                    return 1;
                }

                // Is row1 the child or grandchild of row2
                if (this.IsChildAndParent(row1, row2)) {
                    return this._childFirst;
                }

                // Is row2 the child or grandchild of row1
                if (this.IsChildAndParent(row2, row1)) {
                    return (-1 * this._childFirst);
                }
                return 0;
            }
        }
    }
}

#pragma warning restore 1591
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\DiagnosticListener\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("DiagnosticListener")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DiagnosticListener")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("9c071178-8394-4fbe-88dc-e5f83fd8d173")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\DiagnosticDAL\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wgx.Services.Monitoring.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        public string EventAggregatorConnectionString 
        {
            get
            {
                try
                {
                    return System.Configuration.ConfigurationManager.ConnectionStrings["EventAggregatorDBConnectionString"].ConnectionString;
                }
                catch (System.NullReferenceException ex)
                {
                    throw new System.Configuration.ConfigurationErrorsException("Wgx.Services.Monitoring, error attempting to access connection string from app config file for key EventAggregatorDBConnectionString", ex);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\DiagnosticListener\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3031
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WGXMonitoring.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=|DataDirectory|\\Diagnostic.sdf")]
        public string DiagnosticConnectionString {
            get {
                return ((string)(this["DiagnosticConnectionString"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=(local);Initial Catalog=DiagnosticDB;Integrated Security=True")]
        public string DiagnosticDBConnectionString {
            get {
                return ((string)(this["DiagnosticDBConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\EventProvider\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("EvenProvider")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("EvenProvider")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e839c374-bcd8-47a0-b572-54d3b8b11adb")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\DiagnosticListener\DiagnosticListener.cs ===
//------------------------------------------------------------------------------------------------- 
// <copyright file="DiagnosticListener.cs" company="Microsoft" author="Ron Estrin">
// Copyright   .  All rights reserved.
// </copyright>
// <summary>Logs events to the sql database (EventAggregatorDB).</summary>
//-------------------------------------------------------------------------------------------------
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Diagnostics;
    using System.Runtime.Remoting.Messaging;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Channels.Tcp;
    using Wgx.Services.Monitoring.DiagnosticDBDataSetTableAdapters;

    public class WgxTraceListener : System.Diagnostics.TraceListener
    {
        // this is the queue the holds the event messages
        private System.Collections.Queue queue = new System.Collections.Queue();
        // this wait handle is used to signal the worker thread to process the event queue
        private System.Threading.AutoResetEvent processEvent = new System.Threading.AutoResetEvent(false);
        // this is the table adapter for calling into Service Broker
        private QueriesTableAdapter adapter = new QueriesTableAdapter();

        public WgxTraceListener(string name)
            : base(name)
        {
            // this is the thread that monitors the queue
            System.Threading.Thread thread = new System.Threading.Thread(new System.Threading.ThreadStart(this.DequeueMessage));
            thread.Start();
        }
        public WgxTraceListener() : base()
        {
            // this is the thread that monitors the queue
            System.Threading.Thread thread = new System.Threading.Thread(new System.Threading.ThreadStart(this.DequeueMessage));
            thread.Start();
        }
        
        /// <summary>
        /// Used for legacy purposes only, does not provide event meta data
        /// </summary>
        /// <param name="message"></param>
        public override void Write(string message)
        {
            TraceEvent(null, null, TraceEventType.Information, -1, message);
        }

        /// <summary>
        /// Used for legacy purposes only, does not provide event meta data
        /// </summary>
        /// <param name="message"></param>
        public override void WriteLine(string message)
        {
            TraceEvent(null, null, TraceEventType.Information, -1, message);
        }

        public override bool IsThreadSafe 
        {
            get { return true; }
        }

        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if (this.Filter == null || this.Filter.ShouldTrace(eventCache, Name, eventType, id, null, null, this, null))
            {
                lock (this.queue.SyncRoot)
                {
                    try
                    {
                        this.queue.Enqueue(message);
                    }
                    catch (System.OutOfMemoryException ex)
                    {
                        WriteEventLog(string.Format("Unable to Enqueue message, out of memory exception {0}", ex.Message), EventLogEntryType.Error, 1048);
                    }
                }
                processEvent.Set();
            }
        }

        protected void SendToEventAggegator(object xmlData)
        {
            try
            {
                this.adapter.SendEventToAggregator("InitiatorService", "TargetService", "EventContract", "EventMessageType", xmlData);
            }
            catch (ArgumentException ex)
            {
                WriteEventLog(string.Format("Failure writing event to database: {0}", ex.Message), System.Diagnostics.EventLogEntryType.Error, 1030);
            }
            catch (InvalidOperationException ex)
            {
                WriteEventLog(string.Format("Failure writing event to database: {0}", ex.Message), System.Diagnostics.EventLogEntryType.Error, 1031);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                WriteEventLog(string.Format("Failure writing event to database: {0}", ex.Message), System.Diagnostics.EventLogEntryType.Error, 1032);
            }
        }

        protected void DequeueMessage()
        {
            // the thread never terminates
            while (true)
            {
                // waits for signal from main thread to indicate that there are events to process in the queue
                this.processEvent.WaitOne();
                // process all events in the queue
                while (this.queue.Count > 0)
                {
                    object message = this.queue.Dequeue();
                    SendToEventAggegator(message);
                }
            }
        }

        private void WriteEventLog(string errorMsg, EventLogEntryType entryType, int msgID)
        {
            System.Diagnostics.EventLog eventLog = new EventLog("Application", System.Environment.MachineName, this.GetType().FullName);
            eventLog.WriteEntry(string.Format("Source Name: {0}, Machine Name: {1}, Error writing message id {2}, error msg: {3}", this.Name, System.Environment.MachineName, msgID, errorMsg), entryType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\EventProvider\settings.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3031
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WGXMonitoring.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=WIN-B6F3113JBYG;Initial Catalog=DiagnosticDB;Integrated Security=True" +
            ";Asynchronous Processing=true")]
        public string DiagnosticDBAsyncConnectionString {
            get {
                return ((string)(this["DiagnosticDBAsyncConnectionString"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=.\\SQLEXPRESS;AttachDbFilename=|DataDirectory|\\diagnosticdb.mdf;Integr" +
            "ated Security=True;User Instance=True")]
        public string diagnosticdbConnectionString {
            get {
                return ((string)(this["diagnosticdbConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\UnitTests\EventsCollectionTest.cs ===
using Wgx.Services.Monitoring;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;

namespace WGXMonitoring
{
    /// <summary>
    ///This is a test class for EventsCollectionTest and is intended
    ///to contain all EventsCollectionTest Unit Tests
    ///</summary>
    [TestClass()]
    public class EventsCollectionTest
    {
        private TestContext testContextInstance;
        private static WgxTraceSource g_ts;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }

            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext testContext)
        {
            g_ts = new WgxTraceSource("EventsCollectionTest");
            g_ts.Switch.Level = System.Diagnostics.SourceLevels.All;
            g_ts.TraceOptions = TraceOptionsEx.MethodName;
        }
        #endregion

        /// <summary>
        ///A test for Initialize
        ///</summary>
        [TestMethod()]
        [DeploymentItem("WGX.Services.Monitoring.dll")]
        public void InitializeTest()
        {
        }

         /// <summary>
        ///A test for TraceEvent
        ///</summary>
        [TestMethod()]
        public void TraceEventTest1()
        {
            int index = 0;
            EventsCollection events = g_ts.GetEventsCollection(new Messages1());
            foreach (EventAttribute ea in events)
            {
                Assert.AreEqual(ea.MessageId, 1000 + index * 10);
                events.TraceEvent(index++, new object[] {ea.MessageId});
            }
        }

        [TestMethod()]
        public void TraceEventTest2()
        {
            int index = 0;
            EventsCollection events = g_ts.GetEventsCollection(new Messages2());
            foreach (EventAttribute ea in events)
            {
                Assert.AreEqual(ea.MessageId, 2000 + index * 20);
                events.TraceEvent(index++, new object [] {ea.MessageId});
            }
        }

        [TestMethod()]
        public void TraceEventTest3()
        {
            int index = 0;
            EventsCollection events = g_ts.GetEventsCollection(new Messages3());
            foreach (EventAttribute ea in events)
            {
                Assert.AreEqual(ea.MessageId, 100 + index);
                events.TraceEvent(index++, new object[] { ea.MessageId });
            }
        }

        [TestMethod()]
        //[ExpectedException(typeof(TraceSourceGeneralException))]
        public void TraceEventTest4()
        {
            int index = 0;
            EventsCollection events = g_ts.GetEventsCollection(new Messages4());
            foreach (EventAttribute ea in events)
            {
                Assert.AreEqual(ea.MessageId, 100 + index);
                events.TraceEvent(index++, new object[] { ea.MessageId });
            }
        }

        [TestMethod()]
        public void TestDebugTrace()
        {
            foreach (System.Diagnostics.TraceListener listener in g_ts.Listeners)
            {
                if (!System.Diagnostics.Debug.Listeners.Contains(listener))
                {
                    System.Diagnostics.Debug.Listeners.Add(listener);
                }
            }

            System.Diagnostics.Debug.Write("Test line");
            System.Diagnostics.Debug.WriteLine("Another test Line");
            System.Diagnostics.Debug.WriteIf(true, "true value");
            System.Diagnostics.Debug.WriteLineIf(true, "true value");
        }

        [TestMethod]
        public void TestTracing()
        {
            g_ts.TraceEvent(System.Diagnostics.TraceEventType.Information, 1000, "My Test Event");
            g_ts.TraceEvent(System.Diagnostics.TraceEventType.Information, 1000, "My Test Event {0}", 1);
        }

        [TestMethod]
        public void TraceBinaryData()
        {
            g_ts.TraceEvent(System.Diagnostics.TraceEventType.Critical, 10, "\0A\0\0=J\fQCEd7&\\VvU\0\0\0\0\0\n\0\t\0d\0b\0\0\0\0\0c\0");
        }

        [EventCategory(MessageIdBase = 1000)]
        public class Messages1
        {
            [Event(Message = "Test message for message ID {0}")]
            public int msg1;
            [Event(Message = "Test message for message ID {0}")]
            public int msg2;
            [Event(Message = "Test message for message ID {0}")]
            public int msg3;
            [Event(Message = "Test message for message ID {0}")]
            public int msg4;
            [Event(Message = "Test message for message ID {0}")]
            public int msg5;
        }
       
        [EventCategory(MessageIdBase = 2000, IncrementAmount=20)]
        public class Messages2
        {
            [Event(Message = "Test message for message ID {0}")]
            public int msg1 = 0;
            [Event(Message = "Test message for message ID {0}")]
            public int msg2 = 0;
            [Event(Message = "Test message for message ID {0}")]
            public int msg3 = 0;
            [Event(Message = "Test message for message ID {0}")]
            public int msg4 = 0;
            [Event(Message = "Test message for message ID {0}")]
            public int msg5 = 0;
        }

        [EventCategory(MessageIdBase = 3000)]
        public class Messages3
        {
            [Event(MessageId=100, Message = "Test message for message ID {0}")]
            public int msg1 = 0;
            [Event(MessageId=101, Message = "Test message for message ID {0}")]
            public int msg2 = 0;
            [Event(MessageId=102, Message = "Test message for message ID {0}")]
            public int msg3 = 0;
            [Event(MessageId=103, Message = "Test message for message ID {0}")]
            public int msg4 = 0;
            [Event(MessageId=104, Message = "Test message for message ID {0}")]
            public int msg5 = 0;
        }

        [EventCategory(MessageIdBase = 3000)]
        public class Messages4
        {
            [Event(MessageId = 100, Message = "Test message ID {0}, {1}")]
            public int msg1 = 0;
            [Event(MessageId = 101, Message = "Test message ID {0}, {1}")]
            public int msg2 = 0;
            [Event(MessageId = 102, Message = "Test message ID {0}, {1}")]
            public int msg3 = 0;
            [Event(MessageId = 103, Message = "Test message ID {0}, {1}")]
            public int msg4 = 0;
            [Event(MessageId = 104, Message = "Test message ID {0}, {1}")]
            public int msg5 = 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\Tools\WGXPerfCounterInstaller\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WGXPerfCounterInstaller")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a64a6547-d75e-4b1d-a5b9-d764523770d7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\EventProvider\traceprovider.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    public class EventTraceProvider : TraceListener, IDisposable
    {
        static UInt64 hTraceLog;
        static UInt64 hTraceReg;
        static Guid   g_traceGuid;
        static object _syncLock = new object();
        static class NativeMethods
        {
            internal const int TRACE_VERSION_CURRENT = 1;
            internal const int ERROR_SUCCESS = 0;
            internal const int ERROR_INVALID_PARAMETER = 87;
            internal const int WNODE_FLAG_TRACED_GUID = 0x00020000;
            internal const int WNODE_FLAG_USED_MOF_PTR = 0x00100000;
            internal const int EVENT_TRACE_PRIVATE_LOGGER_MODE = 0x00000800;  // Process Private Logger
            internal const int TRACE_MESSAGE_SEQUENCE = 1;  // Message should include a sequence number
            internal const int TRACE_MESSAGE_GUID = 2;  // Message includes a GUID
            internal const int TRACE_MESSAGE_COMPONENTID = 4;  // Message has no GUID, Component ID instead
            internal const int TRACE_MESSAGE_TIMESTAMP = 8;  // Message includes a timestamp
            internal const int TRACE_MESSAGE_PERFORMANCE_TIMESTAMP =  16; // *Obsolete* Clock type is controlled by the logger
            internal const int TRACE_MESSAGE_SYSTEMINFO = 32; // Message includes system information TID,PID
            internal enum TraceFlags
            {
                TRACE_FLAG_START = 1,
                TRACE_FLAG_END = 2,
                TRACE_FLAG_MIDDLE = 3,
                TRACE_FLAG_ID_AS_ASCII = 4
            }

            // Copied from Win32 APIs
            [StructLayout(LayoutKind.Sequential)]
            internal struct EVENT_TRACE_HEADER_CLASS
            {
                internal byte Type;
                internal byte Level;
                internal ushort Version;
            }


            [StructLayout(LayoutKind.Sequential)]
            internal struct _WNODE_HEADER
            {
                internal uint BufferSize;
                internal uint ProviderID;
                [MarshalAs(UnmanagedType.U8)]
                internal UInt64 hSession;
                internal Int64 TimeStamp;
                internal Guid ProviderGuid;
                internal uint Resolution;
                internal uint Flags;
          
            }
                    
            // Copied from Win32 APIs
            [StructLayout(LayoutKind.Sequential)]
            internal struct EVENT_TRACE_PROPERTIES
            {
                internal _WNODE_HEADER wNode;
                internal uint BufferSize;
                internal uint MinimumBuffers;
                internal uint MaximumBuffers;
                internal uint MaximumFileSize;
                internal uint LogFileMode;
                internal uint FlushTimer;
                internal uint EnableFlags;
                internal int AgeLimit;
                internal uint NumberOfBuffers;
                internal uint FreeBuffers;
                internal uint EventsLost;
                internal uint BuffersWritten;
                internal uint LogBuffersLost;
                internal uint RealTimeBuffersLost;
                internal ulong LoggerThreadId;
                internal uint LogFileNameOffset;
                internal uint LoggerNameOffset;
                
                //internal EVENT_LOG_NAME eventLogName;
            }
            [StructLayout(LayoutKind.Sequential)]
            internal struct EVENT_LOG_NAME
            {
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 1000)]
                internal string wzLogFileName;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 1000)]
                internal string wzSessionName;
            }
            // Copied from Win32 APIs
            [StructLayout(LayoutKind.Sequential)]
            internal struct EVENT_TRACE_HEADER
            {
                internal ushort Size;
                internal ushort FieldTypeFlags;
                internal EVENT_TRACE_HEADER_CLASS Class;
                internal uint ThreadId;
                internal uint ProcessId;
                internal Int64 TimeStamp;
                internal Guid Guid;
                internal uint ClientContext;
                internal uint Flags;
                [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1, SafeArrayUserDefinedSubType = typeof(_MOF_FIELD))]
                internal _MOF_FIELD[] MOF_FIELD;
            }

            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            internal struct _MOF_FIELD
            {
                internal UInt64  DataPtr;
                internal uint   Length;
                internal uint   DataType;
            }


            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
            internal struct ULSTraceHeader
            {
                internal ushort Size;
                internal uint dwVersion;
                internal uint Id;
                internal Guid correlationID;
                internal TraceFlags dwFlags;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                internal string wzExeName;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                internal string wzProduct;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 32)]
                internal string wzCategory;
                [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 800)]
                internal string wzMessage;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal struct ULSTrace
            {
                internal EVENT_TRACE_HEADER Header;
                [MarshalAs(UnmanagedType.ByValArray, SizeConst=1, SafeArrayUserDefinedSubType=typeof(_MOF_FIELD))]
                internal _MOF_FIELD[] MOF_FIELD;
                //internal ULSTraceHeader ULSHeader;
            }

            [StructLayout(LayoutKind.Sequential)]
            internal  struct UserData
            {
                internal IntPtr wsMessage;
                internal int length;
            }
            // Copied from Win32 APIs
            internal enum WMIDPREQUESTCODE
            {
                WMI_GET_ALL_DATA = 0,
                WMI_GET_SINGLE_INSTANCE = 1,
                WMI_SET_SINGLE_INSTANCE = 2,
                WMI_SET_SINGLE_ITEM = 3,
                WMI_ENABLE_EVENTS = 4,
                WMI_DISABLE_EVENTS = 5,
                WMI_ENABLE_COLLECTION = 6,
                WMI_DISABLE_COLLECTION = 7,
                WMI_REGINFO = 8,
                WMI_EXECUTE_METHOD = 9
            }

            // Copied from Win32 APIs
            internal unsafe delegate uint EtwProc(NativeMethods.WMIDPREQUESTCODE requestCode, IntPtr requestContext, uint* bufferSize, IntPtr buffer);

            // Copied from Win32 APIs
            [DllImport("advapi32.dll", CharSet = CharSet.Unicode)]
            internal static extern unsafe uint RegisterTraceGuids([In] EtwProc cbFunc, [In] void* context, [In] ref Guid controlGuid, [In] uint guidCount, IntPtr guidReg, [In] string mofImagePath, [In] string mofResourceName, out ulong regHandle);

            // Copied from Win32 APIs
            [DllImport("advapi32.dll", CharSet = CharSet.Unicode)]
            internal static extern uint UnregisterTraceGuids([In]ulong regHandle);

            // Copied from Win32 APIs
            [DllImport("advapi32.dll", CharSet = CharSet.Unicode)]
            internal static extern UInt64 GetTraceLoggerHandle([In]IntPtr Buffer);

            // Copied from Win32 APIs
            [DllImport("advapi32.dll", SetLastError = true)]
            internal static extern uint TraceEvent([In]UInt64 traceHandle, [In]ref EVENT_TRACE_HEADER evnt);

            // Copied from Win32 APIs
            [DllImport("advapi32.dll", SetLastError = true)]
            internal static extern uint TraceMessageVa([In]UInt64 traceHandle, [In]ulong MsgFlags, [In] ref Guid Guid, [In] short MsgID, [In] ref UserData[] UserData);

            // Copied from Win32 API's
            [DllImport("advapi32.dll", SetLastError = true)]
            internal static extern unsafe uint StartTrace(out ulong hTraceHandle, [In] string InstanceName, [In, Out] EVENT_TRACE_PROPERTIES Properties);

            // Copied from Win32 API's
            [DllImport("advapi32.dll", SetLastError = true)]
            internal static extern unsafe uint ControlTrace([In]ulong hTraceHandle, [In] string SessionName, [In, Out] EVENT_TRACE_PROPERTIES Properties, [In] ulong ControlCode);
            
            
        }

        public Guid ProviderID
        {
            set
            {
                g_traceGuid = value;
                RegisterTraceProvider(g_traceGuid);

            }
            get { return g_traceGuid; }
        }



        public EventTraceProvider(string providerID)
        {
            ProviderID = new Guid(providerID);
        }

        public EventTraceProvider(string providerID, string name) : base(name)
        {
            ProviderID= new Guid(providerID);
        }

        public EventTraceProvider(Guid providerID)
        {
            ProviderID = providerID;

        }

        public override void TraceEvent(TraceEventCache eventCache, string source, TraceEventType eventType, int id, string message)
        {
            if (base.Filter == null || base.Filter.ShouldTrace(eventCache, Name, eventType, id, null, null, this, null))
            {
                const ushort sizeOfWCHAR = 2;
                NativeMethods.ULSTrace ulsTrace = new NativeMethods.ULSTrace();

                // Pretty standard code needed to make things work
                ulsTrace.Header.Size = (ushort)(Marshal.SizeOf(typeof(NativeMethods.EVENT_TRACE_HEADER)) + (uint)Marshal.SizeOf(typeof(NativeMethods._MOF_FIELD)));
                ulsTrace.Header.Flags = NativeMethods.WNODE_FLAG_TRACED_GUID | NativeMethods.WNODE_FLAG_USED_MOF_PTR;

                // Variables communicated to SPTrace
                ulsTrace.Header.Class.Level = (byte)eventType;
                ulsTrace.Header.MOF_FIELD = new NativeMethods._MOF_FIELD[2];
                ulsTrace.Header.MOF_FIELD[0].DataPtr = (ulong)System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(message);
                ulsTrace.Header.MOF_FIELD[0].Length = (uint)(message.Length + 1) * sizeOfWCHAR;

                if (hTraceLog != 0)
                {
                    uint result = NativeMethods.TraceEvent(hTraceLog, ref ulsTrace.Header);
                }
            }
        }

        public static unsafe void RegisterTraceProvider(Guid traceGuid)
        {
            g_traceGuid = traceGuid;
            uint result = NativeMethods.RegisterTraceGuids(ControlCallback, null, ref traceGuid, 0, IntPtr.Zero, null, null, out hTraceReg);
        }

        public static void UnregisterTraceProvider()
        {
            uint result = NativeMethods.UnregisterTraceGuids(hTraceReg);
        }

        public static uint TagFromString(string wzTag)
        {
            System.Diagnostics.Debug.Assert(wzTag.Length == 4);
            return (uint) (wzTag[0] << 24 | wzTag[1] << 16 | wzTag[2] << 8 | wzTag[3]);
        }

        static unsafe uint ControlCallback(NativeMethods.WMIDPREQUESTCODE RequestCode, IntPtr Context, uint* InOutBufferSize, IntPtr Buffer)
        {
            uint Status;
            switch (RequestCode)
            {
                case NativeMethods.WMIDPREQUESTCODE.WMI_ENABLE_EVENTS:
                    hTraceLog = NativeMethods.GetTraceLoggerHandle(Buffer);
                    Status = NativeMethods.ERROR_SUCCESS;
                    break;
                case NativeMethods.WMIDPREQUESTCODE.WMI_DISABLE_EVENTS:
                    hTraceLog = 0;
                    Status = NativeMethods.ERROR_SUCCESS;
                    break;
                default:
                    Status = NativeMethods.ERROR_INVALID_PARAMETER;
                    break;
            }

            *InOutBufferSize = 0;
            return Status;
        }

     
        public override void Write(string message)
        {
            WriteEventLog(string.Format("Machine Name: {0}, error msg: {1}", System.Environment.MachineName, "Write not supported"), EventLogEntryType.Warning, 386968656);
        }

        //
        // Summary:
        //     When overridden in a derived class, writes a message to the listener you
        //     create in the derived class, followed by a line terminator.
        //
        // Parameters:
        //   message:
        //     A message to write.
        public override void WriteLine(string message)
        {            
            WriteEventLog(string.Format("Machine Name: {0}, error msg: {1}", System.Environment.MachineName, "Write not supported"), EventLogEntryType.Warning, 386968656);
        }
        private void WriteEventLog(string errorMsg, EventLogEntryType entryType, int msgID)
        {
            System.Diagnostics.EventLog eventLog = new EventLog("Application", System.Environment.MachineName, this.GetType().FullName);
            eventLog.WriteEntry(string.Format("Source Name: {0}, Machine Name: {1}, Error writing message id {2}, error msg: {3}", this.Name, System.Environment.MachineName, msgID, errorMsg), entryType);
        }
        #region IDisposable Members

        void IDisposable.Dispose()
        {
            if (hTraceLog != 0)
            {
                UnregisterTraceProvider();
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\UnitTests\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "namespace", Target = "Wgx.Services")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1709:IdentifiersShouldBeCasedCorrectly", MessageId = "WGX", Scope = "namespace", Target = "WGXMonitoring")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Perf", Scope = "type", Target = "Wgx.Services.PerfCounterTests2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Wgx.Services.PerfCounterTests2.#AverageCounter")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Wgx.Services.PerfCounterTests2.#BaseCounter")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Wgx.Services.PerfCounterTests2.#Counter1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "Wgx.Services.PerfCounterTests2.#Counter2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "tc", Scope = "member", Target = "Wgx.Services.PerfCounterTests2.#MyClassInitialize(Microsoft.VisualStudio.TestTools.UnitTesting.TestContext)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Scope = "member", Target = "Wgx.Services.Singleton.#myTraceSource()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2122:DoNotIndirectlyExposeMethodsWithLinkDemands", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest.#MyClassInitialize(Microsoft.VisualStudio.TestTools.UnitTesting.TestContext)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Scope = "type", Target = "WGXMonitoring.EventsCollectionTest+Messages1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages1.#msg1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages1.#msg2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages1.#msg3")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages1.#msg4")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages1.#msg5")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Scope = "type", Target = "WGXMonitoring.EventsCollectionTest+Messages2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages2.#.ctor()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages2.#msg1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages2.#msg2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages2.#msg3")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages2.#msg4")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages2.#msg5")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Scope = "type", Target = "WGXMonitoring.EventsCollectionTest+Messages3")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages4.#msg5")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages4.#msg4")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages4.#msg3")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages4.#msg2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages4.#msg1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages3.#.ctor()")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages3.#msg1")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages3.#msg2")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages3.#msg3")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages3.#msg4")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1051:DoNotDeclareVisibleInstanceFields", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages3.#msg5")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1034:NestedTypesShouldNotBeVisible", Scope = "type", Target = "WGXMonitoring.EventsCollectionTest+Messages4")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1805:DoNotInitializeUnnecessarily", Scope = "member", Target = "WGXMonitoring.EventsCollectionTest+Messages4.#.ctor()")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\UnitTests\perfcountertests.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Diagnostics;
using Wgx.Services.Monitoring;
namespace Wgx.Services
{
    sealed class Singleton
    {
        private Singleton() { }
        public static readonly WgxTraceSource _Instance = new WgxTraceSource(typeof(PerfCounterTests2).Name);
        public static WgxTraceSource myTraceSource() { return _Instance; }
    }
    /// <summary>
    /// </summary>
    /// 
    [PerformanceCategory(CategoryType=PerformanceCounterCategoryType.SingleInstance, CategoryName="SingleInstanceCounterCategory")]
    public class SingleInstanceCounters
    {
        [PerformanceCounter]
        public static int singleInstanceCounter;
    }
    [TestClass]
    [PerformanceCategory]
    public class PerfCounterTests2
    {
        public PerfCounterTests2()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        [ClassInitialize()]
        public static void MyClassInitialize(TestContext tc) 
        { 
        }

        [ClassCleanup]
        public static void MyClassCleanup()
        {
        }
        //
        // Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion

        #region test properties
        [PerformanceCounter]
        public int Counter1;

        [PerformanceCounter(CounterName="NewName")]
        public int Counter2;

        [PerformanceCounter(CounterType = PerformanceCounterType.AverageBase)]
        public long BaseCounter;
        //[PerformanceCounter(PerformanceCounterType.RawFraction, "AverageBase", CounterDescription = "TestAverageCounter")]
        [PerformanceCounter(CounterType=PerformanceCounterType.AverageCount64, BasePropertyName="BaseCounter")]
        public long AverageCounter;

        #endregion
        #region test methods

        /// <summary>
        /// This test passes and explicit value to update performance counters and verifies that the values are updated correctly
        /// </summary>
        [TestMethod]
        public void TestUsingIncrementByCounter()
        {
            PerformanceCounterCollection perfGroup = Wgx.Services.Monitoring.PerformanceCounters.GetPerformanceCounters(this, "MyInstance1");
            long prevVal = perfGroup.Counters[Counter1].NextSample().RawValue;
            perfGroup.Counters[Counter1].IncrementBy(100);
            Assert.AreEqual<long>(prevVal + 100, perfGroup.Counters[Counter1].NextSample().RawValue);
        }

        [TestMethod]
        public void TestUsingIncrementCounter()
        {
            PerformanceCounterCollection perfGroup = PerformanceCounters.GetPerformanceCounters(this, "MyInstance1");
            long prevVal = perfGroup.Counters[Counter1].NextSample().RawValue;
            perfGroup.Counters[Counter1].Increment();
            Assert.AreEqual<long>(prevVal + 1, perfGroup.Counters[Counter1].NextSample().RawValue);
        }

        [TestMethod]
        public void TestUsingCounterNameAttribute()
        {
            PerformanceCounterCollection perfGroup = Wgx.Services.Monitoring.PerformanceCounters.GetPerformanceCounters(this, "MyInstance1");
            long prevVal = perfGroup.Counters[Counter2].NextSample().RawValue;
            perfGroup.Counters[Counter2].IncrementBy(100);
            Assert.AreEqual<long>(prevVal + 100, perfGroup.Counters[Counter2].NextSample().RawValue);
        }

        [TestMethod]
        public void TestSingleInstanceCounter()
        {
            PerformanceCounterCollection perfGroup = Wgx.Services.Monitoring.PerformanceCounters.GetPerformanceCounters(typeof(SingleInstanceCounters));
            long prevVal = perfGroup.Counters[SingleInstanceCounters.singleInstanceCounter].NextSample().RawValue;
            perfGroup.Counters[SingleInstanceCounters.singleInstanceCounter].IncrementBy(100);
            Assert.AreEqual<long>(prevVal + 100, perfGroup.Counters[SingleInstanceCounters.singleInstanceCounter].NextSample().RawValue);


        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\Tools\WGXPerfCounterInstaller\program.cs ===
// Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Ron Estrin</author>
// <email>a-roestr@microsoft.com</email>
// <date>2009-01-05</date>


namespace Wgx.Services.Monitoring
{
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Configuration.Install;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Reflection;

    class Program
    {
        static int Main(string[] args)
        {
            Console.WriteLine("This is not a stand-alone utility, you must use InstalUtil.exe to install performace counters");
            Console.WriteLine("Sample usage: InstallUtil.exe /AssemblyName=\"myAssembly.dll\" WGXPerfCounterInstaller.exe");
            return 0;
        }
    }
    

    [RunInstaller(true)]
    public class PerformanceCountersInstaller : System.Configuration.Install.Installer
    {
        //
        // Summary:
        //     Initializes a new instance of the System.Configuration.Install.AssemblyInstaller
        //     class, and specifies both the assembly to install and the command line to
        //     use when creating a new System.Configuration.Install.InstallContext object.
        //
        // Parameters:
        //   assembly:
        //     The System.Reflection.Assembly to install.
        //
        //   commandLine:
        //     The command line to use when creating a new System.Configuration.Install.InstallContext
        //     object for the assembly's installation.
        public PerformanceCountersInstaller()
        {
        }

        //
        // Summary:
        //     Raises the System.Configuration.Install.Installer.BeforeUninstall event.
        //
        // Parameters:
        //   savedState:
        //     An System.Collections.IDictionary that contains the state of the computer
        //     before the installers in the System.Configuration.Install.Installer.Installers
        //     property uninstall their installations.
        protected override void OnBeforeUninstall(System.Collections.IDictionary savedState)
        {
            base.OnBeforeUninstall(savedState);
        }
        //
        // Summary:
        //     Removes an installation.
        //
        // Parameters:
        //   savedState:
        //     An System.Collections.IDictionary that contains the post-installation state
        //     of the computer.
        //
        // Exceptions:
        //   System.ArgumentException:
        //     The saved-state System.Collections.IDictionary might have been corrupted.-or-
        //     A file could not be found.
        //
        //   System.Exception:
        //     An error occurred in the System.Configuration.Install.Installer.BeforeUninstall
        //     event handler of one of the installers in the collection.-or- An error occurred
        //     in the System.Configuration.Install.Installer.AfterUninstall event handler
        //     of one of the installers in the collection.-or- An exception occurred while
        //     uninstalling. The exception is ignored and the uninstall continues. However,
        //     the application might not be fully uninstalled after the uninstall completes.-or-
        //     Installer types were not found in one of the assemblies.-or- An instance
        //     of one of the installer types could not be created.-or- A file could not
        //     be deleted.
        //
        //   System.Configuration.Install.InstallException:
        //     An exception occurred while uninstalling. The exception is ignored and the
        //     uninstall continues. However, the application might not be fully uninstalled
        //     after the uninstall completes.
        public override void Uninstall(System.Collections.IDictionary savedState)
        {
            string assemblyName = string.Empty;
            try
            {
                if (base.Context.Parameters.ContainsKey("AssemblyName"))
                {
                    assemblyName = base.Context.Parameters["AssemblyName"];
                    Assembly asm = Assembly.LoadFrom(assemblyName);
                    GetPerformanceCounterInstallers(asm);
                    base.Uninstall(savedState);

                }
                else
                {
                    Console.WriteLine("You must specify the name of the assembly to un-install");
                }
            }
            catch (FileNotFoundException)
            {
                Console.WriteLine("File not found - AssemblyName = {0}", assemblyName);
            }
            catch (InstallException ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        /// <summary>
        /// Uninstalls perf counters, to be used by unit tests etc.
        /// </summary>
        /// <param name="asm"> The assembly in which perf counters are present.</param>
        /// <param name="savedState">System.Collections.IDictionary used to save information needed to perform commit/rollback/uninstall.</param>
        public void Uninstall(Assembly asm, System.Collections.IDictionary savedState)
        {
            GetPerformanceCounterInstallers(asm);
            this.Context = new InstallContext();
            base.Uninstall(savedState);
        }

        //
        // Summary:
        //     Performs the installation.
        //
        // Parameters:
        //   savedState:
        //     An System.Collections.IDictionary used to save information needed to perform
        //     a commit, rollback, or uninstall operation.
        //
        // Exceptions:
        //   System.ArgumentException:
        //     The savedState parameter is null.-or- A file could not be found.
        //
        //   System.Exception:
        //     An exception occurred in the System.Configuration.Install.Installer.BeforeInstall
        //     event handler of one of the installers in the collection.-or- An exception
        //     occurred in the System.Configuration.Install.Installer.AfterInstall event
        //     handler of one of the installers in the collection.-or- Installer types were
        //     not found in one of the assemblies.-or- An instance of one of the installer
        //     types could not be created.
        public override void Install(System.Collections.IDictionary savedState)
        {
            if (base.Context.Parameters.ContainsKey("AssemblyName"))
            {
                string assemblyName = Context.Parameters["AssemblyName"];
                Assembly asm = Assembly.LoadFrom(assemblyName);
                this.GetPerformanceCounterInstallers(asm);
                base.Install(savedState);

            }
            else
            {
                throw new System.ArgumentException("You must specify the name of the assembly to install using the /AssemblyName command line argument");
            }
        }

        /// <summary>
        /// Installs perf counters, to be used by unit tests etc.
        /// </summary>
        /// <param name="asm"> The assembly in which perf counters are present.</param>
        /// <param name="savedState">System.Collections.IDictionary used to save information needed to perform commit/rollback/uninstall.</param>
        public void Install(Assembly asm, System.Collections.IDictionary savedState)
        {
            this.GetPerformanceCounterInstallers(asm);

            // Populate the InstallContext, required by base Install() methods.
            this.Context = new InstallContext();
            base.Install(savedState);
        }

        /// <summary>
        /// retrieves performance counter installers and populates the installers collection
        /// </summary>
        private void GetPerformanceCounterInstallers(Assembly asm)
        {
            Dictionary <string, MemberInfoToPerformanceCounterAttributeDictionary> propertyAttributeMap = PerformanceCounters.GetAttributes(asm);
            Type[] classTypes = asm.GetTypes();
            System.Collections.SortedList sortedList = new System.Collections.SortedList();
            foreach (Type classType in classTypes)
            {
                if (classType.IsClass)
                {
                    string categoryName = PerformanceCounters.GetPerformanceCategoryName(classType);
                    string categoryDescription = PerformanceCounters.GetPerformanceCategoryDescription(classType);
                    PerformanceCounterCategoryType categoryType = PerformanceCounters.GetPerformanceCategoryType(classType);
                    if (propertyAttributeMap.ContainsKey(categoryName))
                    {
                        CounterCreationDataCollection counterDataCollection = this.SortPerformanceCounters(categoryName, propertyAttributeMap);
                        if (counterDataCollection.Count > 0)
                        {
                            PerformanceCounterInstaller perfCounterInstaller = new PerformanceCounterInstaller();
                            perfCounterInstaller.CategoryName = categoryName;
                            perfCounterInstaller.CategoryHelp = categoryDescription;
                            perfCounterInstaller.CategoryType = categoryType;

                            foreach (CounterCreationData counterdata in counterDataCollection)
                            {
                                try
                                {
                                    perfCounterInstaller.Counters.Add(counterdata);
                                }
                                catch (ArgumentException ex)
                                {
                                    throw new InvalidPerformanceCounterException(string.Format("Unable to create performance category {0} - {1}", categoryName, ex.Message), ex);
                                }
                            }
                            this.Installers.Add(perfCounterInstaller);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// true is performance counter type is a base type else false
        /// </summary>
        /// <param name="PerfType">performance counter type</param>
        /// <returns></returns>
        protected static bool IsBasePerformanceCounter(PerformanceCounterType performanceType)
        {
            if (performanceType == PerformanceCounterType.AverageBase ||
                performanceType == PerformanceCounterType.CounterMultiBase ||
                performanceType == PerformanceCounterType.RawBase ||
                performanceType == PerformanceCounterType.SampleBase ||
                performanceType == PerformanceCounterType.CounterMultiBase)
            {
                return true;
            }
            else
            {
                return false;
            }

        }

        /// <summary>
        /// base performance counters must occur after non-base due to dependancy relationship (by convention)
        /// </summary>
        /// <param name="categoryName"></param>
        /// <returns></returns>
        protected CounterCreationDataCollection SortPerformanceCounters(string categoryName, Dictionary<string, MemberInfoToPerformanceCounterAttributeDictionary> propertyAttributeMap)
        {
            CounterCreationDataCollection outCollection = new CounterCreationDataCollection();

            foreach (PerformanceCounterAttribute perfCounterAttrib in propertyAttributeMap[categoryName].Values)
            {
                // add counter as long as its not a base counter, base counters get added when they are referenced through and AssociatedBaseCounter property
                if (!IsBasePerformanceCounter(perfCounterAttrib.CounterType))
                    outCollection.Add(new CounterCreationData(perfCounterAttrib.CounterName, perfCounterAttrib.CounterDescription, perfCounterAttrib.CounterType));
                // the following LINQ query will return all base counters associated with the current counter
                IEnumerable<PerformanceCounterAttribute> baseCounters = from attrib in propertyAttributeMap[categoryName].Values where !string.IsNullOrEmpty(perfCounterAttrib.BasePropertyName) && attrib.CounterName == perfCounterAttrib.BasePropertyName select attrib;
                foreach (PerformanceCounterAttribute attrib in baseCounters)
                {
                    // add base counter
                    if (IsBasePerformanceCounter(attrib.CounterType))
                    {
                        outCollection.Add(new CounterCreationData(attrib.CounterName, attrib.CounterDescription, attrib.CounterType));
                    }
                    else
                    {
                        // wrong counter type for base counter
                        throw new InvalidPerformanceCounterException(string.Format("ERROR: The associated base counter \"{0}\" in performance category \"{1}\" is not an appropriate base counter type", attrib.CounterName, categoryName));
                    }
                }
                if (!string.IsNullOrEmpty(perfCounterAttrib.BasePropertyName) && baseCounters.Count<PerformanceCounterAttribute>() == 0)
                {
                    // indicates that the referenced base counter does not exist
                    throw new InvalidPerformanceCounterException(string.Format("ERROR: The base performance counter baseName=\"{0}\" which is referenced by counter \"{1}\" cannot be located in category \"{2}\".", perfCounterAttrib.BasePropertyName, perfCounterAttrib.CounterName, categoryName));

                }
            }

            return outCollection;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\UnitTests\WgxMonitoringServiceTests.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace Wgx.Monitoring
{
    /// <summary>
    /// Summary description for WgxMonitoringServiceTests
    /// </summary>
    [TestClass]
    public class WgxMonitoringServiceTests
    {
        public WgxMonitoringServiceTests()
        {
            //
            // TODO: Add constructor logic here
            //
        }

        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
        // Use ClassInitialize to run code before running the first test in the class
        // [ClassInitialize()]
        // public static void MyClassInitialize(TestContext testContext) { }
        //
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
         [TestInitialize()]
         public void MyTestInitialize() 
         {
         }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion


        [TestMethod]
        public void InsertListenerConfigurationTable()
        {
            using (WebService.WgxMonitoringServiceClient client = new WebService.WgxMonitoringServiceClient())
            {
                Wgx.Services.Monitoring.DiagnosticDBDataSet.ListenerFilterDataTable table = client.GetListenerConfigurationTable();
                int count = table.Count;
                client.InsertListenerConfigurationTable("TestListener" + DateTime.Now.ToString(), -1, -1);
                table = client.GetListenerConfigurationTable();
                Assert.AreEqual(count + 1, table.Count);
            }
        }

        [TestMethod]
        public void UpdateListenerConfigurationTable()
        {
            using (WebService.WgxMonitoringServiceClient client = new WebService.WgxMonitoringServiceClient())
            {
                Wgx.Services.Monitoring.DiagnosticDBDataSet.ListenerFilterDataTable table = client.GetListenerConfigurationTable();
                if (table.Count > 0)
                {
                    string newListenerName = "TestListener" + DateTime.Now.ToString("ss.ffff");
                    table[0].ListenerName = newListenerName;
                    client.UpdateListenerConfigurationTable(newListenerName, table[0].TraceThresholdMask, table[0].TraceOutputOptions, table[0].PK_FilterID);
                    table = client.GetListenerConfigurationTable();
                    Assert.AreEqual(table[0].ListenerName, newListenerName);
                }
            }
        }

        [TestMethod]
        public void UpdateTraceConfigurationTable()
        {
            using (WebService.WgxMonitoringServiceClient client = new WebService.WgxMonitoringServiceClient())
            {
                Wgx.Services.Monitoring.DiagnosticDBDataSet.TraceConfigurationSettingsDataTable table = client.GetTraceConfigurationSettings();
                if (table.Count > 0)
                {
                    string newSwitchName = "UpdatedTestSwitch" + DateTime.Now.ToString("ss.ffff");
                    table[0].SwitchName = newSwitchName;
                    client.UpdateTraceConfigurationSettings(table[0].SwitchValue, table[0].UpdateInterval, newSwitchName, table[0].TraceOutputOptions, table[0].PK_TraceConfigSettings);
                    table = client.GetTraceConfigurationSettings();
                    Assert.AreEqual(table[0].SwitchName, newSwitchName);
                }
            }
        }

        [TestMethod]
        public void InsertTraceConfigurationTable()
        {
            using (WebService.WgxMonitoringServiceClient client = new WebService.WgxMonitoringServiceClient())
            {
                Wgx.Services.Monitoring.DiagnosticDBDataSet.TraceConfigurationSettingsDataTable table = client.GetTraceConfigurationSettings();
                int count = table.Count;
                client.InsertTraceConfigurationSettings(-1, 1000, "TestSwitch" + DateTime.Now.ToString("ss.ffff"), -1);
                table = client.GetTraceConfigurationSettings();
                Assert.AreEqual(count + 1, table.Count);
            }
        }

        [TestMethod]
        public void GetEventsXmlByDate()
        {
            using (WebService.WgxMonitoringServiceClient client = new WebService.WgxMonitoringServiceClient())
            {
                Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable table = client.GetEventsXmlTableByDate((DateTime.Now - new TimeSpan(4, 0, 0, 0)).ToString(), (DateTime.Now + new TimeSpan(4, 0, 0, 0)).ToString());
            }
        }

        [TestMethod]
        public void GetEventsXmlByDateAndMachineName()
        {
            using (WebService.WgxMonitoringServiceClient client = new WebService.WgxMonitoringServiceClient())
            {
                Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable table = client.GetEventsXmlTableByDateAndMachineName((DateTime.Now - new TimeSpan(4, 0, 0, 0)).ToString(), (DateTime.Now + new TimeSpan(4, 0, 0, 0)).ToString(), System.Environment.MachineName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Configuration.ascx.cs ===
namespace WgxMonitoringConsoleWebApp
{
    using System;
    using System.Web.UI.WebControls;

    /// <summary>
    /// Trace output configuration options user control to update TraceOutputOptions table in EventAggregator DB
    /// </summary>
    public partial class Configuration : System.Web.UI.UserControl
    {
        protected void ConfigureTraceOutputOptionsBtn_Click(object sender, EventArgs e)
        {
            this.TraceOutputOptionsDiv.Visible = !this.TraceOutputOptionsDiv.Visible;
        }

        protected void OnPreRenderTraceConfigSettingsLabel(object sender, EventArgs e)
        {
            Label item = (Label)sender;
            switch (item.Text)
            {
                case "-1":
                    item.Text = "All";
                    break;
                case "0":
                    item.Text = "Off";
                    break;
                case "1":
                    item.Text = "Critical";
                    break;
                case "3":
                    item.Text = "Error";
                    break;
                case "7":
                    item.Text = "Warning";
                    break;
                case "15":
                    item.Text = "Information";
                    break;
                case "31":
                    item.Text = "Verbose";
                    break;
            }
        }

        protected void OnDataBindingTraceOutputOptionsSelectedValue(object sender, EventArgs e)
        {
            CheckBoxList listCtrl = (CheckBoxList)((TextBox)sender).Parent.FindControl("TraceOutputOptions");
            int traceOutputOptions = -1;
            int.TryParse(((TextBox)sender).Text, out traceOutputOptions);
            foreach (ListItem item in listCtrl.Items)
            {
                if ((traceOutputOptions & int.Parse(item.Value)) != 0)
                {
                    item.Selected = true;
                }
                else
                {
                    item.Selected = false;
                }
            }
        }

        protected void OnTextChangedTraceOutputOptions(object sender, EventArgs e)
        {
            CheckBoxList listCtrl = (CheckBoxList)sender;
            TextBox textBox = (TextBox)listCtrl.Parent.FindControl("TraceOutputOptionsSelectedValue");
            int currentValue = 0;
            foreach (ListItem item in listCtrl.Items)
            {
                if (item.Selected)
                {
                    currentValue |= int.Parse(item.Value);
                }
            }

            textBox.Text = currentValue.ToString();
        }

        protected void AddTraceSwitchBtn_Click1(object sender, EventArgs e)
        {
            this.TraceConfigurationDataSource.Insert();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\UnitTests\WGXTraceSourceTests.cs ===
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Diagnostics;
using WGXMonitoring;
namespace WGXMonitoring
{
    /// <summary>
    /// Runs a series of tests using WGXTraceSource tracing and monitoring functions
    /// </summary>
    [TestClass]
    public class WGXTraceSourceUnitTests
    {
        static PerformanceCounter m_perfCounter1;
        sealed class Singleton
        {
            private Singleton() { }
            public static readonly WGXMonitoring.TraceSourceEx _Instance = new TraceSourceEx(typeof(WGXTraceSourceUnitTests).Name);
            public static TraceSourceEx myTraceSource() { return _Instance; }
        }
        public WGXTraceSourceUnitTests()
        {
        }

        private TestContext testContextInstance;
        
        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        //
        // You can use the following additional attributes as you write your tests:
        //
         [ClassInitialize()]
         public static void MyClassInitialize(TestContext testContext) 
         {
             TraceSourceEx.TraceSource = Singleton._Instance;
             m_perfCounter1 = new PerformanceCounter();
             TraceSourceEx.CreatePerformanceCounters(System.Reflection.Assembly.GetAssembly(typeof(WGXTraceSourceUnitTests)));
         }
        
        // Use ClassCleanup to run code after all tests in a class have run
        // [ClassCleanup()]
        // public static void MyClassCleanup() { }
        //
        // Use TestInitialize to run code before running each test 
        [TestInitialize()]
        public void MyTestInitialize() 
        {
        }
        //
        // Use TestCleanup to run code after each test has run
        // [TestCleanup()]
        // public void MyTestCleanup() { }
        //
        #endregion
        #region test properties
        long m_val = 0;
        [PerformanceCounter]
        public long TestProperty1
        {
            get { return m_val; }
            set { m_val = value; }
        }

        [PerformanceCounter(CounterType=PerformanceCounterType.RawBase, CounterName="AverageBase")]
        public int BaseProperty
        {
            get { return 1; }
        }

        [PerformanceCounter(PerformanceCounterType.RawFraction, "AverageBase", CounterDescription = "TestAverageCounter")]
        public int AverageProperty
        {
            get { return 10; }
        }

        #endregion
        #region test methods
        [TestMethod]
        public void TestInitializationRoutine()
        {
            // accessing the trace source name will cause the WGXTraceSource object to be instantiated as a singleton as this
            // is the first access to the object in the code. This in turn will cause the Initialize method to be invoked
            // innocuous as the assert appears this will trigger alot of code coverage including the extraction of attributes
            // as well as the creation of performance counter categories (if DEBUG)
            Assert.AreEqual<string>(typeof(WGXTraceSourceUnitTests).Name, TraceSourceEx.TraceSource.Name);
        }

       // this test runs the gamut of base class trace methods defined in System.Diagnotics.TraceSource
        [TestMethod]
        public void TestTraceEvent()
        {
            // sanity test to see if we can call the base implementation without generating an exception
            TraceSourceEx.TraceSource.TraceEvent(System.Diagnostics.TraceEventType.Error, 0);
            TraceSourceEx.TraceSource.TraceData(TraceEventType.Error, 0, this);
            TraceSourceEx.TraceSource.TraceInformation("information", new object[] {0, 1, 2, 3});
        }


        /// <summary>
        /// This test passes and explicit value to update performance counters and verifies that the values are updated correctly
        /// </summary>
        [TestMethod]
        public void TestUsingRawValue()
        {
            TraceSourceEx.PerformanceCounterRawValue(this.GetType().FullName, "TestProperty1", 100);
            PerformanceCounter perfCounter1 = new PerformanceCounter(this.GetType().FullName, "TestProperty1", TraceSourceEx.SourceName);
            Assert.AreEqual<long>(100, perfCounter1.RawValue);
        }


        [TestMethod]
        public void TestUsingIncrementBy()
        {
            PerformanceCounter perfCounter1 = new PerformanceCounter(this.GetType().FullName, "TestProperty1", TraceSourceEx.SourceName);
            TestProperty1 = perfCounter1.RawValue;
            TraceSourceEx.PerformanceCounterIncrementBy(this.GetType().FullName, "TestProperty1", TestProperty1);
            Assert.AreEqual<long>(TestProperty1 + TestProperty1, perfCounter1.RawValue);
        }

        [TestMethod]
        public void TestUsingIncrement()
        {
            PerformanceCounter perfCounter1 = new PerformanceCounter(this.GetType().FullName, "TestProperty1", TraceSourceEx.SourceName);
            TestProperty1 = perfCounter1.RawValue;
            TraceSourceEx.PerformanceCounterIncrement(this.GetType().FullName, "TestProperty1");
            Assert.AreEqual<long>(TestProperty1 + 1, perfCounter1.RawValue);
        }

        [TestMethod]
        public void TestUsingDecrement()
        {
            PerformanceCounter perfCounter1 = new PerformanceCounter(this.GetType().FullName, "TestProperty1", TraceSourceEx.SourceName);
            TestProperty1 = perfCounter1.RawValue;
            TraceSourceEx.PerformanceCounterDecrement(this.GetType().FullName, "TestProperty1");
            Assert.AreEqual<long>(TestProperty1 - 1, perfCounter1.RawValue);
        }

        [TestMethod]
        public void TestUsingIncrementWithInstanceName()
        {
            TestProperty1 = 0;
            TraceSourceEx.PerformanceCounterIncrement(this.GetType().FullName, "TestProperty1", "MyInstance");
            PerformanceCounter perfCounter1 = new PerformanceCounter(this.GetType().FullName, "TestProperty1", "MyInstance");
            Assert.AreEqual<long>(TestProperty1 + 1, perfCounter1.RawValue);
        }

        [TestMethod]
        public void PerformanceTest1()
        {
            PerformanceCounter perfCounter1 = new PerformanceCounter(this.GetType().FullName, "TestProperty1", TraceSourceEx.SourceName);
            TestProperty1 = perfCounter1.RawValue;
            for (int i = 0; i < 1000; i++)
            {
                TestProperty1++;
                TraceSourceEx.PerformanceCounterIncrement(this.GetType().FullName, "TestProperty1");
                Assert.AreEqual(TestProperty1, perfCounter1.RawValue);
            }
        }
        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Configuration.ascx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WgxMonitoringConsoleWebApp {
    
    
    public partial class Configuration {
        
        /// <summary>
        /// TraceOutputOptionsDiv control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl TraceOutputOptionsDiv;
        
        /// <summary>
        /// AddTraceSwitchBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton AddTraceSwitchBtn;
        
        /// <summary>
        /// TraceOutputOptionsGridView control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.GridView TraceOutputOptionsGridView;
        
        /// <summary>
        /// TraceConfigurationDataSource control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.ObjectDataSource TraceConfigurationDataSource;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\UnitTests\Service_References\WebService\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Wgx.Monitoring.WebService {
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(ConfigurationName="WebService.IWgxMonitoringService")]
    public interface IWgxMonitoringService {
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetEventsXmlTableByDate", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetEventsXmlTableByDateResponse")]
        Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable GetEventsXmlTableByDate(string fromDate, string toDate);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetEventsXmlTableByDateAndMachineName", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetEventsXmlTableByDateAndMachineNameRes" +
            "ponse")]
        Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable GetEventsXmlTableByDateAndMachineName(string fromDate, string toDate, string MachineName);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetEventsXmlTableByDateAndMachineNameAnd" +
            "SourceName", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetEventsXmlTableByDateAndMachineNameAnd" +
            "SourceNameResponse")]
        Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable GetEventsXmlTableByDateAndMachineNameAndSourceName(string fromDate, string toDate, string MachineName, string Source);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetTraceConfigurationSettingsResponse")]
        Wgx.Services.Monitoring.DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettings();
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/UpdateTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/UpdateTraceConfigurationSettingsResponse" +
            "")]
        void UpdateTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions, int PK_TraceConfigSettings);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetListenerConfigurationTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetListenerConfigurationTableResponse")]
        Wgx.Services.Monitoring.DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTable();
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/UpdateListenerConfigurationTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/UpdateListenerConfigurationTableResponse" +
            "")]
        void UpdateListenerConfigurationTable(string ListenerName, int TraceThresholdMask, int TraceOutputOptions, int PK_FilterID);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/InsertListenerConfigurationTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/InsertListenerConfigurationTableResponse" +
            "")]
        void InsertListenerConfigurationTable(string ListenerName, int TraceThreshold, int TraceOutputOptions);
        
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/InsertTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/InsertTraceConfigurationSettingsResponse" +
            "")]
        void InsertTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions);
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface IWgxMonitoringServiceChannel : Wgx.Monitoring.WebService.IWgxMonitoringService, System.ServiceModel.IClientChannel {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class WgxMonitoringServiceClient : System.ServiceModel.ClientBase<Wgx.Monitoring.WebService.IWgxMonitoringService>, Wgx.Monitoring.WebService.IWgxMonitoringService {
        
        public WgxMonitoringServiceClient() {
        }
        
        public WgxMonitoringServiceClient(string endpointConfigurationName) : 
                base(endpointConfigurationName) {
        }
        
        public WgxMonitoringServiceClient(string endpointConfigurationName, string remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public WgxMonitoringServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public WgxMonitoringServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(binding, remoteAddress) {
        }
        
        public Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable GetEventsXmlTableByDate(string fromDate, string toDate) {
            return base.Channel.GetEventsXmlTableByDate(fromDate, toDate);
        }
        
        public Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable GetEventsXmlTableByDateAndMachineName(string fromDate, string toDate, string MachineName) {
            return base.Channel.GetEventsXmlTableByDateAndMachineName(fromDate, toDate, MachineName);
        }
        
        public Wgx.Services.Monitoring.DiagnosticDBDataSet.EventsXmlDataTable GetEventsXmlTableByDateAndMachineNameAndSourceName(string fromDate, string toDate, string MachineName, string Source) {
            return base.Channel.GetEventsXmlTableByDateAndMachineNameAndSourceName(fromDate, toDate, MachineName, Source);
        }
        
        public Wgx.Services.Monitoring.DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettings() {
            return base.Channel.GetTraceConfigurationSettings();
        }
        
        public void UpdateTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions, int PK_TraceConfigSettings) {
            base.Channel.UpdateTraceConfigurationSettings(SwitchValue, UpdateInterval, SwitchName, TraceOutputOptions, PK_TraceConfigSettings);
        }
        
        public Wgx.Services.Monitoring.DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTable() {
            return base.Channel.GetListenerConfigurationTable();
        }
        
        public void UpdateListenerConfigurationTable(string ListenerName, int TraceThresholdMask, int TraceOutputOptions, int PK_FilterID) {
            base.Channel.UpdateListenerConfigurationTable(ListenerName, TraceThresholdMask, TraceOutputOptions, PK_FilterID);
        }
        
        public void InsertListenerConfigurationTable(string ListenerName, int TraceThreshold, int TraceOutputOptions) {
            base.Channel.InsertListenerConfigurationTable(ListenerName, TraceThreshold, TraceOutputOptions);
        }
        
        public void InsertTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions) {
            base.Channel.InsertTraceConfigurationSettings(SwitchValue, UpdateInterval, SwitchName, TraceOutputOptions);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Default.aspx.cs ===
namespace WgxMonitoringConsoleWebApp
{
    using System;
    using System.Web.UI.WebControls;
    using WgxMonitoringConsoleWebApp.WgxWebConsoleService;

    /// <summary>
    /// Container for EventViewer user control as well as Filter user control and configuration user control
    /// _Default is the orchestrator and is the only class that calls in to the EventPagerClass object for 
    /// managing calls to the WCF monitoring server.
    /// </summary>
    public partial class _Default : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            EventPagingObject pagerObj = new EventPagingObject();
            pagerObj.OnFault = this.OnPageFault; // exception handler callback
            if (!IsPostBack)
            {
                this.Filter1.FromDate = (DateTime.Now - new TimeSpan(7, 0, 0, 0)).ToString();
                this.Filter1.ToDate = DateTime.Now.ToString();
                DiagnosticDBDataSet.GetSummaryEventsDataTable dt = pagerObj.GetEventsSummaryTable(
                    this.Filter1.FromDate, 
                    this.Filter1.ToDate, 
                    null, 
                    0, 
                    null, 
                    0, 
                    null, 
                    null, 
                    0, 
                    null, 
                    false);
                this.SummaryGrid.DataSource = dt;
                this.SummaryGrid.DataBind();
            }

            this.Filter1.OnResetData = this.RefreshBtn_Click1;
            this.EventViewer1.OnPageIndexChanging = this.OnEventViewerPageIndexChanging;
            this.EventViewer1.OnColumnHeaderClick = this.OnColumnHeaderClick;
            this.EventViewer1.OnPageSizeChanging = this.OnPageSizeChanging;
            this.ExceptionMsg.Text = string.Empty;
        }

        /// <summary>
        /// Event handler callback for when an exception is encountered
        /// </summary>
        /// <param name="ex"></param>
        protected void OnPageFault(Exception ex)
        {
            this.ExceptionMsg.Text = ex.Message;
        }

        protected void LastHourBtn_Click(object sender, EventArgs e)
        {
            this.Filter1.ClearFilter();
            this.Filter1.FromDate = (DateTime.Now - new TimeSpan(1, 0, 0)).ToString();
            this.Filter1.ToDate = DateTime.Now.ToString();
            this.RefreshBtn_Click1(sender, e);
        }

        protected void LastDayBtn_Click(object sender, EventArgs e)
        {
            this.Filter1.ClearFilter();
            this.Filter1.FromDate = (DateTime.Now - new TimeSpan(1, 0, 0, 0, 0)).ToString();
            this.Filter1.ToDate = DateTime.Now.ToString();
            this.RefreshBtn_Click1(sender, e);
        }

        protected void LastWeekBtn_Click(object sender, EventArgs e)
        {
            this.Filter1.ClearFilter();
            this.Filter1.FromDate = (DateTime.Now - new TimeSpan(7, 0, 0, 0, 0)).ToString();
            this.Filter1.ToDate = DateTime.Now.ToString();
            this.RefreshBtn_Click1(sender, e);
        }

        protected void LastMonthBtn_Click(object sender, EventArgs e)
        {
            this.Filter1.ClearFilter();
            this.Filter1.FromDate = (DateTime.Now - new TimeSpan(30, 0, 0, 0, 0)).ToString();
            this.Filter1.ToDate = DateTime.Now.ToString();
            this.RefreshBtn_Click1(sender, e);
        }

        /// <summary>
        /// Hides/Shows the User Filter screen
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void FilterBtn_Click(object sender, EventArgs e)
        {
            this.Filter1.Visible = !this.Filter1.Visible;
        }

        /// <summary>
        /// Fired from the Filter user control when the user click the Refresh button
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void RefreshBtn_Click1(object sender, EventArgs e)
        {
            this.EventViewer1.Visible = false;
            EventPagingObject pagerObj = new EventPagingObject();
            EventPagingObject.EventsTable = null;
            EventPagingObject.TotalRowCount = -1;
            DiagnosticDBDataSet.GetSummaryEventsDataTable dt = null;
            dt = pagerObj.GetEventsSummaryTable(
                this.Filter1.FromDate, 
                this.Filter1.ToDate, 
                this.Filter1.Machine_Name, 
                this.Filter1.Machine_Op, 
                this.Filter1.Source_Name, 
                this.Filter1.Source_Op, 
                this.Filter1.Event_Level, 
                this.Filter1.Message_ID, 
                this.Filter1.MessageID_Op, 
                null, 
                false);
            this.SummaryGrid.DataSource = dt;
            this.SummaryGrid.DataBind();
            this.SummaryGrid.PageIndex = 0;
        }

        /// <summary>
        /// Determines whether to sort the grid ascending or descending by toggling state based on sort key
        /// </summary>
        /// <param name="sortKey"></param>
        /// <returns></returns>
        protected bool IsAscending(string sortKey)
        {
            if (Session[sortKey] == null)
            {
                Session[sortKey] = false;
            }
            else
            {
                Session[sortKey] = !((bool)Session[sortKey]);
            }

            return (bool)Session[sortKey];
        }

        /// <summary>
        /// Shows all events for the machine name associated with the currently selected row
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void SummaryGrid_SelectedIndexChanged(object sender, EventArgs e)
        {
            this.EventViewer1.Visible = true;
            EventPagingObject pagerObj = new EventPagingObject();
            EventPagingObject.EventsTable = null;
            if (EventPagingObject.SummaryTable == null)
            {
                pagerObj.GetEventsSummaryTable(this.Filter1.FromDate, this.Filter1.ToDate, null, this.Filter1.Machine_Op, this.Filter1.Source_Name, this.Filter1.Source_Op, this.Filter1.Event_Level, this.Filter1.Message_ID, this.Filter1.MessageID_Op, null, false);
            }

            this.Filter1.Machine_Name = EventPagingObject.SummaryTable[this.SummaryGrid.SelectedIndex].MachineName;
            DiagnosticDBDataSet.EventsDataTable dt = pagerObj.GetFilteredEventsTable(
                this.Filter1.FromDate, 
                this.Filter1.ToDate, 
                this.Filter1.Machine_Name, 
                this.Filter1.Machine_Op, 
                this.Filter1.Source_Name, 
                this.Filter1.Source_Op, 
                this.Filter1.Event_Level, 
                this.Filter1.Message_ID, 
                this.Filter1.MessageID_Op, 
                this.EventViewer1.Page_Size, 
                0, 
                null, 
                false);
            this.EventViewer1.EventsGrid.DataSource = dt;
            this.EventViewer1.CurrentPage = 0;
            this.EventViewer1.EventsGrid.DataBind();
        }

        /// <summary>
        /// Handler for event viewer page change event
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void OnEventViewerPageIndexChanging(object sender, GridViewPageEventArgs e)
        {
            EventPagingObject pagerObj = new EventPagingObject();
            DiagnosticDBDataSet.EventsDataTable dt = pagerObj.GetFilteredEventsTable(
                this.Filter1.FromDate, 
                this.Filter1.ToDate, 
                this.Filter1.Machine_Name, 
                this.Filter1.Machine_Op, 
                this.Filter1.Source_Name, 
                this.Filter1.Source_Op, 
                this.Filter1.Event_Level, 
                this.Filter1.Message_ID, 
                this.Filter1.MessageID_Op, 
                this.EventViewer1.Page_Size, 
                e.NewPageIndex * this.EventViewer1.Page_Size, 
                null, 
                false);
            this.EventViewer1.EventsGrid.DataSource = dt;
            this.EventViewer1.EventsGrid.DataBind();
        }

        /// <summary>
        /// Event handler for sorting EventsMaster columns depending on the column sort key
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void OnColumnHeaderClick(object sender, EventArgs e)
        {
            string sortKey = null;
            switch (((LinkButton)sender).ID)
            {
                case "EventTypeColumn":
                    sortKey = "EventType";
                    break;
                case "DateTimeColumn":
                    sortKey = "DateTime";
                    break;
                case "MessageIDColumn":
                    sortKey = "MessageID";
                    break;
                case "SourceNameColumn":
                    sortKey = "Source";
                    break;
                case "MethodNameColumn":
                    sortKey = "MethodName";
                    break;
            }

            EventPagingObject pagerObj = new EventPagingObject();
            EventPagingObject.EventsTable = null;
            DiagnosticDBDataSet.EventsDataTable dt = pagerObj.GetFilteredEventsTable(
                this.Filter1.FromDate, 
                this.Filter1.ToDate, 
                this.Filter1.Machine_Name, 
                this.Filter1.Machine_Op, 
                this.Filter1.Source_Name, 
                this.Filter1.Source_Op, 
                this.Filter1.Event_Level, 
                this.Filter1.Message_ID, 
                this.Filter1.MessageID_Op, 
                this.EventViewer1.Page_Size, 
                0, 
                sortKey, 
                this.IsAscending(sortKey));
            this.EventViewer1.EventsGrid.DataSource = dt;
            this.EventViewer1.CurrentPage = 0;
            this.EventViewer1.EventsGrid.DataBind();
        }

        /// <summary>
        /// Resizes the page
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="pageSize"></param>
        protected void OnPageSizeChanging(object sender, int pageSize)
        {
            EventPagingObject pagerObj = new EventPagingObject();
            DiagnosticDBDataSet.EventsDataTable dt = pagerObj.GetFilteredEventsTable(
                this.Filter1.FromDate, 
                this.Filter1.ToDate, 
                this.Filter1.Machine_Name, 
                this.Filter1.Machine_Op, 
                this.Filter1.Source_Name, 
                this.Filter1.Source_Op, 
                this.Filter1.Event_Level, 
                this.Filter1.Message_ID, 
                this.Filter1.MessageID_Op, 
                this.EventViewer1.Page_Size, 
                0, 
                null, 
                false);
            this.EventViewer1.EventsGrid.DataSource = dt;
            this.EventViewer1.CurrentPage = 0;
            this.EventViewer1.EventsGrid.DataBind();
        }

        /// <summary>
        /// Hide/Show the configuration control
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ConfigurationBtn_Click(object sender, EventArgs e)
        {
            this.Configuration1.Visible = !this.Configuration1.Visible;
        }

        /// <summary>
        /// Sorts the summary grid using the column heading sort key
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void SummaryGrid_Sorting(object sender, GridViewSortEventArgs e)
        {
            EventPagingObject pagerObj = new EventPagingObject();
            DiagnosticDBDataSet.GetSummaryEventsDataTable dt = pagerObj.GetEventsSummaryTable(
                this.Filter1.FromDate, 
                this.Filter1.ToDate, 
                this.Filter1.Machine_Name, 
                this.Filter1.Machine_Op, 
                this.Filter1.Source_Name, 
                this.Filter1.Source_Op, 
                this.Filter1.Event_Level, 
                this.Filter1.Message_ID, 
                this.Filter1.MessageID_Op, 
                e.SortExpression, 
                this.IsAscending(e.SortExpression));
            this.SummaryGrid.DataSource = dt;
            this.SummaryGrid.DataBind();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Default.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WgxMonitoringConsoleWebApp {
    
    
    public partial class _Default {
        
        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
        
        /// <summary>
        /// H1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlGenericControl H1;
        
        /// <summary>
        /// FilterBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button FilterBtn;
        
        /// <summary>
        /// ConfigurationBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button ConfigurationBtn;
        
        /// <summary>
        /// Configuration1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::WgxMonitoringConsoleWebApp.Configuration Configuration1;
        
        /// <summary>
        /// Filter1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::WgxMonitoringConsoleWebApp.Filter Filter1;
        
        /// <summary>
        /// ExceptionMsg control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Literal ExceptionMsg;
        
        /// <summary>
        /// LastHourBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton LastHourBtn;
        
        /// <summary>
        /// LastDayBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton LastDayBtn;
        
        /// <summary>
        /// LastWeekBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton LastWeekBtn;
        
        /// <summary>
        /// LastMonthBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton LastMonthBtn;
        
        /// <summary>
        /// SummaryGrid control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.GridView SummaryGrid;
        
        /// <summary>
        /// EventViewer1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::WgxMonitoringConsoleWebApp.EventViewer EventViewer1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\EventPagingClass.cs ===
namespace WgxMonitoringConsoleWebApp
{
    using System;
    using System.Web;
    using WgxMonitoringConsoleWebApp.WgxWebConsoleService;

    /// <summary>
    /// Fired when an exception occurs
    /// </summary>
    /// <param name="ex"></param>
    public delegate void FaultState(Exception ex);

    /// <summary>
    /// This business object manages paging and internal data access using the WCF proxy object
    /// </summary>
    public class EventPagingObject
    {
        #region SESSION KEYS
        // these keys are used to retreive cached session state, the use of guid's is to prevent collisions with other keys
        private const string SUMMARY_TABLE = "{00FD8072-88BB-477b-ACD3-ACFEEE86C7BB}";

        private const string EVENTS_TABLE = "{6BC0F186-75BA-408e-B58D-32E3D31B3CFE}";

        private const string REPORTING_TABLE = "{47309E44-B870-4ec1-98E2-DE672A06C4C7}";

        private const string SORT_KEY = "{1EB57809-B456-4b7f-9FDE-39528AF5F986}";

        private const string EVENTS_TABLE_ROW_COUNT = "{26EC9179-B488-4451-A287-BC644709BAB0}";

        private const string PAGESIZE = "{2279E906-B51C-46ce-A7D5-9EDC9C09F6F1}";
        #endregion

        public FaultState OnFault;

        public EventPagingObject()
        {
        }

        /// <summary>
        /// Gets the results of the summary table in session state
        /// </summary>
        public static DiagnosticDBDataSet.GetSummaryEventsDataTable SummaryTable
        {
            get
            {
                return (DiagnosticDBDataSet.GetSummaryEventsDataTable)HttpContext.Current.Session[SUMMARY_TABLE];
            }

            set
            {
                HttpContext.Current.Session[SUMMARY_TABLE] = value;
            }
        }

        /// <summary>
        /// caches the events table in session state
        /// </summary>
        public static DiagnosticDBDataSet.EventsDataTable EventsTable
        {
            get
            {
                return (DiagnosticDBDataSet.EventsDataTable)HttpContext.Current.Session[EVENTS_TABLE];
            }

            set
            {
                HttpContext.Current.Session[EVENTS_TABLE] = value;
            }
        }

        /// <summary>
        /// If row count exceeds 1000, only the first 1000 rows are returned
        /// </summary>
        public static int TotalRowCount
        {
            get
            {
                if (HttpContext.Current.Session[EVENTS_TABLE_ROW_COUNT] != null)
                {
                    int totalRowCount = (int)HttpContext.Current.Session[EVENTS_TABLE_ROW_COUNT];
                    if (totalRowCount > 1000)
                    {
                        totalRowCount = 1000;
                    }

                    return totalRowCount;
                }
                else
                {
                    return -1;
                }
            }

            set
            {
                HttpContext.Current.Session[EVENTS_TABLE_ROW_COUNT] = value;
            }
        }

        /// <summary>
        /// Retrieves the events list based on the filter criteria
        /// </summary>
        /// <param name="fromDate"></param>
        /// <param name="toDate"></param>
        /// <param name="MachineName"></param>
        /// <param name="MachineOp"></param>
        /// <param name="Source"></param>
        /// <param name="SourceOp"></param>
        /// <param name="eventType"></param>
        /// <param name="MessageId"></param>
        /// <param name="MessageIdOp"></param>
        /// <param name="pageSize"></param>
        /// <param name="startRowNum"></param>
        /// <param name="sortKey"></param>
        /// <param name="ascending"></param>
        /// <returns></returns>
        public DiagnosticDBDataSet.EventsDataTable GetFilteredEventsTable(
            string fromDate,
            string toDate,
            string machineName,
            int machineOp,
            string source,
            int sourceOp,
            string eventType,
            int? messageId,
            int messageIdOp,
            int pageSize,
            int startRowNum,
            string sortKey,
            bool ascending)
        {
            if (EventsTable == null)
            {
                WgxMonitoringServiceClient client = new WgxMonitoringServiceClient();
                EventsTable = client.GetFilteredEventsTable(fromDate, toDate, string.IsNullOrEmpty(machineName) ? null : machineName, machineOp, string.IsNullOrEmpty(source) ? null : source, sourceOp, string.IsNullOrEmpty(eventType) ? null : eventType, messageId, messageIdOp, pageSize, startRowNum, sortKey, ascending);
                TotalRowCount = client.GetFilteredEventsRowCount(
                    fromDate, 
                    toDate, 
                    string.IsNullOrEmpty(machineName) ? null : machineName, 
                    machineOp, 
                    string.IsNullOrEmpty(source) ? null : source, 
                    sourceOp, 
                    string.IsNullOrEmpty(eventType) ? null : eventType, 
                    messageId, 
                    messageIdOp, 
                    pageSize, 
                    startRowNum);
                client.Close();
            }

            if (pageSize == -1)
            {
                // implies we want the entire result set
                pageSize = TotalRowCount;
            }

            DiagnosticDBDataSet.EventsDataTable tbl = new DiagnosticDBDataSet.EventsDataTable();
            if (pageSize < TotalRowCount)
            {
                // this is lame but the Select doesn't return a datatable forcing us to create a new datatable                
                for (int i = startRowNum; i < startRowNum + pageSize && i < TotalRowCount; i++)
                {
                    DiagnosticDBDataSet.EventsRow newRow = tbl.NewEventsRow();
                    if (!EventsTable[i].IsEventTypeNull())
                    {
                        newRow.EventType = EventsTable[i].EventType;
                    }

                    if (!EventsTable[i].IsMachineNameNull())
                    {
                        newRow.MachineName = EventsTable[i].MachineName;
                    }

                    if (!EventsTable[i].IsAssemblyNameNull())
                    {
                        newRow.AssemblyName = EventsTable[i].AssemblyName;
                    }

                    if (!EventsTable[i].IsMethodNameNull())
                    {
                        newRow.MethodName = EventsTable[i].MethodName;
                    }

                    if (!EventsTable[i].IsSourceNull())
                    {
                        newRow.Source = EventsTable[i].Source;
                    }

                    if (!EventsTable[i].IsMessageNull())
                    {
                        newRow.Message = EventsTable[i].Message;
                    }

                    if (!EventsTable[i].IsMessageIDNull())
                    {
                        newRow.MessageID = EventsTable[i].MessageID;
                    }

                    if (!EventsTable[i].IsDateTimeNull())
                    {
                        newRow.DateTime = EventsTable[i].DateTime;
                    }

                    if (!EventsTable[i].IsFileNameNull())
                    {
                        newRow.FileName = EventsTable[i].FileName;
                    }

                    if (!EventsTable[i].IsLineNumberNull())
                    {
                        newRow.LineNumber = EventsTable[i].LineNumber;
                    }

                    if (!EventsTable[i].IsThreadIDNull())
                    {
                        newRow.ThreadID = EventsTable[i].ThreadID;
                    }

                    if (!EventsTable[i].IsProcessIDNull())
                    {
                        newRow.ProcessID = EventsTable[i].ProcessID;
                    }

                    if (!EventsTable[i].IsCallStackNull())
                    {
                        newRow.CallStack = EventsTable[i].CallStack;
                    }

                    tbl.Rows.Add(newRow);
                }
            }
            else
            {
                tbl = EventsTable;
            }

            return tbl;
        }

        public void UpdateTraceConfigurationSettings(
            int switchValue,
            int updateInterval,
            string switchName,
            int traceOutputOptions,
            int PK_TraceConfigSettings)
        {
            WgxMonitoringServiceClient client = null;
            client = new WgxMonitoringServiceClient();
            client.UpdateTraceConfigurationSettings(
                switchValue, 
                updateInterval, 
                switchName, 
                traceOutputOptions, 
                PK_TraceConfigSettings);
            client.Close();
        }

        public DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTable()
        {
            WgxMonitoringServiceClient client = null;
            client = new WgxMonitoringServiceClient();
            DiagnosticDBDataSet.ListenerFilterDataTable tbl = client.GetListenerConfigurationTable();
            client.Close();
            return tbl;
        }

        public DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettings()
        {
            WgxMonitoringServiceClient client = new WgxMonitoringServiceClient();
            client = new WgxMonitoringServiceClient();
            DiagnosticDBDataSet.TraceConfigurationSettingsDataTable tbl = client.GetTraceConfigurationSettings();
            client.Close();
            return tbl;
        }

        public void InsertTraceConfigurationSettings(int switchValue, int updateInterval, string switchName, int traceOutputOptions)
        {
            WgxMonitoringServiceClient client = new WgxMonitoringServiceClient();
            client = new WgxMonitoringServiceClient();
            client.InsertTraceConfigurationSettings(switchValue, updateInterval, switchName, traceOutputOptions);
            client.Close();
        }

        /// <summary>
        /// Deletes a particulare TraceSwitch configuration record from the TraceOutput configuration table
        /// </summary>
        /// <param name="SwitchValue"></param>
        /// <param name="UpdateInterval"></param>
        /// <param name="SwitchName"></param>
        /// <param name="TraceOutputOptions"></param>
        /// <param name="PK_TraceConfigSettings"></param>
        public void DeleteTraceConfigurationSettings(
            int switchValue,
            int updateInterval,
            string switchName,
            int traceOutputOptions,
            int PK_TraceConfigSettings)
        {
            WgxMonitoringServiceClient client = new WgxMonitoringServiceClient();
            client = new WgxMonitoringServiceClient();
            client.DeleteTraceConfigurationSettings(
                switchValue, 
                updateInterval, 
                switchName, 
                traceOutputOptions, 
                PK_TraceConfigSettings);
            client.Close();
        }

        /// <summary>
        /// Retrieves the Summary table from the WCF web service
        /// </summary>
        /// <param name="fromDate">start date range</param>
        /// <param name="toDate">end date range</param>
        /// <param name="MachineName">the name of the machine</param>
        /// <param name="MachineOp">the comparison operator (LIKE, NOT LIKE, =)</param>
        /// <param name="Source">the source name</param>
        /// <param name="SourceOp">the comparison operator for source name</param>
        /// <param name="eventType">the event type</param>
        /// <param name="MessageId">the message ID (can be null)</param>
        /// <param name="MessageIdOp">the message ID operator</param>
        /// <param name="SortKey">the key to sort the result set</param>
        /// <param name="bAscending">the sort direction</param>
        /// <returns>SummaryEventsDataTable</returns>
        public DiagnosticDBDataSet.GetSummaryEventsDataTable GetEventsSummaryTable(
            string fromDate,
            string toDate,
            string machineName,
            int machineOp,
            string source,
            int sourceOp,
            string eventType,
            int? messageId,
            int messageIdOp,
            string sortKey,
            bool bAscending)
        {
            WgxMonitoringServiceClient client = new WgxMonitoringServiceClient();
            DiagnosticDBDataSet.GetSummaryEventsDataTable dt = client.GetSummaryDataTable(
                fromDate, 
                toDate, 
                string.IsNullOrEmpty(machineName) ? null : machineName, 
                machineOp, 
                string.IsNullOrEmpty(source) ? null : source, 
                sourceOp, 
                string.IsNullOrEmpty(eventType) ? null : eventType, 
                messageId, 
                messageIdOp, 
                sortKey, 
                bAscending);
            client.Close();
            SummaryTable = dt;
            return dt;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\EventViewer.ascx.cs ===
namespace WgxMonitoringConsoleWebApp
{
    using System;
    using System.Web;
    using System.Web.UI.WebControls;

    /// <summary>
    /// Fires when a new page index is requested
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    public delegate void PageIndexChanging(object sender, GridViewPageEventArgs e);

    /// <summary>
    /// Fires when the size of the page is changing
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="pageSize"></param>
    public delegate void PageSizeChanging(object sender, int pageSize);

    /// <summary>
    /// Display grid containing all event records belonging to a given dataset
    /// </summary>
    public partial class EventViewer : System.Web.UI.UserControl
    {
        public PageIndexChanging OnPageIndexChanging;
        public EventHandler OnColumnHeaderClick;
        public PageSizeChanging OnPageSizeChanging;

        // this is a key identifier that is used to cache the current page size for the grid view
        private const string PAGESIZE = "{EA005252-7516-4017-8AD0-0D0EB6FF1515}"; // unique identifer prevents collisions with other keys

        public GridView EventsGrid
        {
            get
            {
                return this.EventsMasterGridView;
            }
        }

        public int Page_Size
        {
            get
            {
                if (HttpContext.Current.Session[PAGESIZE] == null)
                {
                    HttpContext.Current.Session[PAGESIZE] = 50;
                }

                return (int)HttpContext.Current.Session[PAGESIZE];
            }

            set
            {
                HttpContext.Current.Session[PAGESIZE] = value;
                this.EventsMasterGridView.PageSize = value;
            }
        }

        public int CurrentPage
        {
            get
            {
                if (ViewState["CurrentPage"] == null)
                {
                    ViewState["CurrentPage"] = 0;
                }

                return (int)ViewState["CurrentPage"];
            }

            set
            {
                ViewState["CurrentPage"] = value;
                this.PageNum.Text = (value + 1).ToString();
            }
        }

        public int Total_Pages
        {
            get
            {
                int totalPages = EventPagingObject.TotalRowCount / this.Page_Size;
                if (EventPagingObject.TotalRowCount % this.EventsMasterGridView.PageSize != 0)
                {
                    totalPages++;
                }

                return totalPages;
            }
        }

        protected void Page_Load(object sender, EventArgs e)
        {
            if (!IsPostBack)
            {
                this.PageSize.Text = this.Page_Size.ToString();
            }
        }

        protected void EventViewer_DataBound(object sender, EventArgs e)
        {
            this.TotalPages.Text = string.Format(" of {0}", this.Total_Pages);
        }

        protected void EventsMasterGridView_PageIndexChanged(object sender, EventArgs e)
        {
            int pageIndex = ((System.Web.UI.WebControls.GridView)sender).SelectedIndex;
            if (pageIndex != -1)
            {
                int rowIndex = (this.EventsMasterGridView.PageIndex * this.EventsMasterGridView.PageSize) + pageIndex;
                EventPagingObject pagingObject = new EventPagingObject();
            }
        }

        protected void EventsMasterGridView_RowCommand(object sender, GridViewCommandEventArgs e)
        {
            GridView gridView = (GridView)sender;
            if (e.CommandName == "OnClickExpandButton")
            {
                int editIndex = Convert.ToInt32(e.CommandArgument);
                if (gridView.EditIndex != editIndex)
                {
                    gridView.EditIndex = editIndex;
                }
                else
                {
                    gridView.EditIndex = -1;
                }
            }
        }

        /// <summary>
        /// Color coding for event viewer based on event type
        /// </summary>
        /// <param name="source"></param>
        /// <param name="e"></param>
        protected void OnPreRenderEventType(object source, EventArgs e)
        {
            System.Web.UI.WebControls.Label ctrl = (System.Web.UI.WebControls.Label)source;

            switch (ctrl.Text)
            {
                case "Error":
                    ctrl.ForeColor = System.Drawing.Color.Red;
                    break;
                case "Information":
                    ctrl.ForeColor = System.Drawing.Color.Green;
                    break;
                case "Warning":
                    ctrl.ForeColor = System.Drawing.Color.Orange;
                    break;
                case "Critical":
                    ctrl.ForeColor = System.Drawing.Color.Red;
                    break;
                default:
                    break;
            }
        }

        protected void OnPreRenderMessage(object source, EventArgs e)
        {
            System.Web.UI.WebControls.Label ctrl = (System.Web.UI.WebControls.Label)source;
            if (ctrl.Text.Length > 50)
            {
                ctrl.Text = ctrl.Text.Substring(0, 50);
                ctrl.Text += "...";
            }
        }

        protected void EventsMasterGridView_RowCreated(object sender, GridViewRowEventArgs e)
        {
            if (e.Row.RowType == DataControlRowType.Header)
            {
                e.Row.Visible = false;
            }
            else if (e.Row.RowType == DataControlRowType.DataRow)
            {
            }
        }

        protected void OnColumn_Click(object sender, EventArgs e)
        {
            if (this.OnColumnHeaderClick != null)
            {
                this.OnColumnHeaderClick(sender, e);
            }
        }

        protected void PageNum_TextChanged(object sender, EventArgs e)
        {
            int pageIndex;
            int.TryParse(this.PageNum.Text, out pageIndex);
            pageIndex--;
            if (pageIndex >= 0 && pageIndex < this.Total_Pages)
            {
                this.CurrentPage = pageIndex;
                if (this.OnPageIndexChanging != null)
                {
                    GridViewPageEventArgs eventArgs = new GridViewPageEventArgs(pageIndex);
                    this.OnPageIndexChanging(sender, eventArgs);
                }
            }
        }

        protected void PreviousBtn_Click(object sender, EventArgs e)
        {
            if (this.CurrentPage > 0)
            {
                this.CurrentPage--;
                if (this.OnPageIndexChanging != null)
                {
                    GridViewPageEventArgs eventArgs = new GridViewPageEventArgs(this.CurrentPage);
                    this.OnPageIndexChanging(sender, eventArgs);
                }
            }            
        }

        protected void NextBtn_Click(object sender, EventArgs e)
        {
            if (this.CurrentPage + 1 < this.Total_Pages)
            {
                this.CurrentPage++;
                if (this.OnPageIndexChanging != null)
                {
                    GridViewPageEventArgs eventArgs = new GridViewPageEventArgs(this.CurrentPage);
                    this.OnPageIndexChanging(sender, eventArgs);
                }
            }
        }

        protected void PageSize_TextChanged(object sender, EventArgs e)
        {
            int pageSize;
            int.TryParse(((TextBox)sender).Text, out pageSize);
            this.Page_Size = pageSize;
            if (this.OnPageSizeChanging != null)
            {
                this.OnPageSizeChanging(sender, pageSize);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Filter.ascx.cs ===
namespace WgxMonitoringConsoleWebApp
{
    using System;
    using System.Web.UI.WebControls;

    /// <summary>
    /// Fires when the user clicks on the Refresh data button
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    public delegate void ResetData(object sender, EventArgs e);

    public partial class Filter : System.Web.UI.UserControl
    {
        public ResetData OnResetData = null;

        public string Event_Level
        {
            get
            {
                string eventLevel = string.Empty;
                foreach (ListItem item in this.EventLevel.Items)
                {
                    if (item.Selected)
                    {
                        if (!string.IsNullOrEmpty(eventLevel))
                        {
                            eventLevel += ",";
                        }

                        eventLevel += "'" + item.Value.ToString() + "'";
                    }
                }

                return eventLevel;
            }
        }

        public string Machine_Name
        {
            get
            {
                return this.MachineName.Text;
            }

            set
            {
                this.MachineName.Text = value;
            }
        }

        public string Source_Name
        {
            get { return this.SourceName.Text; }
        }

        public int? Message_ID
        {
            get
            {
                int result = -1;
                if (int.TryParse(this.MessageId.Text, out result))
                {
                    return (int?)result;
                }
                else
                {
                    return null;
                }
            }
        }

        public string FromDate
        {
            get
            {
                return this.FromDateText.Text;
            }

            set
            {
                this.FromDateText.Text = value;
            }
        }

        public string ToDate
        {
            get
            {
                return this.ToDateText.Text;
            }

            set
            {
                this.ToDateText.Text = value;
            }
        }

        public int Machine_Op
        {
            get
            {
                int result = 0;
                int.TryParse(this.MachineNameOp.SelectedValue, out result);
                return result;
            }
        }

        public int MessageID_Op
        {
            get
            {
                int result = 0;
                int.TryParse(this.MessageIdOp.SelectedValue, out result);
                return result;
            }
        }

        public int Source_Op
        {
            get
            {
                int result = 0;
                int.TryParse(this.SourceNameOp.SelectedValue, out result);
                return result;
            }
        }

        public void ClearFilter()
        {
            this.ClearFilter_Click(null, null);
        }

        /// <summary>
        /// Eventlevel filter is a comma delimited string of event levels e.g. 'Error, Warning, Information'
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void EventLevel_SelectedIndexChanged(object sender, EventArgs e)
        {
            Session["EventLevelParameter"] = string.Empty;
            foreach (ListItem item in EventLevel.Items)
            {
                if (item.Selected)
                {
                    if (!string.IsNullOrEmpty((string)Session["EventLevelParameter"]))
                    {
                        Session["EventLevelParameter"] += ",";
                    }

                    Session["EventLevelParameter"] += "'" + item.Value.ToString() + "'";
                }
            }
        }

        /// <summary>
        /// Clears all existing filter criteria
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void ClearFilter_Click(object sender, EventArgs e)
        {
            this.FromDateText.Text = string.Empty;
            this.ToDateText.Text = string.Empty;
            this.MessageId.Text = string.Empty;
            this.SourceName.Text = string.Empty;
            this.MachineName.Text = string.Empty;
            foreach (ListItem item in this.EventLevel.Items)
            {
                item.Selected = true;
            }
        }

        /// <summary>
        /// Fires and event notification to let the listener know that a new dataset is req'd
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        protected void Reset_Click(object sender, EventArgs e)
        {
            if (this.OnResetData != null)
            {
                this.OnResetData(sender, e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\RemoteConsole.aspx.cs ===
using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.Linq;
using System.Web;
using System.Web.Security;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using System.Web.UI.WebControls.WebParts;
using System.Xml.Linq;

namespace WgxMonitoringConsoleWebApp
{
    public partial class RemoteConsole : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\EventViewer.ascx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WgxMonitoringConsoleWebApp {
    
    
    public partial class EventViewer {
        
        /// <summary>
        /// PreviousBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton PreviousBtn;
        
        /// <summary>
        /// NextBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton NextBtn;
        
        /// <summary>
        /// Label1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label1;
        
        /// <summary>
        /// PageNum control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox PageNum;
        
        /// <summary>
        /// TotalPages control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label TotalPages;
        
        /// <summary>
        /// Message control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Message;
        
        /// <summary>
        /// Label2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label2;
        
        /// <summary>
        /// Page_Size control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox PageSize;
        
        /// <summary>
        /// EventTypeColumn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton EventTypeColumn;
        
        /// <summary>
        /// DateTimeColumn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton DateTimeColumn;
        
        /// <summary>
        /// MessageIDColumn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton MessageIDColumn;
        
        /// <summary>
        /// SourceNameColumn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton SourceNameColumn;
        
        /// <summary>
        /// MethodNameColumn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.LinkButton MethodNameColumn;
        
        /// <summary>
        /// EventsMasterGridView control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.GridView EventsMasterGridView;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Filter.ascx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WgxMonitoringConsoleWebApp {
    
    
    public partial class Filter {
        
        /// <summary>
        /// Literal1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Literal Literal1;
        
        /// <summary>
        /// FromDateText control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox FromDateText;
        
        /// <summary>
        /// Label5 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label5;
        
        /// <summary>
        /// ToDateText control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox ToDateText;
        
        /// <summary>
        /// EventLevel control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.CheckBoxList EventLevel;
        
        /// <summary>
        /// MessageId control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox MessageId;
        
        /// <summary>
        /// MessageIdOp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList MessageIdOp;
        
        /// <summary>
        /// Label1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Label1;
        
        /// <summary>
        /// MachineName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox MachineName;
        
        /// <summary>
        /// MachineNameOp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList MachineNameOp;
        
        /// <summary>
        /// Literal2 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Label Literal2;
        
        /// <summary>
        /// SourceName control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.TextBox SourceName;
        
        /// <summary>
        /// SourceNameOp control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.DropDownList SourceNameOp;
        
        /// <summary>
        /// RefreshDataBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button RefreshDataBtn;
        
        /// <summary>
        /// ClearFilterBtn control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.WebControls.Button ClearFilterBtn;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\RemoteConsole.aspx.designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.42
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WgxMonitoringConsoleWebApp
{


    public partial class RemoteConsole
    {

        /// <summary>
        /// form1 control.
        /// </summary>
        /// <remarks>
        /// Auto-generated field.
        /// To modify move field declaration from designer file to code-behind file.
        /// </remarks>
        protected global::System.Web.UI.HtmlControls.HtmlForm form1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\Installer.cs ===
namespace WGX.Monitoring.Service
{
    using System.ComponentModel;
    using System.ServiceProcess;

    [RunInstallerAttribute(true)]
    public class Installer : System.Configuration.Install.Installer
    {
        private ServiceInstaller serviceInstaller;
        private ServiceProcessInstaller processInstaller;

        public Installer()
        {
            this.processInstaller = new ServiceProcessInstaller();
            this.serviceInstaller = new ServiceInstaller();
            this.processInstaller.Account = ServiceAccount.LocalSystem;
            this.serviceInstaller.ServiceName = "WGXMonitoringService";
            this.serviceInstaller.StartType = ServiceStartMode.Manual;
            this.Installers.Add(this.serviceInstaller);
            this.Installers.Add(this.processInstaller);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\Program.cs ===
namespace WGX.Monitoring.Service
{
    using System.ServiceProcess;
    
    public static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        public static void Main()
        {
            ServiceBase[] servicesToRun;
            servicesToRun = new ServiceBase[] 
			{ 
				new Wgx.Services.Monitoring.Service.WgxMonitoringService()
			};
            ServiceBase.Run(servicesToRun);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\RemotingObject.cs ===
namespace Wgx.Services.Monitoring.Service
{
    using System.ComponentModel;
    using Wgx.Services.Monitoring.DiagnosticDBDataSetTableAdapters;

    public partial class RemotingObject : Component
    {
        private System.Threading.AutoResetEvent autoReset = new System.Threading.AutoResetEvent(true);
        public RemotingObject()
        {
            this.InitializeComponent();
        }

        public RemotingObject(IContainer container)
        {
            container.Add(this);
            this.InitializeComponent();
        }
        public void LogMessage(object message)
        {
            System.Threading.ThreadPool.RegisterWaitForSingleObject(this.autoReset, new System.Threading.WaitOrTimerCallback(this.DequeueMessage), message, -1, true);
        }

        protected void DequeueMessage(object xmlData)
        {
            this.autoReset.WaitOne();
            try
            {
                QueriesTableAdapter adapter = new QueriesTableAdapter();
                adapter.SendEventToAggregator("InitiatorService", "TargetService", "EventContract", "EventMessageType", xmlData);
            }
            finally
            {
                this.autoReset.Set();
            }
        }

        protected void DequeueMessage(object xmlData, bool timeOut)
        {
            try
            {
                QueriesTableAdapter adapter = new QueriesTableAdapter();
                adapter.SendEventToAggregator("InitiatorService", "TargetService", "EventContract", "EventMessageType", xmlData);
            }
            finally
            {
                this.autoReset.Set();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("WgxMonitoringConsoleWebApp")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WgxMonitoringConsoleWebApp")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3d5900ae-111a-45be-96b3-d9e4606ca793")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\RemotingObject.Designer.cs ===
namespace Wgx.Services.Monitoring.Service
{
    public partial class RemotingObject
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                this.autoReset.Close();
                if (this.components != null)
                {
                    this.components.Dispose();
                }
            }

            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            components = new System.ComponentModel.Container();
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("WGXMonitoringService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WGXMonitoringService")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8a8481e2-6556-4ed8-85f8-b107b694f758")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\WGXRemotingService.cs ===
namespace Wgx.Services.Monitoring.Service
{
    using System.Runtime.Remoting;
    using System.Runtime.Remoting.Channels;
    using System.Runtime.Remoting.Channels.Tcp;
    using System.ServiceProcess;

    public partial class WgxMonitoringService : ServiceBase
    {
        public WgxMonitoringService()
        {
            InitializeComponent();
        }

        protected override void OnStart(string[] args)
        {
            TcpServerChannel channel = new TcpServerChannel(11000);
            ChannelServices.RegisterChannel(channel, false);
            RemotingConfiguration.RegisterWellKnownServiceType(typeof(RemotingObject),  "SendToAggregator", WellKnownObjectMode.Singleton);
        }

        protected override void OnStop()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\Properties\Settings.Designer.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WGX.Monitoring.Service.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.SpecialSettingAttribute(global::System.Configuration.SpecialSetting.ConnectionString)]
        [global::System.Configuration.DefaultSettingValueAttribute("Data Source=WIN-B6F3113JBYG\\OFFICESERVERS;Initial Catalog=EventAggregator;Integra" +
            "ted Security=True")]
        public string EventAggregatorConnectionString {
            get {
                return ((string)(this["EventAggregatorConnectionString"]));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceFilter\TraceFilter.cs ===
namespace Wgx.Services.Monitoring
{
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Timers;
    using Wgx.Services.Monitoring.DiagnosticDBDataSetTableAdapters;

    public class WgxTraceFilter : System.Diagnostics.TraceFilter
    {
        private System.Timers.Timer timer = new Timer();
 
        private void RetrieveThresholdSettingsFromDB()
        {
            ListenerFilterTableAdapter adapter = new ListenerFilterTableAdapter();
            DiagnosticDBDataSet.ListenerFilterDataTable dt;
            dt = adapter.GetDataByListenerName(this.ListenerName);
            if (dt.Count > 0)
            {
                if (!(dt.Rows[0] as DiagnosticDBDataSet.ListenerFilterRow).IsTraceThresholdMaskNull())
                {
                    TraceThreshold = (dt.Rows[0] as DiagnosticDBDataSet.ListenerFilterRow).TraceThresholdMask;
                }
            }
        }

        private string GetProviderID(string providerID)
        {
            return null;
        }

        private void Initialize()
        {
            double timerInterval;
            if (double.TryParse(System.Configuration.ConfigurationManager.AppSettings["TimerInterval"], out timerInterval))
            {
                this.timer.Interval = timerInterval;
            }
            else
            {
                this.timer.Interval = 10000;
            }

            this.timer.Elapsed += new ElapsedEventHandler(this.Timer_Elapsed);
            this.timer.Enabled = true;

            this.RetrieveThresholdSettingsFromDB();
        }

        void Timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            this.RetrieveThresholdSettingsFromDB();
        }

        public int TraceThreshold
        {
            get;
            set;
        }

        public string ListenerName
        {
            get;
            set;
        }
        public WgxTraceFilter(string initializeData)
        {
            this.ListenerName = initializeData;
            this.Initialize();
        }

        public WgxTraceFilter()
        {
            this.Initialize();
        }
        
        public override bool ShouldTrace(TraceEventCache cache, string source, TraceEventType eventType, int id, string formatOrMessage, object[] args, object objListener, object[] data)
        {
            bool shouldTrace = false;
            return shouldTrace = (TraceThreshold & (int)eventType) != 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXMonitoringService\WGXRemotingService.Designer.cs ===

namespace Wgx.Services.Monitoring.Service
{
    public partial class WgxMonitoringService
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (this.components != null))
            {
                this.components.Dispose();
            }

            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            // 
            // WGXMonitoringService
            // 
            this.ServiceName = "WGXMonitoringService";

        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceFilter\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("WGXTraceFilter")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WGXTraceFilter")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3af41060-8e06-4f49-8d13-5c647678e2a2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("WGXTraceSource")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]
// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e2012597-5dc6-4077-baf2-ccb3496a86cc")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\EventAttributes.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Diagnostics;
    
    [AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
    public sealed class EventAttribute : Attribute
    {
        private string message;
        private int msgID = -1;
        private int resourceId = -1;
        private int facility = 0;
        private bool error = true; 
        private TraceEventType eventType = TraceEventType.Information;

        public EventAttribute()
        {
        }

        public bool Error
        {
            get { return this.error; }
            set { this.error = value; }
        }

        public string Message
        {
            get { return this.message; }
            set { this.message = value; }
        }

        public int MessageId
        {
            get { return this.msgID; }
            set { this.msgID = value; }
        }

        public TraceEventType TraceEventType
        {
            get { return this.eventType; }
            set { this.eventType = value; }
        }

        public int ResourceId
        {
            get { return this.resourceId; }
            set { this.resourceId = value; }
        }

        public int Facility
        {
            get { return this.facility; }
            set { this.facility = value; }
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class EventCategoryAttribute : Attribute
    {
        private int baseCounter;
        private string description;
        private int incrementAmount = 10;
        private string resourceBaseName;
        private string resourceAssembly;

        public EventCategoryAttribute()
        {
        }

        public int MessageIdBase
        {
            get { return this.baseCounter; }
            set { this.baseCounter = value; }
        }

        public int IncrementAmount
        {
            get { return this.incrementAmount; }
            set { this.incrementAmount = value; }
        }

        public string Description
        {
            get { return this.description; }
            set { this.description = value; }
        }

        public string ResourceBaseName
        {
            get { return this.resourceBaseName; }
            set { this.resourceBaseName = value; }
        }

        public string ResourceAssemblyName
        {
            get { return this.resourceAssembly; }
            set { this.resourceAssembly = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxMonitoringConsoleWebApp\Service_References\WgxWebConsoleService\Reference.cs ===
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.3053
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace WgxMonitoringConsoleWebApp.WgxWebConsoleService {
    
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.ServiceContractAttribute(ConfigurationName="WgxWebConsoleService.IWgxMonitoringService")]
    public interface IWgxMonitoringService {
        
        // CODEGEN: Parameter 'GetFilteredEventsTableResult' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetFilteredEventsTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetFilteredEventsTableResponse")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableResponse GetFilteredEventsTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableRequest request);
        
        // CODEGEN: Parameter 'fromDate' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetFilteredEventsRowCount", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetFilteredEventsRowCountResponse")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountResponse GetFilteredEventsRowCount(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountRequest request);
        
        // CODEGEN: Parameter 'GetTraceConfigurationSettingsResult' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetTraceConfigurationSettingsResponse")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsResponse GetTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsRequest request);
        
        // CODEGEN: Parameter 'GetSummaryDataTableResult' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetSummaryDataTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetSummaryDataTableResponse")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableResponse GetSummaryDataTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableRequest request);
        
        // CODEGEN: Parameter 'switchName' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/UpdateTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/UpdateTraceConfigurationSettingsResponse" +
            "")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsResponse UpdateTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsRequest request);
        
        // CODEGEN: Parameter 'GetListenerConfigurationTableResult' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/GetListenerConfigurationTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/GetListenerConfigurationTableResponse")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableResponse GetListenerConfigurationTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableRequest request);
        
        // CODEGEN: Parameter 'ListenerName' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/UpdateListenerConfigurationTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/UpdateListenerConfigurationTableResponse" +
            "")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableResponse UpdateListenerConfigurationTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableRequest request);
        
        // CODEGEN: Parameter 'ListenerName' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/InsertListenerConfigurationTable", ReplyAction="http://tempuri.org/IWgxMonitoringService/InsertListenerConfigurationTableResponse" +
            "")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableResponse InsertListenerConfigurationTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableRequest request);
        
        // CODEGEN: Parameter 'switchName' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/InsertTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/InsertTraceConfigurationSettingsResponse" +
            "")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsResponse InsertTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsRequest request);
        
        // CODEGEN: Parameter 'switchName' requires additional schema information that cannot be captured using the parameter mode. The specific attribute is 'System.Xml.Serialization.XmlElementAttribute'.
        [System.ServiceModel.OperationContractAttribute(Action="http://tempuri.org/IWgxMonitoringService/DeleteTraceConfigurationSettings", ReplyAction="http://tempuri.org/IWgxMonitoringService/DeleteTraceConfigurationSettingsResponse" +
            "")]
        [System.ServiceModel.XmlSerializerFormatAttribute()]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsResponse DeleteTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsRequest request);
    }
    
    /// <summary>
    ///Represents a strongly typed in-memory cache of data.
    ///</summary>
    // This type definition was generated by System.Data.Design.TypedDataSetSchemaImporterExtensionFx35 schema importer extension.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
    [global::System.Serializable()]
    [global::System.ComponentModel.DesignerCategoryAttribute("code")]
    [global::System.ComponentModel.ToolboxItem(true)]
    [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedDataSetSchema")]
    [global::System.Xml.Serialization.XmlRootAttribute("DiagnosticDBDataSet")]
    [global::System.ComponentModel.Design.HelpKeywordAttribute("vs.data.DataSet")]
    public partial class DiagnosticDBDataSet : global::System.Data.DataSet {
        
        private MessageIDTransformTblDataTable tableMessageIDTransformTbl;
        
        private ListenerFilterDataTable tableListenerFilter;
        
        private TraceConfigurationSettingsDataTable tableTraceConfigurationSettings;
        
        private EventsXmlDataTable tableEventsXml;
        
        private EventsDataTable tableEvents;
        
        private GetSummaryEventsDataTable tableGetSummaryEvents;
        
        private EventsReportingDataTable tableEventsReporting;
        
        private EventsSummaryDataTable tableEventsSummary;
        
        private global::System.Data.SchemaSerializationMode _schemaSerializationMode = global::System.Data.SchemaSerializationMode.IncludeSchema;
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public DiagnosticDBDataSet() {
            this.BeginInit();
            this.InitClass();
            global::System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new global::System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            base.Tables.CollectionChanged += schemaChangedHandler;
            base.Relations.CollectionChanged += schemaChangedHandler;
            this.EndInit();
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected DiagnosticDBDataSet(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                base(info, context, false) {
            if ((this.IsBinarySerialized(info, context) == true)) {
                this.InitVars(false);
                global::System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler1 = new global::System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
                this.Tables.CollectionChanged += schemaChangedHandler1;
                this.Relations.CollectionChanged += schemaChangedHandler1;
                return;
            }
            string strSchema = ((string)(info.GetValue("XmlSchema", typeof(string))));
            if ((this.DetermineSchemaSerializationMode(info, context) == global::System.Data.SchemaSerializationMode.IncludeSchema)) {
                global::System.Data.DataSet ds = new global::System.Data.DataSet();
                ds.ReadXmlSchema(new global::System.Xml.XmlTextReader(new global::System.IO.StringReader(strSchema)));
                if ((ds.Tables["MessageIDTransformTbl"] != null)) {
                    base.Tables.Add(new MessageIDTransformTblDataTable(ds.Tables["MessageIDTransformTbl"]));
                }
                if ((ds.Tables["ListenerFilter"] != null)) {
                    base.Tables.Add(new ListenerFilterDataTable(ds.Tables["ListenerFilter"]));
                }
                if ((ds.Tables["TraceConfigurationSettings"] != null)) {
                    base.Tables.Add(new TraceConfigurationSettingsDataTable(ds.Tables["TraceConfigurationSettings"]));
                }
                if ((ds.Tables["EventsXml"] != null)) {
                    base.Tables.Add(new EventsXmlDataTable(ds.Tables["EventsXml"]));
                }
                if ((ds.Tables["Events"] != null)) {
                    base.Tables.Add(new EventsDataTable(ds.Tables["Events"]));
                }
                if ((ds.Tables["GetSummaryEvents"] != null)) {
                    base.Tables.Add(new GetSummaryEventsDataTable(ds.Tables["GetSummaryEvents"]));
                }
                if ((ds.Tables["EventsReporting"] != null)) {
                    base.Tables.Add(new EventsReportingDataTable(ds.Tables["EventsReporting"]));
                }
                if ((ds.Tables["EventsSummary"] != null)) {
                    base.Tables.Add(new EventsSummaryDataTable(ds.Tables["EventsSummary"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, global::System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else {
                this.ReadXmlSchema(new global::System.Xml.XmlTextReader(new global::System.IO.StringReader(strSchema)));
            }
            this.GetSerializationData(info, context);
            global::System.ComponentModel.CollectionChangeEventHandler schemaChangedHandler = new global::System.ComponentModel.CollectionChangeEventHandler(this.SchemaChanged);
            base.Tables.CollectionChanged += schemaChangedHandler;
            this.Relations.CollectionChanged += schemaChangedHandler;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public MessageIDTransformTblDataTable MessageIDTransformTbl {
            get {
                return this.tableMessageIDTransformTbl;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public ListenerFilterDataTable ListenerFilter {
            get {
                return this.tableListenerFilter;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public TraceConfigurationSettingsDataTable TraceConfigurationSettings {
            get {
                return this.tableTraceConfigurationSettings;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public EventsXmlDataTable EventsXml {
            get {
                return this.tableEventsXml;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public new EventsDataTable Events {
            get {
                return this.tableEvents;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public GetSummaryEventsDataTable GetSummaryEvents {
            get {
                return this.tableGetSummaryEvents;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public EventsReportingDataTable EventsReporting {
            get {
                return this.tableEventsReporting;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.Browsable(false)]
        [global::System.ComponentModel.DesignerSerializationVisibility(global::System.ComponentModel.DesignerSerializationVisibility.Content)]
        public EventsSummaryDataTable EventsSummary {
            get {
                return this.tableEventsSummary;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.BrowsableAttribute(true)]
        [global::System.ComponentModel.DesignerSerializationVisibilityAttribute(global::System.ComponentModel.DesignerSerializationVisibility.Visible)]
        public override global::System.Data.SchemaSerializationMode SchemaSerializationMode {
            get {
                return this._schemaSerializationMode;
            }
            set {
                this._schemaSerializationMode = value;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.DesignerSerializationVisibilityAttribute(global::System.ComponentModel.DesignerSerializationVisibility.Hidden)]
        public new global::System.Data.DataTableCollection Tables {
            get {
                return base.Tables;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.ComponentModel.DesignerSerializationVisibilityAttribute(global::System.ComponentModel.DesignerSerializationVisibility.Hidden)]
        public new global::System.Data.DataRelationCollection Relations {
            get {
                return base.Relations;
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override void InitializeDerivedDataSet() {
            this.BeginInit();
            this.InitClass();
            this.EndInit();
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public override global::System.Data.DataSet Clone() {
            DiagnosticDBDataSet cln = ((DiagnosticDBDataSet)(base.Clone()));
            cln.InitVars();
            cln.SchemaSerializationMode = this.SchemaSerializationMode;
            return cln;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override bool ShouldSerializeTables() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override bool ShouldSerializeRelations() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override void ReadXmlSerializable(global::System.Xml.XmlReader reader) {
            if ((this.DetermineSchemaSerializationMode(reader) == global::System.Data.SchemaSerializationMode.IncludeSchema)) {
                this.Reset();
                global::System.Data.DataSet ds = new global::System.Data.DataSet();
                ds.ReadXml(reader);
                if ((ds.Tables["MessageIDTransformTbl"] != null)) {
                    base.Tables.Add(new MessageIDTransformTblDataTable(ds.Tables["MessageIDTransformTbl"]));
                }
                if ((ds.Tables["ListenerFilter"] != null)) {
                    base.Tables.Add(new ListenerFilterDataTable(ds.Tables["ListenerFilter"]));
                }
                if ((ds.Tables["TraceConfigurationSettings"] != null)) {
                    base.Tables.Add(new TraceConfigurationSettingsDataTable(ds.Tables["TraceConfigurationSettings"]));
                }
                if ((ds.Tables["EventsXml"] != null)) {
                    base.Tables.Add(new EventsXmlDataTable(ds.Tables["EventsXml"]));
                }
                if ((ds.Tables["Events"] != null)) {
                    base.Tables.Add(new EventsDataTable(ds.Tables["Events"]));
                }
                if ((ds.Tables["GetSummaryEvents"] != null)) {
                    base.Tables.Add(new GetSummaryEventsDataTable(ds.Tables["GetSummaryEvents"]));
                }
                if ((ds.Tables["EventsReporting"] != null)) {
                    base.Tables.Add(new EventsReportingDataTable(ds.Tables["EventsReporting"]));
                }
                if ((ds.Tables["EventsSummary"] != null)) {
                    base.Tables.Add(new EventsSummaryDataTable(ds.Tables["EventsSummary"]));
                }
                this.DataSetName = ds.DataSetName;
                this.Prefix = ds.Prefix;
                this.Namespace = ds.Namespace;
                this.Locale = ds.Locale;
                this.CaseSensitive = ds.CaseSensitive;
                this.EnforceConstraints = ds.EnforceConstraints;
                this.Merge(ds, false, global::System.Data.MissingSchemaAction.Add);
                this.InitVars();
            }
            else {
                this.ReadXml(reader);
                this.InitVars();
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        protected override global::System.Xml.Schema.XmlSchema GetSchemaSerializable() {
            global::System.IO.MemoryStream stream = new global::System.IO.MemoryStream();
            this.WriteXmlSchema(new global::System.Xml.XmlTextWriter(stream, null));
            stream.Position = 0;
            return global::System.Xml.Schema.XmlSchema.Read(new global::System.Xml.XmlTextReader(stream), null);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal void InitVars() {
            this.InitVars(true);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        internal void InitVars(bool initTable) {
            this.tableMessageIDTransformTbl = ((MessageIDTransformTblDataTable)(base.Tables["MessageIDTransformTbl"]));
            if ((initTable == true)) {
                if ((this.tableMessageIDTransformTbl != null)) {
                    this.tableMessageIDTransformTbl.InitVars();
                }
            }
            this.tableListenerFilter = ((ListenerFilterDataTable)(base.Tables["ListenerFilter"]));
            if ((initTable == true)) {
                if ((this.tableListenerFilter != null)) {
                    this.tableListenerFilter.InitVars();
                }
            }
            this.tableTraceConfigurationSettings = ((TraceConfigurationSettingsDataTable)(base.Tables["TraceConfigurationSettings"]));
            if ((initTable == true)) {
                if ((this.tableTraceConfigurationSettings != null)) {
                    this.tableTraceConfigurationSettings.InitVars();
                }
            }
            this.tableEventsXml = ((EventsXmlDataTable)(base.Tables["EventsXml"]));
            if ((initTable == true)) {
                if ((this.tableEventsXml != null)) {
                    this.tableEventsXml.InitVars();
                }
            }
            this.tableEvents = ((EventsDataTable)(base.Tables["Events"]));
            if ((initTable == true)) {
                if ((this.tableEvents != null)) {
                    this.tableEvents.InitVars();
                }
            }
            this.tableGetSummaryEvents = ((GetSummaryEventsDataTable)(base.Tables["GetSummaryEvents"]));
            if ((initTable == true)) {
                if ((this.tableGetSummaryEvents != null)) {
                    this.tableGetSummaryEvents.InitVars();
                }
            }
            this.tableEventsReporting = ((EventsReportingDataTable)(base.Tables["EventsReporting"]));
            if ((initTable == true)) {
                if ((this.tableEventsReporting != null)) {
                    this.tableEventsReporting.InitVars();
                }
            }
            this.tableEventsSummary = ((EventsSummaryDataTable)(base.Tables["EventsSummary"]));
            if ((initTable == true)) {
                if ((this.tableEventsSummary != null)) {
                    this.tableEventsSummary.InitVars();
                }
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void InitClass() {
            this.DataSetName = "DiagnosticDBDataSet";
            this.Prefix = "";
            this.Namespace = "http://tempuri.org/DiagnosticDBDataSet.xsd";
            this.EnforceConstraints = true;
            this.SchemaSerializationMode = global::System.Data.SchemaSerializationMode.IncludeSchema;
            this.tableMessageIDTransformTbl = new MessageIDTransformTblDataTable();
            base.Tables.Add(this.tableMessageIDTransformTbl);
            this.tableListenerFilter = new ListenerFilterDataTable();
            base.Tables.Add(this.tableListenerFilter);
            this.tableTraceConfigurationSettings = new TraceConfigurationSettingsDataTable();
            base.Tables.Add(this.tableTraceConfigurationSettings);
            this.tableEventsXml = new EventsXmlDataTable();
            base.Tables.Add(this.tableEventsXml);
            this.tableEvents = new EventsDataTable();
            base.Tables.Add(this.tableEvents);
            this.tableGetSummaryEvents = new GetSummaryEventsDataTable();
            base.Tables.Add(this.tableGetSummaryEvents);
            this.tableEventsReporting = new EventsReportingDataTable();
            base.Tables.Add(this.tableEventsReporting);
            this.tableEventsSummary = new EventsSummaryDataTable();
            base.Tables.Add(this.tableEventsSummary);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeMessageIDTransformTbl() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeListenerFilter() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeTraceConfigurationSettings() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEventsXml() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEvents() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeGetSummaryEvents() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEventsReporting() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private bool ShouldSerializeEventsSummary() {
            return false;
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        private void SchemaChanged(object sender, global::System.ComponentModel.CollectionChangeEventArgs e) {
            if ((e.Action == global::System.ComponentModel.CollectionChangeAction.Remove)) {
                this.InitVars();
            }
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedDataSetSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
            DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
            global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
            global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
            global::System.Xml.Schema.XmlSchemaAny any = new global::System.Xml.Schema.XmlSchemaAny();
            any.Namespace = ds.Namespace;
            sequence.Items.Add(any);
            type.Particle = sequence;
            global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
            if (xs.Contains(dsSchema.TargetNamespace)) {
                global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                try {
                    global::System.Xml.Schema.XmlSchema schema = null;
                    dsSchema.Write(s1);
                    for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                        schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                        s2.SetLength(0);
                        schema.Write(s2);
                        if ((s1.Length == s2.Length)) {
                            s1.Position = 0;
                            s2.Position = 0;
                            for (; ((s1.Position != s1.Length) 
                                        && (s1.ReadByte() == s2.ReadByte())); ) {
                                ;
                            }
                            if ((s1.Position == s1.Length)) {
                                return type;
                            }
                        }
                    }
                }
                finally {
                    if ((s1 != null)) {
                        s1.Close();
                    }
                    if ((s2 != null)) {
                        s2.Close();
                    }
                }
            }
            xs.Add(dsSchema);
            return type;
        }
        
        public delegate void MessageIDTransformTblRowChangeEventHandler(object sender, MessageIDTransformTblRowChangeEvent e);
        
        public delegate void ListenerFilterRowChangeEventHandler(object sender, ListenerFilterRowChangeEvent e);
        
        public delegate void TraceConfigurationSettingsRowChangeEventHandler(object sender, TraceConfigurationSettingsRowChangeEvent e);
        
        public delegate void EventsXmlRowChangeEventHandler(object sender, EventsXmlRowChangeEvent e);
        
        public delegate void EventsRowChangeEventHandler(object sender, EventsRowChangeEvent e);
        
        public delegate void GetSummaryEventsRowChangeEventHandler(object sender, GetSummaryEventsRowChangeEvent e);
        
        public delegate void EventsReportingRowChangeEventHandler(object sender, EventsReportingRowChangeEvent e);
        
        public delegate void EventsSummaryRowChangeEventHandler(object sender, EventsSummaryRowChangeEvent e);
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class MessageIDTransformTblDataTable : global::System.Data.TypedTableBase<MessageIDTransformTblRow> {
            
            private global::System.Data.DataColumn columnMessageID;
            
            private global::System.Data.DataColumn columnNewSeverity;
            
            private global::System.Data.DataColumn columnPK_MessageIDTransform;
            
            private global::System.Data.DataColumn columnShouldTrace;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblDataTable() {
                this.TableName = "MessageIDTransformTbl";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal MessageIDTransformTblDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected MessageIDTransformTblDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageIDColumn {
                get {
                    return this.columnMessageID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn NewSeverityColumn {
                get {
                    return this.columnNewSeverity;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_MessageIDTransformColumn {
                get {
                    return this.columnPK_MessageIDTransform;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ShouldTraceColumn {
                get {
                    return this.columnShouldTrace;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow this[int index] {
                get {
                    return ((MessageIDTransformTblRow)(this.Rows[index]));
                }
            }
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowChanging;
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowChanged;
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowDeleting;
            
            public event MessageIDTransformTblRowChangeEventHandler MessageIDTransformTblRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddMessageIDTransformTblRow(MessageIDTransformTblRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow AddMessageIDTransformTblRow(int MessageID, int NewSeverity, bool ShouldTrace) {
                MessageIDTransformTblRow rowMessageIDTransformTblRow = ((MessageIDTransformTblRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        MessageID,
                        NewSeverity,
                        null,
                        ShouldTrace};
                rowMessageIDTransformTblRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowMessageIDTransformTblRow);
                return rowMessageIDTransformTblRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow FindByPK_MessageIDTransform(int PK_MessageIDTransform) {
                return ((MessageIDTransformTblRow)(this.Rows.Find(new object[] {
                            PK_MessageIDTransform})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                MessageIDTransformTblDataTable cln = ((MessageIDTransformTblDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new MessageIDTransformTblDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnMessageID = base.Columns["MessageID"];
                this.columnNewSeverity = base.Columns["NewSeverity"];
                this.columnPK_MessageIDTransform = base.Columns["PK_MessageIDTransform"];
                this.columnShouldTrace = base.Columns["ShouldTrace"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnMessageID = new global::System.Data.DataColumn("MessageID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessageID);
                this.columnNewSeverity = new global::System.Data.DataColumn("NewSeverity", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnNewSeverity);
                this.columnPK_MessageIDTransform = new global::System.Data.DataColumn("PK_MessageIDTransform", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_MessageIDTransform);
                this.columnShouldTrace = new global::System.Data.DataColumn("ShouldTrace", typeof(bool), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnShouldTrace);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_MessageIDTransform}, true));
                this.columnMessageID.AllowDBNull = false;
                this.columnPK_MessageIDTransform.AutoIncrement = true;
                this.columnPK_MessageIDTransform.AutoIncrementSeed = -1;
                this.columnPK_MessageIDTransform.AutoIncrementStep = -1;
                this.columnPK_MessageIDTransform.AllowDBNull = false;
                this.columnPK_MessageIDTransform.ReadOnly = true;
                this.columnPK_MessageIDTransform.Unique = true;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow NewMessageIDTransformTblRow() {
                return ((MessageIDTransformTblRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new MessageIDTransformTblRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(MessageIDTransformTblRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.MessageIDTransformTblRowChanged != null)) {
                    this.MessageIDTransformTblRowChanged(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.MessageIDTransformTblRowChanging != null)) {
                    this.MessageIDTransformTblRowChanging(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.MessageIDTransformTblRowDeleted != null)) {
                    this.MessageIDTransformTblRowDeleted(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.MessageIDTransformTblRowDeleting != null)) {
                    this.MessageIDTransformTblRowDeleting(this, new MessageIDTransformTblRowChangeEvent(((MessageIDTransformTblRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveMessageIDTransformTblRow(MessageIDTransformTblRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "MessageIDTransformTblDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class ListenerFilterDataTable : global::System.Data.TypedTableBase<ListenerFilterRow> {
            
            private global::System.Data.DataColumn columnListenerName;
            
            private global::System.Data.DataColumn columnTraceThresholdMask;
            
            private global::System.Data.DataColumn columnTraceOutputOptions;
            
            private global::System.Data.DataColumn columnPK_FilterID;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterDataTable() {
                this.TableName = "ListenerFilter";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal ListenerFilterDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected ListenerFilterDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ListenerNameColumn {
                get {
                    return this.columnListenerName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TraceThresholdMaskColumn {
                get {
                    return this.columnTraceThresholdMask;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TraceOutputOptionsColumn {
                get {
                    return this.columnTraceOutputOptions;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_FilterIDColumn {
                get {
                    return this.columnPK_FilterID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow this[int index] {
                get {
                    return ((ListenerFilterRow)(this.Rows[index]));
                }
            }
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowChanging;
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowChanged;
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowDeleting;
            
            public event ListenerFilterRowChangeEventHandler ListenerFilterRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddListenerFilterRow(ListenerFilterRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow AddListenerFilterRow(string ListenerName, int TraceThresholdMask, int TraceOutputOptions) {
                ListenerFilterRow rowListenerFilterRow = ((ListenerFilterRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        ListenerName,
                        TraceThresholdMask,
                        TraceOutputOptions,
                        null};
                rowListenerFilterRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowListenerFilterRow);
                return rowListenerFilterRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow FindByPK_FilterID(int PK_FilterID) {
                return ((ListenerFilterRow)(this.Rows.Find(new object[] {
                            PK_FilterID})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                ListenerFilterDataTable cln = ((ListenerFilterDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new ListenerFilterDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnListenerName = base.Columns["ListenerName"];
                this.columnTraceThresholdMask = base.Columns["TraceThresholdMask"];
                this.columnTraceOutputOptions = base.Columns["TraceOutputOptions"];
                this.columnPK_FilterID = base.Columns["PK_FilterID"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnListenerName = new global::System.Data.DataColumn("ListenerName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnListenerName);
                this.columnTraceThresholdMask = new global::System.Data.DataColumn("TraceThresholdMask", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTraceThresholdMask);
                this.columnTraceOutputOptions = new global::System.Data.DataColumn("TraceOutputOptions", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTraceOutputOptions);
                this.columnPK_FilterID = new global::System.Data.DataColumn("PK_FilterID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_FilterID);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_FilterID}, true));
                this.columnListenerName.MaxLength = 2147483647;
                this.columnPK_FilterID.AutoIncrement = true;
                this.columnPK_FilterID.AutoIncrementSeed = -1;
                this.columnPK_FilterID.AutoIncrementStep = -1;
                this.columnPK_FilterID.AllowDBNull = false;
                this.columnPK_FilterID.ReadOnly = true;
                this.columnPK_FilterID.Unique = true;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow NewListenerFilterRow() {
                return ((ListenerFilterRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new ListenerFilterRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(ListenerFilterRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.ListenerFilterRowChanged != null)) {
                    this.ListenerFilterRowChanged(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.ListenerFilterRowChanging != null)) {
                    this.ListenerFilterRowChanging(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.ListenerFilterRowDeleted != null)) {
                    this.ListenerFilterRowDeleted(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.ListenerFilterRowDeleting != null)) {
                    this.ListenerFilterRowDeleting(this, new ListenerFilterRowChangeEvent(((ListenerFilterRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveListenerFilterRow(ListenerFilterRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "ListenerFilterDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class TraceConfigurationSettingsDataTable : global::System.Data.TypedTableBase<TraceConfigurationSettingsRow> {
            
            private global::System.Data.DataColumn columnSwitchValue;
            
            private global::System.Data.DataColumn columnUpdateInterval;
            
            private global::System.Data.DataColumn columnSwitchName;
            
            private global::System.Data.DataColumn columnTraceOutputOptions;
            
            private global::System.Data.DataColumn columnPK_TraceConfigSettings;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsDataTable() {
                this.TableName = "TraceConfigurationSettings";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal TraceConfigurationSettingsDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected TraceConfigurationSettingsDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SwitchValueColumn {
                get {
                    return this.columnSwitchValue;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn UpdateIntervalColumn {
                get {
                    return this.columnUpdateInterval;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SwitchNameColumn {
                get {
                    return this.columnSwitchName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TraceOutputOptionsColumn {
                get {
                    return this.columnTraceOutputOptions;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_TraceConfigSettingsColumn {
                get {
                    return this.columnPK_TraceConfigSettings;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow this[int index] {
                get {
                    return ((TraceConfigurationSettingsRow)(this.Rows[index]));
                }
            }
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowChanging;
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowChanged;
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowDeleting;
            
            public event TraceConfigurationSettingsRowChangeEventHandler TraceConfigurationSettingsRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddTraceConfigurationSettingsRow(TraceConfigurationSettingsRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow AddTraceConfigurationSettingsRow(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions) {
                TraceConfigurationSettingsRow rowTraceConfigurationSettingsRow = ((TraceConfigurationSettingsRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        SwitchValue,
                        UpdateInterval,
                        SwitchName,
                        TraceOutputOptions,
                        null};
                rowTraceConfigurationSettingsRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowTraceConfigurationSettingsRow);
                return rowTraceConfigurationSettingsRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow FindByPK_TraceConfigSettings(int PK_TraceConfigSettings) {
                return ((TraceConfigurationSettingsRow)(this.Rows.Find(new object[] {
                            PK_TraceConfigSettings})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                TraceConfigurationSettingsDataTable cln = ((TraceConfigurationSettingsDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new TraceConfigurationSettingsDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnSwitchValue = base.Columns["SwitchValue"];
                this.columnUpdateInterval = base.Columns["UpdateInterval"];
                this.columnSwitchName = base.Columns["SwitchName"];
                this.columnTraceOutputOptions = base.Columns["TraceOutputOptions"];
                this.columnPK_TraceConfigSettings = base.Columns["PK_TraceConfigSettings"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnSwitchValue = new global::System.Data.DataColumn("SwitchValue", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSwitchValue);
                this.columnUpdateInterval = new global::System.Data.DataColumn("UpdateInterval", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnUpdateInterval);
                this.columnSwitchName = new global::System.Data.DataColumn("SwitchName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSwitchName);
                this.columnTraceOutputOptions = new global::System.Data.DataColumn("TraceOutputOptions", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTraceOutputOptions);
                this.columnPK_TraceConfigSettings = new global::System.Data.DataColumn("PK_TraceConfigSettings", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_TraceConfigSettings);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_TraceConfigSettings}, true));
                this.columnSwitchName.MaxLength = 2147483647;
                this.columnPK_TraceConfigSettings.AutoIncrement = true;
                this.columnPK_TraceConfigSettings.AutoIncrementSeed = -1;
                this.columnPK_TraceConfigSettings.AutoIncrementStep = -1;
                this.columnPK_TraceConfigSettings.AllowDBNull = false;
                this.columnPK_TraceConfigSettings.ReadOnly = true;
                this.columnPK_TraceConfigSettings.Unique = true;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow NewTraceConfigurationSettingsRow() {
                return ((TraceConfigurationSettingsRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new TraceConfigurationSettingsRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(TraceConfigurationSettingsRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.TraceConfigurationSettingsRowChanged != null)) {
                    this.TraceConfigurationSettingsRowChanged(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.TraceConfigurationSettingsRowChanging != null)) {
                    this.TraceConfigurationSettingsRowChanging(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.TraceConfigurationSettingsRowDeleted != null)) {
                    this.TraceConfigurationSettingsRowDeleted(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.TraceConfigurationSettingsRowDeleting != null)) {
                    this.TraceConfigurationSettingsRowDeleting(this, new TraceConfigurationSettingsRowChangeEvent(((TraceConfigurationSettingsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveTraceConfigurationSettingsRow(TraceConfigurationSettingsRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "TraceConfigurationSettingsDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsXmlDataTable : global::System.Data.TypedTableBase<EventsXmlRow> {
            
            private global::System.Data.DataColumn columnPK_Events;
            
            private global::System.Data.DataColumn columnEventData;
            
            private global::System.Data.DataColumn columnRowNumber;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlDataTable() {
                this.TableName = "EventsXml";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsXmlDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsXmlDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn PK_EventsColumn {
                get {
                    return this.columnPK_Events;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventDataColumn {
                get {
                    return this.columnEventData;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn RowNumberColumn {
                get {
                    return this.columnRowNumber;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow this[int index] {
                get {
                    return ((EventsXmlRow)(this.Rows[index]));
                }
            }
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowChanging;
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowChanged;
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowDeleting;
            
            public event EventsXmlRowChangeEventHandler EventsXmlRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsXmlRow(EventsXmlRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow AddEventsXmlRow(string EventData, int RowNumber) {
                EventsXmlRow rowEventsXmlRow = ((EventsXmlRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        null,
                        EventData,
                        RowNumber};
                rowEventsXmlRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsXmlRow);
                return rowEventsXmlRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow FindByPK_Events(int PK_Events) {
                return ((EventsXmlRow)(this.Rows.Find(new object[] {
                            PK_Events})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsXmlDataTable cln = ((EventsXmlDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsXmlDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnPK_Events = base.Columns["PK_Events"];
                this.columnEventData = base.Columns["EventData"];
                this.columnRowNumber = base.Columns["RowNumber"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnPK_Events = new global::System.Data.DataColumn("PK_Events", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnPK_Events);
                this.columnEventData = new global::System.Data.DataColumn("EventData", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventData);
                this.columnRowNumber = new global::System.Data.DataColumn("RowNumber", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnRowNumber);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnPK_Events}, true));
                this.columnPK_Events.AutoIncrement = true;
                this.columnPK_Events.AutoIncrementSeed = -1;
                this.columnPK_Events.AutoIncrementStep = -1;
                this.columnPK_Events.AllowDBNull = false;
                this.columnPK_Events.ReadOnly = true;
                this.columnPK_Events.Unique = true;
                this.columnEventData.MaxLength = 2147483647;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow NewEventsXmlRow() {
                return ((EventsXmlRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsXmlRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsXmlRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsXmlRowChanged != null)) {
                    this.EventsXmlRowChanged(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsXmlRowChanging != null)) {
                    this.EventsXmlRowChanging(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsXmlRowDeleted != null)) {
                    this.EventsXmlRowDeleted(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsXmlRowDeleting != null)) {
                    this.EventsXmlRowDeleting(this, new EventsXmlRowChangeEvent(((EventsXmlRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsXmlRow(EventsXmlRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsXmlDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsDataTable : global::System.Data.TypedTableBase<EventsRow> {
            
            private global::System.Data.DataColumn columnEventID;
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnSource;
            
            private global::System.Data.DataColumn columnMessageID;
            
            private global::System.Data.DataColumn columnMessage;
            
            private global::System.Data.DataColumn columnFileName;
            
            private global::System.Data.DataColumn columnLineNumber;
            
            private global::System.Data.DataColumn columnMethodName;
            
            private global::System.Data.DataColumn columnDateTime;
            
            private global::System.Data.DataColumn columnTimeStamp;
            
            private global::System.Data.DataColumn columnProcessID;
            
            private global::System.Data.DataColumn columnThreadID;
            
            private global::System.Data.DataColumn columnCallStack;
            
            private global::System.Data.DataColumn columnLogicalStack;
            
            private global::System.Data.DataColumn columnEventType;
            
            private global::System.Data.DataColumn columnAssemblyName;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsDataTable() {
                this.TableName = "Events";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventIDColumn {
                get {
                    return this.columnEventID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SourceColumn {
                get {
                    return this.columnSource;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageIDColumn {
                get {
                    return this.columnMessageID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageColumn {
                get {
                    return this.columnMessage;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn FileNameColumn {
                get {
                    return this.columnFileName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn LineNumberColumn {
                get {
                    return this.columnLineNumber;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MethodNameColumn {
                get {
                    return this.columnMethodName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn DateTimeColumn {
                get {
                    return this.columnDateTime;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TimeStampColumn {
                get {
                    return this.columnTimeStamp;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ProcessIDColumn {
                get {
                    return this.columnProcessID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ThreadIDColumn {
                get {
                    return this.columnThreadID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn CallStackColumn {
                get {
                    return this.columnCallStack;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn LogicalStackColumn {
                get {
                    return this.columnLogicalStack;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventTypeColumn {
                get {
                    return this.columnEventType;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn AssemblyNameColumn {
                get {
                    return this.columnAssemblyName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow this[int index] {
                get {
                    return ((EventsRow)(this.Rows[index]));
                }
            }
            
            public event EventsRowChangeEventHandler EventsRowChanging;
            
            public event EventsRowChangeEventHandler EventsRowChanged;
            
            public event EventsRowChangeEventHandler EventsRowDeleting;
            
            public event EventsRowChangeEventHandler EventsRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsRow(EventsRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow AddEventsRow(string MachineName, string Source, int MessageID, string Message, string FileName, int LineNumber, string MethodName, System.DateTime DateTime, long TimeStamp, int ProcessID, string ThreadID, string CallStack, string LogicalStack, string EventType, string AssemblyName) {
                EventsRow rowEventsRow = ((EventsRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        null,
                        MachineName,
                        Source,
                        MessageID,
                        Message,
                        FileName,
                        LineNumber,
                        MethodName,
                        DateTime,
                        TimeStamp,
                        ProcessID,
                        ThreadID,
                        CallStack,
                        LogicalStack,
                        EventType,
                        AssemblyName};
                rowEventsRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsRow);
                return rowEventsRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow FindByEventID(int EventID) {
                return ((EventsRow)(this.Rows.Find(new object[] {
                            EventID})));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsDataTable cln = ((EventsDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnEventID = base.Columns["EventID"];
                this.columnMachineName = base.Columns["MachineName"];
                this.columnSource = base.Columns["Source"];
                this.columnMessageID = base.Columns["MessageID"];
                this.columnMessage = base.Columns["Message"];
                this.columnFileName = base.Columns["FileName"];
                this.columnLineNumber = base.Columns["LineNumber"];
                this.columnMethodName = base.Columns["MethodName"];
                this.columnDateTime = base.Columns["DateTime"];
                this.columnTimeStamp = base.Columns["TimeStamp"];
                this.columnProcessID = base.Columns["ProcessID"];
                this.columnThreadID = base.Columns["ThreadID"];
                this.columnCallStack = base.Columns["CallStack"];
                this.columnLogicalStack = base.Columns["LogicalStack"];
                this.columnEventType = base.Columns["EventType"];
                this.columnAssemblyName = base.Columns["AssemblyName"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnEventID = new global::System.Data.DataColumn("EventID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventID);
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnSource = new global::System.Data.DataColumn("Source", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSource);
                this.columnMessageID = new global::System.Data.DataColumn("MessageID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessageID);
                this.columnMessage = new global::System.Data.DataColumn("Message", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessage);
                this.columnFileName = new global::System.Data.DataColumn("FileName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnFileName);
                this.columnLineNumber = new global::System.Data.DataColumn("LineNumber", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnLineNumber);
                this.columnMethodName = new global::System.Data.DataColumn("MethodName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMethodName);
                this.columnDateTime = new global::System.Data.DataColumn("DateTime", typeof(global::System.DateTime), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnDateTime);
                this.columnTimeStamp = new global::System.Data.DataColumn("TimeStamp", typeof(long), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTimeStamp);
                this.columnProcessID = new global::System.Data.DataColumn("ProcessID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnProcessID);
                this.columnThreadID = new global::System.Data.DataColumn("ThreadID", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnThreadID);
                this.columnCallStack = new global::System.Data.DataColumn("CallStack", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnCallStack);
                this.columnLogicalStack = new global::System.Data.DataColumn("LogicalStack", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnLogicalStack);
                this.columnEventType = new global::System.Data.DataColumn("EventType", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventType);
                this.columnAssemblyName = new global::System.Data.DataColumn("AssemblyName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnAssemblyName);
                this.Constraints.Add(new global::System.Data.UniqueConstraint("Constraint1", new global::System.Data.DataColumn[] {
                                this.columnEventID}, true));
                this.columnEventID.AutoIncrement = true;
                this.columnEventID.AutoIncrementSeed = -1;
                this.columnEventID.AutoIncrementStep = -1;
                this.columnEventID.AllowDBNull = false;
                this.columnEventID.ReadOnly = true;
                this.columnEventID.Unique = true;
                this.columnMachineName.MaxLength = 2147483647;
                this.columnSource.MaxLength = 2147483647;
                this.columnMessage.MaxLength = 2147483647;
                this.columnFileName.MaxLength = 2147483647;
                this.columnMethodName.MaxLength = 2147483647;
                this.columnThreadID.MaxLength = 2147483647;
                this.columnCallStack.MaxLength = 2147483647;
                this.columnLogicalStack.MaxLength = 2147483647;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow NewEventsRow() {
                return ((EventsRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsRowChanged != null)) {
                    this.EventsRowChanged(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsRowChanging != null)) {
                    this.EventsRowChanging(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsRowDeleted != null)) {
                    this.EventsRowDeleted(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsRowDeleting != null)) {
                    this.EventsRowDeleting(this, new EventsRowChangeEvent(((EventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsRow(EventsRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class GetSummaryEventsDataTable : global::System.Data.TypedTableBase<GetSummaryEventsRow> {
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnTotalErrors;
            
            private global::System.Data.DataColumn columnTotalWarnings;
            
            private global::System.Data.DataColumn columnTotalCriticals;
            
            private global::System.Data.DataColumn columnTotalInformational;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsDataTable() {
                this.TableName = "GetSummaryEvents";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal GetSummaryEventsDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected GetSummaryEventsDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalErrorsColumn {
                get {
                    return this.columnTotalErrors;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalWarningsColumn {
                get {
                    return this.columnTotalWarnings;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalCriticalsColumn {
                get {
                    return this.columnTotalCriticals;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalInformationalColumn {
                get {
                    return this.columnTotalInformational;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow this[int index] {
                get {
                    return ((GetSummaryEventsRow)(this.Rows[index]));
                }
            }
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowChanging;
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowChanged;
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowDeleting;
            
            public event GetSummaryEventsRowChangeEventHandler GetSummaryEventsRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddGetSummaryEventsRow(GetSummaryEventsRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow AddGetSummaryEventsRow(string MachineName, int TotalErrors, int TotalWarnings, int TotalCriticals, int TotalInformational) {
                GetSummaryEventsRow rowGetSummaryEventsRow = ((GetSummaryEventsRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        MachineName,
                        TotalErrors,
                        TotalWarnings,
                        TotalCriticals,
                        TotalInformational};
                rowGetSummaryEventsRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowGetSummaryEventsRow);
                return rowGetSummaryEventsRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                GetSummaryEventsDataTable cln = ((GetSummaryEventsDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new GetSummaryEventsDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnMachineName = base.Columns["MachineName"];
                this.columnTotalErrors = base.Columns["TotalErrors"];
                this.columnTotalWarnings = base.Columns["TotalWarnings"];
                this.columnTotalCriticals = base.Columns["TotalCriticals"];
                this.columnTotalInformational = base.Columns["TotalInformational"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnTotalErrors = new global::System.Data.DataColumn("TotalErrors", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalErrors);
                this.columnTotalWarnings = new global::System.Data.DataColumn("TotalWarnings", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalWarnings);
                this.columnTotalCriticals = new global::System.Data.DataColumn("TotalCriticals", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalCriticals);
                this.columnTotalInformational = new global::System.Data.DataColumn("TotalInformational", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalInformational);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow NewGetSummaryEventsRow() {
                return ((GetSummaryEventsRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new GetSummaryEventsRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(GetSummaryEventsRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.GetSummaryEventsRowChanged != null)) {
                    this.GetSummaryEventsRowChanged(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.GetSummaryEventsRowChanging != null)) {
                    this.GetSummaryEventsRowChanging(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.GetSummaryEventsRowDeleted != null)) {
                    this.GetSummaryEventsRowDeleted(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.GetSummaryEventsRowDeleting != null)) {
                    this.GetSummaryEventsRowDeleting(this, new GetSummaryEventsRowChangeEvent(((GetSummaryEventsRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveGetSummaryEventsRow(GetSummaryEventsRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "GetSummaryEventsDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsReportingDataTable : global::System.Data.TypedTableBase<EventsReportingRow> {
            
            private global::System.Data.DataColumn columnEventType;
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnAssemblyName;
            
            private global::System.Data.DataColumn columnSourceName;
            
            private global::System.Data.DataColumn columnDateTime;
            
            private global::System.Data.DataColumn columnMethodName;
            
            private global::System.Data.DataColumn columnProcessID;
            
            private global::System.Data.DataColumn columnThreadID;
            
            private global::System.Data.DataColumn columnMessage;
            
            private global::System.Data.DataColumn columnCallStack;
            
            private global::System.Data.DataColumn columnMessageID;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingDataTable() {
                this.TableName = "EventsReporting";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsReportingDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsReportingDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn EventTypeColumn {
                get {
                    return this.columnEventType;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn AssemblyNameColumn {
                get {
                    return this.columnAssemblyName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn SourceNameColumn {
                get {
                    return this.columnSourceName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn DateTimeColumn {
                get {
                    return this.columnDateTime;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MethodNameColumn {
                get {
                    return this.columnMethodName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ProcessIDColumn {
                get {
                    return this.columnProcessID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn ThreadIDColumn {
                get {
                    return this.columnThreadID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageColumn {
                get {
                    return this.columnMessage;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn CallStackColumn {
                get {
                    return this.columnCallStack;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MessageIDColumn {
                get {
                    return this.columnMessageID;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow this[int index] {
                get {
                    return ((EventsReportingRow)(this.Rows[index]));
                }
            }
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowChanging;
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowChanged;
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowDeleting;
            
            public event EventsReportingRowChangeEventHandler EventsReportingRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsReportingRow(EventsReportingRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow AddEventsReportingRow(string EventType, string MachineName, string AssemblyName, string SourceName, System.DateTime DateTime, string MethodName, string ProcessID, string ThreadID, string Message, string CallStack, int MessageID) {
                EventsReportingRow rowEventsReportingRow = ((EventsReportingRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        EventType,
                        MachineName,
                        AssemblyName,
                        SourceName,
                        DateTime,
                        MethodName,
                        ProcessID,
                        ThreadID,
                        Message,
                        CallStack,
                        MessageID};
                rowEventsReportingRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsReportingRow);
                return rowEventsReportingRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsReportingDataTable cln = ((EventsReportingDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsReportingDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnEventType = base.Columns["EventType"];
                this.columnMachineName = base.Columns["MachineName"];
                this.columnAssemblyName = base.Columns["AssemblyName"];
                this.columnSourceName = base.Columns["SourceName"];
                this.columnDateTime = base.Columns["DateTime"];
                this.columnMethodName = base.Columns["MethodName"];
                this.columnProcessID = base.Columns["ProcessID"];
                this.columnThreadID = base.Columns["ThreadID"];
                this.columnMessage = base.Columns["Message"];
                this.columnCallStack = base.Columns["CallStack"];
                this.columnMessageID = base.Columns["MessageID"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnEventType = new global::System.Data.DataColumn("EventType", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnEventType);
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnAssemblyName = new global::System.Data.DataColumn("AssemblyName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnAssemblyName);
                this.columnSourceName = new global::System.Data.DataColumn("SourceName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnSourceName);
                this.columnDateTime = new global::System.Data.DataColumn("DateTime", typeof(global::System.DateTime), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnDateTime);
                this.columnMethodName = new global::System.Data.DataColumn("MethodName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMethodName);
                this.columnProcessID = new global::System.Data.DataColumn("ProcessID", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnProcessID);
                this.columnThreadID = new global::System.Data.DataColumn("ThreadID", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnThreadID);
                this.columnMessage = new global::System.Data.DataColumn("Message", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessage);
                this.columnCallStack = new global::System.Data.DataColumn("CallStack", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnCallStack);
                this.columnMessageID = new global::System.Data.DataColumn("MessageID", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMessageID);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow NewEventsReportingRow() {
                return ((EventsReportingRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsReportingRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsReportingRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsReportingRowChanged != null)) {
                    this.EventsReportingRowChanged(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsReportingRowChanging != null)) {
                    this.EventsReportingRowChanging(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsReportingRowDeleted != null)) {
                    this.EventsReportingRowDeleted(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsReportingRowDeleting != null)) {
                    this.EventsReportingRowDeleting(this, new EventsReportingRowChangeEvent(((EventsReportingRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsReportingRow(EventsReportingRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsReportingDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents the strongly named DataTable class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        [global::System.Serializable()]
        [global::System.Xml.Serialization.XmlSchemaProviderAttribute("GetTypedTableSchema")]
        public partial class EventsSummaryDataTable : global::System.Data.TypedTableBase<EventsSummaryRow> {
            
            private global::System.Data.DataColumn columnMachineName;
            
            private global::System.Data.DataColumn columnTotalErrors;
            
            private global::System.Data.DataColumn columnTotalWarnings;
            
            private global::System.Data.DataColumn columnTotalCriticals;
            
            private global::System.Data.DataColumn columnTotalInformational;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryDataTable() {
                this.TableName = "EventsSummary";
                this.BeginInit();
                this.InitClass();
                this.EndInit();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsSummaryDataTable(global::System.Data.DataTable table) {
                this.TableName = table.TableName;
                if ((table.CaseSensitive != table.DataSet.CaseSensitive)) {
                    this.CaseSensitive = table.CaseSensitive;
                }
                if ((table.Locale.ToString() != table.DataSet.Locale.ToString())) {
                    this.Locale = table.Locale;
                }
                if ((table.Namespace != table.DataSet.Namespace)) {
                    this.Namespace = table.Namespace;
                }
                this.Prefix = table.Prefix;
                this.MinimumCapacity = table.MinimumCapacity;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected EventsSummaryDataTable(global::System.Runtime.Serialization.SerializationInfo info, global::System.Runtime.Serialization.StreamingContext context) : 
                    base(info, context) {
                this.InitVars();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn MachineNameColumn {
                get {
                    return this.columnMachineName;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalErrorsColumn {
                get {
                    return this.columnTotalErrors;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalWarningsColumn {
                get {
                    return this.columnTotalWarnings;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalCriticalsColumn {
                get {
                    return this.columnTotalCriticals;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataColumn TotalInformationalColumn {
                get {
                    return this.columnTotalInformational;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            [global::System.ComponentModel.Browsable(false)]
            public int Count {
                get {
                    return this.Rows.Count;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow this[int index] {
                get {
                    return ((EventsSummaryRow)(this.Rows[index]));
                }
            }
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowChanging;
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowChanged;
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowDeleting;
            
            public event EventsSummaryRowChangeEventHandler EventsSummaryRowDeleted;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void AddEventsSummaryRow(EventsSummaryRow row) {
                this.Rows.Add(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow AddEventsSummaryRow(string MachineName, int TotalErrors, int TotalWarnings, int TotalCriticals, int TotalInformational) {
                EventsSummaryRow rowEventsSummaryRow = ((EventsSummaryRow)(this.NewRow()));
                object[] columnValuesArray = new object[] {
                        MachineName,
                        TotalErrors,
                        TotalWarnings,
                        TotalCriticals,
                        TotalInformational};
                rowEventsSummaryRow.ItemArray = columnValuesArray;
                this.Rows.Add(rowEventsSummaryRow);
                return rowEventsSummaryRow;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public override global::System.Data.DataTable Clone() {
                EventsSummaryDataTable cln = ((EventsSummaryDataTable)(base.Clone()));
                cln.InitVars();
                return cln;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataTable CreateInstance() {
                return new EventsSummaryDataTable();
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal void InitVars() {
                this.columnMachineName = base.Columns["MachineName"];
                this.columnTotalErrors = base.Columns["TotalErrors"];
                this.columnTotalWarnings = base.Columns["TotalWarnings"];
                this.columnTotalCriticals = base.Columns["TotalCriticals"];
                this.columnTotalInformational = base.Columns["TotalInformational"];
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            private void InitClass() {
                this.columnMachineName = new global::System.Data.DataColumn("MachineName", typeof(string), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnMachineName);
                this.columnTotalErrors = new global::System.Data.DataColumn("TotalErrors", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalErrors);
                this.columnTotalWarnings = new global::System.Data.DataColumn("TotalWarnings", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalWarnings);
                this.columnTotalCriticals = new global::System.Data.DataColumn("TotalCriticals", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalCriticals);
                this.columnTotalInformational = new global::System.Data.DataColumn("TotalInformational", typeof(int), null, global::System.Data.MappingType.Element);
                base.Columns.Add(this.columnTotalInformational);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow NewEventsSummaryRow() {
                return ((EventsSummaryRow)(this.NewRow()));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Data.DataRow NewRowFromBuilder(global::System.Data.DataRowBuilder builder) {
                return new EventsSummaryRow(builder);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override global::System.Type GetRowType() {
                return typeof(EventsSummaryRow);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanged(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanged(e);
                if ((this.EventsSummaryRowChanged != null)) {
                    this.EventsSummaryRowChanged(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowChanging(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowChanging(e);
                if ((this.EventsSummaryRowChanging != null)) {
                    this.EventsSummaryRowChanging(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleted(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleted(e);
                if ((this.EventsSummaryRowDeleted != null)) {
                    this.EventsSummaryRowDeleted(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            protected override void OnRowDeleting(global::System.Data.DataRowChangeEventArgs e) {
                base.OnRowDeleting(e);
                if ((this.EventsSummaryRowDeleting != null)) {
                    this.EventsSummaryRowDeleting(this, new EventsSummaryRowChangeEvent(((EventsSummaryRow)(e.Row)), e.Action));
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void RemoveEventsSummaryRow(EventsSummaryRow row) {
                this.Rows.Remove(row);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public static global::System.Xml.Schema.XmlSchemaComplexType GetTypedTableSchema(global::System.Xml.Schema.XmlSchemaSet xs) {
                global::System.Xml.Schema.XmlSchemaComplexType type = new global::System.Xml.Schema.XmlSchemaComplexType();
                global::System.Xml.Schema.XmlSchemaSequence sequence = new global::System.Xml.Schema.XmlSchemaSequence();
                DiagnosticDBDataSet ds = new DiagnosticDBDataSet();
                global::System.Xml.Schema.XmlSchemaAny any1 = new global::System.Xml.Schema.XmlSchemaAny();
                any1.Namespace = "http://www.w3.org/2001/XMLSchema";
                any1.MinOccurs = new decimal(0);
                any1.MaxOccurs = decimal.MaxValue;
                any1.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any1);
                global::System.Xml.Schema.XmlSchemaAny any2 = new global::System.Xml.Schema.XmlSchemaAny();
                any2.Namespace = "urn:schemas-microsoft-com:xml-diffgram-v1";
                any2.MinOccurs = new decimal(1);
                any2.ProcessContents = global::System.Xml.Schema.XmlSchemaContentProcessing.Lax;
                sequence.Items.Add(any2);
                global::System.Xml.Schema.XmlSchemaAttribute attribute1 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute1.Name = "namespace";
                attribute1.FixedValue = ds.Namespace;
                type.Attributes.Add(attribute1);
                global::System.Xml.Schema.XmlSchemaAttribute attribute2 = new global::System.Xml.Schema.XmlSchemaAttribute();
                attribute2.Name = "tableTypeName";
                attribute2.FixedValue = "EventsSummaryDataTable";
                type.Attributes.Add(attribute2);
                type.Particle = sequence;
                global::System.Xml.Schema.XmlSchema dsSchema = ds.GetSchemaSerializable();
                if (xs.Contains(dsSchema.TargetNamespace)) {
                    global::System.IO.MemoryStream s1 = new global::System.IO.MemoryStream();
                    global::System.IO.MemoryStream s2 = new global::System.IO.MemoryStream();
                    try {
                        global::System.Xml.Schema.XmlSchema schema = null;
                        dsSchema.Write(s1);
                        for (global::System.Collections.IEnumerator schemas = xs.Schemas(dsSchema.TargetNamespace).GetEnumerator(); schemas.MoveNext(); ) {
                            schema = ((global::System.Xml.Schema.XmlSchema)(schemas.Current));
                            s2.SetLength(0);
                            schema.Write(s2);
                            if ((s1.Length == s2.Length)) {
                                s1.Position = 0;
                                s2.Position = 0;
                                for (; ((s1.Position != s1.Length) 
                                            && (s1.ReadByte() == s2.ReadByte())); ) {
                                    ;
                                }
                                if ((s1.Position == s1.Length)) {
                                    return type;
                                }
                            }
                        }
                    }
                    finally {
                        if ((s1 != null)) {
                            s1.Close();
                        }
                        if ((s2 != null)) {
                            s2.Close();
                        }
                    }
                }
                xs.Add(dsSchema);
                return type;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class MessageIDTransformTblRow : global::System.Data.DataRow {
            
            private MessageIDTransformTblDataTable tableMessageIDTransformTbl;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal MessageIDTransformTblRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableMessageIDTransformTbl = ((MessageIDTransformTblDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int MessageID {
                get {
                    return ((int)(this[this.tableMessageIDTransformTbl.MessageIDColumn]));
                }
                set {
                    this[this.tableMessageIDTransformTbl.MessageIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int NewSeverity {
                get {
                    try {
                        return ((int)(this[this.tableMessageIDTransformTbl.NewSeverityColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'NewSeverity\' in table \'MessageIDTransformTbl\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableMessageIDTransformTbl.NewSeverityColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_MessageIDTransform {
                get {
                    return ((int)(this[this.tableMessageIDTransformTbl.PK_MessageIDTransformColumn]));
                }
                set {
                    this[this.tableMessageIDTransformTbl.PK_MessageIDTransformColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool ShouldTrace {
                get {
                    try {
                        return ((bool)(this[this.tableMessageIDTransformTbl.ShouldTraceColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ShouldTrace\' in table \'MessageIDTransformTbl\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableMessageIDTransformTbl.ShouldTraceColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsNewSeverityNull() {
                return this.IsNull(this.tableMessageIDTransformTbl.NewSeverityColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetNewSeverityNull() {
                this[this.tableMessageIDTransformTbl.NewSeverityColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsShouldTraceNull() {
                return this.IsNull(this.tableMessageIDTransformTbl.ShouldTraceColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetShouldTraceNull() {
                this[this.tableMessageIDTransformTbl.ShouldTraceColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class ListenerFilterRow : global::System.Data.DataRow {
            
            private ListenerFilterDataTable tableListenerFilter;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal ListenerFilterRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableListenerFilter = ((ListenerFilterDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ListenerName {
                get {
                    try {
                        return ((string)(this[this.tableListenerFilter.ListenerNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ListenerName\' in table \'ListenerFilter\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableListenerFilter.ListenerNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TraceThresholdMask {
                get {
                    try {
                        return ((int)(this[this.tableListenerFilter.TraceThresholdMaskColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TraceThresholdMask\' in table \'ListenerFilter\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableListenerFilter.TraceThresholdMaskColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TraceOutputOptions {
                get {
                    try {
                        return ((int)(this[this.tableListenerFilter.TraceOutputOptionsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TraceOutputOptions\' in table \'ListenerFilter\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableListenerFilter.TraceOutputOptionsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_FilterID {
                get {
                    return ((int)(this[this.tableListenerFilter.PK_FilterIDColumn]));
                }
                set {
                    this[this.tableListenerFilter.PK_FilterIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsListenerNameNull() {
                return this.IsNull(this.tableListenerFilter.ListenerNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetListenerNameNull() {
                this[this.tableListenerFilter.ListenerNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTraceThresholdMaskNull() {
                return this.IsNull(this.tableListenerFilter.TraceThresholdMaskColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTraceThresholdMaskNull() {
                this[this.tableListenerFilter.TraceThresholdMaskColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTraceOutputOptionsNull() {
                return this.IsNull(this.tableListenerFilter.TraceOutputOptionsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTraceOutputOptionsNull() {
                this[this.tableListenerFilter.TraceOutputOptionsColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class TraceConfigurationSettingsRow : global::System.Data.DataRow {
            
            private TraceConfigurationSettingsDataTable tableTraceConfigurationSettings;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal TraceConfigurationSettingsRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableTraceConfigurationSettings = ((TraceConfigurationSettingsDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int SwitchValue {
                get {
                    try {
                        return ((int)(this[this.tableTraceConfigurationSettings.SwitchValueColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'SwitchValue\' in table \'TraceConfigurationSettings\' is DBNul" +
                                "l.", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.SwitchValueColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int UpdateInterval {
                get {
                    try {
                        return ((int)(this[this.tableTraceConfigurationSettings.UpdateIntervalColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'UpdateInterval\' in table \'TraceConfigurationSettings\' is DB" +
                                "Null.", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.UpdateIntervalColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string SwitchName {
                get {
                    try {
                        return ((string)(this[this.tableTraceConfigurationSettings.SwitchNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'SwitchName\' in table \'TraceConfigurationSettings\' is DBNull" +
                                ".", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.SwitchNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TraceOutputOptions {
                get {
                    try {
                        return ((int)(this[this.tableTraceConfigurationSettings.TraceOutputOptionsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TraceOutputOptions\' in table \'TraceConfigurationSettings\' i" +
                                "s DBNull.", e);
                    }
                }
                set {
                    this[this.tableTraceConfigurationSettings.TraceOutputOptionsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_TraceConfigSettings {
                get {
                    return ((int)(this[this.tableTraceConfigurationSettings.PK_TraceConfigSettingsColumn]));
                }
                set {
                    this[this.tableTraceConfigurationSettings.PK_TraceConfigSettingsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSwitchValueNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.SwitchValueColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSwitchValueNull() {
                this[this.tableTraceConfigurationSettings.SwitchValueColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsUpdateIntervalNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.UpdateIntervalColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetUpdateIntervalNull() {
                this[this.tableTraceConfigurationSettings.UpdateIntervalColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSwitchNameNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.SwitchNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSwitchNameNull() {
                this[this.tableTraceConfigurationSettings.SwitchNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTraceOutputOptionsNull() {
                return this.IsNull(this.tableTraceConfigurationSettings.TraceOutputOptionsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTraceOutputOptionsNull() {
                this[this.tableTraceConfigurationSettings.TraceOutputOptionsColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsXmlRow : global::System.Data.DataRow {
            
            private EventsXmlDataTable tableEventsXml;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsXmlRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEventsXml = ((EventsXmlDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int PK_Events {
                get {
                    return ((int)(this[this.tableEventsXml.PK_EventsColumn]));
                }
                set {
                    this[this.tableEventsXml.PK_EventsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string EventData {
                get {
                    try {
                        return ((string)(this[this.tableEventsXml.EventDataColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'EventData\' in table \'EventsXml\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsXml.EventDataColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int RowNumber {
                get {
                    try {
                        return ((int)(this[this.tableEventsXml.RowNumberColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'RowNumber\' in table \'EventsXml\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsXml.RowNumberColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsEventDataNull() {
                return this.IsNull(this.tableEventsXml.EventDataColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetEventDataNull() {
                this[this.tableEventsXml.EventDataColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsRowNumberNull() {
                return this.IsNull(this.tableEventsXml.RowNumberColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetRowNumberNull() {
                this[this.tableEventsXml.RowNumberColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsRow : global::System.Data.DataRow {
            
            private EventsDataTable tableEvents;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEvents = ((EventsDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int EventID {
                get {
                    return ((int)(this[this.tableEvents.EventIDColumn]));
                }
                set {
                    this[this.tableEvents.EventIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string Source {
                get {
                    try {
                        return ((string)(this[this.tableEvents.SourceColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'Source\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.SourceColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int MessageID {
                get {
                    try {
                        return ((int)(this[this.tableEvents.MessageIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MessageID\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MessageIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string Message {
                get {
                    try {
                        return ((string)(this[this.tableEvents.MessageColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'Message\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MessageColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string FileName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.FileNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'FileName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.FileNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int LineNumber {
                get {
                    try {
                        return ((int)(this[this.tableEvents.LineNumberColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'LineNumber\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.LineNumberColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MethodName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.MethodNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MethodName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.MethodNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public System.DateTime DateTime {
                get {
                    try {
                        return ((global::System.DateTime)(this[this.tableEvents.DateTimeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'DateTime\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.DateTimeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public long TimeStamp {
                get {
                    try {
                        return ((long)(this[this.tableEvents.TimeStampColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TimeStamp\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.TimeStampColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int ProcessID {
                get {
                    try {
                        return ((int)(this[this.tableEvents.ProcessIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ProcessID\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.ProcessIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ThreadID {
                get {
                    try {
                        return ((string)(this[this.tableEvents.ThreadIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ThreadID\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.ThreadIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string CallStack {
                get {
                    try {
                        return ((string)(this[this.tableEvents.CallStackColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'CallStack\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.CallStackColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string LogicalStack {
                get {
                    try {
                        return ((string)(this[this.tableEvents.LogicalStackColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'LogicalStack\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.LogicalStackColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string EventType {
                get {
                    try {
                        return ((string)(this[this.tableEvents.EventTypeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'EventType\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.EventTypeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string AssemblyName {
                get {
                    try {
                        return ((string)(this[this.tableEvents.AssemblyNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'AssemblyName\' in table \'Events\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEvents.AssemblyNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableEvents.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableEvents.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSourceNull() {
                return this.IsNull(this.tableEvents.SourceColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSourceNull() {
                this[this.tableEvents.SourceColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageIDNull() {
                return this.IsNull(this.tableEvents.MessageIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageIDNull() {
                this[this.tableEvents.MessageIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageNull() {
                return this.IsNull(this.tableEvents.MessageColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageNull() {
                this[this.tableEvents.MessageColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsFileNameNull() {
                return this.IsNull(this.tableEvents.FileNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetFileNameNull() {
                this[this.tableEvents.FileNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsLineNumberNull() {
                return this.IsNull(this.tableEvents.LineNumberColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetLineNumberNull() {
                this[this.tableEvents.LineNumberColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMethodNameNull() {
                return this.IsNull(this.tableEvents.MethodNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMethodNameNull() {
                this[this.tableEvents.MethodNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsDateTimeNull() {
                return this.IsNull(this.tableEvents.DateTimeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetDateTimeNull() {
                this[this.tableEvents.DateTimeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTimeStampNull() {
                return this.IsNull(this.tableEvents.TimeStampColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTimeStampNull() {
                this[this.tableEvents.TimeStampColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsProcessIDNull() {
                return this.IsNull(this.tableEvents.ProcessIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetProcessIDNull() {
                this[this.tableEvents.ProcessIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsThreadIDNull() {
                return this.IsNull(this.tableEvents.ThreadIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetThreadIDNull() {
                this[this.tableEvents.ThreadIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsCallStackNull() {
                return this.IsNull(this.tableEvents.CallStackColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetCallStackNull() {
                this[this.tableEvents.CallStackColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsLogicalStackNull() {
                return this.IsNull(this.tableEvents.LogicalStackColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetLogicalStackNull() {
                this[this.tableEvents.LogicalStackColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsEventTypeNull() {
                return this.IsNull(this.tableEvents.EventTypeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetEventTypeNull() {
                this[this.tableEvents.EventTypeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsAssemblyNameNull() {
                return this.IsNull(this.tableEvents.AssemblyNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetAssemblyNameNull() {
                this[this.tableEvents.AssemblyNameColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class GetSummaryEventsRow : global::System.Data.DataRow {
            
            private GetSummaryEventsDataTable tableGetSummaryEvents;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal GetSummaryEventsRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableGetSummaryEvents = ((GetSummaryEventsDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableGetSummaryEvents.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalErrors {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalErrorsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalErrors\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalErrorsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalWarnings {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalWarningsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalWarnings\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalWarningsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalCriticals {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalCriticalsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalCriticals\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalCriticalsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalInformational {
                get {
                    try {
                        return ((int)(this[this.tableGetSummaryEvents.TotalInformationalColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalInformational\' in table \'GetSummaryEvents\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableGetSummaryEvents.TotalInformationalColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableGetSummaryEvents.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableGetSummaryEvents.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalErrorsNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalErrorsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalErrorsNull() {
                this[this.tableGetSummaryEvents.TotalErrorsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalWarningsNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalWarningsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalWarningsNull() {
                this[this.tableGetSummaryEvents.TotalWarningsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalCriticalsNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalCriticalsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalCriticalsNull() {
                this[this.tableGetSummaryEvents.TotalCriticalsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalInformationalNull() {
                return this.IsNull(this.tableGetSummaryEvents.TotalInformationalColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalInformationalNull() {
                this[this.tableGetSummaryEvents.TotalInformationalColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsReportingRow : global::System.Data.DataRow {
            
            private EventsReportingDataTable tableEventsReporting;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsReportingRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEventsReporting = ((EventsReportingDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string EventType {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.EventTypeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'EventType\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.EventTypeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string AssemblyName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.AssemblyNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'AssemblyName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.AssemblyNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string SourceName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.SourceNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'SourceName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.SourceNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public System.DateTime DateTime {
                get {
                    try {
                        return ((global::System.DateTime)(this[this.tableEventsReporting.DateTimeColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'DateTime\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.DateTimeColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MethodName {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.MethodNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MethodName\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MethodNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ProcessID {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.ProcessIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ProcessID\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.ProcessIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string ThreadID {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.ThreadIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'ThreadID\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.ThreadIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string Message {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.MessageColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'Message\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MessageColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string CallStack {
                get {
                    try {
                        return ((string)(this[this.tableEventsReporting.CallStackColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'CallStack\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.CallStackColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int MessageID {
                get {
                    try {
                        return ((int)(this[this.tableEventsReporting.MessageIDColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MessageID\' in table \'EventsReporting\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsReporting.MessageIDColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsEventTypeNull() {
                return this.IsNull(this.tableEventsReporting.EventTypeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetEventTypeNull() {
                this[this.tableEventsReporting.EventTypeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableEventsReporting.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableEventsReporting.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsAssemblyNameNull() {
                return this.IsNull(this.tableEventsReporting.AssemblyNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetAssemblyNameNull() {
                this[this.tableEventsReporting.AssemblyNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsSourceNameNull() {
                return this.IsNull(this.tableEventsReporting.SourceNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetSourceNameNull() {
                this[this.tableEventsReporting.SourceNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsDateTimeNull() {
                return this.IsNull(this.tableEventsReporting.DateTimeColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetDateTimeNull() {
                this[this.tableEventsReporting.DateTimeColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMethodNameNull() {
                return this.IsNull(this.tableEventsReporting.MethodNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMethodNameNull() {
                this[this.tableEventsReporting.MethodNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsProcessIDNull() {
                return this.IsNull(this.tableEventsReporting.ProcessIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetProcessIDNull() {
                this[this.tableEventsReporting.ProcessIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsThreadIDNull() {
                return this.IsNull(this.tableEventsReporting.ThreadIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetThreadIDNull() {
                this[this.tableEventsReporting.ThreadIDColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageNull() {
                return this.IsNull(this.tableEventsReporting.MessageColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageNull() {
                this[this.tableEventsReporting.MessageColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsCallStackNull() {
                return this.IsNull(this.tableEventsReporting.CallStackColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetCallStackNull() {
                this[this.tableEventsReporting.CallStackColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMessageIDNull() {
                return this.IsNull(this.tableEventsReporting.MessageIDColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMessageIDNull() {
                this[this.tableEventsReporting.MessageIDColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Represents strongly named DataRow class.
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public partial class EventsSummaryRow : global::System.Data.DataRow {
            
            private EventsSummaryDataTable tableEventsSummary;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            internal EventsSummaryRow(global::System.Data.DataRowBuilder rb) : 
                    base(rb) {
                this.tableEventsSummary = ((EventsSummaryDataTable)(this.Table));
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public string MachineName {
                get {
                    try {
                        return ((string)(this[this.tableEventsSummary.MachineNameColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'MachineName\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.MachineNameColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalErrors {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalErrorsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalErrors\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalErrorsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalWarnings {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalWarningsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalWarnings\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalWarningsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalCriticals {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalCriticalsColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalCriticals\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalCriticalsColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public int TotalInformational {
                get {
                    try {
                        return ((int)(this[this.tableEventsSummary.TotalInformationalColumn]));
                    }
                    catch (global::System.InvalidCastException e) {
                        throw new global::System.Data.StrongTypingException("The value for column \'TotalInformational\' in table \'EventsSummary\' is DBNull.", e);
                    }
                }
                set {
                    this[this.tableEventsSummary.TotalInformationalColumn] = value;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsMachineNameNull() {
                return this.IsNull(this.tableEventsSummary.MachineNameColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetMachineNameNull() {
                this[this.tableEventsSummary.MachineNameColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalErrorsNull() {
                return this.IsNull(this.tableEventsSummary.TotalErrorsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalErrorsNull() {
                this[this.tableEventsSummary.TotalErrorsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalWarningsNull() {
                return this.IsNull(this.tableEventsSummary.TotalWarningsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalWarningsNull() {
                this[this.tableEventsSummary.TotalWarningsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalCriticalsNull() {
                return this.IsNull(this.tableEventsSummary.TotalCriticalsColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalCriticalsNull() {
                this[this.tableEventsSummary.TotalCriticalsColumn] = global::System.Convert.DBNull;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public bool IsTotalInformationalNull() {
                return this.IsNull(this.tableEventsSummary.TotalInformationalColumn);
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public void SetTotalInformationalNull() {
                this[this.tableEventsSummary.TotalInformationalColumn] = global::System.Convert.DBNull;
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class MessageIDTransformTblRowChangeEvent : global::System.EventArgs {
            
            private MessageIDTransformTblRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRowChangeEvent(MessageIDTransformTblRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public MessageIDTransformTblRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class ListenerFilterRowChangeEvent : global::System.EventArgs {
            
            private ListenerFilterRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRowChangeEvent(ListenerFilterRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public ListenerFilterRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class TraceConfigurationSettingsRowChangeEvent : global::System.EventArgs {
            
            private TraceConfigurationSettingsRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRowChangeEvent(TraceConfigurationSettingsRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public TraceConfigurationSettingsRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsXmlRowChangeEvent : global::System.EventArgs {
            
            private EventsXmlRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRowChangeEvent(EventsXmlRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsXmlRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsRowChangeEvent : global::System.EventArgs {
            
            private EventsRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRowChangeEvent(EventsRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class GetSummaryEventsRowChangeEvent : global::System.EventArgs {
            
            private GetSummaryEventsRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRowChangeEvent(GetSummaryEventsRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public GetSummaryEventsRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsReportingRowChangeEvent : global::System.EventArgs {
            
            private EventsReportingRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRowChangeEvent(EventsReportingRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsReportingRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
        
        /// <summary>
        ///Row event argument class
        ///</summary>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Data.Design.TypedDataSetGenerator", "2.0.0.0")]
        public class EventsSummaryRowChangeEvent : global::System.EventArgs {
            
            private EventsSummaryRow eventRow;
            
            private global::System.Data.DataRowAction eventAction;
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRowChangeEvent(EventsSummaryRow row, global::System.Data.DataRowAction action) {
                this.eventRow = row;
                this.eventAction = action;
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public EventsSummaryRow Row {
                get {
                    return this.eventRow;
                }
            }
            
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public global::System.Data.DataRowAction Action {
                get {
                    return this.eventAction;
                }
            }
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetFilteredEventsTable", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetFilteredEventsTableRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string fromDate;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string toDate;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string machineName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int machineOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=4)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string source;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=5)]
        public int sourceOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=6)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string eventType;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=7)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> messageId;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=8)]
        public int messageIdOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=9)]
        public int pageSize;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=10)]
        public int startRowNum;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=11)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string sortKey;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=12)]
        public bool bAscending;
        
        public GetFilteredEventsTableRequest() {
        }
        
        public GetFilteredEventsTableRequest(string fromDate, string toDate, string machineName, int machineOperator, string source, int sourceOperator, string eventType, System.Nullable<int> messageId, int messageIdOperator, int pageSize, int startRowNum, string sortKey, bool bAscending) {
            this.fromDate = fromDate;
            this.toDate = toDate;
            this.machineName = machineName;
            this.machineOperator = machineOperator;
            this.source = source;
            this.sourceOperator = sourceOperator;
            this.eventType = eventType;
            this.messageId = messageId;
            this.messageIdOperator = messageIdOperator;
            this.pageSize = pageSize;
            this.startRowNum = startRowNum;
            this.sortKey = sortKey;
            this.bAscending = bAscending;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetFilteredEventsTableResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetFilteredEventsTableResponse {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public DiagnosticDBDataSet.EventsDataTable GetFilteredEventsTableResult;
        
        public GetFilteredEventsTableResponse() {
        }
        
        public GetFilteredEventsTableResponse(DiagnosticDBDataSet.EventsDataTable GetFilteredEventsTableResult) {
            this.GetFilteredEventsTableResult = GetFilteredEventsTableResult;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetFilteredEventsRowCount", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetFilteredEventsRowCountRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string fromDate;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string toDate;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string machineName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int machineOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=4)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string Source;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=5)]
        public int sourceOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=6)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string eventType;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=7)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> messageId;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=8)]
        public int messageIdOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=9)]
        public int pageSize;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=10)]
        public int startRowNum;
        
        public GetFilteredEventsRowCountRequest() {
        }
        
        public GetFilteredEventsRowCountRequest(string fromDate, string toDate, string machineName, int machineOperator, string Source, int sourceOperator, string eventType, System.Nullable<int> messageId, int messageIdOperator, int pageSize, int startRowNum) {
            this.fromDate = fromDate;
            this.toDate = toDate;
            this.machineName = machineName;
            this.machineOperator = machineOperator;
            this.Source = Source;
            this.sourceOperator = sourceOperator;
            this.eventType = eventType;
            this.messageId = messageId;
            this.messageIdOperator = messageIdOperator;
            this.pageSize = pageSize;
            this.startRowNum = startRowNum;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetFilteredEventsRowCountResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetFilteredEventsRowCountResponse {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        public int GetFilteredEventsRowCountResult;
        
        public GetFilteredEventsRowCountResponse() {
        }
        
        public GetFilteredEventsRowCountResponse(int GetFilteredEventsRowCountResult) {
            this.GetFilteredEventsRowCountResult = GetFilteredEventsRowCountResult;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetTraceConfigurationSettings", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetTraceConfigurationSettingsRequest {
        
        public GetTraceConfigurationSettingsRequest() {
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetTraceConfigurationSettingsResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetTraceConfigurationSettingsResponse {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettingsResult;
        
        public GetTraceConfigurationSettingsResponse() {
        }
        
        public GetTraceConfigurationSettingsResponse(DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettingsResult) {
            this.GetTraceConfigurationSettingsResult = GetTraceConfigurationSettingsResult;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetSummaryDataTable", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetSummaryDataTableRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string fromDate;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string toDate;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string machineName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int machineOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=4)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string source;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=5)]
        public int sourceOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=6)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string eventType;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=7)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public System.Nullable<int> messageId;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=8)]
        public int messageIdOperator;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=9)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string sortKey;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=10)]
        public bool bAscending;
        
        public GetSummaryDataTableRequest() {
        }
        
        public GetSummaryDataTableRequest(string fromDate, string toDate, string machineName, int machineOperator, string source, int sourceOperator, string eventType, System.Nullable<int> messageId, int messageIdOperator, string sortKey, bool bAscending) {
            this.fromDate = fromDate;
            this.toDate = toDate;
            this.machineName = machineName;
            this.machineOperator = machineOperator;
            this.source = source;
            this.sourceOperator = sourceOperator;
            this.eventType = eventType;
            this.messageId = messageId;
            this.messageIdOperator = messageIdOperator;
            this.sortKey = sortKey;
            this.bAscending = bAscending;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetSummaryDataTableResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetSummaryDataTableResponse {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public DiagnosticDBDataSet.GetSummaryEventsDataTable GetSummaryDataTableResult;
        
        public GetSummaryDataTableResponse() {
        }
        
        public GetSummaryDataTableResponse(DiagnosticDBDataSet.GetSummaryEventsDataTable GetSummaryDataTableResult) {
            this.GetSummaryDataTableResult = GetSummaryDataTableResult;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="UpdateTraceConfigurationSettings", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class UpdateTraceConfigurationSettingsRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        public int switchValue;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        public int updateInterval;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string switchName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int traceOutputOptions;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=4)]
        public int PK_TraceConfigSettings;
        
        public UpdateTraceConfigurationSettingsRequest() {
        }
        
        public UpdateTraceConfigurationSettingsRequest(int switchValue, int updateInterval, string switchName, int traceOutputOptions, int PK_TraceConfigSettings) {
            this.switchValue = switchValue;
            this.updateInterval = updateInterval;
            this.switchName = switchName;
            this.traceOutputOptions = traceOutputOptions;
            this.PK_TraceConfigSettings = PK_TraceConfigSettings;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="UpdateTraceConfigurationSettingsResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class UpdateTraceConfigurationSettingsResponse {
        
        public UpdateTraceConfigurationSettingsResponse() {
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetListenerConfigurationTable", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetListenerConfigurationTableRequest {
        
        public GetListenerConfigurationTableRequest() {
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="GetListenerConfigurationTableResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class GetListenerConfigurationTableResponse {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTableResult;
        
        public GetListenerConfigurationTableResponse() {
        }
        
        public GetListenerConfigurationTableResponse(DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTableResult) {
            this.GetListenerConfigurationTableResult = GetListenerConfigurationTableResult;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="UpdateListenerConfigurationTable", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class UpdateListenerConfigurationTableRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string ListenerName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        public int TraceThresholdMask;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        public int TraceOutputOptions;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int PK_FilterID;
        
        public UpdateListenerConfigurationTableRequest() {
        }
        
        public UpdateListenerConfigurationTableRequest(string ListenerName, int TraceThresholdMask, int TraceOutputOptions, int PK_FilterID) {
            this.ListenerName = ListenerName;
            this.TraceThresholdMask = TraceThresholdMask;
            this.TraceOutputOptions = TraceOutputOptions;
            this.PK_FilterID = PK_FilterID;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="UpdateListenerConfigurationTableResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class UpdateListenerConfigurationTableResponse {
        
        public UpdateListenerConfigurationTableResponse() {
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="InsertListenerConfigurationTable", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class InsertListenerConfigurationTableRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string ListenerName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        public int TraceThreshold;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        public int TraceOutputOptions;
        
        public InsertListenerConfigurationTableRequest() {
        }
        
        public InsertListenerConfigurationTableRequest(string ListenerName, int TraceThreshold, int TraceOutputOptions) {
            this.ListenerName = ListenerName;
            this.TraceThreshold = TraceThreshold;
            this.TraceOutputOptions = TraceOutputOptions;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="InsertListenerConfigurationTableResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class InsertListenerConfigurationTableResponse {
        
        public InsertListenerConfigurationTableResponse() {
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="InsertTraceConfigurationSettings", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class InsertTraceConfigurationSettingsRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        public int switchValue;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        public int updateInterval;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string switchName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int traceOutputOptions;
        
        public InsertTraceConfigurationSettingsRequest() {
        }
        
        public InsertTraceConfigurationSettingsRequest(int switchValue, int updateInterval, string switchName, int traceOutputOptions) {
            this.switchValue = switchValue;
            this.updateInterval = updateInterval;
            this.switchName = switchName;
            this.traceOutputOptions = traceOutputOptions;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="InsertTraceConfigurationSettingsResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class InsertTraceConfigurationSettingsResponse {
        
        public InsertTraceConfigurationSettingsResponse() {
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="DeleteTraceConfigurationSettings", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class DeleteTraceConfigurationSettingsRequest {
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=0)]
        public int switchValue;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=1)]
        public int updateInterval;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=2)]
        [System.Xml.Serialization.XmlElementAttribute(IsNullable=true)]
        public string switchName;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=3)]
        public int traceOutputOptions;
        
        [System.ServiceModel.MessageBodyMemberAttribute(Namespace="http://tempuri.org/", Order=4)]
        public int PK_TraceConfigurationSettings;
        
        public DeleteTraceConfigurationSettingsRequest() {
        }
        
        public DeleteTraceConfigurationSettingsRequest(int switchValue, int updateInterval, string switchName, int traceOutputOptions, int PK_TraceConfigurationSettings) {
            this.switchValue = switchValue;
            this.updateInterval = updateInterval;
            this.switchName = switchName;
            this.traceOutputOptions = traceOutputOptions;
            this.PK_TraceConfigurationSettings = PK_TraceConfigurationSettings;
        }
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    [System.ServiceModel.MessageContractAttribute(WrapperName="DeleteTraceConfigurationSettingsResponse", WrapperNamespace="http://tempuri.org/", IsWrapped=true)]
    public partial class DeleteTraceConfigurationSettingsResponse {
        
        public DeleteTraceConfigurationSettingsResponse() {
        }
    }
    
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public interface IWgxMonitoringServiceChannel : WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService, System.ServiceModel.IClientChannel {
    }
    
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel", "3.0.0.0")]
    public partial class WgxMonitoringServiceClient : System.ServiceModel.ClientBase<WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService>, WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService {
        
        public WgxMonitoringServiceClient() {
        }
        
        public WgxMonitoringServiceClient(string endpointConfigurationName) : 
                base(endpointConfigurationName) {
        }
        
        public WgxMonitoringServiceClient(string endpointConfigurationName, string remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public WgxMonitoringServiceClient(string endpointConfigurationName, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(endpointConfigurationName, remoteAddress) {
        }
        
        public WgxMonitoringServiceClient(System.ServiceModel.Channels.Binding binding, System.ServiceModel.EndpointAddress remoteAddress) : 
                base(binding, remoteAddress) {
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.GetFilteredEventsTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableRequest request) {
            return base.Channel.GetFilteredEventsTable(request);
        }
        
        public DiagnosticDBDataSet.EventsDataTable GetFilteredEventsTable(string fromDate, string toDate, string machineName, int machineOperator, string source, int sourceOperator, string eventType, System.Nullable<int> messageId, int messageIdOperator, int pageSize, int startRowNum, string sortKey, bool bAscending) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableRequest();
            inValue.fromDate = fromDate;
            inValue.toDate = toDate;
            inValue.machineName = machineName;
            inValue.machineOperator = machineOperator;
            inValue.source = source;
            inValue.sourceOperator = sourceOperator;
            inValue.eventType = eventType;
            inValue.messageId = messageId;
            inValue.messageIdOperator = messageIdOperator;
            inValue.pageSize = pageSize;
            inValue.startRowNum = startRowNum;
            inValue.sortKey = sortKey;
            inValue.bAscending = bAscending;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsTableResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).GetFilteredEventsTable(inValue);
            return retVal.GetFilteredEventsTableResult;
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.GetFilteredEventsRowCount(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountRequest request) {
            return base.Channel.GetFilteredEventsRowCount(request);
        }
        
        public int GetFilteredEventsRowCount(string fromDate, string toDate, string machineName, int machineOperator, string Source, int sourceOperator, string eventType, System.Nullable<int> messageId, int messageIdOperator, int pageSize, int startRowNum) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountRequest();
            inValue.fromDate = fromDate;
            inValue.toDate = toDate;
            inValue.machineName = machineName;
            inValue.machineOperator = machineOperator;
            inValue.Source = Source;
            inValue.sourceOperator = sourceOperator;
            inValue.eventType = eventType;
            inValue.messageId = messageId;
            inValue.messageIdOperator = messageIdOperator;
            inValue.pageSize = pageSize;
            inValue.startRowNum = startRowNum;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetFilteredEventsRowCountResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).GetFilteredEventsRowCount(inValue);
            return retVal.GetFilteredEventsRowCountResult;
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.GetTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsRequest request) {
            return base.Channel.GetTraceConfigurationSettings(request);
        }
        
        public DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettings() {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsRequest();
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetTraceConfigurationSettingsResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).GetTraceConfigurationSettings(inValue);
            return retVal.GetTraceConfigurationSettingsResult;
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.GetSummaryDataTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableRequest request) {
            return base.Channel.GetSummaryDataTable(request);
        }
        
        public DiagnosticDBDataSet.GetSummaryEventsDataTable GetSummaryDataTable(string fromDate, string toDate, string machineName, int machineOperator, string source, int sourceOperator, string eventType, System.Nullable<int> messageId, int messageIdOperator, string sortKey, bool bAscending) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableRequest();
            inValue.fromDate = fromDate;
            inValue.toDate = toDate;
            inValue.machineName = machineName;
            inValue.machineOperator = machineOperator;
            inValue.source = source;
            inValue.sourceOperator = sourceOperator;
            inValue.eventType = eventType;
            inValue.messageId = messageId;
            inValue.messageIdOperator = messageIdOperator;
            inValue.sortKey = sortKey;
            inValue.bAscending = bAscending;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetSummaryDataTableResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).GetSummaryDataTable(inValue);
            return retVal.GetSummaryDataTableResult;
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.UpdateTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsRequest request) {
            return base.Channel.UpdateTraceConfigurationSettings(request);
        }
        
        public void UpdateTraceConfigurationSettings(int switchValue, int updateInterval, string switchName, int traceOutputOptions, int PK_TraceConfigSettings) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsRequest();
            inValue.switchValue = switchValue;
            inValue.updateInterval = updateInterval;
            inValue.switchName = switchName;
            inValue.traceOutputOptions = traceOutputOptions;
            inValue.PK_TraceConfigSettings = PK_TraceConfigSettings;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateTraceConfigurationSettingsResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).UpdateTraceConfigurationSettings(inValue);
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.GetListenerConfigurationTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableRequest request) {
            return base.Channel.GetListenerConfigurationTable(request);
        }
        
        public DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTable() {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableRequest();
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.GetListenerConfigurationTableResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).GetListenerConfigurationTable(inValue);
            return retVal.GetListenerConfigurationTableResult;
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.UpdateListenerConfigurationTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableRequest request) {
            return base.Channel.UpdateListenerConfigurationTable(request);
        }
        
        public void UpdateListenerConfigurationTable(string ListenerName, int TraceThresholdMask, int TraceOutputOptions, int PK_FilterID) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableRequest();
            inValue.ListenerName = ListenerName;
            inValue.TraceThresholdMask = TraceThresholdMask;
            inValue.TraceOutputOptions = TraceOutputOptions;
            inValue.PK_FilterID = PK_FilterID;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.UpdateListenerConfigurationTableResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).UpdateListenerConfigurationTable(inValue);
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.InsertListenerConfigurationTable(WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableRequest request) {
            return base.Channel.InsertListenerConfigurationTable(request);
        }
        
        public void InsertListenerConfigurationTable(string ListenerName, int TraceThreshold, int TraceOutputOptions) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableRequest();
            inValue.ListenerName = ListenerName;
            inValue.TraceThreshold = TraceThreshold;
            inValue.TraceOutputOptions = TraceOutputOptions;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertListenerConfigurationTableResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).InsertListenerConfigurationTable(inValue);
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.InsertTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsRequest request) {
            return base.Channel.InsertTraceConfigurationSettings(request);
        }
        
        public void InsertTraceConfigurationSettings(int switchValue, int updateInterval, string switchName, int traceOutputOptions) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsRequest();
            inValue.switchValue = switchValue;
            inValue.updateInterval = updateInterval;
            inValue.switchName = switchName;
            inValue.traceOutputOptions = traceOutputOptions;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.InsertTraceConfigurationSettingsResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).InsertTraceConfigurationSettings(inValue);
        }
        
        [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]
        WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsResponse WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService.DeleteTraceConfigurationSettings(WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsRequest request) {
            return base.Channel.DeleteTraceConfigurationSettings(request);
        }
        
        public void DeleteTraceConfigurationSettings(int switchValue, int updateInterval, string switchName, int traceOutputOptions, int PK_TraceConfigurationSettings) {
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsRequest inValue = new WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsRequest();
            inValue.switchValue = switchValue;
            inValue.updateInterval = updateInterval;
            inValue.switchName = switchName;
            inValue.traceOutputOptions = traceOutputOptions;
            inValue.PK_TraceConfigurationSettings = PK_TraceConfigurationSettings;
            WgxMonitoringConsoleWebApp.WgxWebConsoleService.DeleteTraceConfigurationSettingsResponse retVal = ((WgxMonitoringConsoleWebApp.WgxWebConsoleService.IWgxMonitoringService)(this)).DeleteTraceConfigurationSettings(inValue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\Exceptions.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Runtime.Serialization;

    [Serializable]
    public class InvalidPerformanceCounterException : Exception
    {
        public InvalidPerformanceCounterException()
        {
        }

        public InvalidPerformanceCounterException(string message)
            : base(message)
        {
        }

        public InvalidPerformanceCounterException(string message, Exception inner)
            : base(message, inner)
        {
        }

        protected InvalidPerformanceCounterException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }

    [Serializable]
    public class TraceSourceGeneralException : Exception
    {
        public TraceSourceGeneralException() 
        {
        }

        public TraceSourceGeneralException(string message, Exception inner)
            : base(message, inner)
        {
        }

        public TraceSourceGeneralException(string message)
            : base(message)
        {
        }

        protected TraceSourceGeneralException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\GlobalSuppressions.cs ===
// This file is used by Code Analysis to maintain SuppressMessage 
// attributes that are applied to this project. 
// Project-level suppressions either have no target or are given 
// a specific target and scoped to a namespace, type, member, etc. 
//
// To add a suppression to this file, right-click the message in the 
// Error List, point to "Suppress Message(s)", and click 
// "In Project Suppression File". 
// You do not need to add suppressions to this file manually. 

[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "namespace", Target = "Wgx.Services.Monitoring")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA2210:AssembliesShouldHaveValidStrongNames")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1014:MarkAssembliesWithClsCompliant")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Scope = "member", Target = "Wgx.Services.Monitoring.PerformanceCounters.#GetPerformanceCounters(System.Type,System.Object,System.String)")]
[assembly: System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Wgx", Scope = "type", Target = "Wgx.Services.Monitoring.WgxTraceSource")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\IWGXSourceSwitch.cs ===
using System;
using System.Diagnostics;

namespace Wgx.Services.Monitoring
{
    [Flags]
    public enum TraceOptionsEx
    {
        None = 0,
        LogicalOperationStack = 1,
        DateTime = 2,
        Timestamp = 4,
        ProcessId = 8,
        ThreadId = 16,
        Callstack = 32,
        FileName = 64,
        LineNumber = 128,
        MethodName = 256
    }

    public interface IWgxSourceSwitch
    {
        bool ShouldTrace(int messageID, ref TraceEventType eventType);
        void Initialize();
        TraceOptionsEx TraceOptions
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\PerfCategory.cs ===
using System.Diagnostics;
namespace Wgx.Services.Monitoring
{
    using System;

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    public sealed class PerformanceCategoryAttribute : Attribute
    {
        PerformanceCounterCategoryType categoryType = PerformanceCounterCategoryType.MultiInstance;
        public PerformanceCategoryAttribute()
        {
        }

        public string CategoryDescription
        {
            get;
            set;
        }

        public string CategoryName
        {
            get;
            set;
        }

        public PerformanceCounterCategoryType CategoryType
        {
            get { return categoryType; }
            set { categoryType = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\events.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Reflection;

    public class EventsCollection : IEnumerable<EventAttribute>, IEnumerator<EventAttribute>
    {
        private EventAttribute[] events;
        private WgxTraceSource ts;

        public EventsCollection(WgxTraceSource traceSource, Type classType, object classInstance)
        {
            this.ts = traceSource;
            this.Initialize(classType, classInstance);
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, TraceEventType eventType)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                eventAttrib.TraceEventType = eventType;
                this.InternalTraceEvent(eventAttrib, string.Empty, null);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                this.InternalTraceEvent(eventAttrib, string.Empty, null);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, TraceEventType eventType, params object[] args)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                eventAttrib.TraceEventType = eventType;
                this.InternalTraceEvent(eventAttrib, string.Empty, args);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, params object[] args)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                this.InternalTraceEvent(eventAttrib, string.Empty, args);
            }
        }

        [Conditional("TRACE")]
        public void TraceEvent(int eventId, string optionalMessage, params object[] args)
        {
            EventAttribute eventAttrib = this.GetEventAttribute(eventId);
            if (eventAttrib != null)
            {
                this.InternalTraceEvent(eventAttrib, optionalMessage, args);
            }
        }

        #region IEnumerable Members

        public IEnumerator GetEnumerator()
        {
            return this.events.GetEnumerator();
        }

        #endregion

        #region IEnumerator Members

        public object Current
        {
            get { return this.events.GetEnumerator().Current; }
        }

        public bool MoveNext()
        {
            return this.events.GetEnumerator().MoveNext();
        }

        public void Reset()
        {
            this.events.GetEnumerator().Reset();
        }

        /// <summary>
        /// This method formats the message of a given event id based
        /// on the arguments
        /// </summary>
        /// <param name="eventIndex">Event index.</param>
        /// <param name="args">Argument strings.</param>
        /// <returns>Formatted messages.</returns>
        public string FormatMessage(int eventIndex, params string[] args)
        {
            string msg;
            EventAttribute attribute = GetEventAttribute(eventIndex);

            if (attribute == null)
            {
                return string.Empty;
            }

            if (args == null)
            {
                msg = attribute.Message;
            }
            else
            {
                msg = string.Format(attribute.Message, args);
            }

            return msg;
        }

        /// <summary>
        /// This method returns the error code associated with an event. 
        /// </summary>
        /// <param name="eventIndex">Event Index</param>
        /// <returns>Error Code</returns>
        public uint GetErrorCode(int eventIndex)
        {
            EventAttribute attribute = GetEventAttribute(eventIndex);
            uint id = ((uint)attribute.Facility << 16 & 0x0FFF0000) | (0x0000FFFF & (uint)attribute.MessageId);
            if (attribute.Error)
            {
                id = 0x80000000 | id;
            }

            return id;
        }

        /// <summary>
        /// This method returns the real event Id associated
        /// with an event
        /// </summary>
        /// <param name="eventIndex">Event index.</param>
        /// <returns>Event Id.</returns>
        public int GetEventId(int eventIndex)
        {
            EventAttribute attribute = GetEventAttribute(eventIndex);
            return attribute.MessageId;
        }

        #endregion

        #region IEnumerable<EventAttribute> Members

        IEnumerator<EventAttribute> IEnumerable<EventAttribute>.GetEnumerator()
        {
            return ((IEnumerable<EventAttribute>)events.GetEnumerator()).GetEnumerator();
        }

        #endregion

        #region IEnumerator<EventAttribute> Members

        EventAttribute IEnumerator<EventAttribute>.Current
        {
            get { return ((IEnumerator<EventAttribute>)events.GetEnumerator()).Current; }
        }

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Internal method to implement trace event
        /// </summary>
        /// <param name="eventAttrib">Event attribute</param>
        /// <param name="args">Argument strings</param>
        /// <param name="optionalMessage">An optional message to append. Used for
        /// InnerException which may not be included in the message string
        /// </param>
        protected void InternalTraceEvent(EventAttribute eventAttrib, string optionalMessage, object[] args)
        {
            TraceEventType eventType = eventAttrib.TraceEventType;

            if (this.ts.ShouldTrace(eventAttrib.MessageId, ref eventType))
            {
                StackFrame sf = ts.GetStackFrame();
                try
                {
                    string msg = args == null ? eventAttrib.Message : string.Format(eventAttrib.Message, args);

                    // Append the optional message to the end.
                    // Mostly used by innerException.
                    // There are two use cases of the events defined in events class
                    //   1. Used to generate error details to send outside of service 
                    //      boundary, for example in HTTP response.
                    //   2. Used to generate event log entry which should include as
                    //      much information as possible.
                    // In former case, Inner exception should not not sent outside of 
                    // service boundary, thus the message defined in the Events class 
                    // should not include it by default. The optionalMessage let the
                    // consumer of this class to provide innerException information
                    // when creating internal event log entries.
                    msg = msg + optionalMessage;

                    string xmlEvent = this.ts.PopulateEventSchema(sf, eventType, eventAttrib.MessageId, this.ts.InternalTraceSource.Name, msg);
                    this.ts.InternalTraceSource.TraceEvent(eventType, eventAttrib.MessageId, xmlEvent);
                }
                catch (System.FormatException ex)
                {
                    Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to trace message for event ID {0}", eventAttrib.MessageId), EventLogEntryType.Warning, 1089, ex);
                }
                catch (System.ArgumentNullException ex)
                {
                    Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to trace message for event ID {0}", eventAttrib.MessageId), EventLogEntryType.Warning, 1090, ex);
                }
            }
        }

        protected EventAttribute GetEventAttribute(int eventIndex)
        {
            EventAttribute eventAttrib = null;
            if (this.events == null)
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Events collection has not been initialized"), EventLogEntryType.Warning, 1079, new TraceSourceGeneralException("EventsCollection Initialize() method has not been called"));
            }

            if (this.events.Length > eventIndex)
            {
                eventAttrib = this.events[eventIndex];
            }
            else
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Event index out of array bounds for eventID {0}", eventIndex), EventLogEntryType.Warning, 1073, new TraceSourceGeneralException("Event index exceeds collection size"));
            }

            return eventAttrib;
        }

        protected void Initialize(Type classType, object classInstance)
        {
            int count = 0;
            int baseCounter = 0;
            int incrementAmount = 10;
            {
                if (classType.IsClass)
                {
                    EventCategoryAttribute eventCatattrib = (EventCategoryAttribute)Attribute.GetCustomAttribute(classType, typeof(EventCategoryAttribute));

                    // is there a event category attribute defined for this class?
                    if (eventCatattrib != null)
                    {
                        baseCounter = eventCatattrib.MessageIdBase;
                        incrementAmount = eventCatattrib.IncrementAmount;
                    }
                    else
                    {
                        baseCounter = 0;
                    }

                    System.Reflection.FieldInfo[] fieldInfos = classType.GetFields();       // obtain field meta data (public fields can act as perf counters)
                    foreach (FieldInfo fieldInfo in fieldInfos)
                    {
                        EventAttribute[] attributes = (EventAttribute[])fieldInfo.GetCustomAttributes(typeof(EventAttribute), true);
                        if (this.events != null)
                        {
                            Array.Resize<EventAttribute>(ref this.events, this.events.Length + attributes.Length);
                        }
                        else
                        {
                            Array.Resize<EventAttribute>(ref this.events, attributes.Length);
                        }

                        foreach (EventAttribute eventAttrib in attributes)
                        {
                            if (eventAttrib.MessageId == -1)
                            {
                                eventAttrib.MessageId = baseCounter;
                                baseCounter += incrementAmount;
                            }

                            try
                            {
                                // set value appropriately
                                fieldInfo.SetValue(classInstance, count);

                                // load resource manager                                
                                if (eventAttrib.ResourceId != -1)
                                {
                                    // TO DO
                                    // Add support for resource Id's
                                }

                                this.events[count++] = eventAttrib;
                            }
                            catch (FieldAccessException ex)
                            {
                                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to access field {0} event for  event ID {1}", fieldInfo.Name, eventAttrib.MessageId), EventLogEntryType.Warning, 1089, ex);
                            }
                            catch (System.Reflection.TargetException ex)
                            {
                                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to access field {0} event for  event ID {1}", fieldInfo.Name, eventAttrib.MessageId), EventLogEntryType.Warning, 1089, ex);
                            }
                            catch (ArgumentException ex)
                            {
                                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to access field {0} event for  event ID {1}", fieldInfo.Name, eventAttrib.MessageId), EventLogEntryType.Warning, 1089, ex);
                            }
                        }
                    }
                }
            }
        }

        protected virtual void Dispose(bool disposing)
        {
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\PerfCounterAttribute.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Diagnostics;

    public enum PerformanceCounterUpdateMethod
    {
        UpdateRawData = 0,
        UpdateIncrementBy = 1,
        UpdateIncrement = 2,
        UpdateDecrement = 3
    }

    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
    public sealed class PerformanceCounterAttribute : Attribute
    {        
        private string counterDescription;
        private string counterName;
        private string basePropertyName;
        private PerformanceCounterType performanceCounterType = PerformanceCounterType.NumberOfItems32;

        public PerformanceCounterAttribute()
        {
        }

        public PerformanceCounterType CounterType
        {
            get { return this.performanceCounterType; }
            set { this.performanceCounterType = value; }
        }

        public string CounterName
        {
            get 
            { 
                return this.counterName; 
            }

            set 
            { 
                this.counterName = value; 
            }
        }

        public string CounterDescription
        {
            get { return this.counterDescription; }
            set { this.counterDescription = value; }
        }

        public string BasePropertyName
        {
            get { return this.basePropertyName; }
            set { this.basePropertyName = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\performancecounters.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.Serialization;

    [Serializable]
    public class MemberInfoToPerformanceCounterAttributeDictionary : Dictionary<MemberInfo, PerformanceCounterAttribute>
    {
        public MemberInfoToPerformanceCounterAttributeDictionary() : base() 
        {
        }

        protected MemberInfoToPerformanceCounterAttributeDictionary(SerializationInfo info, StreamingContext context) : base(info, context) 
        {
        }
    }

    public static class PerformanceCounters
    {
        private static object critSec = new object();
        #region Dictionaries
        private static Dictionary<string, CounterNameToPerformanceCounterDictionary> perfCounterMap = new Dictionary<string, CounterNameToPerformanceCounterDictionary>();
        private static Dictionary<Type, PropertyNameToMemberInfoDictionary> memberInfoMap = new Dictionary<Type, PropertyNameToMemberInfoDictionary>();
        private static Dictionary<string, CounterNameToPerformanceCounterAttributeDictionary> counterNameToPerformanceAttributeMap = new Dictionary<string, CounterNameToPerformanceCounterAttributeDictionary>();
        private static Dictionary<string, MemberInfoToPerformanceCounterAttributeDictionary> propertyAttributeMap = new Dictionary<string, MemberInfoToPerformanceCounterAttributeDictionary>();
        private static Dictionary<Type, PerformanceCategoryAttribute> categoryAttributeMap = new Dictionary<Type, PerformanceCategoryAttribute>();
        #endregion

        #region external performance counter implementation
        public static Dictionary<string, MemberInfoToPerformanceCounterAttributeDictionary> GetAttributes(Assembly asm)
        {
            #region clear all dictionary collections
            memberInfoMap.Clear();
            propertyAttributeMap.Clear();
            categoryAttributeMap.Clear();
            counterNameToPerformanceAttributeMap.Clear();
            #endregion
            #region collecting performance attributes
            Type[] types = asm.GetTypes();
            foreach (Type nestedType in types)
            {
                GetMemberInfo(nestedType);
            }

            #endregion collecting custom attributes
            return propertyAttributeMap;
        }

        public static string GetPerformanceCategoryName(Type classType)
        {
            if (categoryAttributeMap.ContainsKey(classType) && string.IsNullOrEmpty(categoryAttributeMap[classType].CategoryName) == false)
            {
                return categoryAttributeMap[classType].CategoryName;
            }
            else
            {
                return classType.FullName;
            }
        }

        public static string GetPerformanceCategoryDescription(Type classType)
        {
            if (categoryAttributeMap.ContainsKey(classType) && string.IsNullOrEmpty(categoryAttributeMap[classType].CategoryDescription) == false)
            {
                return categoryAttributeMap[classType].CategoryDescription;
            }
            else
            {
                return classType.FullName;
            }
        }

        public static PerformanceCounterCategoryType GetPerformanceCategoryType(Type classType)
        {
            if (categoryAttributeMap.ContainsKey(classType))
            {
                return categoryAttributeMap[classType].CategoryType;
            }
            else
            {
                return PerformanceCounterCategoryType.MultiInstance;
            }
        }

        public static PerformanceCounterCollection GetPerformanceCounters(object classInstance, string instanceName)
        {
            if (classInstance != null)
            {
                return GetPerformanceCounters(classInstance.GetType(), classInstance, instanceName);
            }
            else
            {
                throw new TraceSourceGeneralException("The class instance for the performance counters collection was null, use type overloaded method instead");
            }
        }

        public static PerformanceCounterCollection GetPerformanceCounters(Type classType, string instanceName)
        {
            return GetPerformanceCounters(classType, null, instanceName);
        }

        public static PerformanceCounterCollection GetPerformanceCounters(object classInstance)
        {
            if (classInstance != null)
            {
                return GetPerformanceCounters(classInstance.GetType(), classInstance, null);
            }
            else
            {
                throw new TraceSourceGeneralException("The class instance for the performance counters collection was null, use type overloaded method instead");
            }
        }

        public static PerformanceCounterCollection GetPerformanceCounters(Type classType)
        {
            return GetPerformanceCounters(classType, null, null);
        }
        #endregion
        #region internal performance counter implementation
        internal static PerformanceCounterCollection GetPerformanceCounters(Type classType, object classInstance, string instanceName)
        {
            PerformanceCounterCollection perfCollection = new PerformanceCounterCollection();
            if (!memberInfoMap.ContainsKey(classType))
            {
                GetMemberInfo(classType);
            }

            if (memberInfoMap.ContainsKey(classType))
            {
                string categoryName = GetPerformanceCategoryName(classType);
                PropertyNameToMemberInfoDictionary memInfoDictionary = memberInfoMap[classType];
                List<PerformanceCounter> perfCounterArray = new List<PerformanceCounter>();
                int index = 0;
                foreach (string counterName in memInfoDictionary.Keys)
                {
                    MemberInfo memInfo = memInfoDictionary[counterName];
                    PerformanceCounter perfCounter = GetPerCounterInstance(categoryName, counterName, instanceName);
                    perfCounterArray.Add(perfCounter);
                    try
                    {
                        if (memInfo is PropertyInfo)
                        {
                            MethodInfo setMethod = (memInfo as PropertyInfo).GetSetMethod(true);
                            if (setMethod != null)
                            {
                                setMethod.Invoke(classInstance, new object[] { index });
                            }
                        }
                        else if (memInfo is FieldInfo)
                        {
                            (memInfo as FieldInfo).SetValue(classInstance, index);
                        }
                    }
                    catch (System.Security.SecurityException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1091, ex);
                    }
                    catch (System.Reflection.TargetException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1092, ex);
                    }
                    catch (System.ArgumentException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1093, ex);
                    }
                    catch (System.Reflection.TargetInvocationException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1094, ex);
                    }
                    catch (System.Reflection.TargetParameterCountException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1095, ex);
                    }
                    catch (System.MethodAccessException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1096, ex);
                    }
                    catch (System.InvalidOperationException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1097, ex);
                    }
                    catch (System.FieldAccessException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Unable to set performance counter index for counter {0}, category {1}", counterName, categoryName), EventLogEntryType.Warning, 1098, ex);
                    }

                    index++;
                }

                perfCollection.counters = perfCounterArray.ToArray();
            }

            return perfCollection;
        }

        internal static void GetMemberInfo(Type classType)
        {
            if (classType.IsClass) // only interested if declaring type is a Class type
            {
                string CategoryName = GetPerformanceCategoryName(classType);
                if (!memberInfoMap.ContainsKey(classType))
                {
                    memberInfoMap.Add(classType, new PropertyNameToMemberInfoDictionary());
                }

                object attrib = Attribute.GetCustomAttribute(classType, typeof(PerformanceCategoryAttribute));

                if (attrib != null) // is there a performance category attribute defined for this class?
                {
                    PerformanceCategoryAttribute catAttrib = attrib as PerformanceCategoryAttribute;
                    if (!categoryAttributeMap.ContainsKey(classType))
                    {
                        categoryAttributeMap.Add(classType, catAttrib);
                    }

                    CategoryName = GetPerformanceCategoryName(classType);
                }

                System.Reflection.PropertyInfo[] propInfos = classType.GetProperties(); // obtain property meta data
                System.Reflection.MethodInfo[] methodInfos = classType.GetMethods();    // obtain method meta data (not used currently)
                System.Reflection.FieldInfo[] fieldInfos = classType.GetFields();       // obtain field meta data (public fields can act as perf counters)

                // create a new category to hold the perfcounter attributes for this category
                if (!propertyAttributeMap.ContainsKey(CategoryName))
                {
                    propertyAttributeMap.Add(CategoryName, new MemberInfoToPerformanceCounterAttributeDictionary());
                }

                if (!counterNameToPerformanceAttributeMap.ContainsKey(CategoryName))
                {
                    counterNameToPerformanceAttributeMap.Add(CategoryName, new CounterNameToPerformanceCounterAttributeDictionary());
                }

                // get the attributes
                AddMemberInfo(memberInfoMap[classType], CategoryName, propInfos);
                AddMemberInfo(memberInfoMap[classType], CategoryName, methodInfos);
                AddMemberInfo(memberInfoMap[classType], CategoryName, fieldInfos);
            }
        }

        internal static void AddMemberInfo(Dictionary<string, System.Reflection.MemberInfo> propertyDictionary, string categoryName, System.Reflection.MemberInfo[] memberInfoCollection)
        {
            foreach (System.Reflection.MemberInfo memberInfo in memberInfoCollection)
            {
                object[] attributes = memberInfo.GetCustomAttributes(typeof(PerformanceCounterAttribute), true);

                // only add memberInfo if it is attributed (current implementation)
                if (attributes.Length > 0)
                {
                    // check to see if the member is attributed
                    foreach (object attr in attributes)
                    {
                        if (attr.GetType() == typeof(PerformanceCounterAttribute))
                        {
                            PerformanceCounterAttribute perfAttr = attr as PerformanceCounterAttribute;
                            if (memberInfo is System.Reflection.PropertyInfo || memberInfo is System.Reflection.FieldInfo)
                            {
                                // has the user defined a counter name?
                                if (string.IsNullOrEmpty(perfAttr.CounterName))
                                {
                                    // if not use the property name as the default counter name
                                    perfAttr.CounterName = memberInfo.Name;
                                }

                                // has the user defined a counter description?
                                if (string.IsNullOrEmpty(perfAttr.CounterDescription))
                                {
                                    // if not use the counter name as default
                                    perfAttr.CounterDescription = perfAttr.CounterName;
                                }

                                if (!propertyDictionary.ContainsKey(perfAttr.CounterName))
                                {
                                    propertyDictionary.Add(perfAttr.CounterName, memberInfo);
                                }

                                propertyAttributeMap[categoryName].Add(memberInfo, perfAttr);
                                counterNameToPerformanceAttributeMap[categoryName].Add(perfAttr.CounterName, perfAttr);
                            }
                        }
                    }
                }
            }
        }

        internal static string CounterInstanceName(string counterName, string instanceName)
        {
            if (instanceName != null)
                return counterName + "." + instanceName;
            else
                return counterName;
        }

        internal static PerformanceCounter GetPerCounterInstance(string categoryName, string counterName, string instanceName)
        {
            PerformanceCounter counterInstance;
            string key = CounterInstanceName(counterName, instanceName);
            #region obtain performance counter using lazy loading
            {
                if (!perfCounterMap.ContainsKey(categoryName))
                {
                    lock (critSec)
                    {
                        // 2nd check
                        if (!perfCounterMap.ContainsKey(categoryName))
                        {
                            perfCounterMap.Add(categoryName, new CounterNameToPerformanceCounterDictionary());
                        }
                    }
                }
            }

            if (!perfCounterMap[categoryName].TryGetValue(key, out counterInstance))
            {
                // create the perf counter instance
                lock (critSec)
                {
                    // 2nd check
                    if (!perfCounterMap[categoryName].ContainsKey(key))
                    {
                        try
                        {
                            if (instanceName != null)
                            {
                                counterInstance = new PerformanceCounter(categoryName, counterName, instanceName, false);
                            }
                            else
                            {
                                counterInstance = new PerformanceCounter(categoryName, counterName, false);
                            }

                            perfCounterMap[categoryName].Add(key, counterInstance);
                        }
                        catch (ArgumentNullException ex)
                        {
                            WgxTraceSource.WriteEventLog(string.Format("Error updating performance counter {0}, instance name {1}, categoryName {2}", counterName, instanceName, categoryName), EventLogEntryType.Error, 1003, ex);
                        }
                        catch (ArgumentException ex)
                        {
                            WgxTraceSource.WriteEventLog(string.Format("Error updating performance counter {0}, instance name {1}, categoryName {2}", counterName, instanceName, categoryName), EventLogEntryType.Error, 1003, ex);
                        }
                    }
                }
            }

            #endregion
            return counterInstance;
        }
        #endregion // internal representation
    }

    public class PerformanceCounterCollection : IEnumerator, IEnumerable, IEnumerator<PerformanceCounter>, IEnumerable<PerformanceCounter>
    {
        internal PerformanceCounter[] counters;


        public void SafeIncrement(int index)
        {
            if (this.counters != null)
            {
                if (index >= 0 && index < this.counters.Length)
                {
                    try
                    {
                        if (this.counters != null)
                        {
                            this.counters[index].Increment();
                        }
                    }
                    catch (InvalidOperationException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}, category {1}", this.counters[index].CounterName, this.counters[index].CategoryName), EventLogEntryType.Error, 1057, ex);
                    }
                    catch (System.ComponentModel.Win32Exception ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}, category{1}", this.counters[index].CounterName, this.counters[index].CategoryName), EventLogEntryType.Error, 1057, ex);
                    }
                }
            }
            else
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog("Performance counters not intialized", EventLogEntryType.Warning, 1037, new TraceSourceGeneralException("Performance counters not initialized"));
            }
        }

        public void SafeDecrement(int index)
        {
            if (this.counters != null)
            {
                if (index >= 0 && index < this.counters.Length)
                {
                    try
                    {
                        this.counters[index].Decrement();
                    }
                    catch (InvalidOperationException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}, category {1}", this.counters[index].CounterName, this.counters[index].CategoryName), EventLogEntryType.Warning, 1057, ex);
                    }
                    catch (System.ComponentModel.Win32Exception ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}, category{1}", this.counters[index].CounterName, this.counters[index].CategoryName), EventLogEntryType.Warning, 1057, ex);
                    }
                }
            }
            else
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog("Performance counters not intialized", EventLogEntryType.Warning, 1037, new TraceSourceGeneralException("Performance counters not initialized"));
            }
        }

        public void SafeIncrementBy(int index, long amt)
        {
            if (this.counters != null)
            {
                if (index >= 0 && index < this.counters.Length)
                {
                    try
                    {
                        this.counters[index].IncrementBy(amt);
                    }
                    catch (InvalidOperationException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}, categoryName {1}, Instance Name {2}", this.counters[index].CounterName, this.counters[index].CategoryName, this.counters[index].InstanceName), EventLogEntryType.Error, 1057, ex);
                    }
                    catch (System.ComponentModel.Win32Exception ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}, categoryName {1}, Instance Name {2}", this.counters[index].CounterName, this.counters[index].CategoryName, this.counters[index].InstanceName), EventLogEntryType.Error, 1058, ex);
                    }
                }
            }
            else
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog("Performance counters not intialized", EventLogEntryType.Warning, 1037, new TraceSourceGeneralException("Performance counters not initialized"));
            }
        }

        public void SafeRawValue(int index, long amt)
        {
            if (this.counters != null)
            {
                if (index >= 0 && index < this.counters.Length)
                {
                    try
                    {
                        this.counters[index].RawValue = amt;
                    }
                    catch (InvalidOperationException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}", ex.Message), EventLogEntryType.Warning, 1057, ex);
                    }
                    catch (System.ComponentModel.Win32Exception ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}", ex.Message), EventLogEntryType.Warning, 1058, ex);
                    }
                    catch (PlatformNotSupportedException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}", ex.Message), EventLogEntryType.Warning, 1059, ex);
                    }
                    catch (UnauthorizedAccessException ex)
                    {
                        Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Error attempting to increment counter {0}", ex.Message), EventLogEntryType.Warning, 1060, ex);
                    }
                }
            }
            else
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog("Performance counters not intialized", EventLogEntryType.Warning, 1037, new TraceSourceGeneralException("Performance counters not initialized"));
            }
        }

        public IList<PerformanceCounter> Counters
        {
            get
            {
                return this.counters;
            }
        }

        #region IEnumerable Members

        public IEnumerator GetEnumerator()
        {
            return this.counters.GetEnumerator();
        }

        #endregion

        #region IEnumerator Members

        public object Current
        {
            get { return this.counters.GetEnumerator(); }
        }

        public bool MoveNext()
        {
            return this.counters.GetEnumerator().MoveNext();
        }

        public void Reset()
        {
            this.counters.GetEnumerator().Reset();
        }

        #endregion

        #region IEnumerator<PerformanceCounter> Members

        PerformanceCounter IEnumerator<PerformanceCounter>.Current
        {
            get { return ((IEnumerator<PerformanceCounter>)this.counters.GetEnumerator()).Current; }
        }

        #endregion

        #region IDisposable Members

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool removeNative)
        {
        }
        #endregion

        #region IEnumerable<PerformanceCounter> Members

        IEnumerator<PerformanceCounter> IEnumerable<PerformanceCounter>.GetEnumerator()
        {
            return ((IEnumerable<PerformanceCounter>)this.counters.GetEnumerator()).GetEnumerator();
        }

        #endregion
    }

    #region typedefs
    [Serializable]
    internal class PropertyNameToMemberInfoDictionary : Dictionary<string, System.Reflection.MemberInfo>
    {
        public PropertyNameToMemberInfoDictionary()
            : base()
        {
        }

        protected PropertyNameToMemberInfoDictionary(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }

    [Serializable]
    internal class CounterNameToPerformanceCounterAttributeDictionary : Dictionary<string, PerformanceCounterAttribute>
    {
        public CounterNameToPerformanceCounterAttributeDictionary()
            : base()
        {
        }

        protected CounterNameToPerformanceCounterAttributeDictionary(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }

    [Serializable]
    internal class CounterNameToPerformanceCounterDictionary : Dictionary<string, PerformanceCounter>
    {
        public CounterNameToPerformanceCounterDictionary()
            : base()
        {
        }

        protected CounterNameToPerformanceCounterDictionary(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }
    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSwitch\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("WGXTraceSwitch")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WGXTraceSwitch")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("dbf7976e-f29f-4bf2-af76-d6795376a08f")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\PerformanceCountersInstaller.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Reflection;
using System.Configuration.Install;
namespace Wgx.Services.Monitoring
{
    [RunInstaller(true)]
    public partial class PerformanceCountersInstaller : System.Configuration.Install.AssemblyInstaller
    {
        private Dictionary<Type, PropertyNameToMemberInfoDictionary> g_memberInfoMap = new Dictionary<Type, PropertyNameToMemberInfoDictionary>();
        private Dictionary<string, CounterNameToPerformanceCounterAttributeDictionary> g_counterNameToPerformanceAttributeMap = new Dictionary<string, CounterNameToPerformanceCounterAttributeDictionary>();
        private Dictionary<string, MemberInfoToPerformanceCounterAttributeDictionary> g_propertyAttributeMap = new Dictionary<string, MemberInfoToPerformanceCounterAttributeDictionary>();
        private Dictionary<Type, PerformanceCategoryAttribute> g_categoryAttributeMap = new Dictionary<Type, PerformanceCategoryAttribute>();
        private Assembly m_AssemblyToInstall = null;
        //private string m_assemblyPath;

        public PerformanceCountersInstaller()
        {
        }
        public PerformanceCountersInstaller(string fileName, string[] commandLine)
        {
        }
        public PerformanceCountersInstaller(Assembly assembly, string[] commandLine) : base(assembly, commandLine)
        {

            m_AssemblyToInstall = assembly;
        }
        
        
        
        public override void Install(System.Collections.IDictionary stateSaver)
        {
            base.Install(stateSaver);
            CreatePerformanceCounters(m_AssemblyToInstall, stateSaver);
        }

         
        public override void Commit(System.Collections.IDictionary savedState)
        {
            base.Commit(savedState);
        }

        public override void Rollback(System.Collections.IDictionary savedState)
        {
            base.Rollback(savedState);
            foreach (string categoryName in savedState.Keys)
            {
                if (PerformanceCounterCategory.Exists(categoryName))
                {
                    try
                    {
                        PerformanceCounterCategory.Delete(categoryName);
                    }
                    catch (Exception ex)
                    {
                        throw new InvalidOperationException(string.Format("Unable to delete performance category {0} - {1}", categoryName, ex.Message), ex);
                    }
                }
            }
        }

        public override void Uninstall(System.Collections.IDictionary savedState)
        {
            base.Uninstall(savedState);
            foreach (string categoryName in savedState.Keys)
            {
                if (PerformanceCounterCategory.Exists(categoryName))
                {
                    try
                    {
                        PerformanceCounterCategory.Delete(categoryName);
                    }
                    catch (Exception ex)
                    {
                        throw new InvalidOperationException(string.Format("Unable to delete performance category {0} - {1}", categoryName, ex.Message), ex);
                    }
                }
            }
        }
        /// <summary>
        /// NOTE: requires ADMIN rights
        /// the application that calls this method must be running under administrator rights  
        /// to create the performance counters.
        /// </summary>
        /// 
        public void CreatePerformanceCounters(Assembly asm, System.Collections.IDictionary stateSaver)
        {
            GetAttributes(asm);
            Type[] classTypes = asm.GetTypes();
            foreach (Type classType in classTypes)
            {
                if (classType.IsClass)
                {
                    string categoryName = GetPerformanceCategoryName(classType);
                    string categoryDescription = GetPerformanceCategoryDescription(classType);
                    if (g_propertyAttributeMap.ContainsKey(categoryName))
                    {
                        //_perfCounterMap.Add(categoryName, new CounterNameToPerformanceCounterDictionary());
                        #region delete existing perf category if it exists
                        if (PerformanceCounterCategory.Exists(categoryName))
                        {
                            try
                            {
                                PerformanceCounterCategory.Delete(categoryName);
                            }
                            catch (Exception ex)
                            {
                                throw new InvalidOperationException(string.Format("Unable to delete performance category {0} - {1}", categoryName, ex.Message), ex);
                            }
                        }
                        #endregion
                        #region Create new perf category
                        CounterCreationDataCollection counterDataCollection = SortPerformanceCounters(categoryName);
                        if (counterDataCollection.Count > 0)
                        {

                            try
                            {
                                PerformanceCounterCategory perfCat = PerformanceCounterCategory.Create(categoryName, categoryDescription, PerformanceCounterCategoryType.MultiInstance, counterDataCollection);
                                stateSaver.Add(categoryName, perfCat);
                            }
                            catch (Exception ex)
                            {
                                throw new InvalidOperationException(string.Format("Unable to create performance category {0} - {1}", categoryName, ex.Message), ex);
                            }
                        }
                        #endregion
                   }
                }
            }
        }
        /// <summary>
        /// Initializes the diagnostic object. Should only be called once at application startup
        /// </summary>
        /// <param name="SourceName">the trace source name to use for logging</param>
        protected void GetAttributes(Assembly asm)
        {
            #region clear all dictionary collections
            g_memberInfoMap.Clear();
            g_propertyAttributeMap.Clear();
            g_categoryAttributeMap.Clear();
            g_counterNameToPerformanceAttributeMap.Clear();
            #endregion
            #region collecting performance attributes
            Type[] types = asm.GetTypes();
            foreach (Type nestedType in types)
            {
                GetMemberInfo(nestedType);
            }
            #endregion collecting custom attributes
        }

        /// <summary>
        /// Reflects on properties to extract Diagnostic attributes and there associated reflected types
        /// </summary>
        /// <param name="type">the type to perform reflection on</param>
        protected void GetMemberInfo(Type classType)
        {
            if (classType.IsClass) // only interested if declaring type is a Class type
            {
                string CategoryName = GetPerformanceCategoryName(classType);
                #region add type to dictionary
                if (!g_memberInfoMap.ContainsKey(classType))
                {
                    g_memberInfoMap.Add(classType, new PropertyNameToMemberInfoDictionary());
                }
                #endregion
                #region get performance category attribute
                object attrib = Attribute.GetCustomAttribute(classType, typeof(PerformanceCategoryAttribute));

                if (attrib != null) // is there a performance category attribute defined for this class?
                {
                    PerformanceCategoryAttribute catAttrib = attrib as PerformanceCategoryAttribute;
                    if (!g_categoryAttributeMap.ContainsKey(classType))
                        g_categoryAttributeMap.Add(classType, catAttrib);
                    CategoryName = GetPerformanceCategoryName(classType);
                }
                #endregion

                #region obtain meta data for all accessible of property/method/fields
                System.Reflection.PropertyInfo[] propInfos = classType.GetProperties(); // obtain property meta data
                System.Reflection.MethodInfo[] methodInfos = classType.GetMethods();    // obtain method meta data (not used currently)
                System.Reflection.FieldInfo[] fieldInfos = classType.GetFields();       // obtain field meta data (public fields can act as perf counters)
                #endregion

                #region update member info dictionary will meta data for all 3 types
                // create a new category to hold the perfcounter attributes for this category
                if (!g_propertyAttributeMap.ContainsKey(CategoryName))
                    g_propertyAttributeMap.Add(CategoryName, new MemberInfoToPerformanceCounterAttributeDictionary());
                if (!g_counterNameToPerformanceAttributeMap.ContainsKey(CategoryName))
                    g_counterNameToPerformanceAttributeMap.Add(CategoryName, new CounterNameToPerformanceCounterAttributeDictionary());
                // get the attributes
                AddMemberInfo(g_memberInfoMap[classType], CategoryName, propInfos);  // cache properties
                AddMemberInfo(g_memberInfoMap[classType], CategoryName, methodInfos);// cache methods
                AddMemberInfo(g_memberInfoMap[classType], CategoryName, fieldInfos); // cache fields
                #endregion
            }
        }

        /// <summary>
        /// extracts perfCounter attributes using reflection and caches their values for future reference at run-time
        /// </summary>
        /// <param name="PropertyDictionary">on exit will contain all of the public properties (and fields) for a given class type that contain perfCounter attributes only</param>
        /// <param name="CategoryName">the performance category name (or class name if none is defined) associated with this class type</param>
        /// <param name="CategoryDescription">the category description to be used when creating the performance counters</param>
        /// <param name="memberInfos">contains all of the public properties (and fields) for a given class type (category)</param>
        protected void AddMemberInfo(Dictionary<string, System.Reflection.MemberInfo> propertyDictionary, string categoryName, System.Reflection.MemberInfo[] memberInfoCollection)
        {
            foreach (System.Reflection.MemberInfo memberInfo in memberInfoCollection)
            {
                object[] attributes = memberInfo.GetCustomAttributes(typeof(PerformanceCounterAttribute), true);

                if (attributes.Length > 0) // only add memberInfo if it is attributed (current implementation)
                {
                    foreach (object attr in attributes) // check to see if the member is attributed
                    {
                        if (attr.GetType() == typeof(PerformanceCounterAttribute))
                        {
                            PerformanceCounterAttribute perfAttr = attr as PerformanceCounterAttribute;
                            if (!propertyDictionary.ContainsKey(memberInfo.Name))
                                propertyDictionary.Add(memberInfo.Name, memberInfo);

                            if (memberInfo is System.Reflection.PropertyInfo || memberInfo is System.Reflection.FieldInfo)
                            {
                                if (string.IsNullOrEmpty(perfAttr.CounterName)) // has the user defined a counter name?
                                    perfAttr.CounterName = memberInfo.Name; // if not use the property name as the default counter name
                                if (string.IsNullOrEmpty(perfAttr.CounterDescription)) // has the user defined a counter description?
                                    perfAttr.CounterDescription = perfAttr.CounterName; // if not use the counter name as default

                                g_propertyAttributeMap[categoryName].Add(memberInfo, perfAttr);
                                g_counterNameToPerformanceAttributeMap[categoryName].Add(perfAttr.CounterName, perfAttr);
                            }
                        }

                    }
                }
            }
        }

        /// <summary>
        /// retrieves peformance category name by first checking to see if an attribute has been defined otherewise it used the full type name for the category
        /// </summary>
        /// <param name="classType">the class type associated with the performance category</param>
        /// <returns></returns>
        protected string GetPerformanceCategoryName(Type classType)
        {

            if (g_categoryAttributeMap.ContainsKey(classType))
                return g_categoryAttributeMap[classType].CategoryName;
            else
                return classType.FullName;
        }

        protected string GetPerformanceCategoryDescription(Type classType)
        {

            if (g_categoryAttributeMap.ContainsKey(classType))
                return g_categoryAttributeMap[classType].CategoryDescription;
            else
                return classType.FullName;
        }

        /// <summary>
        /// true is performance counter type is a base type else false
        /// </summary>
        /// <param name="PerfType">performance counter type</param>
        /// <returns></returns>
        protected static bool IsBasePerformanceCounter(PerformanceCounterType performanceType)
        {
            if (performanceType == PerformanceCounterType.AverageBase ||
                performanceType == PerformanceCounterType.CounterMultiBase ||
                performanceType == PerformanceCounterType.RawBase ||
                performanceType == PerformanceCounterType.SampleBase)
                return true;
            else
                return false;

        }

        /// <summary>
        /// base performance counters must occur after non-base due to dependancy relationship (by convention)
        /// </summary>
        /// <param name="categoryName"></param>
        /// <returns></returns>
        protected CounterCreationDataCollection SortPerformanceCounters(string categoryName)
        {
            CounterCreationDataCollection outCollection = new CounterCreationDataCollection();

            foreach (PerformanceCounterAttribute perfCounterAttrib in g_propertyAttributeMap[categoryName].Values)
            {
                // add counter as long as its not a base counter, base counters get added when they are referenced through and AssociatedBaseCounter property
                if (!IsBasePerformanceCounter(perfCounterAttrib.CounterType))
                    outCollection.Add(new CounterCreationData(perfCounterAttrib.CounterName, perfCounterAttrib.CounterDescription, perfCounterAttrib.CounterType));
                // the following LINQ query will return all base counters associated with the current counter
                IEnumerable<PerformanceCounterAttribute> baseCounters = from attrib in g_propertyAttributeMap[categoryName].Values where !string.IsNullOrEmpty(perfCounterAttrib.BasePropertyName) && attrib.CounterName == perfCounterAttrib.BasePropertyName select attrib;
                foreach (PerformanceCounterAttribute attrib in baseCounters)
                {
                    // add base counter
                    if (IsBasePerformanceCounter(attrib.CounterType))
                        outCollection.Add(new CounterCreationData(attrib.CounterName, attrib.CounterDescription, attrib.CounterType));
                    else
                    {
                        // wrong counter type for base counter
                        throw new InvalidPerformanceCounterException(string.Format("The associated base counter {0} is not an appropriate performance counter type", attrib.CounterName));
                    }
                }
            }

            return outCollection;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\WGXTraceSource.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;
    using System.Xml;

    public class WgxTraceSource
    {
        #region member fields
        private TraceSource TS;
        private readonly TraceEventCache manager = new TraceEventCache();
        private static XmlWriterSettings writerSettings;
        private static string machineName;
        private bool isSourceSwitchEx;
        private string assemblyName;
        #endregion
        #region PUBLIC API
        public WgxTraceSource(string sourceName)
        {
            this.TS = new TraceSource(sourceName);
            this.AssemblyName = System.Reflection.Assembly.GetCallingAssembly().FullName;

            // are we using the "extended" source switch?
            if (this.TS.Switch is IWgxSourceSwitch) 
            {
                ((IWgxSourceSwitch)TS.Switch).Initialize();
                this.isSourceSwitchEx = true;
            }

            writerSettings = new XmlWriterSettings();
            writerSettings.OmitXmlDeclaration = true;
            writerSettings.Indent = true;
        }
 
        public WgxTraceSource(string sourceName, SourceLevels levels)
        {
            this.TS = new TraceSource(sourceName, levels);
            this.AssemblyName = System.Reflection.Assembly.GetCallingAssembly().FullName;
            // are we using the "extended" source switch?
            if (this.TS.Switch is IWgxSourceSwitch)
            {
                ((IWgxSourceSwitch)TS.Switch).Initialize();
                this.isSourceSwitchEx = true;
            }

            writerSettings = new XmlWriterSettings();
            writerSettings.OmitXmlDeclaration = true;
            writerSettings.Indent = true;
        }

        #region Properties
        public SourceSwitch Switch
        {
            get
            {
                if (this.TS != null)
                {
                    return this.TS.Switch;
                }
                else
                {
                    return null;
                }
            }
            // CA2122 Link Demand requires this
            [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
            set
            {
                if (this.TS != null)
                {
                    this.TS.Switch = value;
                }
            }
        }

        public TraceOptionsEx TraceOptions
        {
            get;
            set;
        }
        public TraceListenerCollection Listeners
        {
            // CA2122 Link Demand requires this
            [EnvironmentPermissionAttribute(SecurityAction.LinkDemand, Unrestricted = true)]
            get
            {
                if (this.TS != null)
                {
                    return this.TS.Listeners;
                }
                else
                {
                    return null;
                }
            }
        }

        internal TraceSource InternalTraceSource
        {
            get
            {
                return this.TS;
            }
        }

        protected string AssemblyName
        {
            get
            {
                return this.assemblyName;
            }

            set
            {
                this.assemblyName = value;
            }
        }

        private static string MachineName
        {
            get
            {
                if (string.IsNullOrEmpty(machineName))
                {
                    machineName = System.Environment.MachineName;
                }

                return machineName;
            }
        }
        #endregion
        public EventsCollection GetEventsCollection(Type classType)
        {
            return this.GetEventsCollection(classType, null);
        }

        public EventsCollection GetEventsCollection(object classInstance)
        {
            if (classInstance != null)
            {
                return this.GetEventsCollection(classInstance.GetType(), classInstance);
            }
            else
            {
                throw new TraceSourceGeneralException("The class instance for the events collection was null, use the overloaded method instead");
            }
        }

        public void TraceEvent(TraceEventType eventType, int messageId, string message)
        {
            TraceEvent(eventType, messageId, message, null);
        }

        public void TraceEvent(TraceEventType eventType, int messageId, string message, params object[] args)
        {
            if (this.ShouldTrace(messageId, ref eventType))
            {
                StackFrame sf = GetStackFrame();
                try
                {
                    string msg = args == null ? message : string.Format(message, args);
                    string xmlEvent = this.PopulateEventSchema(sf, eventType, messageId, this.InternalTraceSource.Name, msg);
                    this.InternalTraceSource.TraceEvent(eventType, messageId, xmlEvent);
                }
                catch (FormatException ex)
                {
                    WgxTraceSource.WriteEventLog(string.Format("Unable to trace message for event ID {0}", messageId), EventLogEntryType.Warning, 1089, ex);
                }
                catch (ArgumentNullException ex)
                {
                    WgxTraceSource.WriteEventLog(string.Format("Unable to trace message for event ID {0}", messageId), EventLogEntryType.Warning, 1090, ex);
                }
            }
        }

        public void TraceFormattedEvent(TraceEventType eventType, int messageId, string message)
        {
            if (this.ShouldTrace(messageId, ref eventType))
            {
                try
                {
                    this.InternalTraceSource.TraceEvent(eventType, messageId, message);
                }
                catch (FormatException ex)
                {
                    WgxTraceSource.WriteEventLog(string.Format("Unable to trace message for event ID {0}", messageId), EventLogEntryType.Warning, 1089, ex);
                }
                catch (ArgumentNullException ex)
                {
                    WgxTraceSource.WriteEventLog(string.Format("Unable to trace message for event ID {0}", messageId), EventLogEntryType.Warning, 1090, ex);
                }
            }
        }

        public StackFrame GetStackFrame()
        {
            StackFrame sf = null;
            bool needFileInfo = false;
            if ((TraceOptions & TraceOptionsEx.MethodName) != 0 ||
                (TraceOptions & TraceOptionsEx.FileName) != 0 ||
                (TraceOptions & TraceOptionsEx.LineNumber) != 0)
            {
                needFileInfo = (TraceOptions & TraceOptionsEx.FileName) != 0 || (TraceOptions & TraceOptionsEx.LineNumber) != 0;
                StackTrace st = new StackTrace(0, needFileInfo);
                sf = st.GetFrame(1);
            }
            return sf;
        }

        #endregion // public API
        #region internal tracing implementation
        internal static void WriteEventLog(string errorMsg, EventLogEntryType entryType, int msgID, Exception ex)
        {
#if ALLOW_EXCEPTIONS
            throw new TraceSourceGeneralException(string.Format("errorMsg {0}, type {1}, msgID {2}", errorMsg, entryType, msgID), ex);
#else
            System.Diagnostics.EventLog eventLog = new EventLog("Application", System.Environment.MachineName, "WGXTraceSource");
            try
            {
                eventLog.WriteEntry(string.Format("Source Name: {0}, Machine Name: {1}, Error writing message id {2}, error msg: {3}", "Wgx.Services.Monitoring", System.Environment.MachineName, msgID, errorMsg), entryType);
            }
            catch
            {
                try
                {
                    // second attempt to write to event log using only the bare minimum of information
                    eventLog.WriteEntry(string.Format("Source Name: {0}, Machine Name: {1}, Error writing message id {2}", "Wgx.Services.Monitoring", System.Environment.MachineName, msgID), entryType);
                }
                catch
                {
                    // can't log the exception so just carry on
                }
            }
#endif
        }

        internal bool ShouldTrace(int messageID, ref TraceEventType eventType)
        {
            bool shouldTrace = true;

            // are we using the "extended" source switch?
            if (this.isSourceSwitchEx)
            {
                // if so then transmute the event type if necessary
                shouldTrace = ((IWgxSourceSwitch)this.TS.Switch).ShouldTrace(messageID, ref eventType);
                TraceOptions = ((IWgxSourceSwitch)this.TS.Switch).TraceOptions;
            }

            return shouldTrace;
        }

        internal string PopulateEventSchema(StackFrame sf, TraceEventType level, int messageID, string sourceName, string message)
        {
            StringBuilder sb = new StringBuilder();

            // write event to database
            try
            {
                XmlWriter w = XmlWriter.Create(sb, writerSettings);

                w.WriteStartElement("Event");
                w.WriteElementString("EventType", level.ToString());
                w.WriteElementString("MachineName", MachineName);
                w.WriteElementString("AssemblyName", (this.AssemblyName != null) ? this.AssemblyName : "Unknown");
                w.WriteElementString("Source", sourceName);
                w.WriteElementString("MessageID", XmlConvert.ToString(messageID));
                w.WriteStartElement("Message");
                w.WriteRaw(message == null ? "NULL" : stripNonValidXMLCharacters(message));
                w.WriteEndElement();

                w.WriteElementString("DateTime", this.manager.DateTime.ToString());

                if ((TraceOptions & TraceOptionsEx.MethodName) != 0 && sf != null)
                {
                    w.WriteElementString("MethodName", sf.GetMethod().Name);
                }

                if ((TraceOptions & TraceOptionsEx.FileName) != 0 && sf != null)
                {
                    w.WriteElementString("FileName", sf.GetFileName());
                }

                if ((TraceOptions & TraceOptionsEx.LineNumber) != 0 && sf != null)
                {
                    w.WriteElementString("LineNumber", XmlConvert.ToString(sf.GetFileLineNumber()));
                }

                if ((TraceOptions & TraceOptionsEx.Timestamp) != 0)
                {
                    w.WriteElementString("TimeStamp", XmlConvert.ToString(this.manager.Timestamp));
                }

                if ((TraceOptions & TraceOptionsEx.ProcessId) != 0)
                {
                    w.WriteElementString("ProcessID", XmlConvert.ToString(TraceEventCache.ProcessId));
                }

                if ((TraceOptions & TraceOptionsEx.ThreadId) != 0)
                {
                    w.WriteElementString("ThreadID", TraceEventCache.ThreadId);
                }

                if ((TraceOptions & TraceOptionsEx.Callstack) != 0)
                {
                    w.WriteElementString("CallStack", this.manager.Callstack);
                }

                w.WriteEndElement();
                w.Close();
            }
            catch (ArgumentException ex)
            {
                Wgx.Services.Monitoring.WgxTraceSource.WriteEventLog(string.Format("Source Name: {0}, Machine Name: {1}, Error attempting to populate event xml error msg", "Wgx.Services.Monitoring", System.Environment.MachineName), EventLogEntryType.Warning, 1012, ex);
            }

            return sb.ToString();
        }

        private static string stripNonValidXMLCharacters(string s)
        {
            StringBuilder _validXML = new StringBuilder(0x80); // Used to hold the output.

            char current; // Used to reference the current character.

            char[] charArray = s.ToCharArray();
            if (string.IsNullOrEmpty(s)) return string.Empty; // vacancy test.
            for (int i = 0; i < charArray.Length; i++)
            {
                current = charArray[i]; // NOTE: No IndexOutOfBoundsException caught here; it should not happen.
                if ((current == 0x9) ||
                    (current == 0xA) ||
                    (current == 0xD) ||
                    ((current >= 0x20) && (current <= 0xD7FF)) ||
                    ((current >= 0xE000) && (current <= 0xFFFD)))
                {
                    _validXML.Append(current);
                }
                else
                {
                    string encoded = string.Format("0x{0:x4}", Convert.ToByte(current));
                    _validXML.Append(encoded);
                }

            }
            return _validXML.ToString();
        }

        protected EventsCollection GetEventsCollection(Type classType, object classInstance)
        {
            return new EventsCollection(this, classType, classInstance);
        }
        #endregion
        #region TRACESOURCE manager (copied from System.Diagnostics)
        internal class TraceEventCache
        {
            // Fields
            private static int processId;
            private static string processName;

            // Properties
            public string Callstack
            {
                get
                {
                    return Environment.StackTrace;
                }
            }

            public DateTime DateTime
            {
                get
                {
                    return DateTime.UtcNow;
                }
            }

            internal static int ProcessId
            {
                get
                {
                    return GetProcessId();
                }
            }

            internal static string ThreadId
            {
                get
                {
                    return GetThreadId().ToString(CultureInfo.InvariantCulture);
                }
            }

            internal long Timestamp
            {
                get
                {
                    return Stopwatch.GetTimestamp();
                }
            }

            // Methods
            internal static int GetProcessId()
            {
                InitProcessInfo();
                return processId;
            }

            internal static int GetThreadId()
            {
                return Thread.CurrentThread.ManagedThreadId;
            }

            private static void InitProcessInfo()
            {
                new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
                if (processName == null)
                {
                    using (Process process = Process.GetCurrentProcess())
                    {
                        processId = process.Id;
                        processName = process.ProcessName;
                    }
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSwitch\traceswitch.cs ===
namespace Wgx.Services.Monitoring
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Timers;
    using Wgx.Services.Monitoring.DiagnosticDBDataSetTableAdapters;

    public class WgxSourceSwitch : System.Diagnostics.SourceSwitch, IWgxSourceSwitch
    {
        private Dictionary<int, MessageTbl> transformTable = new Dictionary<int, MessageTbl>();
        private Timer timer = new Timer();
        private TraceOptionsEx traceOptions;
       
        public WgxSourceSwitch(string displayName, string description)
            : base(displayName, description)
        {
            Initialize();
        }

        public WgxSourceSwitch(string name)
            : base(name)
        {
            Initialize();
        }

        public TraceOptionsEx TraceOptions
        {
            get
            {
                return this.traceOptions;
            }

            set
            {
                this.traceOptions = value;
            }
        }

        public bool ShouldTrace(int messageID, ref TraceEventType eventType)
        {
            bool shouldTrace = true;
            if (this.transformTable.ContainsKey(messageID))
            {
                shouldTrace = this.transformTable[messageID].ShouldTrace;
                if (this.transformTable[messageID].EventType != 0)
                {
                    eventType = (TraceEventType)this.transformTable[messageID].EventType;
                }
            }

            return shouldTrace;
        }

        public void Initialize()
        {
            double timerInterval = 0;
            if (double.TryParse(System.Configuration.ConfigurationManager.AppSettings["TimerInterval"], out timerInterval))
            {
                this.timer.Interval = timerInterval;
            }
            else
            {
                this.timer.Interval = 10000;
            }

            // by default we log all messages
            Level = SourceLevels.All;
            this.timer.Elapsed += new ElapsedEventHandler(this.Timer_Elapsed);
            this.timer.Enabled = true;
            this.RetrieveMessageTransformationsFromDB();
            this.RetrieveTraceSettingsFromDB();
        }

        protected void WriteEventLog(string errorMsg, EventLogEntryType entryType, int msgID)
        {
            System.Diagnostics.EventLog eventLog = new EventLog("Application", System.Environment.MachineName, this.GetType().FullName);
            eventLog.WriteEntry(string.Format("Source Name: {0}, Machine Name: {1}, Error writing message id {2}, error msg: {3}", this.DisplayName, System.Environment.MachineName, msgID, errorMsg), entryType);
        }

        protected void UpdateTraceOptionSettings(DiagnosticDBDataSet.TraceConfigurationSettingsRow row)
        {
            if (!row.IsSwitchValueNull())
            {
                Level = (SourceLevels)row.SwitchValue;
            }

            if (!row.IsTraceOutputOptionsNull())
            {
                this.TraceOptions = (TraceOptionsEx)row.TraceOutputOptions;
            }
        }

        private void Timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            this.RetrieveMessageTransformationsFromDB();
            this.RetrieveTraceSettingsFromDB();
        }

        private void RetrieveMessageTransformationsFromDB()
        {
            try
            {
                MessageIDTransformTblTableAdapter adapter = new MessageIDTransformTblTableAdapter();
                DiagnosticDBDataSet.MessageIDTransformTblDataTable dt = adapter.GetMessageIDTransformTable();
                foreach (DiagnosticDBDataSet.MessageIDTransformTblRow row in dt.Rows)
                {
                    if (!this.transformTable.ContainsKey(row.MessageID))
                    {
                        this.transformTable.Add(row.MessageID, new MessageTbl());
                    }

                    if (!row.IsNewSeverityNull())
                    {
                        this.transformTable[row.MessageID].EventType = (TraceEventType)row.NewSeverity;
                    }
                    else
                    {
                        this.transformTable[row.MessageID].EventType = 0;
                    }

                    if (!row.IsShouldTraceNull())
                    {
                        this.transformTable[row.MessageID].ShouldTrace = row.ShouldTrace;
                    }
                    else
                    {
                        this.transformTable[row.MessageID].ShouldTrace = true;
                    }
                }
            }
            catch (InvalidOperationException ex)
            {
                this.WriteEventLog(string.Format("Unable to access message transformation data table, error msg:{0}", ex.Message), EventLogEntryType.Error, 10021);
            }
            catch (System.Data.SqlClient.SqlException ex)
            {
                this.WriteEventLog(string.Format("Unable to access message transformation data table, error msg:{0}", ex.Message), EventLogEntryType.Error, 10049);
            }
        }

        private void RetrieveTraceSettingsFromDB()
        {
            TraceConfigurationSettingsTableAdapter adapter = new TraceConfigurationSettingsTableAdapter();
            DiagnosticDBDataSet.TraceConfigurationSettingsDataTable dt;
            try
            {
                dt = adapter.GetData();
                if (dt.Count > 0)
                {
                    System.Data.DataRow[] rows;
                    rows = dt.Select("SwitchName = '" + this.DisplayName + "'");
                    
                    // is there a specific setting for this Switch?
                    if (rows.Length > 0) 
                    {
                        DiagnosticDBDataSet.TraceConfigurationSettingsRow row = (DiagnosticDBDataSet.TraceConfigurationSettingsRow)rows[0];
                        if (!row.IsSwitchNameNull())
                        {
                            if (row.SwitchName == this.DisplayName)
                            {
                                this.UpdateTraceOptionSettings(row);
                            }
                        }
                    }
                    else 
                    {
                        // no named settings so just grap the first NULL row as the "default"
                        rows = dt.Select("SwitchName IS NULL");
                        if (rows.Length > 0)
                        {
                            DiagnosticDBDataSet.TraceConfigurationSettingsRow row = (DiagnosticDBDataSet.TraceConfigurationSettingsRow)rows[0];
                            this.UpdateTraceOptionSettings(row);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                this.WriteEventLog(string.Format("Unable to access trace configuration settings data table, error msg:{0}", ex.Message), EventLogEntryType.Error, 10027);
            }
        } 
    
        private class MessageTbl
        {
            public TraceEventType EventType;
            public bool ShouldTrace = true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WGXTraceSource\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DiagnosticObject")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("DiagnosticObject")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2008")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e2012597-5dc6-4077-baf2-ccb3496a86cc")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\BlobStorage.cs ===
//
// <copyright file="BlobStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.IO;
using System.Collections.Specialized;
using System.Threading;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Diagnostics;

[assembly:CLSCompliant(true)]

// disable the generation of warnings for missing documentation elements for 
// public classes/members in this file
#pragma warning disable 1591

namespace AsyncMultiplayer.Common.AzureStorage
{

    /// <summary>
    /// This delegate define the shape of a retry policy. A retry policy will invoke the given
    /// <paramref name="action"/> as many times as it wants to in the face of 
    /// retriable StorageServerExceptions.
    /// </summary>
    /// <param name="action">The action to retry</param>
    /// <returns></returns>
    public delegate void RetryPolicy(Action action);

    #region Blob Storage API
    /// <summary>
    /// The entry point of the blob storage API
    /// </summary>
    public abstract class BlobStorage
    {

        /// <summary>
        /// Factory method for BlobStorage
        /// </summary>
        /// <param name="baseUri">The base URI of the blob storage service</param>
        /// <param name="usePathStyleUris">If true, path-style URIs (http://baseuri/accountname/containername/objectname) are used.
        /// If false host-style URIs (http://accountname.baseuri/containername/objectname) are used,
        /// where baseuri is the URI of the service.
        /// If null, the choice is made automatically: path-style URIs if host name part of base URI is an 
        /// IP addres, host-style otherwise.</param>
        /// <param name="accountName">The name of the storage account</param>
        /// <param name="base64Key">Authentication key used for signing requests</param>
        /// <returns>A newly created BlobStorage instance</returns>
        public static BlobStorage Create(
                                    Uri baseUri,
                                    bool? usePathStyleUris,
                                    string accountName,
                                    string base64Key
                                    )
        {
            //We create a StorageAccountInfo and then extract the properties of that object.
            //This is because the constructor of StorageAccountInfo does normalization of BaseUri.
            StorageAccountInfo accountInfo = new StorageAccountInfo(
                                                baseUri,
                                                usePathStyleUris,
                                                accountName,
                                                base64Key
                                                );
            return new BlobStorageRest(
                accountInfo.BaseUri,
                accountInfo.UsePathStyleUris,
                accountInfo.AccountName,
                accountInfo.Base64Key
                );
        }

        /// <summary>
        /// Factory method for BlobStorage
        /// </summary>
        /// <param name="accountInfo">Account information</param>
        /// <returns>A newly created BlobStorage instance</returns>
        public static BlobStorage Create(StorageAccountInfo accountInfo)
        {
            return new BlobStorageRest(
                accountInfo.BaseUri,
                accountInfo.UsePathStyleUris,
                accountInfo.AccountName,
                accountInfo.Base64Key
                );
        }
                                    

        /// <summary>
        /// Get a reference to a newly created BlobContainer object.
        /// This method does not make any calls to the storage service.
        /// </summary>
        /// <param name="containerName">The name of the container</param>
        /// <returns>A reference to a newly created BlobContainer object</returns>
        public abstract BlobContainer GetBlobContainer(string containerName);


        /// <summary>
        /// Lists the containers within the account.
        /// </summary>
        /// <returns>A list of containers</returns>
        public abstract IEnumerable<BlobContainer> ListBlobContainers();

        /// <summary>
        /// The time out for each request to the storage service.
        /// </summary>
        public TimeSpan Timeout
        {
            get;
            set;
        }

        /// <summary>
        /// The retry policy used for retrying requests
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// The proxy address for the environment. 
        /// </summary>
        public string ProxyAddress
        {
            get;
            set;
        }

        /// <summary>
        /// The base URI of the blob storage service
        /// </summary>
        public Uri BaseUri
        {
            get
            {
                return this.baseUri;
            }
        }

        /// <summary>
        /// The name of the storage account
        /// </summary>
        public string AccountName
        {
            get
            {
                return this.accountName;
            }
        }

        /// <summary>
        /// Indicates whether to use/generate path-style or host-style URIs
        /// </summary>
        public bool UsePathStyleUris
        {
            get
            {
                return this.usePathStyleUris;
            }
        }

        /// <summary>
        /// The default timeout
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes",
                          Justification = "TimeSpan is a non-mutable type")]
        public static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(30);        

        /// <summary>
        /// The default retry policy
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes",
                          Justification = "RetryPolicy is a non-mutable type")]
        public static readonly RetryPolicy DefaultRetryPolicy = RetryPolicies.NoRetry;        


        internal protected BlobStorage(Uri baseUri,
                            bool? usePathStyleUris,
                            string accountName,
                            string base64Key
                            )
        {
            this.baseUri = baseUri;
            this.accountName = accountName;
            this.Base64Key = base64Key;
            if (usePathStyleUris == null)
                this.usePathStyleUris = Utilities.StringIsIPAddress(baseUri.Host);
            else
                this.usePathStyleUris = usePathStyleUris.Value;

            Timeout = DefaultTimeout;
            RetryPolicy = DefaultRetryPolicy;
        }

       private bool usePathStyleUris;
       private Uri baseUri;
       private string accountName;
       protected internal string Base64Key
       {
           get;
           set;
       }
     }


    /// <summary>
    /// Provides definitions for some standard retry policies.
    /// </summary>
    public static class RetryPolicies
    {

        public static readonly TimeSpan StandardMinBackoff = TimeSpan.FromMilliseconds(100);
        public static readonly TimeSpan StandardMaxBackoff = TimeSpan.FromSeconds(30);
        private static readonly Random random = new Random();

        /// <summary>
        /// Policy that does no retries i.e., it just invokes <paramref name="action"/> exactly once
        /// </summary>
        /// <param name="action">The action to retry</param>
        /// <returns>The return value of <paramref name="action"/></returns>
        public static void NoRetry(Action action)
        {
            try
            {
                action();
            }
            catch (TableRetryWrapperException e)
            {
                throw e.InnerException;
            }
        }

        /// <summary>
        /// Policy that retries a specified number of times with a specified fixed time interval between retries
        /// </summary>
        /// <param name="numberOfRetries">The number of times to retry. Should be a non-negative number</param>
        /// <param name="intervalBetweenRetries">The time interval between retries. Use TimeSpan.Zero to specify immediate
        /// retries</param>
        /// <returns></returns>
        /// <remarks>When <paramref name="numberOfRetries"/> is 0 and <paramref name="intervalBetweenRetries"/> is
        /// TimeSpan.Zero this policy is equivalent to the NoRetry policy</remarks>
        public static RetryPolicy RetryN(int numberOfRetries, TimeSpan intervalBetweenRetries)
        {
            return new RetryPolicy((Action action) =>
            {
                RetryNImpl(action, numberOfRetries, intervalBetweenRetries);
            }
            );
        }

        /// <summary>
        /// Policy that retries a specified number of times with a randomized exponential backoff scheme
        /// </summary>
        /// <param name="numberOfRetries">The number of times to retry. Should be a non-negative number.</param>
        /// <param name="deltaBackoff">The multiplier in the exponential backoff scheme</param>
        /// <returns></returns>
        /// <remarks>For this retry policy, the minimum amount of milliseconds between retries is given by the 
        /// StandardMinBackoff constant, and the maximum backoff is predefined by the StandardMaxBackoff constant. 
        /// Otherwise, the backoff is calculated as random(2^currentRetry) * deltaBackoff.</remarks>
        public static RetryPolicy RetryExponentialN(int numberOfRetries, TimeSpan deltaBackoff)
        {
            return new RetryPolicy((Action action) =>
            {
                RetryExponentialNImpl(action, numberOfRetries, StandardMinBackoff, StandardMaxBackoff, deltaBackoff);
            }
            );
        }

        /// <summary>
        /// Policy that retries a specified number of times with a randomized exponential backoff scheme
        /// </summary>
        /// <param name="numberOfRetries">The number of times to retry. Should be a non-negative number</param>
        /// <param name="deltaBackoff">The multiplier in the exponential backoff scheme</param>
        /// <param name="minBackoff">The minimum backoff interval</param>
        /// <param name="maxBackoff">The maximum backoff interval</param>
        /// <returns></returns>
        /// <remarks>For this retry policy, the minimum amount of milliseconds between retries is given by the 
        /// minBackoff parameter, and the maximum backoff is predefined by the maxBackoff parameter. 
        /// Otherwise, the backoff is calculated as random(2^currentRetry) * deltaBackoff.</remarks>
        public static RetryPolicy RetryExponentialN(int numberOfRetries, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff)
        {
            if (minBackoff > maxBackoff)
            {
                throw new ArgumentException("The minimum backoff must not be larger than the maximum backoff period.");
            }
            if (minBackoff < TimeSpan.Zero)
            {
                throw new ArgumentException("The minimum backoff period must not be negative.");
            }

            return new RetryPolicy((Action action) =>
            {
                RetryExponentialNImpl(action, numberOfRetries, minBackoff, maxBackoff, deltaBackoff);
            }
            );
        }

        #region private helper methods

        private static void RetryNImpl(Action action, int numberOfRetries, TimeSpan intervalBetweenRetries)
        {
            do
            {
                try
                {
                    action();
                    break;
                }
                catch (StorageServerException)
                {
                    if (numberOfRetries == 0)
                    {
                        throw;
                    }
                    if (intervalBetweenRetries > TimeSpan.Zero)
                    {
                        Thread.Sleep(intervalBetweenRetries);
                    }

                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureCallRetries);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureCallRetriesPerSecond);
                }
                catch (TableRetryWrapperException e)
                {
                    if (numberOfRetries == 0)
                    {
                        throw e.InnerException;
                    }
                    if (intervalBetweenRetries > TimeSpan.Zero)
                    {
                        Thread.Sleep(intervalBetweenRetries);
                    }

                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureCallRetries);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureCallRetriesPerSecond);
                }
            }
            while (numberOfRetries-- > 0);
        }

        private static void RetryExponentialNImpl(Action action, int numberOfRetries, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff)
        {
            int totalNumberOfRetries = numberOfRetries;
            TimeSpan backoff;

            // sanity check
            // this is already checked when creating the retry policy in case other than the standard settings are used
            // because this library is available in source code, the standard settings can be changed and thus we 
            // check again at this point
            if (minBackoff > maxBackoff)
            {
                throw new ArgumentException("The minimum backoff must not be larger than the maximum backoff period.");
            }
            if (minBackoff < TimeSpan.Zero)
            {
                throw new ArgumentException("The minimum backoff period must not be negative.");
            }

            do
            {
                try
                {
                    action();
                    break;
                }
                catch (StorageServerException)
                {
                    if (numberOfRetries == 0)
                    {
                        throw;
                    }  
                    backoff = CalculateCurrentBackoff(minBackoff, maxBackoff, deltaBackoff, totalNumberOfRetries - numberOfRetries);
                    Debug.Assert(backoff >= minBackoff);
                    Debug.Assert(backoff <= maxBackoff);
                    if (backoff > TimeSpan.Zero) {
                        Thread.Sleep(backoff);
                    }
                }
                catch (TableRetryWrapperException e)
                {
                    if (numberOfRetries == 0)
                    {
                        throw e.InnerException;
                    }
                    backoff = CalculateCurrentBackoff(minBackoff, maxBackoff, deltaBackoff, totalNumberOfRetries - numberOfRetries);
                    Debug.Assert(backoff >= minBackoff);
                    Debug.Assert(backoff <= maxBackoff);
                    if (backoff > TimeSpan.Zero)
                    {
                        Thread.Sleep(backoff);
                    }
                }
            }
            while (numberOfRetries-- > 0);
        }

        private static TimeSpan CalculateCurrentBackoff(TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff, int curRetry)
        {
            long backoff;

            if (curRetry > 30)
            {
                backoff = maxBackoff.Ticks;
            }
            else
            {
                try
                {
                    checked
                    {
                        // only randomize the multiplier here 
                        // it would be as correct to randomize the whole backoff result
                        lock (random)
                        {
                            backoff = random.Next((1 << curRetry) + 1);
                        }
                        // Console.WriteLine("backoff:" + backoff);
                        // Console.WriteLine("random range: [0, " + ((1 << curRetry) + 1) + "]");
                        backoff *= deltaBackoff.Ticks;
                        backoff += minBackoff.Ticks;
                    }
                }
                catch (OverflowException)
                {
                    backoff = maxBackoff.Ticks;
                }
                if (backoff > maxBackoff.Ticks)
                {
                    backoff = maxBackoff.Ticks;
                }
            }
            Debug.Assert(backoff >= minBackoff.Ticks);
            Debug.Assert(backoff <= maxBackoff.Ticks);
            return TimeSpan.FromTicks(backoff);
        }

        #endregion
    }

    /// <summary>
    /// Access control for containers
    /// </summary>
    public enum ContainerAccessControl
    {
        Private,
        Public
    }

    /// <summary>
    /// The blob container class.
    /// Used to access and enumerate blobs in the container.
    /// Storage key credentials are needed to access private blobs but not for public blobs.
    /// </summary>
    public abstract class BlobContainer
    {
        /// <summary>
        /// Use this constructor to access private blobs.
        /// </summary>
        /// <param name="baseUri">The base Uri for the storage endpoint</param>
        /// <param name="accountName">Name of the storage account</param>
        /// <param name="containerName">Name of the container</param>
        internal protected BlobContainer(Uri baseUri, string accountName,  string containerName)
            : this(baseUri, true, accountName, containerName, DateTime.MinValue, string.Empty)
        {}

        /// <summary>
        /// Use this constructor to access private blobs.
        /// </summary>
        /// <param name="baseUri">The base Uri for the storage endpoint</param>
        /// <param name="usePathStyleUris">
        /// If true, path-style URIs (http://baseuri/accountname/containername/objectname) are used and if false 
        /// host-style URIs (http://accountname.baseuri/containername/objectname) are used, where baseuri is the 
        /// URI of the service
        /// </param>
        /// <param name="accountName">Name of the storage account</param>
        /// <param name="containerName">Name of the container</param>
        /// <param name="lastModified">Date of last modification</param>
        internal protected BlobContainer(Uri baseUri, bool usePathStyleUris, string accountName, string containerName, DateTime lastModified, string proxyAddress)
        {
            if (!Utilities.IsValidContainerOrQueueName(containerName))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The specified container name \"{0}\" is not valid!" +
                            "Please choose a name that conforms to the naming conventions for containers!", containerName));
            }
            this.baseUri = baseUri;
            this.usePathStyleUris = usePathStyleUris;
            this.accountName = accountName;
            this.containerName = containerName;
            this.Timeout = BlobStorage.DefaultTimeout;
            this.RetryPolicy = BlobStorage.DefaultRetryPolicy;
            this.LastModifiedTime = lastModified;
            this.ProxyAddress = proxyAddress; 
        }


        /// <summary>
        /// The time out for each request to the storage service.
        /// </summary>
        public TimeSpan Timeout
        {
            get;
            set;
        }

        /// <summary>
        /// The retry policy used for retrying requests
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// The base URI of the blob storage service
        /// </summary>
        public Uri BaseUri
        {
            get
            {
                return this.baseUri;
            }
        }

        /// <summary>
        /// Gets or sets the proxy address for the environment. 
        /// </summary>
        public string ProxyAddress
        {
            get;
            set;
        }

        /// <summary>
        /// The name of the storage account
        /// </summary>
        public string AccountName
        {
            get
            {
                return this.accountName;
            }
        }

        /// <summary>
        /// The name of the blob container.
        /// </summary>
        public string ContainerName
        {
            get
            {
                return this.containerName;
            }
        }

        /// <summary>
        /// Indicates whether to use/generate path-style or host-style URIs
        /// </summary>
        public bool UsePathStyleUris
        {
            get
            {
                return this.usePathStyleUris;
            }
        }

        /// <summary>
        /// The URI of the container
        /// </summary>
        public abstract Uri ContainerUri
        {
            get;
        }

        /// <summary>
        /// The timestamp for last modification of container.
        /// </summary>
        public DateTime LastModifiedTime
        {
            get;
            protected set;
        }

        /// <summary>
        /// Create the container if it does not exist.
        /// The container is created with private access control and no metadata.
        /// </summary>
        /// <returns>true if the container was created. false if the container already exists</returns>
        public abstract bool CreateContainer();

        /// <summary>
        /// Create the container with the specified metadata and access control if it does not exist
        /// </summary>
        /// <param name="metadata">The metadata for the container. Can be null to indicate no metadata</param>
        /// <param name="accessControl">The access control (public or private) with which to create the container</param>
        /// <returns>true if the container was created. false if the container already exists</returns>
        public abstract bool CreateContainer(NameValueCollection metadata, ContainerAccessControl accessControl); 

        /// <summary>
        /// Check if the blob container exists
        /// </summary>
        /// <returns>true if the container exists, false otherwise.</returns>
        public abstract bool DoesContainerExist();

        /// <summary>
        /// Get the properties for the container if it exists.
        /// </summary>
        /// <returns>The properties for the container if it exists, null otherwise</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate",
            Justification="The method makes a call to the blob service")]
        public abstract ContainerProperties GetContainerProperties();

        /// <summary>
        /// Get the access control permissions associated with the container.
        /// </summary>
        /// <returns></returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate",
            Justification = "The method makes a call to the blob service")]
        public abstract ContainerAccessControl GetContainerAccessControl();

        /// <summary>
        /// Set the access control permissions associated with the container.
        /// </summary>
        /// <param name="acl">The permission to set</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate",
            Justification = "The method makes a call to the blob service")]
        public abstract void SetContainerAccessControl(ContainerAccessControl acl);

        /// <summary>
        /// Deletes the current container.
        /// </summary>
        public abstract bool DeleteContainer();

        /// <summary>
        /// Check if the blob container exists
        /// </summary>
        /// <param name="blobName">Name of the BLOB.</param>
        /// <returns>true if the blob exists, false otherwise.</returns>
        public abstract bool DoesBlobExist(string blobName);

        /// <summary>
        /// Create a new blob or overwrite an existing blob.
        /// </summary>
        /// <param name="blobProperties">The properties of the blob</param>
        /// <param name="blobContents">The contents of the blob</param>
        /// <param name="overwrite">Should this request overwrite an existing blob ?</param>
        /// <returns>true if the blob was created. false if the blob already exists and <paramref name="overwrite"/>was set to false</returns>
        /// <remarks>The LastModifiedTime property of <paramref name="blobProperties"/> is set as a result of this call.
        /// This method also has an effect on the ETag values that are managed by the service.</remarks>
        public abstract bool CreateBlob(BlobProperties blobProperties, BlobContents blobContents, bool overwrite);

        /// <summary>
        /// Updates an existing blob if it has not been modified since the specified time which is typically
        /// the last modified time of the blob when you retrieved it.
        /// Use this method to implement optimistic concurrency by avoiding clobbering changes to the blob
        /// made by another writer.
        /// </summary>
        /// <param name="blob">The properties of the blob. This object should be one previously
        /// obtained from a call to GetBlob or GetBlobProperties and have its LastModifiedTime property set.</param>
        /// <param name="contents">The contents of the blob. The contents of the blob should be readable</param>
        /// <returns>true if the blob was updated. false if the blob has changed since the last time</returns>
        /// <remarks>The LastModifiedTime property of <paramref name="blob"/> is set as a result of this call.
        /// This method also has an effect on the ETag values that are managed by the service if the update was 
        /// successful.</remarks>
        public abstract bool UpdateBlobIfNotModified(BlobProperties blob, BlobContents contents);

        /// <summary>
        /// Get the blob contents and properties if the blob exists
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blobContents">Object in which the contents are returned.
        /// This object should contain a writable stream or should be a default constructed object.</param>
        /// <param name="transferAsChunks">Should the blob be gotten in pieces. This requires more round-trips, but will retry smaller pieces in case of failure.</param>
        /// <returns>The properties of the blob if the blob exists.</returns>
        public abstract BlobProperties GetBlob(string name, BlobContents blobContents, bool transferAsChunks);

        /// <summary>
        /// Gets the blob contents and properties if the blob has not been modified since the time specified.
        /// Use this method if you have cached the contents of a blob and want to avoid retrieving the blob
        /// if it has not changed since the last time you retrieved it.
        /// </summary>
        /// <param name="blobProperties">The properties of the blob obtained from an earlier call to GetBlob. This
        /// parameter is updated by the call if the blob has been modified</param>
        /// <param name="blobContents">Contains the stream to which the contents of the blob are written if it has been
        /// modified</param>
        /// <param name="transferAsChunks">Should the blob be gotten in pieces. This requires more round-trips, but will retry smaller pieces in case of failure.</param>
        /// <returns>true if the blob has been modified, false otherwise</returns>
        public abstract bool GetBlobIfModified(BlobProperties blobProperties, BlobContents blobContents, bool transferAsChunks);

        /// <summary>
        /// Get the properties of the blob if it exists.
        /// This method is also the simplest way to check if a blob exists.
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <returns>The properties of the blob if it exists. null otherwise.
        /// The properties for the contents of the blob are not set</returns>
        public abstract BlobProperties GetBlobProperties(string name);

        /// <summary>
        /// Set the metadata of an existing blob.
        /// </summary>
        /// <param name="blobProperties">The blob properties object whose metadata is to be updated</param>
        public abstract void UpdateBlobMetadata(BlobProperties blobProperties);

        /// <summary>
        /// Set the metadata of an existing blob if it has not been modified since it was last retrieved.
        /// </summary>
        /// <param name="blobProperties">The blob properties object whose metadata is to be updated.
        /// Typically obtained by a previous call to GetBlob or GetBlobProperties</param>
        /// <returns>true if the blob metadata was updated. false if it was not updated because the blob
        /// has been modified</returns>
        public abstract bool UpdateBlobMetadataIfNotModified(BlobProperties blobProperties);
        
        /// <summary>
        /// Delete a blob with the given name
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <returns>true if the blob exists and was successfully deleted, false if the blob does not exist</returns>
        public abstract bool DeleteBlob(string name);

        /// <summary>
        /// Delete a blob with the given name if the blob has not been modified since it was last obtained.
        /// Use this method for optimistic concurrency to avoid deleting a blob that has been modified since
        /// the last time you retrieved it
        /// </summary>
        /// <param name="blob">A blob object (typically previously obtained from a GetBlob call)</param>
        /// <param name="modified">This out parameter is set to true if the blob was not deleted because
        /// it was modified</param>
        /// <returns>true if the blob exists and was successfully deleted, false if the blob does not exist or was
        /// not deleted because the blob was modified.</returns>
        public abstract bool DeleteBlobIfNotModified(BlobProperties blob, out bool modified);

        /// <summary>
        /// Enumerates all blobs with a given prefix.
        /// </summary>
        /// <param name="prefix"></param>
        /// <param name="combineCommonPrefixes">If true common prefixes with "/" as seperator</param>
        /// <returns>The list of blob properties and common prefixes</returns>
        public abstract IEnumerable<object> ListBlobs(string prefix, bool combineCommonPrefixes);

        private Uri    baseUri;
        private string accountName;
        private string containerName;
        private bool usePathStyleUris;
    }

    /// <summary>
    /// The properties of a blob.
    /// No member of this class makes a storage service request.
    /// </summary>
    public class BlobProperties
    {
        /// <summary>
        /// Construct a new BlobProperties object
        /// </summary>
        /// <param name="name">The name of the blob</param>
        public BlobProperties(string name)
        {
            Name = name;
        }


        /// <summary>
        /// Name of the blob
        /// </summary>
        public string Name { get; internal set; }

        /// <summary>
        /// URI of the blob
        /// </summary>
        public Uri Uri { get; internal set; }

        /// <summary>
        /// Content encoding of the blob if it set, null otherwise.
        /// </summary>
        public string ContentEncoding { get; set; }

        /// <summary>
        /// Content Type of the blob if it is set, null otherwise.
        /// </summary>
        public string ContentType { get; set; }

        /// <summary>
        /// Content Language of the blob if it is set, null otherwise.
        /// </summary>
        public string ContentLanguage { get; set; }

        /// <summary>
        /// The length of the blob content, null otherwise.
        /// </summary>
        public long ContentLength { get; internal set; }

        /// <summary>
        /// Metadata for the blob in the form of name-value pairs.
        /// </summary>
        public NameValueCollection Metadata { get; set;}

        /// <summary>
        /// The last modified time for the blob. 
        /// </summary>
        public DateTime LastModifiedTime { get; internal set; }

        /// <summary>
        /// The ETag of the blob. This is an identifier assigned to the blob by the storage service
        /// and is used to distinguish contents of two blobs (or versions of the same blob).
        /// </summary>
        public string ETag { get; internal set; }

        internal void Assign(BlobProperties other)
        {
            Name = other.Name;
            Uri = other.Uri;
            ContentEncoding = other.ContentEncoding;
            ContentLanguage = other.ContentLanguage;
            ContentLength = other.ContentLength;
            ContentType = other.ContentType;
            ETag = other.ETag;
            LastModifiedTime = other.LastModifiedTime;
            Metadata = (other.Metadata != null ? new NameValueCollection(other.Metadata) : null) ;
        }
    }

    /// <summary>
    /// The properties of a container.
    /// No member of this class makes a storage service request.
    /// </summary>
    public class ContainerProperties
    {
        public ContainerProperties(string name)
        {
            Name = name;
        }

        public string Name
        {
            get;
            internal set;
        }
        public DateTime LastModifiedTime
        {
            get;
            internal set;
        }

        public string ETag
        {
            get;
            internal set;
        }

        public Uri Uri
        {
            get;
            internal set;
        }

        public NameValueCollection Metadata
        {
            get;
            internal set;
        }
    }


    /// <summary>
    /// The contents of the Blob in various forms.
    /// </summary>
    public class BlobContents
    {
        /// <summary>
        /// Construct a new BlobContents object from a stream.
        /// </summary>
        /// <param name="stream">The stream to/from which blob contents are written/read. The
        /// stream should be seekable in order for requests to be retried.</param>
        public BlobContents(Stream stream)
        {
            this.stream = stream;
        }

        /// <summary>
        /// Construct a new BlobContents object from a byte array.
        /// </summary>
        /// <param name="value">The byte array to/from which contents are written/read.</param>
        public BlobContents(byte[] value)
        {
            this.bytes = value;
            this.stream = new MemoryStream(value, false);
        }

        /// <summary>
        /// Get the contents of a blob as a stream.
        /// </summary>
        public Stream AsStream
        {
            get
            {
                return stream;
            }

        }

        /// <summary>
        /// Get the contents of a blob as a byte array.
        /// </summary>
        public byte[] AsBytes()
        {
            if (bytes != null)
                return bytes;
            if (stream != null)
            {
                stream.Seek(0, SeekOrigin.Begin);
                bytes = new byte[stream.Length];
                int n = 0;
                int offset = 0;
                do
                {
                    n = stream.Read(bytes, offset, bytes.Length - offset);
                    offset += n;

                } while (n > 0);
            }
            return bytes;
        }

        private Stream stream;
        private byte[] bytes;
    }
    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxWebMonitoringService\IMonitoringService.cs ===
using System.Runtime.Serialization;
using System.ServiceModel;
using Wgx.Services.Monitoring;

namespace WgxWebMonitoringService
{
    // NOTE: If you change the interface name "IService1" here, you must also update the reference to "IService1" in Web.config.
    [ServiceContract]
    public interface IWgxMonitoringService
    {
        [OperationContract]
        DiagnosticDBDataSet.EventsDataTable GetFilteredEventsTable(
            string fromDate, 
            string toDate, 
            string machineName, 
            int machineOperator, 
            string source, 
            int sourceOperator, 
            string eventType, 
            int? messageId, 
            int messageIdOperator, 
            int pageSize, 
            int startRowNum, 
            string sortKey, 
            bool bAscending);
        [OperationContract]
        int GetFilteredEventsRowCount(
            string fromDate, 
            string toDate, 
            string machineName, 
            int machineOperator, 
            string Source, 
            int sourceOperator, 
            string eventType, 
            int? messageId, 
            int messageIdOperator, 
            int pageSize, 
            int startRowNum);
        [OperationContract]
        DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettings();
        [OperationContract]
        DiagnosticDBDataSet.GetSummaryEventsDataTable GetSummaryDataTable(
            string fromDate, 
            string toDate, 
            string machineName, 
            int machineOperator, 
            string source, 
            int sourceOperator, 
            string eventType, 
            int? messageId, 
            int messageIdOperator, 
            string sortKey, 
            bool bAscending);
        [OperationContract]
        void UpdateTraceConfigurationSettings(
            int switchValue, 
            int updateInterval, 
            string switchName, 
            int traceOutputOptions, 
            int PK_TraceConfigSettings);
        [OperationContract]
        DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTable();
        [OperationContract]
        void UpdateListenerConfigurationTable(string ListenerName, int TraceThresholdMask, int TraceOutputOptions, int PK_FilterID);
        [OperationContract]
        void InsertListenerConfigurationTable(string ListenerName, int TraceThreshold, int TraceOutputOptions);
        [OperationContract]
        void InsertTraceConfigurationSettings(
            int switchValue, 
            int updateInterval, 
            string switchName, 
            int traceOutputOptions);
        [OperationContract]
        void DeleteTraceConfigurationSettings(
            int switchValue, 
            int updateInterval, 
            string switchName, 
            int traceOutputOptions, 
            int PK_TraceConfigurationSettings);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxWebMonitoringService\MonitoringService.svc.cs ===
namespace WgxWebMonitoringService
{
    using Wgx.Services.Monitoring;
    using Wgx.Services.Monitoring.DiagnosticDBDataSetTableAdapters;

    public class WgxMonitoringService : IWgxMonitoringService
    {

        public DiagnosticDBDataSet.EventsDataTable GetFilteredEventsTable(
            string fromDate, 
            string toDate, 
            string machineName, 
            int machineOperator, 
            string source, 
            int sourceOperator, 
            string eventType, 
            int? messageId, 
            int messageIdOperator, 
            int pageSize, 
            int startRowNum, 
            string sortKey, 
            bool bAscending)
        {
            EventsTableAdapter adapter = new EventsTableAdapter();
            return adapter.GetFilteredEvents(
                fromDate, 
                toDate, 
                machineName, 
                machineOperator, 
                source, 
                sourceOperator, 
                eventType, 
                messageId, 
                messageIdOperator, 
                startRowNum, 
                pageSize, 
                sortKey, 
                bAscending ? 1 : 0, 
                0);
        }

        public int GetFilteredEventsRowCount(
            string fromDate, 
            string toDate, 
            string machineName, 
            int machineOperator, 
            string source, 
            int sourceOperator, 
            string eventType, 
            int? messageId, 
            int messageIdOperator, 
            int pageSize, 
            int startRowNum)
        {
            EventsTableAdapter adapter = new EventsTableAdapter();
            return (int)adapter.GetFilteredEventsRowCount(
                fromDate, 
                toDate, 
                machineName, 
                machineOperator, 
                source, 
                sourceOperator, 
                eventType, 
                messageId, 
                messageIdOperator, 
                startRowNum, 
                pageSize, 
                null, 
                0, 
                1);
        }

        public DiagnosticDBDataSet.TraceConfigurationSettingsDataTable GetTraceConfigurationSettings()
        {
            TraceConfigurationSettingsTableAdapter adapter = new TraceConfigurationSettingsTableAdapter();
            return adapter.GetData();
        }

        public void UpdateTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions, int PK_TraceConfigSettings)
        {
            TraceConfigurationSettingsTableAdapter adapter = new TraceConfigurationSettingsTableAdapter();
            // retrieve existing settings to disable concurrency check
            DiagnosticDBDataSet.TraceConfigurationSettingsDataTable dt = GetTraceConfigurationSettings(); 
            // retreive row being updated
            DiagnosticDBDataSet.TraceConfigurationSettingsRow row = dt.FindByPK_TraceConfigSettings(PK_TraceConfigSettings);
            adapter.Update(SwitchValue, UpdateInterval, SwitchName, TraceOutputOptions, row.SwitchValue, row.UpdateInterval, row.TraceOutputOptions, row.PK_TraceConfigSettings); 
        }

        public DiagnosticDBDataSet.ListenerFilterDataTable GetListenerConfigurationTable()
        {
            ListenerFilterTableAdapter adapter = new ListenerFilterTableAdapter();
            return adapter.GetData();
        }

        public void UpdateListenerConfigurationTable(string ListenerName, int TraceThresholdMask, int TraceOutputOptions, int PK_FilterID)
        {
            ListenerFilterTableAdapter adapter = new ListenerFilterTableAdapter();
            DiagnosticDBDataSet.ListenerFilterDataTable dt = this.GetListenerConfigurationTable();
            DiagnosticDBDataSet.ListenerFilterRow row = dt.FindByPK_FilterID(PK_FilterID);
            adapter.Update(ListenerName, TraceThresholdMask, TraceOutputOptions, row.TraceThresholdMask, row.TraceOutputOptions, row.PK_FilterID);
        }

        public void InsertListenerConfigurationTable(string ListenerName, int TraceThreshold, int TraceOutputOptions)
        {
            ListenerFilterTableAdapter adapter = new ListenerFilterTableAdapter();
            adapter.Insert(ListenerName, TraceThreshold, TraceOutputOptions);
        }

        public void InsertTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions)
        {
            TraceConfigurationSettingsTableAdapter adapter = new TraceConfigurationSettingsTableAdapter();
            adapter.Insert(SwitchValue, UpdateInterval, SwitchName, TraceOutputOptions);
        }

        public void DeleteTraceConfigurationSettings(int SwitchValue, int UpdateInterval, string SwitchName, int TraceOutputOptions, int PK_TraceConfigurationSettings)
        {
            TraceConfigurationSettingsTableAdapter adapter = new TraceConfigurationSettingsTableAdapter();
            adapter.Delete(SwitchValue, UpdateInterval, TraceOutputOptions, PK_TraceConfigurationSettings);
        }

        public DiagnosticDBDataSet.GetSummaryEventsDataTable GetSummaryDataTable(
            string fromDate, 
            string toDate, 
            string machineName, 
            int machineOperator, 
            string source, 
            int sourceOperator, 
            string eventType, 
            int? messageId, 
            int messageIdOperator, 
            string sortKey, 
            bool bAscending)
        {
            GetSummaryEventsTableAdapter adapter = new GetSummaryEventsTableAdapter();
            return adapter.GetSummaryEvents(
                fromDate, 
                toDate, 
                machineName, 
                machineOperator, 
                source, 
                sourceOperator, 
                eventType, 
                messageId, 
                messageIdOperator, 
                sortKey, 
                bAscending ? 1 : 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\Authentication.cs ===
//
// <copyright file="Authentication.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Collections;
using System.Collections.Specialized;
using System.Net;
using System.Web;
using System.Security.Cryptography;
using System.Globalization;
using System.Diagnostics;


namespace AsyncMultiplayer.Common.AzureStorage
{
    /// <summary>
    /// This type represents the different constituent parts that make up a resource Uri in the context of cloud services.
    /// </summary>
    public class ResourceUriComponents
    {
        /// <summary>
        /// The account name in the URI.
        /// </summary>
        public string AccountName { get; set; }

        /// <summary>
        /// This is really the first component (delimited by '/') after the account name. Since it happens to
        /// be a container name in the context of all our storage services (containers in blob storage,
        /// queues in the queue service and table names in table storage), it's named as ContainerName to make it more 
        /// readable at the cost of slightly being incorrectly named.
        /// </summary>
        public string ContainerName { get; set; }

        /// <summary>
        /// The remaining string in the URI.
        /// </summary>
        public string RemainingPart { get; set; }

        /// <summary>
        /// Construct a ResourceUriComponents object.
        /// </summary>
        /// <param name="accountName">The account name that should become part of the URI.</param>
        /// <param name="containerName">The container name (container, queue or table name) that should become part of the URI.</param>
        /// <param name="remainingPart">Remaining part of the URI.</param>
        public ResourceUriComponents(string accountName, string containerName, string remainingPart)
        {
            this.AccountName = accountName;
            this.ContainerName = containerName;
            this.RemainingPart = remainingPart;
        }

        /// <summary>
        /// Construct a ResourceUriComponents object.        
        /// </summary>
        /// <param name="accountName">The account name that should become part of the URI.</param>
        /// <param name="containerName">The container name (container, queue or table name) that should become part of the URI.</param>
        public ResourceUriComponents(string accountName, string containerName)
            : this(accountName, containerName, null)
        {
        }

        /// <summary>
        /// Construct a ResourceUriComponents object.        
        /// </summary>
        /// <param name="accountName">The account name that should become part of the URI.</param>
        public ResourceUriComponents(string accountName)
            : this(accountName, null, null)
        {
        }

        /// <summary>
        /// Construct a ResourceUriComponents object.        
        /// </summary>
        public ResourceUriComponents()
        {
        }
    }

    internal static class MessageCanonicalizer
    {
        /// <summary>
        /// An internal class that stores the canonicalized string version of an HTTP request.
        /// </summary>
        private class CanonicalizedString
        {
            private StringBuilder canonicalizedString = new StringBuilder();

            /// <summary>
            /// Property for the canonicalized string.
            /// </summary>
            internal string Value
            {
                get
                {
                    return canonicalizedString.ToString();
                }
            }

            /// <summary>
            /// Constructor for the class.
            /// </summary>
            /// <param name="initialElement">The first canonicalized element to start the string with.</param>
            internal CanonicalizedString(string initialElement)
            {
                canonicalizedString.Append(initialElement);
            }

            /// <summary>
            /// Append additional canonicalized element to the string.
            /// </summary>
            /// <param name="element">An additional canonicalized element to append to the string.</param>
            internal void AppendCanonicalizedElement(string element)
            {
                canonicalizedString.Append(StorageHttpConstants.ConstChars.Linefeed);
                canonicalizedString.Append(element);
            }
        }

        /// <summary>
        /// Create a canonicalized string out of HTTP request header contents for signing 
        /// blob/queue requests with the Shared Authentication scheme. 
        /// </summary>
        /// <param name="address">The uri address of the HTTP request.</param>
        /// <param name="uriComponents">Components of the Uri extracted out of the request.</param>
        /// <param name="method">The method of the HTTP request (GET/PUT, etc.).</param>
        /// <param name="contentType">The content type of the HTTP request.</param>
        /// <param name="date">The date of the HTTP request.</param>
        /// <param name="headers">Should contain other headers of the HTTP request.</param>
        /// <returns>A canonicalized string of the HTTP request.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase",
            Justification = "Authentication algorithm requires canonicalization by converting to lower case")]
        internal static string CanonicalizeHttpRequest(
            Uri address, 
            ResourceUriComponents uriComponents, 
            string method, 
            string contentType, 
            string date, 
            NameValueCollection headers)
        {
            // The first element should be the Method of the request.
            // I.e. GET, POST, PUT, or HEAD.
            CanonicalizedString canonicalizedString = new CanonicalizedString(method);

            // The second element should be the MD5 value.
            // This is optional and may be empty.
            string httpContentMD5Value = string.Empty;

            // First extract all the content MD5 values from the header.
            ArrayList httpContentMD5Values = HttpRequestAccessor.GetHeaderValues(headers, StorageHttpConstants.HeaderNames.ContentMD5);

            // If we only have one, then set it to the value we want to append to the canonicalized string.
            if (httpContentMD5Values.Count == 1)
            {
                httpContentMD5Value = (string)httpContentMD5Values[0];
            }

            canonicalizedString.AppendCanonicalizedElement(httpContentMD5Value);

            // The third element should be the content type.
            canonicalizedString.AppendCanonicalizedElement(contentType);

            // The fourth element should be the request date.
            // See if there's an storage date header.
            // If there's one, then don't use the date header.
            ArrayList httpStorageDateValues = HttpRequestAccessor.GetHeaderValues(headers, StorageHttpConstants.HeaderNames.StorageDateTime);
            if (httpStorageDateValues.Count > 0)
            {
                date = null;
            }

            canonicalizedString.AppendCanonicalizedElement(date);

            // Look for header names that start with StorageHttpConstants.HeaderNames.PrefixForStorageHeader
            // Then sort them in case-insensitive manner.
            ArrayList httpStorageHeaderNameArray = new ArrayList();
            foreach (string key in headers.Keys)
            {
                if (key.ToLowerInvariant().StartsWith(StorageHttpConstants.HeaderNames.PrefixForStorageHeader, StringComparison.Ordinal))
                {
                    httpStorageHeaderNameArray.Add(key.ToLowerInvariant());
                }
            }

            httpStorageHeaderNameArray.Sort();

            // Now go through each header's values in the sorted order and append them to the canonicalized string.
            foreach (string key in httpStorageHeaderNameArray)
            {
                StringBuilder canonicalizedElement = new StringBuilder(key);
                string delimiter = ":";
                ArrayList values = HttpRequestAccessor.GetHeaderValues(headers, key);

                // Go through values, unfold them, and then append them to the canonicalized element string.
                foreach (string value in values)
                {
                    // Unfolding is simply removal of CRLF.
                    string unfoldedValue = value.Replace(StorageHttpConstants.ConstChars.CarriageReturnLinefeed, string.Empty);

                    // Append it to the canonicalized element string.
                    canonicalizedElement.Append(delimiter);
                    canonicalizedElement.Append(unfoldedValue);
                    delimiter = ",";
                }

                // Now, add this canonicalized element to the canonicalized header string.
                canonicalizedString.AppendCanonicalizedElement(canonicalizedElement.ToString());
            }

            // Now we append the canonicalized resource element.
            string canonicalizedResource = GetCanonicalizedResource(address, uriComponents);
            canonicalizedString.AppendCanonicalizedElement(canonicalizedResource);

            return canonicalizedString.Value;
        }

        internal static string GetCanonicalizedResource(Uri address, ResourceUriComponents uriComponents)
        {
            // Algorithem is as follows
            // 1. Start with the empty string ("")
            // 2. Append the account name owning the resource preceded by a /. This is not 
            //    the name of the account making the request but the account that owns the 
            //    resource being accessed.
            // 3. Append the path part of the un-decoded HTTP Request-URI, up-to but not 
            //    including the query string.
            // 4. If the request addresses a particular component of a resource, like?comp=
            //    metadata then append the sub-resource including question mark (like ?comp=
            //    metadata)
            StringBuilder canonicalizedResource = new StringBuilder(StorageHttpConstants.ConstChars.Slash);
            canonicalizedResource.Append(uriComponents.AccountName);

            // Note that AbsolutePath starts with a '/'.
            canonicalizedResource.Append(address.AbsolutePath);

            NameValueCollection queryVariables = HttpUtility.ParseQueryString(address.Query);
            string compQueryParameterValue = queryVariables[StorageHttpConstants.QueryParams.QueryParamComp];
            if (compQueryParameterValue != null)
            {
                canonicalizedResource.Append(StorageHttpConstants.ConstChars.QuestionMark);
                canonicalizedResource.Append(StorageHttpConstants.QueryParams.QueryParamComp);
                canonicalizedResource.Append(StorageHttpConstants.QueryParams.SeparatorForParameterAndValue);
                canonicalizedResource.Append(compQueryParameterValue);
            }
            
            return canonicalizedResource.ToString();
        }


        /// <summary>
        /// Canonicalize HTTP header contents.
        /// </summary>
        /// <param name="request">An HttpWebRequest object.</param>
        /// <param name="uriComponents">Components of the Uri extracted out of the request.</param>
        /// <returns>The canonicalized string of the given HTTP request's header.</returns>
        internal static string CanonicalizeHttpRequest(HttpWebRequest request, ResourceUriComponents uriComponents)
        {
            return CanonicalizeHttpRequest(
                request.Address, uriComponents, request.Method, request.ContentType, string.Empty, request.Headers);
        }

        /// <summary>
        /// Creates a standard datetime string for the shared key lite authentication scheme.
        /// </summary>
        /// <param name="dateTime">DateTime value to convert to a string in the expected format.</param>
        /// <returns></returns>
        internal static string ConvertDateTimeToHttpString(DateTime dateTime)
        {
            // On the wire everything should be represented in UTC. This assert will catch invalid callers who
            // are violating this rule.
            Debug.Assert(dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue || dateTime.Kind == DateTimeKind.Utc);

            // 'R' means rfc1123 date which is what the storage services use for all dates...
            // It will be in the following format:
            // Sun, 28 Jan 2008 12:11:37 GMT
            return dateTime.ToString("R", CultureInfo.InvariantCulture);
        }

        private static string AppendStringToCanonicalizedString(StringBuilder canonicalizedString, string stringToAppend)
        {
            canonicalizedString.Append(StorageHttpConstants.ConstChars.Linefeed);
            canonicalizedString.Append(stringToAppend);
            return canonicalizedString.ToString();
        }

        internal static string CanonicalizeHttpRequestForSharedKeyLite(HttpWebRequest request, ResourceUriComponents uriComponents, string date)
        {
            StringBuilder canonicalizedString = new StringBuilder(date);
            AppendStringToCanonicalizedString(canonicalizedString, MessageCanonicalizer.GetCanonicalizedResource(request.Address, uriComponents));

            return canonicalizedString.ToString();
        }
    }

    /// <summary>
    /// Use this class to extract various header values from Http requests.
    /// </summary>
    public static class HttpRequestAccessor
    {
        /// <summary>
        /// A helper function for extracting HTTP header values from a NameValueCollection object.
        /// </summary>
        /// <param name="headers">A NameValueCollection object that should contain HTTP header name-values pairs.</param>
        /// <param name="headerName">Name of the header that we want to get values of.</param>
        /// <returns>A array list of values for the header. The values are in the same order as they are stored in the NameValueCollection object.</returns>
        internal static ArrayList GetHeaderValues(NameValueCollection headers, string headerName)
        {
            ArrayList arrayOfValues = new ArrayList();
            string[] values = headers.GetValues(headerName);

            if (values != null)
            {
                foreach (string value in values)
                {
                    // canonization formula requires the string to be left trimmed.
                    arrayOfValues.Add(value.TrimStart());
                }
            }

            return arrayOfValues;
        }


        /// <summary>
        /// Constructs an URI given all its constituents
        /// </summary>
        /// <param name="endpoint">
        /// This is the service endpoint in case of path-style URIs and a host suffix in case of host-style URIs
        /// IMPORTANT: This does NOT include the service name or account name
        /// </param>
        /// <param name="uriComponents">Uri constituents</param>
        /// <param name="pathStyleUri">Indicates whether to construct a path-style Uri (true) or host-style URI (false)</param>
        /// <returns>Full uri</returns>
        public static Uri ConstructResourceUri(Uri endpoint, ResourceUriComponents uriComponents, bool pathStyleUri)
        {
            return pathStyleUri ? 
                    ConstructPathStyleResourceUri(endpoint, uriComponents) : 
                    ConstructHostStyleResourceUri(endpoint, uriComponents);
        }

        /// <summary>
        /// Constructs a path-style resource URI given all its constituents
        /// </summary>
        private static Uri ConstructPathStyleResourceUri(Uri endpoint, ResourceUriComponents uriComponents)
        {
            StringBuilder path = new StringBuilder(string.Empty);
            if (uriComponents.AccountName != null)
            {
                path.Append(uriComponents.AccountName);

                if (uriComponents.ContainerName != null)
                {
                    path.Append(StorageHttpConstants.ConstChars.Slash);
                    path.Append(uriComponents.ContainerName);

                    if (uriComponents.RemainingPart != null)
                    {
                        path.Append(StorageHttpConstants.ConstChars.Slash);
                        path.Append(uriComponents.RemainingPart);
                    }
                }
            }

            return ConstructUriFromUriAndString(endpoint, path.ToString());
        }

        /// <summary>
        /// Constructs a host-style resource URI given all its constituents
        /// </summary>
        private static Uri ConstructHostStyleResourceUri(Uri hostSuffix, ResourceUriComponents uriComponents)
        {
            if (uriComponents.AccountName == null)
            {
                // When there is no account name, full URI is same as hostSuffix
                return hostSuffix;
            }
            else
            {
                // accountUri will be something like "http://accountname.hostSuffix/" and then we append
                // container name and remaining part if they are present.
                Uri accountUri = ConstructHostStyleAccountUri(hostSuffix, uriComponents.AccountName);
                StringBuilder path = new StringBuilder(string.Empty);
                if (uriComponents.ContainerName != null)
                {
                    path.Append(uriComponents.ContainerName);

                    if (uriComponents.RemainingPart != null)
                    {
                        path.Append(StorageHttpConstants.ConstChars.Slash);
                        path.Append(uriComponents.RemainingPart);
                    }
                }
                
                return ConstructUriFromUriAndString(accountUri, path.ToString());
            }
        }


        /// <summary>
        /// Given the host suffix part, service name and account name, this method constructs the account Uri
        /// </summary>
        private static Uri ConstructHostStyleAccountUri(Uri hostSuffix, string accountName)
        {
            // Example: 
            // Input: serviceEndpoint="http://blob.windows.net/", accountName="youraccount"
            // Output: accountUri="http://youraccount.blob.windows.net/"
            Uri serviceUri = hostSuffix;

            // serviceUri in our example would be "http://blob.windows.net/"
            string accountUriString = string.Format(CultureInfo.InvariantCulture,
                                        "{0}{1}{2}.{3}:{4}/",
                                        serviceUri.Scheme,
                                        Uri.SchemeDelimiter,
                                        accountName,
                                        serviceUri.Host,
                                        serviceUri.Port);

            return new Uri(accountUriString);
        }

        private static Uri ConstructUriFromUriAndString(
            Uri endpoint,
            string path)
        {
            // This is where we encode the url path to be valid
            string encodedPath = HttpUtility.UrlPathEncode(path);
            return new Uri(endpoint, encodedPath);
        }
    }

    /// <summary>
    /// Objects of this class contain the credentials (name and key) of a storage account.
    /// </summary>
    public class SharedKeyCredentials
    {

        /// <summary>
        /// Create a SharedKeyCredentials object given an account name and a shared key.
        /// </summary>
        public SharedKeyCredentials(string accountName, byte[] key)
        {
            this.accountName = accountName;
            this.key = key;
        }

        /// <summary>
        /// Signs the request appropriately to make it an authenticated request.
        /// Note that this method takes the URI components as decoding the URI components requires the knowledge
        /// of whether the URI is in path-style or host-style and a host-suffix if it's host-style.
        /// </summary>
        public void SignRequest(HttpWebRequest request, ResourceUriComponents uriComponents)
        {
            if (request == null)
                throw new ArgumentNullException("request");
            string message = MessageCanonicalizer.CanonicalizeHttpRequest(request, uriComponents);
            string computedBase64Signature = ComputeMacSha(message);
            request.Headers.Add(StorageHttpConstants.HeaderNames.Authorization,
                                string.Format(CultureInfo.InvariantCulture,
                                              "{0} {1}:{2}",
                                              StorageHttpConstants.AuthenticationSchemeNames.SharedKeyAuthSchemeName,
                                              accountName,
                                              computedBase64Signature));
        }

        /// <summary>
        /// Signs requests using the SharedKeyLite authentication scheme with is used for the table storage service.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Lite", 
                                                          Justification = "Name of the authentication scheme in the REST protocol")]        
        public void SignRequestForSharedKeyLite(HttpWebRequest request, ResourceUriComponents uriComponents)
        {
            if (request == null)
            {
                throw new ArgumentNullException("request");
            }

            // add the date header to the request
            string dateString = MessageCanonicalizer.ConvertDateTimeToHttpString(DateTime.UtcNow);
            request.Headers.Add(StorageHttpConstants.HeaderNames.StorageDateTime, dateString);

            // compute the signature and add the authentication scheme
            string message = MessageCanonicalizer.CanonicalizeHttpRequestForSharedKeyLite(request, uriComponents, dateString);
            string computedBase64Signature = ComputeMacSha(message);
            request.Headers.Add(StorageHttpConstants.HeaderNames.Authorization,
                                string.Format(CultureInfo.InvariantCulture,
                                              "{0} {1}:{2}",
                                              StorageHttpConstants.AuthenticationSchemeNames.SharedKeyLiteAuthSchemeName,
                                              accountName,
                                              computedBase64Signature));
        }


        private string ComputeMacSha(string canonicalizedString)
        {
            byte[] dataToMAC = System.Text.Encoding.UTF8.GetBytes(canonicalizedString);

            using (HMACSHA256 hmacsha1 = new HMACSHA256(key))
            {
                return System.Convert.ToBase64String(hmacsha1.ComputeHash(dataToMAC));
            }
        }

        private string accountName;
        private byte[] key;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\Queue.cs ===
//
// <copyright file="Queue.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Configuration;
using System.Collections.Specialized;
using System.Xml;
using System.IO;
using System.Globalization;
using System.Diagnostics.CodeAnalysis;


// disable the generation of warnings for missing documentation elements for 
// public classes/members in this file
#pragma warning disable 1591


namespace AsyncMultiplayer.Common.AzureStorage
{

    /// <summary>
    /// The entry point of the queue storage API
    /// </summary>
    public abstract class QueueStorage
    {
        /// <summary>
        /// Factory method for QueueStorage
        /// </summary>
        /// <param name="baseUri">The base URI of the queue service</param>
        /// <param name="usePathStyleUris">If true, path-style URIs (http://baseuri/accountname/containername/objectname) are used.
        /// If false host-style URIs (http://accountname.baseuri/containername/objectname) are used,
        /// where baseuri is the URI of the service.
        /// If null, the choice is made automatically: path-style URIs if host name part of base URI is an 
        /// IP addres, host-style otherwise.</param>
        /// <param name="accountName">The name of the storage account</param>
        /// <param name="base64Key">Authentication key used for signing requests</param>
        /// <returns>A newly created QueueStorage instance</returns>
        public static QueueStorage Create(Uri baseUri, bool? usePathStyleUris, string accountName, string base64Key)
        {
            return new QueueStorageRest(new StorageAccountInfo(baseUri, usePathStyleUris, accountName, base64Key),null);
        }

        public static QueueStorage Create(StorageAccountInfo accountInfo)
        {
            return new QueueStorageRest(accountInfo, null);
        }


        public static QueueStorage Create(StorageAccountInfo accountInfo,string version)
        {
            return new QueueStorageRest(accountInfo,version);
        }

        /// <summary>
        /// Get a reference to a Queue object with a specified name. This method does not make a call to
        /// the queue service.
        /// </summary>
        /// <param name="queueName">The name of the queue</param>
        /// <returns>A newly created queue object</returns>
        public abstract MessageQueue GetQueue(string queueName);


        /// <summary>
        /// Lists the queues within the account.
        /// </summary>
        /// <returns>A list of queues</returns>
        public virtual IEnumerable<MessageQueue> ListQueues()
        {
            return ListQueues(null);
        }

        /// <summary>
        /// Lists the queues within the account that start with the given prefix.
        /// </summary>
        /// <param name="prefix">If prefix is null returns all queues.</param>
        /// <returns>A list of queues.</returns>
        public abstract IEnumerable<MessageQueue> ListQueues(string prefix);

        /// <summary>
        /// The time out for each request to the storage service.
        /// </summary>
        public TimeSpan Timeout
        {
            get;
            set;
        }

        /// <summary>
        /// The retry policy used for retrying requests
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// The base URI of the blob storage service
        /// </summary>
        public Uri BaseUri
        {
            get
            {
                return AccountInfo.BaseUri;
            }
        }

        /// <summary>
        /// The name of the storage account
        /// </summary>
        public string AccountName
        {
            get
            {
                return AccountInfo.AccountName;
            }
        }

        /// <summary>
        /// Indicates whether to use/generate path-style or host-style URIs
        /// </summary>
        public bool UsePathStyleUris
        {
            get
            {
                return AccountInfo.UsePathStyleUris;
            }
        }

        /// <summary>
        /// The default timeout
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes",
                          Justification = "TimeSpan is a non-mutable type")]
        public static readonly TimeSpan DefaultTimeout = TimeSpan.FromSeconds(30);


        /// <summary>
        /// The default retry policy
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes",
                          Justification = "RetryPolicy is a non-mutable type")]
        public static readonly RetryPolicy DefaultRetryPolicy = RetryPolicies.NoRetry;

        internal protected QueueStorage(StorageAccountInfo accountInfo,string version)
        {
            this.AccountInfo = accountInfo;
            Timeout = DefaultTimeout;
            RetryPolicy = DefaultRetryPolicy;
            Version = version;
        }

        protected QueueStorage(QueueStorage other)
        {
            this.AccountInfo = other.AccountInfo;
            this.Timeout = other.Timeout;
            this.RetryPolicy = other.RetryPolicy;
            this.Version = other.Version;
        }

        internal protected StorageAccountInfo AccountInfo { get; set; }
        internal protected SharedKeyCredentials Credentials { get; set; }
        internal protected string Version { get; set; }
    }

    /// <summary>
    /// Objects of this class represent a single message in the queue.
    /// </summary>
    public class Message
    {

        /// <summary>
        /// The maximum message size in bytes.
        /// </summary>
        public static readonly int MaxMessageSize = 8 * 1024;

        /// <summary>
        /// The maximum amount of time a message is kept in the queue. Max value is 7 days. 
        /// Value is given in seconds.
        /// </summary>
        public static readonly int MaxTimeToLive = 7 * 24 * 60 * 60;

        /// <summary>
        /// This constructor is not publicly exposed.
        /// </summary>
        internal Message()
        {
        }

        /// <summary>
        /// Creates a message and initializes the content of the message to be the specified string.
        /// </summary>
        /// <param name="content">A string representing the contents of the message.</param>
        public Message(string content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            this.content = Encoding.UTF8.GetBytes(content);
        }

        /// <summary>
        /// Creates a message and given the specified byte contents.
        /// In this implementation, regardless of whether an XML or binary data is passed into this 
        /// function, message contents are converted to base64 before passing the data to the queue service.
        /// When calculating the size of the message, the size of the base64 encoding is thus the important
        /// parameter.
        /// </summary>
        /// <param name="content"></param>
        public Message(byte[] content)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (Convert.ToBase64String(content).Length > MaxMessageSize)
            {
                throw new ArgumentException("Message body is too big!");
            }
            this.content = content;
        }


        /// <summary>
        /// A unique ID of the message as returned from queue operations.
        /// </summary>
        public string Id
        {
            get;
            internal set;
        }

        /// <summary>
        /// When a message is retrieved from a queue, a PopReceipt is returned. The PopReceipt is used when 
        /// deleting a message from the queue.
        /// </summary>
        public string PopReceipt
        {
            get;
            internal set;
        }

        /// <summary>
        /// The point in time when the message was put into the queue.
        /// </summary>
        public DateTime InsertionTime
        {
            get;
            internal set;
        }

        /// <summary>
        /// A message's expiration time.
        /// </summary>
        public DateTime ExpirationTime
        {
            get;
            internal set;
        }

        /// <summary>
        /// The point in time when a message becomes visible again after a Get() operation was called 
        /// that returned the message.
        /// </summary>
        public DateTime TimeNextVisible
        {
            get;
            internal set;
        }

        /// <summary>
        /// Returns the the contents of the message as a string.
        /// </summary>
        public string ContentAsString()
        {
            return Encoding.UTF8.GetString(this.content);
        }

        /// <summary>
        /// Returns the content of the message as a byte array
        /// </summary>
        public byte[] ContentAsBytes()
        {
            return content;
        }

        /// <summary>
        /// When calling the Get() operation on a queue, the content of messages 
        /// returned in the REST protocol are represented as Base64-encoded strings.
        /// This internal function transforms the Base64 representation into a byte array.
        /// </summary>
        /// <param name="str">The Base64-encoded string.</param>
        internal void SetContentFromBase64String(string str) {
            if (str == null || str == string.Empty)
            {
                // we got a message with an empty <MessageText> element
                this.content = Encoding.UTF8.GetBytes(string.Empty);
            }
            else
            {
                this.content = Convert.FromBase64String(str);
            }
        }

        /// <summary>
        /// Internal method used for creating the XML that becomes part of a REST request
        /// </summary>
        internal byte[] GetContentXMLRepresentation(out int length)
        {
            length = 0;
            byte[] ret = null;
            StringBuilder builder = new StringBuilder();            
            XmlWriterSettings settings = new XmlWriterSettings();
            settings.OmitXmlDeclaration = true;            
            System.Text.UTF8Encoding enc = new UTF8Encoding(false);            
            using (XmlWriter writer = XmlWriter.Create(builder, settings))
            {
                writer.WriteStartDocument();
                writer.WriteStartElement(StorageHttpConstants.XmlElementNames.QueueMessage);
                writer.WriteStartElement(StorageHttpConstants.XmlElementNames.MessageText);
                writer.WriteRaw(Convert.ToBase64String(content));
                writer.WriteEndElement();
                writer.WriteEndElement();
                writer.WriteEndDocument();
                writer.Flush();
            }
            ret = enc.GetBytes(builder.ToString());          
            if (ret != null)
            {
                length = ret.Length;
            }
            return ret;
        }        

        private byte[] content;
    }

    /// <summary>
    /// Queues in the storage client library expose a functionality for listening for incoming messages. 
    /// If a message is put into a queue, a corresponding event is issued and this delegate is called. This functionality
    /// is implemented internally in this library by periodically polling for incoming messages.
    /// </summary>
    /// <param name="sender">The queue that has received a new event.</param>
    /// <param name="e">The event argument containing the message.</param>
    public delegate void MessageReceivedEventHandler(object sender, MessageReceivedEventArgs e);

    /// <summary>
    /// The argument class for the MessageReceived event.
    /// </summary>
    public class MessageReceivedEventArgs : EventArgs
    {
        /// <summary>
        /// The message itself.
        /// </summary>
        private Message _msg;

        /// <summary>
        /// Constructor for creating a message received argument.
        /// </summary>
        /// <param name="msg"></param>
        public MessageReceivedEventArgs(Message msg)
        {
            if (msg == null)
            {
                throw new ArgumentNullException("msg");
            }
            _msg = msg;
        }

        /// <summary>
        /// The message received by the queue.
        /// </summary>
        public Message Message
        {
            get
            {
                return _msg;
            }
            set
            {
                if (value == null)
                {
                    throw new ArgumentNullException("value");
                }
                _msg = value;
            }
        }
    }

    public class QueueProperties
    {
        /// <summary>
        /// The approximated amount of messages in the queue.
        /// </summary>
        public int ApproximateMessageCount
        {
            get;
            internal set;
        }

        /// <summary>
        /// Metadata for the queue in the form of name-value pairs.
        /// </summary>
        public NameValueCollection Metadata
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Objects of this class represent a queue in a user's storage account.
    /// </summary>
    public abstract class MessageQueue
    {

        /// <summary>
        /// The name of the queue.
        /// </summary>
        private string _name;

        /// <summary>
        /// The user account this queue lives in.
        /// </summary>
        private StorageAccountInfo _account;


        /// <summary>
        /// This constructor is only called by subclasses.
        /// </summary>
        internal protected MessageQueue()
        {
            // queues are generated using factory methods
        }

        internal protected MessageQueue(string name, StorageAccountInfo account)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Queue name cannot be null or empty!");
            }
            if (account == null)
            {
                throw new ArgumentNullException("account");
            }
            if (!Utilities.IsValidContainerOrQueueName(name))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The specified queue name \"{0}\" is not valid!" +
                            "Please choose a name that conforms to the naming conventions for queues!", name));
            }
            _name = name;
            _account = account;
        }

        /// <summary>
        /// The name of the queue exposed as a public property.
        /// </summary>
        public string Name
        {
            get
            {
                return _name;
            }
        }

        /// <summary>
        /// The account info object this queue lives in -- exposed as an internal property.
        /// </summary>
        internal StorageAccountInfo AccountInfo
        {
            get {
                return _account;
            }
        }

        /// <summary>
        /// Indicates whether to use/generate path-style or host-style URIs
        /// </summary>
        public bool UsePathStyleUris
        {
            get
            {
                return _account.UsePathStyleUris;
            }
        }

        /// <summary>
        /// The URI of the queue
        /// </summary>
        public abstract Uri QueueUri
        {
            get;
        }

        /// <summary>
        /// The retry policy used for retrying requests; this is the retry policy of the 
        /// storage account where this queue was created
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// The timeout of requests.
        /// </summary>
        public TimeSpan Timeout
        {
            get;
            set;
        }

        /// <summary>
        /// Creates a queue in the specified storage account.
        /// </summary>
        /// <param name="queueAlreadyExists">true if a queue with the same name already exists.</param>
        /// <returns>true if the queue was successfully created.</returns>
        public abstract bool CreateQueue(out bool queueAlreadyExists);

        /// <summary>
        /// Creates a queue in the specified storage account.
        /// </summary>
        /// <returns>true if the queue was successfully created.</returns>
        public virtual bool CreateQueue()
        {
            bool ignore;
            return CreateQueue(out ignore);
        }


        /// <summary>
        /// Determines whether a queue with the same name already exists in an account.
        /// </summary>
        /// <returns>true if a queue with the same name already exists.</returns>
        public virtual bool DoesQueueExist()
        {
            try
            {
                this.GetProperties();
                return true;
            }
            catch (StorageClientException e)
            {
                if (e.ErrorCode == StorageErrorCode.ResourceNotFound)
                    return false;
                throw;
            }
        }

        /// <summary>
        /// Deletes the queue. The queue will be deleted regardless of whether there are messages in the 
        /// queue or not.
        /// </summary>
        /// <returns>true if the queue was successfully deleted.</returns>
        public abstract bool DeleteQueue();

        /// <summary>
        /// Sets the properties of a queue.
        /// </summary>
        /// <param name="properties">The queue's properties to set.</param>
        /// <returns>true if the properties were successfully written to the queue.</returns>
        public abstract bool SetProperties(QueueProperties properties);

        /// <summary>
        /// Retrieves the queue's properties.
        /// </summary>
        /// <returns>The queue's properties.</returns>
        public abstract QueueProperties GetProperties();

        /// <summary>
        /// Retrieves the approximate number of messages in a queue.
        /// </summary>
        /// <returns>The approximate number of messages in this queue.</returns>
        public abstract int ApproximateCount();

        /// <summary>
        /// Puts a message in the queue.
        /// </summary>
        /// <param name="msg">The message to store in the queue.</param>
        /// <returns>true if the message has been successfully enqueued.</returns>
        public abstract bool PutMessage(Message msg);

        /// <summary>
        /// Puts a message in the queue.
        /// </summary>
        /// <param name="msg">The message to store in the queue.</param>
        /// <param name="timeToLiveInSeconds">The time to live for the message in seconds.</param>
        /// <returns>true if the message has been successfully enqueued.</returns>
        public abstract bool PutMessage(Message msg, int timeToLiveInSeconds);

        /// <summary>
        /// Retrieves a message from the queue. 
        /// </summary>
        /// <returns>The message retrieved or null if the queue is empty.</returns>
        public abstract Message GetMessage();

        /// <summary>
        /// Retrieves a message and sets its visibility timeout to the specified number of seconds.
        /// </summary>
        /// <param name="visibilityTimeoutInSeconds">Visibility timeout of the message retrieved in seconds.</param>
        /// <returns></returns>
        public abstract Message GetMessage(int visibilityTimeoutInSeconds);

        /// <summary>
        /// Tries to retrieve the given number of messages.
        /// </summary>
        /// <param name="numberOfMessages">Maximum number of messages to retrieve.</param>
        /// <returns>The list of messages retrieved.</returns>
        public abstract IEnumerable<Message> GetMessages(int numberOfMessages);

        /// <summary>
        /// Tries to retrieve the given number of messages.
        /// </summary>
        /// <param name="numberOfMessages">Maximum number of messages to retrieve.</param>
        /// <param name="visibilityTimeoutInSeconds">The visibility timeout of the retrieved messages in seconds.</param>
        /// <returns>The list of messages retrieved.</returns>
        public abstract IEnumerable<Message> GetMessages(int numberOfMessages, int visibilityTimeoutInSeconds);

        /// <summary>
        /// Get a message from the queue but do not actually dequeue it. The message will remain visible 
        /// for other parties requesting messages.
        /// </summary>
        /// <returns>The message retrieved or null if there are no messages in the queue.</returns>
        public abstract Message PeekMessage();

        /// <summary>
        /// Tries to get a copy of messages in the queue without actually dequeuing the messages.
        /// The messages will remain visible in the queue.
        /// </summary>
        /// <param name="numberOfMessages">Maximum number of message to retrieve.</param>
        /// <returns>The list of messages retrieved.</returns>
        public abstract IEnumerable<Message> PeekMessages(int numberOfMessages);

        /// <summary>
        /// Deletes a message from the queue.
        /// </summary>
        /// <param name="msg">The message to retrieve with a valid popreceipt.</param>
        /// <returns>true if the operation was successful.</returns>
        public abstract bool DeleteMessage(Message msg);

        /// <summary>
        /// Delete all messages in a queue.
        /// </summary>
        /// <returns>true if all messages were deleted successfully.</returns>
        public abstract bool Clear();

        /// <summary>
        /// The default time interval between polling the queue for messages. 
        /// Polling is only enabled if the user has called StartReceiving().
        /// </summary>
        public static readonly int DefaultPollInterval = 5000;

        /// <summary>
        /// The poll interval in milliseconds. If not explicitly set, this defaults to 
        /// the DefaultPollInterval.
        /// </summary>
        public abstract int PollInterval
        {
            get;
            set;
        }

        /// <summary>
        /// Starts the automatic reception of messages.
        /// </summary>
        /// <returns>true if the operation was successful.</returns>
        public abstract bool StartReceiving();

        /// <summary>
        /// Stop the automatic reception of messages.
        /// </summary>
        public abstract void StopReceiving();

        /// <summary>
        /// The event users subscribe to in order to automatically receive messages
        /// from a queue.
        /// </summary>
        public abstract event MessageReceivedEventHandler MessageReceived;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\Errors.cs ===
//
// <copyright file="Errors.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.IO;
using System.Collections.Generic;
using System.Net;
using System.Collections.Specialized;
using System.Runtime.Serialization;
using System.Security.Permissions;
using System.Diagnostics.CodeAnalysis;
using System.Web;
using System.Linq;
using System.Xml;
using System.Xml.Linq;


// disable the generation of warnings for missing documentation elements for 
// public classes/members in this file
// justification is that this file contains many public constants whose names 
// sufficiently reflect their intended usage 
#pragma warning disable 1591

namespace AsyncMultiplayer.Common.AzureStorage
{
    /// <summary>
    /// Error codes that can be returned by the storage service or the client library.
    /// These are divided into server errors and client errors depending on which side
    /// the error can be attributed to.
    /// </summary>
    public enum StorageErrorCode
    {
        None = 0,

        //Server errors
        ServiceInternalError = 1,
        ServiceTimeout,
        ServiceIntegrityCheckFailed,
        TransportError,
        ServiceBadResponse,

        //Client errors
        ResourceNotFound,
        AccountNotFound,
        ContainerNotFound,
        BlobNotFound,
        AuthenticationFailure,
        AccessDenied,
        ResourceAlreadyExists,
        ContainerAlreadyExists,
        BlobAlreadyExists,
        BadRequest,
        ConditionFailed,
        BadGateway
    }

    [Serializable]
    public class StorageExtendedErrorInformation
    {
        public string ErrorCode { get; internal set; }
        public string ErrorMessage { get; internal set; }
        public NameValueCollection AdditionalDetails { get; internal set; }
    }

    /// <summary>
    /// The base class for storage service exceptions
    /// </summary>
    [Serializable]
    public abstract class StorageException : Exception
    {
        /// <summary>
        /// The Http status code returned by the storage service
        /// </summary>
        public HttpStatusCode StatusCode { get; private set; }

        /// <summary>
        /// The specific error code returned by the storage service
        /// </summary>
        public StorageErrorCode ErrorCode { get; private set; }

        /// <summary>
        /// 
        /// </summary>
        public StorageExtendedErrorInformation ExtendedErrorInformation { get; private set; }

        protected StorageException()
        {
        }

        protected StorageException(
            StorageErrorCode errorCode,
            string message,
            HttpStatusCode statusCode,
            StorageExtendedErrorInformation extendedErrorInfo,
            Exception innerException
            )
            : base(message, innerException)
        {
            this.ErrorCode = errorCode;
            this.StatusCode = statusCode;
            this.ExtendedErrorInformation = extendedErrorInfo;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="StorageException"/> class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> object that contains serialized object
        /// data about the exception being thrown</param>
        /// <param name="context">The <see cref="StreamingContext"/> object that contains contextual information
        /// about the source or destionation. </param>
        protected StorageException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            if (null == info)
            {
                throw new ArgumentNullException("info");
            }

            this.StatusCode = (HttpStatusCode)info.GetValue("StatusCode", typeof(HttpStatusCode));
            this.ErrorCode = (StorageErrorCode)info.GetValue("ErrorCode", typeof(StorageErrorCode));
            this.ExtendedErrorInformation = (StorageExtendedErrorInformation)info.GetValue(
                        "ExtendedErrorInformation", typeof(StorageExtendedErrorInformation));
        }

        /// <summary>
        /// Sets the <see cref="SerializationInfo"/> object with additional exception information
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> object that holds the 
        /// serialized object data.</param>
        /// <param name="context">The <see cref="StreamingContext"/> object that contains contextual information
        /// about the source or destionation. </param>
        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            if (null == info)
            {
                throw new ArgumentNullException("info");
            }

            info.AddValue("StatusCode", this.StatusCode);
            info.AddValue("ErrorCode", this.ErrorCode);
            info.AddValue("ExtendedErrorInformation", this.ExtendedErrorInformation);
            base.GetObjectData(info, context);
        }

    }

    /// <summary>
    /// Server exceptions are those due to server side problems.
    /// These may be transient and requests resulting in such exceptions
    /// can be retried with the same parameters.
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors",
        Justification = "Since this exception comes from the server, there must be an HTTP response code associated with it, hence we exclude the default constructor taking only a string but no status code.")]
    [Serializable]
    public class StorageServerException : StorageException
    {
        internal StorageServerException(
            StorageErrorCode errorCode,
            string message,
            HttpStatusCode statusCode,
            Exception innerException
            )
            : base(errorCode, message, statusCode, null, innerException)
        {
        }

        internal StorageServerException(
            StorageErrorCode errorCode,
            string message,
            HttpStatusCode statusCode,
            StorageExtendedErrorInformation extendedErrorInfo,
            Exception innerException
            )
            : base(errorCode, message, statusCode, extendedErrorInfo, innerException)
        {
        }


        /// <summary>
        /// Initializes a new instance of the <see cref="StorageServerException"/> class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> object that contains serialized object
        /// data about the exception being thrown</param>
        /// <param name="context">The <see cref="StreamingContext"/> object that contains contextual information
        /// about the source or destionation. </param>
        protected StorageServerException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public StorageServerException()
        {
        }
    }

    /// <summary>
    /// Client side exceptions are due to incorrect parameters to the request.
    /// These requests should not be retried with the same parameters
    /// </summary>
    [SuppressMessage("Microsoft.Design", "CA1032:ImplementStandardExceptionConstructors",
        Justification = "Since this exception comes from the server, there must be an HTTP response code associated with it, hence we exclude the default constructor taking only a string but no status code.")]
    [Serializable]
    public class StorageClientException : StorageException
    {
        internal StorageClientException(
            StorageErrorCode errorCode,
            string message,
            HttpStatusCode statusCode,
            StorageExtendedErrorInformation extendedErrorInfo,
            Exception innerException
            )
            : base(errorCode, message, statusCode, extendedErrorInfo, innerException)
        {
        }


        /// <summary>
        /// Initializes a new instance of the <see cref="StorageClientException"/> class with
        /// serialized data.
        /// </summary>
        /// <param name="info">The <see cref="SerializationInfo"/> object that contains serialized object
        /// data about the exception being thrown</param>
        /// <param name="context">The <see cref="StreamingContext"/> object that contains contextual information
        /// about the source or destionation. </param>
        protected StorageClientException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

        public StorageClientException()
        {
        }

    }

    #region Error code strings that can be returned in the StorageExtendedErrorInformation.ErrorCode
    /// <summary>
    /// Error code strings that are common to all storage services
    /// </summary>
    public static class StorageErrorCodeStrings
    {
        public const string UnsupportedHttpVerb = "UnsupportedHttpVerb";
        public const string MissingContentLengthHeader = "MissingContentLengthHeader";
        public const string MissingRequiredHeader = "MissingRequiredHeader";
        public const string MissingRequiredXmlNode = "MissingRequiredXmlNode";
        public const string UnsupportedHeader = "UnsupportedHeader";
        public const string UnsupportedXmlNode = "UnsupportedXmlNode";
        public const string InvalidHeaderValue = "InvalidHeaderValue";
        public const string InvalidXmlNodeValue = "InvalidXmlNodeValue";
        public const string MissingRequiredQueryParameter = "MissingRequiredQueryParameter";
        public const string UnsupportedQueryParameter = "UnsupportedQueryParameter";
        public const string InvalidQueryParameterValue = "InvalidQueryParameterValue";
        public const string OutOfRangeQueryParameterValue = "OutOfRangeQueryParameterValue";
        public const string InvalidUri = "InvalidUri";
        public const string InvalidHttpVerb = "InvalidHttpVerb";
        public const string EmptyMetadataKey = "EmptyMetadataKey";
        public const string RequestBodyTooLarge = "RequestBodyTooLarge";
        public const string InvalidXmlDocument = "InvalidXmlDocument";
        public const string InternalError = "InternalError";
        public const string AuthenticationFailed = "AuthenticationFailed";
        public const string Md5Mismatch = "Md5Mismatch";
        public const string InvalidMd5 = "InvalidMd5";
        public const string OutOfRangeInput = "OutOfRangeInput";
        public const string InvalidInput = "InvalidInput";
        public const string OperationTimedOut = "OperationTimedOut";
        public const string ResourceNotFound = "ResourceNotFound";
        public const string InvalidMetadata = "InvalidMetadata";
        public const string MetadataTooLarge = "MetadataTooLarge";
        public const string ConditionNotMet = "ConditionNotMet";
        public const string InvalidRange = "InvalidRange";
        public const string ContainerNotFound = "ContainerNotFound";
        public const string ContainerAlreadyExists = "ContainerAlreadyExists";
        public const string ContainerDisabled = "ContainerDisabled";
        public const string ContainerBeingDeleted = "ContainerBeingDeleted";
        public const string ServerBusy = "ServerBusy";
    }

    /// <summary>
    /// Error code strings that are specific to blob service
    /// </summary>
    public static class BlobErrorCodeStrings
    {
        public const string InvalidBlockId = "InvalidBlockId";
        public const string BlobNotFound = "BlobNotFound";
        public const string BlobAlreadyExists = "BlobAlreadyExists";
        public const string InvalidBlobOrBlock = "InvalidBlobOrBlock";
        public const string InvalidBlockList = "InvalidBlockList";
    }

    /// <summary>
    /// Error code strings that are specific to queue service
    /// </summary>
    public static class QueueErrorCodeStrings
    {
        public const string QueueNotFound = "QueueNotFound";
        public const string QueueDisabled = "QueueDisabled";
        public const string QueueAlreadyExists = "QueueAlreadyExists";
        public const string QueueNotEmpty = "QueueNotEmpty";
        public const string QueueBeingDeleted = "QueueBeingDeleted";
        public const string PopReceiptMismatch = "PopReceiptMismatch";
        public const string InvalidParameter = "InvalidParameter";
        public const string MessageNotFound = "MessageNotFound";
        public const string MessageTooLarge = "MessageTooLarge";
        public const string InvalidMarker = "InvalidMarker";
    }

    /// <summary>
    /// Error code strings that are specific to queue service
    /// </summary>
    ///     public static class TableErrorCodeStrings
    public static class TableErrorCodeStrings
    {
        public const string XMethodNotUsingPost = "XMethodNotUsingPost";
        public const string XMethodIncorrectValue = "XMethodIncorrectValue";
        public const string XMethodIncorrectCount = "XMethodIncorrectCount";

        public const string TableHasNoProperties = "TableHasNoProperties";
        public const string DuplicatePropertiesSpecified = "DuplicatePropertiesSpecified";
        public const string TableHasNoSuchProperty = "TableHasNoSuchProperty";
        public const string DuplicateKeyPropertySpecified = "DuplicateKeyPropertySpecified";
        public const string TableAlreadyExists = "TableAlreadyExists";
        public const string TableNotFound = "TableNotFound";
        public const string EntityNotFound = "EntityNotFound";
        public const string EntityAlreadyExists = "EntityAlreadyExists";
        public const string PartitionKeyNotSpecified = "PartitionKeyNotSpecified";
        public const string OperatorInvalid = "OperatorInvalid";
        public const string UpdateConditionNotSatisfied = "UpdateConditionNotSatisfied";
        public const string PropertiesNeedValue = "PropertiesNeedValue";

        public const string PartitionKeyPropertyCannotBeUpdated = "PartitionKeyPropertyCannotBeUpdated";
        public const string TooManyProperties = "TooManyProperties";
        public const string EntityTooLarge = "EntityTooLarge";
        public const string PropertyValueTooLarge = "PropertyValueTooLarge";
        public const string InvalidValueType = "InvalidValueType";
        public const string TableBeingDeleted = "TableBeingDeleted";
        public const string TableServerOutOfMemory = "TableServerOutOfMemory";
        public const string PrimaryKeyPropertyIsInvalidType = "PrimaryKeyPropertyIsInvalidType";
        public const string PropertyNameTooLong = "PropertyNameTooLong";
        public const string PropertyNameInvalid = "PropertyNameInvalid";

        public const string BatchOperationNotSupported = "BatchOperationNotSupported";
        public const string JsonFormatNotSupported = "JsonFormatNotSupported";
        public const string MethodNotAllowed = "MethodNotAllowed";
        public const string NotImplemented = "NotImplemented";
    }
    #endregion

    #region Helper functions dealing with errors
    internal static partial class Utilities
    {
        internal static void ProcessUnexpectedStatusCode(HttpWebResponse response)
        {
            throw new StorageServerException(
                        StorageErrorCode.ServiceBadResponse,
                        response.StatusDescription,
                        response.StatusCode,
                        null
                        );
        }

        internal static Exception TranslateWebException(Exception e)
        {
            WebException we = e as WebException;
            if (null == we)
            {
                return e;
            }

            // If the response is not null, let's first see what the status code is.
            if (we.Response != null)
            {
                HttpWebResponse response = ((HttpWebResponse)we.Response);

                StorageExtendedErrorInformation extendedError =
                    GetExtendedErrorDetailsFromResponse(
                            response.GetResponseStream(),
                            response.ContentLength
                            );
                Exception translatedException = null;
                if (extendedError != null)
                {
                    translatedException = TranslateExtendedError(
                                                    extendedError,
                                                    response.StatusCode,
                                                    response.StatusDescription,
                                                    e);
                    if (translatedException != null)
                        return translatedException;
                }
                translatedException = TranslateFromHttpStatus(
                                            response.StatusCode,
                                            response.StatusDescription,
                                            extendedError,
                                            we
                                            );
                if (translatedException != null)
                    return translatedException;

            }

            switch (we.Status)
            {
                case WebExceptionStatus.RequestCanceled:
                    return new StorageServerException(
                        StorageErrorCode.ServiceTimeout,
                        "The server request did not complete within the specified timeout",
                        HttpStatusCode.GatewayTimeout,
                        we);

                case WebExceptionStatus.ConnectFailure:
                    return we;

                default:
                    return new StorageServerException(
                        StorageErrorCode.ServiceInternalError,
                        "The server encountered an unknown failure: " + e.Message,
                        HttpStatusCode.InternalServerError,
                        we
                        );
            }
        }

        internal static Exception TranslateFromHttpStatus(
                    HttpStatusCode statusCode,
                    string statusDescription,
                    StorageExtendedErrorInformation details,
                    Exception inner
                    )
        {
            switch (statusCode)
            {
                case HttpStatusCode.Forbidden:
                    return new StorageClientException(
                        StorageErrorCode.AccessDenied,
                        statusDescription,
                        HttpStatusCode.Forbidden,
                        details,
                        inner
                        );

                case HttpStatusCode.Gone:
                case HttpStatusCode.NotFound:
                    return new StorageClientException(
                        StorageErrorCode.ResourceNotFound,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );

                case HttpStatusCode.BadRequest:
                    return new StorageClientException(
                        StorageErrorCode.BadRequest,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );

                case HttpStatusCode.PreconditionFailed:
                case HttpStatusCode.NotModified:
                    return new StorageClientException(
                        StorageErrorCode.BadRequest,
                        statusDescription,
                        statusCode,
                        details,
                        inner);

                case HttpStatusCode.Conflict:
                    return new StorageClientException(
                        StorageErrorCode.ResourceAlreadyExists,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );

                case HttpStatusCode.GatewayTimeout:
                    return new StorageServerException(
                        StorageErrorCode.ServiceTimeout,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );

                case HttpStatusCode.RequestedRangeNotSatisfiable:
                    return new StorageClientException(
                        StorageErrorCode.BadRequest,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );

                case HttpStatusCode.InternalServerError:
                    return new StorageServerException(
                        StorageErrorCode.ServiceInternalError,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );

                case HttpStatusCode.BadGateway:
                    return new StorageServerException(
                        StorageErrorCode.BadGateway,
                        statusDescription,
                        statusCode,
                        details,
                        inner
                        );
            }
            return null;
        }

        private static Exception TranslateExtendedError(
                    StorageExtendedErrorInformation details,
                    HttpStatusCode statusCode,
                    string statusDescription,
                    Exception inner
                    )
        {
            StorageErrorCode errorCode = default(StorageErrorCode);
            switch (details.ErrorCode)
            {
                case StorageErrorCodeStrings.UnsupportedHttpVerb:
                case StorageErrorCodeStrings.MissingContentLengthHeader:
                case StorageErrorCodeStrings.MissingRequiredHeader:
                case StorageErrorCodeStrings.UnsupportedHeader:
                case StorageErrorCodeStrings.InvalidHeaderValue:
                case StorageErrorCodeStrings.MissingRequiredQueryParameter:
                case StorageErrorCodeStrings.UnsupportedQueryParameter:
                case StorageErrorCodeStrings.InvalidQueryParameterValue:
                case StorageErrorCodeStrings.OutOfRangeQueryParameterValue:
                case StorageErrorCodeStrings.InvalidUri:
                case StorageErrorCodeStrings.InvalidHttpVerb:
                case StorageErrorCodeStrings.EmptyMetadataKey:
                case StorageErrorCodeStrings.RequestBodyTooLarge:
                case StorageErrorCodeStrings.InvalidXmlDocument:
                case StorageErrorCodeStrings.InvalidXmlNodeValue:
                case StorageErrorCodeStrings.MissingRequiredXmlNode:
                case StorageErrorCodeStrings.InvalidMd5:
                case StorageErrorCodeStrings.OutOfRangeInput:
                case StorageErrorCodeStrings.InvalidInput:
                case StorageErrorCodeStrings.InvalidMetadata:
                case StorageErrorCodeStrings.MetadataTooLarge:
                case StorageErrorCodeStrings.InvalidRange:
                    errorCode = StorageErrorCode.BadRequest;
                    break;
                case StorageErrorCodeStrings.AuthenticationFailed:
                    errorCode = StorageErrorCode.AuthenticationFailure;
                    break;
                case StorageErrorCodeStrings.ResourceNotFound:
                    errorCode = StorageErrorCode.ResourceNotFound;
                    break;
                case StorageErrorCodeStrings.ConditionNotMet:
                    errorCode = StorageErrorCode.ConditionFailed;
                    break;
                case StorageErrorCodeStrings.ContainerAlreadyExists:
                    errorCode = StorageErrorCode.ContainerAlreadyExists;
                    break;
                case StorageErrorCodeStrings.ContainerNotFound:
                    errorCode = StorageErrorCode.ContainerNotFound;
                    break;
                case BlobErrorCodeStrings.BlobNotFound:
                    errorCode = StorageErrorCode.BlobNotFound;
                    break;
                case BlobErrorCodeStrings.BlobAlreadyExists:
                    errorCode = StorageErrorCode.BlobAlreadyExists;
                    break;
            }

            if (errorCode != default(StorageErrorCode))
                return new StorageClientException(
                                errorCode,
                                statusDescription,
                                statusCode,
                                details,
                                inner
                                );

            switch (details.ErrorCode)
            {
                case StorageErrorCodeStrings.InternalError:
                case StorageErrorCodeStrings.ServerBusy:
                    errorCode = StorageErrorCode.ServiceInternalError;
                    break;
                case StorageErrorCodeStrings.Md5Mismatch:
                    errorCode = StorageErrorCode.ServiceIntegrityCheckFailed;
                    break;
                case StorageErrorCodeStrings.OperationTimedOut:
                    errorCode = StorageErrorCode.ServiceTimeout;
                    break;
            }
            if (errorCode != default(StorageErrorCode))
                return new StorageServerException(
                                errorCode,
                                statusDescription,
                                statusCode,
                                details,
                                inner
                                );



            return null;
        }


        // This is the limit where we allow for the error message returned by the server.
        // Message longer than that will be truncated. 
        private const int ErrorTextSizeLimit = 8 * 1024;

        private static StorageExtendedErrorInformation GetExtendedErrorDetailsFromResponse(
            Stream httpResponseStream,
            long contentLength
            )
        {
            try
            {
                int bytesToRead = (int)Math.Max((long)contentLength, (long)ErrorTextSizeLimit);
                byte[] responseBuffer = new byte[bytesToRead];
                int bytesRead = CopyStreamToBuffer(httpResponseStream, responseBuffer, (int)bytesToRead);
                return GetErrorDetailsFromStream(
                            new MemoryStream(responseBuffer, 0, bytesRead, false)
                            );
            }
            catch (WebException)
            {
                //Ignore network errors when reading error details.
                return null;
            }
            catch (IOException)
            {
                return null;
            }
            catch (TimeoutException)
            {
                return null;
            }
        }

        private static StorageExtendedErrorInformation GetErrorDetailsFromStream(
            Stream inputStream
            )
        {
            StorageExtendedErrorInformation extendedError = new StorageExtendedErrorInformation();
            try
            {
                using (XmlReader reader = XmlReader.Create(inputStream))
                {
                    reader.Read();
                    reader.ReadStartElement(StorageHttpConstants.XmlElementNames.ErrorRootElement);
                    extendedError.ErrorCode = reader.ReadElementString(StorageHttpConstants.XmlElementNames.ErrorCode);
                    extendedError.ErrorMessage = reader.ReadElementString(StorageHttpConstants.XmlElementNames.ErrorMessage);
                    extendedError.AdditionalDetails = new NameValueCollection();

                    // After error code and message we can have a number of additional details optionally followed
                    // by ExceptionDetails element - we'll read all of these into the additionalDetails collection
                    do
                    {
                        if (reader.IsStartElement())
                        {
                            if (string.Compare(reader.LocalName, StorageHttpConstants.XmlElementNames.ErrorException, StringComparison.Ordinal) == 0)
                            {
                                // Need to read exception details - we have message and stack trace
                                reader.ReadStartElement(StorageHttpConstants.XmlElementNames.ErrorException);
                                extendedError.AdditionalDetails.Add(StorageHttpConstants.XmlElementNames.ErrorExceptionMessage,
                                    reader.ReadElementString(StorageHttpConstants.XmlElementNames.ErrorExceptionMessage));
                                extendedError.AdditionalDetails.Add(StorageHttpConstants.XmlElementNames.ErrorExceptionStackTrace,
                                    reader.ReadElementString(StorageHttpConstants.XmlElementNames.ErrorExceptionStackTrace));
                                reader.ReadEndElement();
                            }
                            else
                            {
                                string elementName = reader.LocalName;
                                extendedError.AdditionalDetails.Add(elementName, reader.ReadString());
                            }
                        }
                    }
                    while (reader.Read());
                }
            }
            catch (XmlException)
            {
                //If there is a parsing error we cannot return extended error information
                return null;
            }
            return extendedError;
        }

        internal static StorageExtendedErrorInformation GetExtendedErrorFromXmlMessage(string xmlErrorMessage)
        {
            string message = null;
            string errorCode = null;

            XName xnErrorCode = XName.Get(StorageHttpConstants.XmlElementNames.TableErrorCodeElement,
                StorageHttpConstants.XmlElementNames.DataWebMetadataNamespace);
            XName xnMessage = XName.Get(StorageHttpConstants.XmlElementNames.TableErrorMessageElement,
                StorageHttpConstants.XmlElementNames.DataWebMetadataNamespace);

            using (StringReader reader = new StringReader(xmlErrorMessage))
            {
                XDocument xDocument = null;
                try
                {
                    xDocument = XDocument.Load(reader);
                }
                catch (XmlException)
                {
                    // The XML could not be parsed. This could happen either because the connection 
                    // could not be made to the server, or if the response did not contain the
                    // error details (for example, if the response status code was neither a failure
                    // nor a success, but a 3XX code such as NotModified.
                    return null;
                }

                XElement errorCodeElement =
                    xDocument.Descendants(xnErrorCode).FirstOrDefault();

                if (errorCodeElement == null)
                    return null;

                errorCode = errorCodeElement.Value;

                XElement messageElement =
                    xDocument.Descendants(xnMessage).FirstOrDefault();

                if (messageElement != null)
                {
                    message = messageElement.Value;
                }

            }

            StorageExtendedErrorInformation errorDetails = new StorageExtendedErrorInformation();
            errorDetails.ErrorMessage = message;
            errorDetails.ErrorCode = errorCode;
            return errorDetails;
        }
    }


    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Monitoring\WgxWebMonitoringService\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
#if (!RAZZLE_BUILD)
[assembly: AssemblyTitle("WgxWebMonitoringService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Microsoft")]
[assembly: AssemblyProduct("WgxWebMonitoringService")]
[assembly: AssemblyCopyright("Copyright  Microsoft 2009")]
[assembly: AssemblyTrademark("")]
#endif
[assembly: AssemblyCulture("")]
#if (!RAZZLE_BUILD)
// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f46f845b-f1c4-47c6-ab72-8b52a7ef3a78")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\StorageAccountInfo.cs ===
//
// <copyright file="StorageAccountInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Globalization;
using System.Configuration;
using System.Collections.Specialized;
using System.Diagnostics;
using Microsoft.ServiceHosting.ServiceRuntime;

namespace AsyncMultiplayer.Common.AzureStorage
{
    /// <summary>
    /// Objects of this class encapsulate information about a storage account and endpoint configuration. 
    /// Associated with a storage account is the account name, the base URI of the account and a shared key. 
    /// </summary>
    public class StorageAccountInfo
    {

        /// <summary>
        /// The default configuration string in configuration files for setting the queue storage endpoint.
        /// </summary>
        public static readonly string DefaultQueueStorageEndpointConfigurationString = "QueueStorageEndpoint";

        /// <summary>
        /// The default configuration string in configuration files for setting the blob storage endpoint.
        /// </summary>
        public static readonly string DefaultBlobStorageEndpointConfigurationString = "BlobStorageEndpoint";

        /// <summary>
        /// The default configuration string in configuration files for setting the table storage endpoint.
        /// </summary>
        public static readonly string DefaultTableStorageEndpointConfigurationString = "TableStorageEndpoint";

        /// <summary>
        /// The default configuration string in configuration files for setting the storage account name.
        /// </summary>
        public static readonly string DefaultAccountNameConfigurationString = "AccountName";

        /// <summary>
        /// The default configuration string in configuration files for setting the shared key associated with a storage account.
        /// </summary>
        public static readonly string DefaultAccountSharedKeyConfigurationString = "AccountSharedKey";

        /// <summary>
        /// The default configuration string in configuration files for setting the UsePathStyleUris option.
        /// </summary>
        public static readonly string DefaultUsePathStyleUrisConfigurationString = "UsePathStyleUris";

        /// <summary>
        /// The default prefix string in application config and Web.config files to indicate that this setting should be looked up 
        /// in the fabric's configuration system.
        /// </summary>
        public static readonly string CSConfigStringPrefix = "CSConfigName";

        private bool? _usePathStyleUris;

        /// <summary>
        /// Constructor for creating account info objects.
        /// </summary>
        /// <param name="baseUri">The account's base URI.</param>
        /// <param name="usePathStyleUris">If true, path-style URIs (http://baseuri/accountname/containername/objectname) are used.
        /// If false host-style URIs (http://accountname.baseuri/containername/objectname) are used,
        /// where baseuri is the URI of the service..
        /// If null, the choice is made automatically: path-style URIs if host name part of base URI is an 
        /// IP addres, host-style otherwise.</param>
        /// <param name="accountName">The account name.</param>
        /// <param name="base64Key">The account's shared key.</param>
        public StorageAccountInfo(Uri baseUri, bool? usePathStyleUris, string accountName, string base64Key)
            : this(baseUri, usePathStyleUris, accountName, base64Key, false)
        { 
        }

        /// <summary>
        /// Constructor for creating account info objects.
        /// </summary>
        /// <param name="baseUri">The account's base URI.</param>
        /// <param name="usePathStyleUris">If true, path-style URIs (http://baseuri/accountname/containername/objectname) are used.
        /// If false host-style URIs (http://accountname.baseuri/containername/objectname) are used,
        /// where baseuri is the URI of the service.
        /// If null, the choice is made automatically: path-style URIs if host name part of base URI is an 
        /// IP addres, host-style otherwise.</param>
        /// <param name="accountName">The account name.</param>
        /// <param name="base64Key">The account's shared key.</param>
        /// <param name="allowIncompleteSettings">true if it shall be allowed to only set parts of the StorageAccountInfo properties.</param>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
        public StorageAccountInfo(Uri baseUri, bool? usePathStyleUris, string accountName, string base64Key, bool allowIncompleteSettings)
        {
            if (baseUri == null && !allowIncompleteSettings)
            {
                throw new ArgumentNullException("baseUri");
            }
            if (string.IsNullOrEmpty(base64Key) && !allowIncompleteSettings)
            {
                throw new ArgumentNullException("base64Key");
            }
            if (baseUri != null) 
            {
                string newAccountName = null;
                Uri newBaseUri = null;
                if (IsStandardStorageEndpoint(baseUri, out newAccountName, out newBaseUri)) {
                    if (!string.IsNullOrEmpty(newAccountName) && 
                        !string.IsNullOrEmpty(accountName) &&
                        string.Compare(accountName, newAccountName, StringComparison.Ordinal) != 0)
                    {
                        throw new ArgumentException("The configured base URI " + baseUri.AbsoluteUri + " for the storage service is incorrect. " + 
                                                    "The configured account name " + accountName + " must match the account name " + newAccountName +
                                                    " as specified in the storage service base URI." +
                                                     GeneralAccountConfigurationExceptionString);
                    }
                    Debug.Assert((newBaseUri == null && newAccountName == null) || (newBaseUri != null && newAccountName != null));
                    if (newAccountName != null && newBaseUri != null) {
                        accountName = newAccountName;
                        baseUri = newBaseUri;
                    }
                }
            }
            if (string.IsNullOrEmpty(accountName) && !allowIncompleteSettings)
            {
                throw new ArgumentNullException("accountName");
            }
            if (!string.IsNullOrEmpty(accountName) && accountName.ToLowerInvariant() != accountName) {
                throw new ArgumentException("The account name must not contain upper-case letters. " + 
                                "The account name is the first part of the URL for accessing the storage services as presented to you by the portal or " +
                                "the predefined storage account name when using the development storage tool. " + 
                                GeneralAccountConfigurationExceptionString);
            }

            BaseUri = baseUri;
            AccountName = accountName;
            Base64Key = base64Key;
            if (usePathStyleUris == null && baseUri == null && !allowIncompleteSettings) {
                throw new ArgumentException("Cannot determine setting from empty URI.");
            }
            else if (usePathStyleUris == null)
            {
                if (baseUri != null)
                {
                    _usePathStyleUris = Utilities.StringIsIPAddress(baseUri.Host);
                }
                else
                {
                    _usePathStyleUris = null;
                }
            }
            else
            {
                UsePathStyleUris = usePathStyleUris.Value;
            }
        }

        /// <summary>
        /// The base URI of the account.
        /// </summary>
        public Uri BaseUri
        {
            get;
            set;
        }

        /// <summary>
        /// The account name.
        /// </summary>
        public string AccountName
        {
            get;
            set;
        }

        /// <summary>
        /// The account's key.
        /// </summary>
        public string Base64Key
        {
            get;
            set;
        }

        /// <summary>
        /// If set, returns the UsePathStyleUris properties. If the property has not been explicitly set, 
        /// the implementation tries to derive the correct value from the base URI.
        /// </summary>
        public bool UsePathStyleUris
        {
            get
            {
                if (_usePathStyleUris == null)
                {
                    if (BaseUri == null)
                    {
                        return false;
                    }
                    else
                    {
                        return Utilities.StringIsIPAddress(BaseUri.Host);
                    }
                }
                else
                {
                    return _usePathStyleUris.Value;
                }
            }
            set {
                _usePathStyleUris = value;
            }
        }

        /// <summary>
        /// Retrieves account settings for the queue service from the default settings. 
        /// </summary>
        public static StorageAccountInfo GetDefaultQueueStorageAccountFromConfiguration(bool allowIncompleteSettings)
        {
            return GetAccountInfoFromConfiguration(DefaultQueueStorageEndpointConfigurationString, allowIncompleteSettings);
        }

        /// <summary>
        /// Retrieves account settings for the queue service from the default settings. 
        /// Throws an exception in case of incomplete settings.
        /// </summary>
        public static StorageAccountInfo GetDefaultQueueStorageAccountFromConfiguration()
        {
            return GetAccountInfoFromConfiguration(DefaultQueueStorageEndpointConfigurationString, false);
        }

        /// <summary>
        /// Retrieves account settings for the table service from the default settings. 
        /// </summary>
        public static StorageAccountInfo GetDefaultTableStorageAccountFromConfiguration(bool allowIncompleteSettings)
        {
            return GetAccountInfoFromConfiguration(DefaultTableStorageEndpointConfigurationString, allowIncompleteSettings);
        }

        /// <summary>
        /// Retrieves account settings for the table service from the default settings. 
        /// Throws an exception in case of incomplete settings.
        /// </summary>
        public static StorageAccountInfo GetDefaultTableStorageAccountFromConfiguration()
        {
            return GetAccountInfoFromConfiguration(DefaultTableStorageEndpointConfigurationString, false);
        }

        /// <summary>
        /// Retrieves account settings for the blob service from the default settings. 
        /// </summary>
        public static StorageAccountInfo GetDefaultBlobStorageAccountFromConfiguration(bool allowIncompleteSettings)
        {
            return GetAccountInfoFromConfiguration(DefaultBlobStorageEndpointConfigurationString, allowIncompleteSettings);
        }

        /// <summary>
        /// Retrieves account settings for the blob service from the default settings. 
        /// Throws an exception in case of incomplete settings.
        /// </summary>
        public static StorageAccountInfo GetDefaultBlobStorageAccountFromConfiguration()
        {
            return GetAccountInfoFromConfiguration(DefaultBlobStorageEndpointConfigurationString, false);
        }

        /// <summary>
        /// Gets settings from default configuration names except for the endpoint configuration string.
        /// </summary>
        public static StorageAccountInfo GetAccountInfoFromConfiguration(string endpointConfiguration, bool allowIncompleteSettings) 
        {
            return GetAccountInfoFromConfiguration(DefaultAccountNameConfigurationString, 
                                       DefaultAccountSharedKeyConfigurationString,
                                       endpointConfiguration, 
                                       DefaultUsePathStyleUrisConfigurationString,
                                       allowIncompleteSettings);
        }

        /// <summary>
        /// Gets settings from default configuration names except for the endpoint configuration string. Throws an exception 
        /// in the case of incomplete settings.
        /// </summary>
        public static StorageAccountInfo GetAccountInfoFromConfiguration(string endpointConfiguration)
        {
            return GetAccountInfoFromConfiguration(DefaultAccountNameConfigurationString,
                                       DefaultAccountSharedKeyConfigurationString,
                                       endpointConfiguration,
                                       DefaultUsePathStyleUrisConfigurationString,
                                       false);
        }

        /// <summary>
        /// Gets a configuration setting from application settings in the Web.config or App.config file. 
        /// When running in a hosted environment, configuration settings are read from .cscfg
        /// files.
        /// </summary>
        public static string GetConfigurationSetting(string configurationSetting, string defaultValue, bool throwIfNull)
        {
            if (string.IsNullOrEmpty(configurationSetting))
            {
                throw new ArgumentException("configurationSetting cannot be empty or null", "configurationSetting");
            }

            string ret = null;

            // first, try to read from appsettings
            ret = TryGetAppSetting(configurationSetting);

            // settings in the csc file overload settings in Web.config
            if (RoleManager.IsRoleManagerRunning)
            {
                string cscRet = TryGetConfigurationSetting(configurationSetting);
                if (!string.IsNullOrEmpty(cscRet))
                {
                    ret = cscRet;
                }

                // if there is a csc config name in the app settings, this config name even overloads the 
                // setting we have right now
                string refWebRet = TryGetAppSetting(StorageAccountInfo.CSConfigStringPrefix + configurationSetting);
                if (!string.IsNullOrEmpty(refWebRet))
                {
                    cscRet = TryGetConfigurationSetting(refWebRet);
                    if (!string.IsNullOrEmpty(cscRet))
                    {
                        ret = cscRet;
                    }
                }
            }

            // if we could not retrieve any configuration string set return value to the default value
            if (string.IsNullOrEmpty(ret) && defaultValue != null)
            {
                ret = defaultValue;
            }

            if (string.IsNullOrEmpty(ret) && throwIfNull)
            {
                throw new ConfigurationErrorsException(
                    string.Format(CultureInfo.InvariantCulture, "Cannot find configuration string {0}.", configurationSetting));
            }
            return ret;
        }

        /// <summary>
        /// Retrieves account information settings from configuration settings. First, the implementation checks for 
        /// settings in an application config section of an app.config or Web.config file. These values are overwritten 
        /// if the same settings appear in a .csdef file.
        /// The implementation also supports indirect settings. In this case, indirect settings overwrite all other settings.
        /// </summary>        
        /// <param name="accountNameConfiguration">Configuration string for the account name.</param>
        /// <param name="accountSharedKeyConfiguration">Configuration string for the key.</param>
        /// <param name="endpointConfiguration">Configuration string for the endpoint.</param>
        /// <param name="usePathStyleUrisConfiguration">Configuration string for the path style.</param>
        /// <param name="allowIncompleteSettings">If false, an exception is thrown if not all settings are available.</param>
        /// <returns>StorageAccountInfo object containing the retrieved settings.</returns>        
        public static StorageAccountInfo GetAccountInfoFromConfiguration(string accountNameConfiguration,
                                                                         string accountSharedKeyConfiguration,
                                                                         string endpointConfiguration, 
                                                                         string usePathStyleUrisConfiguration,
                                                                         bool allowIncompleteSettings)
        {
            if (string.IsNullOrEmpty(endpointConfiguration))
            {
                throw new ArgumentException("Endpoint configuration is missing", "endpointConfiguration");
            }
            string endpoint = null;
            string name = null;
            string key = null;
            string pathStyle = null;

            name = TryGetAppSetting(accountNameConfiguration);
            key = TryGetAppSetting(accountSharedKeyConfiguration);
            endpoint = TryGetAppSetting(endpointConfiguration);
            pathStyle = TryGetAppSetting(usePathStyleUrisConfiguration);


            // settings in the csc file overload settings in Web.config
            if (RoleManager.IsRoleManagerRunning)
            {
                // get config settings from the csc file
                string cscName = TryGetConfigurationSetting(accountNameConfiguration);
                if (!string.IsNullOrEmpty(cscName))
                {
                    name = cscName;
                }
                string cscKey = TryGetConfigurationSetting(accountSharedKeyConfiguration);
                if (!string.IsNullOrEmpty(cscKey))
                {
                    key = cscKey;
                }
                string cscEndpoint = TryGetConfigurationSetting(endpointConfiguration);
                if (!string.IsNullOrEmpty(cscEndpoint))
                {
                    endpoint = cscEndpoint;
                }
                string cscPathStyle = TryGetConfigurationSetting(usePathStyleUrisConfiguration);
                if (!string.IsNullOrEmpty(cscPathStyle))
                {
                    pathStyle = cscPathStyle;
                }

                // the Web.config can have references to csc setting strings
                // these count event stronger than the direct settings in the csc file
                string refWebName = TryGetAppSetting(CSConfigStringPrefix + accountNameConfiguration);
                if (!string.IsNullOrEmpty(refWebName))
                {
                    cscName = TryGetConfigurationSetting(refWebName);
                    if (!string.IsNullOrEmpty(cscName))
                    {
                        name = cscName;
                    }
                }
                string refWebKey = TryGetAppSetting(CSConfigStringPrefix + accountSharedKeyConfiguration);
                if (!string.IsNullOrEmpty(refWebKey))
                {
                    cscKey = TryGetConfigurationSetting(refWebKey);
                    if (!string.IsNullOrEmpty(cscKey))
                    {
                        key = cscKey;
                    }
                }
                string refWebEndpoint = TryGetAppSetting(CSConfigStringPrefix + endpointConfiguration);
                if (!string.IsNullOrEmpty(refWebEndpoint))
                {
                    cscEndpoint = TryGetConfigurationSetting(refWebEndpoint);
                    if (!string.IsNullOrEmpty(cscEndpoint))
                    {
                        endpoint = cscEndpoint;
                    }
                }
                string refWebPathStyle = TryGetAppSetting(CSConfigStringPrefix + usePathStyleUrisConfiguration);
                if (!string.IsNullOrEmpty(refWebPathStyle))
                {
                    cscPathStyle = TryGetConfigurationSetting(refWebPathStyle);
                    if (!string.IsNullOrEmpty(cscPathStyle))
                    {
                        pathStyle = cscPathStyle;
                    }
                }
            }

            if (string.IsNullOrEmpty(key) && !allowIncompleteSettings)
            {
                throw new ArgumentException("No account key specified!");
            }
            if (string.IsNullOrEmpty(endpoint) && !allowIncompleteSettings)
            {
                throw new ArgumentException("No endpoint specified!");
            }
            if (string.IsNullOrEmpty(name))
            {
                // in this case let's try to derive the account name from the Uri
                string newAccountName = null;
                Uri newBaseUri = null;
                if (IsStandardStorageEndpoint(new Uri(endpoint), out newAccountName, out newBaseUri))
                {
                    Debug.Assert((newAccountName != null && newBaseUri != null) || (newAccountName == null && newBaseUri == null));
                    if (newAccountName != null && newBaseUri != null)
                    {
                        endpoint = newBaseUri.AbsoluteUri;
                        name = newAccountName;
                    }
                }
                if (string.IsNullOrEmpty(name) && !allowIncompleteSettings)
                {
                    throw new ArgumentException("No account name specified.");
                }
            }

            bool? usePathStyleUris = null;
            if (!string.IsNullOrEmpty(pathStyle))
            {
                bool b;
                if (!bool.TryParse(pathStyle, out b))
                {
                    throw new ConfigurationErrorsException("Cannot parse value of setting UsePathStyleUris as a boolean");
                }
                usePathStyleUris = b;
            }
            Uri tmpBaseUri = null;
            if (!string.IsNullOrEmpty(endpoint))
            {
                tmpBaseUri = new Uri(endpoint);
            }
            return new StorageAccountInfo(tmpBaseUri, usePathStyleUris, name, key, allowIncompleteSettings);
        }


        /// <summary>
        /// Checks whether all essential properties of this object are set. Only then, the account info object 
        /// should be used in ohter APIs of this library.
        /// </summary>
        /// <returns></returns>
        public bool IsCompleteSetting()
        {
            return BaseUri != null && Base64Key != null && AccountName != null;
        }

        /// <summary>
        /// Checks whether this StorageAccountInfo object is complete in the sense that all properties are set.
        /// </summary>
        public void CheckComplete()
        {
            if (!IsCompleteSetting())
            {
                throw new ConfigurationErrorsException("Account information incomplete!");
            }
        }

        #region Private methods

        private static string TryGetConfigurationSetting(string configName)
        {
            string ret = null;
            try
            {
                ret = RoleManager.GetConfigurationSetting(configName);
            }
            catch (RoleException)
            {
                return null;
            }
            return ret;
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031:DoNotCatchGeneralExceptionTypes", 
                                                          Justification = "Make sure that nothing prevents us to read from the fabric's configuration envrionment.")]
        private static string TryGetAppSetting(string configName)
        {
            string ret = null;
            try
            {
                ret = ConfigurationSettings.AppSettings[configName];
            }
            // some exception happened when accessing the app settings section
            // most likely this is because there is no app setting file
            // we assume that this is because there is no app settings file; this is not an error
            // and explicitly all exceptions are captured here
            catch (Exception)
            {
                return null;
            }
            return ret;
        }

        private static string GeneralAccountConfigurationExceptionString {
            get {
                return "If the portal defines http://test.blob.core.windows.net as your blob storage endpoint, the string \"test\" " + 
                       "is your account name, and you can specify http://blob.core.windows.net as the BlobStorageEndpoint in your " +
                       "service's configuration file(s).";
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Globalization", "CA1308:NormalizeStringsToUppercase")]
        private static bool IsStandardStorageEndpoint(Uri baseUri, out string newAccountName, out Uri newBaseUri) {
            if (baseUri == null) {
                throw new ArgumentNullException("baseUri");
            }

            newAccountName = null;
            newBaseUri = null;

            string host = baseUri.Host;
            if (string.IsNullOrEmpty(host)) {
                throw new ArgumentException("The host part of the Uri " + baseUri.AbsoluteUri + " must not be null or empty.");
            }
            if (host != host.ToLowerInvariant()) {
                throw new ArgumentException("The specified host string " + host + " must not contain upper-case letters.");
            }

            string suffix = null;
            if (host.EndsWith(StorageHttpConstants.StandardPortalEndpoints.TableStorageEndpoint, StringComparison.Ordinal)) {
                suffix = StorageHttpConstants.StandardPortalEndpoints.TableStorageEndpoint;
            }
            if (host.EndsWith(StorageHttpConstants.StandardPortalEndpoints.BlobStorageEndpoint, StringComparison.Ordinal))
            {
                suffix = StorageHttpConstants.StandardPortalEndpoints.BlobStorageEndpoint;
            }
            if (host.EndsWith(StorageHttpConstants.StandardPortalEndpoints.QueueStorageEndpoint, StringComparison.Ordinal))
            {
                suffix = StorageHttpConstants.StandardPortalEndpoints.QueueStorageEndpoint;
            }
            // a URL as presented on the portal was specified, lets find out whether it is in the correct format
            if (suffix != null) {
                int index = host.IndexOf(suffix, StringComparison.Ordinal);
                Debug.Assert(index != -1);
                if (index > 0) {
                    string first = host.Substring(0, index);
                    Debug.Assert(!string.IsNullOrEmpty(first));
                    if (first[first.Length-1] != StorageHttpConstants.ConstChars.Dot[0]) {
                        return false;
                    }
                    first = first.Substring(0, first.Length - 1);
                    if (string.IsNullOrEmpty(first)) {
                        throw new ArgumentException("The configured base URI " + baseUri.AbsoluteUri + " for the storage service is incorrect. " + 
                                                     GeneralAccountConfigurationExceptionString);
                    }
                    if (first.Contains(StorageHttpConstants.ConstChars.Dot)) {
                        throw new ArgumentException("The configured base URI " + baseUri.AbsoluteUri + " for the storage service is incorrect. " + 
                                                     GeneralAccountConfigurationExceptionString);
                    }
                    newAccountName = first;
                    newBaseUri = new Uri(baseUri.Scheme + Uri.SchemeDelimiter + suffix + baseUri.PathAndQuery);                    
                }
                return true;
            }
            return false;
        }


        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\RestQueue.cs ===
//
// <copyright file="RestQueue.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Web;
using System.Net;
using System.Collections.Specialized;
using System.IO;
using System.Xml;
using System.Diagnostics;
using System.Globalization;
using System.Threading;


namespace AsyncMultiplayer.Common.AzureStorage
{

    internal class QueueStorageRest : QueueStorage
    {
        private SharedKeyCredentials _credentials;

        internal QueueStorageRest(StorageAccountInfo accountInfo,string version)
            : base(accountInfo,version)
        {
            byte[] key = null;
            if (accountInfo.Base64Key != null)
            {
                key = Convert.FromBase64String(accountInfo.Base64Key);
            }
            _credentials = new SharedKeyCredentials(accountInfo.AccountName, key);
        }

        /// <summary>
        /// Get a reference to a Queue object with a specified name. This method does not make a call to
        /// the queue service.
        /// </summary>
        /// <param name="queueName">The name of the queue</param>
        /// <returns>A newly created queue object</returns>
        public override MessageQueue GetQueue(string queueName)
        {
            return new QueueRest(queueName,
                                 AccountInfo, 
                                 Timeout,
                                 RetryPolicy,
                                 Version
                                 );
        }

        internal class ListQueueResult
        {
            internal ListQueueResult(IEnumerable<string> names, IEnumerable<string> urls, string nextMarker)
            {
                Names = names;
                Urls = urls;
                NextMarker = nextMarker;
            }

            internal IEnumerable<string> Names
            {
                get;
                private set;
            }

            internal IEnumerable<string> Urls
            {
                get;
                private set;
            }

            internal string NextMarker
            {
                get;
                private set;
            }
        }

        /// <summary>
        /// Lists all queues with a given prefix within an account.
        /// </summary>
        /// <param name="prefix"></param>
        /// <returns>The list of queue names.</returns>
        public override IEnumerable<MessageQueue> ListQueues(string prefix)
        {
            string marker = "";
            const int maxResults = StorageHttpConstants.ListingConstants.MaxQueueListResults;

            do
            {
                ListQueueResult result = ListQueuesImpl(prefix, marker, maxResults);
                if (result == null)
                {
                    marker = null;
                }
                else
                {
                    marker = result.NextMarker;

                    foreach (string name in result.Names)
                    {
                        yield return new QueueRest(name, AccountInfo, this.Timeout, this.RetryPolicy,this.Version);
                    }
                }
            } while (marker != null);
        }

        /// <summary>
        /// Lists the queues within the account.
        /// </summary>
        /// <returns>A list of queues</returns>
        private ListQueueResult ListQueuesImpl(string prefix, string marker, int maxResult)
        {
            ListQueueResult result = null;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();
                col.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.List);
                if (!string.IsNullOrEmpty(prefix))
                {
                    col.Add(StorageHttpConstants.QueryParams.QueryParamPrefix, prefix);
                }
                if (!string.IsNullOrEmpty(marker))
                {
                    col.Add(StorageHttpConstants.QueryParams.QueryParamMarker, marker);
                }
                col.Add(StorageHttpConstants.QueryParams.QueryParamMaxResults, maxResult.ToString(CultureInfo.InvariantCulture));

                ResourceUriComponents uriComponents;
                Uri uri = Utilities.CreateRequestUri(
                                        AccountInfo.BaseUri,
                                        AccountInfo.UsePathStyleUris,
                                        AccountInfo.AccountName,
                                        null,
                                        null,
                                        Timeout,
                                        col,
                                        out uriComponents
                                        );
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Get, Timeout);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            using (Stream stream = response.GetResponseStream())
                            {
                                result = GetQueuesFromResponse(stream);
                                stream.Close();
                            }
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });

            return result;
        }

        private static ListQueueResult GetQueuesFromResponse(Stream stream)
        {
            ListQueueResult result = null;
            List<string> names = new List<string>();
            List<string> urls = new List<string>();
            string nextMarker = null;

            XmlDocument doc = new XmlDocument();
            try
            {
                doc.Load(stream);
            }
            catch (XmlException xe)
            {
                throw new StorageServerException(StorageErrorCode.ServiceBadResponse,
                    "The result of a ListQueue operation could not be parsed", default(HttpStatusCode), xe);
            }

            // get queue names and urls
            XmlNodeList queueNameNodes = doc.SelectNodes(XPathQueryHelper.QueueListQuery);
            foreach (XmlNode queueNameNode in queueNameNodes)
            {
                string queueName = XPathQueryHelper.LoadSingleChildStringValue(queueNameNode, StorageHttpConstants.XmlElementNames.QueueName, true);
                names.Add(queueName);
                string url = XPathQueryHelper.LoadSingleChildStringValue(queueNameNode, StorageHttpConstants.XmlElementNames.Url, true);
                urls.Add(url);
            }

            // Get the nextMarker
            XmlNode nextMarkerNode = doc.SelectSingleNode(XPathQueryHelper.NextMarkerQuery);
            if (nextMarkerNode != null && nextMarkerNode.FirstChild != null)
            {
                nextMarker = nextMarkerNode.FirstChild.Value;
            }
            if (names.Count > 0)
            {
                Debug.Assert(names.Count == urls.Count);
                result = new ListQueueResult(names, urls, nextMarker);
            }
            return result;
        }
    }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1001:TypesThatOwnDisposableFieldsShouldBeDisposable", 
                                                     Justification = "Disposable types are only used for automatic receiving of messages, which handle the disposal themselves.")]
    internal class QueueRest : MessageQueue
    {
        #region Member variables and constructors

        private Uri _queueUri;
        private SharedKeyCredentials _credentials;
        private int _pollInterval = DefaultPollInterval;
        private string version;


        internal QueueRest(
                    string name,
                    StorageAccountInfo account,
                    TimeSpan timeout,
                    RetryPolicy retryPolicy,
                    string version
                    )
            : base(name, account)
        {
            byte[] key = null;
            if (AccountInfo.Base64Key != null)
            {
                key = Convert.FromBase64String(AccountInfo.Base64Key);
            }
            ResourceUriComponents uriComponents = new ResourceUriComponents(account.AccountName, name, null);
            _credentials = new SharedKeyCredentials(AccountInfo.AccountName, key);
            _queueUri = HttpRequestAccessor.ConstructResourceUri(account.BaseUri, uriComponents, account.UsePathStyleUris);
            Timeout = timeout;
            RetryPolicy = retryPolicy;
            this.version = version;
        }
        #endregion

        #region Public interface

        public override Uri QueueUri
        {
            get
            {
                return _queueUri;
            }
        }

        public override bool CreateQueue(out bool queueAlreadyExists)
        {
            bool result = false;
            queueAlreadyExists = false;
            // cannot use ref or out parameters in the retry expression below
            bool exists = false;

            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(null, new NameValueCollection(), false, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Put);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.Created)
                        {
                            // as an addition we could parse the result and retrieve
                            // queue properties at this point
                            exists = false;
                            result = true;
                        }
                        else if (response.StatusCode == HttpStatusCode.NoContent)
                        {
                            exists = true;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    if (we.Response != null && 
                        ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Conflict)
                    {
                        exists = true;
                    }
                    else
                    {
                        throw Utilities.TranslateWebException(we);
                    }
                }
            });

            queueAlreadyExists = exists;
            return result;
        }

        public override bool DeleteQueue()
        {
            bool result = false;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();                
                
                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(null, col, false, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Delete);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.NoContent)
                        {
                            result = true;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    if (we.Response != null &&
                        (((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.NotFound ||
                         ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.PreconditionFailed ||
                         ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Conflict))
                    {
                        result = false;
                    }
                    else
                    {
                        throw Utilities.TranslateWebException(we);
                    }
                }
            });

            return result;
        }

        public override bool SetProperties(QueueProperties properties)
        {
            if (properties == null)
            {
                throw new ArgumentNullException("properties");
            }

            bool result = false;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();
                col.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.Metadata);

                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(null, col, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Put, properties.Metadata);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.NoContent)
                        {
                            result = true;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });

            return result;
        }

        public override QueueProperties GetProperties()
        {
            QueueProperties result = null;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();
                col.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.Metadata);

                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(null, col, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Get, null);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            result = GetPropertiesFromHeaders(response);
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });

            return result;
        }

        public override int ApproximateCount()
        {
            QueueProperties props = GetProperties();
            return props.ApproximateMessageCount;
        }

        // getting and putting messages

        public override bool PutMessage(Message msg)
        {
            return PutMessage(msg, -1);
        }

        public override bool PutMessage(Message msg, int timeToLiveInSeconds)
        {
            if (timeToLiveInSeconds < -1)
            {
                throw new ArgumentException("ttl parameter must be equal or larger than 0.");
            }
            else if (timeToLiveInSeconds > Message.MaxTimeToLive)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture,
                    "timeToLiveHours parameter must be smaller or equal than {0}, which is 7 days in hours.", Message.MaxTimeToLive));
            }
            if (msg == null || msg.ContentAsBytes() == null)
            {
                throw new ArgumentNullException("msg");
            }
            if (Convert.ToBase64String(msg.ContentAsBytes()).Length > Message.MaxMessageSize)
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "Messages cannot be larger than {0} bytes.", Message.MaxMessageSize));
            }

            bool result = false;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();
                if (timeToLiveInSeconds != -1)
                {
                    col.Add(StorageHttpConstants.RequestParams.MessageTtl, timeToLiveInSeconds.ToString(CultureInfo.InvariantCulture));
                }

                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(StorageHttpConstants.RequestParams.Messages, col, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Post, null);
                int len;
                byte[] body = msg.GetContentXMLRepresentation(out len);
                request.ContentLength = len;
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (Stream requestStream = request.GetRequestStream())
                    {                                               
                        requestStream.Write(body, 0, body.Length);
                        requestStream.Close();
                        using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                        {
                            if (response.StatusCode == HttpStatusCode.Created)
                            {
                                result = true;
                            }
                            else
                            {
                                Utilities.ProcessUnexpectedStatusCode(response);
                            }
                            response.Close();
                        }
                    }
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });

            return result;
        }

        public override Message GetMessage()
        {
            IEnumerable<Message> result = GetMessages(1);
            if (result == null || result.Count() == 0)
            {
                return null;
            }
            return result.First();
        }

        public override Message GetMessage(int visibilityTimeoutInSeconds)
        {
            IEnumerable<Message> result = GetMessages(1, visibilityTimeoutInSeconds);
            if (result == null || result.Count() == 0)
            {
                return null;
            }
            return result.First();
        }

        public override IEnumerable<Message> GetMessages(int numberOfMessages)
        {
            return GetMessages(numberOfMessages, -1);
        }

        public override IEnumerable<Message> GetMessages(int numberOfMessages, int visibilityTimeout)
        {
            return InternalGet(numberOfMessages, visibilityTimeout, false);
        }

        public override Message PeekMessage()
        {
            IEnumerable<Message> result = PeekMessages(1);
            if (result == null || result.Count() == 0)
            {
                return null;
            }
            return result.First();
        }

        public override IEnumerable<Message> PeekMessages(int numberOfMessages)
        {
            return InternalGet(numberOfMessages, -1, true);
        }

        // deleting messages
        public override bool DeleteMessage(Message msg)
        {
            if (msg.PopReceipt == null)
            {
                throw new ArgumentException("No PopReceipt for the given message!");
            }

            bool result = false;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();
                col.Add(StorageHttpConstants.RequestParams.PopReceipt, msg.PopReceipt.ToString());

                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(StorageHttpConstants.RequestParams.Messages + "/" + msg.Id, col, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Delete, null);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.NoContent)
                        {
                            result = true;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }

                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });

            return result;
        }

        public override bool Clear()
        {
            bool result = false;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();

                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(StorageHttpConstants.RequestParams.Messages, col, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Delete, null);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.NoContent)
                        {
                            result = true;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }

                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });

            return result;
        }

        // automatic receiving of messages
        public override int PollInterval
        {
            get
            {
                return _pollInterval;
            }
            set
            {
                if (value < 0)
                {
                    throw new ArgumentException("The send threshold must be a positive value.");
                }
                if (_run)
                {
                    throw new ArgumentException("You cannot set the poll interval while the receive thread is running");
                }
                _pollInterval = value;
            }
        }

        private AutoResetEvent _evStarted;
        private AutoResetEvent _evStopped;
        private AutoResetEvent _evQuit;
        private bool _run;
        private Thread _receiveThread;
        private int _internalPollInterval;


        private void PeriodicReceive()
        {
            Message msg;

            _evStarted.Set();
            _internalPollInterval = PollInterval;
            while (!_evQuit.WaitOne(_internalPollInterval, false))
            {
                // time is up, so we get the message and continue
                msg = GetMessage();
                if (msg != null)
                {
                    MessageReceived(this, new MessageReceivedEventArgs(msg));
                    // continue receiving fast until we get no message
                    _internalPollInterval = 10;
                }
                else
                {
                    // we got no message, so we can fall back to the normal speed
                    _internalPollInterval = PollInterval;
                }
            }
            _evStopped.Set();
        }

        public override bool StartReceiving()
        {
            lock (this)
            {
                if (_run)
                {
                    return true;
                }
                _run = true;
            }
            if (_evStarted == null) {
                _evStarted = new AutoResetEvent(false);
            }
            if (_evStopped == null) {
                _evStopped = new AutoResetEvent(false);
            }
            if (_evQuit == null) {
                _evQuit = new AutoResetEvent(false);
            }
            _receiveThread = new Thread(new ThreadStart(this.PeriodicReceive));
            _receiveThread.Start();
            if (!_evStarted.WaitOne(10000, false))
            {
                _receiveThread.Abort();
                CloseEvents();
                _run = false;
                return false;
            }
            return true;
        }

        public override void StopReceiving()
        {
            _evQuit.Set();
            if (!_evStopped.WaitOne(10000, false))            
            {
                _receiveThread.Abort();
            }
            CloseEvents();
            _run = false;
        }

        private void CloseEvents()
        {
            if (_evStarted != null)
            {
                _evStarted.Close();
            }
            if (_evStopped != null)
            {
                _evStopped.Close();
            }
            if (_evQuit != null)
            {
                _evQuit.Close();
            }
        }

        public override event MessageReceivedEventHandler MessageReceived;

        #endregion

        #region Helper methods

        private static QueueProperties GetPropertiesFromHeaders(HttpWebResponse response)
        {
            QueueProperties properties = new QueueProperties();
            int prefixLength = StorageHttpConstants.HeaderNames.PrefixForMetadata.Length;
            foreach (string key in response.Headers.AllKeys)
            {
                if (key.Equals(StorageHttpConstants.HeaderNames.ApproximateMessagesCount, StringComparison.OrdinalIgnoreCase))
                {
                    properties.ApproximateMessageCount = Convert.ToInt32(response.Headers[key], CultureInfo.InvariantCulture);
                }
                else if (key.StartsWith(StorageHttpConstants.HeaderNames.PrefixForMetadata, StringComparison.OrdinalIgnoreCase))
                {
                    if (properties.Metadata == null)
                    {
                        properties.Metadata = new NameValueCollection();
                    }
                    properties.Metadata.Add(key.Substring(prefixLength), response.Headers[key]);
                }
            }
            return properties;
        }


        private IEnumerable<Message> InternalGet(int numberOfMessages, int visibilityTimeout, bool peekOnly)
        {
            if (peekOnly && visibilityTimeout != -1)
            {
                throw new ArgumentException("A peek operation does not change the visibility of messages", "visibilityTimeout");
            }
            if (numberOfMessages < 1)
            {
                throw new ArgumentException("numberOfMessages must be a positive integer", "numberOfMessages");
            }
            if (visibilityTimeout < -1)
            {
                throw new ArgumentException("Visibility Timeout must be 0 or a positive integer", "visibilityTimeout");
            }

            IEnumerable<Message> result = null;

            RetryPolicy(() =>
            {
                NameValueCollection col = new NameValueCollection();
                col.Add(StorageHttpConstants.RequestParams.NumOfMessages, numberOfMessages.ToString(CultureInfo.InvariantCulture));
                if (visibilityTimeout != -1)
                {
                    col.Add(StorageHttpConstants.RequestParams.VisibilityTimeout,
                            visibilityTimeout.ToString(CultureInfo.InvariantCulture));
                }
                if (peekOnly)
                {
                    col.Add(StorageHttpConstants.RequestParams.PeekOnly,
                            peekOnly.ToString(CultureInfo.InvariantCulture));
                }

                ResourceUriComponents uriComponents;
                Uri uri = CreateRequestUri(StorageHttpConstants.RequestParams.Messages, col, out uriComponents);
                HttpWebRequest request = CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Get, null);
                _credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            using (Stream stream = response.GetResponseStream())
                            {
                                result = GetMessageFromResponse(stream);
                                stream.Close();
                            }
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }

                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });


            return result;
        }

        private static IEnumerable<Message> GetMessageFromResponse(Stream stream)
        {
            List<Message> result = null;
            Message msg;

            XmlDocument doc = new XmlDocument();
            try
            {
                doc.Load(stream);
            }
            catch (XmlException xe)
            {
                throw new StorageServerException(StorageErrorCode.ServiceBadResponse,
                    "The result of a get message opertation could not be parsed", default(HttpStatusCode), xe);
            }

            XmlNodeList messagesNodes = doc.SelectNodes(XPathQueryHelper.MessagesListQuery);
            if (messagesNodes.Count > 0)
            {
                result = new List<Message>();
            }
            foreach (XmlNode messageNode in messagesNodes)
            {
                msg = new Message();
                msg.Id = messageNode.SelectSingleNode(StorageHttpConstants.XmlElementNames.MessageId).FirstChild.Value.Trim();
                Debug.Assert(msg.Id != null);
                if (messageNode.SelectSingleNode(StorageHttpConstants.XmlElementNames.PopReceipt) != null)
                {
                    msg.PopReceipt = messageNode.SelectSingleNode(StorageHttpConstants.XmlElementNames.PopReceipt).FirstChild.Value.Trim();
                    Debug.Assert(msg.PopReceipt != null);
                }                
                msg.InsertionTime = XPathQueryHelper.LoadSingleChildDateTimeValue(messageNode, StorageHttpConstants.XmlElementNames.InsertionTime, false).Value;
                msg.ExpirationTime = XPathQueryHelper.LoadSingleChildDateTimeValue(messageNode, StorageHttpConstants.XmlElementNames.ExpirationTime, false).Value;
                if (XPathQueryHelper.LoadSingleChildDateTimeValue(messageNode, StorageHttpConstants.XmlElementNames.TimeNextVisible, false) != null)
                {
                    msg.TimeNextVisible = XPathQueryHelper.LoadSingleChildDateTimeValue(messageNode, StorageHttpConstants.XmlElementNames.TimeNextVisible, false).Value;
                }
                msg.SetContentFromBase64String(XPathQueryHelper.LoadSingleChildStringValue(messageNode, StorageHttpConstants.XmlElementNames.MessageText, false));
                result.Add(msg);
            }
            return result.AsEnumerable();
        }

        private HttpWebRequest CreateHttpRequest(Uri uri, string httpMethod)
        {
            return CreateHttpRequest(uri, httpMethod, null);
        }

        private HttpWebRequest CreateHttpRequest(Uri uri, string httpMethod, NameValueCollection metadata)
        {
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(uri);
            request.Timeout = (int)Timeout.TotalMilliseconds;
            request.ReadWriteTimeout = (int)Timeout.TotalMilliseconds;
            request.Method = httpMethod;
            request.ContentLength = 0;
            request.Headers.Add(StorageHttpConstants.HeaderNames.StorageDateTime,
                                Utilities.ConvertDateTimeToHttpString(DateTime.UtcNow));
            if (!String.IsNullOrEmpty(this.version))
            {
                request.Headers.Add(StorageHttpConstants.HeaderNames.Version, this.version);
            }
            
            if (metadata != null)
            {
                Utilities.AddMetadataHeaders(request, metadata);
            }
            return request;
        }

        private Uri CreateRequestUri(
                        string uriSuffix,
                        NameValueCollection queryParameters,
                        out ResourceUriComponents uriComponents
                        )
        {
            return CreateRequestUri(uriSuffix, queryParameters, false, out uriComponents);
        }

        private Uri CreateRequestUri(
            string uriSuffix,
            NameValueCollection queryParameters,
            bool accountOperation,
            out ResourceUriComponents uriComponents
            )
        {
            return Utilities.CreateRequestUri(
                            this.AccountInfo.BaseUri,
                            this.AccountInfo.UsePathStyleUris,
                            this.AccountInfo.AccountName,
                            accountOperation ? null : this.Name,
                            uriSuffix,
                            this.Timeout,
                            queryParameters,
                            out uriComponents
                            );
        }

        #endregion

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\RestHelpers.cs ===
//
// <copyright file="RestHelpers.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO;
using System.Net;
using System.Diagnostics;
using System.Globalization;
using System.Collections.Specialized;
using System.Web;
using System.Xml;
using System.Text.RegularExpressions;

namespace AsyncMultiplayer.Common.AzureStorage
{
    namespace StorageHttpConstants
    {

        internal static class ConstChars
        {
            internal const string Linefeed = "\n";
            internal const string CarriageReturnLinefeed = "\r\n";
            internal const string Colon = ":";
            internal const string Comma = ",";
            internal const string Slash = "/";
            internal const string BackwardSlash = @"\";
            internal const string Space = " ";
            internal const string Ampersand = "&";
            internal const string QuestionMark = "?";
            internal const string Equal = "=";
            internal const string Bang = "!";
            internal const string Star = "*";
            internal const string Dot = ".";
        }

        internal static class RequestParams
        {
            internal const string NumOfMessages = "numofmessages";
            internal const string VisibilityTimeout = "visibilitytimeout";
            internal const string PeekOnly = "peekonly";
            internal const string MessageTtl = "messagettl";
            internal const string Messages = "messages";
            internal const string PopReceipt = "popreceipt";
        }

        internal static class QueryParams
        {
            internal const string SeparatorForParameterAndValue = "=";
            internal const string QueryParamTimeout = "timeout";
            internal const string QueryParamComp = "comp";

            // Other query string parameter names
            internal const string QueryParamBlockId = "blockid";
            internal const string QueryParamPrefix = "prefix";
            internal const string QueryParamMarker = "marker";
            internal const string QueryParamMaxResults = "maxresults";
            internal const string QueryParamDelimiter = "delimiter";
            internal const string QueryParamModifiedSince = "modifiedsince";
        }

        internal static class CompConstants
        {
            internal const string Metadata = "metadata";
            internal const string List = "list";
            internal const string BlobList = "bloblist";
            internal const string BlockList = "blocklist";
            internal const string Block = "block";
            internal const string Acl = "acl";
        }

        internal static class XmlElementNames
        {
            internal const string BlockList = "BlockList";
            internal const string Block = "Block";
            internal const string EnumerationResults = "EnumerationResults";
            internal const string Prefix = "Prefix";
            internal const string Marker = "Marker";
            internal const string MaxResults = "MaxResults";
            internal const string Delimiter = "Delimiter";
            internal const string NextMarker = "NextMarker";
            internal const string Containers = "Containers";
            internal const string Container = "Container";
            internal const string ContainerName = "Name";
            internal const string ContainerNameAttribute = "ContainerName";
            internal const string AccountNameAttribute = "AccountName";
            internal const string LastModified = "LastModified";
            internal const string Etag = "Etag";
            internal const string Url = "Url";
            internal const string CommonPrefixes = "CommonPrefixes";
            internal const string ContentType = "ContentType";
            internal const string ContentEncoding = "ContentEncoding";
            internal const string ContentLanguage = "ContentLanguage";
            internal const string Size = "Size";
            internal const string Blobs = "Blobs";
            internal const string Blob = "Blob";
            internal const string BlobName = "Name";
            internal const string BlobPrefix = "BlobPrefix";
            internal const string BlobPrefixName = "Name";
            internal const string Name = "Name";
            internal const string Queues = "Queues";
            internal const string Queue = "Queue";
            internal const string QueueName = "QueueName";
            internal const string QueueMessagesList = "QueueMessagesList";
            internal const string QueueMessage = "QueueMessage";
            internal const string MessageId = "MessageId";
            internal const string PopReceipt = "PopReceipt";
            internal const string InsertionTime = "InsertionTime";
            internal const string ExpirationTime = "ExpirationTime";
            internal const string TimeNextVisible = "TimeNextVisible";
            internal const string MessageText = "MessageText";

            // Error specific constants
            internal const string ErrorRootElement = "Error";
            internal const string ErrorCode = "Code";
            internal const string ErrorMessage = "Message";
            internal const string ErrorException = "ExceptionDetails";
            internal const string ErrorExceptionMessage = "ExceptionMessage";
            internal const string ErrorExceptionStackTrace = "StackTrace";
            internal const string AuthenticationErrorDetail = "AuthenticationErrorDetail";

            //The following are for table error messages
            internal const string DataWebMetadataNamespace = "http://schemas.microsoft.com/ado/2007/08/dataservices/metadata";
            internal const string TableErrorCodeElement = "code";
            internal const string TableErrorMessageElement = "message";
        }

        internal static class HeaderNames
        {
            internal const string PrefixForStorageProperties = "x-ms-prop-";
            internal const string PrefixForMetadata = "x-ms-meta-";
            internal const string PrefixForStorageHeader = "x-ms-";
            internal const string PrefixForTableContinuation = "x-ms-continuation-";

            //
            // Standard headers...
            //
            internal const string ContentLanguage = "Content-Language";
            internal const string ContentLength = "Content-Length";
            internal const string ContentType = "Content-Type";
            internal const string ContentEncoding = "Content-Encoding";
            internal const string ContentMD5 = "Content-MD5";
            internal const string ContentRange = "Content-Range";
            internal const string LastModifiedTime = "Last-Modified";
            internal const string Server = "Server";
            internal const string Allow = "Allow";
            internal const string ETag = "ETag";
            internal const string Range = "Range";
            internal const string Date = "Date";
            internal const string Authorization = "Authorization";
            internal const string IfModifiedSince = "If-Modified-Since";
            internal const string IfUnmodifiedSince = "If-Unmodified-Since";
            internal const string IfMatch = "If-Match";
            internal const string IfNoneMatch = "If-None-Match";
            internal const string IfRange = "If-Range";
            internal const string NextPartitionKey = "NextPartitionKey";
            internal const string NextRowKey = "NextRowKey";
            internal const string NextTableName = "NextTableName";

            //
            // Storage specific custom headers...
            //
            internal const string StorageDateTime = PrefixForStorageHeader + "date";
            internal const string PublicAccess = PrefixForStorageProperties + "publicaccess";
            internal const string StorageRange = PrefixForStorageHeader + "range";

            internal const string CreationTime = PrefixForStorageProperties + "creation-time";
            internal const string ForceUpdate = PrefixForStorageHeader + "force-update";
            internal const string ApproximateMessagesCount = PrefixForStorageHeader + "approximate-messages-count";
            internal const string Version = PrefixForStorageHeader + "version";
        }

        internal static class HeaderValues
        {
            internal const string ContentTypeXml = "application/xml";

            /// <summary>
            /// This is the default content-type xStore uses when no content type is specified
            /// </summary>
            internal const string DefaultContentType = "application/octet-stream";

            // The Range header value is "bytes=start-end", both start and end can be empty
            internal const string RangeHeaderFormat = "bytes={0}-{1}";

        }

        internal static class AuthenticationSchemeNames
        {
            internal const string SharedKeyAuthSchemeName = "SharedKey";
            internal const string SharedKeyLiteAuthSchemeName = "SharedKeyLite";
        }

        internal static class HttpMethod
        {
            internal const string Get = "GET";
            internal const string Put = "PUT";
            internal const string Post = "POST";
            internal const string Head = "HEAD";
            internal const string Delete = "DELETE";
            internal const string Trace = "TRACE";
            internal const string Options = "OPTIONS";
            internal const string Connect = "CONNECT";
        }

        internal static class BlobBlockConstants
        {
            internal const int KB = 1024;
            internal const int MB = 1024 * KB;
            /// <summary>
            /// When transmitting a blob that is larger than this constant, this library automatically
            /// transmits the blob as individual blocks. I.e., the blob is (1) partitioned
            /// into separate parts (these parts are called blocks) and then (2) each of the blocks is 
            /// transmitted separately.
            /// The maximum size of this constant as supported by the real blob storage service is currently 
            /// 64 MB; the development storage tool currently restricts this value to 2 MB.
            /// Setting this constant can have a significant impact on the performance for uploading or
            /// downloading blobs.
            /// As a general guideline: If you run in a reliable environment increase this constant to reduce
            /// the amount of roundtrips. In an unreliable environment keep this constant low to reduce the 
            /// amount of data that needs to be retransmitted in case of connection failures.
            /// </summary>
            internal const long MaximumBlobSizeBeforeTransmittingAsBlocks = 2 * MB;
            /// <summary>
            /// The size of a single block when transmitting a blob that is larger than the 
            /// MaximumBlobSizeBeforeTransmittingAsBlocks constant (see above).
            /// The maximum size of this constant is currently 4 MB; the development storage 
            /// tool currently restricts this value to 1 MB.
            /// Setting this constant can have a significant impact on the performance for uploading or 
            /// downloading blobs.
            /// As a general guideline: If you run in a reliable environment increase this constant to reduce
            /// the amount of roundtrips. In an unreliable environment keep this constant low to reduce the 
            /// amount of data that needs to be retransmitted in case of connection failures.
            /// </summary>
            internal const long BlockSize = 1 * MB;
        }

        internal static class ListingConstants
        {
            internal const int MaxContainerListResults = 100;
            internal const int MaxBlobListResults = 100;
            internal const int MaxQueueListResults = 50;
            internal const int MaxTableListResults = 50;
        }

        /// <summary>
        /// Contains regular expressions for checking whether container and table names conform
        /// to the rules of the storage REST protocols.
        /// </summary>
        public static class RegularExpressionStrings
        {
            /// <summary>
            /// Container or queue names that match against this regular expression are valid.
            /// </summary>
            public const string ValidContainerNameRegex = @"^([a-z]|\d){1}([a-z]|-|\d){1,61}([a-z]|\d){1}$";

            /// <summary>
            /// Table names that match against this regular expression are valid.
            /// </summary>
            public const string ValidTableNameRegex = @"^([a-z]|[A-Z]){1}([a-z]|[A-Z]|\d){2,62}$";
        }

        internal static class StandardPortalEndpoints
        {
            internal const string BlobStorage = "blob";
            internal const string QueueStorage = "queue";
            internal const string TableStorage = "table";
            internal const string StorageHostSuffix = ".core.windows.net";
            internal const string BlobStorageEndpoint = BlobStorage + StorageHostSuffix;
            internal const string QueueStorageEndpoint = QueueStorage + StorageHostSuffix;
            internal const string TableStorageEndpoint = TableStorage + StorageHostSuffix;
        }
    }

    internal static partial class Utilities
    {
        internal static HttpWebRequest CreateHttpRequest(Uri uri, string httpMethod, TimeSpan timeout)
        {
            return CreateHttpRequest(uri, httpMethod, timeout, string.Empty);
        }

        internal static HttpWebRequest CreateHttpRequest(Uri uri, string httpMethod, TimeSpan timeout, string proxyAddress)
        {
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(uri);
            request.Timeout = (int)timeout.TotalMilliseconds;
            request.ReadWriteTimeout = (int)timeout.TotalMilliseconds;
            request.Method = httpMethod;
            request.ContentLength = 0;
            if (!string.IsNullOrEmpty(proxyAddress))
            {
                request.Proxy = new WebProxy(proxyAddress);
            }

            request.Headers.Add(StorageHttpConstants.HeaderNames.StorageDateTime,
                                Utilities.ConvertDateTimeToHttpString(DateTime.UtcNow));
            return request;
        }


        /// <summary>
        /// Converts the date time to a valid string form as per HTTP standards
        /// </summary>
        internal static string ConvertDateTimeToHttpString(DateTime dateTime)
        {
            // On the wire everything should be represented in UTC. This assert will catch invalid callers who
            // are violating this rule.
            Debug.Assert(dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue || dateTime.Kind == DateTimeKind.Utc);

            // 'R' means rfc1123 date which is what our server uses for all dates...
            // It will be in the following format:
            // Sun, 28 Jan 2008 12:11:37 GMT
            return dateTime.ToString("R", CultureInfo.InvariantCulture);
        }

        /// <summary>
        /// Parse a string having the date time information in acceptable formats according to HTTP standards
        /// </summary>
        internal static bool TryGetDateTimeFromHttpString(string dateString, out DateTime? result)
        {
            DateTime dateTime;
            result = null;

            // 'R' means rfc1123 date which is the preferred format used in HTTP
            bool parsed = DateTime.TryParseExact(dateString, "R", null, DateTimeStyles.None, out dateTime);
            if (parsed)
            {
                // For some reason, format string "R" makes the DateTime.Kind as Unspecified while it's actually
                // Utc. Specifying DateTimeStyles.AssumeUniversal also doesn't make the difference. If we also
                // specify AdjustToUniversal it works as expected but we don't really want Parse to adjust 
                // things automatically.
                result = DateTime.SpecifyKind(dateTime, DateTimeKind.Utc);
                return true;
            }

            return false;
        }


        /// <summary>
        /// Copies from one stream to another
        /// </summary>
        /// <param name="sourceStream">The stream to copy from</param>
        /// <param name="destinationStream">The stream to copy to</param>
        internal static long CopyStream(Stream sourceStream, Stream destinationStream)
        {
            const int BufferSize = 0x10000;
            byte[] buffer = new byte[BufferSize];
            int n = 0;
            long totalRead = 0;
            do
            {
                n = sourceStream.Read(buffer, 0, BufferSize);
                if (n > 0)
                {
                    totalRead += n;
                    destinationStream.Write(buffer, 0, n);
                }

            } while (n > 0);
            return totalRead;
        }

        internal static void CopyStream(Stream sourceStream, Stream destinationStream, long length)
        {
            const int BufferSize = 0x10000;
            byte[] buffer = new byte[BufferSize];
            int n = 0;
            long amountLeft = length;

            do
            {
                amountLeft -= n;
                n = sourceStream.Read(buffer, 0, (int)Math.Min(BufferSize, amountLeft));
                if (n > 0)
                {
                    destinationStream.Write(buffer, 0, n);
                }

            } while (n > 0);
        }

        internal static int CopyStreamToBuffer(Stream sourceStream, byte[] buffer, int bytesToRead)
        {
            int n = 0;
            int amountLeft = bytesToRead;
            do
            {
                n = sourceStream.Read(buffer, bytesToRead - amountLeft, amountLeft);
                amountLeft -= n;
            } while (n > 0);
            return bytesToRead - amountLeft;
        }

        internal static Uri CreateRequestUri(
                                Uri baseUri,
                                bool usePathStyleUris,
                                string accountName,
                                string containerName,
                                string blobName,
                                TimeSpan Timeout,
                                NameValueCollection queryParameters,
                                out ResourceUriComponents uriComponents
                                )
        {
            uriComponents =
                new ResourceUriComponents(accountName, containerName, blobName);
            Uri uri = HttpRequestAccessor.ConstructResourceUri(baseUri, uriComponents, usePathStyleUris);

            if (queryParameters != null)
            {
                UriBuilder builder = new UriBuilder(uri);

                if (queryParameters.Get(StorageHttpConstants.QueryParams.QueryParamTimeout) == null)
                {
                    queryParameters.Add(StorageHttpConstants.QueryParams.QueryParamTimeout,
                    Timeout.TotalSeconds.ToString(CultureInfo.InvariantCulture));
                }

                StringBuilder sb = new StringBuilder();
                bool firstParam = true;
                foreach (string queryKey in queryParameters.AllKeys)
                {
                    if (!firstParam)
                        sb.Append("&");
                    sb.Append(HttpUtility.UrlEncode(queryKey));
                    sb.Append('=');
                    sb.Append(HttpUtility.UrlEncode(queryParameters[queryKey]));
                    firstParam = false;
                }

                if (sb.Length > 0)
                {
                    builder.Query = sb.ToString();
                }
                return builder.Uri;
            }
            else
            {
                return uri;
            }
        }

        internal static bool StringIsIPAddress(string address)
        {
            IPAddress outIPAddress;

            return IPAddress.TryParse(address, out outIPAddress);
        }

        internal static void AddMetadataHeaders(HttpWebRequest request, NameValueCollection metadata)
        {
            foreach (string key in metadata.Keys)
            {
                request.Headers.Add(
                    StorageHttpConstants.HeaderNames.PrefixForMetadata + key,
                    metadata[key]
                    );
            }
        }

        internal static bool IsValidTableName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return false;
            }
            Regex reg = new Regex(StorageHttpConstants.RegularExpressionStrings.ValidTableNameRegex);
            if (reg.IsMatch(name))
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        internal static bool IsValidContainerOrQueueName(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                return false;
            }
            Regex reg = new Regex(StorageHttpConstants.RegularExpressionStrings.ValidContainerNameRegex);
            if (reg.IsMatch(name))
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\StorageClientPerfCounters.cs ===
// <copyright file="StorageClientPerfCounters.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-03-22</date>
// <summary>Contains the class definition for StorageClientPerfCounters class.</summary>

namespace AsyncMultiplayer.Common.AzureStorage
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class is used to define the performance counters for the Azure storage client.
    /// </summary>
    [SuppressMessage("Microsoft.StyleCop.CSharp.MaintainabilityRules", "SA1401:FieldsMustBePrivate", Justification = "Public fields required by the performance counter framework.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented", Justification = "Fields are self documenting.")]
    [PerformanceCategory(CategoryName = "AzureStorageClientPerfCounters")]
    [CLSCompliant(false)]
    public sealed class StorageClientPerfCounters
    {
        [PerformanceCounter(CounterName = "Azure Table Queries Run", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of Azure Table queries run so far.")]
        public static int AzureTableQueriesRun;

        [PerformanceCounter(CounterName = "Azure Table Queries Run Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of Azure Table queries run per second.")]
        public static int AzureTableQueriesRunPerSecond;

        [PerformanceCounter(CounterName = "Azure Table Queries Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of an Azure Table query.", BasePropertyName = "Azure Table Queries Duration Base")]
        public static int AzureTableQueriesDuration;

        [PerformanceCounter(CounterName = "Azure Table Queries Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of an Azure Table query base.")]
        public static int AzureTableQueriesDurationBase;

        [PerformanceCounter(CounterName = "Azure Table Queries Errors", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of Azure Table queries that had errors so far.")]
        public static int AzureTableQueryErrors;

        [PerformanceCounter(CounterName = "Azure Table Queries Errors Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of Azure Table queries errors per second.")]
        public static int AzureTableQueryErrorsPerSecond;

        [PerformanceCounter(CounterName = "Azure Blob Accesses", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of Azure Blob accesses so far.")]
        public static int AzureBlobAccesses;

        [PerformanceCounter(CounterName = "Azure Blob Accesses Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of Azure Blob accesses per second.")]
        public static int AzureBlobAccessesPerSecond;

        [PerformanceCounter(CounterName = "Azure Blob Access Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of an Azure Blob access.", BasePropertyName = "Azure Blob Access Duration Base")]
        public static int AzureBlobAccessDuration;

        [PerformanceCounter(CounterName = "Azure Blob Access Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of an Azure Blob access base.")]
        public static int AzureBlobAccessDurationBase;

        [PerformanceCounter(CounterName = "Azure Blob Access Errors", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of Azure Blob accesses that had errors so far.")]
        public static int AzureBlobAccessErrors;

        [PerformanceCounter(CounterName = "Azure Blob Access Errors Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of Azure Blob access errors per second.")]
        public static int AzureBlobAccessErrorsPerSecond;

        [PerformanceCounter(CounterName = "Azure Call Retries", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The total number of Azure calls that have had to be retried so far.")]
        public static int AzureCallRetries;

        [PerformanceCounter(CounterName = "Azure Call Retries Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of Azure calls that have had to be retried per second.")]
        public static int AzureCallRetriesPerSecond;

        /// <summary>
        /// Prevents a default instance of the StorageClientPerfCounters class from being created.
        /// </summary>
        private StorageClientPerfCounters()
        {
        }

        /// <summary>
        /// Gets the name of the performance counters.
        /// </summary>
        public static string Name
        {
            get
            {
                return "AzureStorageClientPerfCounters";
            }
        }

        /// <summary>
        /// Gets or sets the collection of perf  counters for the storage client.
        /// </summary>
        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\CreateAzureTables\Properties\AssemblyInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CreateAzureTables")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\CreateAzureTables\CreateAzureTables.cs ===
//-------------------------------------------------------------------
// <copyright file="CreateAzureTables.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Tool to create Azure tables for notification and session services.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="03/24/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.CreateAzureTables
{
    using System;
    using AsyncMultiplayer.NotificationService;
    using Common.AzureStorage;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using SessionAzureStorage;

    /// <summary>
    /// The class that creates.
    /// </summary>
    public class CreateAzureTables
    {
        /// <summary>
        /// The name used to retrieve Azure settings in the NPDB configuration. 
        /// </summary>
        private const string ServiceConfigName = "notification_front_end";

        /// <summary>
        /// The name of the tool.
        /// </summary>
        private const string ComponentName = "CreateAzureTables";

        /// <summary>
        /// Gets the Azure storage account
        /// </summary>
        public static string AzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token
        /// </summary>
        public static string AzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the Azure table storage access endpoint.
        /// </summary>
        public static string AzureTableStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureTableStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure blob storage access endpoint. 
        /// </summary>
        public static string AzureBlobStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureBlobStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure retry count
        /// </summary>
        public static int AzureRetryCount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.AzureRetryCount);
            }
        }

        /// <summary>
        /// Gets the Azure queue storage access point. 
        /// </summary>
        public static string AzureQueueStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureQueueStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the proxy address for the environment. 
        /// </summary>
        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }

        /// <summary>
        /// Create the Azure tables, including session tables and notification tables.
        /// </summary>
        public static void Main()
        {
            Console.WriteLine("Start initialization...");

            try
            {
                // register the configuration providers
                Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
                Container.Instance.AddService<IFileSystem, FileSystem>();
                ConfigurationSelector.RegisterProvider(ServiceConfigName, "LEET");

                INotificationStorage notificationStorage = new NotificationAzureStorage(
                        AzureTableStorageEndPoint,
                        AzureStorageAccount,
                        AzureStorageToken,
                        ProxyAddress);

                UserDataAzureStorage userDataStorage = new UserDataAzureStorage(
                    AzureTableStorageEndPoint,
                    AzureStorageAccount,
                    AzureStorageToken,
                    ProxyAddress);

                StorageAccountInfo account = new StorageAccountInfo(
                    new Uri(AzureTableStorageEndPoint),
                    null,
                    AzureStorageAccount,
                    AzureStorageToken,
                    false);

                SessionAzureStorage sessionStorage = new SessionAzureStorage(account);

                RetryPolicy retryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));

                Console.WriteLine("Creating Notificatiohn/Session Azure Tables in the cloud...");
                Console.WriteLine("  Creating Session Tables...");
                retryPolicy(() =>
                {
                    try
                    {
                        sessionStorage.InitializeStorage();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.ToString());
                        Console.WriteLine("  Retrying ...");
                    }
                });

                Console.WriteLine("  Creating Notification Tables...");
                retryPolicy(() =>
                {
                    try
                    {
                        notificationStorage.InitializeStorage();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.ToString());
                        Console.WriteLine("  Retrying ...");
                    }
                });

                Console.WriteLine("  Creating User Data Tables...");
                retryPolicy(() =>
                {
                    try
                    {
                        userDataStorage.InitializeStorage();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.ToString());
                        Console.WriteLine("  Retrying ...");
                    }
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }

            Console.WriteLine("Done...");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\TableStorage.cs ===
//
// <copyright file="TableStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// This file contains helper classes for accessing the table storage service:
//      - base classes for tables and table entities (table rows) containing the necessary 
//        partition key and row key values
//      - methods for applying the table storage authentication scheme and for handling 
//        authentication in DataServiceContext objects
//      - helper methods for creating, listing, and managing tables
//      - a set of table storage constants
//      - convenience methods for dealing with continuation tokens and paging
//      - simple error handling helpers
//      - retry semantics for table storage requests
// 
// Examples of how to make use of the classes and methods in this file are available 
// in the simple sample application contained in this solution.  


using System;
using System.Collections.Generic;
using System.Data.Services.Client;
using System.Data.Services.Common;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;

// disable the generation of warnings for missing documentation elements for 
// public classes/members in this file
#pragma warning disable 1591

namespace AsyncMultiplayer.Common.AzureStorage
{

    /// <summary>
    /// Class representing some important table storage constants.
    /// </summary>
    public static class TableStorageConstants
    {
        /// <summary>
        /// The maximum size of strings per property/column is 64 kB (that is 32k characters.)
        /// Note: This constant is smaller for the development storage table service.
        /// </summary>
        public static readonly int MaxStringPropertySizeInBytes = 64 * 1024;


        /// <summary>
        /// One character in the standard UTF-16 character presentation is 2 bytes.
        /// Note: This constant is smaller for the development storage table service.
        /// </summary>
        public static readonly int MaxStringPropertySizeInChars = MaxStringPropertySizeInBytes / 2;

        /// <summary>
        /// We want to prevent users from the pitfall of mixing up Utc and local time.
        /// Because of this we add some time to the minimum supported datetime.
        /// As a result, there will be no error condition from the server even 
        /// if a user converts the minimum supported date time to a local time and 
        /// stores this in a DateTime field.
        /// The local development storage support the SQL range of dates which is narrower than the
        /// one for the table storage service and so we use that value here. 
        /// </summary>
        public static readonly DateTime MinSupportedDateTime = DateTime.FromFileTime(0).ToUniversalTime().AddYears(200);

        //You can use this if you are programming against the real table storage service only but then your
        //code will not work against the local development table storage.
        //public static readonly DateTime MinSupportedDateTime = DateTime.FromFileTime(0).ToUniversalTime().AddDays(7);

        /// <summary>
        /// Internal constant for querying tables.
        /// </summary>
        internal const string TablesName = "Tables";

        /// <summary>
        /// Internal constant for querying tables.
        /// </summary>
        internal const string TablesQuery = "/" + TablesName;
    }


    /// <summary>
    /// API entry point for using structured storage. The underlying usage pattern is designed to be 
    /// similar to the one used in blob and queue services in this library. 
    /// Users create a TableStorage object by calling the static Create() method passing account credential 
    /// information to this method. The TableStorage object can then be used to create, delete and list tables. 
    /// There are two methods to get DataServiceContext objects that conform to the appropriate security scheme. 
    /// The first way is to call the GetDataServiceContext() method on TableStorage objects. The naming is again 
    /// chosen to conform to the convention in the other APIs for blob and queue services in this library. 
    /// This class can also be used as an adapter pattern. I.e., DataServiceContext objects can be created 
    /// independnt from a TableStorage object. Calling the Attach() method will make sure that the appropriate 
    /// security signing is used on these objects. This design was chosen to support various usage patterns that 
    /// might become necessary for autogenerated code.
    /// </summary>
    public class TableStorage
    {

        /// <summary>
        /// The default retry policy
        /// </summary>
        [SuppressMessage("Microsoft.Security", "CA2104:DoNotDeclareReadOnlyMutableReferenceTypes",
                          Justification = "RetryPolicy is a non-mutable type")]
        public static readonly RetryPolicy DefaultRetryPolicy = RetryPolicies.NoRetry;


        /// <summary>
        /// Creates a TableStorage service object. This object is the entry point into the table storage API.
        /// </summary>
        /// <param name="baseUri">The base URI of the table storage service.</param>
        /// <param name="usePathStyleUris">Type of URI scheme used.</param>
        /// <param name="accountName">The account name.</param>
        /// <param name="base64Key">Base64 encoded version of the key.</param>
        /// <returns></returns>
        public static TableStorage Create(Uri baseUri,
                                          bool? usePathStyleUris,
                                          string accountName,
                                          string base64Key
                                         )
        {
            //We create a StorageAccountInfo and then extract the properties of that object.
            //This is because the constructor of StorageAccountInfo does normalization of BaseUri.
            StorageAccountInfo info = new StorageAccountInfo(
                                            baseUri,
                                            usePathStyleUris,
                                            accountName,
                                            base64Key
                                            );

            return new TableStorage(info.BaseUri, info.UsePathStyleUris, info.AccountName, info.Base64Key);
        }

        /// <summary>
        /// Creates a TableStorage object.
        /// </summary>
        public static TableStorage Create(StorageAccountInfo info)
        {
            return new TableStorage(info.BaseUri, info.UsePathStyleUris, info.AccountName, info.Base64Key);
        }

        /// <summary>
        /// Infers a list of tables from a DataServiceContext-derived type and makes sure
        /// those tables exist in the given service. The table endpoint information is retrieved from the 
        /// standard configuration settings.
        /// </summary>
        /// <remarks>
        /// Tables are inferred by finding all the public properties of type IQueryable&lt;T&gt; in 
        /// the provided type, where T is a type with an ID (in the case of table storage, this means it either
        /// has a [DataServiceKey("PartitionKey", "RowKey")] attribute in the class, or derives from
        /// the TableStorageEntity class included in this sample library (which in turn has that attribute).
        /// </remarks>
        public static void CreateTablesFromModel(Type serviceContextType)
        {
            CreateTablesFromModel(serviceContextType, StorageAccountInfo.DefaultTableStorageEndpointConfigurationString);
        }

        /// <summary>
        /// Infers a list of tables from a DataServiceContext-derived type and makes sure
        /// those tables exist in the given service.        
        /// </summary>
        /// <param name="serviceContextType">The DataServiceContext type from which the tables are inferred.</param>
        /// <param name="endpointConfiguration">A configuration string that is used to determine the table storage endpoint.</param>
        public static void CreateTablesFromModel(Type serviceContextType, string endpointConfiguration)
        {
            StorageAccountInfo account = StorageAccountInfo.GetAccountInfoFromConfiguration(endpointConfiguration);
            CreateTablesFromModel(serviceContextType, account);
        }

        /// <summary>
        /// Infers a list of tables from a DataServiceContext-derived type and makes sure
        /// those tables exist in the given service.        
        /// </summary>
        /// <param name="serviceContextType">The type of the DataServiceContext.</param>
        /// <param name="account">An object containing information about the table storage endpoint to be used.</param>
        public static void CreateTablesFromModel(Type serviceContextType, StorageAccountInfo account)
        {
            TableStorage tableStorage = TableStorage.Create(account);
            foreach (string tableName in DataServiceUtilities.EnumerateEntitySetNames(serviceContextType))
            {
                tableStorage.TryCreateTable(tableName);
            }
        }

        /// <summary>
        /// Creates a DataServiceContext object that takes care of implementing the table storage signing process.
        /// </summary>
        public TableStorageDataServiceContext GetDataServiceContext()
        {
            ResourceUriComponents uriComponents = new ResourceUriComponents(_accountName);
            Uri uri = HttpRequestAccessor.ConstructResourceUri(_baseUri, uriComponents, _usePathStyleUris);
            TableStorageDataServiceContext svc = new TableStorageDataServiceContext(uri, _accountName, _base64Key);
            if (svc != null)
            {
                svc.RetryPolicy = this.RetryPolicy;
            }
            return svc;
        }


        /// <summary>
        /// If the adaptor pattern with Attach() shall be used, this function can be used to generate the 
        /// table service base Uri depending on the path style syntax.
        /// </summary>
        static public Uri GetServiceBaseUri(Uri baseUri, bool usePathStyleUris, string accountName)
        {
            ResourceUriComponents uriComponents = new ResourceUriComponents(accountName);
            Uri uri = HttpRequestAccessor.ConstructResourceUri(baseUri, uriComponents, usePathStyleUris);
            return uri;
        }

        /// <summary>
        /// If the adaptor pattern with Attach() shall be used, this function can be used to generate the 
        /// table service base Uri depending on the path style syntax.
        /// </summary>
        static public Uri GetServiceBaseUri(StorageAccountInfo account)
        {
            return GetServiceBaseUri(account.BaseUri, account.UsePathStyleUris, account.AccountName);
        }

        /// <summary>
        /// If DataServiceContext objects are created at different places, this method can be called to configure the 
        /// DataServiceContext object to implement the required security scheme.
        /// </summary>
        public void Attach(DataServiceContext svc)
        {
            // this is an explicit way of dealing with situations where Attach() is called on objects that already 
            // have the necessary events hooked up to deal with table storage
            // in the event Attach() is called multiple times on a normal DataServiceContext object, we make sure to 
            // not doing authentication twice in the sending event itself
            if (svc is TableStorageDataServiceContext)
            {
                throw new ArgumentException("Cannot attach to a TableStorageDataServiceContext object. " +
                                            "These objects already contain the functionality for accessing the table storage service.");
            }
            new ContextRef(this, svc);
        }

        internal IEnumerable<TableStorageTable> ListTableImpl(DataServiceQuery<TableStorageTable> query)
        {
            IEnumerable<TableStorageTable> ret = null;

            RetryPolicy(() =>
            {
                try
                {
                    ret = query.Execute();
                }
                catch (InvalidOperationException e)
                {
                    if (TableStorageHelpers.CanBeRetried(e))
                    {
                        throw new TableRetryWrapperException(e);
                    }
                    throw;
                }
            });
            return ret;
        }

        /// <summary>
        /// Lists all the tables under this service's URL
        /// </summary>
        public IEnumerable<string> ListTables()
        {
            DataServiceContext svc = GetDataServiceContext();
            string nextKey = null;
            DataServiceQuery<TableStorageTable> localQuery;
            IEnumerable<TableStorageTable> tmp;
            svc.MergeOption = MergeOption.NoTracking;
            IQueryable<TableStorageTable> query = from t in svc.CreateQuery<TableStorageTable>(TableStorageConstants.TablesName)
                                                  select t;
            // result chunking
            // if we would not do this, the default value of 1000 is used before query result pagination
            // occurs
            query = query.Take(StorageHttpConstants.ListingConstants.MaxTableListResults);


            DataServiceQuery<TableStorageTable> orig = query as DataServiceQuery<TableStorageTable>;
            try
            {
                tmp = ListTableImpl(orig);
            }
            catch (InvalidOperationException e)
            {
                HttpStatusCode status;
                if (TableStorageHelpers.EvaluateException(e, out status) && status == HttpStatusCode.NotFound)
                {
                    yield break;
                }
                throw;
            }
            if (tmp == null)
            {
                yield break;
            }
            foreach (TableStorageTable table in tmp)
            {
                yield return table.TableName;
            }

            QueryOperationResponse qor = tmp as QueryOperationResponse;
            qor.Headers.TryGetValue(StorageHttpConstants.HeaderNames.PrefixForTableContinuation +
                                    StorageHttpConstants.HeaderNames.NextTableName,
                                    out nextKey);

            while (nextKey != null)
            {
                localQuery = orig;
                localQuery = localQuery.AddQueryOption(StorageHttpConstants.HeaderNames.NextTableName, nextKey);
                try
                {
                    tmp = ListTableImpl(localQuery);
                }
                catch (InvalidOperationException e)
                {
                    HttpStatusCode status;
                    if (TableStorageHelpers.EvaluateException(e, out status) && status == HttpStatusCode.NotFound)
                    {
                        yield break;
                    }
                    throw;
                }
                if (tmp == null)
                {
                    yield break;
                }
                foreach (TableStorageTable table in tmp)
                {
                    yield return table.TableName;
                }
                qor = tmp as QueryOperationResponse;
                qor.Headers.TryGetValue(StorageHttpConstants.HeaderNames.PrefixForTableContinuation +
                                        StorageHttpConstants.HeaderNames.NextTableName,
                                        out nextKey);
            }

        }

        /// <summary>
        /// Creates a new table in the service
        /// </summary>
        /// <param name="tableName">The name of the table to be created</param>
        public void CreateTable(string tableName)
        {
            ParameterValidator.CheckStringParameter(tableName, false, "tableName");
            if (!Utilities.IsValidTableName(tableName))
            {
                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture, "The specified table name \"{0}\" is not valid!" +
                                            "Please choose a name that conforms to the naming conventions for tables!", tableName));
            }
            RetryPolicy(() =>
            {
                try
                {
                    DataServiceContext svc = GetDataServiceContext();
                    svc.AddObject(TableStorageConstants.TablesName, new TableStorageTable() { TableName = tableName });
                    svc.SaveChanges();
                }
                // exceptions are DataServiceClientException, DataServiceQueryException and DataServiceRequestException
                // all of the above exceptions are InvalidOperationExceptions
                catch (InvalidOperationException e)
                {
                    HttpStatusCode status;
                    if (TableStorageHelpers.CanBeRetried(e, out status))
                    {
                        if (status == HttpStatusCode.Conflict)
                        {
                            // don't retry in this case as this is an expected exception if the table exists
                            // just return the exception
                            throw;
                        }
                        else
                        {
                            throw new TableRetryWrapperException(e);
                        }
                    }
                    throw;
                }
            });
        }

        /// <summary>
        /// Tries to create a table with the given name.
        /// The main difference to the CreateTable method is that this function first queries the 
        /// table storage service whether the table already exists, before it tries to actually create 
        /// the table. The reason is that this 
        /// is more lightweight for the table storage service than always trying to create a table that 
        /// does already exist. Furthermore, as we expect that applications don't really randomly create
        /// tables, the additional roundtrip that is required for creating the table is necessary only very
        /// rarely.
        /// </summary>
        /// <param name="tableName">The name of the table.</param>
        /// <returns>True if the operation was completed successfully. False if the table already exists.</returns>
        public bool TryCreateTable(string tableName)
        {
            ParameterValidator.CheckStringParameter(tableName, false, "tableName");
            if (DoesTableExist(tableName))
            {
                return false;
            }
            try
            {
                CreateTable(tableName);
                return true;
            }
            catch (InvalidOperationException e)
            {
                HttpStatusCode status;
                if (TableStorageHelpers.EvaluateException(e, out status) && status == HttpStatusCode.Conflict)
                {
                    return false;
                }
                throw;
            }
        }

        /// <summary>
        /// Checks whether a table with the same name already exists.
        /// </summary>
        /// <param name="tableName">The name of the table to check.</param>
        /// <returns>True iff the table already exists.</returns>
        public bool DoesTableExist(string tableName)
        {
            ParameterValidator.CheckStringParameter(tableName, false, "tableName");
            bool tableExists = false;

            RetryPolicy(() =>
            {
                try
                {
                    DataServiceContext svc = GetDataServiceContext();
                    svc.MergeOption = MergeOption.NoTracking;
                    IEnumerable<TableStorageTable> query = from t in svc.CreateQuery<TableStorageTable>(TableStorageConstants.TablesName)
                                                           where t.TableName == tableName
                                                           select t;
                    tableExists = false;
                    try
                    {
                        // the query contains the whole primary key
                        // thus, if the query succeeds we can be sure that the table exists
                        (query as DataServiceQuery<TableStorageTable>).Execute();
                        tableExists = true;
                    }
                    catch (DataServiceQueryException e)
                    {
                        HttpStatusCode s;
                        if (TableStorageHelpers.EvaluateException(e, out s) && s == HttpStatusCode.NotFound)
                        {
                            tableExists = false;
                        }
                        else
                        {
                            throw;
                        }
                    }
                    catch (NullReferenceException ne)
                    {
                        //This is a workaround for bug in DataServiceQuery<T>.Execute. It throws a
                        //NullReferenceException instead of a DataServiceRequestException when it
                        //cannot connect to the the server. This workaround will be removed when
                        //the fix for this bug is released.
                        throw new DataServiceRequestException("Unable to connect to server.", ne);
                    }
                }
                catch (InvalidOperationException e)
                {
                    HttpStatusCode status;
                    if (TableStorageHelpers.CanBeRetried(e, out status))
                    {
                        throw new TableRetryWrapperException(e);
                    }
                    throw;
                }
            });
            return tableExists;
        }

        /// <summary>
        /// Deletes a table from the service.
        /// </summary>
        /// <param name="tableName">The name of the table to be deleted</param>
        public void DeleteTable(string tableName)
        {
            ParameterValidator.CheckStringParameter(tableName, false, "tableName");

            RetryPolicy(() =>
            {
                try
                {
                    DataServiceContext svc = GetDataServiceContext();
                    TableStorageTable table = new TableStorageTable() { TableName = tableName };
                    svc.AttachTo(TableStorageConstants.TablesName, table);
                    svc.DeleteObject(table);
                    svc.SaveChanges();
                }
                catch (InvalidOperationException e)
                {
                    HttpStatusCode status;
                    if (TableStorageHelpers.CanBeRetried(e, out status))
                    {
                        // we do this even thouh NoContent is currently not in the exceptions that 
                        // are retried
                        if (status == HttpStatusCode.NoContent || status == HttpStatusCode.NotFound)
                        {
                            // don't retry in this case, just return the exception
                            throw;
                        }
                        else
                        {
                            throw new TableRetryWrapperException(e);
                        }
                    }
                    throw;
                }
            });
        }

        /// <summary>
        /// Tries to delete the table with the given name. 
        /// </summary>
        /// <param name="tableName">The name of the table to delete.</param>
        /// <returns>True if the table was successfully deleted. False if the table does not exists.</returns>
        public bool TryDeleteTable(string tableName)
        {
            ParameterValidator.CheckStringParameter(tableName, false, "tableName");
            try
            {
                DeleteTable(tableName);
                return true;
            }
            catch (InvalidOperationException e)
            {
                HttpStatusCode status;
                if (TableStorageHelpers.EvaluateException(e, out status) && status == HttpStatusCode.NotFound)
                {
                    return false;
                }
                throw;
            }
        }

        /// <summary>
        /// The retry policy used for retrying requests
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// The base URI of the table storage service
        /// </summary>
        public Uri BaseUri
        {
            get
            {
                return this._baseUri;
            }
        }

        /// <summary>
        /// The name of the storage account
        /// </summary>
        public string AccountName
        {
            get
            {
                return this._accountName;
            }
        }

        /// <summary>
        /// Indicates whether to use/generate path-style or host-style URIs
        /// </summary>
        public bool UsePathStyleUris
        {
            get
            {
                return this._usePathStyleUris;
            }
        }

        /// <summary>
        /// The base64 encoded version of the key.
        /// </summary>
        internal string Base64Key
        {
            get
            {
                return _base64Key;
            }
        }

        internal protected TableStorage(Uri baseUri,
                            bool? usePathStyleUris,
                            string accountName,
                            string base64Key
                            )
        {
            this._baseUri = baseUri;
            this._accountName = accountName;
            this._base64Key = base64Key;
            if (usePathStyleUris == null)
            {
                this._usePathStyleUris = Utilities.StringIsIPAddress(baseUri.Host);
            }
            else
            {
                this._usePathStyleUris = usePathStyleUris.Value;
            }
            RetryPolicy = DefaultRetryPolicy;
        }

        private Uri _baseUri;
        private bool _usePathStyleUris;
        private string _accountName;
        private string _base64Key;
    }



    public static class TableStorageHelpers
    {

        #region Error handling helpers

        /// <summary>
        /// Checks whether the exception is or contains a DataServiceClientException and extracts the 
        /// returned http status code and extended error information.
        /// </summary>
        /// <param name="exception">The exception from which to extract information</param>
        /// <param name="status">The Http status code for the exception</param>
        /// <param name="extendedErrorInfo">Extended error information including storage service specific
        /// error code and error message</param>
        /// <returns>True if the exception is or contains a DataServiceClientException.</returns>
        public static bool EvaluateException(
            Exception exception,
            out HttpStatusCode status,
            out StorageExtendedErrorInformation extendedErrorInfo
            )
        {
            return EvaluateExceptionImpl(exception, out status, out extendedErrorInfo, true);
        }

        /// <summary>
        /// Checks whether the exception is or contains a DataServiceClientException and extracts the 
        /// returned http status code.
        /// </summary>
        /// <param name="exception">The exception from which to extract information</param>
        /// <param name="status">The Http status code for the exception</param>
        /// <returns>True if the exception is or contains a DataServiceClientException.</returns>
        public static bool EvaluateException(
            Exception exception,
            out HttpStatusCode status
            )
        {
            StorageExtendedErrorInformation extendedErrorInfo;
            return EvaluateExceptionImpl(exception, out status, out extendedErrorInfo, false);
        }

        private static bool EvaluateExceptionImpl(
            Exception e,
            out HttpStatusCode status,
            out StorageExtendedErrorInformation extendedErrorInfo,
            bool getExtendedErrors
            )
        {
            status = HttpStatusCode.Unused;
            extendedErrorInfo = null;
            while (e.InnerException != null)
            {
                e = e.InnerException;

                DataServiceClientException dsce = e as DataServiceClientException;
                if (dsce != null)
                {
                    status = (HttpStatusCode)dsce.StatusCode;
                    if (getExtendedErrors)
                        extendedErrorInfo = Utilities.GetExtendedErrorFromXmlMessage(dsce.Message);
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Checks whether the exception is either a DataServiceClientException, a DataServiceQueryException or a 
        /// DataServiceRequestException.
        /// </summary>
        public static bool IsTableStorageException(Exception exception)
        {
            return ((exception is DataServiceClientException) || (exception is DataServiceQueryException) || (exception is DataServiceRequestException));
        }

        /// <summary>
        /// Only certain classes of errors should be retried. This method evaluates an exception 
        /// and returns whether this class of exception can be retried.
        /// </summary>
        /// <param name="e">The exception to analyze.</param>
        /// <param name="statusCode">The HttpStatusCode retrieved from the exception.</param>
        internal static bool CanBeRetried(InvalidOperationException e, out HttpStatusCode statusCode)
        {
            HttpStatusCode status;

            statusCode = HttpStatusCode.Unused;
            if (EvaluateException(e, out status))
            {
                statusCode = status;
                if (status == HttpStatusCode.RequestTimeout ||
                    // server error codes above 500
                    status == HttpStatusCode.ServiceUnavailable ||
                    status == HttpStatusCode.InternalServerError ||
                    status == HttpStatusCode.BadGateway ||
                    status == HttpStatusCode.GatewayTimeout)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Overload that does not retrun the HttpStatusCode.
        /// </summary>
        internal static bool CanBeRetried(InvalidOperationException e)
        {
            HttpStatusCode ignored;
            return CanBeRetried(e, out ignored);
        }

        #endregion

        #region Methods for checking properties to be inserted into a table

        /// <summary>
        /// Checks whether the string can be inserted in a table storage table. Throws an exception if 
        /// this is not the case.
        /// </summary>
        /// <param name="propertyValue"></param>
        public static void CheckStringProperty(string propertyValue)
        {
            if (string.IsNullOrEmpty(propertyValue))
            {
                throw new ArgumentException("The string cannot be null or empty!");
            }
            if (propertyValue.Length > TableStorageConstants.MaxStringPropertySizeInChars)
            {
                throw new ArgumentException("The string cannot be longer than the maximum string property size.");
            }
        }

        /// <summary>
        /// Checks whether the string can be inserted into a table storage table.
        /// </summary>
        public static bool ValidateStringProperty(string propertyValue)
        {
            if (string.IsNullOrEmpty(propertyValue))
            {
                return false;
            }
            if (propertyValue.Length > TableStorageConstants.MaxStringPropertySizeInChars)
            {
                return false;
            }
            return true;
        }

        #endregion

    }

    [DataServiceKey("TableName")]
    public class TableStorageTable
    {
        private string _tableName;


        /// <summary>
        /// The table name.
        /// </summary>
        public string TableName
        {
            get
            {
                return this._tableName;
            }

            set
            {
                ParameterValidator.CheckStringParameter(value, false, "TableName");
                this._tableName = value;
            }
        }

        public TableStorageTable()
        {
        }

        /// <summary>
        /// Creates a table with the specified name.
        /// </summary>
        /// <param name="name">The name of the table.</param>
        public TableStorageTable(string name)
        {
            ParameterValidator.CheckStringParameter(name, false, "name");
            this.TableName = name;
        }

        public override bool Equals(object obj)
        {
            if (obj == null)
            {
                return false;
            }
            TableStorageTable rhs = obj as TableStorageTable;

            if (rhs == null)
            {
                return false;
            }

            return (this.TableName == rhs.TableName);
        }

        public override int GetHashCode()
        {
            return this.TableName.GetHashCode();
        }
    }


    /// <summary>
    /// This class represents an entity (row) in a table in table storage.
    /// </summary>
    [CLSCompliant(false)]
    [DataServiceKey("PartitionKey", "RowKey")]
    public abstract class TableStorageEntity
    {

        public DateTime Timestamp
        {
            get;
            set;
        }

        /// <summary>
        /// The partition key of a table entity. The concatenation of the partition key 
        /// and row key must be unique per table.
        /// </summary>
        public virtual string PartitionKey
        {
            get;
            set;
        }

        /// <summary>
        /// The row key of a table entity.
        /// </summary>
        public virtual string RowKey
        {
            get;
            set;
        }

        /// <summary>
        /// Creates a TableStorageEntity object.
        /// </summary>
        protected TableStorageEntity(string partitionKey, string rowKey)
        {
            PartitionKey = partitionKey;
            RowKey = rowKey;
        }

        /// <summary>
        /// Creates a TableStorageEntity object.
        /// </summary>
        protected TableStorageEntity()
        {
        }

        
        /// <summary>
        /// Compares to entities.
        /// </summary>
        public override bool Equals(object obj)
        {
            if (obj == null)
            {
                return false;
            }
            TableStorageEntity rhs = obj as TableStorageEntity;

            if (rhs == null)
            {
                return false;
            }

            return (this.PartitionKey == rhs.PartitionKey
                       && this.RowKey == rhs.RowKey);
        }
        

        /// <summary>
        /// Computes a HashCode for this object.
        /// </summary>
        public override int GetHashCode()
        {
            if (PartitionKey == null)
            {
                return base.GetHashCode();
            }
            if (!String.IsNullOrEmpty(this.RowKey))
            {
                return this.PartitionKey.GetHashCode() ^ this.RowKey.GetHashCode();
            }
            else
            {
                return this.PartitionKey.GetHashCode();
            }
        }
    }

    /// <summary>
    /// This class can be used for handling continuation tokens in TableStorage.
    /// </summary>
    /// <typeparam name="TElement"></typeparam>
    public class TableStorageDataServiceQuery<TElement>
    {

        private DataServiceQuery<TElement> _query;

        /// <summary>
        /// Objects of this class can be created using this constructor directly or by 
        /// calling a factory method on the TableStorageDataServiceContext class
        /// </summary>
        public TableStorageDataServiceQuery(DataServiceQuery<TElement> query)
            : this(query, RetryPolicies.NoRetry)
        {
        }

        /// <summary>
        /// Objects of this class can be created using this constructor directly or by 
        /// calling a factory method on the TableStorageDataServiceContext class
        /// </summary>
        public TableStorageDataServiceQuery(DataServiceQuery<TElement> query, RetryPolicy policy)
        {
            if (query == null)
            {
                throw new ArgumentNullException("query");
            }
            _query = query;
            RetryPolicy = policy;
        }

        /// <summary>
        /// Gets the underlying normal query object.
        /// </summary>
        public DataServiceQuery<TElement> Query
        {
            get
            {
                return _query;
            }
            set
            {
                _query = value;
            }
        }


        /// <summary>
        /// The retry policy used for retrying requests
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Normal Execute() on the query without retry. Just maps to _query.Execute().
        /// </summary>
        /// <returns></returns>
        public IEnumerable<TElement> Execute()
        {
            return ExecuteWithRetries(RetryPolicies.NoRetry);
        }

        /// <summary>
        /// Calling Execute() on the query with the current retry policy.
        /// </summary>
        /// <returns>An IEnumerable respresenting the results of the query.</returns>
        public IEnumerable<TElement> ExecuteWithRetries()
        {
            return ExecuteWithRetries(RetryPolicy);
        }

        /// <summary>
        /// Calling Execute() on the query with the current retry policy.
        /// </summary>
        /// <param name="retry">The retry policy to be used for this request.</param>
        /// <returns>An IEnumerable respresenting the results of the query.</returns>
        public IEnumerable<TElement> ExecuteWithRetries(RetryPolicy retry)
        {
            IEnumerable<TElement> ret = null;
            if (retry == null)
            {
                throw new ArgumentNullException("retry");
            }
            retry(() =>
            {
                try
                {
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRun);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRunPerSecond);
                    Stopwatch stopWatch = new Stopwatch();
                    stopWatch.Start();
                    try
                    {
                        ret = _query.Execute();
                    }
                    catch (Exception)
                    {
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrors);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrorsPerSecond);
                        throw;
                    }
                    finally
                    {
                        stopWatch.Stop();
                        StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureTableQueriesDuration, stopWatch.ElapsedTicks);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesDurationBase);
                    }
                }
                catch (InvalidOperationException e)
                {
                    if (TableStorageHelpers.CanBeRetried(e))
                    {
                        throw new TableRetryWrapperException(e);
                    }
                    throw;
                }
            });
            return ret;
        }

        /// <summary>
        /// Returns all results of the query and hides the complexity of continuation if 
        /// this is desired by a user. Users should be aware that this operation can return 
        /// many objects. Uses no retries.
        /// Important: this function does not call Execute immediately. Instead, it calls Execute() on 
        /// the query only when the result is enumerated. This is a difference to the normal 
        /// Execute() and Execute() with retry method.         
        /// </summary>
        /// <returns>An IEnumerable representing the results of the query.</returns>
        public IEnumerable<TElement> ExecuteAll()
        {
            return ExecuteAll(false);
        }

        /// <summary>
        /// Returns all results of the query and hides the complexity of continuation if 
        /// this is desired by a user. Users should be aware that this operation can return 
        /// many objects. This operation also uses the current retry policy.
        /// Important: this function does not call Execute immediately. Instead, it calls Execute() on 
        /// the query only when the result is enumerated. This is a difference to the normal 
        /// Execute() and Execute() with retry method. 
        /// </summary>
        /// <returns>An IEnumerable representing the results of the query.</returns>
        public IEnumerable<TElement> ExecuteAllWithRetries()
        {
            return ExecuteAll(true);
        }

        /// <summary>
        /// Returns all results of the query and hides the complexity of continuation if 
        /// this is desired by a user. Users should be aware that this operation can return 
        /// many objects. 
        /// Important: this function does not call Execute immediately. Instead, it calls Execute() on 
        /// the query only when the result is enumerated. This is a difference to the normal 
        /// Execute() and Execute() with retry method. 
        /// </summary>
        /// <param name="withRetry">Determines whether to use retries or not.</param>
        /// <returns>An IEnumerable representing the results of the query.</returns>
        public IEnumerable<TElement> ExecuteAll(bool withRetry)
        {
            IEnumerable<TElement> res;
            IEnumerable<TElement> tmp;
            string nextPartitionKey = null;
            string nextRowKey = null;
            DataServiceQuery<TElement> localQuery;

            if (_query == null)
            {
                throw new ArgumentException("The local DataServiceQuery element cannot be null!");
            }

            if (withRetry)
            {
                res = ExecuteWithRetries();
            }
            else
            {
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRun);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRunPerSecond);
                Stopwatch stopWatch = new Stopwatch();
                stopWatch.Start();
                try
                {
                    res = _query.Execute();
                }
                catch (Exception)
                {
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrors);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrorsPerSecond);
                    throw;
                }
                finally
                {
                    stopWatch.Stop();
                    StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureTableQueriesDuration, stopWatch.ElapsedTicks);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesDurationBase);
                }
            }
            if (res == null)
            {
                yield break;
            }
            foreach (TElement item in res)
            {
                yield return item;
            }
            QueryOperationResponse qor = res as QueryOperationResponse;
            qor.Headers.TryGetValue(StorageHttpConstants.HeaderNames.PrefixForTableContinuation +
                                    StorageHttpConstants.HeaderNames.NextPartitionKey,
                                    out nextPartitionKey);
            qor.Headers.TryGetValue(StorageHttpConstants.HeaderNames.PrefixForTableContinuation +
                                    StorageHttpConstants.HeaderNames.NextRowKey,
                                    out nextRowKey);

            while (nextPartitionKey != null || nextRowKey != null)
            {
                localQuery = _query;
                if (nextPartitionKey != null)
                {
                    localQuery = localQuery.AddQueryOption(StorageHttpConstants.HeaderNames.NextPartitionKey, nextPartitionKey);
                }
                if (nextRowKey != null)
                {
                    localQuery = localQuery.AddQueryOption(StorageHttpConstants.HeaderNames.NextRowKey, nextRowKey);
                }
                if (withRetry)
                {
                    TableStorageDataServiceQuery<TElement> retryQuery = new TableStorageDataServiceQuery<TElement>(localQuery, RetryPolicy);
                    tmp = retryQuery.ExecuteWithRetries();
                }
                else
                {
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRun);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRunPerSecond);
                    Stopwatch stopWatch = new Stopwatch();
                    stopWatch.Start();
                    try
                    {
                        tmp = localQuery.Execute();
                    }
                    catch (Exception)
                    {
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrors);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrorsPerSecond);
                        throw;
                    }
                    finally
                    {
                        stopWatch.Stop();
                        StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureTableQueriesDuration, stopWatch.ElapsedTicks);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesDurationBase);
                    }
                }
                if (tmp == null)
                {
                    yield break;
                }
                foreach (TElement item in tmp)
                {
                    yield return item;
                }
                qor = tmp as QueryOperationResponse;
                qor.Headers.TryGetValue(StorageHttpConstants.HeaderNames.PrefixForTableContinuation +
                                        StorageHttpConstants.HeaderNames.NextPartitionKey,
                                        out nextPartitionKey);
                qor.Headers.TryGetValue(StorageHttpConstants.HeaderNames.PrefixForTableContinuation +
                                        StorageHttpConstants.HeaderNames.NextRowKey,
                                        out nextRowKey);
            }
        }
    }

    /// <summary>
    /// The table storage-specific DataServiceContext class. It adds functionality for handling 
    /// the authentication process required by the table storage service.
    /// </summary>
    public class TableStorageDataServiceContext : DataServiceContext
    {
        private string _sharedKey;
        private string _accountName;

        /// <summary>
        /// Creates a DataServiceContext object and configures it so that it can be used with the table storage service.
        /// </summary>
        /// <param name="serviceRoot">The root URI of the service.</param>
        /// <param name="accountName">The account name.</param>
        /// <param name="sharedKey">The shared key associated with this service.</param>
        internal TableStorageDataServiceContext(Uri serviceRoot, string accountName, string sharedKey)
            : base(serviceRoot)
        {
            if (string.IsNullOrEmpty(accountName))
            {
                throw new ArgumentNullException("accountName");
            }
            if (string.IsNullOrEmpty(sharedKey))
            {
                throw new ArgumentNullException("sharedKey");
            }
            _sharedKey = sharedKey;
            _accountName = accountName;
            SendingRequest += new EventHandler<SendingRequestEventArgs>(DataContextSendingRequest);
            IgnoreMissingProperties = true;

            // we assume that this is the expected client behavior
            MergeOption = MergeOption.PreserveChanges;

            RetryPolicy = TableStorage.DefaultRetryPolicy;
        }

        /// <summary>
        /// Creates a DataServiceContext object and configures it so that it can be used with the table storage service.
        /// </summary>
        /// <param name="account">A StorageAccountInfo object containing information about how to access the table storage service.</param>
        public TableStorageDataServiceContext(StorageAccountInfo account)
            : this(TableStorage.GetServiceBaseUri(account), account.AccountName, account.Base64Key) { }


        /// <summary>
        /// Creates a DataServiceContext object and configures it so that it can be used with the table storage service.
        /// Information on the table storage endpoint is retrieved by accessing configuration settings in the app config section 
        /// of a Web.config or app config file, or by accessing settings in cscfg files.
        /// </summary>
        public TableStorageDataServiceContext()
            : this(StorageAccountInfo.GetAccountInfoFromConfiguration(StorageAccountInfo.DefaultTableStorageEndpointConfigurationString)) { }


        /// <summary>
        /// The retry policy used for retrying requests
        /// </summary>
        public RetryPolicy RetryPolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Calls the SaveChanges() method and applies retry semantics.
        /// </summary>
        public DataServiceResponse SaveChangesWithRetries()
        {
            DataServiceResponse ret = null;
            RetryPolicy(() =>
            {
                try
                {
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRun);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRunPerSecond);
                    Stopwatch stopWatch = new Stopwatch();
                    stopWatch.Start();
                    try
                    {
                        ret = SaveChanges();
                    }
                    catch (Exception)
                    {
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrors);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrorsPerSecond);
                        throw;
                    }
                    finally
                    {
                        stopWatch.Stop();
                        StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureTableQueriesDuration, stopWatch.ElapsedTicks);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesDurationBase);
                    }
                }
                catch (InvalidOperationException e)
                {
                    if (TableStorageHelpers.CanBeRetried(e))
                    {
                        throw new TableRetryWrapperException(e);
                    }
                    throw;
                }
            });
            return ret;
        }

        /// <summary>
        /// Calls the SaveChanges() method and applies retry semantics.
        /// </summary>
        public DataServiceResponse SaveChangesWithRetries(SaveChangesOptions options)
        {
            DataServiceResponse ret = null;
            RetryPolicy(() =>
            {
                try
                {
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRun);
                    StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesRunPerSecond);
                    Stopwatch stopWatch = new Stopwatch();
                    stopWatch.Start();
                    try
                    {
                        ret = SaveChanges(options);
                    }
                    catch (Exception)
                    {
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrors);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueryErrorsPerSecond);
                        throw;
                    }
                    finally
                    {
                        stopWatch.Stop();
                        StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureTableQueriesDuration, stopWatch.ElapsedTicks);
                        StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureTableQueriesDurationBase);
                    }
                }
                catch (InvalidOperationException e)
                {
                    if (TableStorageHelpers.CanBeRetried(e))
                    {
                        throw new TableRetryWrapperException(e);
                    }
                    throw;
                }
            });
            return ret;
        }

        /// <summary>
        /// Callback method called whenever a request is sent to the table service. This 
        /// is where the signing of the request takes place.
        /// </summary>
        private void DataContextSendingRequest(object sender, SendingRequestEventArgs e)
        {
            HttpWebRequest request = e.Request as HttpWebRequest;

            // this setting can potentially result in very rare error conditions from HttpWebRequest
            // using retry policies, these error conditions are dealt with
            request.KeepAlive = true;

            // do the authentication
            byte[] key;
            SharedKeyCredentials credentials;

            Debug.Assert(_sharedKey != null);
            key = Convert.FromBase64String(_sharedKey);
            credentials = new SharedKeyCredentials(_accountName, key);
            credentials.SignRequestForSharedKeyLite(request, new ResourceUriComponents(_accountName, _accountName));
        }
    }

    #region Internal and private helpers

    /// <summary>
    /// Helper class to avoid long-lived references to context objects
    /// </summary>
    /// <remarks>
    /// Need to be careful not to maintain a reference to the context
    /// object from the auth adapter, since the adapter is probably
    /// long-lived and the context is not. This intermediate helper
    /// class is the one subscribing to context events, so when the
    /// context can be collected then this will be collectable as well.
    /// </remarks>
    internal class ContextRef
    {
        private TableStorage _adapter;

        public ContextRef(TableStorage adapter, DataServiceContext context)
        {
            if (adapter == null)
            {
                throw new ArgumentNullException("adapter");
            }
            if (context == null)
            {
                throw new ArgumentNullException("context");
            }
            this._adapter = adapter;
            context.SendingRequest += this.HandleSendingRequest;
        }

        private void HandleSendingRequest(object sender, SendingRequestEventArgs e)
        {
            HttpWebRequest request = e.Request as HttpWebRequest;

            // first, we have to make sure that the request is not signed twice
            // this could happen if Attach() is called multiple times on the same DataServiceContext object
            WebHeaderCollection col = request.Headers;
            if (col != null)
            {
                foreach (string header in col)
                {
                    if (string.Compare(header, StorageHttpConstants.HeaderNames.StorageDateTime, StringComparison.Ordinal) == 0)
                    {
                        return;
                    }
                }
            }

            // this setting can potentially result in very rare error conditions from HttpWebRequest
            // using retry policies, these error conditions are dealt with
            request.KeepAlive = true;

            // do the authentication
            byte[] key;
            SharedKeyCredentials credentials;

            Debug.Assert(_adapter.Base64Key != null);
            key = Convert.FromBase64String(_adapter.Base64Key);
            credentials = new SharedKeyCredentials(_adapter.AccountName, key);
            credentials.SignRequestForSharedKeyLite(request, new ResourceUriComponents(_adapter.AccountName, _adapter.AccountName));
        }
    }

    /// <summary>
    /// The retry policies for blobs and queues deal with special StorageClient and StorageServer exceptions.
    /// In case of tables, we don't want to return these exceptions but instead the normal data service 
    /// exception. This class serves as a simple wrapper for these exceptions, and indicates that we 
    /// need retries.
    /// Data service exceptions are stored as inner exceptions.
    /// </summary>
    [Serializable]
    public class TableRetryWrapperException : Exception
    {
        /// <summary>
        /// Creates a TableRetryWrapperException object.
        /// </summary>
        public TableRetryWrapperException()
            : base()
        {
        }

        /// <summary>
        /// Creates a TableRetryWrapperException object.
        /// </summary>
        public TableRetryWrapperException(Exception innerException)
            : base(string.Empty, innerException)
        {
        }

        /// <summary>
        /// Creates a TableRetryWrapperException object.
        /// </summary>
        public TableRetryWrapperException(string message)
            : base(message)
        {
        }

        /// <summary>
        /// Creates a TableRetryWrapperException object.
        /// </summary>
        public TableRetryWrapperException(string message, Exception innerException)
            : base(message, innerException)
        {
        }

        /// <summary>
        /// Creates a TableRetryWrapperException object.
        /// </summary>
        protected TableRetryWrapperException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
        }

    }

    internal static class ParameterValidator
    {
        internal static void CheckStringParameter(string s, bool canBeNullOrEmpty, string name)
        {
            if (string.IsNullOrEmpty(s) && !canBeNullOrEmpty)
            {
                throw new ArgumentException(
                    string.Format(CultureInfo.InvariantCulture, "The parameter {0} cannot be null or empty.", name));
            }
            if (s.Length > TableStorageConstants.MaxStringPropertySizeInChars)
            {
                throw new ArgumentException(
                    string.Format(CultureInfo.InvariantCulture,
                        "The parameter {0} cannot be longer than {1} characters.",
                        name, TableStorageConstants.MaxStringPropertySizeInChars));
            }
        }
    }

    internal static class DataServiceUtilities
    {
        public static bool IsEntityType(Type t, Type contextType)
        {
            // ADO.NET data services convention: a type 't' is an entity if
            // 1) 't' has at least one key column
            // 2) there is a top level IQueryable<T> property in the context where T is 't' or a supertype of 't'
            // Non-primitive types that are not entity types become nested structures ("complex types" in EDM)

            if (!t.GetProperties().Any(p => IsKeyColumn(p))) return false;

            foreach (PropertyInfo pi in contextType.GetProperties())
            {
                if (typeof(IQueryable).IsAssignableFrom(pi.PropertyType))
                {
                    if (pi.PropertyType.GetGenericArguments()[0].IsAssignableFrom(t))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public static bool IsKeyColumn(PropertyInfo pi)
        {
            // Astoria convention:
            // 1) try the DataServiceKey attribute
            // 2) if not attribute, try <typename>ID
            // 3) finally, try just ID

            object[] attribs = pi.DeclaringType.GetCustomAttributes(typeof(DataServiceKeyAttribute), true);
            if (attribs != null && attribs.Length > 0)
            {
                Debug.Assert(attribs.Length == 1);
                return ((DataServiceKeyAttribute)attribs[0]).KeyNames.Contains(pi.Name);
            }

            if (pi.Name.Equals(pi.DeclaringType.Name + "ID", System.StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }

            if (pi.Name == "ID")
            {
                return true;
            }

            return false;
        }

        public static IEnumerable<PropertyInfo> EnumerateEntitySetProperties(Type contextType)
        {
            foreach (PropertyInfo prop in contextType.GetProperties())
            {
                if (typeof(IQueryable).IsAssignableFrom(prop.PropertyType) &&
                    prop.PropertyType.GetGenericArguments().Length > 0 &&
                    DataServiceUtilities.IsEntityType(prop.PropertyType.GetGenericArguments()[0], contextType))
                {
                    yield return prop;
                }
            }
        }

        public static IEnumerable<string> EnumerateEntitySetNames(Type contextType)
        {
            return EnumerateEntitySetProperties(contextType).Select(p => p.Name);
        }

    }

    #endregion
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\UnitTestUtilities\UnitTestHelper.cs ===
// <copyright file="UnitTestHelper.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-30</date>
// <summary>Contains the class definition for UnitTestHelper class.</summary>

namespace AsyncMultiplayer.Common.UnitTestUtilities
{
    using System;
    using System.Net;
    using Leet.Core.Utils;
    using Microsoft.VisualStudio.TestTools.UnitTesting;

    /// <summary>
    /// Helper class that provides methods for helping unit test development, like handling
    /// expected exceptions and serialization of classes.
    /// The code for this is derived from Pedro Silva's Blog:
    /// http://blogs.msdn.com/pedrosilva/archive/2007/09/24/testing-when-exceptions-are-expected.aspx
    /// </summary>
    public static class UnitTestHelper
    {
        #region Exception Handling Helpers

        /// <summary>
        /// Delegate to code to be tested.
        /// </summary>
        public delegate void ExceptionTestDelegate();

        /// <summary>
        /// Tests method for an expected exception being thrown.
        /// </summary>
        /// <param name="del">Delegate to code to be tested.</param>
        /// <param name="exception">Expected exception.</param>
        public static void TestException(ExceptionTestDelegate del, Type exception)
        {
            try
            {
                // Call the delegate, fail the test if it doesn't throw an exception.
                del();
                Assert.Fail("Test should have thrown exception " + exception.ToString() + ".");
            }
            catch (AssertFailedException)
            {
                // If it's a failed assert, then just rethrow because it's our failure above.
                throw;
            }
            catch (Exception e)
            {
                // Test that the method threw the exception that we were expecting.
                Assert.IsInstanceOfType(e, exception, "Exception is not of the expected type.", exception.ToString());
            }
        }

        /// <summary>
        /// Tests method for an expected LIVEnException being thrown with a specific status code.
        /// </summary>
        /// <param name="del">Delegate to code to be tested.</param>
        /// <param name="eventID">Expected eventID for the LIVEnException thrown.</param>
        public static void TestException(ExceptionTestDelegate del, int eventID)
        {
            string expectedName = typeof(LIVEnException).FullName;
            try
            {
                // Call the delegate, fail the test if it doesn't throw an exception.
                del();
                Assert.Fail("Test should have thrown a " + expectedName + " with eventID: " + eventID + ".");
            }
            catch (AssertFailedException)
            {
                // If it's a failed assert, then just rethrow because it's our failure above.
                throw;
            }
            catch (Exception e)
            {
                // Test that the method threw the exception that we were expecting.
                Assert.IsInstanceOfType(e, typeof(LIVEnException), "Exception is not of the expected type.", expectedName);

                LIVEnException livEnException = (LIVEnException)e;
                uint livEnExceptionEventID = livEnException.ErrorCode & 0x0000FFFF; // Disregard the higher 16 bits.
                if (livEnExceptionEventID != eventID)
                {
                    Assert.Fail(expectedName + " expected with eventID: " + eventID + " actual eventID thrown:" + livEnExceptionEventID);
                }
            }
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\UnitTestUtilities\FakeProfileProvider.cs ===
// <copyright file="FakeProfileProvider.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-12</date>
// <summary>Contains the class definition for FakeProfileProvider class.</summary>

namespace AsyncMultiplayer.Common.UnitTestUtilities
{
    using System;
    using Leet.Identity;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;

    /// <summary>
    /// Fake implementation of IProfileProvider.
    /// </summary>
    public class FakeProfileProvider : IProfileProvider
    {
        /// <summary>
        /// Gets the profile for the calling user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="locale">Locale of the strings returned</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="friendsInfoList">Friends info list.</param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the calling user</returns>
        public Profile GetProfile(IUserIdentity callerIdentity, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            friendsInfoList = null;
            return this.GetFakeProfile(sectionFlags, out partialResult);
        }

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="gamertag">
        /// Gamertag of the user whose profile is requested
        /// </param>
        /// <param name="locale">Locale of the strings returned</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="friendsInfoList">Friends info list</param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <param name="targetIdentity">
        /// Identity of the user whose profile is requested
        /// </param>
        /// <returns>Profile of the target user</returns>
        public Profile GetProfile(IUserIdentity callerIdentity, string gamertag, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult, out Identity targetIdentity)
        {
            targetIdentity = null;
            friendsInfoList = null;
            return this.GetFakeProfile(sectionFlags, out partialResult);
        }

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="targetXuid">Target's Xuid</param>
        /// <param name="locale">Locale of the caller</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="friendsInfoList">Friend list information.</param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the target user</returns>
        public Profile GetProfile(IUserIdentity callerIdentity, ulong targetXuid, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            friendsInfoList = null;
            return this.GetFakeProfile(sectionFlags, out partialResult);
        }

        /// <summary>
        /// Gets the profile for the target user specified. Only those sections
        /// of the profile specified in the sectionFlags bitmap are returned.
        /// Furthermore, only those data fields visible to the calling user will
        /// be returned.
        /// </summary>
        /// <param name="callerIdentity">Identity of the caller</param>
        /// <param name="cid">
        /// CID of the user whose profile is requested
        /// </param>
        /// <param name="locale">Locale of the strings returned</param>
        /// <param name="sectionFlags">
        /// Bitmap specifying which profile sections should be returned
        /// </param>
        /// <param name="friendsInfoList">Friends info list</param>
        /// <param name="partialResult">
        /// Indicates whether the profile being returned is only partially filled out 
        /// (due to connectivity or throttling, etc)
        /// </param>
        /// <returns>Profile of the target user</returns>
        public Profile GetProfile(IUserIdentity callerIdentity, long cid, string locale, long sectionFlags, out IReadOnlyFriendInfo[] friendsInfoList, out bool partialResult)
        {
            friendsInfoList = null;
            return this.GetFakeProfile(sectionFlags, out partialResult);
        }

        /// <summary>
        /// Gets a list of the calling user's friends
        /// </summary>
        /// <param name="callerIdentity">Calling user's identity</param>
        /// <param name="friendNetwork">Network friends are requested from</param>
        /// <param name="friendsListInfo">Friends info list</param>
        /// <param name="partialResult">
        /// Indicates whether partial results are being returned
        /// </param>
        /// <returns>Friends list.</returns>
        public XmlSerializableList<Profile> GetFriends(IUserIdentity callerIdentity, Network friendNetwork, out IReadOnlyFriendInfo[] friendsListInfo, out bool partialResult)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Get friends for leaderboard.
        /// </summary>
        /// <param name="callerIdentity">Caller identity.</param>
        /// <param name="friendNetwork">The social network.</param>
        /// <param name="partialResult">Partial results.</param>
        /// <returns>Friend info.</returns>
        public Leet.Live.Livecache.Logic.Profile.IReadOnlyFriendInfo[] GetFriendsForLeaderboard(IUserIdentity callerIdentity, Network friendNetwork, out bool partialResult)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Return the profile for a given array of xuids
        /// </summary>
        /// <param name="callingXuid">Caller xuid.</param>
        /// <param name="xuids">Array of xuids.</param>
        /// <returns>Gamer profile.</returns>
        public Leet.Live.Livecache.Logic.Profile.IGamerProfile[] GetProfile(
            ulong callingXuid,
            ulong[] xuids)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Gets fake profile.
        /// </summary>
        /// <param name="sectionFlags"> Bitmap specifying which profile sections should be returned </param>
        /// <param name="partialResult"> Indicates whether the profile being returned is only partially filled out </param>
        /// <returns>Profile of the target user.</returns>
        private Profile GetFakeProfile(long sectionFlags, out bool partialResult)
        {
            var profile = new Profile();
            partialResult = true;

            profile.ProfileProperties = new XmlSerializableDictionary<ProfileProperty, object>();
            var profileProperties = profile.ProfileProperties;

            profileProperties.Add(ProfileProperty.GamerTag, "FakeGamerTag");
            profileProperties.Add(ProfileProperty.GamerScore, 6666);
            profileProperties.Add(ProfileProperty.HasAvatar, true);
            profileProperties.Add(ProfileProperty.AvatarImageUrl, "http://avatar.xboxlive.com/avatar/alphazulu77/avatar-body.png");
            profileProperties.Add(ProfileProperty.Bio, "Fake bio");
            profileProperties.Add(ProfileProperty.GamerPicUrl, "http://image.xboxlive.com/global/t.585207d1/tile/0/20007");
            profileProperties.Add(ProfileProperty.SmallGamerPicUrl, "http://image.xboxlive.com/global/t.585207d1/tile/0/10007");
            profileProperties.Add(ProfileProperty.Location, "FakeLocation");
            profileProperties.Add(ProfileProperty.Motto, "Fake Motto!");
            profileProperties.Add(ProfileProperty.Name, "Fake Name");
            profileProperties.Add(ProfileProperty.MembershipLevel, "Fake Level");
            profileProperties.Add(ProfileProperty.GamerZone, "Fake Zone");

            return profile;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\UnitTestUtilities\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-30</date>
// <summary>Contains the assembly information for the UnitTestUtilities assembly.</summary>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("UnitTestUtilities")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6db089d7-a2bf-4b66-bddd-a87982f79ebc")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\CreateOrDeleteSessionTables\CreateOrDeleteSessionTables.cs ===
// <copyright file="CreateOrDeleteSessionTables.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-13</date>
// <summary>This file contains the code for the CreateOrDeleteSessionTables executable.</summary>

namespace AsyncMultiplayer.CreateOrDeleteSessionTables
{
    using System;
    using System.Text;
    using Common.AzureStorage;
    using NotificationService;
    using SessionAzureStorage;

    /// <summary>
    /// The class that contains the Main() method.
    /// </summary>
    public class CreateOrDeleteSessionTables
    {
        /// <summary>
        /// The Account information
        /// </summary>
        private static readonly StorageAccountInfo Account;

        /// <summary>
        /// Initializes static members of the CreateOrDeleteSessionTables class.
        /// </summary>
        static CreateOrDeleteSessionTables()
        {
            CreateOrDeleteSessionTables.Account = StorageAccountInfo.GetDefaultTableStorageAccountFromConfiguration();
        }

        /// <summary>
        /// Defines what Action is to be taken
        /// </summary>
        private enum Action
        {
            /// <summary>
            /// Create tables Action.
            /// </summary>
            Create,

            /// <summary>
            /// Delete tables Action.
            /// </summary>
            Delete
        }

        /// <summary>
        /// Gets the name of the program.
        /// </summary>
        public static string ProgramName
        {
            get { return "CreateOrDeleteSessionTables"; }
        }

        /// <summary>
        /// This is the main method of the executable.
        /// It will read the App.config to get the endpoint/Account information.
        /// Usage of the exe: CreateOrDeleteSessionTables create/delete
        /// </summary>
        /// <param name="args">The arguments passed to the executable </param>
        public static void Main(string[] args)
        {
            Action act;
            
            if (args.Length != 1)
            {
                DisplayUsage();
                return;
            }
            else
            {
                if ("create".Equals(args[0].ToLower()))
                {
                    act = Action.Create;
                }
                else if ("delete".Equals(args[0].ToLower()))
                {
                    act = Action.Delete;
                }
                else
                {
                    DisplayUsage();
                    return;
                }
            }

            Console.WriteLine(CreateOrDeleteSessionTables.ProgramName + ": Creates or deletes Azure tables from the cloud.");

            if (act == Action.Create)
            {
                CreateTables();
            }
            else
            {
                DeleteTables();
            }

            Console.WriteLine(CreateOrDeleteSessionTables.ProgramName + ": Ended.");
        }

        /// <summary>
        /// Create the session and notification tables.
        /// </summary>
        private static void CreateTables()
        {
            Console.WriteLine(CreateOrDeleteSessionTables.ProgramName + ": Creating Session Azure Tables in the cloud...");
            SessionAzureStorage azureStorage = new SessionAzureStorage(Account);
            azureStorage.InitializeStorage();
            Console.WriteLine(CreateOrDeleteSessionTables.ProgramName + ": Created Session Azure Tables.");

            Console.WriteLine(CreateOrDeleteSessionTables.ProgramName + ": Creating Notification Azure Tables in the cloud...");
            NotificationAzureStorage notificationAzureStorage = new NotificationAzureStorage(Account);
            notificationAzureStorage.InitializeStorage();

            Console.WriteLine(CreateOrDeleteSessionTables.ProgramName + ": Created Notification Azure Tables.");
        }

        /// <summary>
        /// Delete the session and notification tables.
        /// </summary>
        private static void DeleteTables()
        {
            TableStorage tableStorage = TableStorage.Create(CreateOrDeleteSessionTables.Account);

            const string DeletedTableFormat = "{0}: Deleted Table: {1}";
            const string TableNotFoundFormat = "{0}: Did not find Table: {1}";

            if (tableStorage.DoesTableExist(SessionDataServiceContext.SessionTableName))
            {
                tableStorage.DeleteTable(SessionDataServiceContext.SessionTableName);
                Console.WriteLine(DeletedTableFormat, CreateOrDeleteSessionTables.ProgramName, SessionDataServiceContext.SessionTableName);
            }
            else
            {
                Console.WriteLine(TableNotFoundFormat, CreateOrDeleteSessionTables.ProgramName, SessionDataServiceContext.SessionTableName);
            }

            if (tableStorage.DoesTableExist(SessionEntryDataServiceContext.SessionEntryTableName))
            {
                tableStorage.DeleteTable(SessionEntryDataServiceContext.SessionEntryTableName);
                Console.WriteLine(DeletedTableFormat, CreateOrDeleteSessionTables.ProgramName, SessionEntryDataServiceContext.SessionEntryTableName);
            }
            else
            {
                Console.WriteLine(TableNotFoundFormat, CreateOrDeleteSessionTables.ProgramName, SessionEntryDataServiceContext.SessionEntryTableName);
            }

            if (tableStorage.DoesTableExist(SessionIndexDataServiceContext.SessionIndexTableName))
            {
                tableStorage.DeleteTable(SessionIndexDataServiceContext.SessionIndexTableName);
                Console.WriteLine(DeletedTableFormat, CreateOrDeleteSessionTables.ProgramName, SessionIndexDataServiceContext.SessionIndexTableName);
            }
            else
            {
                Console.WriteLine(TableNotFoundFormat, CreateOrDeleteSessionTables.ProgramName, SessionIndexDataServiceContext.SessionIndexTableName);
            }

            if (tableStorage.DoesTableExist(SessionCountDataServiceContext.SessionCountTableName))
            {
                tableStorage.DeleteTable(SessionCountDataServiceContext.SessionCountTableName);
                Console.WriteLine(DeletedTableFormat, CreateOrDeleteSessionTables.ProgramName, SessionCountDataServiceContext.SessionCountTableName);
            }
            else
            {
                Console.WriteLine(TableNotFoundFormat, CreateOrDeleteSessionTables.ProgramName, SessionIndexDataServiceContext.SessionIndexTableName);
            }

            if (tableStorage.DoesTableExist(NotificationDataServiceContext.NotificationTableName))
            {
                tableStorage.DeleteTable(NotificationDataServiceContext.NotificationTableName);
                Console.WriteLine(DeletedTableFormat, CreateOrDeleteSessionTables.ProgramName, NotificationDataServiceContext.NotificationTableName);
            }
            else
            {
                Console.WriteLine(TableNotFoundFormat, CreateOrDeleteSessionTables.ProgramName, NotificationDataServiceContext.NotificationTableName);
            }

            if (tableStorage.DoesTableExist(NotificationDataServiceContext.UserDataTableName))
            {
                tableStorage.DeleteTable(NotificationDataServiceContext.UserDataTableName);
                Console.WriteLine(DeletedTableFormat, CreateOrDeleteSessionTables.ProgramName, NotificationDataServiceContext.UserDataTableName);
            }
            else
            {
                Console.WriteLine(TableNotFoundFormat, CreateOrDeleteSessionTables.ProgramName, NotificationDataServiceContext.UserDataTableName);
            }
        }

        /// <summary>
        /// Displays the usage of the program.
        /// </summary>
        private static void DisplayUsage()
        {
            StringBuilder usageStrBuilder = new StringBuilder();
            usageStrBuilder.AppendFormat("{0} Usage: ", CreateOrDeleteSessionTables.ProgramName);
            Console.WriteLine(usageStrBuilder.AppendFormat("{0} create/delete", CreateOrDeleteSessionTables.ProgramName));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\CreateOrDeleteSessionTables\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-13</date>
// <summary>Contains the assembly information for the CreateOrDeleteSessionTables assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("CreateOrDeleteSessionTables")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("32360618-8189-4213-8d0b-cd50359afca2")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GameStateAzureStorage\GameStateAzureStorage.cs ===
// <copyright file="GameStateAzureStorage.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-09</date>
// <summary>Contains the class definition for GameStateAzureStorage.</summary>
namespace AsyncMultiplayer.GameStateAzureStorage
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using Common.AzureStorage;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics; 
    using SessionCommon;

    /// <summary>
    /// This class provides an Azure blob implementation for IGameStateStorage.
    /// </summary>
    public class GameStateAzureStorage : IGameStateStorage
    {
        /// <summary>
        /// Initializes a new instance of the GameStateAzureStorage class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        public GameStateAzureStorage(StorageAccountInfo account)
            : this(account, string.Empty)
        {
        }

        /// <summary>
        /// Initializes a new instance of the GameStateAzureStorage class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        /// <param name="proxyAddress">The proxy setting for the environment</param>
        public GameStateAzureStorage(StorageAccountInfo account, string proxyAddress)
        {
            this.Account = account;
            this.ProxyAddress = proxyAddress;
        }

        /// <summary>
        /// Gets or sets the storage account information.
        /// </summary>
        /// <value>The account value itself.</value>
        public StorageAccountInfo Account { get; set; }

        /// <summary>
        /// Gets or sets the proxy setting for the environment. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Provision state storage for a particular session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to provision storage.</param>
        /// <param name="gameID">The gameID of the session for which to provision storage.</param>
        public void ProvisionStorage(string sessionID, uint gameID)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);

                // Create the container if it does not exist.
                container.CreateContainer(null, ContainerAccessControl.Private);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorOnProvisioningAzureStorage,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString());
            }
        }

        /// <summary>
        /// Deprovision game storage for a particular session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to deprovision storage.</param>
        /// <param name="gameID">The gameID of the session for which to deprovision storage.</param>
        public void DeprovisionStorage(string sessionID, uint gameID)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);
                container.DeleteContainer();
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorOnDeprovisioningAzureStorage,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString());
            }
        }

        /// <summary>
        /// Get the contents of a file.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to get the data.</param>
        /// <param name="gameID">The gameID of the session for which to get the data.</param>
        /// <param name="fileName">The name of the file to be retrieved.</param>
        /// <returns>The game state file.</returns>
        public GameStateFile Load(string sessionID, uint gameID, string fileName)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            GameStateFile stateFile = new GameStateFile();
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);

                BlobContents contents = new BlobContents(new MemoryStream());
                BlobProperties properties = container.GetBlob(fileName, contents, false);
                stateFile.Info = GetGameStateFileInfo(properties);
                stateFile.DataStream = contents.AsStream;
                stateFile.DataStream.Seek(0, SeekOrigin.Begin);
            }
            catch (StorageClientException ex)
            {
                try
                {
                    stateFile.Dispose();
                }
                catch (Exception)
                {
                    // Ignore any exceptions on Dispose.
                }

                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.GameDataNotFoundInAzureStore,
                    HttpStatusCode.NotFound,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString(),
                    fileName);
            }

            return stateFile;
        }

        /// <summary>
        /// Save the contents to a backend file.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to save the data file.</param>
        /// <param name="gameID">The gameID of the session for which to save the data file.</param>
        /// <param name="fileName">The name of the file to be saved.</param>
        /// <param name="saveStream">Data Stream to be saved into the backend file.</param>
        public void Save(string sessionID, uint gameID, string fileName, Stream saveStream)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);
                container.CreateBlob(new BlobProperties(fileName), new BlobContents(saveStream), true);
            }
            catch (StorageClientException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileSavingAzureBlob,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString(),
                    fileName);
            }
        }

        /// <summary>
        /// Enumerate storage files for a particular session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to enumerate the files.</param>
        /// <param name="gameID">The gameID of the session for which to enumerate the files.</param>
        /// <returns>The information about the files.</returns>
        public GameStateFileInfo[] EnumerateFiles(string sessionID, uint gameID)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            List<GameStateFileInfo> fileInfos = new List<GameStateFileInfo>();
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);

                IEnumerable<object> blobs = container.ListBlobs(string.Empty, false);
                foreach (var blob in blobs)
                {
                    fileInfos.Add(GetGameStateFileInfo((BlobProperties)blob));
                }
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorOnEnumeratingFilesInAzureStorage,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString());
            }

            return fileInfos.ToArray();
        }

        /// <summary>
        /// Get the information about a particular file.
        /// </summary>
        /// <param name="sessionID">The sessionID corresponding to the file for which to get the file info.</param>
        /// <param name="gameID">The gameID corresponding to the file for which to get the file info.</param>
        /// <param name="fileName">The fileName corresponding to the file for which to get the file info.</param>
        /// <returns>The information about a game state file.</returns>
        public GameStateFileInfo QueryFileInfo(string sessionID, uint gameID, string fileName)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            GameStateFileInfo stateFileInfo = null;
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);
                BlobProperties properties = container.GetBlobProperties(fileName);

                stateFileInfo = GameStateAzureStorage.GetGameStateFileInfo(properties);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileQueryingAzureBlob,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString(),
                    fileName);
            }

            return stateFileInfo;
        }

        /// <summary>
        /// Delete a particular file.
        /// </summary>
        /// <param name="sessionID">The sessionID corresponding to the file to be deleted.</param>
        /// <param name="gameID">The gameID corresponding to the file to be deleted.</param>
        /// <param name="fileName">The fileName corresponding to the file to be deleted.</param>
        public void DeleteFile(string sessionID, uint gameID, string fileName)
        {
            BlobStorage blobStorage = BlobStorage.Create(this.Account);
            blobStorage.RetryPolicy = RetryPolicies.RetryN(2, TimeSpan.FromMilliseconds(100));
            blobStorage.ProxyAddress = this.ProxyAddress;

            string containerName = this.GetContainerName(sessionID, gameID);
            try
            {
                BlobContainer container = blobStorage.GetBlobContainer(containerName);
                container.DeleteBlob(fileName);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileDeletingAzureBlob,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString(),
                    fileName);
            }
        }

        /// <summary>
        /// Gets a GameStateFileInfo object based on the BlobProperties.
        /// </summary>
        /// <param name="properties">The blob properties.</param>
        /// <returns>GameStateFileInfo object based on the BlobProperties.</returns>
        private static GameStateFileInfo GetGameStateFileInfo(BlobProperties properties)
        {
            GameStateFileInfo info = new GameStateFileInfo();

            info.ContentEncoding = properties.ContentEncoding;
            info.ContentLanguage = properties.ContentLanguage;
            info.ContentLength = properties.ContentLength;
            info.ContentType = properties.ContentType;
            info.ETag = properties.ETag;
            info.LastModifiedTime = properties.LastModifiedTime;
            info.Name = properties.Name;

            return info;
        }

        /// <summary>
        /// Gets the Azure Blob container name based on sessionID and gameID.
        /// </summary>
        /// <param name="sessionID">The sessionID for the container name.</param>
        /// <param name="gameID">The gameID for the container name.</param>
        /// <returns>The Azure Blob container name based on sessionID and gameID.</returns>
        private string GetContainerName(string sessionID, uint gameID)
        {
            // Since all the sessionIDs in case of session service are GUIDs, two different combinations of sessionID and gameID will not result in the same container name.
            // Also, the combination must conform to the following rules for a valid Container Name:
            // The container name must be a valid DNS name, conforming to the following naming rules:
            // 1. Container names must start with a letter or number, and can contain only letters, numbers, and the dash (-) character.
            // 2. Every dash (-) character must be immediately preceded and followed by a letter or number.
            // 3. All letters in a container name must be lowercase.
            // 4. Container names must be from 3 through 63 characters long.
            string containerName = sessionID.ToLower() + gameID;
            return containerName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GameStateStorage.Test\GameStateStorageTests.cs ===
// <copyright file="GameStateStorageTests.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-10</date>
// <summary>Contains the class definition for GameStateStorageTests.cs class.</summary>
namespace AsyncMultiplayer.GameStateStorageTests
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using AsyncMultiplayer.SessionCommon;
    using Common.AzureStorage;
    using Common.UnitTestUtilities;
    using GameStateAzureStorage;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using LIVEN.Common.Diagnostics;
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using SessionManagementService;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Tests the IGameStateStorage implementations.
    /// </summary>
    [TestClass]
    public class GameStateStorageTests
    {
        /// <summary>
        /// Used to store the installation state for perf counters.
        /// </summary>
        private static readonly IDictionary SavedState = new Hashtable();

        /// <summary>
        /// The reference to an implementation of IGameStateStorage to be tested.
        /// </summary>
        private readonly IGameStateStorage stateStorage;

        /// <summary>
        /// The gameID for which to store state.
        /// </summary>
        private readonly uint gameID;

        /// <summary>
        /// The fileName for which to store state.
        /// </summary>
        private readonly string fileName;

        /// <summary>
        /// The instance of the tets context used by the test cases in this class.
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        /// Initializes a new instance of the GameStateStorageTests class.
        /// </summary>
        public GameStateStorageTests()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();
            ServiceConfigs.Initialize();

            StorageAccountInfo account = StorageAccountInfo.GetDefaultBlobStorageAccountFromConfiguration();
            this.stateStorage = new GameStateAzureStorage(account);

            this.gameID = 7777;
            this.fileName = "testFile";

            // Initialize event system.
            SessionServiceEvents.Initialize("GameStateStorageTests");

            // Initialize perfcounters
            StorageClientPerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(
                                                    typeof(StorageClientPerfCounters), "GameStateStorageTests");
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        /// <value>The test context.</value>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        /// <summary>
        /// Initilize the test class.
        /// </summary>
        /// <param name="context">The TestContext for this test class.</param>
        [ClassInitialize]
        public static void TestClassInitialize(TestContext context)
        {
            // Install the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Install(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Cleanup after the run.
        /// </summary>
        [ClassCleanup]
        public static void TestClassCleanup()
        {
            // Uninstall the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Uninstall(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Test ProvisionStorage.
        /// </summary>
        [TestMethod]
        public void TestProvisionStorage()
        {
            string sessionID = Guid.NewGuid().ToString();

            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            Console.WriteLine("\n Provisioned storage for Session with SessionID: " + sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test DeprovisionStorage.
        /// </summary>
        [TestMethod]
        public void TestDeprovisionStorage()
        {
            string sessionID = Guid.NewGuid().ToString();

            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            Console.WriteLine("\n Provisioned storage for Session with SessionID: " + sessionID + " and GameID: " + this.gameID);

            this.stateStorage.DeprovisionStorage(sessionID, this.gameID);
            Console.WriteLine("\n Deprovisioned storage for Session with SessionID: " + sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test Load.
        /// </summary>
        [TestMethod]
        public void TestLoad()
        {
            string sessionID = Guid.NewGuid().ToString();

            // First Save and then Load
            byte[] data = new byte[1024 * 1024];
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = 0xFF;
            }

            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            this.stateStorage.Save(sessionID, this.gameID, this.fileName, new MemoryStream(data));
            Console.WriteLine("\n Saved file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);

            GameStateFile file = this.stateStorage.Load(sessionID, this.gameID, this.fileName);

            bool areSame = false;
            int readValue;
            int bytesRead = 0;
            do
            {
                readValue = file.DataStream.ReadByte();

                if (readValue != 0xFF)
                {
                    break;
                }

                bytesRead++;
            }
            while (bytesRead <= data.Length);

            if (bytesRead == data.Length && readValue == -1)
            {
                areSame = true;
            }

            Assert.IsTrue(areSame, "File data loaded is not the same as what was saved.");
            Console.WriteLine("\n Loaded file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test Load container not found.
        /// </summary>
        [TestMethod]
        public void TestLoadContainerNotFound()
        {
            string sessionID = Guid.NewGuid().ToString();

            // Simply load with out creating the container or the blob
            Console.WriteLine("\n Trying to load file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);

            // Try to load the game data
            GameStateFile file;
            UnitTestHelper.TestException(
                delegate { file = this.stateStorage.Load(sessionID, this.gameID, this.fileName); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.GameDataNotFoundInAzureStore));

            Console.WriteLine("\n As expected, failed to load file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test Load blob not found.
        /// </summary>
        [TestMethod]
        public void TestLoadBlobNotFound()
        {
            string sessionID = Guid.NewGuid().ToString();

            // Load the blob after creating the container.
            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            Console.WriteLine("\n Trying to load file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);

            // Try to load the game data
            GameStateFile file;
            UnitTestHelper.TestException(
                delegate { file = this.stateStorage.Load(sessionID, this.gameID, this.fileName); },
                SessionServiceEvents.Events.GetEventId(SessionServiceEvents.GameDataNotFoundInAzureStore));

            Console.WriteLine("\n As expected, failed to load file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test Save.
        /// </summary>
        [TestMethod]
        public void TestSave()
        {
            string sessionID = Guid.NewGuid().ToString();
            byte[] data = new byte[1024 * 1024];

            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            this.stateStorage.Save(sessionID, this.gameID, this.fileName, new MemoryStream(data));
            Console.WriteLine("\n Saved file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test EnumerateFiles.
        /// </summary>
        [TestMethod]
        public void EnumerateFiles()
        {
            byte[] data = new byte[1024 * 1024];
            string newSessionID = Guid.NewGuid().ToString();
            this.stateStorage.ProvisionStorage(newSessionID, this.gameID);
            for (int i = 0; i < 10; i++)
            {
                this.stateStorage.Save(newSessionID, this.gameID, i.ToString(), new MemoryStream(data));
            }

            Console.WriteLine("\n Saved files for Session with SessionID: "
                + newSessionID + " and GameID: " + this.gameID);

            bool areNamesSame = true;
            int name = 0;
            GameStateFileInfo[] fileInfos = this.stateStorage.EnumerateFiles(newSessionID, this.gameID);

            // Sort fileInfos by name
            IEnumerable<GameStateFileInfo> sortedFileInfos = fileInfos.OrderBy(fileInfo => fileInfo.Name);
            foreach (var info in sortedFileInfos)
            {
                areNamesSame = info.Name.Equals(name.ToString());
                if (!areNamesSame)
                {
                    break;
                }

                name++;
            }

            Assert.IsTrue(areNamesSame, "The file name(s) returned are not what were expected.");
            Console.WriteLine("\n Sucessfully enumerated files for Session with SessionID: " +
                newSessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test QueryFileInfo.
        /// </summary>
        [TestMethod]
        public void TestQueryFileInfo()
        {
            string sessionID = Guid.NewGuid().ToString();
            string newFileName = "anotherFileName";

            // First Save and then query
            byte[] data = new byte[1024 * 1024];
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = 0xFF;
            }

            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            this.stateStorage.Save(sessionID, this.gameID, newFileName, new MemoryStream(data));
            Console.WriteLine("\n Saved file: " + newFileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);

            GameStateFileInfo fileInfo = this.stateStorage.QueryFileInfo(sessionID, this.gameID, newFileName);
            Assert.IsTrue(fileInfo.Name.Equals(newFileName), "The file name returned is not what was expected.");
            Assert.IsTrue(fileInfo.ContentLength == 1024 * 1024, "The file size returned is not what was expected.");
            Console.WriteLine("\n Sucessfully queried file: " + newFileName + " for Session with SessionID: " +
                sessionID + " and GameID: " + this.gameID);
        }

        /// <summary>
        /// Test DeleteFile.
        /// </summary>
        [TestMethod]
        public void TestDeleteFile()
        {
            string sessionID = Guid.NewGuid().ToString();
            byte[] data = new byte[1024 * 1024];

            this.stateStorage.ProvisionStorage(sessionID, this.gameID);
            this.stateStorage.Save(sessionID, this.gameID, this.fileName, new MemoryStream(data));
            Console.WriteLine("\n Saved file: " + this.fileName + " for Session with SessionID: "
                + sessionID + " and GameID: " + this.gameID);

            this.stateStorage.DeleteFile(sessionID, this.gameID, this.fileName);

            Console.WriteLine("\n Deleted file: " + this.fileName + " for Session with SessionID: " +
                sessionID + " and GameID: " + this.gameID);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GameStateStorage.Test\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-09</date>
// <summary>Contains the assembly information for the GameStateStorage.Test assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameStateStorage.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fe6d8720-5943-407a-9cd9-4633cb4cb75d")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPlugins\GarbageCollectorPluginCommon.cs ===
// <copyright file="GarbageCollectorPluginCommon.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-06</date>
// <summary>Contains the class definition for GarbageCollectorPluginCommon class.</summary>

namespace AsyncMultiplayer.GarbageCollectorPlugins
{
    using System;
    using System.Net;
    using Common.AzureStorage;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using LIVEN.Common.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class has common garbage collector plugin functionality.
    /// </summary>
    public class GarbageCollectorPluginCommon
    {
        /// <summary>
        /// Private object used for syncrhonizing access to CommonInitialization().
        /// </summary>
        private static object lockObject = new object();

        /// <summary>
        /// Whether required interfaces are registered.
        /// </summary>
        private static bool areInterfacesRegistered = false;

        /// <summary>
        /// This method implemements common initialization required by the garbage collector plugins.
        /// This needs to be synchronized to prevent the interfaces being registered twice.
        /// </summary>
        /// <param name="componentName">The name of the service component.</param>
        public static void CommonInitialization(string componentName)
        {
            // We are OK with locking here, since this is executed only once per plugin.
            lock (lockObject)
            {
                if (!areInterfacesRegistered)
                {
                    // register the configuration providers
                    Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
                    Container.Instance.AddService<IFileSystem, FileSystem>();
                    ConfigurationSelector.RegisterProvider(componentName, "LEET");

                    // We switch this to false because HttpWebRequest does not handle 100-continue header well in a multithreaded scenario.
                    // Seeing hangs/deadlocks with it being true.
                    ServicePointManager.Expect100Continue = false;

                    // Initialize event system.
                    SessionServiceEvents.Initialize(componentName);
                    SessionMaintenanceEvents.Initialize(componentName);
                    NotificationEvents.Initialize(componentName);

                    // Initialize perfcounters
                    StorageClientPerfCounters.Counters =
                        PerformanceCounters.GetPerformanceCounters(typeof(StorageClientPerfCounters), componentName);
                    GarbageCollectorPerfCounters.Counters =
                        PerformanceCounters.GetPerformanceCounters(typeof(GarbageCollectorPerfCounters), componentName);

                    areInterfacesRegistered = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPlugins\GarbageCollectorPerfCounters.cs ===
// <copyright file="GarbageCollectorPerfCounters.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-18</date>
// <summary>Contains the class definition for GarbageCollectorPerfCounters class.</summary>

namespace AsyncMultiplayer.GarbageCollectorPlugins
{
    using System;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class is used to define the performance counters for the garbage collector.
    /// </summary>
    [SuppressMessage("Microsoft.StyleCop.CSharp.MaintainabilityRules", "SA1401:FieldsMustBePrivate", Justification = "Public fields required by the performance counter framework.")]
    [SuppressMessage("Microsoft.StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented", Justification = "Fields are self documenting.")]
    [PerformanceCategory(CategoryName = "GarbageCollectorPerfCounters")]
    public sealed class GarbageCollectorPerfCounters
    {
        [PerformanceCounter(CounterName = "Sessions Processed", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The number of sessions processed successfully by session garbage collector so far.")]
        public static int SessionsProcessed;

        [PerformanceCounter(CounterName = "Sessions Processed Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of sessions processed by session garbage collector successfully per second.")]
        public static int SessionsProcessedPerSecond;

        [PerformanceCounter(CounterName = "Sessions Deleted", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The number of sessions deleted by session garbage collector so far.")]
        public static int SessionsDeleted;

        [PerformanceCounter(CounterName = "Sessions Deleted Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of sessions deleted by session garbage collector per second.")]
        public static int SessionsDeletedPerSecond;

        [PerformanceCounter(CounterName = "Sessions Processed with Errors", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The number of sessions processed with errors by session garbage collector so far.")]
        public static int SessionsProcessedWithErrors;

        [PerformanceCounter(CounterName = "Sessions Processed with Errors Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of sessions processed with errors by session garbage collector per second.")]
        public static int SessionsProcessedWithErrorsPerSecond;

        [PerformanceCounter(CounterName = "Notifications Deleted", CounterType = PerformanceCounterType.NumberOfItems64, CounterDescription = "The number of notifications deleted successfully by notification garbage collector so far.")]
        public static int NotificationsDeleted;

        [PerformanceCounter(CounterName = "Notifications Deleted Per Second", CounterType = PerformanceCounterType.RateOfCountsPerSecond32, CounterDescription = "Number of notifications deleted by notification garbage collector successfully per second.")]
        public static int NotificationsDeletedPerSecond;

        [PerformanceCounter(CounterName = "Session Garbage Collector Run Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of a session garbage collector run.", BasePropertyName = "Session Garbage Collector Run Duration Base")]
        public static int SessionGarbageCollectorRunDuration;

        [PerformanceCounter(CounterName = "Session Garbage Collector Run Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of a session garbage collector run.")]
        public static int SessionGarbageCollectorRunDurationBase;

        [PerformanceCounter(CounterName = "Notification Garbage Collector Run Duration", CounterType = PerformanceCounterType.AverageTimer32, CounterDescription = "The average duration of a notification garbage collector run.", BasePropertyName = "Notification Garbage Collector Run Duration Base")]
        public static int NotificationGarbageCollectorRunDuration;

        [PerformanceCounter(CounterName = "Notification Garbage Collector Run Duration Base", CounterType = PerformanceCounterType.AverageBase, CounterDescription = "The average duration of a notification garbage collector run.")]
        public static int NotificationGarbageCollectorRunDurationBase;

        /// <summary>
        /// Prevents a default instance of the GarbageCollectorPerfCounters class from being created.
        /// </summary>
        private GarbageCollectorPerfCounters()
        {
        }

        /// <summary>
        /// Gets the name of the performance counters.
        /// </summary>
        public static string Name
        {
            get
            {
                return "GarbageCollectorPerfCounters";
            }
        }

        /// <summary>
        /// Gets or sets the collection of perf counters for the garbage collector.
        /// </summary>
        public static PerformanceCounterCollection Counters
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPlugins\ServiceConfigs.cs ===
// <copyright file="ServiceConfigs.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-13</date>
// <summary>Contains the class definition for ServiceConfigs class.</summary>

namespace AsyncMultiplayer.GarbageCollectorPlugins
{
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    /// <summary>
    /// Supplies the config for the plugins 
    /// </summary>
    public class ServiceConfigs
    {
        /// <summary>
        /// The interface of the database.
        /// </summary>
        private const string QueueDatabaseInterface = "lest_AsyncNotification_db";

        /// <summary>
        /// Gets the number of days to wait before cleaning session data.
        /// </summary>
        public static uint DaysToWaitBeforeCleaningSessions
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return (uint)configSettings.GetIntSetting(Settings.GarbageCollectorService_DaysToWaitBeforeCleaningSessions);
            }
        }

        /// <summary>
        /// Gets the number of days to wait before cleaning notification data.
        /// </summary>
        public static uint DaysToWaitBeforeCleaningNotifications
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return (uint)configSettings.GetIntSetting(Settings.GarbageCollectorService_DaysToWaitBeforeCleaningNotificat);
            }
        }

        /// <summary>
        /// Gets the maximum concurrent number of sessions to process.
        /// </summary>
        public static int MaxConcurrentSessionsToProcess
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.GarbageCollectorService_MaxConcurrentSessionsToProcess);
            }
        }

        /// <summary>
        /// Gets a value indicating whether the garbage collector service should be run in test mode.
        /// In Test mode, the garbage collector waits for only SecondsToWaitInTestMode seconds rather than a day after the first warning before cleaning up.
        /// </summary>
        public static bool RunInTestMode
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetBoolSetting(Settings.GarbageCollectorService_RunInTestMode);
            }
        }

        /// <summary>
        /// Gets the Azure storage account.
        /// </summary>
        public static string AzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SessionFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token.
        /// </summary>
        public static string AzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.SessionFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the Azure table storage access endpoint.
        /// </summary>
        public static string AzureTableStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureTableStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure blob storage access endpoint.
        /// </summary>
        public static string AzureBlobStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureBlobStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure storage account.
        /// </summary>
        public static string NotificationAzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token.
        /// </summary>
        public static string NotificationAzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the connection string to notification request queue.
        /// </summary>
        public static string NotificationRequestQueueConnectionString
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetConnectionString(QueueDatabaseInterface);
            }
        }

        /// <summary>
        /// Gets the proxy settings in the configuration.
        /// </summary>
        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPlugins\NotificationGarbageCollectorPlugin.cs ===
// <copyright file="NotificationGarbageCollectorPlugin.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-06</date>
// <summary>Contains the class definition for NotificationGarbageCollectorPlugin class.</summary>

namespace AsyncMultiplayer.GarbageCollectorPlugins
{
    using System;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using System.Threading;
    using Common.AzureStorage;
    using Leet.Core.Diagnostics;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationService;
    using TimerBasedService.Common;

    /// <summary>
    /// This class implements the notification garbage collector plugin.
    /// </summary>
    public class NotificationGarbageCollectorPlugin : ITimerPlugin
    {
        /// <summary>
        /// Saves the notification Azure storage account information. 
        /// </summary>
        private static StorageAccountInfo notificationAzureAccount;

        /// <summary>
        /// current UserDataAzureStorage. 
        /// </summary>
        private static UserDataAzureStorage userDataStorage;

        /// <summary>
        /// Save a reference to the associated timer.
        /// </summary>
        private Timer timer;

        /// <summary>
        /// Save a reference to the associated description.
        /// </summary>
        private TimerPluginDescription description;

        /// <summary>
        /// The entry point of the plugin.
        /// </summary>
        /// <param name="state">The state passed to the work method.</param>
        public void DoWork(object state)
        {
            // first disable the timer
            this.timer.Change(Timeout.Infinite, 0);

            // NOTE: An exception thrown here can crash the whole service, which may have multiple plugins.
            // Make sure that all exceptions are caught.
            Stopwatch stopWatch = new Stopwatch();
            try
            {
               stopWatch.Start();
               Logging.TraceInformation(
                        "{0} {1}",
                       this.description.DisplayName,
                       "NotificationGarbageCollectorPlugin fired. Starting cleaning cycle.");

                this.GarbageCollectNotifications();

                Logging.TraceInformation(
                    "{0} {1}",
                   this.description.DisplayName,
                   "NotificationGarbageCollectorPlugin: Ended cleaning cycle.");
            }
            catch (Exception ex)
            {
                // Log all unexpected exceptions
                LIVEnException livEnException = new LIVEnException(
                                                        NotificationEvents.Events,
                                                        NotificationEvents.UnexpectedExceptionInNotificationGarbageCollector,
                                                        HttpStatusCode.InternalServerError,
                                                        ex,
                                                        true);

                Logging.TraceException(
                    livEnException,
                    "{0} An exception occured during the notification garbage collection run",
                    this.description.DisplayName);
            }
            finally
            {
                // re-enable the timer
                if (this.description.Frequency > 0)
                {
                    this.timer.Change(this.description.Frequency * 1000, Timeout.Infinite);
                }

                stopWatch.Stop();
                GarbageCollectorPerfCounters.Counters.SafeIncrementBy(GarbageCollectorPerfCounters.NotificationGarbageCollectorRunDuration, stopWatch.ElapsedTicks);
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.NotificationGarbageCollectorRunDurationBase);
            }
        }

        /// <summary>
        /// This method initializes the plugin.
        /// </summary>
        /// <param name="timer">The timer associated with this plugin.</param>
        /// <param name="description">The description of the timer.</param>
        /// <param name="componentName">The calling service component name.</param>
        public void Initialize(Timer timer, TimerPluginDescription description, string componentName)
        {
            GarbageCollectorPluginCommon.CommonInitialization(componentName);
            this.timer = timer;
            this.description = description;
            NotificationGarbageCollectorPlugin.notificationAzureAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                null,
                ServiceConfigs.NotificationAzureStorageAccount,
                ServiceConfigs.NotificationAzureStorageToken,
                false);

            NotificationGarbageCollectorPlugin.userDataStorage = new UserDataAzureStorage(
                ServiceConfigs.AzureTableStorageEndPoint,
                ServiceConfigs.NotificationAzureStorageAccount,
                ServiceConfigs.NotificationAzureStorageToken,
                ServiceConfigs.ProxyAddress);
        }

        /// <summary>
        /// Helper method to get a list of entities based row key.
        /// </summary>
        /// <param name="dataServiceContext">The service context object.</param>
        /// <param name="rowKey">All rows with row keys greater than or eaual to this row key will be retrieved.</param>
        /// <returns>A numerable of NotificationAzureTableEntity entities.</returns>
        private static IEnumerable<NotificationAzureTableEntity> GetEntityList(NotificationDataServiceContext dataServiceContext, string rowKey)
        {
            var queryResult = from c in dataServiceContext.AsyncNotificationTable
                              where c.RowKey.CompareTo(rowKey) >= 0
                              select c;

            TableStorageDataServiceQuery<NotificationAzureTableEntity> query =
                new TableStorageDataServiceQuery<NotificationAzureTableEntity>(queryResult as DataServiceQuery<NotificationAzureTableEntity>, dataServiceContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<NotificationAzureTableEntity> res = query.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// Gets the row key of the first notification to delete.
        /// </summary>
        /// <returns>the row key of the first notification to delete.</returns>
        private static string GetStartingRowKey()
        {
            DateTime dayToStartDeleting = DateTime.UtcNow.AddDays(-1 * ServiceConfigs.DaysToWaitBeforeCleaningNotifications);
            return string.Format(Notification.IdPrefixFormatString, (DateTime.MaxValue.Ticks - dayToStartDeleting.Ticks));
        }

        /// <summary>
        /// Garbage collect notifications.
        /// </summary>
        private void GarbageCollectNotifications()
        {
            // Get Notifications to delete
            NotificationDataServiceContext notificationDataServiceContext = new NotificationDataServiceContext(NotificationGarbageCollectorPlugin.notificationAzureAccount);
            notificationDataServiceContext.ProxyAddress = ServiceConfigs.ProxyAddress;

            string rowKey = NotificationGarbageCollectorPlugin.GetStartingRowKey();

            Logging.TraceVerbose(
                        "{0} {1} {2}",
                        this.description.DisplayName,
                        "Start collecting with rowKey:",
                        rowKey);

            IEnumerable<NotificationAzureTableEntity> notificationEntitiesToDelete = NotificationGarbageCollectorPlugin.GetEntityList(notificationDataServiceContext, rowKey);
            if (notificationEntitiesToDelete.FirstOrDefault() != null)
            {
                Logging.TraceVerbose(
                            "{0} {1} {2} {3}",
                            this.description.DisplayName,
                            "GetEntityList() with rowKey:",
                            rowKey,
                            " returned some entities to delete. Iterating...");

                foreach (NotificationAzureTableEntity entityToDelete in notificationEntitiesToDelete)
                {
                    try
                    {
                        Logging.TraceVerbose(
                                    "{0} {1} {2}",
                                    this.description.DisplayName,
                                    "Deleting notification: ",
                                    entityToDelete.Id);

                        // Delete notification data
                        notificationDataServiceContext.DeleteObject(entityToDelete);
                        notificationDataServiceContext.SaveChangesWithRetries();
                        GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.NotificationsDeleted);
                        GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.NotificationsDeletedPerSecond);

                        Logging.TraceVerbose(
                                    "{0} {1} {2} {3}",
                                    this.description.DisplayName,
                                    "Notification: ",
                                    entityToDelete.Id,
                                    " has been deleted.");

                        NotificationGarbageCollectorPlugin.userDataStorage.UpdateUserDataTimeStamp(entityToDelete.PartitionKey);
                    }
                    catch (LIVEnException)
                    {
                        // Ignore any LIVEnException(s)
                    }
                    catch (Exception ex)
                    {
                        // Trace this exception and ignore it.
                        // We don't want an exception in the processing of a notification to stop the whole garbage collection cycle.
                        Logging.TraceWarning(
                            "{0} {1} {2} {3} {4} {5} {6} {7} {8}",
                            this.description.DisplayName,
                            "An exception occured while trying to delete a notification, PartitionKey: ",
                            entityToDelete.PartitionKey,
                            " RowKey: ",
                            entityToDelete.RowKey,
                            " Exception Details: ",
                            ex.Message,
                            "\n",
                            ex.StackTrace);
                    }
                }
            }
            else
            {
                Logging.TraceVerbose(
                            "{0} {1} {2} {3}",
                            this.description.DisplayName,
                            "GetEntityList() with rowKey:",
                            rowKey,
                            " returned nothing to delete.");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GameStateAzureStorage\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-09</date>
// <summary>Contains the assembly information for the GameStateAzureStorage assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GameStateAzureStorage")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6117a7c6-b781-43be-8a57-7eb1be408c63")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPluginsTest\GarbageCollectorPluginsTest.cs ===
// <copyright file="GarbageCollectorPluginsTest.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-17</date>
// <summary>Contains the class definition for GarbageCollectorPluginsTest.</summary>

namespace AsyncMultiplayer.GarbageCollectorPluginsTest
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Threading;
    using Common.AzureStorage;
    using GarbageCollectorPlugins;
    using Leet.Core.Diagnostics;
    using TimerBasedService.Common;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class tests the garbage collector plugins.
    /// </summary>
    public class GarbageCollectorPluginsTest
    {
        /// <summary>
        /// Used to store the installation state for perf counters.
        /// </summary>
        private static readonly IDictionary SavedState = new Hashtable();

        /// <summary>
        /// The scheduled timers.
        /// </summary>
        private static readonly List<System.Threading.Timer> ServiceTimers;

        /// <summary>
        /// The description for the session garbage collector plugin.
        /// </summary>
        private static readonly TimerPluginDescription SessionPluginDesc;

        /// <summary>
        /// The description for the notification garbage collector plugin.
        /// </summary>
        private static readonly TimerPluginDescription NotificationPluginDesc;

        /// <summary>
        /// Initializes static members of the GarbageCollectorPluginsTest class.
        /// </summary>
        static GarbageCollectorPluginsTest()
        {
            GarbageCollectorPluginsTest.ServiceTimers = new List<Timer>();

            GarbageCollectorPluginsTest.SessionPluginDesc = new TimerPluginDescription(
                                                                    "SessionGarbageCollector",
                                                                    "AsyncMultiplayer.GarbageCollectorPlugins.SessionGarbageCollectorPlugin, GarbageCollectorPlugins",
                                                                    10,
                                                                    86400,
                                                                    string.Empty);

            GarbageCollectorPluginsTest.NotificationPluginDesc = new TimerPluginDescription(
                                                                        "NotificationGarbageCollector",
                                                                        "AsyncMultiplayer.GarbageCollectorPlugins.NotificationGarbageCollectorPlugin, GarbageCollectorPlugins",
                                                                        1,
                                                                        86400,
                                                                        string.Empty);
        }

        /// <summary>
        /// Gets the component name.
        /// </summary>
        protected static string ComponentName
        {
            get
            {
                return "GarbageCollectorPluginsTest";
            }
        }

        /// <summary>
        /// The main method of the test harness.
        /// </summary>
        /// <param name="args">The arguments to the executable.</param>
        public static void Main(string[] args)
        {
            Console.WriteLine("{0}: Entering Main()", GarbageCollectorPluginsTest.ComponentName);

            // Run the program by default for 5 minutes
            int runningTimeInSecs = 5 * 60;
            if (args.Length != 0)
            {
                runningTimeInSecs = int.Parse(args[0]) * 60;
            }

            // Register trace logger.
            Leet.Core.IoCCo.Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Leet.Core.IoCCo.Container.Instance.AddService<ILogging, Logging>();

            // Install the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Install(typeof(StorageClientPerfCounters).Assembly, GarbageCollectorPluginsTest.SavedState);
            PerformanceCountersInstaller garbageCollectorPerfCountersInstaller = new PerformanceCountersInstaller();
            IDictionary garbageCollectorPerfCounterInstallerSavedState = new Hashtable();
            garbageCollectorPerfCountersInstaller.Install(typeof(GarbageCollectorPerfCounters).Assembly, garbageCollectorPerfCounterInstallerSavedState);

            Dictionary<TimerPluginDescription, ITimerPlugin> garbageCollectorInfos = new Dictionary<TimerPluginDescription, ITimerPlugin>();
            garbageCollectorInfos.Add(GarbageCollectorPluginsTest.SessionPluginDesc, new SessionGarbageCollectorPlugin());
            garbageCollectorInfos.Add(GarbageCollectorPluginsTest.NotificationPluginDesc, new NotificationGarbageCollectorPlugin());

            foreach (KeyValuePair<TimerPluginDescription, ITimerPlugin> garbageCollectorInfo in garbageCollectorInfos)
            {
                ITimerPlugin timerPlugin = garbageCollectorInfo.Value;
                TimerCallback timerDelegate = new TimerCallback(timerPlugin.DoWork);

                TimerPluginDescription plugin = garbageCollectorInfo.Key;

                int period = (int)plugin.Frequency * 1000;
                Timer timer = new Timer(timerDelegate, null, plugin.Due * 1000, period);
                GarbageCollectorPluginsTest.ServiceTimers.Add(timer);

                timerPlugin.Initialize(timer, plugin, ComponentName);
            }

            Console.WriteLine(
                "{0}: Main thread sleeping for {1} seconds, allowing plugins to get some work done.", GarbageCollectorPluginsTest.ComponentName, runningTimeInSecs);

            // Sleep for running time
            Thread.Sleep(runningTimeInSecs * 1000);

            Console.WriteLine("{0}: Main thread awoke, shutting down the program.", GarbageCollectorPluginsTest.ComponentName);

            // Clean up all the timers
            foreach (Timer serviceTimer in GarbageCollectorPluginsTest.ServiceTimers)
            {
                serviceTimer.Dispose();
            }

            // Uninstall the perf counters.
            PerformanceCountersInstaller perfCountersUnInstaller = new PerformanceCountersInstaller();
            perfCountersUnInstaller.Uninstall(typeof(StorageClientPerfCounters).Assembly, GarbageCollectorPluginsTest.SavedState);
            PerformanceCountersInstaller garbageCollectorPerfCountersUnInstaller = new PerformanceCountersInstaller();
            garbageCollectorPerfCountersUnInstaller.Uninstall(typeof(GarbageCollectorPerfCounters).Assembly, garbageCollectorPerfCounterInstallerSavedState);

            Console.WriteLine("{0}: Exiting Main()", GarbageCollectorPluginsTest.ComponentName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\Common\AzureStorageClient\RestBlobStorage.cs ===
//
// <copyright file="RestBlobStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Globalization;
using System.IO;
using System.Net;
using System.Text;
using System.Xml;
using AsyncMultiplayer.Common.AzureStorage.StorageHttpConstants;

namespace AsyncMultiplayer.Common.AzureStorage
{
    using System.Diagnostics;
    using System.Reflection;

    internal class BlobStorageRest : BlobStorage
    {
        private SharedKeyCredentials credentials;
        internal BlobStorageRest(Uri baseUri,
                                 bool? usePathStyleUris,
                                 string accountName,
                                 string base64Key
                                )
            : base(baseUri, usePathStyleUris, accountName, base64Key)
        {
            byte[] key = null;
            this.Base64Key = base64Key;
            if (base64Key != null)
                key = Convert.FromBase64String(base64Key);
            this.credentials = new SharedKeyCredentials(accountName, key);
        }

        /// <summary>
        /// Get a reference to a BlobContainer object with the given name.
        /// This method does not make any calls to the storage service.
        /// </summary>
        /// <param name="containerName">The name of the container</param>
        /// <returns>A reference to a newly created BlobContainer object</returns>
        public override BlobContainer GetBlobContainer(string containerName)
        {
            return new BlobContainerRest(
                            BaseUri,
                            UsePathStyleUris,
                            AccountName,
                            containerName,
                            Base64Key,
                            DateTime.MinValue,
                            Timeout,
                            RetryPolicy, 
                            this.ProxyAddress
                            );
        }

        /// <summary>
        /// Lists the containers within the account.
        /// </summary>
        /// <returns>A list of containers</returns>
        public override IEnumerable<BlobContainer> ListBlobContainers()
        {
            string marker = "", prefix = null;
            const int maxResults = StorageHttpConstants.ListingConstants.MaxContainerListResults;
            byte[] key = null;
            if (Base64Key != null)
                key = Convert.FromBase64String(Base64Key);
            SharedKeyCredentials credentials = new SharedKeyCredentials(AccountName, key);


            do
            {
                ListContainersResult result = ListContainersImpl(prefix, marker, maxResults);
                marker = result.NextMarker;
                foreach (ContainerProperties container in result.Containers)
                {
                    yield return new BlobContainerRest(
                                    BaseUri,
                                    UsePathStyleUris,
                                    AccountName,
                                    container.Name,
                                    Base64Key,
                                    container.LastModifiedTime,
                                    Timeout,
                                    RetryPolicy,
                                    this.ProxyAddress
                                    );
                }
            } while (marker != null);

        }

        internal class ListContainersResult
        {
            internal ListContainersResult(IEnumerable<ContainerProperties> containers, string nextMarker)
            {
                this.Containers = containers;
                this.NextMarker = nextMarker;
            }

            public IEnumerable<ContainerProperties> Containers { get; private set; }

            public string NextMarker { get; private set; }

        }

        private ListContainersResult ListContainersImpl(
            string prefix,
            string marker,
            int maxResults
            )
        {
            ListContainersResult result = null;
            ResourceUriComponents uriComponents;
            Uri listContainerssUri = CreateRequestUriForListContainers(
                                        prefix,
                                        marker,
                                        null,
                                        maxResults,
                                        out uriComponents
                                        );
            HttpWebRequest request = Utilities.CreateHttpRequest(listContainerssUri, StorageHttpConstants.HttpMethod.Get, Timeout, this.ProxyAddress);
            credentials.SignRequest(request, uriComponents);

            try
            {
                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    if (response.StatusCode == HttpStatusCode.OK)
                    {
                        using (Stream stream = response.GetResponseStream())
                        {
                            result = ListContainersResultFromResponse(stream);
                        }
                    }
                    else
                    {
                        Utilities.ProcessUnexpectedStatusCode(response);
                    }
                }
            }
            catch (IOException ioe)
            {
                throw new StorageServerException(
                        StorageErrorCode.TransportError,
                        "The connection may be lost",
                         default(HttpStatusCode),
                         null,
                         ioe
                         );
            }
            catch (System.TimeoutException te)
            {
                throw new StorageServerException(
                              StorageErrorCode.ServiceTimeout,
                              "Timeout during listing containers",
                               HttpStatusCode.RequestTimeout,
                               null,
                               te
                               );
            }
            catch (WebException we)
            {
                throw Utilities.TranslateWebException(we);
            }
            return result;
        }

        private Uri CreateRequestUriForListContainers(
            string prefix, string fromMarker, string delimiter, int maxResults, out ResourceUriComponents uriComponents)
        {
            NameValueCollection queryParams = BlobStorageRest.CreateRequestUriForListing(prefix, fromMarker, delimiter, maxResults);

            return Utilities.CreateRequestUri(BaseUri, UsePathStyleUris, AccountName, null, null, Timeout, queryParams, out uriComponents);
        }

        internal static NameValueCollection CreateRequestUriForListing(string prefix, string fromMarker, string delimiter, int maxResults)
        {
            NameValueCollection queryParams = new NameValueCollection();
            queryParams.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.List);

            if (!string.IsNullOrEmpty(prefix))
                queryParams.Add(StorageHttpConstants.QueryParams.QueryParamPrefix, prefix);

            if (!string.IsNullOrEmpty(fromMarker))
                queryParams.Add(StorageHttpConstants.QueryParams.QueryParamMarker, fromMarker);

            if (!string.IsNullOrEmpty(delimiter))
                queryParams.Add(StorageHttpConstants.QueryParams.QueryParamDelimiter, delimiter);

            queryParams.Add(StorageHttpConstants.QueryParams.QueryParamMaxResults,
                maxResults.ToString(CultureInfo.InvariantCulture));

            return queryParams;
        }

        private static ListContainersResult ListContainersResultFromResponse(Stream responseBody)
        {
            List<ContainerProperties> containers = new List<ContainerProperties>();
            string nextMarker = null;

            XmlDocument doc = new XmlDocument();
            try
            {
                doc.Load(responseBody);
            }
            catch (XmlException xe)
            {
                throw new StorageServerException(StorageErrorCode.ServiceBadResponse,
                    "The result of a ListBlobContainers operation could not be parsed", default(HttpStatusCode), xe);
            }


            // Get all the containers returned as the listing results
            XmlNodeList containerNodes = doc.SelectNodes(XPathQueryHelper.ContainerQuery);

            foreach (XmlNode containerNode in containerNodes)
            {
                DateTime? lastModified = XPathQueryHelper.LoadSingleChildDateTimeValue(
                    containerNode, StorageHttpConstants.XmlElementNames.LastModified, false);

                string eTag = XPathQueryHelper.LoadSingleChildStringValue(
                    containerNode, StorageHttpConstants.XmlElementNames.Etag, false);

                string containerUri = XPathQueryHelper.LoadSingleChildStringValue(
                    containerNode, StorageHttpConstants.XmlElementNames.Url, true);

                string containerName = XPathQueryHelper.LoadSingleChildStringValue(
                    containerNode, StorageHttpConstants.XmlElementNames.Name, true);

                ContainerProperties properties = new ContainerProperties(containerName);
                if (lastModified.HasValue)
                    properties.LastModifiedTime = lastModified.Value;
                properties.ETag = eTag;

                Uri uri = null;
                Uri.TryCreate(containerUri, UriKind.Absolute, out uri);
                properties.Uri = uri;

                containers.Add(properties);
            }

            // Get the nextMarker
            XmlNode nextMarkerNode = doc.SelectSingleNode(XPathQueryHelper.NextMarkerQuery);
            if (nextMarkerNode != null && nextMarkerNode.FirstChild != null)
            {
                nextMarker = nextMarkerNode.FirstChild.Value;
            }

            return new ListContainersResult(containers, nextMarker);
        }
    }

    internal class BlobContainerRest : BlobContainer
    {

        internal BlobContainerRest(
            Uri baseUri,
            bool usePathStyleUris,
            string accountName,
            string containerName,
            string base64Key,
            DateTime lastModified,
            TimeSpan timeOut,
            RetryPolicy retryPolicy, 
            string proxyAddress
            )
            : base(baseUri, usePathStyleUris, accountName, containerName, lastModified, proxyAddress)
        {
            ResourceUriComponents uriComponents =
                new ResourceUriComponents(accountName, containerName, null);
            containerUri = HttpRequestAccessor.ConstructResourceUri(baseUri, uriComponents, usePathStyleUris);
            if (base64Key != null)
                key = Convert.FromBase64String(base64Key);
            credentials = new SharedKeyCredentials(accountName, key);
            Timeout = timeOut;
            RetryPolicy = retryPolicy;
            this.ProxyAddress = proxyAddress; 
        }

        public override Uri ContainerUri
        {
            get
            {
                return this.containerUri;
            }
        }

        public override bool CreateContainer()
        {
            return CreateContainerImpl(null, ContainerAccessControl.Private);
        }

        /// <summary>
        /// Create the container with the specified access control if it does not exist
        /// </summary>
        /// <param name="metadata">The metadata for the container. Can be null to indicate no metadata</param>
        /// <param name="accessControl">The access control (public or private) with which to create the container</param>
        /// <returns>true if the container was created. false if the container already exists</returns>
        public override bool CreateContainer(NameValueCollection metadata, ContainerAccessControl accessControl)
        {
            return CreateContainerImpl(metadata, accessControl);
        }


        public override bool DoesContainerExist()
        {
            bool result = false;
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri uri = Utilities.CreateRequestUri(BaseUri, UsePathStyleUris, AccountName, ContainerName, null, Timeout,
                            new NameValueCollection(), out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Get, Timeout, this.ProxyAddress);
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                            result = true;
                        else if (response.StatusCode == HttpStatusCode.Gone || response.StatusCode == HttpStatusCode.NotFound)
                            result = false;
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                            result = false;
                        }

                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    if (we.Response != null &&
                        (((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Gone ||
                         ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.NotFound)
                       )
                        result = false;
                    else
                        throw Utilities.TranslateWebException(we);
                }
            });
            return result;
        }

        /// <summary>
        /// Get the properties for the container if it exists.
        /// </summary>
        /// <returns>The metadata for the container if it exists, null otherwise</returns>
        public override ContainerProperties GetContainerProperties()
        {
            ContainerProperties result = null;
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri uri = Utilities.CreateRequestUri(BaseUri, UsePathStyleUris, AccountName, ContainerName, null, Timeout,
                            new NameValueCollection(), out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Get, Timeout, this.ProxyAddress);
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            result = ContainerPropertiesFromResponse(response);
                        }
                        else if (response.StatusCode == HttpStatusCode.Gone || response.StatusCode == HttpStatusCode.NotFound)
                        {
                            result = null;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                            result = null;
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    if (we.Response != null &&
                        ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Gone ||
                        (((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.NotFound)
                        )
                        result = null;
                    else
                        throw Utilities.TranslateWebException(we);
                }

            });
            return result;
        }

        /// <summary>
        /// Get the access control permissions associated with the container.
        /// </summary>
        /// <returns></returns>
        public override ContainerAccessControl GetContainerAccessControl()
        {
            ContainerAccessControl accessControl = ContainerAccessControl.Private;
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                NameValueCollection queryParams = new NameValueCollection();
                queryParams.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.Acl);

                Uri uri = Utilities.CreateRequestUri(BaseUri, UsePathStyleUris, AccountName, ContainerName, null, Timeout,
                            queryParams, out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Get, Timeout,this.ProxyAddress);
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            string acl = response.Headers[StorageHttpConstants.HeaderNames.PublicAccess];
                            bool publicAcl = false;
                            if (acl != null && bool.TryParse(acl, out publicAcl))
                            {
                                accessControl = (publicAcl ? ContainerAccessControl.Public : ContainerAccessControl.Private);
                            }
                            else
                            {
                                throw new StorageServerException(
                                            StorageErrorCode.ServiceBadResponse,
                                            "The server did not respond with expected container access control header",
                                            default(HttpStatusCode),
                                            null,
                                            null
                                            );
                            }
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }

            });
            return accessControl;
        }

        /// <summary>
        /// Get the access control permissions associated with the container.
        /// </summary>
        /// <returns></returns>
        public override void SetContainerAccessControl(ContainerAccessControl acl)
        {
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                NameValueCollection queryParams = new NameValueCollection();
                queryParams.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.Acl);

                Uri uri = Utilities.CreateRequestUri(BaseUri, UsePathStyleUris, AccountName, ContainerName, null, Timeout,
                            queryParams, out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Put, Timeout, this.ProxyAddress);
                request.Headers.Add(StorageHttpConstants.HeaderNames.PublicAccess,
                    (acl == ContainerAccessControl.Public).ToString());
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode != HttpStatusCode.OK)
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }

            });
        }

        public override bool DeleteContainer()
        {
            bool result = false;
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri uri = Utilities.CreateRequestUri(BaseUri, this.UsePathStyleUris, AccountName, ContainerName, null, Timeout, new NameValueCollection(),
                            out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Delete, Timeout, this.ProxyAddress);
                credentials.SignRequest(request, uriComponents);
                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK || response.StatusCode == HttpStatusCode.Accepted)
                            result = true;
                        else
                            Utilities.ProcessUnexpectedStatusCode(response);
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    if (we.Response != null &&
                        (((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.NotFound ||
                          ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Gone ||
                          ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Conflict))                    
                        result = false;                    
                    else                    
                        throw Utilities.TranslateWebException(we);                    
                }
            }
            );
            return result;
        }

        private bool CreateContainerImpl(NameValueCollection metadata, ContainerAccessControl accessControl)
        {
            bool result = false;
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri uri = Utilities.CreateRequestUri(BaseUri, UsePathStyleUris, AccountName, ContainerName, null, Timeout, new NameValueCollection(),
                                  out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Put, Timeout, this.ProxyAddress);
                if (metadata != null)
                {
                    Utilities.AddMetadataHeaders(request, metadata);
                }
                if (accessControl == ContainerAccessControl.Public)
                {
                    request.Headers.Add(StorageHttpConstants.HeaderNames.PublicAccess, "true");
                }
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.Created)
                            result = true;
                        else if (response.StatusCode == HttpStatusCode.Conflict)
                            result = false;
                        else
                            Utilities.ProcessUnexpectedStatusCode(response);
                        response.Close();
                    }
                }
                catch (WebException we)
                {
                    if (we.Response != null && ((HttpWebResponse)we.Response).StatusCode == HttpStatusCode.Conflict)
                        result = false;
                    else
                        throw Utilities.TranslateWebException(we);
                }
            });
            return result;
        }

        public override bool DoesBlobExist(string blobName)
        {
            //if the blob exists, the GetBlobProperties function should return for us a BlobProperties object, otherwise it returns null
            if (GetBlobProperties(blobName) == null)
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Create a new blob or overwrite an existing blob.
        /// </summary>
        /// 
        /// <param name="blobProperties">The properties of the blob</param>
        /// <param name="blobContents">The contents of the blob</param>
        /// <param name="overwrite">Should this request overwrite an existing blob ?</param>
        /// <returns>true if the blob was created. false if the blob already exists and <paramref name="overwrite"/>was set to false</returns>
        /// <remarks>The LastModifiedTime property of <paramref name="blobProperties"/> is set as a result of this call</remarks>
        public override bool CreateBlob(BlobProperties blobProperties, BlobContents blobContents, bool overwrite)
        {
            StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccesses);
            StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessesPerSecond);
            Stopwatch stopWatch = new Stopwatch();
            stopWatch.Start();

            bool result;
            try
            {
                result = PutBlobImpl(blobProperties, blobContents.AsStream, overwrite, null);
            }
            catch (Exception)
            {
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessErrors);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessErrorsPerSecond);
                throw;
            }
            finally
            {
                stopWatch.Stop();
                StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureBlobAccessDuration, stopWatch.ElapsedTicks);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessDurationBase);
            }

            return result;
        }

        /// <summary>
        /// Updates an existing blob if it has not been modified since the specified time which is typically
        /// the last modified time of the blob when you retrieved it.
        /// Use this method to implement optimistic concurrency by avoiding clobbering changes to the blob
        /// made by another writer.
        /// </summary>
        /// <param name="blobProperties">The properties of the blob. This object should be one previously
        /// obtained from a call to GetBlob or GetBlobProperties and have its LastModifiedTime property set.</param>
        /// <param name="contents">The contents of the blob. The contents of the blob should be readable</param>
        /// <returns>true if the blob was updated. false if the blob has changed since the last time</returns>
        /// <remarks>The LastModifiedTime property of <paramref name="properties"/> is set as a result of this call</remarks>
        public override bool UpdateBlobIfNotModified(BlobProperties blobProperties, BlobContents contents)
        {
            return PutBlobImpl(blobProperties, contents.AsStream, true, blobProperties.ETag);
        }

        /// <summary>
        /// Get the blob contents and properties if the blob exisits
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blobContents">Object in which the contents are returned.
        /// This object should contain a writable stream or should be a default constructed object.</param>
        /// <param name="transferAsChunks">Should the blob be gotten in pieces. This requires more round-trips, but will retry smaller piecs in case of failure.</param>
        /// <returns>The properties of the blob if the blob exists.</returns>
        public override BlobProperties GetBlob(string name, BlobContents blobContents, bool transferAsChunks)
        {
            StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccesses);
            StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessesPerSecond);
            Stopwatch stopWatch = new Stopwatch();
            stopWatch.Start();

            BlobProperties result;
            try
            {
                bool notModified = false;
                result = GetBlobImpl(name, blobContents.AsStream, null, transferAsChunks, out notModified);
            }
            catch (Exception)
            {
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessErrors);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessErrorsPerSecond);
                throw;
            }
            finally
            {
                stopWatch.Stop();
                StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureBlobAccessDuration, stopWatch.ElapsedTicks);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessDurationBase);
            }

            return result;
        }

        /// <summary>
        /// Gets the blob contents and properties if the blob has not been modified since the time specified.
        /// Use this method if you have cached the contents of a blob and want to avoid retrieving the blob
        /// if it has not changed since the last time you retrieved it.
        /// </summary>
        /// <param name="blobProperties">The properties of the blob obtained from an earlier call to GetBlob. This
        /// parameter is updated by the call if the blob has been modified</param>
        /// <param name="blobContents">Contains the stream to which the contents of the blob are written if it has been
        /// modified</param>
        /// <param name="transferAsChunks">Should the blob be gotten in pieces. This requires more round-trips, but will retry smaller piecs in case of failure.</param>
        /// <returns>true if the blob has been modified, false otherwise</returns>
        public override bool GetBlobIfModified(BlobProperties blobProperties, BlobContents blobContents, bool transferAsChunks)
        {
            bool modified = true;
            BlobProperties newProperties =
                GetBlobImpl(blobProperties.Name, blobContents.AsStream, blobProperties.ETag, transferAsChunks, out modified);
            if (modified)
                blobProperties.Assign(newProperties);
            return modified;
        }

        /// <summary>
        /// Get the properties of the blob if it exists.
        /// This method is also the simplest way to check if a blob exists.
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <returns>The properties of the blob if it exists. null otherwise.
        /// The properties for the contents of the blob are not set</returns>
        public override BlobProperties GetBlobProperties(string name)
        {
            try
            {
                bool modified = false;
                return GetBlobImpl(name, null, null, false, out modified);
            }
            catch (StorageClientException se)
            {
                if (se.ErrorCode == StorageErrorCode.ResourceNotFound || se.ErrorCode == StorageErrorCode.BlobNotFound)
                    return null;
                throw;
            }
        }

        /// <summary>
        /// Set the metadata of an existing blob.
        /// </summary>
        /// <param name="blobProperties">The blob properties object whose metadata is to be updated</param>
        public override void UpdateBlobMetadata(BlobProperties blobProperties)
        {
            SetBlobMetadataImpl(blobProperties, null);
        }

        /// <summary>
        /// Set the metadata of an existing blob if it has not been modified since it was last retrieved.
        /// </summary>
        /// <param name="blobProperties">The blob properties object whose metadata is to be updated.
        /// Typically obtained by a previous call to GetBlob or GetBlobProperties</param>
        public override bool UpdateBlobMetadataIfNotModified(BlobProperties blobProperties)
        {
            return SetBlobMetadataImpl(blobProperties, blobProperties.ETag);
        }

        /// <summary>
        /// Delete a blob with the given name
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <returns>true if the blob exists and was successfully deleted, false if the blob does not exist</returns>
        public override bool DeleteBlob(string name)
        {
            StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccesses);
            StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessesPerSecond);
            Stopwatch stopWatch = new Stopwatch();
            stopWatch.Start();

            bool result;
            try
            {
                bool unused = false;
                result = DeleteBlobImpl(name, null, out unused);
            }
            catch (Exception)
            {
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessErrors);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessErrorsPerSecond);
                throw;
            }
            finally
            {
                stopWatch.Stop();
                StorageClientPerfCounters.Counters.SafeIncrementBy(StorageClientPerfCounters.AzureBlobAccessDuration, stopWatch.ElapsedTicks);
                StorageClientPerfCounters.Counters.SafeIncrement(StorageClientPerfCounters.AzureBlobAccessDurationBase);
            }

            return result;
        }

        /// <summary>
        /// Delete a blob with the given name if the blob has not been modified since it was last obtained.
        /// Use this method for optimistic concurrency to avoid deleting a blob that has been modified since
        /// the last time you retrieved it
        /// </summary>
        /// <param name="blob">A blob object (typically previously obtained from a GetBlob call)</param>
        /// <param name="modified">This out parameter is set to true if the blob was not deleted because
        /// it was modified</param>
        /// <returns>true if the blob exists and was successfully deleted, false if the blob does not exist or was
        /// not deleted because the blob was modified.</returns>
        public override bool DeleteBlobIfNotModified(BlobProperties blob, out bool modified)
        {
            return DeleteBlobImpl(blob.Name, blob.ETag, out modified);
        }

        /// <summary>
        /// Enumerates all blobs with a given prefix.
        /// </summary>
        /// <param name="prefix"></param>
        /// <param name="combineCommonPrefixes">If true common prefixes with "/" as seperator</param>
        /// <returns>The list of blob properties and common prefixes</returns>
        public override IEnumerable<object> ListBlobs(string prefix, bool combineCommonPrefixes)
        {
            string marker = "";
            const int maxResults = StorageHttpConstants.ListingConstants.MaxBlobListResults;

            string delimiter = combineCommonPrefixes ? "/" : "";
            do
            {
                ListBlobsResult result = ListBlobsImpl(prefix, marker, delimiter, maxResults);
                marker = result.NextMarker;
                foreach (string commonPrefix in result.CommonPrefixes)
                {
                    yield return commonPrefix;
                }

                foreach (BlobProperties blob in result.Blobs)
                {
                    yield return blob;
                }
            } while (marker != null);
        }

        private HttpWebRequest CreateHttpRequestForPutBlob(Uri uri, string httpMethod, BlobProperties blobProperties,
                    long contentLength, bool overwrite, string eTag)
        {
            HttpWebRequest request = Utilities.CreateHttpRequest(uri, httpMethod, Timeout, this.ProxyAddress);
            if (blobProperties.ContentEncoding != null)
                request.Headers.Add(StorageHttpConstants.HeaderNames.ContentEncoding, blobProperties.ContentEncoding);
            if (blobProperties.ContentLanguage != null)
                request.Headers.Add(StorageHttpConstants.HeaderNames.ContentLanguage, blobProperties.ContentLanguage);
            if (blobProperties.ContentType != null)
                request.ContentType = blobProperties.ContentType;
            if (eTag != null)
                request.Headers.Add(StorageHttpConstants.HeaderNames.IfMatch, eTag);

            if (blobProperties.Metadata != null && blobProperties.Metadata.Count > 0)
            {
                Utilities.AddMetadataHeaders(request, blobProperties.Metadata);
            }
            request.ContentLength = contentLength;
            if (!overwrite)
            {
                request.Headers.Set(StorageHttpConstants.HeaderNames.IfNoneMatch, "*");
            }
            return request;
        }

        private HttpWebRequest CreateHttpRequestForGetBlob(Uri uri, string httpMethod, string ifNoneMatchETag, string ifMatchETag)
        {
            HttpWebRequest request = Utilities.CreateHttpRequest(uri, httpMethod, Timeout, this.ProxyAddress);
            if (ifNoneMatchETag != null)
            {
                request.Headers.Add(StorageHttpConstants.HeaderNames.IfNoneMatch, ifNoneMatchETag);
            }
            if (ifMatchETag != null)
            {
                request.Headers.Add(StorageHttpConstants.HeaderNames.IfMatch, ifMatchETag);
            }
            return request;
        }


        /// <summary>
        /// Uploads a blob in chunks.
        /// </summary>
        /// <param name="blobProperties"></param>
        /// <param name="stream"></param>
        /// <param name="overwrite"></param>
        /// <param name="eTag"></param>
        /// <returns></returns>
        private bool PutLargeBlobImpl(BlobProperties blobProperties, Stream stream, bool overwrite, string eTag)
        {
            bool retval = false;
            // Since we got a large block, chunk it into smaller pieces called blocks
            long blockSize = StorageHttpConstants.BlobBlockConstants.BlockSize;
            long startPosition = stream.Position;
            long length = stream.Length - startPosition;
            int numBlocks = (int)Math.Ceiling((double)length / blockSize);
            string[] blockIds = new string[numBlocks];

            //We can retry only if the stream supports seeking. An alternative is to buffer the data in memory
            //but we do not do this currently.
            RetryPolicy R = (stream.CanSeek ? this.RetryPolicy : RetryPolicies.NoRetry);

            //Upload each of the blocks, retrying any failed uploads
            for (int i = 0; i < numBlocks; ++i)
            {
                string blockId = Convert.ToBase64String(System.BitConverter.GetBytes(i));
                blockIds[i] = blockId;
                R(() =>
                {
                    // Rewind the stream to appropriate location in case this is a retry
                    if (stream.CanSeek)
                        stream.Position = startPosition + i * blockSize;
                    NameValueCollection nvc = new NameValueCollection();
                    nvc.Add(QueryParams.QueryParamComp, CompConstants.Block);
                    nvc.Add(QueryParams.QueryParamBlockId, blockId); // The block naming should be more elaborate to give more meanings on GetBlockList
                    long blockLength = Math.Min(blockSize, length - stream.Position);
                    retval = UploadData(blobProperties, stream, blockLength, overwrite, eTag, nvc);
                });
            }

            // Now commit the list
            // First create the output
            using (MemoryStream buffer = new MemoryStream())
            {
                // construct our own XML segment with correct blockId's
                XmlTextWriter writer = new XmlTextWriter(buffer, Encoding.UTF8);
                writer.WriteStartDocument();
                writer.WriteStartElement(XmlElementNames.BlockList);
                foreach (string id in blockIds)
                {
                    writer.WriteElementString(XmlElementNames.Block, id);
                }
                writer.WriteEndElement();
                writer.WriteEndDocument();
                writer.Flush();
                buffer.Position = 0; //Rewind

                NameValueCollection nvc = new NameValueCollection();
                nvc.Add(QueryParams.QueryParamComp, CompConstants.BlockList);

                retval = UploadData(blobProperties, buffer, buffer.Length, overwrite, eTag, nvc);
            }

            return retval;
        }

        private bool PutBlobImpl(BlobProperties blobProperties, Stream stream, bool overwrite, string eTag)
        {
            // If the blob is large, we should use blocks to upload it in pieces.
            // This will ensure that a broken connection will only impact a single piece
            long originalPosition = stream.Position;
            long length = stream.Length - stream.Position;
            if (length > StorageHttpConstants.BlobBlockConstants.MaximumBlobSizeBeforeTransmittingAsBlocks)
                return PutLargeBlobImpl(blobProperties, stream, overwrite, eTag);

            bool retval = false;
            RetryPolicy R = stream.CanSeek ? this.RetryPolicy : RetryPolicies.NoRetry;
            R(() =>
            {
                if (stream.CanSeek)
                    stream.Position = originalPosition;
                retval = UploadData(blobProperties, stream, length, overwrite, eTag, new NameValueCollection());
            });

            return retval;
        }

        private bool UploadData(BlobProperties blobProperties, Stream stream, long length, bool overwrite, string eTag, NameValueCollection nvc)
        {
            ResourceUriComponents uriComponents;
            Uri blobUri = Utilities.CreateRequestUri(BaseUri, this.UsePathStyleUris, AccountName, ContainerName,
                 blobProperties.Name, Timeout, nvc, out uriComponents);
            HttpWebRequest request = CreateHttpRequestForPutBlob(
                                        blobUri,
                                        StorageHttpConstants.HttpMethod.Put,
                                        blobProperties,
                                        length,
                                        overwrite,
                                        eTag
                                        );
            credentials.SignRequest(request, uriComponents);
            bool retval = false;

            try
            {
                using (Stream requestStream = request.GetRequestStream())
                {
                    Utilities.CopyStream(stream, requestStream, length);
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.Created)
                        {
                            retval = true;
                        }
                        else if (!overwrite && 
                                (response.StatusCode == HttpStatusCode.PreconditionFailed ||
                                 response.StatusCode == HttpStatusCode.NotModified))

                        {
                            retval = false;
                        }
                        else
                        {
                            retval = false;
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }

                        blobProperties.LastModifiedTime = response.LastModified.ToUniversalTime();
                        blobProperties.ETag = response.Headers[StorageHttpConstants.HeaderNames.ETag];
                        response.Close();
                    }
                    requestStream.Close();
                }
            }
            catch (IOException ioe)
            {
                throw new StorageServerException(
                            StorageErrorCode.TransportError,
                            "The connection may be lost",
                            default(HttpStatusCode),
                            null,
                            ioe
                            );
            }
            catch (System.TimeoutException te)
            {
                throw new StorageServerException(
                            StorageErrorCode.ServiceTimeout,
                            "Timeout during blob upload",
                            HttpStatusCode.RequestTimeout,
                            null,
                            te
                            );
            }
            catch (WebException we)
            {
                if (we.Response != null)
                {
                    HttpWebResponse response = (HttpWebResponse)we.Response;


                    if ((response.StatusCode == HttpStatusCode.PreconditionFailed ||
                         response.StatusCode == HttpStatusCode.NotModified) &&
                        (!overwrite || eTag != null))

                    {
                        retval = false;
                        return retval;
                    }
                }
                throw Utilities.TranslateWebException(we);
            }
            return retval;
        }

        private BlobProperties GetBlobImpl(string blobName, Stream stream, string oldETag, bool chunked, out bool modified)
        {
            //We introduce this local variable since lambda expressions cannot contain use an out parameter
            BlobProperties blobProperties = null;
            bool localModified = true;

            //If we are interested only in the blob properties (stream == null) or we are performing
            // a chunked download we first obtain just the blob properties
            if (stream == null || chunked)
            {
                RetryPolicy(() =>
                {
                    blobProperties = DownloadData(
                                        blobName,
                                        null,
                                        oldETag,
                                        null,
                                        0,
                                        0,
                                        new NameValueCollection(),
                                        ref localModified
                                        );
                });
                modified = localModified;
                if (stream == null)
                {
                    return blobProperties;
                }
            }


            RetryPolicy R = stream.CanSeek ? this.RetryPolicy : RetryPolicies.NoRetry;
            long originalPosition = stream.CanSeek ? stream.Position : 0;
            if (chunked && blobProperties != null && blobProperties.ContentLength > 0)
            {
                //Chunked download. Obtain ranges of the blobs in 'BlockSize' chunks
                //Ensure that the If-Match <Etag>header is used on each request so
                //that we are assured that all data belongs to the single blob we
                //started downloading.
                long location = 0;
                while (location < blobProperties.ContentLength)
                {
                    long nBytes = Math.Min(blobProperties.ContentLength - location, StorageHttpConstants.BlobBlockConstants.BlockSize);
                    R(() =>
                    {
                        // Set the position to rewind in case of a retry
                        if (stream.CanSeek)
                            stream.Position = originalPosition + location;
                        DownloadData(
                                blobName,
                                stream,
                                oldETag,
                                blobProperties.ETag,
                                location,
                                nBytes,
                                new NameValueCollection(),
                                ref localModified
                                );
                    });
                    location += nBytes;
                }
            }
            else
            {
                //Non-chunked download. Obtain the entire blob in a single request.
                R(() =>
                {
                    // Set the position to rewind in case of a retry
                    if (stream.CanSeek)
                        stream.Position = originalPosition;

                    blobProperties = DownloadData(
                                        blobName,
                                        stream,
                                        oldETag,
                                        null,
                                        0,
                                        0,
                                        new NameValueCollection(),
                                        ref localModified
                                        );
                });
            }
            modified = localModified;
            return blobProperties;
        }

        private bool SetBlobMetadataImpl(BlobProperties blobProperties, string eTag)
        {
            bool retval = false;
            RetryPolicy(() =>
            {
                NameValueCollection queryParams = new NameValueCollection();
                queryParams.Add(StorageHttpConstants.QueryParams.QueryParamComp, StorageHttpConstants.CompConstants.Metadata);

                ResourceUriComponents uriComponents;
                Uri uri = Utilities.CreateRequestUri(
                    BaseUri,
                    this.UsePathStyleUris,
                    AccountName,
                    ContainerName,
                    blobProperties.Name,
                    Timeout,
                    queryParams,
                    out uriComponents
                    );
                HttpWebRequest request = Utilities.CreateHttpRequest(uri, StorageHttpConstants.HttpMethod.Put, Timeout, this.ProxyAddress);
                if (blobProperties.Metadata != null)
                {
                    Utilities.AddMetadataHeaders(request, blobProperties.Metadata);
                }
                if (eTag != null)
                {
                    request.Headers.Add(StorageHttpConstants.HeaderNames.IfMatch, eTag);
                }
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            retval = true;
                        }
                        else if ((response.StatusCode == HttpStatusCode.PreconditionFailed ||
                                  response.StatusCode == HttpStatusCode.NotModified) && 
                                 eTag != null)
                        {
                            retval = false;
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                            retval = false;
                        }
                        blobProperties.LastModifiedTime = response.LastModified.ToUniversalTime();
                        blobProperties.ETag = response.Headers[StorageHttpConstants.HeaderNames.ETag];
                        response.Close();
                    }
                }
                catch (IOException ioe)
                {
                    throw new StorageServerException(StorageErrorCode.TransportError, "The connection may be lost",
                                default(HttpStatusCode), ioe);
                }
                catch (System.TimeoutException te)
                {
                    throw new StorageServerException(StorageErrorCode.ServiceTimeout, "Timeout during blob metadata upload",
                                    HttpStatusCode.RequestTimeout, te);
                }
                catch (WebException we)
                {
                    if (we.Response != null)
                    {
                        HttpWebResponse response = (HttpWebResponse)we.Response;
                        if (eTag != null &&
                            (response.StatusCode == HttpStatusCode.PreconditionFailed ||
                             response.StatusCode == HttpStatusCode.NotModified))
                        {
                            retval = false;
                            return;
                        }
                    }
                    throw Utilities.TranslateWebException(we);
                }
            });
            return retval;
        }

        private List<int> GetBlockList(string blobName, string eTag)
        {
            List<int> blocks;
            using (MemoryStream blockListStream = new MemoryStream())
            {
                bool temp = true;
                NameValueCollection nvc = new NameValueCollection();
                nvc.Add(QueryParams.QueryParamComp, CompConstants.BlockList);

                DownloadData(blobName, blockListStream, eTag, null, 0, 0, nvc, ref temp);
                XmlDocument doc = new XmlDocument();
                blockListStream.Position = 0;
                doc.Load(blockListStream);

                blocks = new List<int>();
                foreach (XmlNode block in doc.SelectNodes(XPathQueryHelper.BlockQuery))
                {
                    blocks.Add((int)XPathQueryHelper.LoadSingleChildLongValue(block, XmlElementNames.Size, false));
                }
            }
            return blocks;
        }

        /// <summary>
        /// Helper method used for getting blobs, ranges of blobs and blob properties.
        /// </summary>
        /// <param name="blobName">Name of the blob</param>
        /// <param name="stream">The output stream to write blob data to. Can be null if only retrieving blob properties</param>
        /// <param name="eTagIfNoneMatch">The If-None-Match header. Used to avoid downloading blob data if the blob has not changed</param>
        /// <param name="eTagIfMatch">The If-Match header. Used to ensure that all chunks of the blob are of the same blob</param>
        /// <param name="offset">The offset of the blob data to begin downloading from. Set to 0 to download all data.</param>
        /// <param name="length">The length of the blob data to download. Set to 0 to download all data</param>
        /// <param name="nvc">Query paramters to add to the request.</param>
        /// <param name="localModified">Whether the blob had been modfied with respect to the <paramref name="eTagIfNoneMatch"/></param>
        /// <returns></returns>
        private BlobProperties DownloadData(
            string blobName,
            Stream stream,
            string eTagIfNoneMatch,
            string eTagIfMatch,
            long offset,
            long length,
            NameValueCollection nvc,
            ref bool localModified
            )
        {
            ResourceUriComponents uriComponents;
            Uri blobUri = Utilities.CreateRequestUri(BaseUri, this.UsePathStyleUris, AccountName, ContainerName, blobName, Timeout, nvc, out uriComponents);
            string httpMethod = (stream == null ? StorageHttpConstants.HttpMethod.Head : StorageHttpConstants.HttpMethod.Get);
            HttpWebRequest request = CreateHttpRequestForGetBlob(blobUri, httpMethod, eTagIfNoneMatch, eTagIfMatch);

            if (offset != 0 || length != 0)
            {
                //Use the blob storage custom header for range since the standard HttpWebRequest.AddRange 
                //accepts only 32 bit integers and so does not work for large blobs
                string rangeHeaderValue = string.Format(
                                            CultureInfo.InvariantCulture,
                                            HeaderValues.RangeHeaderFormat,
                                            offset,
                                            offset + length - 1);
                request.Headers.Add(HeaderNames.StorageRange, rangeHeaderValue);
            }
            credentials.SignRequest(request, uriComponents);

            BlobProperties blobProperties;

            try
            {
                using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                {
                    if (response.StatusCode == HttpStatusCode.OK
                        || response.StatusCode == HttpStatusCode.PartialContent)
                    {
                        blobProperties = BlobPropertiesFromResponse(blobName, blobUri, response);
                        if (stream != null)
                        {
                            using (Stream responseStream = response.GetResponseStream())
                            {
                                long bytesCopied = Utilities.CopyStream(responseStream, stream);
                                if (blobProperties.ContentLength > 0 && bytesCopied < blobProperties.ContentLength)
                                    throw new StorageServerException(
                                        StorageErrorCode.ServiceTimeout,
                                        "Unable to read complete data from server",
                                        HttpStatusCode.RequestTimeout,
                                        null
                                        );
                            }
                        }
                    }
                    else
                    {
                        Utilities.ProcessUnexpectedStatusCode(response);
                        return null;
                    }
                }
                return blobProperties;
            }
            catch (IOException ioe)
            {
                throw new StorageServerException(StorageErrorCode.TransportError, "The connection may be lost",
                            default(HttpStatusCode), ioe);
            }
            catch (System.TimeoutException te)
            {
                throw new StorageServerException(StorageErrorCode.ServiceTimeout, "Timeout during blob download",
                                HttpStatusCode.RequestTimeout, te);
            }
            catch (WebException we)
            {
                if (we.Response != null)
                {
                    HttpWebResponse response = (HttpWebResponse)we.Response;
                    if (eTagIfNoneMatch != null &&
                       (response.StatusCode == HttpStatusCode.PreconditionFailed ||
                         response.StatusCode == HttpStatusCode.NotModified))
                    {
                        localModified = false;
                        blobProperties = null;
                        return blobProperties;
                    }
                }
                throw Utilities.TranslateWebException(we);
            }
        }

        private static NameValueCollection MetadataFromHeaders(WebHeaderCollection headers)
        {
            int prefixLength = StorageHttpConstants.HeaderNames.PrefixForMetadata.Length;
            string[] headerNames = headers.AllKeys;
            NameValueCollection metadataEntries = new NameValueCollection();
            foreach (string headerName in headerNames)
            {
                if (headerName.StartsWith(StorageHttpConstants.HeaderNames.PrefixForMetadata,
                        StringComparison.OrdinalIgnoreCase))
                {
                    // strip out the metadata prefix
                    metadataEntries.Add(headerName.Substring(prefixLength), headers[headerName]);
                }
            }
            return metadataEntries;
        }

        private static BlobProperties BlobPropertiesFromResponse(
                            string blobName, Uri blobUri, HttpWebResponse response
                            )
        {
            BlobProperties blobProperties = new BlobProperties(blobName);
            blobProperties.Uri = blobUri;
            blobProperties.ContentEncoding = response.Headers[StorageHttpConstants.HeaderNames.ContentEncoding];
            blobProperties.LastModifiedTime = response.LastModified.ToUniversalTime();
            blobProperties.ETag = response.Headers[StorageHttpConstants.HeaderNames.ETag];
            blobProperties.ContentLanguage = response.Headers[StorageHttpConstants.HeaderNames.ContentLanguage];
            blobProperties.ContentLength = response.ContentLength;
            blobProperties.ContentType = response.ContentType;

            NameValueCollection metadataEntries = MetadataFromHeaders(response.Headers);
            if (metadataEntries.Count > 0)
                blobProperties.Metadata = metadataEntries;

            return blobProperties;
        }

        private ContainerProperties ContainerPropertiesFromResponse(HttpWebResponse response)
        {
            ContainerProperties prop = new ContainerProperties(ContainerName);
            prop.LastModifiedTime = response.LastModified.ToUniversalTime();
            prop.ETag = response.Headers[StorageHttpConstants.HeaderNames.ETag];
            prop.Uri = containerUri;
            prop.Metadata = MetadataFromHeaders(response.Headers);
            return prop;
        }

        bool DeleteBlobImpl(string name, string eTag, out bool modified)
        {
            bool retval = false;
            bool localModified = false;
            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri blobUri = Utilities.CreateRequestUri(BaseUri, this.UsePathStyleUris, AccountName, ContainerName, name, Timeout, new NameValueCollection(),
                                           out uriComponents);
                HttpWebRequest request = Utilities.CreateHttpRequest(blobUri, StorageHttpConstants.HttpMethod.Delete, Timeout, this.ProxyAddress);

                if (eTag != null)
                    request.Headers.Add(StorageHttpConstants.HeaderNames.IfMatch, eTag);
                credentials.SignRequest(request, uriComponents);

                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK ||
                            response.StatusCode == HttpStatusCode.Accepted)
                        {
                            retval = true;
                        }
                        else
                            Utilities.ProcessUnexpectedStatusCode(response);
                        response.Close();
                    }
                }
                catch (IOException ioe)
                {
                    throw new StorageServerException(StorageErrorCode.TransportError, "The connection may be lost",
                                default(HttpStatusCode), ioe);
                }
                catch (System.TimeoutException te)
                {
                    throw new StorageServerException(StorageErrorCode.ServiceTimeout, "Timeout during blob delete",
                                    HttpStatusCode.RequestTimeout, te);
                }
                catch (WebException we)
                {
                    if (we.Response != null)
                    {
                        HttpStatusCode status = ((HttpWebResponse)we.Response).StatusCode;
                        if (status == HttpStatusCode.NotFound ||
                            status == HttpStatusCode.Gone)
                        {
                            localModified = true;
                            retval = false;
                        }
                        else if (status == HttpStatusCode.PreconditionFailed ||
                                 status == HttpStatusCode.NotModified)
                        {
                            retval = false;
                            localModified = true;
                        }
                        else
                        {
                            throw Utilities.TranslateWebException(we);
                        }
                    }
                    else
                    {
                        throw Utilities.TranslateWebException(we);
                    }
                }
            });
            modified = localModified;
            return retval;
        }

        internal class ListBlobsResult
        {
            internal ListBlobsResult(IEnumerable<BlobProperties> blobs, IEnumerable<string> commonPrefixes, string nextMarker)
            {
                Blobs = blobs;
                CommonPrefixes = commonPrefixes;
                NextMarker = nextMarker;
            }

            internal IEnumerable<BlobProperties> Blobs
            {
                get;
                private set;
            }

            internal IEnumerable<string> CommonPrefixes
            {
                get;
                private set;
            }

            internal string NextMarker
            {
                get;
                private set;
            }
        }

        private ListBlobsResult ListBlobsImpl(string prefix, string fromMarker, string delimiter, int maxCount)
        {
            ListBlobsResult result = null;

            RetryPolicy(() =>
            {
                ResourceUriComponents uriComponents;
                Uri listBlobsUri = CreateRequestUriForListBlobs(prefix, fromMarker, delimiter, maxCount, out uriComponents);

                HttpWebRequest request = Utilities.CreateHttpRequest(listBlobsUri, StorageHttpConstants.HttpMethod.Get, Timeout, this.ProxyAddress);
                credentials.SignRequest(request, uriComponents);


                try
                {
                    using (HttpWebResponse response = (HttpWebResponse)request.GetResponse())
                    {
                        if (response.StatusCode == HttpStatusCode.OK)
                        {
                            using (Stream stream = response.GetResponseStream())
                            {
                                result = ListBlobsResultFromResponse(stream);
                            }
                        }
                        else
                        {
                            Utilities.ProcessUnexpectedStatusCode(response);
                        }
                    }
                }
                catch (IOException ioe)
                {
                    throw new StorageServerException(StorageErrorCode.TransportError, "The connection may be lost",
                                default(HttpStatusCode), ioe);
                }
                catch (System.TimeoutException te)
                {
                    throw new StorageServerException(StorageErrorCode.ServiceTimeout, "Timeout during listing blobs",
                                    HttpStatusCode.RequestTimeout, te);
                }
                catch (WebException we)
                {
                    throw Utilities.TranslateWebException(we);
                }
            });
            return result;
        }

        private Uri CreateRequestUriForListBlobs(
            string prefix, string fromMarker, string delimiter, int maxResults, out ResourceUriComponents uriComponents)
        {
            NameValueCollection queryParams = BlobStorageRest.CreateRequestUriForListing(prefix, fromMarker, delimiter, maxResults);
            return Utilities.CreateRequestUri(BaseUri, this.UsePathStyleUris, AccountName, ContainerName, null, Timeout, queryParams, out uriComponents);
        }

        private static ListBlobsResult ListBlobsResultFromResponse(Stream responseBody)
        {
            List<BlobProperties> blobs = new List<BlobProperties>();
            List<string> commonPrefixes = new List<string>();
            string nextMarker = null;

            XmlDocument doc = new XmlDocument();
            try
            {
                doc.Load(responseBody);
            }
            catch (XmlException xe)
            {
                throw new StorageServerException(StorageErrorCode.ServiceBadResponse,
                    "The result of a ListBlobs operation could not be parsed", default(HttpStatusCode), xe);
            }

            // Get the commonPrefixes
            XmlNodeList prefixNodes = doc.SelectNodes(XPathQueryHelper.CommonPrefixQuery);

            foreach (XmlNode prefixNode in prefixNodes)
            {
                string blobPrefix = XPathQueryHelper.LoadSingleChildStringValue(
                    prefixNode, StorageHttpConstants.XmlElementNames.BlobPrefixName, false);
                commonPrefixes.Add(blobPrefix);
            }

            // Get all the blobs returned as the listing results
            XmlNodeList blobNodes = doc.SelectNodes(XPathQueryHelper.BlobQuery);

            foreach (XmlNode blobNode in blobNodes)
            {
                DateTime? lastModified = XPathQueryHelper.LoadSingleChildDateTimeValue(
                    blobNode, StorageHttpConstants.XmlElementNames.LastModified, false);

                string eTag = XPathQueryHelper.LoadSingleChildStringValue(
                    blobNode, StorageHttpConstants.XmlElementNames.Etag, false);

                string contentType = XPathQueryHelper.LoadSingleChildStringValue(
                    blobNode, StorageHttpConstants.XmlElementNames.ContentType, false);

                string contentEncoding = XPathQueryHelper.LoadSingleChildStringValue(
                    blobNode, StorageHttpConstants.XmlElementNames.ContentEncoding, false);

                string contentLanguage = XPathQueryHelper.LoadSingleChildStringValue(
                    blobNode, StorageHttpConstants.XmlElementNames.ContentLanguage, false);

                long? blobSize = XPathQueryHelper.LoadSingleChildLongValue(
                    blobNode, StorageHttpConstants.XmlElementNames.Size, false);

                string blobUrl = XPathQueryHelper.LoadSingleChildStringValue(
                    blobNode, StorageHttpConstants.XmlElementNames.Url, true);

                string blobName = XPathQueryHelper.LoadSingleChildStringValue(
                    blobNode, StorageHttpConstants.XmlElementNames.BlobName, true);

                BlobProperties properties = new BlobProperties(blobName);
                properties.Uri = new Uri(blobUrl);
                if (lastModified.HasValue)
                    properties.LastModifiedTime = lastModified.Value;
                properties.ContentEncoding = contentEncoding;
                properties.ContentLanguage = contentLanguage;
                properties.ETag = eTag;
                properties.ContentLength = (blobSize == null ? 0 : blobSize.Value);
                properties.ContentType = contentType;

                blobs.Add(properties);
            }

            // Get the nextMarker
            XmlNode nextMarkerNode = doc.SelectSingleNode(XPathQueryHelper.NextMarkerQuery);
            if (nextMarkerNode != null && nextMarkerNode.FirstChild != null)
            {
                nextMarker = nextMarkerNode.FirstChild.Value;
            }

            return new ListBlobsResult(blobs, commonPrefixes, nextMarker);
        }

        private Uri containerUri;
        private byte[] key;
        private SharedKeyCredentials credentials;
    }

    /// <summary>
    /// Helper class for loading values from an XML segment
    /// </summary>
    internal static class XPathQueryHelper
    {
        // In general queries are like "//{0}/{1}/{2}" - using Join as it's more efficient than Format

        internal static readonly string NextMarkerQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
            new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.EnumerationResults,
                StorageHttpConstants.XmlElementNames.NextMarker
            });

        internal static readonly string ContainerQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
            new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.EnumerationResults,
                StorageHttpConstants.XmlElementNames.Containers,
                StorageHttpConstants.XmlElementNames.Container
            });

        internal static readonly string BlobQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
            new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.EnumerationResults,
                StorageHttpConstants.XmlElementNames.Blobs,
                StorageHttpConstants.XmlElementNames.Blob
            });

        internal static readonly string BlockQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
            new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.BlockList,
                StorageHttpConstants.XmlElementNames.Block
            });

        internal static readonly string QueueListQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
            new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.EnumerationResults,
                StorageHttpConstants.XmlElementNames.Queues,
                StorageHttpConstants.XmlElementNames.Queue
            });

        internal static readonly string MessagesListQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
                    new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.QueueMessagesList,
                StorageHttpConstants.XmlElementNames.QueueMessage,
            });

        internal static readonly string CommonPrefixQuery = string.Join(StorageHttpConstants.ConstChars.Slash,
            new string[] 
            {
                "", "", 
                StorageHttpConstants.XmlElementNames.EnumerationResults,
                StorageHttpConstants.XmlElementNames.Blobs,
                StorageHttpConstants.XmlElementNames.BlobPrefix
            });

        internal static DateTime? LoadSingleChildDateTimeValue(XmlNode node, string childName, bool throwIfNotFound)
        {
            XmlNode childNode = node.SelectSingleNode(childName);

            if (childNode != null && childNode.FirstChild != null)
            {
                DateTime? dateTime;
                if (!Utilities.TryGetDateTimeFromHttpString(childNode.FirstChild.Value, out dateTime))
                {
                    throw new StorageServerException(StorageErrorCode.ServiceBadResponse,
                        "Date time value returned from server " + childNode.FirstChild.Value + " can't be parsed.",
                        default(HttpStatusCode),
                        null
                        );
                }
                return dateTime;
            }
            else if (!throwIfNotFound)
            {
                return null;
            }
            else
            {
                return null;
            }
        }


        internal static string LoadSingleChildStringValue(XmlNode node, string childName, bool throwIfNotFound)
        {
            XmlNode childNode = node.SelectSingleNode(childName);

            if (childNode != null && childNode.FirstChild != null)
            {
                return childNode.FirstChild.Value;
            }
            else if (!throwIfNotFound)
            {
                return null;
            }
            else
            {
                return null;   // unnecessary since Fail will throw, but keeps the compiler happy
            }
        }

        internal static long? LoadSingleChildLongValue(XmlNode node, string childName, bool throwIfNotFound)
        {
            XmlNode childNode = node.SelectSingleNode(childName);

            if (childNode != null && childNode.FirstChild != null)
            {
                return long.Parse(childNode.FirstChild.Value, CultureInfo.InvariantCulture);
            }
            else if (!throwIfNotFound)
            {
                return null;
            }
            else
            {
                return null;   // unnecessary since Fail will throw, but keeps the compiler happy
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPlugins\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-06</date>
// <summary>Contains the assembly information for the GarbageCollectorPlugins assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GarbageCollectorPlugins")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b274b35e-4ae1-4cbf-9058-26fc40a96659")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\Database\AsyncNotification\AccessLayer\QueueAccess.cs ===
// <copyright file="QueueAccess.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation. All rights reserved.
// </copyright>
// 
// Author = Feng Gao fgao
// 04/11/2008 Created
// <summary>
//   The utility class for accessing the service broker queues. 
//
// </summary>

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Data;
    using System.Data.SqlClient;
    using System.Net;
    using Leet.Core;
    using Leet.Core.Diagnostics;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics; 
    using Wgx.Services.Monitoring;

    /// <summary>
    /// The actract access layer of queues to receive, send, response dialogs.
    /// </summary>
    public class QueueAccess
    {
        /// <summary>
        /// The name of this componenent. Used for trace log. 
        /// </summary>
        private const string ComponentName = "ServiceBrokerQueueAccess"; 

        #region connection related
        /// <summary>
        /// The connection of this class. It is not closed until everything is done or something wrong happens. 
        /// </summary>
        private SqlConnection connection;

        /// <summary>
        /// The connection string. Used for future if we decide to reconnect. 
        /// </summary>
        private string connString;

        /// <summary>
        /// The transaction object. 
        /// </summary>
        private SqlTransaction transaction;

        /// <summary>
        /// The persistent SqlCommand object. 
        /// </summary>
        private SqlCommand sqlcommand;

        #endregion

        #region store procedure related
        /// <summary>
        /// The name of the store procedure for Receive a message. 
        /// </summary>
        private string nameForReceive; 

        /// <summary>
        /// The name of the store procedure for send a message on dialog. 
        /// </summary>
        private string nameForSendResponse; 

        /// <summary>
        /// The name of the store procedure for end a dialog. 
        /// </summary>
        private string nameForEndConversation; 

        /// <summary>
        /// The name of the store procedure for start a dialog. 
        /// </summary>
        private string nameForStartDialog;

        /// <summary>
        /// The name of the store procedure for starting a dialog on a particular conversation group handle. 
        /// </summary>
        private string nameForStartDialogWithHandle;
        #endregion

        /// <summary>
        /// The name of the queue to receive a message. This is used for generic RecieveMessage store procedure. 
        /// Please note there isn't a name called nameForQueueToSend. Send doesn't need a queue name. Instead it 
        /// requires a conversationhandle. This handle has the information of (from, to) information. 
        /// </summary>
        private string nameForQueueToReceive;

        #region Message Related fields

        /// <summary>
        /// The converation handle of the received request. This is used to keep state. 
        /// </summary>
        private Guid conversationHandle;

        /// <summary>
        /// The conversation group handle of the received message. It is not used. 
        /// </summary>
        private Guid conversationGroupId; 

        /// <summary>
        /// The received message body. 
        /// </summary>
        private string messageBody; 

        /// <summary>
        /// The received message Type name. 
        /// </summary>
        private string messageTypeName;

        #endregion 

        /// <summary>
        /// Initializes a new instance of the QueueAccess class. 
        /// </summary>
        public QueueAccess()
        {
            this.connString = string.Empty;    
        }

        /// <summary>
        /// Initializes a new instance of the QueueAccess class.
        /// </summary>
        /// <param name="connectionString">The event notification message. It is used to compose the connection string. </param>
        public QueueAccess(string connectionString)
        {
            this.connString = connectionString;
            this.Init(); 
        }

        /// <summary>
        /// Gets or sets the name for store procedure to receive a message. 
        /// </summary>
        public string StoreProcNameForReceive
        {
            get { return this.nameForReceive; }
            set { this.nameForReceive = value; }
        }

        /// <summary>
        /// Gets or sets the name for store procedure to send a message on a dialog. 
        /// </summary>
        public string StoreProcNameForSendResponse
        {
            get { return this.nameForSendResponse; }
            set { this.nameForSendResponse = value; }
        }

        /// <summary>
        /// Gets or sets the name for store proceure to end a dialog. 
        /// </summary>
        public string StoreProcNameForEndConversation
        {
            get { return this.nameForEndConversation; }
            set { this.nameForEndConversation = value; }
        }

        /// <summary>
        /// Gets or sets the name for store procedure to start a new conversation. 
        /// </summary>
        public string StoreProcNameForStartDialog
        {
            get { return this.nameForStartDialog; }
            set { this.nameForStartDialog = value; }
        }

        /// <summary>
        /// Gets or sets the name for store procedure to start a new conversation with a given conversation group id. 
        /// </summary>
        public string StoreProcNameForStartDialogWithHandle
        {
            get { return this.nameForStartDialogWithHandle; }
            set { this.nameForStartDialogWithHandle = value; }
        }

        /// <summary>
        /// Gets or sets the name of the queue to receive a message. It is used for generic store procedures which also takes
        /// a queue name to receive a message. 
        /// </summary>
        public string QueueToReceive
        {
            get { return this.nameForQueueToReceive; }
            set { this.nameForQueueToReceive = value; }
        }

        /// <summary>
        /// Gets the message body received from the queue. 
        /// </summary>
        public string ReceivedMessage
        {
            get { return this.messageBody; }
        }

        /// <summary>
        /// Gets the received Message type name. 
        /// </summary>
        public string ReceivedMessageTypeName
        {
            get { return this.messageTypeName; }
        }

        /// <summary>
        /// Gets the conversation handle of the received message. 
        /// </summary>
        public Guid ReceivedMessageHandle
        {
            get { return this.conversationHandle; }
        }

        /// <summary>
        /// Gets the conversation group Id of the received message.
        /// </summary>
        public Guid ReceivedConversationGroupId
        {
            get { return this.conversationGroupId; }
        }

        /// <summary>
        /// Gets or sets the connection string. 
        /// </summary>
        public string ConnectionString
        {
            get { return this.connString; }
            set { this.connString = value; }
        }

        /// <summary>
        /// Gets the sqlcommand object. 
        /// </summary>
        public SqlCommand SqlCommand
        {
            get { return this.sqlcommand; }
        }

        /// <summary>
        /// Init the queue object. This is seperated from the constructor because the connection string must be set first. 
        /// </summary>
        public void Init()
        {
            // open the connection and set all variables. 
            this.connection = new SqlConnection(this.connString);
            this.sqlcommand = new SqlCommand();
            this.sqlcommand.Connection = this.connection;
            this.transaction = null;
            this.connection.Open(); 
        }

        /// <summary>
        /// Close the connection and dispose it. If there are pending transactions, this will automatically rollback. 
        /// </summary>
        public void Close()
        {
            if (this.connection != null && this.connection.State != ConnectionState.Closed)
            {
                this.connection.Close();
            }
            else
            {
                Logging.TraceError("{0} Error: the sql connection is either closed or lost. ", ComponentName);
            }
        }

        /// <summary>
        /// Begin a transaction. 
        /// </summary>
        public void BeginTransaction()
        {
            this.transaction = this.connection.BeginTransaction();
        }

        /// <summary>
        /// Rollback the transaction.
        /// </summary>
        public void RollbackTransaction()
        {
            if (this.transaction == null)
            {
                Logging.TraceError("{0}: Error: the transaction is either rolled back or committed",
                    ComponentName);

                return;
            }

            try
            {
                this.transaction.Rollback();
                this.transaction = null;
                this.sqlcommand.Transaction = null;
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.QueueAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    ex.ToString());      
            }
        }

        /// <summary>
        /// Try to commit the transaction. If it fails, try to rollback. 
        /// </summary>
        public void CommitTransaction()
        {
            if (this.transaction == null)
            {
                Logging.TraceError("{0}: Error: the transaction is either rolled back or committed",
                    ComponentName);
                return;
            }

            try
            {
                this.transaction.Commit();
                this.transaction = null;
                this.sqlcommand.Transaction = null;
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.QueueAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    ex.ToString());   
            }
        }

        /// <summary>
        /// Tries to receive a message. This method relies on the store procedure to determine which queue to receive. 
        /// It also rely on the store procedure to determine whether it will block or not. 
        /// </summary>
        /// <returns>Whether there is a message or not. </returns>
        public bool ReceiveOneMessage()
        {
            int result = 0;

            this.sqlcommand.CommandType = CommandType.StoredProcedure;
            this.sqlcommand.CommandText = this.StoreProcNameForReceive;

            // Clear all existing parameters.
            this.sqlcommand.Parameters.Clear();
            this.sqlcommand.Parameters.Add("@Return_Value", SqlDbType.Int).Direction = ParameterDirection.ReturnValue;
            this.sqlcommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier, 40).Direction = ParameterDirection.Output;
            this.sqlcommand.Parameters.Add("@ConversationGroup", SqlDbType.UniqueIdentifier, 40).Direction = ParameterDirection.Output;
            this.sqlcommand.Parameters.Add("@MessageBody", SqlDbType.NVarChar, -1).Direction = ParameterDirection.Output;
            this.sqlcommand.Parameters.Add("@MessageTypeName", SqlDbType.NVarChar, 128).Direction = ParameterDirection.Output;

            // Must assign both transaction object and connection object to command object.
            this.sqlcommand.Connection = this.connection;
            this.sqlcommand.Transaction = this.transaction;

            // Receive a request from PublishRequestQueue
            this.sqlcommand.ExecuteNonQuery();

            result = (int)this.sqlcommand.Parameters["@Return_Value"].Value; 
            if (result != 1)
            {
                this.messageBody = string.Empty;
                this.messageTypeName = string.Empty;
                return false;
            }
            else
            {
                this.conversationHandle = (Guid)this.sqlcommand.Parameters["@ConversationHandle"].Value;
                this.conversationGroupId = (Guid)this.sqlcommand.Parameters["@ConversationGroup"].Value;
                this.messageBody = Convert.ToString(this.sqlcommand.Parameters["@MessageBody"].Value);
                this.messageTypeName = Convert.ToString(this.sqlcommand.Parameters["@MessageTypeName"].Value);
                return true;
            }
        }

        /// <summary>
        /// End a conversation. On the given handle. 
        /// Conversation handle is unique on either end of the conversation even for the same conversation. Conversation_Id is unique 
        /// for each conversation. There is no need to specify which end point this has to execute because from SQL service broker, 
        /// conversation handle tells everything (machine, end point, conversation group, conversation_id). 
        /// </summary>
        /// <param name="handle">The conversation handle. </param>
        public void EndConversation(Guid handle)
        {
            this.sqlcommand.CommandType = CommandType.StoredProcedure;
            this.sqlcommand.CommandText = this.StoreProcNameForEndConversation;

            this.sqlcommand.Connection = this.connection;
            this.sqlcommand.Transaction = this.transaction;
            
            // Make sure we remove all the previous parametsrs. 
            this.sqlcommand.Parameters.Clear();
            this.sqlcommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier).Value = handle;
            this.sqlcommand.ExecuteNonQuery();
        }

        /// <summary>
        /// Send a response on a given conversation handle. 
        /// NOTE: whehter the conversation is closed on this end is determined by the store procedure. 
        /// </summary>
        /// <param name="handle">The conversation handle. </param>
        /// <param name="message">The message body. </param>
        public void SendResponse(Guid handle, string message)
        {
            this.sqlcommand.CommandType = CommandType.StoredProcedure;
            this.sqlcommand.CommandText = this.StoreProcNameForSendResponse;
            this.sqlcommand.Connection = this.connection;
            this.sqlcommand.Transaction = this.transaction;
            
            // Make sure we remove all the previous parametsrs. 
            this.sqlcommand.Parameters.Clear();
            this.sqlcommand.Parameters.Add("@Message", SqlDbType.NVarChar, -1).Value = message;
            this.sqlcommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier).Value = handle;
            this.sqlcommand.ExecuteNonQuery();
        }

        /// <summary>
        /// Start a dialog and send a message without conversation group. The SQL server will assign one.
        /// NOTE: This is different from SendMessage is the store procedure will begin a dialog first. This is normally called from the service iniator. 
        /// A dialog has to define two end points and a service constract. All the fields are hidden in the store procedure. 
        /// </summary>
        /// <param name="message">The message body. </param>
        public void StartDialog(string message)
        {
            this.sqlcommand.CommandType = CommandType.StoredProcedure;
            this.sqlcommand.CommandText = this.StoreProcNameForStartDialog;
            this.sqlcommand.Connection = this.connection;

            this.sqlcommand.Transaction = this.transaction;
            
            // Make sure we remove all the previous parametsrs. 
            this.sqlcommand.Parameters.Clear();
            this.sqlcommand.Parameters.Add("@Message", SqlDbType.NVarChar, -1).Value = message;

            this.sqlcommand.ExecuteNonQuery();
        }

        /// <summary>
        /// Start a conversation with a preexisting GUID as conversation group id. 
        /// NOTE: this is provided to be more flexible on merging different dialogs into one conversation group. 
        /// If you are not familiar with it, use StartDialog instead. 
        /// </summary>
        /// <param name="conversationGroupId">The GUId used for conversation group Id. </param>
        /// <param name="message">The message body. </param>
        public void StartDialogWithHandle(Guid conversationGroupId, string message)
        {
            this.sqlcommand.CommandType = CommandType.StoredProcedure;
            this.sqlcommand.CommandText = this.StoreProcNameForStartDialogWithHandle;

            this.sqlcommand.Connection = this.connection;
            this.sqlcommand.Transaction = this.transaction;
            
            // Make sure we remove all the previous parametsrs. 
            this.sqlcommand.Parameters.Clear();
            this.sqlcommand.Parameters.Add("@Message", SqlDbType.NVarChar, -1).Value = message;
            this.sqlcommand.Parameters.Add("@GroupHandle", SqlDbType.UniqueIdentifier).Value = conversationGroupId;
            this.sqlcommand.ExecuteNonQuery();
        }
    } // Class level
} // Namespace level
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPlugins\SessionGarbageCollectorPlugin.cs ===
// <copyright file="SessionGarbageCollectorPlugin.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-06</date>
// <summary>Contains the class definition for SessionGarbageCollectorPlugin class.</summary>

namespace AsyncMultiplayer.GarbageCollectorPlugins
{
    using System;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using System.Threading;
    using Common.AzureStorage;
    using GameStateAzureStorage;
    using Leet.Core.Diagnostics;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationSender;
    using NotificationService;
    using SessionAzureStorage;
    using SessionCommon;
    using TimerBasedService.Common;

    /// <summary>
    /// This class implements the session garbage collector plugin.
    /// </summary>
    public class SessionGarbageCollectorPlugin : ITimerPlugin
    {
        /// <summary>
        /// Seconds to wait before deleting sessions after a warning in test mode.
        /// </summary>
        private const uint SecondsToWaitInTestMode = 10;

        /// <summary>
        /// Save a reference to the associated timer.
        /// </summary>
        private Timer timer;

        /// <summary>
        /// Save a reference to the associated description.
        /// </summary>
        private TimerPluginDescription description;

        /// <summary>
        /// The session garbage collector to be used by this plugin.
        /// </summary>
        private SessionAzureGarbageCollector sessionGarbageCollector;

        /// <summary>
        /// The notification sender to be used by this plugin.
        /// </summary>
        private NotificationSender notificationSender;

        /// <summary>
        /// The account to use for game session Azure queries.
        /// </summary>
        private StorageAccountInfo gameSessionAccount;

        /// <summary>
        /// Controls the maximum number of sessions being processed at a time.
        /// </summary>
        private Semaphore sessionsProcessingSemaphore;

        /// <summary>
        /// The entry point of the plugin.
        /// </summary>
        /// <param name="state">The state passed to the work method.</param>
        public void DoWork(object state)
        {
            // first disable the timer
            this.timer.Change(Timeout.Infinite, 0);

            // NOTE: An exception thrown here can crash the whole service, which may have multiple plugins.
            // Make sure that all exceptions are caught.
            Stopwatch stopWatch = new Stopwatch();
            try
            {
                stopWatch.Start();
                Logging.TraceInformation(
                        "{0}: {1}",
                       this.description.DisplayName,
                       "SessionGarbageCollectorPlugin fired. Starting cleaning cycle.");

                this.GarbageCollectSessions();

                Logging.TraceInformation(
                    "{0}: {1}",
                   this.description.DisplayName,
                   "SessionGarbageCollectorPlugin: Ended cleaning cycle.");
            }
            catch (Exception ex)
            {
                // Log all unexpected exceptions
                LIVEnException livEnException = new LIVEnException(
                                                        SessionServiceEvents.Events,
                                                        SessionServiceEvents.UnexpectedExceptionInSessionGarbageCollector,
                                                        HttpStatusCode.InternalServerError,
                                                        ex,
                                                        true);

                Logging.TraceException(
                    livEnException,
                    "{0} {1}",
                    this.description.DisplayName,
                    "An exception occured during the session garbage collection run: ");
            }
            finally
            {
                // re-enable the timer
                if (this.description.Frequency > 0)
                {
                    this.timer.Change(this.description.Frequency * 1000, Timeout.Infinite);
                }

                stopWatch.Stop();
                GarbageCollectorPerfCounters.Counters.SafeIncrementBy(GarbageCollectorPerfCounters.SessionGarbageCollectorRunDuration, stopWatch.ElapsedTicks);
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionGarbageCollectorRunDurationBase);
            }
        }

        /// <summary>
        /// This method initializes the plugin.
        /// </summary>
        /// <param name="timer">The timer associated with this plugin.</param>
        /// <param name="description">The description of the timer.</param>
        /// /// <param name="componentName">The calling service component name.</param>
        public void Initialize(Timer timer, TimerPluginDescription description, string componentName)
        {
            this.timer = timer;
            this.description = description;
            GarbageCollectorPluginCommon.CommonInitialization(componentName);

            // Initially allow no session processing.
            this.sessionsProcessingSemaphore = new Semaphore(
                ServiceConfigs.MaxConcurrentSessionsToProcess, ServiceConfigs.MaxConcurrentSessionsToProcess);

            // Initialize the session garbage collector and other objects.
            this.gameSessionAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            INotificationStorage notificationStorage = new NotificationAzureStorage(
                ServiceConfigs.AzureTableStorageEndPoint,
                ServiceConfigs.NotificationAzureStorageAccount,
                ServiceConfigs.NotificationAzureStorageToken,
                ServiceConfigs.ProxyAddress);

            StorageAccountInfo gameStateAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureBlobStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);
            IGameStateStorage gameStateStorage = new GameStateAzureStorage(gameStateAccount, ServiceConfigs.ProxyAddress);

            this.sessionGarbageCollector = new SessionAzureGarbageCollector(
                        this.gameSessionAccount, ServiceConfigs.ProxyAddress, notificationStorage, gameStateStorage, SecondsToWaitInTestMode);

            INotificationRequest notificationRequest = new NotificationRequestUtils(ServiceConfigs.NotificationRequestQueueConnectionString);
            this.notificationSender = new NotificationSender(notificationRequest);
        }

        /// <summary>
        /// Find out where to start processing session data for Garbage Collection.
        /// </summary>
        /// <returns>The date time where to start processing.</returns>
        private static DateTime GetGCStartTime()
        {
            DateTime rightNow = DateTime.UtcNow;
            return rightNow.AddDays(-1 * ServiceConfigs.DaysToWaitBeforeCleaningSessions);
        }

        /// <summary>
        /// Gets a list of session index Azure Table entities based on the criteria supplied.
        /// </summary>
        /// <param name="sessionIndexContext">The data service context for the query.</param>
        /// <param name="partitionKey">Partition key for the session index table.</param>
        /// <returns>All session index Azure Table entities which have partition keys equal to or less than the partitionKey supplied.</returns>
        private static IEnumerable<SessionIndexAzureTableEntity> GetSessionIndexEntityList(
            SessionIndexDataServiceContext sessionIndexContext, string partitionKey)
        {
            var query = from c in sessionIndexContext.SessionIndexTable
                        where c.PartitionKey.CompareTo(partitionKey) <= 0
                        select c;

            TableStorageDataServiceQuery<SessionIndexAzureTableEntity> sessionIndexQuery =
                new TableStorageDataServiceQuery<SessionIndexAzureTableEntity>(
                    query as DataServiceQuery<SessionIndexAzureTableEntity>,
                    sessionIndexContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionIndexAzureTableEntity> res = sessionIndexQuery.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// Garbage collect sessions.
        /// </summary>
        private void GarbageCollectSessions()
        {
            // Get all sessions starting from GetGCStartTime upto indefinitely in the past.
            SessionIndexDataServiceContext sessionContext = new SessionIndexDataServiceContext(this.gameSessionAccount);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = ServiceConfigs.ProxyAddress;
            DateTime startingDateTime = SessionGarbageCollectorPlugin.GetGCStartTime();
            IEnumerable<SessionIndexAzureTableEntity> sessionIndexEntities =
                                                SessionGarbageCollectorPlugin.GetSessionIndexEntityList(
                                                                        sessionContext,
                                                                        startingDateTime.ToString(SessionIndexAzureTableEntity.GetPartitionKeyFormat()));

            foreach (var sessionIndexEntity in sessionIndexEntities)
            {
                this.sessionsProcessingSemaphore.WaitOne();
                ThreadPool.QueueUserWorkItem(new WaitCallback(this.ProcessSession), sessionIndexEntity);
            }
        }

        /// <summary>
        /// Process session for garbage collection.
        /// </summary>
        /// <param name="sessionIndexEntityObj">Parameter to the thread callback method, this is expected to be a SessionIndexAzureTableEntity object.</param>
        private void ProcessSession(object sessionIndexEntityObj)
        {
            SessionIndexAzureTableEntity sessionIndexEntity = (SessionIndexAzureTableEntity) sessionIndexEntityObj;

            try
            {
                int warnedSeatIndex;
                SessionState sessionState;

                bool wasSessionDeleted = this.sessionGarbageCollector.DeleteSession(
                                                                    sessionIndexEntity.SessionID,
                                                                    (uint)sessionIndexEntity.GameID,
                                                                    sessionIndexEntity.PartitionKey,
                                                                    sessionIndexEntity.RowKey,
                                                                    out warnedSeatIndex,
                                                                    out sessionState,
                                                                    ServiceConfigs.RunInTestMode);
                if (wasSessionDeleted)
                {
                    Logging.TraceVerbose(
                        "{0} {1} {2} {3} {4} {5} {6}",
                        this.description.DisplayName,
                        "SessionGarbageCollectorPlugin: Session was deleted, Partition being processed: ",
                        sessionIndexEntity.PartitionKey,
                        " SessionID: ",
                        sessionIndexEntity.SessionID,
                        " GameID: ",
                        sessionIndexEntity.GameID.ToString());

                    GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsDeleted);
                    GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsDeletedPerSecond);
                }
                else
                {
                    Logging.TraceVerbose(
                        "{0} {1} {2} {3} {4} {5} {6}",
                        this.description.DisplayName,
                        "SessionGarbageCollectorPlugin: Session was NOT deleted, Partition being processed: ",
                        sessionIndexEntity.PartitionKey,
                        " SessionID: ",
                        sessionIndexEntity.SessionID,
                        " GameID: ",
                        sessionIndexEntity.GameID.ToString());
                }

                // If someone was warned, send a notification.
                if (warnedSeatIndex >= 0)
                {
                    if (sessionState == null)
                    {
                        Logging.TraceInformation(
                            "{0} {1} {2} {3} {4} {5} {6}",
                            this.description.DisplayName,
                            "SessionGarbageCollectorPlugin: A player was warned but the session was not returned, hence cannot send the notification, SessionID: ",
                            sessionIndexEntity.SessionID,
                            " GameID: ",
                            sessionIndexEntity.GameID.ToString(),
                            " WarnedSeatIndex: ",
                            warnedSeatIndex);
                    }
                    else
                    {
                        this.notificationSender.SendNudgeNotification(sessionState, warnedSeatIndex);
                    }
                }

                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsProcessed);
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsProcessedPerSecond);
            }
            catch (LIVEnException)
            {
                // Ignore any LIVEnException.
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsProcessedWithErrors);
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsProcessedWithErrorsPerSecond);
            }
            catch (Exception ex)
            {
                // Trace this exception and ignore it.
                // We don't want an exception in the processing of a session to stop the whole garbage collection cycle.
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsProcessedWithErrors);
                GarbageCollectorPerfCounters.Counters.SafeIncrement(GarbageCollectorPerfCounters.SessionsProcessedWithErrorsPerSecond);
                Logging.TraceWarning(
                    "{0} {1} {2} {3} {4} {5} {6}",
                    this.description.DisplayName,
                    "An exception occured while trying to delete/warn a session, SessionID: ",
                    sessionIndexEntity.SessionID,
                    " GameID: ",
                    sessionIndexEntity.GameID.ToString(),
                    " Exception Details: \n",
                    ex.ToString());
            }
            finally
            {
                this.sessionsProcessingSemaphore.Release();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationSender\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-12-10</date>
// <summary>Contains the assembly information for the NotificationSender assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationSender")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("55ab6e64-5b94-4735-82be-a9cc6838118b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\GarbageCollectorPluginsTest\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-17</date>
// <summary>Contains the assembly information for the GarbageCollectorPluginsTest assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("GarbageCollectorPluginsTest")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f6b3c630-c0ed-4b42-a33c-20362a225961")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\Database\AsyncNotification\Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Unit test case for NotificationRequest Queue
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading; 
    using System.Xml.Serialization;
  
    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            string connectionString = "Data Source=fgao-srv\\FGAOSQLSERVER;Initial Catalog=AsyncNotification;Integrated Security=True"; 
            QueueAccess queueAccess = new QueueAccess();
            queueAccess.ConnectionString = connectionString; 
            
            // setup responseQueue first
            queueAccess.StoreProcNameForStartDialog = "NotificationSchema.SendNotificationRequest"; 
            queueAccess.StoreProcNameForReceive = "NotificationSchema.ReceiveNotificationRequest";
            queueAccess.StoreProcNameForEndConversation = "NotificationSchema.EndConversation";
            int receivedCount = 0; 
            
            // note that the stored procedures for notification is not a full loop. 
            // the queue are setup to mimic fire and forget, conversation should be end by the recever

            // send 10 messages
            queueAccess.Init();
            try
            {
                for (int i = 0; i < 10; i++)
                {
                    queueAccess.BeginTransaction();
                    queueAccess.StartDialog(string.Format("message {0} sent ", i));
                    queueAccess.CommitTransaction();
                }

                // receive the messages
                while (true)
                {
                    queueAccess.BeginTransaction();
                    if (queueAccess.ReceiveOneMessage())
                    {
                        Console.WriteLine("Received " + queueAccess.ReceivedMessage);
                        
                        // we are not sending response back, just end it
                        queueAccess.EndConversation(queueAccess.ReceivedMessageHandle);
                        queueAccess.CommitTransaction();
                        receivedCount++;
                        if (receivedCount >= 10)
                        {
                            break;
                        }
                    }
                    else
                    {
                        queueAccess.RollbackTransaction();
                        Console.WriteLine("No message received, go to sleep");
                        Thread.Sleep(2000); 
                    }
                }
            }
            catch (Exception ex)
            {
                queueAccess.RollbackTransaction();
                queueAccess.Close();
                Console.WriteLine("Error happened " + ex.ToString());
            }

            // NOTE: we are not receiving response. An internally activated stored procedure will end all these
            //       message. 

            // NOTE we are using another constructor. No need to call Initialize. 
            //The rest is to clear the activation events from ActivationQueue. 
            QueueAccess eventQueueAccess = new QueueAccess(connectionString);
            eventQueueAccess.StoreProcNameForReceive = "NotificationSchema.ReceiveRequestEvent";
           
            receivedCount = 0;
            while (true)
            {
                eventQueueAccess.BeginTransaction();
                if (eventQueueAccess.ReceiveOneMessage())
                {
                    Console.WriteLine("Activatinon event received");
                    
                    // for activation event, don't end the conversation. They are sent from the same converation handle
                    eventQueueAccess.CommitTransaction(); 
                }
                else
                {
                    eventQueueAccess.RollbackTransaction();
                    break;
                }
            }

            eventQueueAccess.Close(); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationSender\NotificationSender.cs ===
// <copyright file="NotificationSender.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-08</date>
// <summary>Contains the class definition for NotificationSender class.</summary>
namespace AsyncMultiplayer.NotificationSender
{
    using System.Collections.Generic;
    using System.Net;
    using System.Text;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationService;
    using SessionCommon;

    /// <summary>
    /// This class sends out notifications on behalf of the Session Management Service.
    /// </summary>
    public class NotificationSender
    {
        /// <summary>
        /// This field has the reference to the INotificationRequest implementation.
        /// </summary>
        private readonly INotificationRequest notificationRequest;

        /// <summary>
        /// The system identity. 
        /// </summary>
        private readonly IdentityToken systemIdentity;

        /// <summary>
        /// Initializes a new instance of the NotificationSender class.
        /// </summary>
        /// <param name="notificationRequest">The notification reference to use for sending notifications.</param>
        public NotificationSender(INotificationRequest notificationRequest)
        {
            this.notificationRequest = notificationRequest;
            this.systemIdentity = new IdentityToken(0, "MPSystem");
        }

        /// <summary>
        /// Gets the system identity (Xbox LIVE),used in default cases and system notifications.
        /// </summary>
        public IdentityToken SystemIdentity
        {
            get
            {
                return this.systemIdentity;
            }
        }

        /// <summary>
        /// Sends YoutTurn notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="senderIdentity">The sender's identity.</param>
        public void SendYourTurnNotification(SessionState sessionState, IdentityToken senderIdentity)
        {
            IdentityToken activePlayer = null;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Index == sessionState.State.ActiveSeatIndex)
                {
                    activePlayer = seat.Profile;
                    break;
                }
            }

            if (activePlayer == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ActivePlayerNotFound,
                    HttpStatusCode.InternalServerError,
                    null,
                    true,
                    sessionState.SessionID,
                    sessionState.GameID.ToString());
            }

            YourTurnNotification notification = new YourTurnNotification
                                                        {
                                                            GameId = sessionState.GameID,
                                                            SessionId = sessionState.SessionID,
                                                            Variant = (uint)sessionState.Variant
                                                        };

            this.SendCreateNotificationRequest(notification, senderIdentity, activePlayer, sessionState.GetOwnerLocale());
        }

        /// <summary>
        /// Send request to delete user's invitation notification. This is part of the action 
        /// of rejecting an inviation. 
        /// </summary>
        /// <param name="gameId">The GameId. </param>
        /// <param name="sessionId">The SessionId. </param>
        /// <param name="owner">The identity of the user who is rejecting. </param>
        public void DeleteInvitationNotification(uint gameId, string sessionId, IdentityToken owner)
        {
            NotificationQueryParameter queryParameter = new NotificationQueryParameter();
            queryParameter.GameId = gameId;
            queryParameter.SessionId = sessionId;
            queryParameter.UserId = owner.Token;
            queryParameter.Type = (uint)Notification.NotificationType.Invitation;

            NotificationRequest request = new NotificationRequest();
            request.To = owner.Token;
            request.From = owner.Token;
            request.Action = NotificationRequest.ActionType.Delete;
            request.Command = request.Action.ToString();
            request.GameId = gameId;
            request.SessionId = sessionId;
            request.RequestData = Notification.SerializeToString(queryParameter);
            this.notificationRequest.SendNotificationRequest(request);
        }

        /// <summary>
        /// Delete YourTurn notification from the user's storage once he/she has made the move. 
        /// </summary>
        /// <param name="sessionState">The state of the session. Used to determined GameId and SessionId. </param>
        /// <param name="lastPlayer">The player who made the game state change. </param>
        public void DeleteYourTurnNotification(SessionState sessionState, IdentityToken lastPlayer)
        {
            this.DeleteNotificationByType(sessionState, lastPlayer, Notification.NotificationType.YourTurn);
        }

        /// <summary>
        /// Delete a specific type of notification from the user's storage 
        /// </summary>
        /// <param name="sessionState">The state of the session. Used to determined GameId and SessionId. </param>
        /// <param name="owner">The owner of the notification. </param>
        /// <param name="type">The type of notifications to be deleted. </param>
        public void DeleteNotificationByType(SessionState sessionState, IdentityToken owner, Notification.NotificationType type)
        {
            NotificationQueryParameter queryParameter = new NotificationQueryParameter();
            queryParameter.GameId = sessionState.GameID;
            queryParameter.SessionId = sessionState.SessionID;
            queryParameter.UserId = owner.Token;
            queryParameter.Type = (uint)type;

            NotificationRequest request = new NotificationRequest();
            request.Action = NotificationRequest.ActionType.Delete;
            request.To = owner.Token;
            request.From = this.systemIdentity.Token;
            request.Command = request.Action.ToString();
            request.GameId = sessionState.GameID;
            request.SessionId = sessionState.SessionID;
            request.RequestData = Notification.SerializeToString(queryParameter);
            this.notificationRequest.SendNotificationRequest(request);
        }

        /// <summary>
        /// Delete all notifications for a sesssion from the user's storage 
        /// </summary>
        /// <param name="sessionState">The state of the session. Used to determined GameId and SessionId. </param>
        /// <param name="owner">The owner of the notification. </param>
        public void DeleteAllNotificationsForSession(SessionState sessionState, IdentityToken owner)
        {
            NotificationQueryParameter queryParameter = new NotificationQueryParameter();
            queryParameter.GameId = sessionState.GameID;
            queryParameter.SessionId = sessionState.SessionID;
            queryParameter.UserId = owner.Token;

            NotificationRequest request = new NotificationRequest();
            request.Action = NotificationRequest.ActionType.Delete;
            request.To = owner.Token;
            request.From = this.systemIdentity.Token;
            request.Command = request.Action.ToString();
            request.GameId = sessionState.GameID;
            request.SessionId = sessionState.SessionID;
            request.RequestData = Notification.SerializeToString(queryParameter);
            this.notificationRequest.SendNotificationRequest(request);
        }

        /// <summary>
        /// Delete Nudge notification from the user's storage once he/she has made the move. 
        /// </summary>
        /// <param name="sessionState">The state of the session. </param>
        /// <param name="lastPlayer">The player who made the game state chagne. </param>
        public void DeleteNudgeNotification(SessionState sessionState, IdentityToken lastPlayer)
        {
            this.DeleteNotificationByType(sessionState, lastPlayer, Notification.NotificationType.Nudge);
        }

        /// <summary>
        /// Sends GameOver notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        public void SendGameOverNotification(SessionState sessionState)
        {
            GameOverNotification notification = new GameOverNotification
                                                    {
                                                        GameId = sessionState.GameID,
                                                        SessionId = sessionState.SessionID,
                                                        Variant = (uint)sessionState.Variant
                                                    };

            List<IdentityToken> receivers = new List<IdentityToken>();
            foreach (var seat in sessionState.Seats)
            {
                receivers.Add(seat.Profile);
            }

            this.SendCreateNotificationRequest(notification, this.systemIdentity, receivers, sessionState.GetOwnerLocale());
        }

        /// <summary>
        /// Sends GameOver notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="seatIDsToBeNotified">Array of seatIDs that need to get the notification. </param>
        public void SendGameOverNotification(SessionState sessionState, int[] seatIDsToBeNotified)
        {
            List<int> toBeNotifiedSeatIndexList = new List<int>(seatIDsToBeNotified);
            toBeNotifiedSeatIndexList.Sort();

            List<IdentityToken> toBeNotifiedList = new List<IdentityToken>();
            int numOfToBeNotifiedProcessed = 0;

            foreach (var seat in sessionState.Seats)
            {
                // If this is not one of the "to be notified seats", skip this seat.
                if (toBeNotifiedSeatIndexList.BinarySearch(seat.Index) < 0)
                {
                    continue;
                }

                toBeNotifiedList.Add(seat.Profile);
                numOfToBeNotifiedProcessed++;

                // If we have processed all "to be notified seats", break from the loop.
                if (numOfToBeNotifiedProcessed == seatIDsToBeNotified.Length)
                {
                    break;
                }
            }

            GameOverNotification notification = new GameOverNotification
            {
                GameId = sessionState.GameID,
                SessionId = sessionState.SessionID,
                Variant = (uint)sessionState.Variant
            };

            this.SendCreateNotificationRequest(notification, this.systemIdentity, toBeNotifiedList, sessionState.GetOwnerLocale());
        }

        /// <summary>
        /// Sends YouWin notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="winningSeatIDs">Array of winning seatIDs</param>
        public void SendYouWinNotification(SessionState sessionState, int[] winningSeatIDs)
        {
            List<int> winningSeatIndexList = new List<int>(winningSeatIDs);
            winningSeatIndexList.Sort();

            List<IdentityToken> winnerList = new List<IdentityToken>();
            int numberOfWinnersProcessed = 0;

            foreach (var seat in sessionState.Seats)
            {
                // If this is not one of the winner seats, skip this seat.
                if (winningSeatIndexList.BinarySearch(seat.Index) < 0)
                {
                    continue;
                }

                winnerList.Add(seat.Profile);
                numberOfWinnersProcessed++;

                // If we have processed all winners, break from the loop.
                if (numberOfWinnersProcessed == winningSeatIDs.Length)
                {
                    break;
                }
            }

            this.SendYouWinNotification(sessionState, winnerList);
        }

        /// <summary>
        /// Sends YouWin notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="winnerList">Array of winners.</param>
        public void SendYouWinNotification(SessionState sessionState, List<IdentityToken> winnerList)
        {
            YouWinNotification notification = new YouWinNotification
                                                    {
                                                        GameId = sessionState.GameID,
                                                        SessionId = sessionState.SessionID,
                                                        Variant = (uint)sessionState.Variant
                                                    };

            this.SendCreateNotificationRequest(notification, this.systemIdentity, winnerList, sessionState.GetOwnerLocale());
        }

        /// <summary>
        /// Sends YouLose notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="losingSeatIDs">Array of losing seatIDs</param>
        public void SendYouLoseNotification(SessionState sessionState, int[] losingSeatIDs)
        {
            List<int> losingSeatIndexList = new List<int>(losingSeatIDs);
            losingSeatIndexList.Sort();

            List<IdentityToken> loserList = new List<IdentityToken>();
            int numberOfLosersProcessed = 0;

            foreach (var seat in sessionState.Seats)
            {
                // If this is not one of the loser seats, skip this seat.
                if (losingSeatIndexList.BinarySearch(seat.Index) < 0)
                {
                    continue;
                }

                loserList.Add(seat.Profile);
                numberOfLosersProcessed++;

                // If we have processed all losers, break from the loop.
                if (numberOfLosersProcessed == losingSeatIDs.Length)
                {
                    break;
                }
            }

            YouLoseNotification notification = new YouLoseNotification
                                                    {
                                                        GameId = sessionState.GameID,
                                                        SessionId = sessionState.SessionID,
                                                        Variant = (uint)sessionState.Variant
                                                    };

            this.SendCreateNotificationRequest(notification, this.systemIdentity, loserList, sessionState.GetOwnerLocale());
        }

        /// <summary>
        /// Sends GameTie notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="tieSeatIDs">Array of tie seatIDs</param>
        public void SendGameTieNotification(SessionState sessionState, int[] tieSeatIDs)
        {
            List<int> tieSeatIndexList = new List<int>(tieSeatIDs);
            tieSeatIndexList.Sort();

            List<IdentityToken> tierList = new List<IdentityToken>();
            int numberOfTiersProcessed = 0;

            foreach (var seat in sessionState.Seats)
            {
                // If this is not one of the tie seats, skip this seat.
                if (tieSeatIndexList.BinarySearch(seat.Index) < 0)
                {
                    continue;
                }

                tierList.Add(seat.Profile);
                numberOfTiersProcessed++;

                // If we have processed all tie'ers, break from the loop.
                if (numberOfTiersProcessed == tieSeatIDs.Length)
                {
                    break;
                }
            }

            GameTieNotification notification = new GameTieNotification
                                                    {
                                                        GameId = sessionState.GameID,
                                                        SessionId = sessionState.SessionID,
                                                        Variant = (uint)sessionState.Variant
                                                    };

            this.SendCreateNotificationRequest(notification, this.systemIdentity, tierList, sessionState.GetOwnerLocale());
        }

        /// <summary>
        /// Sends User Nudge notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="nudgedPlayerSeatIndex">Seat index of the nudged player.</param>
        /// <param name="senderIdentity">The identity of the nudge sender.</param>
        public void SendUserNudgeNotification(SessionState sessionState, int nudgedPlayerSeatIndex, IdentityToken senderIdentity)
        {
            IdentityToken nudgedPlayer = null;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Index == nudgedPlayerSeatIndex)
                {
                    nudgedPlayer = seat.Profile;
                    break;
                }
            }

            if (nudgedPlayer == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNudgedPlayerNotFound,
                    HttpStatusCode.InternalServerError,
                    null,
                    true,
                    sessionState.SessionID,
                    sessionState.GameID.ToString(),
                    nudgedPlayerSeatIndex.ToString());
            }

            NudgeNotification notification = new NudgeNotification
                                                    {
                                                        GameId = sessionState.GameID,
                                                        SessionId = sessionState.SessionID,
                                                        Variant = (uint)sessionState.Variant
                                                    };
            
            this.SendCreateNotificationRequest(notification, senderIdentity, nudgedPlayer, sessionState.GetPlayerLocale(senderIdentity));
        }

        /// <summary>
        /// Sends Nudge notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="nudgedPlayerSeatIndex">Seat index of the nudged player.</param>
        public void SendNudgeNotification(SessionState sessionState, int nudgedPlayerSeatIndex)
        {
            IdentityToken nudgedPlayer = null;
            foreach (var seat in sessionState.Seats)
            {
                if (seat.Index == nudgedPlayerSeatIndex)
                {
                    nudgedPlayer = seat.Profile;
                    break;
                }
            }

            this.SendNudgeNotification(sessionState, nudgedPlayer);
        }

        /// <summary>
        /// Sends Nudge notification.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="nudgedPlayer">The identity of the nudged player.</param>
        public void SendNudgeNotification(SessionState sessionState, IdentityToken nudgedPlayer)
        {
            if (nudgedPlayer != null)
            {
                NudgeNotification notification = new NudgeNotification
                                                     {
                                                         GameId = sessionState.GameID,
                                                         SessionId = sessionState.SessionID,
                                                         Variant = (uint)sessionState.Variant
                                                     };

                this.SendCreateNotificationRequest(notification, this.systemIdentity, nudgedPlayer, sessionState.GetOwnerLocale());
            }
        }

        /// <summary>
        /// Sends Nudge notification from a particular user.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out the notification.</param>
        /// <param name="nudgedPlayer">The identity of the nudged player.</param>
        /// <param name="senderIdentity">The identity of the sender.</param>
        public void SendNudgeNotification(SessionState sessionState, IdentityToken nudgedPlayer, IdentityToken senderIdentity)
        {
            if (nudgedPlayer != null)
            {
                NudgeNotification notification = new NudgeNotification
                {
                    GameId = sessionState.GameID,
                    SessionId = sessionState.SessionID,
                    Variant = (uint)sessionState.Variant
                };

                this.SendCreateNotificationRequest(notification, senderIdentity, nudgedPlayer, sessionState.GetOwnerLocale());
            }
        }

        /// <summary>
        /// Send a create notification request to the queue. The notification will be sent 
        /// to a list of recipients.
        /// </summary>
        /// <param name="notification">The notification.</param>
        /// <param name="senderIdentity">The identity of the sender.</param>
        /// <param name="recipients">The identities of a list of recipients.</param>
        /// <param name="sendersLocale">The locale of the sender.</param>
        internal void SendCreateNotificationRequest(Notification notification, IdentityToken senderIdentity, List<IdentityToken> recipients, string sendersLocale)
        {
            NotificationRequest request = new NotificationRequest();
            request.From = senderIdentity.Token;

            StringBuilder toStringBuilder = new StringBuilder();
            foreach (var receiverIdentity in recipients)
            {
                toStringBuilder.Append(receiverIdentity.Token);
                toStringBuilder.Append(";");
            }

            request.To = toStringBuilder.ToString();
            request.Action = NotificationRequest.ActionType.Create;
            request.Command = request.Action.ToString() + notification.Type.ToString();
            request.GameId = notification.GameId;
            request.SessionId = notification.SessionId;
            request.RequestDataType = (int)notification.Type;
            request.RequestData = Notification.SerializeToString(notification);
            request.RequestLocale = sendersLocale;

            this.notificationRequest.SendNotificationRequest(request);
        }

        /// <summary>
        /// Send a create notification request to the queue.
        /// </summary>
        /// <param name="notification">The notification body. </param>
        /// <param name="senderIdentity">The identity of the sender.</param>
        /// <param name="recipient">The identity of the receipient</param>
        /// <param name="sendersLocale">The locale of the sender.</param>
        internal void SendCreateNotificationRequest(Notification notification, IdentityToken senderIdentity, IdentityToken recipient, string sendersLocale)
        {
            NotificationRequest request = new NotificationRequest();
            request.From = senderIdentity.Token;

            request.To = recipient.Token;
            request.Action = NotificationRequest.ActionType.Create;
            request.Command = request.Action.ToString() + notification.Type.ToString();
            request.GameId = notification.GameId;
            request.SessionId = notification.SessionId;
            request.RequestDataType = (int)notification.Type;
            request.RequestData = Notification.SerializeToString(notification);
            request.RequestLocale = sendersLocale;
            this.notificationRequest.SendNotificationRequest(request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedService\Service.cs ===
//-------------------------------------------------------------------
// <copyright file="Service.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The main thread of the timer based service
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.EventBasedService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Threading;
    using System.Timers;
    using AsyncMultiplayer.EventBasedService.Common;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Health.Common;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// The main Notification service.
    /// </summary>
    public partial class EventBasedService : System.ServiceProcess.ServiceBase, IEventService
    {
        /// <summary>
        /// The maximum allowed timer based plugins.
        /// </summary>
        private const int MaxAllowedPlugins = 5;

        /// <summary>
        /// The display name of the component. 
        /// </summary>
        private const string ComponentName = "system_nudge_dispatcher";

        /// <summary>
        /// The service base. This pointer is used for stopping the service gracefully. 
        /// </summary>
        private static System.ServiceProcess.ServiceBase serviceBase = null;

        /// <summary>
        /// A flag to indicate whether the Notification service is stopping.
        /// </summary>
        private static bool serviceIsStopping;

        /// <summary>
        /// a signal used to wake up all the threads. 
        /// </summary>
        private ManualResetEvent stoppingEvent;

        /// <summary>
        /// an array of events for child threads to report they are done. 
        /// </summary>
        private ManualResetEvent[] doneEvents;

        /// <summary>
        /// A list of the worker threads. 
        /// </summary>
        private List<Thread> workerThreadList;

        /// <summary>
        /// Initializes a new instance of the EventBasedService class. 
        /// </summary>
        public EventBasedService()
        {
        }

        /// <summary>
        /// Gets or sets a value indicating whether the service is stopping
        /// </summary>
        public static bool ServiceIsStopping
        {
            get { return serviceIsStopping; }
            set { serviceIsStopping = value; }
        }

        /// <summary>
        /// Gets or sets the service base of EventBasedService. 
        /// </summary>
        public static System.ServiceProcess.ServiceBase ServiceBase
        {
            get { return EventBasedService.serviceBase; }
            set { EventBasedService.serviceBase = value; }
        }

        /// <summary>
        /// Provide a way to gracefully stop the service. 
        /// </summary>
        public static void StopService()
        {
            EventBasedService.ServiceBase.Stop();
        }

        /// <summary>
        /// Check if the service is stopping. This is used for other plugin threads to access
        /// this value. 
        /// </summary>
        /// <returns>A boolean to indicate if the service is stopping</returns>
        public bool IsServiceStopping()
        {
            return ServiceIsStopping;
        }

        /// <summary>
        /// The overrided onStart method. Enable the timer. Init the queue object.
        /// </summary>
        /// <param name="args">Argument lists. It is not used by this override method. </param>
        protected override void OnStart(string[] args)
        {
            try
            {
                // Initialize event system.
                SystemNudgeServiceEvents.Initialize(ComponentName);

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Starting EventBasedService.");

                // Set the default directory to current.Service will use system32 by default. 
                // this is required in case any of the file path uses relative path. 
                System.IO.Directory.SetCurrentDirectory(System.AppDomain.CurrentDomain.BaseDirectory);

                this.stoppingEvent = new ManualResetEvent(false);
                this.workerThreadList = new List<Thread>(); 

                EventBasedService.ServiceIsStopping = false;

                // initialize the health listner
                try
                {
                    string healthCheckPort = ConfigurationManager.AppSettings["HealthCheck_HighPort"];

                    // Invoke the health listner only when port can be found in EventBasedService.exe.config
                    if (String.IsNullOrEmpty(healthCheckPort))
                    {
                        Logging.TraceError(
                            "{0}: {1}",
                            ComponentName,
                            "healthCheckPort is empty in the EventBasedService.exe.config file.");
                    }
                    else
                    {
                        ushort listnerPort = UInt16.Parse(healthCheckPort);
                        HealthListener.InitializeHealthListener(ComponentName, listnerPort);
                    }
                }
                catch (Exception ex)
                {
                    // we should let the System Nudge Service run
                    // any exception caught here can only be due to bad configuration which should not happen
                    Logging.TraceException(
                        ex,
                        "{0}: {1}",
                        ComponentName,
                        "Caught exception initializing health blocks.");
                }

                this.InitializePlugins();

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "EventBasedService started.");
            }
            catch (Exception e)
            {
                Logging.TraceException(
                    e,
                    "{0}: {1}",
                    ComponentName,
                    "Exception caught during EventBasedService start up.");

                HandleException("OnStart", e);
            }
        }

        /// <summary>
        /// The overrided onStop method. Close the queue object.
        /// </summary>
        protected override void OnStop()
        {
            try
            {
                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Stoping EventBasedService.");

                // Set the flag to indicate the service is stopping.
                // This is used to control the while loop of EventBasedServiceWorker
                EventBasedService.ServiceIsStopping = true;

                // wait for all the child threads to complete. 
                this.stoppingEvent.Set();

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Wait for all the child threads to stop. ");

                // Wait all the threads to complete. The timeout is set to 10000 milliseconds. 
                WaitHandle.WaitAll(this.doneEvents, 10000);

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "EventBasedService stopped.");
            }
            catch (Exception e)
            {
                Logging.TraceException(
                    e,
                    "{0}: {1}",
                    ComponentName,
                    "Exception caught during EventBasedService shut down.");

                HandleException("OnStop", e);
            }
        }

        /// <summary>
        /// The entry point of the service.
        /// </summary>
        private static void Main()
        {
            try
            {
                Leet.Core.IoCCo.Container.Instance.AddService<ILogFormatter, LogFormatter>();
                Leet.Core.IoCCo.Container.Instance.AddService<ILogging, Logging>();

                Leet.Core.IoCCo.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();

                Leet.Core.IoCCo.Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
                ((NpdbConfigurationProvider)Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", ComponentName);

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Enter Main()");

                System.ServiceProcess.ServiceBase[] servicesToRun;

                // More than one user service may run within the same process. To add
                // another service to this process, change the following line to
                // create a second service object. For example,
                //
                // ServicesToRun = new System.ServiceProcess.ServiceBase[]
                // {new Service1(), new MySecondUserService()};

                // Save a pointer to service base so other threads can access it
                EventBasedService.ServiceBase = new EventBasedService();
                servicesToRun = new System.ServiceProcess.ServiceBase[] { EventBasedService.ServiceBase };

                System.ServiceProcess.ServiceBase.Run(servicesToRun);

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Leave Main()");
            }
            catch (Exception e)
            {
                Logging.TraceException(
                    e,
                    "{0}: {1}",
                    ComponentName,
                    "Exception caught in EventBasedService.Main().");

                EventBasedService.HandleException("Main()", e);
            }
        }

        /// <summary>
        /// This eventlogs the exception.
        /// to the client.
        /// </summary>
        /// <param name="methodName">Name of the web method from which
        /// exception is thrown.
        /// </param>
        /// <param name="ex">Exception object.</param>
        private static void HandleException(string methodName, Exception ex)
        {
            Logging.TraceException(
                ex,
                "{0}: {1} {2}",
                ComponentName,
                "Unhandled Exception in EventBasedService.",
                methodName);

            SystemNudgeServiceEvents.Events.TraceEvent(
                SystemNudgeServiceEvents.UnexpectedExceptionInService,
                "\r\nUnexpected exception happened in: " + methodName + ".\r\n",
                ex.ToString());

            throw ex;
        }

        /// <summary>
        /// Load and initialize the timer plugins. 
        /// </summary>
        private void InitializePlugins()
        {
            List<EventServicePluginDescription> plugins = (List<EventServicePluginDescription>)System.Configuration.ConfigurationManager.GetSection("Plugins");
            if (plugins.Count == 0)
            {
                throw new LIVEnException("No plugins are specified in the cofiguration file ");
            }

            if (plugins.Count > MaxAllowedPlugins)
            {
                throw new LIVEnException("There are too many plugins specified in the config file. ");
            }

            this.doneEvents = new ManualResetEvent[plugins.Count];
            int index = 0; 
            foreach (EventServicePluginDescription plugin in plugins)
            {
                Logging.TraceInformation(
                    "{0}: {1} {2}",
                    ComponentName,
                    "Load plugin ",
                    plugin.DisplayName);

                ManualResetEvent doneEvent = new ManualResetEvent(false); 
                this.doneEvents[index] = doneEvent; 
                Type type = Type.GetType((string)plugin.Type);
                IEventServicePlugin eventServicePlugin = Activator.CreateInstance(type) as IEventServicePlugin;
                eventServicePlugin.Initialize(this, this.stoppingEvent, doneEvent, plugin, ComponentName);
                Thread thread = new Thread(eventServicePlugin.DoWork);
                this.workerThreadList.Add(thread); 
                thread.Start();

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Plugin initialized and started. "); 
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedPluginCommon\SamplePlugin.cs ===
//-------------------------------------------------------------------
// <copyright file="SamplePlugin.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  This is a sample implementation of IEventServicePlugin interface
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.EventBasedService.Common
{
    using System.Threading;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// A sample plugin for event based service
    /// </summary>
    public class SamplePlugin : IEventServicePlugin
    {
        /// <summary>
        /// An event used to force the child thread to wake up. 
        /// </summary>
        private ManualResetEvent wakeupEvent;

        /// <summary>
        /// An event used to signal the master thread that it is done. 
        /// </summary>
        private ManualResetEvent doneEvent;

        /// <summary>
        /// Save a reference to the associated description. 
        /// </summary>
        private EventServicePluginDescription description;

        /// <summary>
        /// A pointer to the parent service. 
        /// </summary>
        private IEventService parentService;

        /// <summary>
        /// The entry point of the plugin
        /// </summary>
        /// <param name="state">The state to pass into. </param>
        public void DoWork(object state)
        {
            while (!this.parentService.IsServiceStopping())
            {
                Logging.TraceError(
                    "{0}: {1}",
                   this.description.DisplayName,
                   "I am awake and doing nothing.");

                // wait for wake up event or time out. 
                this.wakeupEvent.WaitOne(10000);
            }

            Logging.TraceError(
                "{0}: {1}",
                this.description.DisplayName,
                "I received service stopping. terminate. ");

            this.doneEvent.Set();
        }

        /// <summary>
        /// This method initializes the plugin. 
        /// </summary>
        /// <param name="parentService">The containing service object. </param>
        /// <param name="wakeupEvent">The signal used to wake a thread</param>
        /// <param name="doneEvent">The singal used to tell the master thread that it is done</param>
        /// <param name="description">The description of the timer. </param>
        /// <param name="componentName">The service component name.</param>
        public void Initialize(IEventService parentService, ManualResetEvent wakeupEvent, ManualResetEvent doneEvent, EventServicePluginDescription description, string componentName)
        {
            // option is ignored in this sample. It can be an xml string with 
            // optional arguments. 
            this.wakeupEvent = wakeupEvent;
            this.doneEvent = doneEvent;
            this.parentService = parentService;
            this.description = description;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedService\PluginConfigurationSection.cs ===
//-----------------------------------------------------------------------------
// <copyright file="PluginConfigurationSection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//     This file contains the class for retrieving custom-defined plugins
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/11/2010">
//     Class Created
// </history>
//-----------------------------------------------------------------------------
namespace AsyncMultiplayer.EventBasedService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Xml;
    using AsyncMultiplayer.EventBasedService.Common;
    using Leet.Core.Utils;

    /// <summary>
    /// Custom Handler to access the custom-defined Configuration Section.
    /// </summary>
    public class PluginConfigSectionHandler : IConfigurationSectionHandler
    {
        /// <summary>
        /// Creates a custom-defined object that contains the custom-defined settings.
        /// </summary>
        /// <param name="parent">Parent object in web.config.</param>
        /// <param name="configContext">Configuration context object.</param>
        /// <param name="section">Specified Section XML node.</param>
        /// <returns>The object created by the handler.</returns>
        object IConfigurationSectionHandler.Create(
          object parent, object configContext, XmlNode section)
        {
            List<EventServicePluginDescription> configObject = new List<EventServicePluginDescription>();
            foreach (XmlNode child in section.SelectNodes("add"))
            {
                if (XmlNodeType.Element == child.NodeType)
                {
                    try
                    {
                        configObject.Add(new EventServicePluginDescription(
                            child.Attributes["name"].Value,
                            child.Attributes["type"].Value,
                            child.Attributes["option"].Value));
                    }
                    catch (Exception)
                    {
                        throw new LIVEnException("Invalid configuration entry " + child.ToString());
                    }
                }
            }

            return configObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedPluginCommon\IEventServicePlugin.cs ===
//-------------------------------------------------------------------
// <copyright file="IEventServicePlugin.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Internal interface definition for handling event based service plugin
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.EventBasedService.Common
{
    using System;
    using System.Threading;

    /// <summary>
    /// The IEventServicePlugin defines the interface that
    /// handles and processes notification request internally.
    /// </summary>
    public interface IEventServicePlugin
    {
        /// <summary>
        /// The entry point of the plugin
        /// </summary>
        /// <param name="state">The state object to pass in.  </param>
        void DoWork(object state);

        /// <summary>
        /// This method initializes the plugin. 
        /// </summary>
        /// <param name="parentService">A pointer to the parent service</param>
        /// <param name="stoppingEvent">The signal used to wake a thread</param>
        /// <param name="doneEvent">The singal used to tell the master thread that it is done</param>
        /// <param name="description">The description of the timer. </param>
        /// <param name="componentName">The service component name.</param>
        void Initialize(IEventService parentService, ManualResetEvent stoppingEvent, ManualResetEvent doneEvent, EventServicePluginDescription description, string componentName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedPluginCommon\EventServicePluginDescription.cs ===
//-------------------------------------------------------------------
// <copyright file="EventServicePluginDescription.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Defines the properties of a timer plugin configuration. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.EventBasedService.Common
{
    using System;

    /// <summary>
    /// The class defines the description properties of a timer plugin. 
    /// these fields should be 
    /// </summary>
    public class EventServicePluginDescription
    {
        /// <summary>
        /// Initializes a new instance of the EventServicePluginDescription class. 
        /// </summary>
        /// <param name="name">The name of the plugin. </param>
        /// <param name="type">The provider type string name. </param>
        /// <param name="option">The options for initialize the plugin. </param>
        public EventServicePluginDescription(string name, string type, string option)
        {
            this.DisplayName = name;
            this.Type = type;
            this.Options = option;
        }

        /// <summary>
        /// Gets or sets the display name of the plugin
        /// </summary>
        public string DisplayName { get; set; }

        /// <summary>
        /// Gets or sets the type name of the plugin
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Gets or sets the options to create the plugin. The string should be in xml. 
        /// </summary>
        public string Options { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedPluginCommon\IEventService.cs ===
//-------------------------------------------------------------------
// <copyright file="IEventService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Internal interface definition for Time based service. 
//  This interface defines some methods that the plugins can access. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.EventBasedService.Common
{
    using System;

    /// <summary>
    /// The ITimerService defines the interface that
    /// handles and processes notification request internally.
    /// </summary>
    public interface IEventService
    {
        /// <summary>
        /// Check if the service is stopping. 
        /// </summary>
        /// <returns>bool to indicate if the service is stopping</returns>
        bool IsServiceStopping(); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\EventBasedService\ServiceInstall.cs ===
//-------------------------------------------------------------------
// <copyright file="ServiceInstall.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The ProjectInstaller class. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/29/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService.Internal
{
    using System;
    using System.ComponentModel; 
    using System.Configuration.Install; 
    using System.ServiceModel;
    using System.ServiceProcess;
   
    /// <summary>
    /// Defines the project installer class. This is used to install the service. 
    /// </summary>
    [RunInstaller(true)]
    public class ProjectInstaller : Installer
    {
        /// <summary>
        /// The ServiceProcessInstaller object. 
        /// </summary>
        private ServiceProcessInstaller process;

        /// <summary>
        /// The ServiceInstaller service object. 
        /// </summary>
        private ServiceInstaller service;

        /// <summary>
        /// Initializes a new instance of the ProjectInstaller class. 
        /// </summary>
        public ProjectInstaller()
        {
            this.process = new ServiceProcessInstaller();
            this.process.Account = ServiceAccount.LocalSystem;
            this.service = new ServiceInstaller();
            this.service.ServiceName = "AsyncMultiplayer EventBasedService Service";
            Installers.Add(this.process);
            Installers.Add(this.service);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationAzureStorage\NotificationAzureEntity.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationAzureEntity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  NotificationAzureTableEntity class. Added Azure Table specific properties. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/15/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.Data.Services.Common;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using AsyncMultiplayer.Common.AzureStorage;

    /// <summary>
    /// The wrapper class of notification for using Azure Table Storage. 
    /// The concatnation of PartitionKey and RowKey has to be unique. 
    /// The natural choice for PartitionKey is Target so all the notifications of
    /// one particular user will be on the same partition. 
    /// RowKey is GameId+SessionId+
    /// </summary>
    [Serializable]
    public class NotificationAzureTableEntity : TableStorageEntity
    {
        /// <summary>
        /// Initializes a new instance of the NotificationAzureTableEntity class. 
        /// </summary>
        public NotificationAzureTableEntity()
            : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NotificationAzureTableEntity class based on a notification. 
        /// </summary>
        /// <param name="baseNotification">The base notification object. </param>
        public NotificationAzureTableEntity(Notification baseNotification)
            : this()
        {
            this.PartitionKey = baseNotification.UserId;
            this.RowKey = baseNotification.Id;

            this.Id = baseNotification.Id;
            this.From = baseNotification.From;
            this.UserId = baseNotification.UserId;
            this.Type = (int)baseNotification.Type;
            this.Status = (int)baseNotification.Status;
            this.Category = (int)baseNotification.Category;
            this.GameId = (int)baseNotification.GameId;
            this.Variant = (int)baseNotification.Variant;
            this.SessionId = baseNotification.SessionId;
            this.IsUserVisible = baseNotification.IsUserVisible;
            this.SentTime = baseNotification.SentTime;
            this.DeliveredTime = baseNotification.DeliveredTime;
            this.ExpirationTime = baseNotification.ExpirationTime;
            this.SupportedPlatform = baseNotification.SupportedPlatform;
            this.NotificationString = Notification.SerializeToString(baseNotification);
        }

        #region Copied from Notification.cs
        /// <summary>
        /// Gets or sets notification Id.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Gets or sets the originator of this notification. 
        /// </summary>
        public string From { get; set; }

        /// <summary>
        /// Gets or sets the target of this notification. 
        /// </summary>
        public string UserId { get; set; }

        /// <summary>
        /// Gets or sets notification type.
        /// </summary>
        public int Type { get; set; }

        /// <summary>
        /// Gets or sets notification category. 
        /// </summary>
        public int Category { get; set; }

        /// <summary>
        /// Gets or sets notification status. 
        /// </summary>
        public int Status { get; set; }

        /// <summary>
        /// Gets or sets game Id.
        /// </summary>
        public int GameId { get; set; }

        /// <summary>
        /// Gets or sets game variant. 
        /// </summary>
        public int Variant { get; set; }

        /// <summary>
        /// Gets or sets session Id.
        /// </summary>
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether
        /// the notification is visible to the user.
        /// </summary>
        public bool IsUserVisible { get; set; }

        /// <summary>
        /// Gets or sets sent time of this
        /// notification.
        /// </summary>
        public DateTime SentTime { get; set; }

        /// <summary>
        /// Gets or sets the actual delivery time of 
        /// this notification. 
        /// </summary>
        public DateTime DeliveredTime { get; set; }

        /// <summary>
        /// Gets or sets the expiration time of this
        /// notification. 
        /// </summary>
        public DateTime ExpirationTime { get; set; }

        /// <summary>
        /// Gets or sets supported platform of this
        /// notification.
        /// </summary>
        public int SupportedPlatform { get; set; }

        /// <summary>
        /// Gets or sets the serialized notification object.  
        /// </summary>
        public string NotificationString { get; set; }

        #endregion

        /// <summary>
        /// Check if the notification statisfy the qeury condition. Note this method doesn't validate the queryParameter. 
        /// It simply checks all the conditions presented in the paramter. It is upto whoever constructed the paramter to 
        /// validate the logic. 
        /// </summary>
        /// <param name="queryParameter">The query parameter. </param>
        /// <param name="ignoreUserInfo">Whether should ignore UserInfo. </param>
        /// <returns>true or false. </returns>
        public bool SatisfyQueryParamter(NotificationQueryParameter queryParameter, bool ignoreUserInfo)
        {
            if (!ignoreUserInfo)
            {
                if (!string.IsNullOrEmpty(queryParameter.UserId) &&
                    string.Compare(this.UserId, queryParameter.UserId) != 0)
                {
                    return false;
                }
            }

            // check game Id
            if (queryParameter.GameId != null && queryParameter.GameId != (uint)this.GameId)
            {
                return false;
            }

            // check category
            if (queryParameter.Category != null && queryParameter.Category != this.Category)
            {
                return false;
            }

            // check variant. 
            if (queryParameter.Variant != null && queryParameter.Variant != (uint)this.Variant)
            {
                return false;
            }

            // check session id. 
            if (!string.IsNullOrEmpty(queryParameter.SessionId) &&
                string.Compare(queryParameter.SessionId, this.SessionId) != 0)
            {
                return false;
            }

            // check the type
            if (queryParameter.Type != null && queryParameter.Type != (uint)this.Type)
            {
                return false;
            }

            if (queryParameter.UserVisibleOnly && !this.IsUserVisible)
            {
                return false;
            }

            // Do not return expired messages
            // This was added as a part of SLS Bug 138732
            if (DateTime.UtcNow > this.ExpirationTime)
            {
                return false;
            }

            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationAzureStorage\NotificationAzureStorage.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationAzureStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Azure table based notification storage. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.Globalization;
    using System.Linq;
    using System.Net;
    using AsyncMultiplayer.Common.AzureStorage;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// This class implements a file based notification storage.
    /// </summary>
    public class NotificationAzureStorage : INotificationStorage
    {
        /// <summary>
        /// The format string of NotificationId
        /// </summary>
        public const string IdFormatString = "{0:D19}-{1}";

        /// <summary>
        /// The display name of the component for tracing. 
        /// </summary>
        private const string ComponentName = "NotificationAzureStorage";

        /// <summary>
        /// Initializes a new instance of the NotificationAzureStorage class. 
        /// This class will try to read the account info from the config. 
        /// </summary>
        public NotificationAzureStorage()
            : this(StorageAccountInfo.GetDefaultTableStorageAccountFromConfiguration())
        {
        }

        /// <summary>
        /// Initializes a new instance of the NotificationAzureStorage class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        public NotificationAzureStorage(StorageAccountInfo account)
        {
            this.Account = account;
            this.RetryCount = 3;
        }

        /// <summary>
        /// Initializes a new instance of the NotificationAzureStorage class with proxy setting. 
        /// </summary>
        /// <param name="endPoint">The end point of the table storage.</param>
        /// <param name="account">The Azure storage account. </param>
        /// <param name="token">The token for accessing table storage. </param>
        /// <param name="proxy">The proxy address</param>
        public NotificationAzureStorage(string endPoint, string account, string token, string proxy)
            : this(new StorageAccountInfo(new Uri(endPoint), null, account, token, false))
        {
            this.ProxyAddress = proxy; 
        }

        /// <summary>
        /// Gets or sets the storage account information. 
        /// </summary>
        public StorageAccountInfo Account { get; set; }

        /// <summary>
        /// Gets or sets the retry count to access Azure Storage. 
        /// </summary>
        public int RetryCount { get; set; }

        /// <summary>
        /// Gets or sets the proxy address for the environment. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Initializes the storage for the first time use. 
        /// </summary>
        public
        void
        InitializeStorage()
        {
            TableStorage.CreateTablesFromModel(typeof(NotificationDataServiceContext), this.Account);
        }

        /// <summary>
        /// Query notifications.
        /// User identity is based on the HTTP request cookie or authorization header.
        /// </summary>
        /// <param name="queryParameter">Query parameter.</param>
        /// <returns>Notification entries.</returns>
        public
        NotificationList
        QueryNotifications(NotificationQueryParameter queryParameter)
        {
            Logging.TraceVerbose("{0}: QueryNotifications(): userId= {1}", ComponentName, queryParameter.UserId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;

                NotificationList results = new NotificationList();
                int count = 0;
                IEnumerable<NotificationAzureTableEntity> entityList;

                if (string.IsNullOrEmpty(queryParameter.LastId))
                {
                    entityList = this.GetEntityList(svc, queryParameter.UserId);
                }
                else
                {
                    entityList = this.GetEntityList(svc, queryParameter.UserId, queryParameter.LastId);
                }

                foreach (NotificationAzureTableEntity entity in entityList)
                {
                    // filter the result. Note the result is already sorted. and everything will be older than qeuryParamter.LastId
                    if (entity.SatisfyQueryParamter(queryParameter, true))
                    {
                        Notification.NotificationType type = (Notification.NotificationType)Enum.ToObject(
                            typeof(Notification.NotificationType),
                            entity.Type);

                        try
                        {
                            Notification notification = Notification.DeserializeFromString(entity.NotificationString, type);

                            // NOTE: UserId will not go out the system. 
                            notification.UserId = string.Empty;
                            results.Add(notification);
                            count++;
                            if (count >= queryParameter.Count)
                            {
                                break;
                            }
                        }
                        catch (System.InvalidOperationException ex)
                        {
                            Logging.TraceWarning("{0} {1} {2}", 
                                ComponentName,
                                "Exception in Deserializing notifications: string=" + entity.NotificationString + ", type=" + type,
                                ex.ToString());
                            
                            continue;
                        }
                    }
                }

                return results;
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in QueryNotifications(): userId=" + queryParameter.UserId);  
            }
        }

        /// <summary>
        /// Update the status of the notification. 
        /// </summary>
        /// <param name="userId">The idnetification string of the owner of the notification. </param>
        /// <param name="notificationId">The GUID of the notification. </param>
        /// <param name="status">The new status. </param>
        public
        void
        UpdateNotification(
            string userId,
            string notificationId,
            Notification.NotificationStatus status)
        {
            Logging.TraceVerbose("{0}: {1}", 
                ComponentName, 
                string.Format("UpdateNotification(): userId={0}, notificationid={1}, new status={2}", userId, notificationId, status));

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;

                NotificationAzureTableEntity entity = this.GetEntityById(svc, userId, notificationId);
                if (entity != null)
                {
                    entity.Status = (int)status;

                    // Update is relatively expensive because we need to update the inner object. 
                    Notification.NotificationType type = (Notification.NotificationType)Enum.ToObject(
                        typeof(Notification.NotificationType),
                        entity.Type);

                    try
                    {
                        Notification notification = Notification.DeserializeFromString(entity.NotificationString, type);
                        notification.Status = status;
                        entity.NotificationString = Notification.SerializeToString(notification);
                    }
                    catch (System.InvalidOperationException ex)
                    {
                        Logging.TraceWarning("{0}: {1} {2}",
                                ComponentName,
                                "Exception in Deserializing/Serializing notification: string=" + entity.NotificationString + ", type=" + entity.Type,
                                ex.ToString());

                        return;
                    }

                    svc.Detach(entity);
                    svc.AttachTo(NotificationDataServiceContext.NotificationTableName, entity, "*");
                    svc.UpdateObject(entity);
                    svc.SaveChangesWithRetriesIgnoreNotFound();
                }
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    string.Format("Exception in UpdateNotification(): userId={0}, notificationid={1}, new status={2}", userId, notificationId, status));
            }
        }

        /// <summary>
        /// This method saves a notification to storage.
        /// </summary>
        /// <param name="userId">The identification of the user identity. </param>
        /// <param name="gameId">Game Id of the notification.</param>
        /// <param name="sessionId">Session Id of the notification.</param>
        /// <param name="notification">Notification object.</param>
        /// <returns>Notification Id.</returns>
        public
        string
        SaveNotification(
            string userId,
            uint gameId,
            string sessionId,
            Notification notification)
        {
            Logging.TraceVerbose("{0}: {1} {2}",
                ComponentName,
                string.Format("SaveNotification(): userId={0}, gameId={1}, sessionId={2}, ", userId, gameId, sessionId),
                string.Format(" Notification: Id={0}, From={1}, Type={2}, SentTime={3}", notification.Id, notification.From, notification.Type, notification.SentTime));

            try
            {
                // first validate if all the fields in notification are properly set. 
                NotificationAzureTableEntity entity = new NotificationAzureTableEntity(notification);

                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;

                // check if the entity/notification is already saved
                IEnumerable<NotificationAzureTableEntity> entityList = this.GetEntityList(svc, userId);
                if (entityList.FirstOrDefault(e => e.Id == entity.Id) != null)
                {
                    Logging.TraceWarning("{0}: {1} {2} {3}",
                        ComponentName,
                        "Notification: ",
                        notification.Id,
                        " has already been saved! Skipping duplicate...");

                    return entity.Id;
                }

                // Add the new entity to the table
                svc.AddObject(NotificationDataServiceContext.NotificationTableName, entity);

                bool consolidateSameNtfn = true;
                bool consolidateYourTurn = true;
                if(notification.Type != Notification.NotificationType.Nudge)
                    consolidateYourTurn = false;


                // consolidate existing entity of the same type/game/session
                if (notification.Category != Notification.NotificationCategory.Info)
                {
                    // find the previous one and delete it. 
                    NotificationQueryParameter queryParameterForSameNtfn = new NotificationQueryParameter();
                    queryParameterForSameNtfn.Type = (uint)notification.Type;
                    queryParameterForSameNtfn.GameId = notification.GameId;
                    queryParameterForSameNtfn.SessionId = notification.SessionId;


                    NotificationQueryParameter queryParameterForYourTurnNtfn = new NotificationQueryParameter();
                    queryParameterForYourTurnNtfn.Type = (uint)Notification.NotificationType.YourTurn;
                    queryParameterForYourTurnNtfn.GameId = notification.GameId;
                    queryParameterForYourTurnNtfn.SessionId = notification.SessionId;

                    foreach (NotificationAzureTableEntity existEntity in entityList)
                    {
                        if (consolidateSameNtfn)
                        {
                            if (existEntity.SatisfyQueryParamter(queryParameterForSameNtfn, true))
                            {
                                svc.DeleteObject(existEntity);
                                consolidateSameNtfn = false;
                            }
                        }
                        if (consolidateYourTurn)
                        {
                            if (existEntity.SatisfyQueryParamter(queryParameterForYourTurnNtfn, true))
                            {
                                svc.DeleteObject(existEntity);
                                consolidateYourTurn = false;
                            }
                        }
                        if (!consolidateSameNtfn && !consolidateYourTurn)
                        {
                            break;
                        }
                    }
                }

                // BUGBUG: 
                // There is a bug in the storage client. The batch option doesn't include required
                // x-ms-version: 2009-04-14 in the header. This should be fixed once the storageclient
                // is updated. 
                // svc.SaveChangesWithRetries(SaveChangesOptions.Batch);
                // without specifying the SaveChangeOptions, there will be one request for each change. 
                svc.SaveChangesWithRetriesIgnoreNotFound();
                return notification.Id;
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    string.Format("Exception in SaveNotification(): userId={0}, gameId={1}, sessionId={2}, notification={3}", userId, gameId, sessionId, notification.Id));
            }
        }

        /// <summary>
        /// Method to delete all notification of a user. 
        /// </summary>
        /// <param name="userId">The user id. </param>
        public
        void
        DeleteNotification(
            string userId)
        {
            Logging.TraceVerbose("{0} {1}", ComponentName, "DeleteNotification() with userId=" + userId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress; 

                IEnumerable<NotificationAzureTableEntity> res = this.GetEntityList(svc, userId);
                foreach (NotificationAzureTableEntity entity in res)
                {
                    svc.DeleteObject(entity);
                }

                svc.SaveChangesWithRetriesIgnoreNotFound(SaveChangesOptions.ContinueOnError);
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in DeleteNotification: userId=" + userId);
            }
        }

        /// <summary>
        /// This method deletes a notification from storage.
        /// </summary>
        /// <param name="userId">The identification of the user identity. </param>
        /// <param name="notificationId">Notificaiton Id.</param>
        public
        void
        DeleteNotification(
            string userId,
            string notificationId)
        {
          Logging.TraceVerbose("{0}: {1}",
                ComponentName,
                string.Format("DeleteNotification(): userId={0}, notificationId={1}", userId, notificationId));

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress; 

                NotificationAzureTableEntity entity = this.GetEntityById(svc, userId, notificationId);
                if (entity != null)
                {
                    svc.DeleteObject(entity);
                }

                // the reason this entity might not found is because someone else could have deleted
                // the object. 
                svc.SaveChangesWithRetriesIgnoreNotFound(SaveChangesOptions.ContinueOnError);
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    string.Format("Exception in DeleteNotification: userId={0}, notificationId={1}", userId, notificationId));
            }
        }

        /// <summary>
        /// This method deletes notifications of a session from storage.
        /// </summary>
        /// <param name="userId">The identification of the user. </param>
        /// <param name="gameId">The identification of the game. </param>
        /// <param name="sessionId">The identification of the session. </param>
        public
        void
        DeleteNotificationBySession(
            string userId,
            uint gameId,
            string sessionId)
        {
            Logging.TraceVerbose("{0} {1}",
                ComponentName,
                string.Format("DeleteNotificationBySession(): userId={0}, gameId={1}, sessionId={2}", userId, gameId, sessionId));

            NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
            svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
            svc.ProxyAddress = this.ProxyAddress;
            IEnumerable<NotificationAzureTableEntity> res = this.GetEntityList(svc, userId, gameId, sessionId);
            foreach (NotificationAzureTableEntity entity in res)
            {
                svc.DeleteObject(entity);
            }

            svc.SaveChangesWithRetriesIgnoreNotFound(SaveChangesOptions.ContinueOnError); 
        }

        /// <summary>
        /// Delete the notifications based on the query parameter. 
        /// </summary>
        /// <param name="userId">The id of the user. </param>
        /// <param name="queryParameter">The query parameter. </param>
        public
        void
        DeleteNotification(string userId, NotificationQueryParameter queryParameter)
        {
            Logging.TraceVerbose("{0} {1}",
                ComponentName,
                string.Format("DeleteNotification(): userId={0}, QueryParameter: gameId={1}, sessionId={2}", userId, queryParameter.GameId, queryParameter.SessionId));

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;
                IEnumerable<NotificationAzureTableEntity> res = this.GetEntityList(svc, userId);
                foreach (NotificationAzureTableEntity entity in res)
                {
                    if (entity.SatisfyQueryParamter(queryParameter, true))
                    {
                        svc.DeleteObject(entity);
                    }
                }

                svc.SaveChangesWithRetriesIgnoreNotFound(SaveChangesOptions.ContinueOnError);
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    string.Format("Exception in DeleteNotification: userId={0}, QueryParameter: gameId={1}, sessionId={2}", userId, queryParameter.GameId, queryParameter.SessionId));
            }
        }

        /// <summary>
        /// Get the preformatted Exception text. 
        /// </summary>
        /// <param name="exception">The exception object. </param>
        /// <returns>The exception message. </returns>
        private static string GetExceptionMessage(Exception exception)
        {
            HttpStatusCode statusCode;
            StorageExtendedErrorInformation extendedErrorInfo;
            if (TableStorageHelpers.EvaluateException(exception, out statusCode, out extendedErrorInfo))
            {
                if (extendedErrorInfo != null)
                {
                    return string.Format(CultureInfo.InvariantCulture, "{0} {1}", extendedErrorInfo.ErrorCode ?? string.Empty, extendedErrorInfo.ErrorMessage ?? string.Empty);
                }
            }

            DataServiceClientException dse = exception.InnerException as DataServiceClientException;
            if (dse != null)
            {
                return dse.Message;
            }
            else
            {
                return exception.Message;
            }
        }

        /// <summary>
        /// A private helper method to get an entity based on ID. The ID is the row key. 
        /// </summary>
        /// <param name="svc">The service context object. </param>
        /// <param name="userId">The user identification. Part of the partition key. </param>
        /// <param name="notificationId">The notification Id. Row Key. </param>
        /// <returns>The entity if found. </returns>
        private NotificationAzureTableEntity GetEntityById(
            NotificationDataServiceContext svc,
            string userId,
            string notificationId)
        {
            Logging.TraceVerbose("{0} {1}",
                ComponentName,
                string.Format("GetEntityById(): svc={0}, userId={1}, notificationId={2}", svc.GetHashCode(), userId, notificationId));

            var queryResult = from c in svc.AsyncNotificationTable
                              where c.PartitionKey == userId
                              && c.RowKey == notificationId
                              select c;

            TableStorageDataServiceQuery<NotificationAzureTableEntity> query =
                new TableStorageDataServiceQuery<NotificationAzureTableEntity>(queryResult as DataServiceQuery<NotificationAzureTableEntity>, svc.RetryPolicy);

            try
            {
                IEnumerable<NotificationAzureTableEntity> results = query.ExecuteWithRetries();
                return results.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                OperationResponse response = ex.Response;
                if (response.StatusCode == (int)HttpStatusCode.NotFound)
                {
                    return null;
                }
                else
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// A private helper method to get a list of entities based on userId. 
        /// </summary>
        /// <param name="svc">The service context object. </param>
        /// <param name="userId">The user identification. </param>
        /// <returns>A numerable of entities. </returns>
        private IEnumerable<NotificationAzureTableEntity> GetEntityList(
            NotificationDataServiceContext svc,
            string userId)
        {
            Logging.TraceVerbose("{0} {1}",
                ComponentName,
                string.Format("GetEntityById(): svc={0}, userId={1}", svc.GetHashCode(), userId));

            var queryResult = from c in svc.AsyncNotificationTable
                              where c.PartitionKey == userId &&
                                    c.ExpirationTime >= DateTime.UtcNow
                              select c;

            TableStorageDataServiceQuery<NotificationAzureTableEntity> query =
                new TableStorageDataServiceQuery<NotificationAzureTableEntity>(queryResult as DataServiceQuery<NotificationAzureTableEntity>, svc.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<NotificationAzureTableEntity> res = query.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// A private helper method to get a list of entities based on userId and the minimum timestamp. 
        /// </summary>
        /// <param name="svc">The servicecontext object. </param>
        /// <param name="userId">The user identification. </param>
        /// <param name="lastId">The notification id as the last received. </param>
        /// <returns>A numberable collection of entities. </returns>
        private IEnumerable<NotificationAzureTableEntity> GetEntityList(
            NotificationDataServiceContext svc,
            string userId,
            string lastId)
        {
            Logging.TraceVerbose("{0} {1}",
                ComponentName,
                string.Format("GetEntityById(): svc={0}, userId={1}, lastId={2}", svc.GetHashCode(), userId, lastId));

            var queryResult = from c in svc.AsyncNotificationTable
                              where c.PartitionKey == userId &&
                                    c.ExpirationTime >= DateTime.UtcNow &&
                                    string.Compare(c.RowKey, lastId) > 0
                              select c;

            TableStorageDataServiceQuery<NotificationAzureTableEntity> query =
                new TableStorageDataServiceQuery<NotificationAzureTableEntity>(queryResult as DataServiceQuery<NotificationAzureTableEntity>, svc.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<NotificationAzureTableEntity> res = query.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// This method gets all the notifications of a user for a particular session.
        /// </summary>
        /// <param name="svc">The data service context to use.</param>
        /// <param name="userId">The identification of the user.</param>
        /// <param name="gameId">The identification of the game.</param>
        /// <param name="sessionId">The identification of the session.</param>
        /// <returns>An enumerable collection of notification entities.</returns>
        private IEnumerable<NotificationAzureTableEntity> GetEntityList(NotificationDataServiceContext svc, string userId, uint gameId, string sessionId)
        {
            var queryResult = from c in svc.AsyncNotificationTable
                              where c.PartitionKey.Equals(userId) &&
                                    c.SessionId.Equals(sessionId) &&
                                    c.GameId == (int)gameId &&
                                    c.ExpirationTime >= DateTime.UtcNow
                              select c;

            TableStorageDataServiceQuery<NotificationAzureTableEntity> query =
                new TableStorageDataServiceQuery<NotificationAzureTableEntity>(queryResult as DataServiceQuery<NotificationAzureTableEntity>, svc.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<NotificationAzureTableEntity> res = query.ExecuteAllWithRetries();
            return res;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationAzureStorage\UserDataAzureStorage.cs ===
//-------------------------------------------------------------------
// <copyright file="UserDataAzureStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Azure table based user data
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.Globalization;
    using System.Linq;
    using System.Net;
    using AsyncMultiplayer.Common.AzureStorage;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// This class implements a file based notification storage.
    /// </summary>
    public class UserDataAzureStorage
    {
        /// <summary>
        /// The display name of the component for tracing. 
        /// </summary>
        private const string ComponentName = "UserDataAzureStorage";

        /// <summary>
        /// Initializes a new instance of the UserDataAzureStorage class. 
        /// This class will try to read the account info from the config. 
        /// </summary>
        public UserDataAzureStorage()
            : this(StorageAccountInfo.GetDefaultTableStorageAccountFromConfiguration())
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserDataAzureStorage class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        public UserDataAzureStorage(StorageAccountInfo account)
        {
            this.Account = account;
            this.RetryCount = 3;
        }

        /// <summary>
        /// Initializes a new instance of the UserDataAzureStorage class. 
        /// </summary>
        /// <param name="endPoint">The end point of the table storage.</param>
        /// <param name="account">The Azure storage account. </param>
        /// <param name="token">The token for accessing table storage. </param>
        public UserDataAzureStorage(string endPoint, string account, string token)
            : this(new StorageAccountInfo(new Uri(endPoint), null, account, token, false))
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserDataAzureStorage class. 
        /// </summary>
        /// <param name="endPoint">The end point of the table storage.</param>
        /// <param name="account">The Azure storage account. </param>
        /// <param name="token">The token for accessing table storage. </param>
        /// <param name="proxy">The proxy setting for the environment. </param>
        public UserDataAzureStorage(string endPoint, string account, string token, string proxy)
            : this(endPoint, account, token)
        {
            this.ProxyAddress = proxy; 
        }

        /// <summary>
        /// Gets or sets the storage account information. 
        /// </summary>
        public StorageAccountInfo Account { get; set; }

        /// <summary>
        /// Gets or sets the retry count to access Azure Storage. 
        /// </summary>
        public int RetryCount { get; set; }

        /// <summary>
        /// Gets or sets the proxy address for the environment. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Initializes the storage for the first time use. 
        /// </summary>
        public
        void
        InitializeStorage()
        {
            TableStorage.CreateTablesFromModel(typeof(NotificationDataServiceContext), this.Account);
        }

        /// <summary>
        /// Get a user data object from the storage. 
        /// </summary>
        /// <param name="userId">The ID of the user data. </param>
        /// <returns>Userdata object if exists. </returns>
        public
        UserData
        GetUserData(string userId)
        {
            Logging.TraceVerbose("{0}: GetUserData(): userId={1}", ComponentName, userId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;
                UserDataAzureEntity entity = this.GetUserDataEntityById(svc, userId);
                if (entity != null)
                {
                    return entity.CreateUserDataFromEntity();
                }
                else
                {
                    return null;
                }
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in GetUserData(): userId=" + userId);
            }
        }

        /// <summary>
        /// Update the time stamp of UserData in storage. 
        /// </summary>
        /// <param name="userId">The id of the user. </param>
        public
        void
        UpdateUserDataTimeStamp(string userId)
        {
            Logging.TraceVerbose("{0}: UpdateUserDataTimeStamp(): userId= {1}", ComponentName, userId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;
                UserDataAzureEntity entity = null;
                bool created = this.GetOrCreateUserDataEntityById(svc, userId, out entity);

                // by now the entity should have existed
                // do an unconditional update if we didn't just create one. 
                if (!created && entity != null)
                {
                    svc.Detach(entity);
                    svc.AttachTo(NotificationDataServiceContext.UserDataTableName, entity, "*");
                    entity.LastUpdateTime = DateTime.UtcNow;
                    svc.UpdateObject(entity);
                    svc.SaveChangesWithRetries();
                }
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in UpdateUserDataTimeStamp(): userId=" + userId);
            }
        }

        /// <summary>
        /// Reset the invite count and associcated timestamp. 
        /// </summary>
        /// <param name="userId">The id of the user. </param>
        public
        void
        ResetUserDataInivteCount(string userId)
        {
            Logging.TraceVerbose("{0}: ResetUserDataInivteCount(): userId= {1}", ComponentName, userId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;
                UserDataAzureEntity entity = null;
                bool created = this.GetOrCreateUserDataEntityById(svc, userId, out entity);

                // by now the entity should have existed
                // do an unconditional update if we didn't just create one. 
                if (!created && entity != null)
                {
                    svc.Detach(entity);
                    svc.AttachTo(NotificationDataServiceContext.UserDataTableName, entity, "*");
                    entity.InviteCount = 0;
                    entity.LastInviteResetTime = DateTime.UtcNow;
                    svc.UpdateObject(entity);
                    svc.SaveChangesWithRetries();
                }
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in ResetUserDataInivteCount(): userId=" + userId);
            }
        }

        /// <summary>
        /// Update the UserData in storage. 
        /// </summary>
        /// <param name="userData">The new user data object. </param>
        public
        void
        UpdateUserData(UserData userData)
        {
            Logging.TraceVerbose("{0}: UpdateUserData(): userId= {1}", ComponentName, userData.UserId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                svc.ProxyAddress = this.ProxyAddress;
                UserDataAzureEntity entity = null;
                bool created = this.GetOrCreateUserDataEntity(svc, userData, out entity);

                // by now the entity should have existed
                // do an unconditional update
                if (!created && entity != null)
                {
                    svc.Detach(entity);
                    svc.AttachTo(NotificationDataServiceContext.UserDataTableName, entity, "*");
                    entity.CopyData(userData);
                    svc.UpdateObject(entity);
                    svc.SaveChangesWithRetries();
                }
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in UpdateUserData(): userId=" + userData.UserId);
            }
        }

        /// <summary>
        /// Method to delete a user from user data table. 
        /// </summary>
        /// <param name="userId">The user id. </param>
        public
        void
        DeleteUserData(
            string userId)
        {
            Logging.TraceVerbose("{0}:DeleteUserData(): userId= {1}", ComponentName, userId);

            try
            {
                NotificationDataServiceContext svc = new NotificationDataServiceContext(this.Account);
                svc.ProxyAddress = this.ProxyAddress;
                svc.RetryPolicy = RetryPolicies.RetryN(this.RetryCount, TimeSpan.FromSeconds(1));
                UserDataAzureEntity entity = this.GetUserDataEntityById(svc, userId);
                if (entity != null)
                {
                    svc.DeleteObject(entity);
                    svc.SaveChangesWithRetries();
                }
            }
            catch (Exception ex)
            {
                // log an event for error consolidation and monitoring
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AzureStorageAccessFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    "Exception in DeleteUserData(): userId=" + userId);
            }
        }

        /// <summary>
        /// Get the preformatted Exception text. 
        /// </summary>
        /// <param name="exception">The exception object. </param>
        /// <returns>The exception message. </returns>
        private static string GetExceptionMessage(Exception exception)
        {
            HttpStatusCode statusCode;
            StorageExtendedErrorInformation extendedErrorInfo;
            if (TableStorageHelpers.EvaluateException(exception, out statusCode, out extendedErrorInfo))
            {
                if (extendedErrorInfo != null)
                {
                    return string.Format(CultureInfo.InvariantCulture, "{0} {1}", extendedErrorInfo.ErrorCode ?? string.Empty, extendedErrorInfo.ErrorMessage ?? string.Empty);
                }
            }

            DataServiceClientException dse = exception.InnerException as DataServiceClientException;
            if (dse != null)
            {
                return dse.Message;
            }
            else
            {
                return exception.Message;
            }
        }


        /// <summary>
        ///  Get or create user data entity in the storage based on userId
        /// </summary>
        /// <param name="svc"></param>
        /// <param name="userId"></param>
        /// <param name="entity"></param>
        /// <returns></returns>
        private bool GetOrCreateUserDataEntityById(
            NotificationDataServiceContext svc,
            string  userId,
            out UserDataAzureEntity entity)
        {
            UserData userData = new UserData(userId);
            return GetOrCreateUserDataEntity(svc, userData, out entity);

        }

        /// <summary>
        /// Get or create user data entity in the storage. 
        /// </summary>
        /// <param name="svc">DataServiceConext used to access the storage. </param>
        /// <param name="userData"></param>
        /// <param name="entity">The out paramater to return the id. </param>
        /// <returns>Whether a new entity has been created. </returns>
        private bool GetOrCreateUserDataEntity(
            NotificationDataServiceContext svc,
            UserData userData,
            out UserDataAzureEntity entity)
        {
            bool created = false;
            entity = this.GetUserDataEntityById(svc, userData.UserId);
            if (entity == null)
            {
                try
                {
                    entity = new UserDataAzureEntity(userData);
                    svc.AddObject(NotificationDataServiceContext.UserDataTableName, entity);
                    svc.SaveChangesWithRetries();
                    created = true;
                }
                catch (DataServiceRequestException ex)
                {
                    OperationResponse response = ex.Response.FirstOrDefault();
                    if (response.StatusCode == (int)HttpStatusCode.Conflict)
                    {
                        // someone else has created the entry, just get it again. 
                        svc.Detach(entity);
                        entity = this.GetUserDataEntityById(svc, userData.UserId);
                    }
                    else
                    {
                        throw;
                    }
                }
            }

            return created;
        }

        /// <summary>
        /// A private helper method to get an entity based on ID. The ID is the row key. 
        /// </summary>
        /// <param name="svc">The service context object. </param>
        /// <param name="userId">The user identification. Part of the partition key. </param>
        /// <returns>The entity if found. </returns>
        private UserDataAzureEntity GetUserDataEntityById(
            NotificationDataServiceContext svc,
            string userId)
        {
            var queryResult = from c in svc.UserDataTable
                              where c.PartitionKey == userId && c.RowKey == userId
                              select c;

            TableStorageDataServiceQuery<UserDataAzureEntity> query =
                new TableStorageDataServiceQuery<UserDataAzureEntity>(queryResult as DataServiceQuery<UserDataAzureEntity>, svc.RetryPolicy);

            try
            {
                IEnumerable<UserDataAzureEntity> results = query.ExecuteWithRetries();
                return results.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                OperationResponse response = ex.Response;
                if (response.StatusCode == (int)HttpStatusCode.NotFound)
                {
                    return null;
                }
                else
                {
                    throw;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationAzureStorage\UserDataAzureEntity.cs ===
//-------------------------------------------------------------------
// <copyright file="UserDataAzureEntity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Entity used to save user settings, configs in Azure table. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/15/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using AsyncMultiplayer.Common.AzureStorage;

    /// <summary>
    /// The partition key is user id. Row key is not used. Each user data is a row. 
    /// </summary>
    [Serializable]
    public class UserDataAzureEntity : TableStorageEntity
    {
        /// <summary>
        /// Initializes a new instance of the UserDataAzureEntity class. 
        /// </summary>
        public UserDataAzureEntity()
            : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserDataAzureEntity class. 
        /// </summary>
        /// <param name="userData">The user data. </param>
        public UserDataAzureEntity(UserData userData)
            : this()
        {
            this.CopyData(userData);
        }

        /// <summary>
        /// Gets or sets the time stamp of the last time when the user's storage is updated.
        /// </summary>
        public DateTime LastUpdateTime { get; set; }

        /// <summary>
        /// Gets or sets the time when the last invite request is sent through public front end. 
        /// </summary>
        public DateTime LastInviteResetTime { get; set; }

        /// <summary>
        /// Gets or sets the number of invite sent since last time the count was reset. 
        /// This counter will reset based on the current time and LastInviteTime. 
        /// </summary>
        public int InviteCount { get; set; }

        /// <summary>
        /// Gets or sets the URL for mobile push. 
        /// </summary>
        public string PushUrl { get; set; }

        /// <summary>
        /// Key that uniquely identifies the Push Url
        /// </summary>
        public string PushUrlKey { get; set; }

        /// <summary>
        /// Subsciption Type associated with Push Url
        /// </summary>
        public string SubTypes { get; set; }


        /// <summary>
        /// Subsciption Type associated with Push Url
        /// </summary>
        public string PushLocale { get; set; }

        /// <summary>
        /// Copy the data from a userdata object. 
        /// </summary>
        /// <param name="userData">The user data object. </param>
        public void CopyData(UserData userData)
        {
            this.PartitionKey = userData.UserId;
            this.RowKey = userData.UserId;
            this.LastInviteResetTime = userData.LastInviteResetTime;
            this.LastUpdateTime = userData.LastUpdateTime;
            this.InviteCount = userData.InviteCount;
            this.PushUrl = userData.Push.Url;
            this.PushUrlKey = userData.Push.UrlKey;
            this.SubTypes = userData.Push.SubTypes;
            this.PushLocale = userData.Push.Locale;
        }

        /// <summary>
        /// Create a UserData object from the entity. 
        /// </summary>
        /// <returns>A user data object created from the entity.</returns>
        public UserData CreateUserDataFromEntity()
        {
            UserData userData = new UserData(PartitionKey);
            userData.LastUpdateTime = LastUpdateTime;
            userData.InviteCount = InviteCount;
            userData.LastInviteResetTime = LastInviteResetTime;
            userData.Push.Url = PushUrl;
            userData.Push.UrlKey = PushUrlKey;
            userData.Push.SubTypes = SubTypes;
            userData.Push.Locale = PushLocale;
            return userData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationAzureStorage\NotificationDataServiceContext.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationDataServiceContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Azure table storage dataservice context. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Data.Services.Client;
    using System.Data.Services.Common;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.ServiceModel.Web;
    using System.Text;
    using System.Xml.Serialization;
    using AsyncMultiplayer.Common.AzureStorage;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    /// <summary>
    /// DataServiceContext for Azure Table Storage Access. This is a helper class mostly used 
    /// To get NotificationTable. 
    /// </summary>
    public class NotificationDataServiceContext : TableStorageDataServiceContext
    {
        /// <summary>
        /// The name of the table used to save the notifications in Azure Table. 
        /// </summary>
        public const string NotificationTableName = "AsyncNotificationTable";

        /// <summary>
        /// The name of the table used to save user settings, counters etc. 
        /// </summary>
        public const string UserDataTableName = "UserDataTable";

        /// <summary>
        /// Initializes a new instance of the NotificationDataServiceContext class based on the accountInfo. 
        /// </summary>
        /// <param name="accountInfo">The account information. </param>
        public NotificationDataServiceContext(StorageAccountInfo accountInfo)
            : base(accountInfo)
        {
            SendingRequest += new EventHandler<SendingRequestEventArgs>(this.SetProxy);
            this.ResolveType = this.ResolveEntityType;
        }

        /// <summary>
        /// Gets or sets the porxy address. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Gets the user data list. 
        /// </summary>
        public IQueryable<UserDataAzureEntity> UserDataTable
        {
            get
            {
                return this.CreateQuery<UserDataAzureEntity>(UserDataTableName);
            }
        }

        /// <summary>
        /// Gets NotificationTable object list.  
        /// </summary>
        public IQueryable<NotificationAzureTableEntity> AsyncNotificationTable
        {
            get
            {
                return this.CreateQuery<NotificationAzureTableEntity>(NotificationTableName);
            }
        }

        /// <summary>
        /// Save the changes with retries but ignore NotFound Exception. 
        /// </summary>
        public void SaveChangesWithRetriesIgnoreNotFound()
        {
            this.SaveChangesWithRetriesIgnoreNotFound(SaveChangesOptions.None); 
        }

        /// <summary>
        /// Save the changes with retries but ignore NotFound Exception. 
        /// </summary>
        /// <param name="options">The option of save changes. </param>
        public void SaveChangesWithRetriesIgnoreNotFound(SaveChangesOptions options)
        {
            try
            {
                this.SaveChangesWithRetries(options);
            }
            catch (DataServiceRequestException ex)
            {
                OperationResponse response = ex.Response.FirstOrDefault();
                if (response.StatusCode != (int)HttpStatusCode.NotFound)
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Delegate to return entity type for more efficient handling than default by reflection. 
        /// </summary>
        /// <param name="name">The qualified name of the table. </param>
        /// <returns>The type of an entity in the table.</returns>
        public Type ResolveEntityType(string name)
        {
            if (name.EndsWith(UserDataTableName))
            {
                return typeof(UserDataAzureEntity);
            }
            else
            {
                return typeof(NotificationAzureTableEntity);
            }
        }

        /// <summary>
        /// Callback method called whenever a request is sent to the table service. This 
        /// is where the signing of the request takes place. This method is chained with 
        /// whatever is set in base class. 
        /// </summary>
        /// <param name="sender">The sender of the callback method. </param>
        /// <param name="e">The callback args. </param>
        private void SetProxy(object sender, SendingRequestEventArgs e)
        {
            if (!string.IsNullOrEmpty(this.ProxyAddress))
            {
                HttpWebRequest request = e.Request as HttpWebRequest;
                request.Proxy = new WebProxy(this.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationAzureStorage.Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Main cs file for testing Notification Azure Storage. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/22/2009">
//     Class created
// </history>
// <history date="11/25/2009">
//     updated to read from feed.xml - HughV
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Xml;
    using System.Xml.Linq;

    using AsyncMultiplayer.Common.AzureStorage;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            string userId = @"LIVEnSpotlight";
            string sessionId = "My first session";
            uint gameId = 100;

            // load before clearing data
            // if there is no file or the file is formatted incorrectly it will throw (intentionally)
            List<SpotLightNotification> notifications = LoadFeed(userId);

            StorageAccountInfo account = StorageAccountInfo.GetDefaultTableStorageAccountFromConfiguration();
            NotificationAzureStorage storage = new NotificationAzureStorage(account);
            UserDataAzureStorage userDataStorage = new UserDataAzureStorage(account);
          
            //// Console.WriteLine(" First create the tables if it doesn't exist");
            //// storage.InitializeStorage();
             storage.DeleteNotification(userId); 
             ////userDataStorage.DeleteUserData(userId); 

            foreach (SpotLightNotification spotlight in notifications)
            {
                storage.SaveNotification(userId, spotlight.GameId, spotlight.SessionId, spotlight);
            }

            userDataStorage.UpdateUserDataTimeStamp(userId);

            userId = @"bvttest";
            sessionId = "My first session";
            gameId = 100;
            storage.DeleteNotification(userId); 

            MessageWaitingNotification waitnotification = new MessageWaitingNotification();
            waitnotification.SupportedPlatform = (int)Notification.Platform.Web;
            waitnotification.Count = 2;
            waitnotification.GameId = gameId;
            waitnotification.SessionId = sessionId; 
            waitnotification.UserId = userId;
            storage.SaveNotification(waitnotification.UserId, gameId, sessionId, waitnotification);

            WarningNotification warnNotification = new WarningNotification();
            warnNotification.UserId = userId;
            warnNotification.GameId = gameId;
            warnNotification.SessionId = sessionId;
            storage.SaveNotification(warnNotification.UserId, gameId, sessionId, warnNotification);

            // this is to see the consolidated effect. There should only have on MessageWiatingNotification. 
            MessageWaitingNotification waitnotification2 = new MessageWaitingNotification();
            waitnotification2.SupportedPlatform = (int)Notification.Platform.Web;
            waitnotification2.Count = 3;
            waitnotification2.UserId = userId;
            waitnotification2.GameId = gameId;
            waitnotification2.SessionId = sessionId; 
            storage.SaveNotification(waitnotification.UserId, gameId, sessionId, waitnotification2);
            userDataStorage.UpdateUserDataTimeStamp(userId);

            Notification youwinNotification = new YouWinNotification();
            youwinNotification.SupportedPlatform = (int)Notification.Platform.Web;
            youwinNotification.UserId = userId;
            youwinNotification.GameId = gameId;
            youwinNotification.SessionId = sessionId;

            // save the notification
            storage.SaveNotification(youwinNotification.UserId, gameId, sessionId, youwinNotification);
            userDataStorage.UpdateUserDataTimeStamp(userId); 

            // this operation should fail
            try
            {
                storage.UpdateNotification(userId, waitnotification.Id, Notification.NotificationStatus.Viewed);
            }
            catch
            {
            }

            // query the notification
            NotificationQueryParameter queryParameter = new NotificationQueryParameter();
            queryParameter.Count = 50; 
            queryParameter.UserId = userId;
            NotificationList mylist = storage.QueryNotifications(queryParameter);

            // update one notification
            storage.UpdateNotification(userId, mylist[0].Id, Notification.NotificationStatus.Viewed);

            // delete the notification
            storage.DeleteNotification(userId, mylist[0].Id);
            storage.DeleteNotificationBySession(userId, gameId, sessionId);

            // validate nothing left
            mylist = storage.QueryNotifications(queryParameter);
            Console.WriteLine("There are {0} notifications ", mylist.Count());
        }

        /// <summary>Helper to load xml file</summary>
        /// <param name="userId">the user id</param>
        /// <returns>a list of notifications deserialized from feed.xml</returns>
        private static List<SpotLightNotification> LoadFeed(string userId)
        {
            const string FILE = @"feed.xml";

            List<SpotLightNotification> notifications = new List<SpotLightNotification>();

            // find file on disk
            FileInfo fi = new FileInfo(FILE);

#if DEBUG
            // code might be running from bin\debug so look up 2 levels
            if (!fi.Exists)
            {
                fi = new FileInfo(@"..\..\" + FILE);
            }

#endif
            // load and parse XML
            XDocument doc = XDocument.Load(fi.FullName);
            XElement element = GetFirst(doc.Elements());

            foreach (XElement spotlight in element.Elements())
            {
                string title = spotlight.Element("Title").Value;
                string subTitle = spotlight.Element("Subtitle").Value;
                string url = spotlight.Element("Url").Value;
                string gameId = spotlight.Element("GameId").Value;
                uint dwGameId = string.IsNullOrEmpty(gameId) ? 0 : uint.Parse(gameId);

                SpotLightNotification notification = new SpotLightNotification(title, subTitle, url)
                                                         {
                                                             UserId = userId,
                                                             GameId = dwGameId,
                                                             From = "Xbox Spotlight",
                                                             SessionId = string.Empty
                                                         };

                notifications.Add(notification);
            }

            return notifications;
        }

        /// <summary>get the first element in a collection</summary>
        /// <param name="elements">the collection</param>
        /// <returns>the first element</returns>
        private static XElement GetFirst(IEnumerable<XElement> elements)
        {
            XElement element = null;

            foreach (XElement temp in elements)
            {
                // grab the first element
                element = temp;
                break;
            }

            if (null == element)
            {
                throw new XmlException("XML is malformed");
            }

            return element;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\BeaconNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="BeaconNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="micole">
//     Michael Cole
// </author>
//
// <summary>
//  BeaconNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/02/2011">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold Beacon notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "BeaconNotification")]
    public class BeaconNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the BeaconNotification class.
        /// </summary>
        public BeaconNotification()
            : base()
        {
            this.Type = NotificationType.Beacon;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\FriendRequestNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="FriendRequestNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  FriendRequestNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold FriendRequest notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "FriendRequestNotification")]
    public class FriendRequestNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the FriendRequestNotification class.
        /// </summary>
        public FriendRequestNotification()
            : base()
        {
            this.Type = NotificationType.FriendRequest;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }

        /// <summary>
        /// Gets or sets a value indicating whether a friend request is present. 
        /// </summary>
        public bool FriendRequestPresent { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether a XBL message is present. 
        /// </summary>
        public bool MessageWaiting { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\INotificationProvider.cs ===
//-------------------------------------------------------------------
// <copyright file="INotificationProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Internal interface definition for handling notification request
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/11/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;

    /// <summary>
    /// The INotificationProvider defines the interface that
    /// handles and processes notification request internally.
    /// </summary>
    public interface INotificationProvider
    {
        /// <summary>
        /// This method processes one notification request.
        /// </summary>
        /// <param name="notificationRequest">Notification request object.</param>
        void
        ProcessNotificationRequest(NotificationRequest notificationRequest);

        /// <summary>
        /// This method initializes the provider. 
        /// </summary>
        void
        Initialize(); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\INotificationRequest.cs ===
//-------------------------------------------------------------------
// <copyright file="INotificationRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Internal interface definition for notification request
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;

    /// <summary>
    /// The INotificationRequest defines the interface that
    /// supports creation of a notification request.
    /// </summary>
    public interface INotificationRequest
    {
        /// <summary>
        /// This method sends a notification request.
        /// </summary>
        /// <param name="notificationRequest">Notification request object.</param>
        void
        SendNotificationRequest(NotificationRequest notificationRequest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\GameTieNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="GameTieNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  GameTieNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold GameOver notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "GameTieNotification")]
    public class GameTieNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the GameTieNotification class.
        /// </summary>
        public GameTieNotification()
            : base()
        {
            this.Type = NotificationType.GameTie;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\GameOverNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="GameOverNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  GameOverNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold GameOver notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "GameOverNotification")]
    public class GameOverNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the GameOverNotification class.
        /// </summary>
        public GameOverNotification()
            : base()
        {
            this.Type = NotificationType.GameOver;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\InviteRequest.cs ===
//-------------------------------------------------------------------
// <copyright file="InviteRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  InviteRequest class used for SendInvite 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/20/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Class to hold invite request data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [Serializable]
    [DataContract(Name = "InviteRequest")]
    public class InviteRequest
    {
        /// <summary>
        /// Initializes a new instance of the InviteRequest class. 
        /// </summary>
        public InviteRequest()
        {
        }

        /// <summary>
        /// Gets or sets the recipients
        /// </summary>
        [DataMember(IsRequired = true)]
        public string Recipients { get; set; }

        /// <summary>
        /// Gets or sets the game id of the invite. 
        /// </summary>
        [DataMember(IsRequired = true)]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the session id of the invite. 
        /// </summary>
        [DataMember(IsRequired = true)]
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets message date 
        /// </summary>
        [DataMember]
        public string Data { get; set; }

        /// <summary>
        /// Gets or sets the optional FriendRequest
        /// </summary>
        [DataMember(Order = 1)]
        public bool FriendRequest { get; set; }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\INotificationStorage.cs ===
//-------------------------------------------------------------------
// <copyright file="INotificationStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Internal interface definition for notificaiton Storage
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// The INotificationStorage defines the interface that
    /// notification storage component provides.
    /// </summary>
    public interface INotificationStorage
    {
        /// <summary>
        /// Query notifications.
        /// User identity is based on the HTTP request cookie or authorization header.
        /// </summary>
        /// <param name="queryParameter">Query parameter.</param>
        /// <returns>Notification entries.</returns>
        NotificationList
        QueryNotifications(NotificationQueryParameter queryParameter);

        /// <summary>
        /// This method saves a notification to storage.
        /// </summary>
        /// <param name="userId">The identificatio of the user. </param>
        /// <param name="gameId">Game Id of the notification.</param>
        /// <param name="sessionId">Session Id of the notification.</param>
        /// <param name="notification">Notification object.</param>
        /// <returns>Notification Id.</returns>
        string
        SaveNotification(
            string userId,
            uint gameId,
            string sessionId,
            Notification notification);

        /// <summary>
        /// This method deletes a notification from storage.
        /// </summary>
        /// <param name="userId">The identification of the user.</param>
        /// <param name="notificationId">Notificaiton Id.</param>
        void
        DeleteNotification(
            string userId,
            string notificationId);

        /// <summary>
        /// This method deletes notifications from the storage. 
        /// NotificationQueryParameter.Count and LastId are not used in this case. 
        /// </summary>
        /// <param name="userId">The id of the user. </param>
        /// <param name="queryParameter">The query parameter of the notifications. </param>
        void
        DeleteNotification(string userId, NotificationQueryParameter queryParameter);

        /// <summary>
        /// This method deletes all notifications from a user's storage. 
        /// </summary>
        /// <param name="userId">The user id. </param>
        void
        DeleteNotification(string userId);

        /// <summary>
        /// This method deletes notifications of a session from storage.
        /// </summary>
        /// <param name="userId">The identification of the User.</param>
        /// <param name="gameId">The identification of the game. </param>
        /// <param name="sessionId">Session Id.</param>
        void
        DeleteNotificationBySession(
            string userId,
            uint gameId,
            string sessionId);

        /// <summary>
        /// This method update the notification status to a new value. 
        /// </summary>
        /// <param name="userId">The identification of the user. </param>
        /// <param name="notificationId">The notification identification. </param>
        /// <param name="status">The new status to be changed to. </param>
        void
        UpdateNotification(
            string userId,
            string notificationId,
            Notification.NotificationStatus status);

        /// <summary>
        /// This method intialize the storage for the first time. 
        /// </summary>
        void
        InitializeStorage();
    }

    /// <summary>
    /// Query parameters for notification.
    /// </summary>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "NotificationQueryParameter")]
    public class NotificationQueryParameter
    {
        /// <summary>
        /// Gets or sets the user identification. 
        /// </summary>
        public string UserId { get; set; }

        /// <summary>
        /// Gets or sets the category of notifications. 
        /// </summary>
        public int? Category { get; set; }

        /// <summary>
        /// Gets or sets game Id.
        /// </summary>
        public uint? GameId { get; set; }

        /// <summary>
        /// Gets or sets game variant.
        /// </summary>
        public int? Variant { get; set; }

        /// <summary>
        /// Gets or sets session Id.
        /// </summary>
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets the last notification id received. 
        /// </summary>
        public string LastId { get; set; }

        /// <summary>
        /// Gets or sets the number of results to be returned.
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether
        /// the notification is visible to the user.
        /// </summary>
        public bool UserVisibleOnly { get; set; }

        /// <summary>
        /// Gets or sets the type of the notification. 
        /// </summary>
        public uint? Type { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\InvitationNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="InvitationNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  InvitationNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold Invitation notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "InvitationNotification")]
    public class InvitationNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the InvitationNotification class.
        /// </summary>
        public InvitationNotification()
            : base()
        {
            this.Type = NotificationType.Invitation;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo;
            this.FriendRequest = false;
        }

        /// <summary>
        /// Gets or sets the optional FriendRequest. 
        /// </summary>
        public bool FriendRequest { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\MediaChangeNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="MediaChangeNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="douga">
//     Doug Anderson
// </author>
//
// <summary>
//  MediaChangeNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="02/16/2012">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Class to hold media change notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "MediaChangeNotification")]
    public class MediaChangeNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the MediaChangeNotification class.
        /// </summary>
        public MediaChangeNotification()
            : base()
        {
            this.Type = NotificationType.MediaChange;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\MessageNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="MessageWaitingNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Message waiting notification. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/19/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold SessionRemoved notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "MessageNotification")]
    public class MessageNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the MessageWaitingNotification class.
        /// </summary>
        public MessageNotification()
            : base()
        {
            this.Type = NotificationType.Message;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\NotificationList.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  NotificationList class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold a list of notifications.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("System.Xml", "2.0.50727.3053")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [CollectionDataContract(Name = "NotificationList")]
    public class NotificationList : List<Notification>
    {
        /// <summary>
        /// Initializes a new instance of the NotificationList class.
        /// </summary>
        public NotificationList()
            : base()
        {
        }

        /// <summary>
        /// Initializes a new instance of the NotificationList class.
        /// </summary>
        /// <param name="items">Items to initialize the class.</param>
        public NotificationList(IEnumerable<Notification> items)
            : base(items)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\NotificationRequest.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The extended methods of NotificationRequest besides the ones auto generated. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/08/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;  
    using System.Runtime.Serialization;

    /// <summary>
    /// The notification request class. 
    /// </summary>
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "NotificationRequest")]
    public class NotificationRequest
    {
        /// <summary>
        /// Initializes a new instance of the NotificationRequest class. 
        /// </summary>
        public NotificationRequest()
        {
            this.RequestId = Guid.NewGuid().ToString();
            this.RequestTime = DateTime.UtcNow;
        }

        /// <summary>
        ///  Request Action Type enumeration.
        /// </summary>
        public enum ActionType
        {
            /// <summary>
            ///  This is to create new notification(s). 
            /// </summary>
            Create = 0,

            /// <summary>
            /// Delete notification(s)
            /// </summary>
            Delete = 1,

            /// <summary>
            /// Invalid action type. 
            /// </summary>
            NotDefined = 255
        }

        /// <summary>
        /// Gets or sets the identifier of the request for internall tracking. 
        /// </summary>
        [DataMember]
        public string RequestId { get; set; }

        /// <summary>
        /// Gets or sets the time of the request. 
        /// </summary>
        [DataMember]
        public DateTime RequestTime { get; set; }

        /// <summary>
        /// Gets or sets the number of retries of this request. 
        /// </summary>
        [DataMember]
        public int TriedTimes { get; set; }

        /// <summary>
        /// Gets or sets the user info of the initiator. It could be xuid or serialized user info. 
        /// </summary>
        [DataMember]
        public string From { get; set; }

        /// <summary>
        /// Gets or sets the locale of the initiator. This is for the fall through case. 
        /// </summary>
        [DataMember]
        public string RequestLocale { get; set; }

        /// <summary>
        /// Gets or sets the list of recipients 
        /// </summary>
        [DataMember]
        public string To { get; set; }

        /// <summary>
        /// Gets or sets the gameid of this request. 
        /// </summary>
        [DataMember]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the session id of this request. 
        /// </summary>
        [DataMember]
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets the command of the request. 
        /// </summary>
        [DataMember]
        public string Command { get; set; }

        /// <summary>
        /// Gets or sets the action type of this request. 
        /// </summary>
        [DataMember]
        public ActionType Action { get; set; }

        /// <summary>
        /// Gets or sets the requested data type. This field is used to 
        /// deserialize RequestData. The value also depends on ActionType. 
        /// </summary>
        [DataMember]
        public int RequestDataType { get; set; }

        /// <summary>
        /// Gets or sets the detailed request data. The exact format depends on 
        /// ActionType and RequestDataType. 
        /// </summary>
        [DataMember]
        public string RequestData { get; set; }

        /// <summary>
        /// Gets or sets a list of recipeints. This is used to keep temporary data between processing steps. 
        /// </summary>
        public List<UserInfo> RecipientsInfo { get; set; }

        /// <summary>
        /// Gets or sets the identity information of the sender.This is used to keep temporary data between 
        /// processing steps. 
        /// </summary>
        public UserInfo SenderInfo { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\NotificationsDiag.cs ===


namespace NotificationCommon
{
    using Leet.Core.Diagnostics;
   public static class NotificationsDiag
    {
        public static ILogging Logging
        {
            get { return Leet.Core.IoCCo.Container.Instance.GetComponent<ILogging>(); }
        }
    }

   public class AzureStorageAccessFailure : BaseEvent
   {
       public AzureStorageAccessFailure()
           : base(8001, System.Diagnostics.TraceEventType.Error, "Azure storage access failure")
       {
       }

       public AzureStorageAccessFailure(string param)
           : base(8001, System.Diagnostics.TraceEventType.Error, "Azure storage access failure" + param)
       {
       }
   }

   public class SmtpServerConnectionError : BaseEvent
   {
       public SmtpServerConnectionError()
           : base(8012, System.Diagnostics.TraceEventType.Error, "Error connecting SMTP server")
       {
       }
   }

   public class SmtpServerInvalidOperation : BaseEvent
   {
       public SmtpServerInvalidOperation()
           : base(8013, System.Diagnostics.TraceEventType.Error, "SMTP Server Invalid Operation")
       {
       }
   }
   public class RetriableError : BaseEvent
   {
       public RetriableError()
           : base(8019, System.Diagnostics.TraceEventType.Warning, "Retriable exception")
       {
       }
   }
   
  public class ErrorProcessingNotification : BaseEvent
  {
      public ErrorProcessingNotification()
          : base(8020, System.Diagnostics.TraceEventType.Error, "Could not process a notification, dropping and moving on")
      {
      }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\MatchFoundNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="MatchFoundNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="micole">
//     Michael Cole
// </author>
//
// <summary>
//  MatchFoundNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/02/2011">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold MatchFound notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "MatchFoundNotification")]
    public class MatchFoundNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the MatchFoundNotification class.
        /// </summary>
        public MatchFoundNotification()
            : base()
        {
            this.Type = NotificationType.MatchFound;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\NotificationAuditLog.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using Leet.Core.IoCCo;
using Leet.Core.Configuration;
using System.Data;
using Leet.Core.Diagnostics;

namespace AsyncMultiplayer.NotificationService
{
    public enum NotificationAuditState
    {
        Error = 0,
        ReceivedFromQueue = 1,
        DeliveredToClient = 2,
        ProcessingCompleted = 3,  // NOTE:  This value (3) is linked to the value in p_ResponseQueueListener and should not be changed here
        EmailSent = 4,
        WrittenToStorage = 5,
        DeletedFromStorage = 6,
        SentToPushNotSystem = 7
    }

    public class NotificationAuditLog
    {
        private const string DB_INTERFACE_NAME = "lest_AsyncNotification_db";

        /// <summary>
        /// Use to enable or disable audit logging.  This attribute is ThreadStatic and will have a separate value
        /// for each thread that sets it.  To preserve logging integrity, this value should be set only once before 
        /// any log writes are attempted for a message.
        /// </summary>
        [ThreadStatic]
        public static bool IsEnabled;

        public NotificationAuditLog()
        {
        }

        /// <summary>
        /// Write a new row to AsyncNotification.t_notifications_audit table to track the status of a notification.
        /// Note that this method must be thread safe since it is static and will be accessed by many threads at
        /// the same time.
        /// </summary>
        /// <param name="state">Current state of the notification</param>
        /// <param name="request">The notification currently being tracked</param>
        public static void UpdateTrackingState(NotificationAuditState state, NotificationRequest request)
        {
            // Make sure logging is enabled
            if (!IsEnabled) return;

            // Swallow the null parameter to avoid potentialy breaking functional code
            if (request == null)
            {
                Logging.TraceVerbose("NotificationAuditLog.UpdateTrackingState received a NULL NotificationRequest.  Dropping the audit update.");
                return;
            }

            string dbConnectionString = String.Empty;

            try
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                dbConnectionString = configSettings.GetConnectionString(DB_INTERFACE_NAME);
            }
            catch (Exception ex)
            {
                Logging.TraceWarning(ex, "Failed to build connection string to {0}", DB_INTERFACE_NAME);
                return;
            }

            try
            {
                using (SqlConnection sqlConn = new SqlConnection(dbConnectionString))
                {
                    using (SqlCommand sqlCmd = sqlConn.CreateCommand())
                    {
                        sqlCmd.CommandType = CommandType.StoredProcedure;
                        sqlCmd.CommandText = "NotificationSchema.p_InsertAuditRow";

                        sqlCmd.Parameters.Add("@RequestId", SqlDbType.NVarChar, 128);
                        sqlCmd.Parameters.Add("@NotificationType", SqlDbType.Int);
                        sqlCmd.Parameters.Add("@Sender", SqlDbType.NVarChar, 256);
                        sqlCmd.Parameters.Add("@NotificationState", SqlDbType.TinyInt);
                        sqlCmd.Parameters.Add("@EventTime", SqlDbType.DateTime);

                        sqlCmd.Parameters["@RequestId"].Value = request.RequestId;
                        sqlCmd.Parameters["@NotificationType"].Value = request.RequestDataType;
                        if (request.SenderInfo != null && !String.IsNullOrEmpty(request.SenderInfo.GamerTag))
                        {
                            sqlCmd.Parameters["@Sender"].Value = request.SenderInfo.GamerTag;
                        }
                        else
                        {
                            sqlCmd.Parameters["@Sender"].Value = "Unknown Sender";
                        }

                        sqlCmd.Parameters["@NotificationState"].Value = (int)state;
                        sqlCmd.Parameters["@EventTime"].Value = DateTime.Now;

                        try
                        {
                            sqlConn.Open();
                            sqlCmd.ExecuteNonQuery();
                        }
                        catch (SqlException sqlEx)
                        {
                            Logging.TraceException(sqlEx, "SQL Exception:  Failed to write to t_notifications_audit table");
                        }
                        catch (Exception ex)
                        {
                            Logging.TraceException(ex, "Failed to write to t_notifications_audit table");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Logging.TraceException(ex, "Unexpected exception while writing to the t_notifications_audit table");
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\Notification.cs ===
//-------------------------------------------------------------------
// <copyright file="Notification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Notification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Xml.Serialization;

    /// <summary>
    /// Class to hold all notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [KnownType(typeof(YourTurnNotification))]
    [KnownType(typeof(GameOverNotification))]
    [KnownType(typeof(InvitationNotification))]
    [KnownType(typeof(NudgeNotification))]
    [KnownType(typeof(MessageNotification))]
    [KnownType(typeof(YouWinNotification))]
    [KnownType(typeof(YouLoseNotification))]
    [KnownType(typeof(GameTieNotification))]
    [KnownType(typeof(FriendRequestNotification))]
    [KnownType(typeof(Spotlight))]
    [KnownType(typeof(MatchFoundNotification))]
    [KnownType(typeof(BeaconNotification))]
    [DataContract(Name = "Notification")]
    public abstract class Notification
    {
        /// <summary>
        /// The prefix for the format string of NotificationId.
        /// This part deals with DateTime portion of the NotificationId.
        /// </summary>
        public const string IdPrefixFormatString = "{0:D19}";

        /// <summary>
        /// The format string of NotificationId
        /// </summary>
        public const string IdFormatString = IdPrefixFormatString + "-{1}";

        /// <summary>
        /// The length of the ticks in a notification id. 
        /// </summary>
        public const int IdTicksLength = 19;

        /// <summary>
        /// The lenght of a guid string {E6F973E4-644B-4d2f-AB5F-EA3074BCDF75}
        /// </summary>
        public const int IdGuidLength = 36;

        /// <summary>
        /// The length of the id.
        /// The id contains 19 digits as time ticks, a dash and a guid. 
        /// </summary>
        public const int IdLength = IdTicksLength + IdGuidLength + 1;

        /// <summary>
        /// Flag used within the Variant property used to signify that a particular Notification has come from the SLS Messaging system
        /// </summary>
        public const uint SLSNotificationFlag = 1112222111;

        /// <summary>
        /// The id of the notification. 
        /// </summary>
        [DataMember]
        private string id;

        /// <summary>
        /// Initializes a new instance of the Notification class. 
        /// </summary>
        public Notification()
        {
            this.id = string.Format(IdFormatString, (DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks), Guid.NewGuid());
            this.SentTime = DateTime.UtcNow;

            // The following value should be set. Some storage solution like Azure Table will
            // complain if the fields are empty. The creator can overwrite these two if necessary. 
            this.DeliveredTime = DateTime.UtcNow;
            this.ExpirationTime = DateTime.MaxValue;
            this.Status = NotificationStatus.UnRead;
        }

        /// <summary>
        /// Notification Category Enumeration. 
        /// </summary>
        public enum NotificationCategory
        {
            /// <summary>
            /// The category is not specified. 
            /// </summary>
            NotSpecified = 0,

            /// <summary>
            /// The notification is TODO. Requires user actions. 
            /// </summary>
            ToDo = 1,

            /// <summary>
            /// The notification is informational only. 
            /// </summary>
            Info = 2
        }

        /// <summary>
        /// Notitification status enumberation. 
        /// </summary>
        public enum NotificationStatus
        {
            /// <summary>
            /// The notification is already viewed by the user. 
            /// </summary>
            UnRead = 0,

            /// <summary>
            /// The notification is pending to be viewed by the user. 
            /// </summary>
            Viewed = 1
        }

        /// <summary>
        ///  Notification type enumeration.
        /// </summary>
        public enum NotificationType
        {
            /// <summary>
            ///  This is your turn.
            /// </summary>
            YourTurn = 0,

            /// <summary>
            ///  Nudge to remind the player.
            /// </summary>
            Nudge = 4,

            /// <summary>
            ///  A game invitation.
            /// </summary>
            Invitation = 8,

            /// <summary>
            ///  Game over.
            /// </summary>
            GameOver = 9,

            /// <summary>
            /// Message. 
            /// </summary>
            Message = 14,

            /// <summary>
            /// You have won the game. 
            /// </summary>
            YouWin = 15,

            /// <summary>
            /// You have lost the game. 
            /// </summary>
            YouLose = 16,

            /// <summary>
            /// The game is a tie. 
            /// </summary>
            GameTie = 17,

            /// <summary>
            /// Someone wants to be a friend. 
            /// </summary>
            FriendRequest = 18,

            /// <summary>
            /// A beacon has been set. 
            /// </summary>
            Beacon = 19,

            /// <summary>
            /// A match has been made by Async Matchmaking. 
            /// </summary>
            MatchFound = 20,
        }

        

        /// <summary>
        /// Gets or sets the notification Id.
        /// NOTE: setter is still here so the test code can pass. It will eventually be removed. 
        /// </summary>
        public string Id
        {
            get { return this.id; }
            set { this.id = value; }
        }

        /// <summary>
        /// Gets or sets the originator of this notification. This could be the name of a system component
        /// or some identity of the user. 
        /// </summary>
        [DataMember]
        public string From { get; set; }

        /// <summary>
        /// Gets or sets the target of this notification. This is the owner's public identity of the 
        /// notification. 
        /// </summary>
        [DataMember]
        public string UserId { get; set; }

        /// <summary>
        /// Gets or sets notification category. 
        /// </summary>
        [DataMember]
        public NotificationCategory Category { get; set; }

        /// <summary>
        /// Gets or sets notification type.
        /// </summary>
        [DataMember]
        public NotificationType Type { get; set; }

        /// <summary>
        /// Gets or sets the localized notification type display name. 
        /// </summary>
        [DataMember]
        public string TypeDisplayName { get; set; }

        /// <summary>
        /// Gets or sets notification status. 
        /// </summary>
        [DataMember]
        public NotificationStatus Status { get; set; }

        /// <summary>
        /// Gets or sets game Id.
        /// </summary>
        [DataMember]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the game display name. 
        /// </summary>
        [DataMember]
        public string GameDisplayName { get; set; }

        /// <summary>
        /// Gets or sets the variant of the game.
        /// </summary>
        [DataMember]
        public uint Variant { get; set; }

        /// <summary>
        /// Gets or sets session Id.
        /// </summary>
        [DataMember]
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether
        /// the notification is visible to the user.
        /// </summary>
        [DataMember]
        public bool IsUserVisible { get; set; }

        /// <summary>
        /// Gets or sets sent time of this
        /// notification.
        /// </summary>
        [DataMember]
        public DateTime SentTime { get; set; }

        /// <summary>
        /// Gets or sets the actual delivery time of 
        /// this notification. 
        /// </summary>
        [DataMember]
        public DateTime DeliveredTime { get; set; }

        /// <summary>
        /// Gets or sets the expiration time of this
        /// notification. 
        /// </summary>
        [DataMember]
        public DateTime ExpirationTime { get; set; }

        /// <summary>
        /// Gets or sets the image urls. 
        /// </summary>
        [DataMember]
        public string Images { get; set; }

        /// <summary>
        /// Gets or sets the associated URL. 
        /// This URL could be help URL or the general information regarding the notification. 
        /// </summary>
        [DataMember]
        public string Url { get; set; }

        /// <summary>
        /// Gets or sets supported platform of this
        /// notification.
        /// </summary>
        [DataMember]
        public int SupportedPlatform { get; set; }

        /// <summary>
        /// Gets or sets additional datablob. 
        /// </summary>
        [DataMember]
        public string DataBlob { get; set; }

        /// <summary>
        /// This method serializes an object to string.
        /// </summary>
        /// <param name="obj">Object to be serialized.</param>
        /// <returns>Serialized string of the object</returns>
        public
        static
        string
        SerializeToString(object obj)
        {
            XmlSerializer serializer = new XmlSerializer(obj.GetType());
            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, obj);

                return writer.ToString();
            }
        }

        /// <summary>
        /// This method deserializes a XML string into an object.
        /// </summary>
        /// <typeparam name="T">The generic type parameter.</typeparam>
        /// <param name="xml">XML string to be deserialized.</param>
        /// <returns>Object deserialized from the XML string</returns>
        public
        static
        T
        DeserializeFromString<T>(string xml)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(T));

            using (StringReader reader = new StringReader(xml))
            {
                return (T)serializer.Deserialize(reader);
            }
        }

        /// <summary>
        /// Deserialize from an xml string by specifying the type. 
        /// </summary>
        /// <param name="xml">The xml string. </param>
        /// <param name="type">The type of the notification. </param>
        /// <returns>Deserialized notification object. </returns>
        public
        static
        Notification
        DeserializeFromString(string xml, NotificationType type)
        {
            Notification newNotification;
            switch (type)
            {
                case Notification.NotificationType.GameOver:
                    newNotification = Notification.DeserializeFromString<GameOverNotification>(xml);
                    break;
                case Notification.NotificationType.Invitation:
                    newNotification = Notification.DeserializeFromString<InvitationNotification>(xml);
                    break;
                case Notification.NotificationType.Nudge:
                    newNotification = Notification.DeserializeFromString<NudgeNotification>(xml);
                    break;
                case Notification.NotificationType.YourTurn:
                    newNotification = Notification.DeserializeFromString<YourTurnNotification>(xml);
                    break;
                case Notification.NotificationType.Message:
                    newNotification = Notification.DeserializeFromString<MessageNotification>(xml);
                    break;
                case Notification.NotificationType.YouWin:
                    newNotification = Notification.DeserializeFromString<YouWinNotification>(xml);
                    break;
                case Notification.NotificationType.YouLose:
                    newNotification = Notification.DeserializeFromString<YouLoseNotification>(xml);
                    break;
                case Notification.NotificationType.GameTie:
                    newNotification = Notification.DeserializeFromString<GameTieNotification>(xml);
                    break;
                case Notification.NotificationType.FriendRequest:
                    newNotification = Notification.DeserializeFromString<FriendRequestNotification>(xml);
                    break;
				case Notification.NotificationType.Beacon:
					newNotification = Notification.DeserializeFromString<BeaconNotification>(xml);
					break;
				case Notification.NotificationType.MatchFound:
					newNotification = Notification.DeserializeFromString<MatchFoundNotification>(xml);
					break;
				default:
                    throw new InvalidOperationException(String.Format("Type {0} is not suspported", type));
            }

            return newNotification;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\NudgeNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="NudgeNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  NudgeNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold Nudge notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "NudgeNotification")]
    public class NudgeNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the NudgeNotification class.
        /// </summary>
        public NudgeNotification()
            : base()
        {
            this.Type = NotificationType.Nudge;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\UserData.cs ===
//-------------------------------------------------------------------
// <copyright file="UserData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  User control data. This class is used to help Notification Service to make certain 
//  decisions 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/28/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Collections.Generic;

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Class to hold BestScore notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "UserData")]
    public class UserData
    {
        /// <summary>
        /// Initializes a new instance of the UserData class.
        /// </summary>
        /// <param name="userId">The unique id of the user. </param>
        public UserData(string userId)
        {
            this.UserId = userId; 
            this.InviteCount = 0;
            this.LastInviteResetTime = DateTime.UtcNow;
            this.LastUpdateTime = DateTime.UtcNow;
            this.Push =  new UserSubscription(); 
        }

        /// <summary>
        /// Gets or sets the user id. It has to be unique. 
        /// </summary>
        [DataMember]
        public string UserId { get; set; }

        /// <summary>
        /// Gets or sets the number of inivtes sent since last reset.
        /// </summary>
        [DataMember]
        public int InviteCount { get; set; }

        /// <summary>
        /// Gets or sets the time when InviteCount was reset
        /// </summary>
        [DataMember]
        public DateTime LastInviteResetTime { get; set; }

        /// <summary>
        /// Gets or sets the time when the user's storage was last updated.
        /// </summary>
        [DataMember]
        public DateTime LastUpdateTime { get; set; }

        /// <summary>
        /// Gets or sets the push Subscription
        /// </summary>
        [DataMember]
        public UserSubscription Push { get; set; }

    }

    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2010/12/XboxLive.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "PushSubscription")]
    public class PushSubscription
    {
        [DataMember]
        public string Url;
        [DataMember]
        public string SubTypes;
    }

    public class UserSubscription
    {
        public string Url;
        public string SubTypes;
        public string UrlKey;
        public string Locale;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\YouLoseNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="YouLoseNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  YouLoseNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold GameOver notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "YouLoseNotification")]
    public class YouLoseNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the YouLoseNotification class.
        /// </summary>
        public YouLoseNotification()
            : base()
        {
            this.Type = NotificationType.YouLose;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\Spotlight.cs ===
//-------------------------------------------------------------------
// <copyright file="Spotlight.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Spotlight notification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="11/13/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Class to hold Spotlight data. 
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "Spotlight")]
    public class Spotlight
    {
        /// <summary>
        /// Initializes a new instance of the Spotlight class. 
        /// </summary>
        /// <param name="title">The title of the notification. </param>
        /// <param name="subtitle">The subtitle of the notification. </param>
        /// <param name="url">The launch url. </param>
        /// <param name="gameId">The game id of the spotlight. </param>
        public Spotlight(string title, string subtitle, string url, uint gameId)
        {
            this.Title = title;
            this.Subtitle = subtitle;
            this.Url = url;
            this.GameId = gameId; 
        }
            
        /// <summary>
        /// Gets or sets the title. 
        /// </summary>
        [DataMember]
        public string Title { get; set; }

        /// <summary>
        /// Gets or sets the subtitle. 
        /// </summary>
        [DataMember]
        public string Subtitle { get; set; }

        /// <summary>
        /// Gets or sets the Url. 
        /// </summary>
        [DataMember]
        public string Url { get; set; }

        /// <summary>
        /// Gets or sets the GameId. 
        /// </summary>
        [DataMember]
        public uint GameId { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\UserInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="UserInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  A class used in notification service to keep the user information.  
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/28/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Runtime.Serialization;
    using System.Xml.Serialization; 

    /// <summary>
    /// Class to hold User Info data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "UserInfo")]
    public class UserInfo
    {
        /// <summary>
        /// The prefix to a gamertag recipient in a notification. 
        /// </summary>
        public const string GamertagPrefix = "gamertag:";

        /// <summary>
        /// The delimiter characters. 
        /// </summary>
        public static readonly string[] UserDelimitor = new string[] { ";" };

        /// <summary>
        /// Initializes a new instance of the UserInfo class. 
        /// </summary>
        public UserInfo()
        {
        }

        /// <summary>
        /// Initializes a new instance of the UserInfo class.
        /// </summary>
        /// <param name="xuid">The Xuid of the user. </param>
        public UserInfo(ulong xuid)
        {
            this.Xuid = xuid;
        }

        /// <summary>
        /// Gets or sets the display name of the user. 
        /// </summary>
        [DataMember]
        public string DisplayName { get; set; }

        /// <summary>
        /// Gets or sets the gamer tag of the user. 
        /// </summary>
        [DataMember]
        public string GamerTag { get; set; }

        /// <summary>
        /// Gets or sets the email address of the user. 
        /// </summary>
        [XmlIgnore]
        public string EmailAddress { get; set; }

        /// <summary>
        /// Gets or sets the Xuid of the user. 
        /// </summary>
        [XmlIgnore]
        public ulong Xuid { get; set; }

        /// <summary>
        /// Gets or sets the Puid of the user
        /// </summary>
        [XmlIgnore]
        public long Puid { get; set; }

        /// <summary>
        /// Gets or sets the locale of the user. 
        /// </summary>
        [XmlIgnore]
        public string Locale { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\YourTurnNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="YourTurnNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  YourTurnNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold YourTurn notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "YourTurnNotification")]
    public class YourTurnNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the YourTurnNotification class.
        /// </summary>
        public YourTurnNotification()
            : base()
        {
            this.Type = NotificationType.YourTurn;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\YouWinNotification.cs ===
//-------------------------------------------------------------------
// <copyright file="YouWinNotification.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  YouWinNotification class
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/17/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Xml.Linq;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Class to hold GameOver notification data.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [System.Xml.Serialization.XmlRootAttribute(Namespace = "http://schemas.datacontract.org/2004/07/AsyncMultiplayer.NotificationService", IsNullable = false)]
    [Serializable]
    [DataContract(Name = "YouWinNotification")]
    public class YouWinNotification : Notification
    {
        /// <summary>
        /// Initializes a new instance of the YouWinNotification class.
        /// </summary>
        public YouWinNotification()
            : base()
        {
            this.Type = NotificationType.YouWin;
            this.IsUserVisible = true;
            this.Category = NotificationCategory.ToDo; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\Utility.cs ===
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Xml;
using System.Xml.XPath;
using Leet.Core.Diagnostics;

namespace AsyncMultiplayer.NotificationService
{
    public class LocalizationUtility
    {
        /// <summary>
        /// The file name that has the localized notification type names. 
        /// </summary>
        private const string NotTypeNameFile = @"\LocalizedNotificationTypeName.xml";

        /// <summary>
        /// A hash table for localized type names. 
        /// </summary>
        private static Hashtable localizedTypeNames;

        /// <summary>
        /// the format string for generate the key for looking up localized string. 
        /// </summary>
        private const string LocalizedNameKeyFormat = "{0}:{1}";

        /// <summary>
        /// The default locale if X-locale is not present. 
        /// </summary>
        public const string DefaultLocale = "en-US";
      

       /// Read the localized type names into the hash table. 
        /// </summary>
        private static Hashtable ReadLocalizedTypeNames()
        {
            Hashtable localizedNames = new Hashtable();
            XmlDocument doc = new XmlDocument();

            string currentDir = Path.GetDirectoryName(typeof(LocalizationUtility).Assembly.CodeBase);
          

            try
            {
                doc.Load(currentDir + NotTypeNameFile);
                XPathNodeIterator iterator = doc.CreateNavigator().Select("//NotificationTypeDisplayName//Entry");

                foreach (XPathNavigator node in iterator)
                {
                    string type = node.SelectSingleNode("@Type").Value;
                    string locale = node.SelectSingleNode("@Locale").Value;
                    string value = node.SelectSingleNode("@Value").Value;
                    string key = string.Format(LocalizedNameKeyFormat, type, locale);
                    localizedNames.Add(key, value);
                }
                return localizedNames;
            }
                
            catch (IOException ex)
            {
                Logging.TraceException(ex, "{0}: {1}",
                    "Utility",
                    "File not found");
            }
            return null;
        }

        public static string LocalizedNotificationType(string type, CultureInfo culture)
        {
            if (localizedTypeNames == null)
                localizedTypeNames = ReadLocalizedTypeNames();
            // Notification type display name localization is done by this service. 
            string key = string.Format(LocalizedNameKeyFormat, type, culture.Name);

            // if the provided locale doesn't exist, fallback to language
            // if the language doesn't exist, fallback to default locale. 
            if (!localizedTypeNames.Contains(key))
            {
                key = string.Format(LocalizedNameKeyFormat, type, culture.TwoLetterISOLanguageName);
                if (!localizedTypeNames.Contains(key))
                {
                    key = string.Format(LocalizedNameKeyFormat, type, DefaultLocale);
                }
            }

            return (string)localizedTypeNames[key];
        }

        public static string LocalizedBeaconGameDisplayName(CultureInfo culture, string dataBlob)
        {
            // Divide all pairs (remove empty strings)
            string[] tokens = dataBlob.Split(new char[] { '^' }, System.StringSplitOptions.RemoveEmptyEntries);

            // Walk through each item pair (Locale followed by GameDisplayName)
            // If we find the default locale, keep track of the value so we
            // can use it in case we don't get an exact match
            string defaultGameDisplayName = string.Empty;
            for (int i = 0; i < tokens.Length; i += 2)
            {
                // Check if this is the exact culture we're looking for
                if ((tokens[i] == culture.Name) && (i < tokens.Length - 1))
                {
                    return tokens[i + 1];
                }

                // Check if this is the default culture
                if ((tokens[i] == DefaultLocale) && (i < tokens.Length - 1))
                {
                    defaultGameDisplayName = tokens[i + 1];
                }
            }

            // We didn't find the exact Game Display Name we were looking for, so just return the
            // Game display Name in the Default Locale.  Note that we're not guaranteed to even
            // have the default locale specified, in which case we'll be returning a blank string
            return defaultGameDisplayName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationData.Common\GameEventData.cs ===
using System;

namespace NotificationData.Common
{
    public struct GameEventData
    {
        [CLSCompliant(false)]
        public uint GameId;

        public int Lcid;

        [CLSCompliant(false)]
        public uint VariantId;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationCommon\Properties\AssemblyInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationCommon")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("de682dd1-c769-4fd7-953d-572a04f210ed")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationData.Common\ILeoFeedEventSerializer.cs ===
namespace NotificationData.Common
{
    public interface ILeoFeedEventSerializer<T>
    {
        /// <summary>
        /// Serializes the current object into string format.
        /// </summary>
        /// <returns>Serialized ILeoFeedEventData</returns>
        string Serialize(T data);

        /// <summary>
        /// Loads the current object with serialized data.
        /// </summary>
        /// <param name="feedEventData">A string serialized using ILeoFeedEventData.Serialize</param>
        T Deserialize(string feedEventData);
    } 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationData.Common\LeoFeedEventSerializer.cs ===
using System.Xml.Serialization;
using System.IO;

namespace NotificationData.Common
{
    public class LeoFeedEventSerializer<T> : ILeoFeedEventSerializer<T>
    {
        #region ILeoFeedEventSerializer Members

        string ILeoFeedEventSerializer<T>.Serialize(T data)
        {
            StringWriter str = new StringWriter();

            XmlSerializer serializer = new XmlSerializer(typeof(T));
            serializer.Serialize(str, data);

            return str.ToString();
        }

        T ILeoFeedEventSerializer<T>.Deserialize(string feedEventData)
        {
            StringReader str = new StringReader(feedEventData);

            XmlSerializer serializer = new XmlSerializer(typeof(T));
            T eventData = (T)serializer.Deserialize(str);

            return eventData;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationData.Common\SinglePlayerFeedEventData.cs ===
using System;
using System.Xml.Serialization;
using Leet.Authentication;

[assembly: CLSCompliant(true)]
namespace NotificationData.Common.EventData
{

    [Serializable]
    [CLSCompliant(true)]
    public abstract class SinglePlayerFeedEventData 
    {
        public SocialIdentity PublisherIdentity { get; set; }
        [CLSCompliant(false)] 
        public GameEventData GameData{ get; set;}
        public String PlatformOfPublisher { get; set; }



        #region consructors
        protected SinglePlayerFeedEventData() { }

        [CLSCompliant(false)]
        protected SinglePlayerFeedEventData(SocialIdentity publisher, GameEventData gameEventData, string publisherPlatform)
        {

            PublisherIdentity = publisher;
            GameData = gameEventData;
            PlatformOfPublisher = publisherPlatform;
        }
        #endregion
    }

    [Serializable]
    [XmlInclude(typeof (SinglePlayerFeedEventData))]
    [CLSCompliant(true)]
    public class ScoreFeedEventData : SinglePlayerFeedEventData
    {
        public long Score { get; set; }

        protected ScoreFeedEventData() { } 
        [CLSCompliant(false)]
        public ScoreFeedEventData(SocialIdentity publisher, GameEventData gameEventData, string publisherPlatform, long score)
            : base(publisher, gameEventData, publisherPlatform)
        {
            Score = score;
        }
    }

    [Serializable]
    [XmlInclude(typeof(TimeSpan))]
    [XmlInclude(typeof (SinglePlayerFeedEventData))]
    [CLSCompliant(true)]
    public class TimeScoreFeedEventData : SinglePlayerFeedEventData
    {
        [XmlIgnore]
        public TimeSpan TimeScore { get; set; }

        //This is a hack.  XmlSerializer doesn't work with TimeSpan due to an omission of this
        //type in XmlCustomFormatter in the CLR.  This is a work around.
        /// <summary>
        /// This is a Serialization Hack, do not access this property directly, instead you should use TimeScore
        /// </summary>
        [XmlElement("TimeScore")]
        public string XmlTimeScore
        {
            get { return TimeScore.ToString(); }
            set { TimeScore = TimeSpan.Parse(value); }
        }

        protected TimeScoreFeedEventData() { } 

        public TimeScoreFeedEventData(SocialIdentity publisher, GameEventData gameEventData, string publisherPlatform, TimeSpan timeScore)
            : base(publisher, gameEventData, publisherPlatform)
        {
            TimeScore = timeScore;
        }

    }

    [Serializable]
    [CLSCompliant(true)]
    [XmlInclude(typeof (SinglePlayerFeedEventData))]
    public class AchievementFeedEventData :SinglePlayerFeedEventData
    {

        public Guid AchievementId { get; set; }

        public AchievementFeedEventData()
        {
        }

        [CLSCompliant(false)]
        public AchievementFeedEventData(SocialIdentity publisher, GameEventData gameEventData, string publisherPlatform, Guid achievementId)
            : base(publisher, gameEventData, publisherPlatform)
        {
            AchievementId = achievementId;
        }
    }

    [Serializable]
    [CLSCompliant(true)]
    public enum ScoreTypes
    {
        NoScore = 1,
        NumericalScore = 2,
        TimeScore = 3
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationData.Common\MultiplayerFeedEventData.cs ===
using System;
using System.Collections.Generic;
using System.Xml.Serialization;
using Leet.Authentication;

namespace NotificationData.Common.EventData
{


    [Serializable]
    [XmlInclude(typeof(TimeSpan))]
    [CLSCompliant(true)]
    public class MultiplayerFeedEventData 
    {
        [CLSCompliant(false)]
        public GameEventData GameData{ get; set;}

        public List<SocialIdentity> Winners { get; set; }
        public List<SocialIdentity> Losers { get; set; }
        public List<SocialIdentity> Tied { get; set; }

        public Boolean IsTeamGame { get; set; }

        protected MultiplayerFeedEventData()
        {
        }

        [CLSCompliant(false)]
        public MultiplayerFeedEventData(GameEventData gameEventData, bool isTeamGame, List<SocialIdentity> winners, List<SocialIdentity> losers, List<SocialIdentity> tied)
        {
            GameData = gameEventData;
            IsTeamGame = isTeamGame;
            Winners = winners;
            Losers = losers;
            Tied = tied;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationFileStorage\Properties\AssemblyInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/18/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationFileStorage")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("373e6863-52f6-4333-aa46-72362fbefa31")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationData.Common\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationData.Common")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("fd143c93-72a9-4956-b340-0f917d4331fa")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationFileStorage\NotificationFileStorage.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationFileStorage.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  A file based notification storage, this is used as a temporary
//  storage before the formal database storage is implemented
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/18/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Text;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// This class implements a file based notification storage.
    /// </summary>
    public class NotificationFileStorage : INotificationStorage, INotificationRequest
    {
        /// <summary>
        /// File suffix.
        /// </summary>
        private const string FileSuffix = ".xml";

        /// <summary>
        /// File Enumeration.
        /// </summary>
        private const string FileEnumeration = "*.xml";

        /// <summary>
        /// Directory path to the storage location.
        /// </summary>
        private string storagePath;

        /// <summary>
        /// Initializes a new instance of the NotificationFileStorage class.
        /// </summary>
        /// <param name="rootPath">Root path of the storage.</param>
        public NotificationFileStorage(string rootPath)
        {
            this.storagePath = rootPath;
        }

        /// <summary>
        /// Initialize the file storage. 
        /// This method should only be called only from 
        /// </summary>
        public
        void
        InitializeStorage()
        {
        }

        /// <summary>
        /// Query notifications.
        /// User identity is based on the HTTP request cookie or authorization header.
        /// </summary>
        /// <param name="queryParameter">Query parameter.</param>
        /// <returns>Notification entries.</returns>
        public
        NotificationList
        QueryNotifications(NotificationQueryParameter queryParameter)
        {
            NotificationList results = new NotificationList();
            Notification entry = null;
            string userPath = this.storagePath + @"\" + queryParameter.UserId;
            DirectoryInfo di = new DirectoryInfo(userPath);
            FileInfo[] files = di.GetFiles(NotificationFileStorage.FileEnumeration);
            BinaryFormatter formatter = new BinaryFormatter();

            // No notifications
            if (files.Count() == 0)
            {
                return null;
            }

            // Go through each file, deserialize them
            foreach (FileInfo fi in files)
            {
                using (Stream stream = File.Open(userPath + @"\" + fi.Name, FileMode.Open))
                {
                    entry = (Notification)formatter.Deserialize(stream);
                    results.Add(entry);
                }
            }

            return results;
        }

        /// <summary>
        /// This method saves a notification to storage.
        /// </summary>
        /// <param name="userId">The identification of the user.</param>
        /// <param name="gameId">Game Id of the notification.</param>
        /// <param name="sessionId">Session Id of the notification.</param>
        /// <param name="notification">Notification object.</param>
        /// <returns>Notification Id.</returns>
        public
        string
        SaveNotification(
            string userId,
            uint gameId,
            string sessionId,
            Notification notification)
        {
            // In file based storage, notification is saved as a file with name
            // as puid\gameId-sessionId-notificationId.xml
            // This is a test harness, so no parameter checking is done here
            string userPath = this.storagePath + @"\" + userId;
            string filePath;

            // If user directory doesn't exist, create one
            if (!Directory.Exists(userPath))
            {
                // Create a directory for this user if it doesn't exist already
                Directory.CreateDirectory(userPath);
            }

            filePath = userPath + @"\" + notification.Id + NotificationFileStorage.FileSuffix;

            // Serialize the notification object to the file
            using (Stream s = File.Open(filePath, FileMode.Create))
            {
                BinaryFormatter formatter = new BinaryFormatter();
                formatter.Serialize(s, notification);
            }

            return notification.Id;
        }

        /// <summary>
        /// This method update the notification status to a new value. 
        /// </summary>
        /// <param name="userId">The identification of the user. </param>
        /// <param name="notificationId">The notification identification. </param>
        /// <param name="status">The new status to be changed to. </param>
        public
        void
        UpdateNotification(
            string userId,
            string notificationId,
            Notification.NotificationStatus status)
        {
        }

        /// <summary>
        /// Delete all the notifications of the user. 
        /// </summary>
        /// <param name="userId">The identity of the user. </param>
        public
        void
        DeleteNotification(string userId)
        {
            return;
        }

        /// <summary>
        /// This method deletes a notification from storage.
        /// </summary>
        /// <param name="userId">Live Id puid.</param>
        /// <param name="notificationId">Notificaiton Id.</param>
        public
        void
        DeleteNotification(
            string userId,
            string notificationId)
        {
            // Get the file name
            string userPath = this.storagePath + @"\" + userId;
            string filePath = userPath + @"\" +
                notificationId + NotificationFileStorage.FileSuffix;

            // Delete the file
            try
            {
                File.Delete(filePath);
            }
            catch (FileNotFoundException)
            {
                throw new WebProtocolException(HttpStatusCode.NotFound, "Not found", null);
            }

            return;
        }

        /// <summary>
        /// This method deletes notifications of a session from storage.
        /// </summary>
        /// <param name="userId">The identification of the user. </param>
        /// <param name="gameId">The GUID of the gameId. </param>
        /// <param name="sessionId">Session Id.</param>
        public
        void
        DeleteNotificationBySession(
            string userId,
            uint gameId,
            string sessionId)
        {
            return;
        }

        /// <summary>
        /// Delete the notifications based on the query parameter. 
        /// Count and LastId are not used. 
        /// </summary>
        /// <param name="userId">The id of the user. </param>
        /// <param name="queryParameter">The query parameter. </param>
        public
        void
        DeleteNotification(string userId, NotificationQueryParameter queryParameter)
        {
            return;
        }

        /// <summary>
        /// This method simulates sending a notification request.
        /// This method will actually call save notification to create a new notification.
        /// Before real notification queue and storage are created, this is used to
        /// enable end to end scenario on onebox.
        /// </summary>
        /// <param name="notificationRequest">Notification request object.</param>
        public
        void
        SendNotificationRequest(NotificationRequest notificationRequest)
        {
            Notification.NotificationType type = (Notification.NotificationType)Enum.ToObject(
                       typeof(Notification.NotificationType),
                       notificationRequest.RequestDataType);
            Notification newNotification = Notification.DeserializeFromString(notificationRequest.RequestData, type);

            // Save this notification
            this.SaveNotification(
                notificationRequest.To,
                (uint) notificationRequest.GameId,
                notificationRequest.SessionId,
                newNotification);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationFileStorage.Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Main cs file
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Xml.Serialization;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            NotificationFileStorage fileStorage = null;
            INotificationStorage notificationStorage = null;
            INotificationRequest notificationRequestHandler = null;
            string rootPath = @"c:\\notifications";
            NotificationRequest notificationRequest;
            Notification notification;
            NotificationList results;
            ulong puid = 50;
            notificationRequest = new NotificationRequest();

            // Initialize notificaiton request interface
            fileStorage = new NotificationFileStorage(rootPath);
            notificationRequestHandler = fileStorage;
            notificationStorage = fileStorage;

            // Create some notifications first
            notification = new NudgeNotification();
            notification.Id = Guid.NewGuid();
            notification.SupportedPlatform = (int)Notification.Platform.Web;
            notificationRequest.RequestType = (int)Notification.NotificationType.Nudge;
            notificationRequest.RequestData = Program.SerializeToString(notification);

            // This simulates internal services which need to send notifications
            // First, set up a notification request object
            notificationRequest.RequestId = Guid.NewGuid().ToString();
            notificationRequest.GameId = Guid.NewGuid().ToString();
            notificationRequest.SessionId = Guid.NewGuid().ToString();
            notificationRequest.PlayerPuid = puid;

            // Then send the request off
            notificationRequestHandler.SendNotificationRequest(notificationRequest);

            // Check whether it is successful by enumerating/Querying notifications
            NotificationQueryParameter parameter = new NotificationQueryParameter();
            parameter.Puid = puid;

            results = fileStorage.QueryNotifications(parameter);

            // Now delete that notification
            fileStorage.DeleteNotification(puid, notification.Id);
        }

        /// <summary>
        /// This method serializes an object to string.
        /// </summary>
        /// <param name="obj">Object to be serialized.</param>
        /// <returns>Serialized string of the object</returns>
        public
        static
        string
        SerializeToString(object obj)
        {
            XmlSerializer serializer = new XmlSerializer(obj.GetType());

            using (StringWriter writer = new StringWriter())
            {
                serializer.Serialize(writer, obj);

                return writer.ToString();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationFileStorage.Test\Properties\AssemblyInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationFileStorage.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("88c7f9ca-93ce-485b-9648-919674d6365b")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationHealth\Block_AzureTableAccess.cs ===
//
// Block_AzureTableAccess.cs
//
// Copyright (c) Microsoft Corporation. All Rights Reserved.
//
// Healthcheck Module
// 
//
// Common healthblock implementation.
//
// Author: a-gamavi 4/2010
//         
//

using System;
using System.IO;
using System.Text;
using System.Data;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Reflection;
using System.Configuration; 
using System.Xml.Serialization;
using Leet.Core;
using Leet.Core.IO;
using Leet.Core.Configuration;
using Leet.Core.IoCCo;
using AsyncMultiplayer.NotificationService;
using Leet.Health.Common;

namespace Notification.Health
{

// --------------------------------------------------------------------------------------
// AzureTableAccess - Verifies that Azure table can be accessed
//
// --------------------------------------------------------------------------------------
internal class AzureTableAccess : IHealthBlock
{
    public ResourceTypeEnum ResourceType
    {
        get { return ResourceTypeEnum.Remote; }
    }

    public void DoCheck(
        HealthBlockManager  blockManager,
        NameValueCollection blockParams,
        HealthReport        report)
    {
        IConfigurationProvider config = Container.Instance.GetComponent<IConfigurationProvider>();

        AzureTableAccessReport myReport = new AzureTableAccessReport();
        report.ExtendedReport = myReport;

        // Fill out component and extended message
        myReport.Component = config.ComponentName;

        try
        {
            // the query should execute even user doesn't exist
            string userId = @"Mpprodmon01";

            // query for notifications
            NotificationQueryParameter queryParameter = new NotificationQueryParameter();
            queryParameter.Count = 1;
            queryParameter.UserId = userId;

            NotificationStorageSingleton.Instance.QueryNotifications(queryParameter);    

            // If no exception is thrown, Azure table can be accessed
            myReport.Message = "Verified the access to Azure table";
            report.HealthStatus = HealthStatusEnum.Green;  // no exceptions thrown
        }
        catch (Exception ex)
        {
            // Write the exception to the health report
            myReport.Message = ex.ToString();
            report.HealthStatus = HealthStatusEnum.Red;
        }
    }
}

/// <summary>
/// Class to hold singleton notification storage.
/// </summary>
public class NotificationStorageSingleton
{
    private static NotificationAzureStorage instance = null;
    private NotificationStorageSingleton() { }

    public static NotificationAzureStorage Instance
    {
        get
        {
            if (instance == null)
            {
                // Instantiate NotificationStorage object
                StorageConfigs storageConfigs = new StorageConfigs();

                instance = new NotificationAzureStorage(storageConfigs.AzureTableStorageEndPoint,
                                                        storageConfigs.AzureStorageAccount,
                                                        storageConfigs.AzureStorageToken,
                                                        storageConfigs.ProxyAddress);
            }

            return instance; 
        }
    }
}

// --------------------------------------------------------------------------------------
// AzureTableAccessReport - health report
// --------------------------------------------------------------------------------------
public class AzureTableAccessReport : IExtendedHealthReport
{
    /// <summary>
    /// The component name.
    /// </summary>
    public string Component { get; set; }

    /// <summary>
    /// The extended message. 
    /// </summary>
    public string Message { get; set; }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Email\SMTPConfigs.cs ===
//-------------------------------------------------------------------
// <copyright file="SMTPConfigs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  SMTP Provider  Related Configurations. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/23/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Data;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;

    /// <summary>
    /// Service configuration class. 
    /// </summary>
    public class SMTPConfigs
    {
        /// <summary>
        /// Gets the SMTP provider account for sending emails. 
        /// </summary>
        public string NotificationSMTPProvider_Account
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_Account);
            }
        }

        /// <summary>
        /// Gets the SMTP provider account password. 
        /// </summary>
        public string NotificationSMTPProvider_Password
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_Password);
            }
        }

        /// <summary>
        /// Gets the domain setting of the account used for SMTP provider. 
        /// </summary>
        public string NotificationSMTPProvider_Domain
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_Domain);
            }
        }

        /// <summary>
        /// Gets the hostname of SMTP server. 
        /// </summary>
        public string NotificationSMTPProvider_HostName
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_HostName);
            }
        }

        /// <summary>
        /// Gets the email address of the the account. 
        /// </summary>
        public string NotificationSMTPProvider_EmailAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_EmailAddress);
            }
        }

        /// <summary>
        /// Gets the display name of the account. 
        /// </summary>
        public string NotificationSMTPProvider_DisplayName
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_DisplayName);
            }
        }

        /// <summary>
        /// Gets the path of the template. It should ends with \\
        /// </summary>
        public string NotificationSMTPProvider_TemplatePath
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_TemplatePath);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Email\InviteEmailComposer.cs ===

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Net.Mail;
    using System.Text;
    using System.Web;
    using GameMetadata.Common;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// This class implements the invite email composer. 
    /// </summary>
    internal class InviteEmailComposer : INotificationEmailComposer
    {
        /// <summary>
        /// Componenet name of InviteEmailComposer.
        /// </summary>
        public const string ComponentName = "InviteEmailComposer";

        /// <summary>
        /// The template type this composer is going to use. 
        /// </summary>
        private const Templates.TemplateType TemplateType = Templates.TemplateType.Invite;

        /// <summary>
        /// The media type of the HTML-formatted email. 
        /// </summary>
        private const string HtmlMediaType = "text/html";

        /// <summary>
        /// Gets the proxy address for the environment. 
        /// </summary>
        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }

        /// <summary>
        /// ComposeEmails() composes a list of notification MailMessage's ready to send.
        /// </summary>
        /// <param name="request">
        ///     The notification request object. 
        /// </param>
        /// <param name="senderAddress">
        ///     The account used for sending emails. 
        /// </param>
        /// <returns>A list of MailMessage's ready to send.</returns>
        public List<MailMessage> ComposeEmails(NotificationRequest request, MailAddress senderAddress)
        {
            Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "Entering ComposeEmails(): request=" + request.RequestId,
                    " SenderAddress=" + senderAddress.Address);

            InvitationNotification invite = Notification.DeserializeFromString<InvitationNotification>(request.RequestData);
            List<MailMessage> mailList = new List<MailMessage>();
            string subject = string.Empty;
            string body = string.Empty;
            string senderDisplayName = request.SenderInfo.GamerTag;
            string senderLocale = request.RequestLocale;
            string friendRequestSection = string.Empty;
            string encodedSenderName = HttpUtility.HtmlEncode(senderDisplayName);

            try
            {
                if (!String.IsNullOrEmpty(request.SenderInfo.DisplayName))
                {
                    senderDisplayName = request.SenderInfo.GamerTag + " (" + request.SenderInfo.DisplayName + ")";
                }

                // 1. Build the subject of the email for all recipients
                subject = NotificationSMTPProvider.EmailTemplates.GetTemplate(
                    TemplateType,
                    senderLocale,
                    Templates.TemplateSection.Subject);

                GameMetadataComposite gameData = NotificationSMTPProvider.GmsClient.GetGameMetadata(request.GameId, senderLocale, invite.Variant);
                if (gameData == null)
                {
                    throw new LIVEnException("Invalid gameId: " + request.GameId.ToString() + "; or locale: " + senderLocale);
                }

                string gameDisplayName = gameData.GameAndVariantName;
                if (string.IsNullOrEmpty(gameDisplayName))
                {
                    throw new LIVEnException("NULL or empty game name for gameId: " + request.GameId.ToString());
                }

                subject = string.Format(subject, senderDisplayName, gameDisplayName);

                // 2. Build the body of the email in HTML format
                body = NotificationSMTPProvider.EmailTemplates.GetTemplate(
                    TemplateType,
                    senderLocale,
                    Templates.TemplateSection.Body);

                // Game icons are are available form GMS. If GMS does not have an icon, default to XblIcon
                string ImageUrl;
                if ((gameData.Images!=null) && gameData.Images.ContainsKey(ImageType.GameTile_WebSmall))
                {
                    ImageUrl = gameData.Images[ImageType.GameTile_WebSmall].ImageUrl;
                }
                else
                { 
                    IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                    ImageUrl = configSettings.GetSetting(Settings.NotificationFE_XblIconWebSmallUrl);
                }

                // add the optional friend request section
                if (invite.FriendRequest)
                {
                    string friendRequestSectionTemplate = NotificationSMTPProvider.EmailTemplates.GetTemplate(TemplateType, senderLocale, Templates.TemplateSection.FriendRequest);
                    friendRequestSection = string.Format(friendRequestSectionTemplate, encodedSenderName);
                }

                string encodedSenderDisplayName = HttpUtility.HtmlEncode(senderDisplayName);
                body = string.Format(
                    body,
                    encodedSenderDisplayName, 
                    HttpUtility.HtmlEncode(gameDisplayName), 
                    HttpUtility.HtmlEncode(ImageUrl),
                    HttpUtility.HtmlEncode(invite.Url), 
                    friendRequestSection);

                AlternateView htmlView = AlternateView.CreateAlternateViewFromString(body, Encoding.UTF8, HtmlMediaType);

                foreach (UserInfo user in request.RecipientsInfo)
                {
                    if (!string.IsNullOrEmpty(user.EmailAddress))
                    {
                        MailMessage message = new MailMessage(senderAddress, new MailAddress(user.EmailAddress));
                        message.Sender = senderAddress;
                        message.Subject = subject;

                        message.AlternateViews.Add(htmlView);
                        mailList.Add(message);
                    }
                }
            }
            catch (Exception ex)
            {
                Logging.TraceWarning("{0}: {1} {2}",
                   ComponentName,
                   "Failed to compose emails for notification request! request.RequestData=" + request.RequestData,
                   "Exception: " + ex.ToString());                 
            }

            Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "Leaving ComposeEmails(): request=" + request.RequestId);

            return mailList;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Email\NotificationEmailComposer.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationEmailComposer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Defines and implements INotificationEmailComposer.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/06/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Net.Mail;
    using System.Text;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// INotificationEmailComposer defines the email composer interface
    /// with a method to send email notification messages.
    /// </summary>
    public interface INotificationEmailComposer
    {
        /// <summary>
        /// ComposeEmails() composes a list of notification MailMessage's ready to send.
        /// </summary>
        /// <param name="request">
        ///     The notification request. 
        /// </param>
        /// <param name="senderAddress">
        ///     The sender's email address. 
        /// </param>
        /// <returns>A list of MailMessage's ready to send.</returns>
        List<MailMessage> ComposeEmails(NotificationRequest request, MailAddress senderAddress);
    }

    /// <summary>
    /// NotificationEmailComposerFactory implements the factory for creating
    /// notification email composers.
    /// </summary>
    public class NotificationEmailComposerFactory
    {
        /// <summary>
        /// The constant display name of the component. 
        /// </summary>
        private const string ComponentName = "NotificationEmailComposerFactory";

        /// <summary>
        /// Creates a notification email composer
        /// as specified by the incoming MessageType.
        /// </summary>
        /// <param name="type">
        ///     The MessageType specifies the type of email going out.
        /// </param>
        /// <returns>Returns a notification email composer.</returns>
        public static INotificationEmailComposer GetEmailComposer(Notification.NotificationType type)
        {
            INotificationEmailComposer nec = null;

            switch (type)
            {
                case Notification.NotificationType.Invitation:
                    nec = new InviteEmailComposer();
                    break;

                default:
                    Logging.TraceError("{0}: {1}",
                                         ComponentName,
                                         string.Format("Type {0} is not supported", type));
                    break;
            }

            return nec;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Email\Templates.cs ===
//-------------------------------------------------------------------
// <copyright file="Templates.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
// The template managment class. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/23/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic; 
    using System.Data;
    using System.Xml;
    using Leet.Core.Diagnostics;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics; 

    /// <summary>
    /// Service configuration class. 
    /// </summary>
    public class Templates
    {
        /// <summary>
        /// Componenet name of Templates.
        /// </summary>
        public const string ComponentName = "Templates";

        /// <summary>
        /// The const format string for key in the hash table. 
        /// </summary>
        private const string KeyFormat = "{0}-{1}-{2}";

        /// <summary>
        /// The default locale.
        /// </summary>
        private const string DefaultLocale = "en-us"; 

        /// <summary>
        /// the dictionary that holds all the templates. 
        /// </summary>
        private Dictionary<string, string> templates;

        /// <summary>
        /// Initializes a new instance of the Templates class. 
        /// </summary>
        public Templates()
        {
            this.templates = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        }

        /// <summary>
        /// The allowed template types. 
        /// </summary>
        public enum TemplateType
        {
            /// <summary>
            /// The invite type template. 
            /// </summary>
            Invite = 0
        }

        /// <summary>
        /// The enum of template sections allowed. 
        /// </summary>
        public enum TemplateSection
        {
            /// <summary>
            /// The Body section. 
            /// </summary>
            Body = 0,

            /// <summary>
            /// The subject section. 
            /// </summary>
            Subject = 1,

            /// <summary>
            /// The section for friend request in email body. 
            /// </summary>
            FriendRequest = 2,
        }

        /// <summary>
        /// Get the template value. 
        /// </summary>
        /// <param name="templateType">The type of the template. </param>
        /// <param name="locale">The locale. </param>
        /// <param name="templateSection">The section of the template. </param>
        /// <returns>The template string. </returns>
        public string GetTemplate(TemplateType templateType, string locale, TemplateSection templateSection)
        {
            string key = string.Format(KeyFormat, templateType.ToString(), locale, templateSection.ToString());
            if (this.templates.ContainsKey(key))
            {
                return (string)this.templates[key];
            }
            else
            {
                key = string.Format(KeyFormat, templateType.ToString(), DefaultLocale, templateSection.ToString());
                return (string)this.templates[key];
            }
        }

        /// <summary>
        /// Initialize the hash table and read in the templates. 
        /// </summary>
        /// <param name="filePath">The full path of the template xml.</param>
        public void Initialize(string filePath)
        {
            try
            {
                XmlDocument doc = new XmlDocument();
                doc.Load(filePath);
                XmlElement root = doc.DocumentElement;
                XmlNodeList nodes = root.SelectNodes("//Templates//Template");

                foreach (XmlNode node in nodes)
                {
                    string templateType = node["TemplateType"].InnerText;
                    string locale = node["Locale"].InnerText;
                    string section = node["Section"].InnerText;
                    string value = node["Value"].InnerXml; // HTML email template
                    this.AddValue(templateType, locale, section, value);
                }
            }
            catch (System.IO.FileNotFoundException ex)
            {
                // Log an error event
                new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.InviteEmailTemplateNotFound,
                    System.Net.HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    ex.ToString());   
            }
            catch (Exception ex)
            {
                // catch all other exceptions
                new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.InviteEmailTemplateInitFailed,
                    System.Net.HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    ex.ToString());  
            }
        }

        /// <summary>
        /// Add a value to the template hash table. 
        /// </summary>
        /// <param name="typeName">The type name. </param>
        /// <param name="locale">The locale. </param>
        /// <param name="section">The section. </param>
        /// <param name="value">The value. </param>
        private void AddValue(string typeName, string locale, string section, string value)
        {
            try
            {
                TemplateType templateType = (TemplateType)Enum.Parse(typeof(TemplateType), typeName);
                TemplateSection templateSection = (TemplateSection)Enum.Parse(typeof(TemplateSection), section);
                string key = String.Format(KeyFormat, typeName, locale, section);
                this.templates.Add(key, value);
            }
            catch (System.ArgumentException ex)
            {
                // there is something wrong with the template. 
                Logging.TraceWarning("{0}: {1} {2}",
                    ComponentName,
                    "Failed to AddValue for type: " + typeName + ", locale: " + locale + ", section: " + section + ", value: " + value,
                    "Exception: " + ex.ToString());

                new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.InviteEmailTemplateDuplicatedEntries,
                    System.Net.HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    ex.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Email\NotificationSMTPProvider.cs ===

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Net;
    using System.Net.Mail;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using Leet.Core.Configuration;
    using NotificationCommon;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class NotificationSMTPProvider : INotificationProvider
    {
        /// <summary>
        /// Componenet name of NotificationSMTPProvider.
        /// </summary>
        public const string ComponentName = "NotificationSMTPProvider";

        /// <summary>
        /// The template of the smtp provider. 
        /// </summary>
        private static Templates emailTemplates = new Templates(); 

        /// <summary>
        /// The static object for configuration settings. 
        /// </summary>
        private static SMTPConfigs configInstance = new SMTPConfigs();

        /// <summary>
        /// The metadata client used to retrieve the game metadata. 
        /// </summary>
        private static IGameMetadataClient _gameMetadataClient;


        private static Action<MailMessage> _sendEmaildelegate;
        private static Func<uint, string, GameMetadataComposite> _gmsCallDelegate;
        private static Action<string, Exception, bool> _exceptionLogger;

        private static readonly List<Type> GmsretriableExceptionList = new List<Type>();
        private static readonly List<Type> SmtpRetriableExceptionList = new List<Type>();

        private const int RetryWaitInSec = 10;    // wait for 10 seconds before next retry

        // Number of times a dependency should be retried (SMTP)
        public static int RetryMax()
        {
            IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
            int retryDuration = configSettings.GetIntSetting(Settings.Notification_SMTPRetryDurationMin);
            int count = (retryDuration * 60 / RetryWaitInSec);
            return ((count == 0) ? 1 : count); // Try at least once.

        }

        /// <summary>
        /// Initializes a new instance of the NotificationSMTPProvider class. 
        /// </summary>
        public NotificationSMTPProvider()
        {
        }

        /// <summary>
        /// Gets the Email template of this SMTP provider. 
        /// </summary>
        public static Templates EmailTemplates
        {
            get { return emailTemplates; }
        }

        /// <summary>
        /// Gets the game metadata client. 
        /// </summary>
        public static IGameMetadataClient GmsClient
        {
            get { return _gameMetadataClient; }
        }

        /// <summary>
        /// Initializes the provider. This method will be called by the Coordinator only once. 
        /// Load the templates. 
        /// </summary>
        public void Initialize()
        {
            EmailTemplates.Initialize(configInstance.NotificationSMTPProvider_TemplatePath);
            
            string useFakeClientVal = ConfigurationManager.AppSettings["UseFakeClient"];
            if (string.IsNullOrEmpty(useFakeClientVal))
            {
                useFakeClientVal = "false";
            }

            // Register GameMetadataClient
            if (Boolean.Parse(useFakeClientVal.Trim().ToLower()))
            {
                Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            }
            else
            {
                GameMetadataClient.RegisterContainerServices();
            }

            // register the interfaces
            _gameMetadataClient = Container.Instance.GetComponent<IGameMetadataClient>();
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.CommunicationException));
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.EndpointNotFoundException));
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.ServerTooBusyException));
            var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
            _gmsCallDelegate = gmsClient.GetGameMetadata;
       
            SmtpRetriableExceptionList.Add(typeof(SmtpException));
            SmtpRetriableExceptionList.Add(typeof(InvalidOperationException));
            _sendEmaildelegate = this.SendEmail;

            _exceptionLogger = HandleException;
         }

        /// <summary>
        /// Process one notification request. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        public void ProcessNotificationRequest(NotificationRequest request)
        {
            List<MailMessage> mailList = new List<MailMessage>();

            try
            {
                Logging.TraceVerbose("{0}: {1}",
                        ComponentName,
                        "ProcessNotificationRequest(): request=" + request.RequestId);

                Notification.NotificationType type = (Notification.NotificationType)Enum.ToObject(
                    typeof(Notification.NotificationType),
                    request.RequestDataType);

                Notification notification = Notification.DeserializeFromString(request.RequestData, type);
                var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
                GameMetadataComposite gmc = RetryController.RetryFunc(RetryMax, RetryWaitInSec, GmsretriableExceptionList,
                                        (Exception ex, bool retriable) => _exceptionLogger("Calling GMS", ex, retriable),
                                        () => _gmsCallDelegate(notification.GameId, request.RequestLocale));
                if (gmc != null)
                {
                    notification.SupportedPlatform = (int)gmc.SupportedPlatformsBitMask;
                }

                INotificationEmailComposer nec = NotificationEmailComposerFactory.GetEmailComposer(type);
                if (nec == null)
                {
                    Logging.TraceWarning("{0}: {1}",
                        ComponentName,
                        "No email composer for notification type:" + type + ". Skipping sending emails from (" + request.From + ") to (" + request.To + ").");

                    return;
                }

                mailList = nec.ComposeEmails(
                    request,
                    new MailAddress(configInstance.NotificationSMTPProvider_EmailAddress, configInstance.NotificationSMTPProvider_DisplayName));

                if (mailList.Count > 0)
                {
                    foreach (MailMessage mail in mailList)
                    {
                           // RetryController will only retry if this is an exception listed in RetriableExceptionList
                            RetryController.Retry(RetryMax,
                            RetryWaitInSec,
                            SmtpRetriableExceptionList,
                            (Exception ex, bool retriable) => _exceptionLogger("Calling SMTP SendEmail", ex, retriable),
                            () => _sendEmaildelegate(mail));
                      
                    }

                    NotificationAuditLog.UpdateTrackingState(NotificationAuditState.EmailSent, request);
                }
            }
            catch (Exception ex)
            {
                // catch all exceptions so the NT service will keep running.
                Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "Failed to process notification request! request.RequestData=" + request.RequestData,
                    "Exception: " + ex.ToString());

                if (request != null)
                {
                    NotificationAuditLog.UpdateTrackingState(NotificationAuditState.Error, request);
                }
             
            }
            finally
            {
                // clean up unmanaged resources (i.e. streams in LinkedResources)
                foreach (MailMessage mail in mailList)
                {
                    mail.Dispose();
                }
            }
        }

        public static void HandleException(string message, Exception exception, bool retriable)
        {
            if (retriable)
            {
                NotificationsDiag.Logging.LogEvent(new RetriableError(), exception, message, null);
            }

        }

        /// <summary>
        /// This method sends an email notification to the list of receipients
        /// with the specified subject and body. The email is sent by using
        /// the Notification Account credentials.
        /// </summary>
        /// <param name="mail">
        ///     Specifies the mail to send.
        /// </param>
        private void SendEmail(
            MailMessage mail)
        {
            Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "Entering SendEmail()...");

            SmtpClient client = new SmtpClient();
            client.Host = configInstance.NotificationSMTPProvider_HostName;
            if (!string.IsNullOrEmpty(configInstance.NotificationSMTPProvider_Domain))
            {
                NetworkCredential credentials = new NetworkCredential(
                    configInstance.NotificationSMTPProvider_Account,
                    configInstance.NotificationSMTPProvider_Password,
                    configInstance.NotificationSMTPProvider_Domain);

                client.Credentials = credentials;
            }

            try
            {
                Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "Sending email from (" + mail.From.Address + ") to (" + mail.To[0].Address + ")...");

                client.Send(mail);

                Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "Email sent from (" + mail.From.Address + ") to (" + mail.To[0].Address + ")!");
            }
            catch (System.InvalidOperationException ex)
            {
                // This System.Net.Mail.SmtpClient has a Overload:System.Net.Mail.SmtpClient.SendAsync
                // call in progress.-or- System.Net.Mail.SmtpClient.Host is null.-or-System.Net.Mail.SmtpClient.Host
                // is equal to the empty string ("").-or- System.Net.Mail.SmtpClient.Port is
                // zero.
                // log an event for error consolidation and monitoring
                NotificationsDiag.Logging.LogEvent(new SmtpServerInvalidOperation(), ex);
                throw;

            }
            catch (System.Net.Mail.SmtpException ex)
            {
                // log an event for error consolidation and monitoring
                NotificationsDiag.Logging.LogEvent(new SmtpServerConnectionError(), ex);
                throw;

            }

            Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "Leaving SendEmail().");

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\MobilePush\NotificationLite.cs ===


namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Xml.Serialization;
    using AsyncMultiplayer.NotificationService;

    /// <summary>
    /// Class to hold Notification Lite object for Push Tickle.
    /// </summary>
    [Serializable]
    [XmlRoot(ElementName = "Notification")]
    public class NotificationLite
    {
        [XmlAttribute]
        public string Id { get; set; }
        [XmlAttribute]
        public DateTime Expiration { get; set; }
        [XmlAttribute]
        public DateTime Sent { get; set; }
        [XmlAttribute]
        public string FromGamerTag { get; set; }
        [XmlAttribute]
        public string FromDisplayName { get; set; }
        [XmlAttribute]
        public string GameDisplayName { get; set; }
        [XmlAttribute]
        public uint GameId { get; set; }
        [XmlAttribute]
        public string ImageUrl { get; set; }
        [XmlAttribute]
        public string SessionId { get; set; }
        [XmlAttribute]
        public Notification.NotificationStatus Status { get; set; }
        [XmlAttribute]
        public Notification.NotificationType Type { get; set; }
        [XmlAttribute]
        public string TypeDisplayName { get; set; }
        [XmlAttribute]
        public string Url { get; set; }
        [XmlAttribute]
        public string DataBlob { get; set; }
        
        public NotificationLite()
        {}

        public NotificationLite(Notification notification, UserInfo sender, string gameDisplayName, string imageUrl, string redirectUrl)
        {
            Id = notification.Id;
            Expiration = notification.ExpirationTime;
            Sent = notification.SentTime;
            FromGamerTag = sender.GamerTag;
            FromDisplayName = sender.DisplayName;
            GameDisplayName = gameDisplayName;
            GameId = notification.GameId;
            ImageUrl = imageUrl;
            SessionId = notification.SessionId;
            Status = notification.Status;
            Type = notification.Type;
            TypeDisplayName = notification.TypeDisplayName;
            Url = redirectUrl;
            DataBlob = notification.DataBlob;
        }

    }

    [Serializable]
    [XmlRoot(ElementName = "Info")]
    public class PushData
    {
        [XmlAttribute]
        public string DataSource;
        [XmlAttribute]
        public bool FetchRequired;
        [XmlElement(ElementName = "Notification",
            IsNullable = true)]
        public NotificationLite Notification;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Feed\NotificationFeedProvider.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationFeedProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The Dummy Feed Provider. This is a place holder. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/19/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Net; 
    using System.Text;
    using System.Xml.Serialization;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class NotificationFeedProvider : INotificationProvider
    {
        /// <summary>
        /// Initializes a new instance of the NotificationFeedProvider class. 
        /// </summary>
        public NotificationFeedProvider()
        {
        }

        /// <summary>
        /// Initializes the provider. 
        /// </summary>
        public void Initialize()
        {
        }

        /// <summary>
        /// Process one notification request. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        public void ProcessNotificationRequest(NotificationRequest request)
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\MobilePush\NotificationPushDiag.cs ===


namespace AsyncMultiplayer.NotificationService
{
    using System.Diagnostics;
    using Leet.Core.Diagnostics;

    public class MpnsCertNotFound : BaseEvent
    {
        public MpnsCertNotFound()
            : base(8021, TraceEventType.Error, "HTTPS Cert needed for mutual auth with MPNS missing")
        {
        }
    }
    public class MpnsCertMultFound : BaseEvent
    {
        public MpnsCertMultFound()
            : base(8022, TraceEventType.Error, "Mutliple HTTPS Cert needed for mutual auth with MPNS were found on the server")
        {
        }
    }

    public class SendPushFailedUnexpected : BaseEvent
    {
        public SendPushFailedUnexpected()
            : base(8023, TraceEventType.Warning, "Unable to send push notification")
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Storage\NotificationStorageProvider.cs ===

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using System.Collections.Generic;
    using Leet.Core.Configuration;
    using NotificationCommon;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class NotificationStorageProvider : INotificationProvider
    {
        /// <summary>
        /// The display name of the component for tracing. 
        /// </summary>
        private const string ComponentName = "NotificationStorageProvider";

        /// <summary>
        /// The delimiter characters. 
        /// </summary>
        private static readonly string[] UserDelimitor = new string[] { ";" };


        private const int RetryWaitInSec = 10;    // wait for 10 seconds before next retry

        private static Func<uint, string, GameMetadataComposite> _gmsCallDelegate;

        private static readonly List<Type> GmsretriableExceptionList = new List<Type>();
        private static readonly List<Type> AzureretriableExceptionList = new List<Type>();

        private static Action<string, Exception, bool> _exceptionLogger;

        /// <summary>
        /// The title id for Xbox LIVE Extras app. 
        /// </summary>
        private const uint XboxLiveExtrasTitleId = 1297287404;

        /// <summary>
        /// The number of notifications to look through to see if a user has a Friend Request\Message notification
        /// </summary>
        private const int NotificationCount = 50; //it is very less likely that a user will have more than 50 notifications at a time and this will fix bug 11098 99% of the time.

        /// <summary>
        /// Gets the value of the current notificaiton storage.
        /// </summary>
        private INotificationStorage NotificationStorage
        {
            get
            {
                return StorageSingleton.NotificationStorage;
            }
        }

        /// <summary>
        /// Gets the value fo the current user data storage. 
        /// </summary>
        public static UserDataAzureStorage UserDataStorage
        {
            get
            {
                return StorageSingleton.UserDataStorage;
            }
        }


        // Number of times a dependency - Azure, and GMS should be retried when a retriable failure is encountered
        public static int RetryMax()
        {
            IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
            int retryDuration = configSettings.GetIntSetting(Settings.Notification_DependencyRetryDurationMin);
            int count = (retryDuration*60/RetryWaitInSec);
            return ((count == 0) ? 1 : count); // Try at least once.

        }

        /// <summary>
        /// Initializes the storage provider. 
        /// </summary>
        public void Initialize()
        {
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.CommunicationException));
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.EndpointNotFoundException));
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.ServerTooBusyException));
            var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
            _gmsCallDelegate = gmsClient.GetGameMetadata;
            AzureretriableExceptionList.Add(typeof(LIVEnException));

            _exceptionLogger = HandleException;
        }

        /// <summary>
        /// Process one notification request. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        public void ProcessNotificationRequest(NotificationRequest request)
        {
            Logging.TraceVerbose( "{0}: {1}", ComponentName, "ProcessNotificationRequest(): request=" + request.RequestId);

            NotificationRequest.ActionType actionType = request.Action;

            switch (actionType)
            {
                case NotificationRequest.ActionType.Delete:
                    this.DeleteNotification(request);
                    break;
                case NotificationRequest.ActionType.Create:
                    this.SaveNotification(request);
                    break;
                default:
                    throw new InvalidOperationException(
                        string.Format("Invalid RequestType {0} is not supported in storage provider", actionType));
            }
        }

        /// <summary>
        /// Save a notification to the storage. This is to process Create action. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        private void SaveNotification(NotificationRequest request)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "SaveNotification(): request=" + request.RequestId);

            Notification.NotificationType requestDataType = (Notification.NotificationType) Enum.ToObject(
                                                                                                typeof (
                                                                                                    Notification.
                                                                                                    NotificationType),
                                                                                                request.RequestDataType);
            Notification notification = Notification.DeserializeFromString(request.RequestData, requestDataType);

            // SLS Messaging specific logic to avoid doing the Game Service lookups
            if (!notification.Variant.Equals(Notification.SLSNotificationFlag))
            {
                var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
                GameMetadataComposite gmc = new GameMetadataComposite();

                gmc = RetryController.RetryFunc(RetryMax, RetryWaitInSec, GmsretriableExceptionList,
                                            (Exception ex, bool retriable) => _exceptionLogger("Calling GMS", ex, retriable),
                                            () => _gmsCallDelegate(notification.GameId, request.RequestLocale));

                if (gmc != null)
                {
                    notification.SupportedPlatform = (int)gmc.SupportedPlatformsBitMask;
                }
            }

            if (requestDataType == Notification.NotificationType.FriendRequest)
            {
                // Special handling for friend notification, overloaded with message (Both sent from front end)
                FriendRequestNotification newNotification = notification as FriendRequestNotification;
                this.SaveSpecialNotification(newNotification);
            }
            else
            {
                foreach (UserInfo user in request.RecipientsInfo)
                {

                    if (user.Xuid == 0)
                    {
                        continue;
                    }

                    notification.UserId = user.Xuid.ToString();
                    RetryController.RetryFunc(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                              (Exception ex, bool retriable) =>
                                              _exceptionLogger("Calling Azure SaveNotification", ex, retriable),
                                              () => this.NotificationStorage.SaveNotification(
                                                        notification.UserId,
                                                        (uint) request.GameId,
                                                        request.SessionId,
                                                        notification));

                    RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                          (Exception ex, bool retriable) =>
                                          _exceptionLogger("Calling Azure UpdateUserDataTimeStamp", ex, retriable),
                                          () =>
                                          UserDataStorage.UpdateUserDataTimeStamp(notification.UserId));


                }
            }

            // Update the audit record for this notification
            NotificationAuditLog.UpdateTrackingState(NotificationAuditState.WrittenToStorage, request);
        }

        /// <summary>
        /// Save a Friend or message notification to the storage if one not present yet. 
        /// </summary>
        /// <param name="newNotification">The new notification. </param>
        private void SaveSpecialNotification(FriendRequestNotification newNotification)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "SaveSpecialNotification(): userId=" + newNotification.UserId);

            
                // Find out if there there is incoming friend/message request from the new notification
                bool friendRequestPending = newNotification.FriendRequestPresent;
                bool messageWaiting = newNotification.MessageWaiting;

                // check if there is already a friend/message request notification
                Notification currentFriendNotification = null;
                Notification currentMesssageNotification = null;
                NotificationQueryParameter queryParameter = new NotificationQueryParameter();
                queryParameter.UserId = newNotification.UserId;
                queryParameter.Category = (int)Notification.NotificationCategory.ToDo;
                queryParameter.Count = NotificationCount;
                NotificationList userNotifications = 
                    RetryController.RetryFunc(RetryMax, RetryWaitInSec,
                                               AzureretriableExceptionList,
                                               (Exception ex, bool retriable) =>
                                               _exceptionLogger(
                                                   "Calling Azure SaveSpecialNotification:Query",
                                                   ex, retriable),
                                               () =>
                                               this.NotificationStorage.QueryNotifications(
                                                   queryParameter));
                if (userNotifications != null)
                {
                    // Find the first friend notification and message notification
                    foreach (Notification n in userNotifications)
                    {
                        if (n.Type == Notification.NotificationType.FriendRequest)
                        {
                            currentFriendNotification = n;
                            if (currentMesssageNotification != null)
                            {
                                // found both, no need to continue
                                break;
                            }
                        }
                        else if (n.Type == Notification.NotificationType.Message)
                        {
                            currentMesssageNotification = n;
                            if (currentFriendNotification != null)
                            {
                                // found both, no need to continue
                                break;
                            }
                        }
                    }
                }

                // the user doesn't have friend notification, and there are incoming friends requests
                if ((currentFriendNotification == null) && (friendRequestPending == true))
                {

                    // Check if we need to set the titleId to Xbox Live Extras (Live App)
                    IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                    if (configSettings.GetBoolSetting(Settings.Notification_FRGameIdIsLivApp))
                    {
                        newNotification.DataBlob = "FriendRequest";
                        newNotification.GameId = XboxLiveExtrasTitleId;
                    }
                    // send a new friend notification.
                    RetryController.RetryFunc(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                              (Exception ex, bool retriable) =>
                                              _exceptionLogger("Calling Azure SaveSpecialNotification:SaveNotification", ex, retriable),
                                              () => this.NotificationStorage.SaveNotification(
                                                        newNotification.UserId,
                                                        0,
                                                        string.Empty,
                                                        newNotification));

                    RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                              (Exception ex, bool retriable) =>
                                              _exceptionLogger("Calling Azure SaveSpecialNotification:UpdateUserDataTimeStamp", ex, retriable),
                                              () => UserDataStorage.UpdateUserDataTimeStamp(newNotification.UserId));

                  }
                else if ((currentFriendNotification != null) && (friendRequestPending == false))
                {
                    // Delete the existing stale friend notifications
                    this.NotificationStorage.DeleteNotification(newNotification.UserId, currentFriendNotification.Id);
                    UserDataStorage.UpdateUserDataTimeStamp(newNotification.UserId);
                }

                // the user doesn't have message notification, and there are messages waiting
                if ((currentMesssageNotification == null) && (messageWaiting == true))
                {
                    // Create a new message notification
                    MessageNotification messageNotification = new MessageNotification();
                    messageNotification.From = newNotification.From;
                    messageNotification.UserId = newNotification.UserId;
                    messageNotification.DataBlob = "Message";
                    messageNotification.GameId = XboxLiveExtrasTitleId;

                    // send the new message notification.


                    RetryController.RetryFunc(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                              (Exception ex, bool retriable) =>
                                              _exceptionLogger("Calling Azure SaveSpecialNotification:SaveNotification", ex, retriable),
                                              () => this.NotificationStorage.SaveNotification(
                                                        newNotification.UserId,
                                                        0,
                                                        string.Empty,
                                                        messageNotification));


                    RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                          (Exception ex, bool retriable) =>
                                          _exceptionLogger("Calling Azure SaveSpecialNotification:UpdateUserDataTimeStamp", ex, retriable),
                                          () => UserDataStorage.UpdateUserDataTimeStamp(newNotification.UserId));



                }
                else if ((currentMesssageNotification != null) && (messageWaiting == false))
                {
                    // Delete the existing stale message notification
                    RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                          (Exception ex, bool retriable) =>
                                          _exceptionLogger("Calling Azure SaveSpecialNotification:DeleteNotification",
                                                           ex, retriable),
                                          () =>
                                          this.NotificationStorage.DeleteNotification(newNotification.UserId,
                                                                                      currentMesssageNotification.Id));
                    RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                          (Exception ex, bool retriable) =>
                                          _exceptionLogger(
                                              "Calling Azure SaveSpecialNotification:UpdateUserDataTimeStamp", ex,
                                              retriable),
                                          () => UserDataStorage.UpdateUserDataTimeStamp(newNotification.UserId));
                }
        }

        /// <summary>
        /// Delete notification(s) from the storage. This is to process Delete actions. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        private void DeleteNotification(NotificationRequest request)
        {
            Logging.TraceVerbose("{0}: {1}", ComponentName, "DeleteNotification(): request=" + request.RequestId);

            // RequestData is a serialized NotificationQueryParameter object
            NotificationQueryParameter queryParameter = Notification.DeserializeFromString<NotificationQueryParameter>(request.RequestData);
            string[] receipientList = request.To.Split(UserDelimitor, StringSplitOptions.RemoveEmptyEntries);
            foreach (string recipient in receipientList)
            {

                ulong xuid = 0;
                ulong.TryParse(recipient, out xuid);
                if (xuid == 0)
                {
                    continue;
                }
                RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                      (Exception ex, bool retriable) =>
                                      _exceptionLogger("Calling Azure DeleteNotification", ex, retriable),
                                      () =>
                                      this.NotificationStorage.DeleteNotification(xuid.ToString(), queryParameter));
                RetryController.Retry(RetryMax, RetryWaitInSec, AzureretriableExceptionList,
                                      (Exception ex, bool retriable) =>
                                      _exceptionLogger("Calling Azure SaveSpecialNotification:UpdateUserDataTimeStamp",
                                                       ex, retriable),
                                      () =>
                                      UserDataStorage.UpdateUserDataTimeStamp(xuid.ToString()));

            }

            // Update the audit record for this notification
            NotificationAuditLog.UpdateTrackingState(NotificationAuditState.DeletedFromStorage, request);
        }

        public static void HandleException(string message, Exception exception, bool retriable)
        {
            if (retriable)
            {
                NotificationsDiag.Logging.LogEvent(new RetriableError(), exception, message,null);
            }
          
        }
        /// <summary>
        /// Class to hold singleton notification storage.
        /// </summary>
        private class StorageSingleton
        {
            /// <summary>
            /// A static storage configuration instance. 
            /// </summary>
            internal static readonly StorageConfigs ConfigInstance;

            /// <summary>
            /// Interface to the current notification storage.
            /// </summary>
            internal static readonly INotificationStorage NotificationStorage;

            /// <summary>
            /// The current user data storage. 
            /// </summary>
            internal static readonly UserDataAzureStorage UserDataStorage;

            /// <summary>
            /// Initializes static members of the StorageSingleton class.
            /// </summary>
            static StorageSingleton()
            {
                ConfigInstance = new StorageConfigs();

                NotificationStorage = new NotificationAzureStorage(
                    ConfigInstance.AzureTableStorageEndPoint,
                    ConfigInstance.AzureStorageAccount,
                    ConfigInstance.AzureStorageToken,
                    ConfigInstance.ProxyAddress);

                UserDataStorage = new UserDataAzureStorage(
                    ConfigInstance.AzureTableStorageEndPoint,
                    ConfigInstance.AzureStorageAccount,
                    ConfigInstance.AzureStorageToken,
                    ConfigInstance.ProxyAddress);

                return;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\MobilePush\NotificationSenderUtility.cs ===


using System.Security.Cryptography.X509Certificates;

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.IO;
    using System.Net;
    using System.Text;
    using Leet.Core.Diagnostics;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;

    #region NotificationType Enum
    public enum NotificationType
    {
        Token = 1,
        Toast = 2,
        Raw = 3
    }
    #endregion

    public class MPNSResponse
    {
        public MPNSResponse(HttpWebResponse response)
        {
            Timestamp = DateTimeOffset.Now;
            MessageId = response.Headers[NotificationSenderUtility.MessageIdHeader];
            ChannelUri = response.ResponseUri.ToString();
            StatusCode = response.StatusCode;
            NotificationStatus = response.Headers[NotificationSenderUtility.NotificationStatusHeader];
            DeviceConnectionStatus = response.Headers[NotificationSenderUtility.DeviceConnectionStatusHeader];
            SubscriptionStatus = response.Headers[NotificationSenderUtility.SubscriptionStatusHeader];
        }

        public DateTimeOffset Timestamp { get; private set; }
        public string MessageId { get; private set; }
        public string ChannelUri { get; private set; }
        public NotificationType NotificationType { get; private set; }
        public HttpStatusCode StatusCode { get; private set; }
        public string NotificationStatus { get; private set; }
        public string DeviceConnectionStatus { get; private set; }
        public string SubscriptionStatus { get; private set; }

        public bool IsSubscriptionExpired()
        {
            return SubscriptionStatus.Equals("Expired", StringComparison.InvariantCultureIgnoreCase);
        }

        public bool IsDelivered()
        {
            return ((StatusCode == HttpStatusCode.OK) &&
                    NotificationStatus.Equals("Received", StringComparison.InvariantCultureIgnoreCase));
        }

        public bool IsQueueFull()
        {
            return ((StatusCode == HttpStatusCode.OK) &&
                    NotificationStatus.Equals("QueueFull", StringComparison.InvariantCultureIgnoreCase));
        }

        public string DeliveryStatus()
        {
            return
                String.Format(
                    "PushUrl:{0}, MessageId:{1}, NotificationStatus:{2}, DeviceConnectionStatus:{3}, SubscriptionStatus:{4}",
                    ChannelUri, MessageId, NotificationStatus, DeviceConnectionStatus, SubscriptionStatus);
        }
                
    }
 
    public class NotificationSenderUtility
    {
      
        #region Local constants
        public const string MessageIdHeader = "X-MessageID";
        public const string NotificationClassHeader = "X-NotificationClass";
        public const string NotificationStatusHeader = "X-NotificationStatus";
        public const string DeviceConnectionStatusHeader = "X-DeviceConnectionStatus";
        public const string SubscriptionStatusHeader = "X-SubscriptionStatus";
        public const string WindowsphoneTargetHeader = "X-WindowsPhone-Target";
        public static int MaxPayloadLength;
        public string Proxy;

        public NotificationSenderUtility(string proxyServer)
        {
            Proxy = proxyServer;
            IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
            MaxPayloadLength = configSettings.GetIntSetting(Settings.NotificationInternal_PushPayloadMax);
        }
       

        #endregion
       
        #region SendXXXNotification functionality
        public MPNSResponse SendRawNotification(Uri uri, byte[] payload,X509Certificate2 cert)
        {
            return SendMessage(uri, payload, NotificationType.Raw, cert);
        }

        #endregion
       

        #region Send Message to Microsoft Push Service
        private MPNSResponse SendMessage(Uri channelUri, byte[] payload, NotificationType notificationType, X509Certificate cert)
        {
            //Check the length of the payload and reject it if too long
            if (payload.Length > MaxPayloadLength)
                throw new ArgumentOutOfRangeException("Payload is too long. Maximum payload size shouldn't exceed " +
                                                      MaxPayloadLength + " bytes");
            if ((channelUri.Scheme == Uri.UriSchemeHttps) && (cert == null))
            {
                throw new ArgumentException("Certificate cannot be null for HTTPS scehme");
            }

            Logging.TraceVerbose("Sending: {0}", Encoding.UTF8.GetString(payload));
            try
            {
                //Create and initialize the request object
                HttpWebRequest request = (HttpWebRequest) WebRequest.Create(channelUri);
                request.Proxy = new WebProxy(Proxy);
                request.Method = WebRequestMethods.Http.Post;
                request.ContentType = "text/xml; charset=utf-8";
                request.ContentLength = payload.Length;
                request.Headers[MessageIdHeader] = Guid.NewGuid().ToString();
                request.Headers[NotificationClassHeader] = ((int) notificationType).ToString();

                if (channelUri.Scheme == Uri.UriSchemeHttps)
                {
                    // Add the client certificate
                    request.ClientCertificates.Add(cert);
                }

                if (notificationType == NotificationType.Toast)
                    request.Headers[WindowsphoneTargetHeader] = "toast";
                else if (notificationType == NotificationType.Token)
                    request.Headers[WindowsphoneTargetHeader] = "token";

                using (Stream stream = request.GetRequestStream())
                {
                    stream.Write(payload, 0, payload.Length);
                }
                var response = (HttpWebResponse) request.GetResponse();
                return new MPNSResponse(response);
            }
            catch (WebException ex)
            {
                if (ex.Status == WebExceptionStatus.ProtocolError)
                {
                    return new MPNSResponse((HttpWebResponse) ex.Response);
                }

                throw;
            }

        }
        

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\Storage\StorageConfigs.cs ===
//-------------------------------------------------------------------
// <copyright file="StorageConfigs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Storage Provider  Related Configurations. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/23/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Data;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;

    /// <summary>
    /// Service configuration class. 
    /// </summary>
    public class StorageConfigs
    {
        /// <summary>
        /// Gets the Azure storage account
        /// </summary>
        public string AzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token
        /// </summary>
        public string AzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the Azure table storage access endpoint.
        /// </summary>
        public string AzureTableStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureTableStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure blob storage access endpoint. 
        /// </summary>
        public string AzureBlobStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureBlobStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure queue storage access point. 
        /// </summary>
        public string AzureQueueStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureQueueStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the retry count to access Azure 
        /// </summary>
        public int AzureRetryCount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.AzureRetryCount);
            }
        }

        /// <summary>
        /// Gets the proxy address for the environment. 
        /// </summary>
        public string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\PreProcess\CreatePreProcessor.cs ===
//-------------------------------------------------------------------
// <copyright file="CreatePreProcessor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The Preprocessor of creating a notification. The purpose of this stage is to lookup all the required
//  information about the notification here only once. Notification request could be send to multiple users. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/19/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Mail;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Xml.Serialization;
    using GameMetadata.Client;
    using GameMetadata.Common;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Live.Livecache.Logic.Profile;
    using Leet.Live.Livecache.Providers;
    using Leet.Profile;
    using Leet.UserGameData.DataContracts;
    using Leet.Utils;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class CreatePreProcessor : INotificationProvider
    {
        /// <summary>
        /// The prefix to a gamertag recipient in a notification. 
        /// </summary>
        public const string GamertagPrefix = "gamertag:";

		/// <summary>
		/// The prefix to a xuid recipient in a notification. 
		/// </summary>
		public const string XuidPrefix = "xuid:";

        /// <summary>
        /// The optional prefix to an email recipient in a notification. 
        /// </summary>
        public const string EmailPrefix = "email:";

        /// <summary>
        /// The default locale of the system. 
        /// </summary>
        private const string DefaultLocale = "en-US";

        /// <summary>
        /// The display name of the component. 
        /// </summary>
        private const string ComponentName = "CreatePreProcessor";

        /// <summary>
        /// The delimiter characters. 
        /// </summary>
        private static readonly string[] userDelimitor = new string[] { ";" };

        /// <summary>
        /// The sender info of the system. 
        /// </summary>
        private static UserInfo systemSenderInfo;

        /// <summary>
        /// Initializes a new instance of the CreatePreProcessor class. 
        /// </summary>
        public CreatePreProcessor()
        {
        }

        /// <summary>
        /// Gets the profile provider. 
        /// </summary>
        public static IProfileProvider ProfileClient
        {
            get
            {
                return Container.Instance.GetComponent<IProfileProvider>();
            }
        }

        /// <summary>
        /// Gets the maximum allowed recipient count in the inivte. 
        /// </summary>
        public static int NotificationSMTPProvider_MaxRecipientCount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationSMTPProvider_MaxRecipientCount);
            }
        }

        /// <summary>
        /// Gets the email address of the system mail sender. 
        /// </summary>
        public static string SystemSender_EmailAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationSMTPProvider_EmailAddress);
            }
        }

        /// <summary>
        /// Initializes the provider.
        /// We actually didn't enforce this to be called by one thread or only initialize once. In the same 
        /// environment, the result should be all the same. Of course, it is better the caller garantee that
        /// Initialize is called only once in a single thread. 
        /// </summary>
        public void Initialize()
        {
            string useFakeClientVal = ConfigurationManager.AppSettings["UseFakeClient"];
            string serviceConfigName = ConfigurationManager.AppSettings["ServiceConfigName"];
            if (string.IsNullOrEmpty(useFakeClientVal))
            {
                useFakeClientVal = "false";
            }

            // Register GameMetadataClient
            if (Boolean.Parse(useFakeClientVal.Trim().ToLower()))
            {
                Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            }
            else
            {
                GameMetadataClient.RegisterContainerServices();
            }

            // register the interfaces
            Leet.Core.IoCCo.Container.Instance.AddService<Leet.Live.Livecache.Providers.IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>(); // this looks nasty but this is needed for ILcPresence which is used by IPresenceDataAccess
            LeetLivecacheClient.RegisterServiceInterfacesAndInitialize(serviceConfigName);
            Container.Instance.SetLifeCycleForService<xonline.common.webplatform.livecache.ILcPresence>(LifeCycleMode.Singleton); //ILcPresence is PerWebRequestInstance and we dont have a webContext here in the NT Service and so we change the Lifecycle mode to Singleton
            ProfileProvider.RegisterWithIocContainer(Container.Instance, serviceConfigName);
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            systemSenderInfo = new UserInfo(0);

            systemSenderInfo.DisplayName = string.Empty;
            systemSenderInfo.EmailAddress = SystemSender_EmailAddress;
            systemSenderInfo.GamerTag = "Xbox LIVE";
        }

        /// <summary>
        /// Process one notification request. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        public void ProcessNotificationRequest(NotificationRequest request)
        {
            Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "ProcessNotificationRequest(): request=" + request.RequestId);

            Notification.NotificationType requestDataType = (Notification.NotificationType)Enum.ToObject(
                typeof(Notification.NotificationType),
                request.RequestDataType);

            switch (requestDataType)
            {
                case Notification.NotificationType.Invitation:
                    this.ProcessInviteRequest(request);
                    this.ProcessRecipientsInEmail(request);
                    break;
                case Notification.NotificationType.FriendRequest:
                    this.ProcessSenderInXuid(request);
                    this.ProcessNotificationRecipients(request);
                    this.ProcessIncomingFriendRequest(request);
                    break;
                default:
                    this.ProcessSenderInXuid(request);
                    this.ProcessNotificationRecipients(request);
                    break;
            }
        }

        /// <summary>
        /// Check if the input email address is valid. 
        /// </summary>
        /// <param name="email">The email address to check. </param>
        /// <returns>True if valid; Otherwise false.</returns>
        private static bool IsValidEmailAddress(string email)
        {
            if (String.IsNullOrEmpty(email))
            {
                return false;
            }

            MailAddress address = null;
            try
            {
                address = new MailAddress(email);
            }
            catch
            {
                Logging.TraceVerbose("{0}: {1}", ComponentName, "The email address:", email, " is not valid.");
            }

            return address != null;
        }

        /// <summary>
        /// Create userInfo to From field based on the passed in Xuid. This is the common path except for invitations. 
        /// Request and its payload might be changed after this method. 
        /// </summary>
        /// <param name="orgRequest">The original notification request. </param>
        private void ProcessSenderInXuid(NotificationRequest orgRequest)
        {
            Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "ProcessSenderInXuid(): request=" + orgRequest.RequestId,
                    " SenderXuid=" + orgRequest.From);

            Notification.NotificationType type = (Notification.NotificationType)Enum.ToObject(typeof(Notification.NotificationType), orgRequest.RequestDataType);
            ulong senderXuid = 0;
            try
            {
				senderXuid = ulong.Parse(orgRequest.From);
            }
            catch (FormatException)
            {
                Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "Failed to parse sender to Xuid",
                    orgRequest.From);
                throw new LIVEnException("Invalid Sender info in request " + orgRequest.From);
            }

            UserInfo fromInfo;
            if (senderXuid == 0)
            {
                fromInfo = systemSenderInfo;
            }
            else
            {
                UserIdentity senderIdentity = new UserIdentity(senderXuid);
                fromInfo = new UserInfo(senderXuid);
                fromInfo.GamerTag = senderIdentity.Gamertag;

                // get the display name from profile. 
                this.UpdateSenderInfo(fromInfo, orgRequest.RequestLocale);
            }

            Notification notification = Notification.DeserializeFromString(orgRequest.RequestData, type);
            orgRequest.SenderInfo = fromInfo;
            notification.From = Notification.SerializeToString(orgRequest.SenderInfo);
            orgRequest.RequestData = Notification.SerializeToString(notification);
        }

        /// <summary>
        /// Update Sender's display name based on sender's privacy setting. 
        /// </summary>
        /// <param name="senderInfo">The sender of the request. </param>
        /// <param name="locale">The locale of the user. </param>
        /// <returns>true if sender info is updated. </returns>
        private bool UpdateSenderInfo(UserInfo senderInfo, string locale)
        {
            LIVEnServiceMobileExtendedAuthDataProvider.Puid = senderInfo.Xuid;
            UserIdentity identity = new UserIdentity(senderInfo.Xuid);
            identity.IsAuthenticated = true;

            bool partialResult;
            IReadOnlyFriendInfo[] friendsInfoList = null;
            Leet.UserGameData.DataContracts.Profile profile = null;

            try
            {
                profile = ProfileClient.GetProfile(identity, locale, (long)ProfileSections.XboxLiveProperties, out friendsInfoList, out partialResult);
            }
            catch (Exception ex)
            {
                Logging.TraceException(ex, "Failed to populate user profile");
            }

            bool senderInfoUpdated = false;
            if ((profile != null) && (profile.ProfileProperties != null) && (profile.ProfileProperties.ContainsKey(ProfileProperty.Name)))
            {
                object privacyValue;
                if (profile.ProfileProperties.TryGetValue(ProfileProperty.ShowGamerProfile, out privacyValue))
                {
                    if ((int)privacyValue == (int)Leet.Live.Livecache.Logic.Profile.PrivilegeValue.Allow)
                    {
                        senderInfo.DisplayName = (string)profile.ProfileProperties[ProfileProperty.Name];
                        senderInfoUpdated = true;
                    }
                }
            }

            return senderInfoUpdated;
        }

        /// <summary>
        /// Preprocess the notification request. This is the place to do all the lookups
        /// fill out the right fields. 
        /// </summary>
        /// <param name="orgRequest">The original request. </param>
        private void ProcessInviteRequest(NotificationRequest orgRequest)
        {
            Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "ProcessInviteRequest(): request=" + orgRequest.RequestId,
                    " SenderInfo=" + orgRequest.From);

            orgRequest.SenderInfo = Notification.DeserializeFromString<UserInfo>(orgRequest.From);
            var xcache = Container.Instance.GetComponent<IXCacheDataAccess>();
            ulong xuid = 0;
            if (xcache.GetPuidByGamerTag(orgRequest.SenderInfo.GamerTag, out xuid))
            {
                // Update Sender's DisplayName based on privacy setting
                orgRequest.SenderInfo.Xuid = xuid;
                if (this.UpdateSenderInfo(orgRequest.SenderInfo, orgRequest.RequestLocale))
                {
                    orgRequest.From = Notification.SerializeToString(orgRequest.SenderInfo);
                    Notification notification = Notification.DeserializeFromString(orgRequest.RequestData, Notification.NotificationType.Invitation);
                    notification.From = Notification.SerializeToString(orgRequest.SenderInfo);
                    orgRequest.RequestData = Notification.SerializeToString(notification);
                }
            }
        }

        /// <summary>
        /// Lookup the information of the invitatation email recipients. 
        /// </summary>
        /// <param name="request">The request to be processed. </param>
        private void ProcessRecipientsInEmail(NotificationRequest request)
        {
            Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "ProcessRecipientsInEmail(): request=" + request.RequestId,
                    " Recipients = " + request.To);

            request.RecipientsInfo = new List<UserInfo>();
            string[] receipientList = request.To.Split(userDelimitor, StringSplitOptions.RemoveEmptyEntries);
            var xcache = Container.Instance.GetComponent<IXCacheDataAccess>();
            foreach (string recipient in receipientList)
            {
                UserInfo userInfo = null;

                string recipientTrimmed = recipient.Trim();

                // check if this list has any prefixed recipient
                if (recipientTrimmed.IndexOf(GamertagPrefix, StringComparison.OrdinalIgnoreCase) != -1)
                {
                    if (GamertagPrefix.Length == recipientTrimmed.Length)
                    {
                        // invalid entry in the list
                        continue;
                    }

                    // Find xuid for recipients with gamertag prefixes
                    string gamertag = recipientTrimmed.Substring(GamertagPrefix.Length).Trim();
                    ulong xuid = 0;
                    if (xcache.GetPuidByGamerTag(gamertag, out xuid))
                    {
                        userInfo = new UserInfo();
                        userInfo.Xuid = xuid;
                        userInfo.GamerTag = gamertag;
                    }
                    else
                    {
                        Logging.TraceVerbose("{0}: {1} {2} {3}", ComponentName, "Skipped recipient: ", gamertag, ", since it's not a valid XBL gamertag.");
                    }
                }
                else
                {
                    string email = recipientTrimmed;
                    if (recipientTrimmed.IndexOf(EmailPrefix, StringComparison.OrdinalIgnoreCase) != -1)
                    {
                        if (EmailPrefix.Length == recipientTrimmed.Length)
                        {
                            // invalid entry in the list
                            continue;
                        }

                        email = recipientTrimmed.Substring(EmailPrefix.Length);
                    }

                    // verify that this is a valid email address
                    if (IsValidEmailAddress(email))
                    {
                        userInfo = new UserInfo();
                        userInfo.EmailAddress = email;
                        userInfo.Puid = IdentityManager.GetPuidFromEmailAddress(email);

                        if (userInfo.Puid != 0)
                        {
                            UserIdentity userIdentity = new UserIdentity(userInfo.Puid);
                            userInfo.Xuid = userIdentity.Xuid;
                            userInfo.GamerTag = userIdentity.Gamertag;
                        }
                        else
                        {
                            Logging.TraceVerbose("{0}: {1} {2} {3}", ComponentName, "Skipped recipient: ", email, ", since its Windows Live PUID is 0.");
                        }
                    }
                    else
                    {
                        Logging.TraceVerbose("{0}: {1} {2} {3}", ComponentName, "Skipped recipient: ", email, ", since it's not a valid email address.");
                    }
                }

                // Add this recipient to result collection
                if (userInfo != null)
                {
                    userInfo.Locale = request.RequestLocale;

                    if (request.RecipientsInfo.Count < NotificationSMTPProvider_MaxRecipientCount)
                    {
                        request.RecipientsInfo.Add(userInfo);
                        Logging.TraceVerbose("{0}: {1} {2} {3}", ComponentName, "Added recipient (gamertag): ", userInfo.GamerTag, " to RecipientsInfo.");
                    }
                    else
                    {
                        // if more recipients are specified, drop them to avoid potential attacks.
                        Logging.TraceVerbose("{0}: {1}",
                            ComponentName,
                            "Skipping recipients. Too many specified by sender: " + request.From);

                        break;
                    }
                }
            }
            if (request.RecipientsInfo.Count > 0)
            {
                // Do a batch check and see if there is any recipient that blocks messages
                var presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
                uint[] results = new uint[0];

                try
                {
                    results = presenceDataAccess.CanSendMessageToUsers(request.SenderInfo.Xuid, request.RecipientsInfo.Select(r => r.Xuid).ToArray());
                }
                catch (ArgumentException argEx)
                {
                    Logging.TraceException(argEx, "Livecache call failed with invalid input parameters");
                }
                catch (Exception ex)
                {
                    // Likely catching an xonline.common.webplatform.livecache.LivecacheResponseException here
                    Logging.TraceException(ex, "Livecache call failed, defaulting to no sender permissions for this request");
                }

                // if we got no results from LC (we should have) we know the call went wrong
                // and we'll default to the sender NOT having permissions to send messages
                if (results.Length == 0)
                {
                    if (request.RecipientsInfo != null)
                    {
                        request.RecipientsInfo.Clear();
                    }
                    return;
                }

                // remove the blocked recipients
                for (int i = results.Length - 1; i >= 0; i--)
                {
                    if (results[i] == LivecacheConstants.XONLINE_E_MESSAGE_SENDER_BLOCKED || results[i] == LivecacheConstants.XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)
                    {
                        Logging.TraceWarning("{0}: {1} {2} {3} {4} {5} {6}",
                                ComponentName,
                                "Removing recipient: ",
                                request.RecipientsInfo[i],
                                ", since CanSendMessageToUsers() returned ",
                                results[i],
                                " for invite from ",
                                request.From);

                        request.RecipientsInfo.RemoveAt(i);
                    }
                }
            }
        }

        /// <summary>
        /// Generate the RecipientInfo list. 
        /// </summary>
        /// <param name="request">The request to be processed. </param>
        private void ProcessNotificationRecipients(NotificationRequest request)
        {
            Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "ProcessNotificationRecipients(): request=" + request.RequestId,
                    " Recipients = " + request.To);

            request.RecipientsInfo = new List<UserInfo>();
            string[] receipientList = request.To.Split(userDelimitor, StringSplitOptions.RemoveEmptyEntries);
            foreach (string recipient in receipientList)
            {
                try
                {
					// Remove the XUID prefix if it exists
					string trimmedRecipient = recipient.Trim();
					if (trimmedRecipient.StartsWith(XuidPrefix))
					{
						trimmedRecipient = trimmedRecipient.Substring(XuidPrefix.Length);
					}

                    ulong xuid = 0;
					xuid = ulong.Parse(trimmedRecipient);
                    UserIdentity userIdentity = new UserIdentity(xuid);
                    UserInfo userInfo = new UserInfo(xuid);

                    // We don't need to any other information 
                    // NOTE: we are not using PUID for now. 
                    userInfo.Puid = userIdentity.Puid;
                    request.RecipientsInfo.Add(userInfo);
                }
                catch
                {
                    Logging.TraceInformation("{0}: {1} {2}",
                        ComponentName,
                        "Failed to parse userId ",
                        recipient);
                }
            }
        }

        /// <summary>
        /// Check if the recipient has any incoming friend request and update the request for further processing in Storage Provider. 
        /// Request and its payload might be changed after this method. 
        /// </summary>
        /// <param name="orgRequest">The original notification request. </param>
        private void ProcessIncomingFriendRequest(NotificationRequest orgRequest)
        {
            try
            {
                Logging.TraceVerbose("{0}: {1} {2}",
                        ComponentName,
                        "ProcessIncomingFriendRequest(): request=" + orgRequest.RequestId,
                        " User xuid=" + orgRequest.RecipientsInfo[0].Xuid);

                FriendRequestNotification notification = Notification.DeserializeFromString<FriendRequestNotification>(orgRequest.RequestData);

                // This request comes from QueryNotifications on frone-end, and addressed to the caller himself.
                ulong userXuid = orgRequest.RecipientsInfo[0].Xuid;
                LIVEnServiceMobileExtendedAuthDataProvider.Puid = userXuid;
                bool friendRequestPending, messageWaiting;
                this.CheckXBLMessages(userXuid, out friendRequestPending, out messageWaiting);
                notification.FriendRequestPresent = friendRequestPending;
                notification.MessageWaiting = messageWaiting;

                // Update the notification in the request
                orgRequest.RequestData = Notification.SerializeToString(notification);
            }
            catch (Exception ex)
            {
                // catch all exceptions so the pipeline continues processing
                Logging.TraceWarning("{0}: {1} {2}",
                        ComponentName,
                        "Failed to ProcessIncomingFriendRequest. orgRequest.RequestData=" + orgRequest.RequestData,
                        "Exception: " + ex.ToString());
            }
        }

        /// <summary>
        /// Check XBL to see if there is any incoming messages for the specified user. 
        /// </summary>
        /// <param name="xuid">The XUID of the user. </param>
        /// <param name="friendRequestPending">TRUE if there is a incoming friend request. </param>
        /// <param name="messageWaiting">TRUE if there is a XBL message waiting for LiveApp. </param>
        private void CheckXBLMessages(ulong xuid, out bool friendRequestPending, out bool messageWaiting)
        {
            Logging.TraceVerbose("{0}: {1}",
                ComponentName,
                "CheckXBLMessages(): xuid=" + xuid);

            friendRequestPending = false;
            messageWaiting = false;
            try
            {
                var presenceDataAccess = Container.Instance.GetComponent<IPresenceDataAccess>();
                // bug 12728
                // call the EnumerateMessages with the flag includeWebAlive = false
                xonline.common.protocol.MessageSummary2[] messages = presenceDataAccess.EnumerateMessages(xuid, false);
                if (messages != null)
                {
                    var friendsRequests = messages.FirstOrDefault(m => m.bMessageType == xonline.common.protocol.MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST);
                    if (friendsRequests != null)
                    {
                        friendRequestPending = true;
                    }

                    var messagesForLiveApp = messages.FirstOrDefault(
                        m => (m.dwMessageFlags & xonline.common.protocol.MsgDefs.XONLINE_MSG_FLAG_NON_EXPORTABLE) == 0 &&
                             (m.dwMessageFlags & xonline.common.protocol.MsgDefs.XONLINE_MSG_FLAG_READ) == 0 &&
                            m.bMessageType != xonline.common.protocol.MsgDefs.XONLINE_MSG_TYPE_FRIEND_REQUEST &&
                            m.bMessageType != xonline.common.protocol.MsgDefs.XONLINE_MSG_TYPE_LIVE_MESSAGE &&
                            m.bMessageType != xonline.common.protocol.MsgDefs.XONLINE_MSG_TYPE_COMP_REMINDER &&
                            m.bMessageType != xonline.common.protocol.MsgDefs.XONLINE_MSG_TYPE_COMP_REQUEST &&
                            m.bMessageType != xonline.common.protocol.MsgDefs.XONLINE_MSG_TYPE_TEAM_RECRUIT &&
                            m.dwSenderTitleID != xonline.common.service.XOn.ZUNE_TITLE_ID);

                    if (messagesForLiveApp != null)
                    {
                        messageWaiting = true;
                    }
                }
            }
            catch (Exception ex)
            {
                // catch all exceptions if we cannot get friends info since it's a best effort job.
                Logging.TraceWarning("{0}: {1} {2}",
                    ComponentName,
                    "CheckXBLMessages(): Exception happened for user: " + xuid,
                    ex.ToString());
            }

            Logging.TraceVerbose("{0}: {1}",
                ComponentName,
                "User (xuid=" + xuid + "): FriendRequestPending=" + friendRequestPending + "; messageWaiting=" + messageWaiting);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProvider\MobilePush\NotificationPushProvider.cs ===




using System.Net;

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text;
    using System.Xml;
    using System.Globalization;
    using System.Security.Cryptography.X509Certificates;
    using System.Xml.Serialization;
    using GameMetadata.Common;
    using GameMetadata.Client;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.Utils;
    using Leet.Core.IoCCo;
    using NotificationCommon;

    /// <summary>
    /// Main class for sending Push Notification
    /// </summary>
    public class NotificationPushProvider : INotificationProvider
    {
        public const string ComponentName = "NotificationPushProvider";
        private const string NotificationDataSource = "ToDo";
        
        private static IGameMetadataClient _gameMetadataClient;
        private static IConfigurationProvider _configSettings;


        private static readonly List<Type> GmsretriableExceptionList = new List<Type>();
        private static Func<uint, string, uint, GameMetadataComposite> _gmsCallDelegate;
        private static Action<string, Exception, bool> _exceptionLogger;
 
        private const int RetryWaitInSec = 10;    // wait for 10 seconds before next retry

        /// <summary>
        /// Initializes a new instance of the NotificationPushProvider class. 
        /// </summary>
        public NotificationPushProvider()
        {
            this.Initialize();
        }

        /// <summary>
        /// Initializes the provider. 
        /// </summary>
        public void Initialize()
        {
            // register the interfaces
            _gameMetadataClient = Container.Instance.GetComponent<IGameMetadataClient>();
            _configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.CommunicationException));
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.EndpointNotFoundException));
            GmsretriableExceptionList.Add(typeof(System.ServiceModel.ServerTooBusyException));
            var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
            _gmsCallDelegate = gmsClient.GetGameMetadata;
            _exceptionLogger = HandleException;
        }

        /// <summary>
        /// Gets the game metadata client. 
        /// </summary>
        public static IGameMetadataClient GmsClient
        {
            get { return _gameMetadataClient; }
        }

        /// <summary>
        /// Number of times a dependency should be retried (GMS)
        /// </summary>
        /// <returns></returns>
        public static int RetryMax()
        {
            return 5;
        }


        public static void HandleException(string message, Exception exception, bool retriable)
        {
            if (retriable)
            {
                NotificationsDiag.Logging.LogEvent(new RetriableError(), exception, message, null);
            }

        }
        /// <summary>
        /// Process one notification request. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        public void ProcessNotificationRequest(NotificationRequest request)
        {
            string pushUrl = String.Empty;
            try
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                Logging.TraceVerbose("{0}: {1}",
                                     ComponentName,
                                     "ProcessNotificationRequest(): request=" + request.RequestId);

                Notification.NotificationType type = (Notification.NotificationType) Enum.ToObject(
                                                                                         typeof (
                                                                                             Notification.
                                                                                             NotificationType),
                                                                                         request.RequestDataType);

                Notification notification = Notification.DeserializeFromString(request.RequestData, type);


                if (type != Notification.NotificationType.FriendRequest)
                {
                    foreach (UserInfo user in request.RecipientsInfo)
                    {
                        if (user.Xuid == 0)
                        {
                            continue;
                        }

                        // Construct the Tickle and send it out
                        UserData userData = NotificationStorageProvider.UserDataStorage.GetUserData(user.Xuid.ToString());

                        if (!((userData.Push == null) || (String.IsNullOrEmpty(userData.Push.Url))))
                        {
                            // Send Push Notification for this user
                            try
                            {
                                SendPushNotification(request, user, userData, notification);
                            }
                            catch (WebException ex)
                            {
                                Logging.WriteEvent(new SendPushFailedUnexpected(), ex, "Failed to send Push Notification to {0}at url {1}",user.GamerTag, userData.Push.Url);
                            }
                        }
                    }
                }
            }

            catch (Exception ex)
            {
                // catch and log
                Logging.TraceWarning("{0}: {1} {2}",
                    ComponentName,
                    "Failed to process notification request! request.RequestData=" + request.RequestData,
                    "Exception: " + ex.ToString());                 
            }

        }

        /// <summary>
        /// Send Push notification to specified userData
        /// </summary>
        /// <param name="request"></param>
        /// <param name="user"></param>
        /// <param name="userData"></param>
        /// <param name="notification"></param>
        private static void SendPushNotification(NotificationRequest request, UserInfo user, UserData userData, Notification notification)
        {
            if (String.IsNullOrEmpty(userData.Push.Locale))
            {
                userData.Push.Locale = LocalizationUtility.DefaultLocale;
            }
            var gmsClient = Container.Instance.GetComponent<IGameMetadataClient>();
            GameMetadataComposite gmc = RetryController.RetryFunc(RetryMax, RetryWaitInSec,
                                                                  GmsretriableExceptionList,
                                                                  (Exception ex, bool retriable) =>
                                                                  _exceptionLogger("Calling GMS", ex,
                                                                                   retriable),
                                                                  () =>
                                                                  _gmsCallDelegate(notification.GameId,
                                                                                   userData.Push.Locale,
                                                                                   notification.Variant));
                         
            byte[] payload = GetPayload(request, userData, notification, gmc);

            var util = new NotificationSenderUtility(_configSettings.GetSetting(Settings.ProxyAddress));
            X509Certificate2 certificate = null;
            Uri pushUri = new Uri(userData.Push.Url);
            if (pushUri.Scheme == Uri.UriSchemeHttps)
            {
                // Get the mutual auth certificate
                certificate = GetX509Certificate(_configSettings.GetSetting(Settings.Notification_MPNSCertName));
            }

            Logging.TraceVerbose("{0}: Sending Push to {1} at Url {2}",
                              ComponentName,
                              user.GamerTag,
                              userData.Push.Url);
       
            MPNSResponse resp = util.SendRawNotification(new Uri(userData.Push.Url), payload, certificate);

            Logging.TraceVerbose("{0}: Sent Push to {1} at Url {2} and got response {3}",
                              ComponentName,
                              user.GamerTag,
                              userData.Push.Url,
                              resp.DeliveryStatus());
            if (resp.IsSubscriptionExpired())
            {
                // We need to remove the subscription from user record
                userData.Push = new UserSubscription();
                NotificationStorageProvider.UserDataStorage.UpdateUserData(userData);
                Logging.TraceVerbose("{0}: {1}",
                                     ComponentName,
                                     " Push url " + userData.Push.Url + " has EXPIRED for " + user.GamerTag);
            }
            else if (resp.IsDelivered())
            {
                // Write the Audit log
                NotificationAuditLog.UpdateTrackingState(NotificationAuditState.SentToPushNotSystem,
                                                         request);
                Logging.TraceVerbose("{0}: {1} {2}",
                                     ComponentName,
                                     " Sent Push notification request=" + request.RequestData,
                                     " For User=" + user.GamerTag);
            }
            else
            {
                Logging.WriteEvent(new SendPushFailedUnexpected(), "Failed to send Push Notification to {0}. The result was: {1}", user.GamerTag, resp.DeliveryStatus());
            }
        }

        /// <summary>
        /// Get Payload for sending to MPNS
        /// </summary>
        /// <param name="request"></param>
        /// <param name="userData"></param>
        /// <param name="notification"></param>
        /// <param name="gmc"></param>
        /// <returns></returns>
        private static byte[] GetPayload(NotificationRequest request, UserData userData, Notification notification, GameMetadataComposite gmc)
        {
            // Url for default canned image
            string imageUrl = _configSettings.GetSetting(Settings.NotificationFE_XblIconMobileSmallUrl);

            // Get the Locale for the user
            CultureInfo culture = new CultureInfo(userData.Push.Locale, false);

            // Localize the TypeDisplayName
            notification.TypeDisplayName = LocalizationUtility.LocalizedNotificationType(notification.Type.ToString(), culture);

            NotificationLite tickle;

            // Special handling for Beacon Notifications
            if (notification.Type == Notification.NotificationType.Beacon)
            {
                // Use the images contained in the Notification
                List<GameImageComposite> imageUrls = DeserializeObject<List<GameImageComposite>>(notification.Images);
                for (int i = 0; i < imageUrls.Count; i++)
                {
                    if (imageUrls[i].ImageType == ImageType.GameTile_MobileSmall)
                    {
                        imageUrl = imageUrls[i].ImageUrl;
                        break;
                    }
                }

                // For Beacon Notifications, we grab a localized version of
                // the Game Display Name from the Notification's Data Blob
                tickle = new NotificationLite(
                    notification,
                    request.SenderInfo,
                    LocalizationUtility.LocalizedBeaconGameDisplayName(culture, notification.DataBlob),
                    imageUrl,
                    notification.Url);

                // Remove the DataBlob data from the notification since it was only
                // holding each of the localized versions of the Game Display Name
                tickle.DataBlob = string.Empty;
            }
            else
            {
                
                if ((gmc != null) && (gmc.Images != null) && (gmc.Images.ContainsKey(ImageType.GameTile_MobileSmall)))
                {
                    imageUrl = gmc.Images[ImageType.GameTile_MobileSmall].ImageUrl;
                }

                tickle = new NotificationLite(
                    notification,
                    request.SenderInfo,
                    gmc.GameAndVariantName,
                    imageUrl,
                    gmc.GameRedirectionUrl);
            }

            // We have a subscription for this user
            var data = new PushData();
            data.DataSource = NotificationDataSource;
            data.Notification = tickle;
            data.FetchRequired = false;

            // Create an empty name space to be used during serialzation
            XmlSerializerNamespaces ns = new XmlSerializerNamespaces();
            ns.Add("", "");

            var stream = new MemoryStream();
            var xmlTextWriter = new XmlTextWriter(stream, Encoding.UTF8);
            var x = new XmlSerializer(data.GetType());
            x.Serialize(xmlTextWriter, data, ns);
            stream = (MemoryStream) xmlTextWriter.BaseStream;

            byte[] payload = stream.ToArray();

            if (payload.Length > NotificationSenderUtility.MaxPayloadLength)
            {
                // We can't fit the notification object so remove it and set the FetchRequired flag
                data.FetchRequired = true;
                data.Notification = null;
                x.Serialize(stream, data);
                payload = stream.ToArray();
            }
            return payload;
        }

        /// <summary>
        /// Creates an object from an XML string.
        /// </summary>
        /// <param name="xml">XML document in a string.</param>
        /// <returns>Object representation of the string.</returns>
        private static T DeserializeObject<T>(string xml)
        {
            T result;
            XmlSerializer ser = new XmlSerializer(typeof(T));
            using (TextReader tr = new StringReader(xml))
            {
                result = (T)ser.Deserialize(tr);
            }

            return result;
        }

        /// <summary>
        /// Get a local x509 certificate
        /// </summary>
        /// <returns>a X509Certificate2 </returns>
        private static X509Certificate2 GetX509Certificate(string subjectName)
        {
            // Use the Local Store
            X509Store store = new X509Store(StoreLocation.LocalMachine);

            // Get certificate by thumbprint
            store.Open(OpenFlags.ReadOnly);
            X509Certificate2Collection collection = store.Certificates.Find(X509FindType.FindBySubjectName, subjectName,
                                                                            false);
            store.Close();

            if (collection.Count == 1)
            {
                // If found, return the certificate
                return collection[0];
            }

            if (collection.Count > 1)
            {
                // cert not found
                Logging.WriteEvent(new MpnsCertMultFound(), "Multiple certs found with name \"{0}\".", subjectName);
 
                // multiple certs found
                throw new ApplicationException(String.Format(System.Globalization.CultureInfo.CurrentUICulture,
                                                             "Multiple certs found with name \"{0}\".", subjectName));
            }

            // cert not found
            Logging.WriteEvent(new MpnsCertNotFound(), "Certificate with name \"{0}\" not found.",
                                                         subjectName);
            // multiple certs found
            throw new ApplicationException(String.Format(System.Globalization.CultureInfo.CurrentUICulture,
                                                         "Certificate with name \"{0}\" not found.", subjectName));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProviderCoordinator\NotificationRequestCoordinator.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationRequestCoordinator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The coordinator class that takes NotificationRequest object and load proper notification providers
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/1/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using Leet.Core.Utils;

    /// <summary>
    /// The notification provider coordinator class.
    /// This class has two major purpose. 
    /// 1. split the TO field so notifications can be sent to all the users in the TO field
    /// 2. based on notification request type, appropriate notification providers will be created to process
    /// </summary>
    public class NotificationProviderCoordinator : INotificationProvider
    {
        /// <summary>
        /// The display name of the component. 
        /// </summary>
        private const string ComponentName = "NotificationProviderCoordiantor";

        /// <summary>
        /// A hashtable used to save the request map. 
        /// </summary>
        private static Hashtable requestProviderMap = null;

        /// <summary>
        /// A hash table used to save the flow map. 
        /// </summary>
        private static Hashtable flowMap = null;

        /// <summary>
        /// A dictionary that saves instances of request handlers for current worker thread. 
        /// </summary>
        private Dictionary<string, INotificationProvider> requestHandlerInstances = new Dictionary<string,INotificationProvider>();

        /// <summary>
        /// A boolean variable to indicate if the static memebers have been initialized. 
        /// </summary>
        private static bool initialized = false;

        /// <summary>
        /// An object used to lock. 
        /// </summary>
        private static object lockObj = new object();

        /// <summary>
        /// The delimitor for flow settings. 
        /// </summary>
        private string[] flowDelimitor = new string[] { ",", ";" };

        /// <summary>
        /// Initializes a new instance of the NotificationProviderCoordinator class. 
        /// </summary>
        public NotificationProviderCoordinator()
        {
        }

        /// <summary>
        /// Finds an auto service provider for the incoming request type.
        /// Service providers added in web.config take precedence over build-in providers.
        /// </summary>
        /// <param name="requestType">Type of the incoming auto request.</param>
        /// <returns>Returns an auto service provider for the specified request type.</returns>
        public INotificationProvider GetNotificationProvider(string requestType)
        {
            INotificationProvider provider = null;

            if (string.IsNullOrEmpty(requestType))
            {
                throw new LIVEnException("Null RequestType");
            }
            else
            {
                if (requestHandlerInstances.ContainsKey(requestType))
                {
                    return requestHandlerInstances[requestType];
                }
                else
                {
                    if (requestProviderMap.ContainsKey(requestType))
                    {
                        Type type = Type.GetType((string)requestProviderMap[requestType]);
                        provider = Activator.CreateInstance(type) as INotificationProvider;
                        requestHandlerInstances[requestType] = provider;
                    }
                    else
                    {
                        throw new LIVEnException(string.Format("Invalid RequestTpe {0} is not supported", requestType));
                    }
                }
            }

            return provider;
        }

        /// <summary>
        /// Initializes the NotificationRquestCoordinator. 
        /// </summary>
        public void Initialize()
        {
            // make sure only one thread will initialize. 
            lock (lockObj)
            {
                if (!initialized)
                {
                    requestProviderMap = new Hashtable();
                    flowMap = new Hashtable();
                    this.InitializeMap();
                    initialized = true;
                }
            }
        }

        /// <summary>
        /// Process a notification request based on the configuration. 
        /// </summary>
        /// <param name="request">The request object. </param>
        public void ProcessNotificationRequest(NotificationRequest request)
        {
            // We support detailed command or just the generic action. 
            // The detailed command overrides the generic action. 
            string requestCommand = string.Empty; 

            if (!string.IsNullOrEmpty(request.Command) && flowMap.Contains(request.Command))
            {
                requestCommand = request.Command;
            }
            else
            {
                requestCommand = request.Action.ToString();
            }

            // Now lookup the flowmap and load the provider one by one. 
            if (!string.IsNullOrEmpty(requestCommand) && flowMap.Contains(requestCommand))
            {
                string[] steps = (string[])flowMap[requestCommand];
                foreach (string step in steps)
                {
                    INotificationProvider provider = this.GetNotificationProvider(step);
                    provider.ProcessNotificationRequest(request);
                }
            }
            else
            {
                throw new InvalidOperationException(string.Format("Invalid Request Command {0}, Action {1} is not supported", request.Command, request.Action));
            }
        }

        /// <summary>
        /// Initialize the request map hash table with settings from web.config and build-in providers.
        /// </summary>
        private void InitializeMap()
        {
            // Get custom-defined service providers from config
            Hashtable customProviders = (Hashtable)System.Configuration.ConfigurationManager.GetSection("NotificationProviders");
            if (customProviders != null)
            {
                foreach (DictionaryEntry de in customProviders)
                {
                    requestProviderMap[de.Key] = de.Value;
                    Type type = Type.GetType((string)de.Value);
                    INotificationProvider provider = Activator.CreateInstance(type) as INotificationProvider;
                    provider.Initialize();
                }
            }

            // Get flow definitions from config
            Hashtable flowDefs = (Hashtable)System.Configuration.ConfigurationManager.GetSection("NotificationRequestFlow");
            if (flowDefs != null)
            {
                foreach (DictionaryEntry de in flowDefs)
                {
                    string[] flowsteps = ((string)de.Value).Split(this.flowDelimitor, StringSplitOptions.RemoveEmptyEntries);
                    flowMap[de.Key] = flowsteps;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProviderCoordinator.Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Main cs file for testing Notification Azure Storage. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/22/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Xml.Serialization;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using AsyncMultiplayer.NotificationService; 

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            ConfigurationSelector.RegisterProvider("dummy-service", "LEET");

            NotificationProviderCoordinator coordinator = new NotificationProviderCoordinator();
            coordinator.Initialize(); 

            // now create some requests and let the coordinator process it. 
            InvitationNotification invite = new InvitationNotification();
            invite.From = "test corrdinator";
            invite.GameId = 5000;
            invite.SessionId = "first_session";
            //invite.Sender = "fgao@microsoft.com"; 

            NotificationRequest request = new NotificationRequest();
            request.Action =  NotificationRequest.ActionType.Create;
            request.Command = request.Action.ToString() + invite.Type.ToString(); 
            request.RequestDataType = (int)Notification.NotificationType.Invitation;
            request.RequestData = Notification.SerializeToString(invite);
            request.GameId = invite.GameId;
            request.SessionId = invite.SessionId;
            request.To = @"fgao@microsoft.com;fgao@hotmail.com";

            string requestString = Notification.SerializeToString(request);
            NotificationRequest testRequest = Notification.DeserializeFromString<NotificationRequest>(requestString); 

            coordinator.ProcessNotificationRequest(testRequest);

            NotificationRequest deleteRequest = new NotificationRequest();
            deleteRequest.Action = NotificationRequest.ActionType.Delete;
            deleteRequest.Command = deleteRequest.Action.ToString(); 
            deleteRequest.GameId = invite.GameId;
            deleteRequest.SessionId = invite.SessionId;
            deleteRequest.To = @"fgao@microsoft.com;fgao@hotmail.com";
            
            NotificationQueryParameter parameter = new NotificationQueryParameter();
            parameter.GameId = invite.GameId;
            parameter.SessionId = invite.SessionId;
            parameter.Type = (uint) invite.Type; 
            deleteRequest.RequestData = Notification.SerializeToString(parameter);

            requestString = Notification.SerializeToString(deleteRequest);
            testRequest = Notification.DeserializeFromString<NotificationRequest>(requestString); 
            coordinator.ProcessNotificationRequest(testRequest);            
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProviderCoordinator\ProviderConfigurationSection.cs ===
//-----------------------------------------------------------------------------
// <copyright file="ProviderConfigurationSection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//     This file contains the class for retrieving custom-defined config settings in
//     ProviderConfiguration section
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/01/2009">
//     Class Created
// </history>
//-----------------------------------------------------------------------------
namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Xml;

    /// <summary>
    /// Custom Handler to access the custom-defined Configuration Section.
    /// </summary>
    public class ProviderConfigSectionHandler : IConfigurationSectionHandler
    {
        /// <summary>
        /// Creates a custom-defined object that contains the custom-defined settings.
        /// </summary>
        /// <param name="parent">Parent object in web.config.</param>
        /// <param name="configContext">Configuration context object.</param>
        /// <param name="section">Specified Section XML node.</param>
        /// <returns>The object created by the handler.</returns>
        object IConfigurationSectionHandler.Create(
          object parent, object configContext, XmlNode section)
        {
            // Creates the configuration object that this method will return.
            Hashtable configObject = new Hashtable();

            foreach (XmlNode child in section.SelectNodes("add"))
            {
                if (XmlNodeType.Element == child.NodeType)
                {
                    string request = child.Attributes["name"].Value;
                    string providerType = child.Attributes["type"].Value;
                    configObject.Add(request, providerType);
                }
            }

            return configObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationRequestUtils.Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Unit test case for NotificationRequestUtils
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Threading;
    using System.Xml.Serialization;

    /// <summary>
    /// Main class for notification file storage test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            string userId = @"2600292641994140;fgao@hotmail.com";
            string sessionId = "My_first_session";
            uint gameId = 7777;

            string connectionString = "Data Source=fgao-srv\\FGAOSQLSERVER;Initial Catalog=AsyncNotification;Integrated Security=True";
            INotificationRequest sendRequestUtils = new NotificationRequestUtils(connectionString);

            // Create some notifications first
            NudgeNotification nudge = new NudgeNotification();
            nudge.GameId = gameId;
            nudge.SessionId = sessionId;
            
            // Fill out the notification request. 
            NotificationRequest request = new NotificationRequest();
            request.From = "2600292641994140";
            request.To = userId;
            request.GameId = nudge.GameId; 
            request.SessionId = nudge.SessionId;
            request.Action = NotificationRequest.ActionType.Create;
            request.Command = request.Action.ToString() + nudge.Type.ToString(); 
            request.RequestDataType = (int)nudge.Type;
            request.RequestData = Notification.SerializeToString(nudge);
            sendRequestUtils.SendNotificationRequest(request);

            //request = new NotificationRequest();
            //InvitationNotification invite = new InvitationNotification(); 
            //UserInfo senderInfo = new UserInfo(2600292641994140);
            //senderInfo.Cid = 0;
            //senderInfo.GamerTag = "Unit Test";

            //// TODO: fill out the following two fields accordingly using IProfileProvider
            ////       There is a privacy review for this. Sync with Dave
            //senderInfo.EmailAddress = @"ztest01@microsoft.com";
            //senderInfo.DisplayName = "Unit Test";

            //request.From = Notification.SerializeToString(senderInfo);
            //request.RequestLocale = "en-US"; 
            //request.Action = NotificationRequest.ActionType.Create;
            //request.Command = request.Action.ToString() + Notification.NotificationType.Invitation.ToString();
            //request.To = @"fgao@microsoft.com"; 
            //request.GameId = gameId;
            //request.SessionId = sessionId;
            //request.RequestDataType = (int)Notification.NotificationType.Invitation;
            //request.RequestData = Notification.SerializeToString(invite);
            //sendRequestUtils.SendNotificationRequest(request);

            request = new NotificationRequest();
            request.To = "2600292641994140"; 
            request.Action = NotificationRequest.ActionType.Delete;
            NotificationQueryParameter parameter = new NotificationQueryParameter();
            //parameter.GameId = nudge.GameId;
            //parameter.SessionId = nudge.SessionId;
            parameter.Type = 18;

            request.RequestData = Notification.SerializeToString(parameter); 
            sendRequestUtils.SendNotificationRequest(request);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationRequestUtils\NotificationRequestUtils.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationRequestUtils.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  A utility calss to send a notification request to the queue 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/24/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Text;
    using System.Xml.Serialization;
    using Leet.Core.IoCCo;
    using Leet.Core.Configuration;
    using Leet.Core.Utils;
    using Leet.Core.Diagnostics;
    using LIVEN.Common.Diagnostics; 
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Utility class to send notification request. 
    /// </summary>
    public class NotificationRequestUtils : INotificationRequest
    {
        /// <summary>
        /// The display name of the component. 
        /// </summary>
        private const string ComponentName = "NotificationRequestUtils";


        /// <summary>
        /// Initializes a new instance of the NotificationRequestUtils class. 
        /// </summary>
        public NotificationRequestUtils()
        {
            NotificationEvents.Initialize("notification_front_end");
        }

        /// <summary>
        /// Initializes a new instance of the NotificationRequestUtils class. 
        /// </summary>
        /// <param name="connectionString">The connection string to the database. </param>
        public NotificationRequestUtils(string connectionString)
            : this()
        {
            this.ConnectionString = connectionString;
        }

        /// <summary>
        /// Gets or sets the connection string for accessing the database. 
        /// </summary>
        public string ConnectionString { get; set; }

        /// <summary>
        /// Gets the sleep time before submitting a request to the SSB notification queue (to throttle incoming requests). 
        /// </summary>
        public int InputThrottleTimeInMilliseconds
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationInternal_InputThrottleTimeInMilliseconds);
            }
        }

        /// <summary>
        /// Send a notification request to the queue. 
        /// </summary>
        /// <param name="request">The notification request. </param>
        public
        void
        SendNotificationRequest(NotificationRequest request)
        {
            // Validate the incoming request
            if (String.IsNullOrEmpty(request.To))
            {
                // Log a warning if no recipients to send the notification.
                Logging.TraceVerbose("{0}: {1} {2}",
                    ComponentName,
                    "No recipients specified in the NotificationRequest.",
                    request.ToString());

                return;
            }

            // Check if we need to throttle the request
            if (InputThrottleTimeInMilliseconds != 0)
            {
                System.Threading.Thread.Sleep(InputThrottleTimeInMilliseconds);
            }

            SqlCommand sqlCmd = null;

            try
            {
                string requestMessage = Notification.SerializeToString(request);

                using (SqlConnection sqlConnection = new SqlConnection(this.ConnectionString))
                {
                    sqlConnection.Open();

                    sqlCmd = sqlConnection.CreateCommand();
                    sqlCmd.CommandType = CommandType.StoredProcedure;
                    sqlCmd.CommandText = "NotificationSchema.p_SendNotificationRequest";

                    sqlCmd.Parameters.Add("@Message", SqlDbType.NVarChar, -1);
                    sqlCmd.Parameters["@Message"].Direction = ParameterDirection.Input;
                    sqlCmd.Parameters["@Message"].Value = requestMessage;

                    sqlCmd.Transaction = sqlConnection.BeginTransaction();

                    sqlCmd.ExecuteNonQuery();

                    sqlCmd.Transaction.Commit();
                }
            }
            catch (SqlException sqlex)
            {
                Logging.TraceException(sqlex, "{0}: {1}",
                     ComponentName,
                     "Unable to add the request to the queue");

                try
                {
                    if (sqlCmd != null && sqlCmd.Transaction != null)
                    {
                        sqlCmd.Transaction.Rollback();
                    }
                }
                catch (Exception sqlEx2)
                {
                    Logging.TraceException(sqlEx2, "Failed to rollback new request message from the queue");
                }

                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.QueueAccessFailure,
                    HttpStatusCode.InternalServerError,
                    sqlex,
                    true,
                    sqlex.ToString());
            }
            finally
            {
                if (sqlCmd != null)
                {
                    sqlCmd.Dispose();
                }
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationProviderCoordinator\RequestFlowConfigurationSection.cs ===
//-----------------------------------------------------------------------------
// <copyright file="RequestFlowConfigurationSection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//     This file contains the class for retrieving custom-defined config settings
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/03/2009">
//     Created
// </history>
//-----------------------------------------------------------------------------
namespace AsyncMultiplayer.NotificationService
{
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Xml;

    /// <summary>
    /// Custom Handler to access the custom-defined Configuration Section.
    /// </summary>
    public class RequestFlowConfigSectionHandler : IConfigurationSectionHandler
    {
        /// <summary>
        /// Creates a custom-defined object that contains the custom-defined settings.
        /// </summary>
        /// <param name="parent">Parent object in web.config.</param>
        /// <param name="configContext">Configuration context object.</param>
        /// <param name="section">Specified Section XML node.</param>
        /// <returns>The object created by the handler.</returns>
        object IConfigurationSectionHandler.Create(
          object parent, object configContext, XmlNode section)
        {
            // Creates the configuration object that this method will return.
            Hashtable configObject = new Hashtable();

            foreach (XmlNode child in section.SelectNodes("add"))
            {
                if (XmlNodeType.Element == child.NodeType)
                {
                    string request = child.Attributes["name"].Value;
                    string providerType = child.Attributes["flow"].Value;
                    configObject.Add(request, providerType);
                }
            }

            return configObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\Global.asax.cs ===
namespace AsyncMultiplayer.NotificationService.FrontEnd
{
    using System;
    using System.Collections;
    using System.Configuration;
    using System.IO;
    using System.Web;
    using System.Xml;
    using System.Xml.XPath;
    using Common.AzureStorage;
    using GameMetadata.Client;
    using Leet.Core.Caching;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics; 
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.BI;
    using Leet.Identity.ActiveAuth.Wrapper;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.Providers;
    using Leet.Identity;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class Global : System.Web.HttpApplication
    {
        /// <summary>
        /// Component Name.
        /// </summary>
        private const string ComponentName = "NotificationServiceFrontEndGlobal";

        /// <summary>
        /// The name used in the NPDB configuration. 
        /// </summary>
        private const string ServiceConfigName = "notification_front_end";

        /// <summary>
        /// The interface of the database. 
        /// </summary>
        private const string DatabaseInterface = "lest_AsyncNotification_db";

        /// <summary>
        /// Temporary used to enable debug mode without authentication. 
        /// </summary>
        private static bool debugMode;

        /// <summary>
        /// The client to access game metadata. 
        /// </summary>
        private static IGameMetadataClient metadataClient;

        
        /// <summary>
        /// The name Serivce name space. 
        /// </summary>
        private string serviceNamespace = typeof(NotificationService).Namespace;

        /// <summary>
        /// Gets the game metadata client. 
        /// </summary>
        public static IGameMetadataClient MetadataClient
        {
            get
            {
                return metadataClient;
            }
        }

        /// <summary>
        /// Gets the friend request URL to xbox web site. 
        /// </summary>
        public static string FriendRequestUrl
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_FriendRequestUrl);
            }
        }

        /// <summary>
        /// Gets LiveApp supported locales. 
        /// </summary>
        public static string LiveAppSupportedLocales
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_LiveAppSupportedLocales);
            }
        }

        /// <summary>
        /// Gets the Azure storage account
        /// </summary>
        public static string AzureStorageAccount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageAccount);
            }
        }

        /// <summary>
        /// Gets the Azure storage access token
        /// </summary>
        public static string AzureStorageToken
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_AzureStorageToken);
            }
        }

        /// <summary>
        /// Gets the maximum allowed invites request per hour. 
        /// </summary>
        public static int InviteQuotaPerHour
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationFE_InviteQuotaPerHour);
            }
        }

        /// <summary>
        /// Gets the maximum characters the data blob can carry in a InviteRequest. 
        /// </summary>
        public static int DataBlobMaxCchLength
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationFE_DataBlobMaxCchLength);
            }
        }

        /// <summary>
        /// Gets the Azure table storage access endpoint.
        /// </summary>
        public static string AzureTableStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureTableStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure blob storage access endpoint. 
        /// </summary>
        public static string AzureBlobStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureBlobStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the Azure retry count
        /// </summary>
        public static int AzureRetryCount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.AzureRetryCount);
            }
        }

        /// <summary>
        /// Gets the Azure queue storage access point. 
        /// </summary>
        public static string AzureQueueStorageEndPoint
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.AzureQueueStorageEndPoint);
            }
        }

        /// <summary>
        /// Gets the proxy address for the environment. 
        /// </summary>
        public static string ProxyAddress
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.ProxyAddress);
            }
        }

        /// <summary>
        /// Gets or sets the static instance of SendRequestUtils. 
        /// </summary>
        public static INotificationRequest SendRequestUtil { get; set; }

        /// <summary>
        /// Gets a value indicating whether the service is for debug mode. 
        /// </summary>
        public static bool DebugMode
        {
            get { return debugMode; }
        }

        /// <summary>
        /// Gets the connection string to send notification requests. 
        /// </summary>
        internal static string RequestQueueConnectionString
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetConnectionString(DatabaseInterface);
            }
        }

        /// <summary>
        /// Application OnStart event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            NotificationEvents.Initialize(ServiceConfigName);

            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>(); 

            ConfigurationSelector.RegisterProvider(ServiceConfigName, "LEET");

            // register the activeAuth
            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize(ServiceConfigName);
            ActiveAuthWrapperAuthManager.RegisterWithIocContainer(Container.Instance);

            // Register locale helper
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            // Register Cache Provider
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();

            // Initialize and register with CosMos
            SpotlightManager.Initialize();

            SendRequestUtil = new NotificationRequestUtils(RequestQueueConnectionString);
            debugMode = bool.Parse(ConfigurationManager.AppSettings["IsDebugMode"]);

            // get the game metadata provider. 
            string useFakeClientVal = ConfigurationManager.AppSettings["UseFakeClient"];
            if (string.IsNullOrEmpty(useFakeClientVal))
            {
                useFakeClientVal = "false";
            }

            // Register GameMetadataClient
            if (Boolean.Parse(useFakeClientVal.Trim().ToLower()))
            {
                Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
                Logging.TraceWarning("{0}: {1}",
                    ComponentName,
                    "Fake GMS client is used. If this is not your intention, change web.config and set UseFakeClient to false!"); 
            }
            else
            {
                GameMetadataClient.RegisterContainerServices();
            }

            metadataClient = Container.Instance.GetComponent<IGameMetadataClient>();

            Container.Instance.AddService<IBILog, BILog>(); // to log business intelligence data

            // Initialize perfcounters
            StorageClientPerfCounters.Counters =
                PerformanceCounters.GetPerformanceCounters(typeof(StorageClientPerfCounters), Global.ServiceConfigName);

            Logging.TraceInformation("{0}: {1}",
                ComponentName,
                "Service Application Started.");

            Logging.TraceInformation("{0}: {1} {2}",
                ComponentName,
                "Proxy setting is ", 
                ProxyAddress);

            Logging.TraceInformation("{0}: {1} {2}",
                ComponentName,
                "Connection string to Send Notification request is ",
                RequestQueueConnectionString);

            Logging.TraceInformation("{0}: {1} {2}",
                ComponentName,
                "Azure storage account is ",
                AzureStorageAccount);
        }

        /// <summary>
        /// Application OnEnd event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_End(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application BeginRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_BeginRequest(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            HttpContext.Current.Response.Headers["Cache-Control"] = "no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }

        /// <summary>
        /// Application error handler. 
        /// </summary>
        /// <param name="sender">Sender object. </param>
        /// <param name="e">The event arguments. </param>
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            Logging.TraceException(ex,
                ComponentName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\NotificationHostFactory.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using Leet.Utils;
using NotificationServiceFrontEnd.V1;

namespace AsyncMultiplayer.NotificationService.FrontEnd
{
    public class NotificationHostFactory : MultipleHTTPSecureBindingsServiceHostFactory<INotificationFrontEnd>
    {
    }

    public class NotificationSubscribeHostFactory : MultipleHTTPSecureBindingsServiceHostFactory<ISubscription>
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\INotificationFrontEnd.cs ===
//-------------------------------------------------------------------
// <copyright file="INotificationFrontEnd.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="a-thkuo">
//     Ted Kuo
// </author>
//
// <summary>
//  Notification service front end WCF contract
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="06/02/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
namespace AsyncMultiplayer.NotificationService.FrontEnd
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Web;
    using System.ServiceModel;
    using System.ServiceModel.Web;
    using Microsoft.ServiceModel.Web;

    /// <summary>
    /// Notification Front End Service contract definition
    /// </summary>
    [ServiceKnownType(typeof(SpotlightList))]
    [ServiceContract]
    public interface INotificationFrontEnd
    {
        /// <summary>
        /// Get the spotlight notifications. 
        /// </summary>
        /// <param name="carrierString">The optional carrier name. </param>
        /// <returns>A list of spotlight notification</returns>
        [WebHelp(Comment = "Retrieve given number of notifications starting with the given Id.")]
        [WebGet(UriTemplate = "Spotlight/?carrier={carrierString}")]
        [OperationContract]
        List<Spotlight> GetSpotLight(string carrierString);

        /// <summary>
        /// Returns certain number of notifications starting with the given Id.
        /// User identity is based on the HTTP request authorization header.
        /// </summary>
        /// <param name="gameIdString">The string format of the gameId</param>
        /// <param name="sessionId">The sessionId string. </param>
        /// <param name="category">The category of the requested notifications. </param>
        /// <param name="lastId">Starting notification Id.</param>
        /// <param name="count">Maximum number of notification to be returned.</param>
        /// <param name="typeString">The required notification type. </param>
        /// <param name="userVisibleOnly">Whether or not search user visible notificaiton only.</param>
        /// <returns>Notification entries.</returns>
        [WebHelp(Comment = "Retrieve given number of notifications starting with the given Id.")]
        [WebGet(UriTemplate = "?game={gameIdString}&session={sessionId}&category={category}&last={lastId}&count={count}&type={typeString}&userVisibleOnly={userVisibleOnly}")]
        [OperationContract]
        NotificationList GetNotifications(
            string gameIdString,
            string sessionId,
            int category,
            string lastId,
            int count,
            string typeString,
            bool userVisibleOnly);

        /// <summary>
        /// Update the status of the notification. 
        /// </summary>
        /// <param name="notificationId">NotificationID used to update the notification. </param>
        /// <param name="status">The new status. </param>
        [WebHelp(Comment = "Update notification status.")]
        [WebInvoke(Method = "PUT", UriTemplate = "update/?notification={notificationId}&status={status}")]
        [OperationContract]
        void UpdateNotification(string notificationId, string status);

        /// <summary>
        /// This method deletes a notification of the given Id.
        /// </summary>
        /// <param name="notificationId">Notification Id.</param>
        [WebHelp(Comment = "Delete notification of the given Id.")]
        [WebInvoke(Method = "DELETE", UriTemplate = "delete/?notification={notificationId}")]
        [OperationContract]
        void DeleteNotificationQuery(string notificationId);

        /// <summary>
        /// This method deletes all notifications of the given session.
        /// </summary>
        /// <param name="gameIdString">Game id of the request in string format. </param>
        /// <param name="sessionId">Session Id.</param>
        [WebHelp(Comment = "Delete notification of the given session.")]
        [WebInvoke(Method = "DELETE", UriTemplate = "deletesession/?game={gameIdString}&session={sessionId}")]
        [OperationContract]
        void DeleteNotificationBySession(string gameIdString, string sessionId);

        /// <summary>
        /// Send a game related invite to a list of recipients. 
        /// </summary>
        /// <param name="inviteRequest">The invite request object in http request body. </param>
        [WebHelp(Comment = "Send an invite to a list of recipients.")]
        [WebInvoke(Method = "POST", UriTemplate = "invite/")]
        [OperationContract]
        void SendInvite(InviteRequest inviteRequest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\Properties\AssemblyInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/16/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationServiceFrontEnd")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8432c5b1-43bc-422a-bb67-ab882f03c5e5")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\SpotlightList.cs ===
//-------------------------------------------------------------------
// <copyright file="SpotlightList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="yguo">
//     Yonghong GUO
// </author>
//
// <summary>
//  Class to hold Spotlight list with Etag.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="1/29/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.FrontEnd
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Class to hold a list of spotlight and an Etag of the list.
    /// </summary>
    public class SpotlightList : List<Spotlight>
    {
        /// <summary>
        /// Initializes a new instance of the SpotlightList class.
        /// </summary>
        public SpotlightList() : base()
        {
            this.Etag = string.Empty;
        }

        /// <summary>
        /// Gets or sets the Etag of the spotlight list.
        /// </summary>
        public string Etag { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\SpotlightManager.cs ===
//-------------------------------------------------------------------
// <copyright file="SpotlightManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="yguo">
//     Yonghong GUO
// </author>
//
// <summary>
//  Adaptor class to get and transform spotlight feeds from cosmos.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="1/25/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.FrontEnd
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using Cosmos.Publishing.Client;
    using Cosmos.Publishing.Common;
    using Leet.Core.Caching;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Wcf;
    using Leet.Utils;

    /// <summary>
    /// Global Application Class.
    /// </summary>    
    internal class SpotlightManager
    {
        /// <summary>
        /// The max number of spotlights to fetch and return.
        /// </summary>
        private const int MaxSpotlightCount = 10;

        /// <summary>
        /// The default length of a locale string in the form of "en-US".
        /// </summary>
        private const int DefaultLocaleLength = 5;

        /// <summary>
        /// CosMos content type for Spotlight feed items. 
        /// </summary>
        private const string SpotlightContentType = "spotlight-feed";

        /// <summary>
        /// Spotlight title field from CosMos.
        /// </summary>
        private const string SpotlightTitleFieldName = "title";

        /// <summary>
        /// Spotlight subtitle field from CosMos.
        /// </summary>
        private const string SpotlightSubtitleFieldName = "subtitle";

        /// <summary>
        /// Spotlight url field from CosMos.
        /// </summary>
        private const string SpotlightUrlFieldName = "link";

        /// <summary>
        /// Spotlight game id field from CosMos.
        /// </summary>
        private const string SpotlightGameIdFieldName = "gameid";

        /// <summary>
        /// Default locale for supported countries/regions.
        /// </summary>
        private static readonly Dictionary<string, string> DefaultLocaleForRegion = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "AT", "de-AT" },
            { "AU", "en-AU" },
            { "BE", "fr-BE" },
            { "BR", "pt-BR" },
            { "CA", "en-CA" },
            { "CH", "de-CH" },
            { "CL", "es-CL" },
            { "CO", "es-CO" },
            { "CZ", "cs-CZ" },
            { "DE", "de-DE" },
            { "DK", "da-DK" },
            { "ES", "es-ES" },
            { "FR", "fr-FR" },
            { "FI", "fi-FI" },
            { "GB", "en-GB" },
            { "GR", "el-GR" },
            { "HK", "en-HK" },
            { "HU", "hu-HU" },
            { "IE", "en-IE" },
            { "IN", "en-IN" },
            { "IT", "it-IT" },
            { "JP", "ja-JP" },
            { "KR", "ko-KR" },
            { "MX", "es-MX" },
            { "NL", "nl-NL" },
            { "NO", "nb-NO" },
            { "NZ", "en-NZ" },
            { "PL", "pl-PL" },
            { "PT", "pt-PT" },
            { "RU", "ru-RU" },
            { "SG", "en-SG" },
            { "SE", "sv-SE" },
            { "TW", "zh-TW" },
            { "US", "en-US" },
            { "ZA", "en-ZA" },
        };

        /// <summary>
        /// Gets the path to spotlight feeds from cosmos.
        /// </summary>
        private static string SpotlightFeedPath
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationFE_SpotlightFeedPath);
            }
        }

        /// <summary>
        /// Gets the life in minutes of cached spotlights.
        /// </summary>
        private static int SpotlightCacheExpiryInMinutes
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationFE_SpotlightCacheExpiryInMinutes);
            }
        }

        /// <summary>
        /// Initialize and register with CosMos. 
        /// </summary>
        public static void Initialize()
        {
            // register with CosMos 
            Container.Instance.AddService<IEndpointConfigurator<IPublishingService>, EndpointConfigurator<IPublishingService>>();
            Container.Instance.AddService<IWcfProxyFactory<IPublishingService>, ServerProxyFactory<IPublishingService>>();
            Container.Instance.AddService<IPublishingService, PublishingServiceShim>();
        }

        /// <summary>
        /// Get the spotlight feed items from CosMos and transform to spotlight list. 
        /// </summary>
        /// <param name="locale">The locale of the requesting client. </param>
        /// <param name="carrierString">The optional carrier name. </param>
        /// <returns>A list of spotlights.</returns>
        public static SpotlightList GetSpotlightList(string locale, string carrierString)
        {
            // Validate the locale string from client.
            string supportedLocale = GetSupportedLocale(locale);
            if (string.IsNullOrEmpty(supportedLocale))
            {
                // locale not supported/invalid: return null
                return null;
            }

            // if we don't have a cached list for this locale, call CosMos to get it and cache
            ICacheProvider cache = Container.Instance.GetComponent<ICacheProvider>();
            SpotlightList list = cache.GetObject(supportedLocale) as SpotlightList;
            if (list == null)
            {
                list = GetSpotlightListInternal(supportedLocale, carrierString);
                DateTime absoluteExpiration = DateTime.UtcNow.AddMinutes(SpotlightCacheExpiryInMinutes);
                cache.Insert(supportedLocale, list, absoluteExpiration);
            }

            return list;
        }

        /// <summary>
        /// Get the spotlight feed items from CosMos and transform to spotlight list. 
        /// </summary>
        /// <param name="locale">The locale of the requesting client. </param>
        /// <param name="carrierString">The optional carrier name. </param>
        /// <returns>A list of spotlights.</returns>
        private static SpotlightList GetSpotlightListInternal(string locale, string carrierString)
        {
            // Get Spotlight feed path from config settings: should look like "/mobile/spotlight/{LOCALE}/feed/";
            string pathSetting = SpotlightFeedPath; 

            // if pathSetting is null, bail out
            string path = pathSetting.Replace("{LOCALE}", locale);

            var publishingService = Container.Instance.GetComponent<IPublishingService>();
            var items = publishingService.GetContentItemsInDirectory(path)
                .Where(i => i.ContentTypeName == SpotlightContentType)
                .OrderByDescending(i => i.LastUpdatedDate);

            SpotlightList resultList = new SpotlightList();
            foreach (PublishingContentItem item in items)
            {
                if (IsValidSpotlightFeedItem(item))
                {
                    uint gameId = 0;
                    string link = null;
                    if (item.Fields.ContainsKey(SpotlightGameIdFieldName))
                    {
                        UInt32.TryParse(item.Fields[SpotlightGameIdFieldName].Value, out gameId);
                    }

                    if (item.Fields.ContainsKey(SpotlightUrlFieldName))
                    {
                        link = item.Fields[SpotlightUrlFieldName].Value;
                    }

                    Spotlight spotlight = new Spotlight(
                        item.Fields[SpotlightTitleFieldName].Value,
                        item.Fields[SpotlightSubtitleFieldName].Value,
                        link,
                        gameId);

                    resultList.Add(spotlight);
                    if (resultList.Count > MaxSpotlightCount)
                    {
                        // skip extra spotlights
                        break;
                    }
                }
            }

            // Mark the list with a time stamp as the Etag
            if ((items != null) && (items.Count() > 0))
            {
                resultList.Etag = items.First().LastUpdatedDate.ToString();
            }
            else
            {
                // return an empty list with current time
                resultList.Etag = DateTime.UtcNow.ToString();
            }

            return resultList;
        }

        /// <summary>
        /// Check if the input spotlight feed item is valid.
        /// </summary>
        /// <param name="item">The spotlight feed item from CosMos. </param>
        /// <returns>Returns true if this is a valid feed item; o/w false.</returns>
        private static bool IsValidSpotlightFeedItem(PublishingContentItem item)
        {
            if ((item == null) || (item.Fields == null))
            {
                return false;
            }

            // spotlight feed item must carry title
            if (!item.Fields.ContainsKey(SpotlightTitleFieldName) ||
                string.IsNullOrEmpty(item.Fields[SpotlightTitleFieldName].Value))
            {
                return false;
            }

            // spotlight feed item must carry subtitle
            if (!item.Fields.ContainsKey(SpotlightSubtitleFieldName) ||
                string.IsNullOrEmpty(item.Fields[SpotlightSubtitleFieldName].Value))
            {
                return false;
            }

            // spotlight feed item must carry link or gameid
            if (!item.Fields.ContainsKey(SpotlightUrlFieldName) ||
                string.IsNullOrEmpty(item.Fields[SpotlightUrlFieldName].Value))
            {
                // link not provided or link value is empty: gameid must be provided
                if (!item.Fields.ContainsKey(SpotlightGameIdFieldName) ||
                    string.IsNullOrEmpty(item.Fields[SpotlightGameIdFieldName].Value))
                {
                    return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Verify that the input locale is valid; 
        /// Otherwise fall back to the default locale for a supported region.
        /// </summary>
        /// <param name="locale">The locale string from client. </param>
        /// <returns>Returns a supported locale or null.</returns>
        private static string GetSupportedLocale(string locale)
        {
            // Check if the locale is in the supported list.
            var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
            if (localeHelper.Exists(locale) == false)
            {
                // Fall back to the default locale for the region: locale must be in the form "en-US"
                string region = null;
                if ((locale.Length == DefaultLocaleLength) && (locale[2] == '-'))
                {
                    region = locale.Substring(3, 2);
                }

                if (string.IsNullOrEmpty(region) || !DefaultLocaleForRegion.ContainsKey(region))
                {
                    // invalid locale from client or region not supported: return null
                    return null;
                }
                else
                {
                    locale = DefaultLocaleForRegion[region];
                }
            }

            return locale;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\Notifications.svc.cs ===
namespace AsyncMultiplayer.NotificationService.FrontEnd
{
    using System;
    using System.Collections.Generic;
    using System.Globalization;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Web;
    using AsyncMultiplayer.NotificationService;
    using GameMetadata.Common;
    using Leet.Core.BI;
    using Leet.Core.Configuration;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics; 
    using Microsoft.ServiceModel.Web;
    using Wgx.Services.Common;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// Notification service class which handles all notificaiton related requests.
    /// </summary>
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class NotificationService : INotificationFrontEnd
    {
        /// <summary>
        /// Component Name.
        /// </summary>
        private const string ComponentName = "NotificationServiceFrontEnd";

        /// <summary>
        /// The title id for Xbox LIVE Extras app. 
        /// </summary>
        private const uint XboxLiveExtrasTitleID = 1297287404;

        /// <summary>
        /// The default number of notifications to return if Count is not specified. 
        /// </summary>
        private const int DefaultReturnCount = 20;

        /// <summary>
        /// The Max number of notifications to return. 
        /// </summary>
        private const int MaxReturnCount = 1000;

        /// <summary>
        /// The default locale if X-locale is not present. 
        /// </summary>
        private const string DefaultLocale = "en-US";

        /// <summary>
        /// The sender XUID of system notifications. 
        /// </summary>
        private const string SystemSenderXuid = "0";

        /// <summary>
        /// A fake user identity
        /// </summary>
        private static readonly IUserIdentity FakeUser = new UserIdentity(50, 2600292642023854);

        /// <summary>
        /// An empty list of notifications.
        /// </summary>
        private static readonly NotificationList emptyNotificationList = new NotificationList();

        /// <summary>
        /// An empty list of spotlight.
        /// </summary>
        private static readonly SpotlightList emptySpotlightList = new SpotlightList();

        /// <summary>
        /// The generic XBL icons in different sizes. 
        /// </summary>
        private static IDictionary<ImageType, GameImageComposite> genericXblIcons = null;

        /// <summary>
        /// Initializes a new instance of the NotificationService class.
        /// </summary>
        public NotificationService()
        {
            WcfErrorHandler.Instance.OnProvideFault += new System.EventHandler<WcfProvideFaultEventArgs>(this.Instance_OnProvideFault);
        }

        /// <summary>
        /// Gets the value of the current notificaiton storage.
        /// </summary>
        private INotificationStorage NotificationStorage
        {
            get
            {
                return StorageSingleton.NotificationStorage;
            }
        }

        /// <summary>
        /// Gets the value of the current user data storage. 
        /// </summary>
        private UserDataAzureStorage UserDataStorage
        {
            get
            {
                return StorageSingleton.UserDataStorage;
            }
        }

        /// <summary>
        /// Gets the value of the generic Xbox Live Icons. 
        /// </summary>
        private IDictionary<ImageType, GameImageComposite> GenericXblIcons
        {
            get
            {
                if (genericXblIcons == null)
                {
                    lock (typeof(ParameterValidator))
                    {
                        if (genericXblIcons == null)
                        {
                            IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                            genericXblIcons = new Dictionary<ImageType, GameImageComposite>();
                            genericXblIcons[ImageType.GameTile_WebSmall] = new GameImageComposite { Height = 32, Width = 32, ImageType = ImageType.GameTile_WebSmall, ImageUrl = configSettings.GetSetting(Settings.NotificationFE_XblIconWebSmallUrl) };
                            genericXblIcons[ImageType.GameTile_WebLarge] = new GameImageComposite { Height = 64, Width = 64, ImageType = ImageType.GameTile_WebLarge, ImageUrl = configSettings.GetSetting(Settings.NotificationFE_XblIconWebLargeUrl) };
                            genericXblIcons[ImageType.GameTile_MobileSmall] = new GameImageComposite { Height = 99, Width = 99, ImageType = ImageType.GameTile_MobileSmall, ImageUrl = configSettings.GetSetting(Settings.NotificationFE_XblIconMobileSmallUrl) };
                            genericXblIcons[ImageType.GameTile_MobileLarge] = new GameImageComposite { Height = 179, Width = 179, ImageType = ImageType.GameTile_MobileLarge, ImageUrl = configSettings.GetSetting(Settings.NotificationFE_XblIconMobileLargeUrl) };
                        }
                    }
                }

                return genericXblIcons;
            }
        }

        /// <summary>
        /// Get the spotlight notifications. 
        /// </summary>
        /// <param name="carrierString">The optional carrier name. </param>
        /// <returns>A list of spotlight notification</returns>
        public List<Spotlight> GetSpotLight(string carrierString)
        {
            try
            {
                IncomingWebRequestContext request = WebOperationContext.Current.IncomingRequest;
                string locale = request.Headers[CustomWebHeaderNames.XLocale];
                if (string.IsNullOrEmpty(locale))
                {
                    // no locale info from client: reject request.
                    ParameterValidator.RejectInput("locale is empty");
                }

                SpotlightList spotlightList = SpotlightManager.GetSpotlightList(locale, carrierString);
                if (spotlightList == null)
                {
                    return NotificationService.emptySpotlightList;
                }

                string etag = request.Headers[HttpRequestHeader.IfNoneMatch];
                OutgoingWebResponseContext response = WebOperationContext.Current.OutgoingResponse;
                response.ETag = spotlightList.Etag;
                if (!String.IsNullOrEmpty(etag) && spotlightList.Etag == etag)
                {
                    // etag identical: No spotlight changes since last request. Return 304 not modified
                    response.StatusCode = HttpStatusCode.NotModified;
                    response.SuppressEntityBody = true;
                    return null;
                }
                else
                {
                    return spotlightList;
                }
            }
            catch (Exception ex)
            {
                HandleException("GetSpotLight", ex);
            }

            return null;
        }

        /// <summary>
        /// Returns certain number of notifications starting with the given Id.
        /// User identity is based on the HTTP request authorization header.
        /// </summary>
        /// <param name="gameIdString">The string format of the gameId</param>
        /// <param name="sessionId">The sessionId string. </param>
        /// <param name="category">The category of the requested notifications. </param>
        /// <param name="lastId">Starting notification Id.</param>
        /// <param name="count">Maximum number of notification to be returned.</param>
        /// <param name="typeString">The required notification type. </param>
        /// <param name="userVisibleOnly">Whether or not search user visible notificaiton only.</param>
        /// <returns>Notification entries.</returns>
        public NotificationList GetNotifications(
            string gameIdString,
            string sessionId,
            int category,
            string lastId,
            int count,
            string typeString,
            bool userVisibleOnly)
        {
            var parameter = new NotificationQueryParameter();

            try
            {
                IUserIdentity identity = this.GetCallerIdentity();

                if (category < 0 || category == (int)Notification.NotificationCategory.NotSpecified)
                {
                    parameter.Category = null;
                }
                else
                {
                    parameter.Category = (int)ParameterValidator.ValidateEnumType<Notification.NotificationCategory>(category.ToString());
                }

                if (!string.IsNullOrEmpty(typeString))
                {
                    parameter.Type = (uint)ParameterValidator.ValidateEnumType<Notification.NotificationType>(typeString);
                }

                // Only validate the lastId if it is provided. 
                if (!string.IsNullOrEmpty(lastId))
                {
                    parameter.LastId = ParameterValidator.ValidateNotificationId(lastId);
                }

                if (!string.IsNullOrEmpty(gameIdString))
                {
                    parameter.GameId = ParameterValidator.ValidateGameId(gameIdString);
                    if (!string.IsNullOrEmpty(sessionId))
                    {
                        parameter.SessionId = ParameterValidator.ValidateSessionId(sessionId);
                    }
                }
                else
                {
                    // if gameId is not specified but session id is present, reject the input
                    if (!string.IsNullOrEmpty(sessionId))
                    {
                        ParameterValidator.RejectInput("GameId is null while sessionId is not null");
                    }
                }

                parameter.UserId = this.GetStorageKey(identity);
                parameter.Count = count <= 0 ? DefaultReturnCount : (count > MaxReturnCount ? MaxReturnCount : count);
                parameter.UserVisibleOnly = userVisibleOnly;
                
                CultureInfo cultureInfo = GetCultureInfo();
                NotificationList responseList = this.QueryNotifications(identity, parameter, cultureInfo.Name);
                this.LocalizeResponse(responseList, cultureInfo);
                return responseList;
            }
            catch (Exception ex)
            {
                HandleException("GetNotifications", ex);
            }

            return null;
        }

        /// <summary>
        /// Update the status of the notification. 
        /// </summary>
        /// <param name="notificationId">NotificationID used to update the notification. </param>
        /// <param name="status">The new status. </param>
        public void UpdateNotification(string notificationId, string status)
        {
            try
            {
                if (String.IsNullOrEmpty(notificationId))
                {
                    ParameterValidator.RejectInput("Notification ID is null or empty");
                }
                else
                {
                    ParameterValidator.ValidateNotificationId(notificationId);
                }

                Notification.NotificationStatus statusEnum = ParameterValidator.ValidateEnumType<Notification.NotificationStatus>(status);
                IUserIdentity identy = this.GetCallerIdentity();
                string userId = this.GetStorageKey(identy);
                this.NotificationStorage.UpdateNotification(
                    userId,
                    notificationId,
                    statusEnum);

                this.UserDataStorage.UpdateUserDataTimeStamp(userId);
            }
            catch (Exception ex)
            {
                HandleException("UpdateNotification", ex);
            }
        }

        /// <summary>
        /// This method deletes a notification of the given Id.
        /// </summary>
        /// <param name="notificationId">Notification Id.</param>
        public void DeleteNotificationQuery(string notificationId)
        {
            try
            {
                if (String.IsNullOrEmpty(notificationId))
                {
                    ParameterValidator.RejectInput("Notification ID is null or empty");
                }
                else
                {
                    ParameterValidator.ValidateNotificationId(notificationId);
                }

                IUserIdentity identy = this.GetCallerIdentity();
                string userId = this.GetStorageKey(identy);
                this.NotificationStorage.DeleteNotification(userId, notificationId);
                this.UserDataStorage.UpdateUserDataTimeStamp(userId);
            }
            catch (Exception ex)
            {
                HandleException("DeleteNotification", ex);
            }
        }

        /// <summary>
        /// This method deletes all notifications of the given session.
        /// </summary>
        /// <param name="gameIdString">Game id of the request in string format. </param>
        /// <param name="sessionId">Session Id.</param>
        public void DeleteNotificationBySession(string gameIdString, string sessionId)
        {
            try
            {
                if (String.IsNullOrEmpty(gameIdString))
                {
                    ParameterValidator.RejectInput("Game Id ID is null or empty");
                }

                if (String.IsNullOrEmpty(sessionId))
                {
                    ParameterValidator.RejectInput("Session ID is null or empty");
                }

                ParameterValidator.ValidateSessionId(sessionId);
                uint gameId = ParameterValidator.ValidateGameId(gameIdString);
                string locale = WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XLocale];
                GameMetadataComposite gameData = Global.MetadataClient.GetGameMetadata(gameId, locale);
                if (gameData == null)
                {
                    // invalid input. 
                    ParameterValidator.RejectInput("gameid is invalid");
                }

                IUserIdentity identy = this.GetCallerIdentity();
                string userId = this.GetStorageKey(identy);
                this.NotificationStorage.DeleteNotificationBySession(userId, gameId, sessionId);
                this.UserDataStorage.UpdateUserDataTimeStamp(userId);
            }
            catch (Exception ex)
            {
                HandleException("DeleteNotificationBySession", ex);
            }
        }

        /// <summary>
        /// Send a game related invite to a list of recipients. 
        /// </summary>
        /// <param name="inviteRequest">The invite request object in http request body. </param>
        public void SendInvite(InviteRequest inviteRequest)
        {
            try
            {
                IUserIdentity identity = this.GetCallerIdentity();
                string userId = this.GetStorageKey(identity);

                // log business intelligence data, need to log before any validations
                try
                {
                    BILogging.LogBIData(
                        OriginatorIDType.Xbox,
                        identity.Xuid,                
                        WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XPlatformType],
                        inviteRequest.GameId,
                        "notification_front_end",
                        "SendInvite");
                }
                catch (Exception ex)
                {
                    // None of this should throw, but take no chance
                    Logging.TraceException(ex,
                        ComponentName,
                        "Unexpected exception caught while writing BI data",
                        ex.ToString());
                }

                // session Id is a required field. 
                string sessionId;
                uint variant = 0;
                bool isGameVariantKnown = false;
                if (string.IsNullOrEmpty(inviteRequest.SessionId))
                {
                    sessionId = string.Empty;
                    ParameterValidator.RejectInput("sessionId is empty");
                }
                else
                {
                    // The sessionId in invite request can be a combination of sessionId & variant.
                    ParameterValidator.ParseInviteData(inviteRequest.SessionId, out sessionId, out variant, out isGameVariantKnown);
                }

                if (string.IsNullOrEmpty(inviteRequest.Recipients))
                {
                    ParameterValidator.RejectInput("receipients list is empty");
                }

                if (!string.IsNullOrEmpty(inviteRequest.Data) && (inviteRequest.Data.Length > Global.DataBlobMaxCchLength))
                {
                    ParameterValidator.RejectInput("Data member in InviteRequest is too big");
                }

                // Check how many invites the user has already sent in the past hour. 
                UserData userData = this.UserDataStorage.GetUserData(userId);
                if (userData == null)
                {
                    userData = new UserData(userId);
                }
                else if ((DateTime.UtcNow - userData.LastInviteResetTime).TotalHours > 1)
                {
                    userData.LastInviteResetTime = DateTime.UtcNow;
                    userData.InviteCount = 0;
                }
                else if (userData.InviteCount >= Global.InviteQuotaPerHour)
                {
                    throw new LIVEnException(
                        NotificationEvents.Events,
                        NotificationEvents.QuotaExceeded,
                        HttpStatusCode.NotAcceptable);
                }

                // Find the locale of the caller. Default to "en-US" if not found.
                string locale = WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XLocale];
                if (string.IsNullOrEmpty(locale))
                {
                    ParameterValidator.RejectInput("X-Locale is null or empty");
                }

                var localeHelper = Container.Instance.GetComponent<ILocaleHelper>();
                locale = localeHelper.GetSupportedLocale(locale);

                UserInfo senderInfo = new UserInfo(identity.Xuid);
                senderInfo.GamerTag = identity.Gamertag;

                InvitationNotification invite = new InvitationNotification();
                invite.From = Notification.SerializeToString(senderInfo);
                invite.GameId = inviteRequest.GameId;
                invite.SessionId = sessionId;
                if (isGameVariantKnown)
                {
                    invite.Variant = variant;
                }

                GameMetadataComposite gameData;
                if (isGameVariantKnown)
                {
                    gameData = Global.MetadataClient.GetGameMetadata(invite.GameId, locale, variant);
                }
                else
                {
                    gameData = Global.MetadataClient.GetGameMetadata(invite.GameId, locale);
                }
                
                if (gameData == null)
                {
                    // invalid input. 
                    ParameterValidator.RejectInput("gameid or variant is invalid");
                }

                // BUGBUG: SessionId and Data should be encoded to prevent XSS. 
                invite.Url = Global.MetadataClient.GetGameSessionRedirectionUrl(invite.GameId, invite.SessionId);
                if (string.IsNullOrEmpty(invite.Url))
                {
                    // invalid input. 
                    ParameterValidator.RejectInput("gameid or session id is invalid");
                }

                invite.DataBlob = inviteRequest.Data;
                invite.SupportedPlatform = (int)gameData.SupportedPlatformsBitMask;

                // create a request
                NotificationRequest request = new NotificationRequest();
                request.From = invite.From;
                request.RequestLocale = locale;
                request.Action = NotificationRequest.ActionType.Create;
                request.Command = request.Action.ToString() + Notification.NotificationType.Invitation.ToString();
                request.To = inviteRequest.Recipients;
                request.GameId = inviteRequest.GameId;
                request.SessionId = sessionId;
                request.RequestDataType = (int)Notification.NotificationType.Invitation;
                request.RequestData = Notification.SerializeToString(invite);

                Global.SendRequestUtil.SendNotificationRequest(request);

                userData.InviteCount++;
                this.UserDataStorage.UpdateUserData(userData);
            }
            catch (Exception ex)
            {
                HandleException("SendInvite", ex);
            }
        }

        /// <summary>
        /// This eventlogs the exception and throws the WebProtocol exception
        /// to the client.
        /// </summary>
        /// <param name="methodName">
        /// name of the web method from which exception is thrown.
        /// </param>
        /// <param name="ex">exception object.</param>
        private static void HandleException(string methodName, Exception ex)
        {
            Logging.TraceException(ex, "{0}: {1} {2}",
                ComponentName,
                "Exception caught in method: ",
                methodName);

            LIVEnException le = ex as LIVEnException;
            if (le == null)
            {
                le = new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.UnexpectedFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    methodName,
                    true,
                    ex.ToString());
            }

            le.ThrowWebProtocolException();
        }

        /// <summary>
        /// Query notifications.
        /// User identity is based on the HTTP request cookie or authorization header.
        /// </summary>
        /// <param name="caller">The identity of the caller. </param>
        /// <param name="queryParameter">Query parameter.</param>
        /// <returns>Notification entries.</returns>
        private
        NotificationList
        QueryNotifications(IUserIdentity caller, NotificationQueryParameter queryParameter, string localeString)
        {
            // Check if we should send out a notification request to update friend notifications
            if (this.ShouldCheckXblForFriendRequest(queryParameter))
            {
                FriendRequestNotification notification = new FriendRequestNotification();
                notification.Url = Global.FriendRequestUrl;
                notification.UserId = caller.Xuid.ToString();

                // create a notification request to do the actual check in back-end
                NotificationRequest friendRequest = new NotificationRequest();
                friendRequest.From = SystemSenderXuid;
                friendRequest.Action = NotificationRequest.ActionType.Create;
                friendRequest.Command = friendRequest.Action.ToString();
                friendRequest.To = caller.Xuid.ToString();
                friendRequest.RequestDataType = (int)Notification.NotificationType.FriendRequest;
                friendRequest.RequestData = Notification.SerializeToString(notification);

                Global.SendRequestUtil.SendNotificationRequest(friendRequest);
            }

            OutgoingWebResponseContext response = WebOperationContext.Current.OutgoingResponse;
            IncomingWebRequestContext request = WebOperationContext.Current.IncomingRequest;
            string etag = request.Headers[HttpRequestHeader.IfNoneMatch];

            UserData userData = this.UserDataStorage.GetUserData(queryParameter.UserId);
            if (userData == null)
            {
                return NotificationService.emptyNotificationList;
            }
            else
            {
                string entityToHash = userData.LastUpdateTime.ToString() + Notification.SerializeToString(queryParameter) + localeString;
                response.SetHashEtag<string>(entityToHash);
            }

            if (!String.IsNullOrEmpty(etag) && response.ETag == etag)
            {
                // the etag is the same. There is no changes. Return 304 not modified
                response.StatusCode = HttpStatusCode.NotModified;
                response.SuppressEntityBody = true;
                 return null;
            }
            else
            {
                return this.NotificationStorage.QueryNotifications(queryParameter);
            }
        }

        /// <summary>
        /// Get the current user identity from the request context. 
        /// </summary>
        /// <returns>The user identity. </returns>
        private IUserIdentity GetCallerIdentity()
        {
            IAuthenticationManager authManager = null;

            if (Global.DebugMode)
            {
                return FakeUser;
            }

            authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AuthenticationFailure,
                    HttpStatusCode.Unauthorized);
            }

            return authManager.CurrentUser;
        }

        /// <summary>
        /// Gets the identity key used for storage. 
        /// </summary>
        /// <param name="identity">The identity of the caller. </param>
        /// <returns>The identity key string. </returns>
        private string GetStorageKey(IUserIdentity identity)
        {
            return identity.Xuid.ToString();
        }

        /// <summary>
        /// Serialize the image urls from a dictionary. 
        /// Dictionary itself is not serailable. Here just convert it into a list. 
        /// </summary>
        /// <param name="images">The dictionary that contains all image urls. </param>
        /// <returns>The serialized list of image urls</returns>
        private string SerializeImageUrls(IDictionary<ImageType, GameImageComposite> images)
        {
            List<GameImageComposite> imageUrlList = new List<GameImageComposite>();
            foreach (ImageType type in images.Keys)
            {
                imageUrlList.Add(images[type]);
            }

            return Notification.SerializeToString(imageUrlList);
        }

        /// <summary>
        /// Deep copy dictionary from source to destination
        /// </summary>
        /// <param name="src">Source</param>
        /// <param name="dest">Destination</param>
        private void DeepCopy(IDictionary<ImageType, GameImageComposite> src, IDictionary<ImageType, GameImageComposite> dest)
        {
            string imageUrl = src.ContainsKey(ImageType.GameTile_WebSmall)
                                  ? src[ImageType.GameTile_WebSmall].ImageUrl
                                  : GenericXblIcons[ImageType.GameTile_WebSmall].ImageUrl;
            dest.Add(ImageType.GameTile_WebSmall,new GameImageComposite { Height = 32, Width = 32, ImageType = ImageType.GameTile_WebSmall, ImageUrl = imageUrl});

            imageUrl = src.ContainsKey(ImageType.GameTile_WebLarge)
                           ? src[ImageType.GameTile_WebLarge].ImageUrl
                           : GenericXblIcons[ImageType.GameTile_WebLarge].ImageUrl;
            dest.Add(ImageType.GameTile_WebLarge,new GameImageComposite { Height = 64, Width = 64, ImageType = ImageType.GameTile_WebLarge, ImageUrl = imageUrl});

            imageUrl = src.ContainsKey(ImageType.GameTile_MobileSmall)
                           ? src[ImageType.GameTile_MobileSmall].ImageUrl
                           : GenericXblIcons[ImageType.GameTile_MobileSmall].ImageUrl;
            dest.Add(ImageType.GameTile_MobileSmall, new GameImageComposite { Height = 99, Width = 99, ImageType = ImageType.GameTile_MobileSmall, ImageUrl = imageUrl });

            imageUrl = src.ContainsKey(ImageType.GameTile_MobileLarge)
                           ? src[ImageType.GameTile_MobileLarge].ImageUrl
                           : GenericXblIcons[ImageType.GameTile_MobileLarge].ImageUrl;
            dest.Add(ImageType.GameTile_MobileLarge, new GameImageComposite { Height = 179, Width = 179, ImageType = ImageType.GameTile_MobileLarge, ImageUrl = imageUrl });
        }

        /// <summary>
        /// Determine if we should check friend request based on input query paramters. 
        /// </summary>
        /// <param name="queryParams">The query parameters. </param>
        /// <returns>True if should.</returns>
        private bool ShouldCheckXblForFriendRequest(NotificationQueryParameter queryParams)
        {
            if ((queryParams.Type == (uint)Notification.NotificationType.FriendRequest) || (queryParams.Type == (uint)Notification.NotificationType.Message))
            {
                return true;
            }

            if (queryParams.Type == null)
            {
                if ((queryParams.GameId == null) || (queryParams.GameId == 0))
                {
                    if (string.IsNullOrEmpty(queryParams.SessionId))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <summary>
        /// Returns the CultureInfo of the current incoming request
        /// </summary>
        /// <returns></returns>
        private CultureInfo GetCultureInfo()
        {
            CultureInfo cultureInfo;
            IncomingWebRequestContext request = WebOperationContext.Current.IncomingRequest;
            string localeString = request.Headers[CustomWebHeaderNames.XLocale];
            try
            {
                if (!string.IsNullOrEmpty(localeString))
                {
                    cultureInfo = new CultureInfo(localeString, false);
                }
                else
                {
                    cultureInfo = new CultureInfo(DefaultLocale, false);
                }
            }
            catch
            {
                // the locale is not a valid one, just use default locale. 
                cultureInfo = new CultureInfo(DefaultLocale, false);
            }
            return cultureInfo;
        }


        /// <summary>
        /// Localize the notification based on the locale. 
        /// </summary>
        /// <param name="notificationList">The notification list to be localized. </param>
        private void LocalizeResponse(NotificationList notificationList, CultureInfo cultureInfo)
        {
             NotificationList localizedList = notificationList;

            if (notificationList != null)
            {
                for (int i = notificationList.Count - 1; i >= 0; i--)
                {
                    Notification notification = notificationList[i];
   
                    // Filtering out notifications for locales not supported by LiveApp yet
                    if (notification.GameId == XboxLiveExtrasTitleID) 
                    {
                        if (Global.LiveAppSupportedLocales.IndexOf(cultureInfo.Name, StringComparison.OrdinalIgnoreCase) == -1)
                        {
                            notificationList.RemoveAt(i);
                            continue;
                        }
                    }

                    // for title, the fallback scheme is done by game metadata service.
					// We assume it will always return  something.
                    GameMetadataComposite gameData = null;
                    if (notification.GameId != 0)
                    {
                        gameData = Global.MetadataClient.GetGameMetadata(notification.GameId, cultureInfo.Name, notification.Variant);

                        if (gameData != null)
                        {
                            notification.GameDisplayName = gameData.GameAndVariantName;
                            notification.Url = gameData.GameRedirectionUrl;
                            IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                            IDictionary<ImageType, GameImageComposite> gameImages = new Dictionary<ImageType, GameImageComposite>();

                            if ((gameData.Images == null) || (gameData.Images.Count == 0))
                            {
                                DeepCopy(this.GenericXblIcons, gameImages);
                            }
                            else
                            {
                                DeepCopy(gameData.Images, gameImages);
                            }
                            if (notification.Type == Notification.NotificationType.Message)
                            {
                                // Override the image url
                                gameImages[ImageType.GameTile_MobileSmall].ImageUrl =
                                    configSettings.GetSetting(Settings.NotificationFE_LiveAppMessageMobileSmallUrl);
                            }
                            if (notification.Type == Notification.NotificationType.FriendRequest)
                            {
                                // Override the image url
                                gameImages[ImageType.GameTile_MobileSmall].ImageUrl =
                                     configSettings.GetSetting(Settings.NotificationFE_LiveAppFRMobileSmallUrl);
                            }
                            notification.Images = this.SerializeImageUrls(gameImages);
                        }
                    }
                    else if (notification.Type == Notification.NotificationType.Beacon)
                    {
                        // Beacons have a title id of 0 but send custom images.  They also
                        // store all of the locale-specific GameDisplayNames in the DataBlob.

                        // Set the GameDisplayName based on the user's locale
                        notification.GameDisplayName = LocalizationUtility.LocalizedBeaconGameDisplayName(cultureInfo, notification.DataBlob);

                        // Beacons used the DataBlob to hold the localized game display names, so we should now get rid of it.
                        notification.DataBlob = string.Empty;

                        // Use a default image if none were passed in the Notification
                        if (string.IsNullOrEmpty(notification.Images))
                        {
                            notification.Images = this.SerializeImageUrls(this.GenericXblIcons);
                        }
                    }
                    else
                    {
                        // The notification is not tied to a specific game: Use the generic XBL icons
                        notification.Images = this.SerializeImageUrls(this.GenericXblIcons);
                    }
                  
                    notification.TypeDisplayName = LocalizationUtility.LocalizedNotificationType(notification.Type.ToString(), cultureInfo);
                }
            }
        }

        /// <summary>
        /// Provide fault with our own error handler.
        /// </summary>
        /// <param name="sender">The object that sends the event. </param>
        /// <param name="e">The arguments of the event. </param>
        private void Instance_OnProvideFault(object sender, WcfProvideFaultEventArgs e)
        {
            if (e.Exception != null)
            {
                // Check if we have handled the exception
                if (e.Exception is WebProtocolException)
                {
                    WebProtocolException webEx = e.Exception as WebProtocolException;
                    if (webEx.StatusCode == HttpStatusCode.InternalServerError)
                    {
                        e.WebOperationContext.OutgoingResponse.StatusCode = HttpStatusCode.InternalServerError;
                    }

                    return;
                }
                else if (e.Exception is FormatException)
                {
                    e.WebOperationContext.OutgoingResponse.StatusCode = HttpStatusCode.BadRequest;
                }
                else
                {
                    // Errors did't get handled are internal server errors. 
                    e.WebOperationContext.OutgoingResponse.StatusCode = HttpStatusCode.InternalServerError;
                    ServiceErrorMessage errorMessage = new ServiceErrorMessage()
                    {
                        ApiName = e.WebOperationContext.IncomingRequest.UriTemplateMatch.RequestUri.LocalPath,
                        LIVEnErrorCode = (uint)NotificationEvents.UnexpectedFailure,
                        ErrorMessage = "Internal Server Error.",
                    };

                    FaultException<ServiceErrorMessage> fe = new FaultException<ServiceErrorMessage>(errorMessage);
                    MessageFault mf = fe.CreateMessageFault();
                    e.Message = Message.CreateMessage(e.MessageVersion, mf, null);
                }
            }
        }

        /// <summary>
        /// Class to hold singleton notification storage.
        /// </summary>
        private class StorageSingleton
        {
            /// <summary>
            /// Interface to the current notification storage.
            /// </summary>
            internal static readonly INotificationStorage NotificationStorage =
                new NotificationAzureStorage(
                    Global.AzureTableStorageEndPoint,
                    Global.AzureStorageAccount,
                    Global.AzureStorageToken,
                    Global.ProxyAddress);

            /// <summary>
            /// current UserDataStorage provider. 
            /// </summary>
            internal static readonly UserDataAzureStorage UserDataStorage =
                new UserDataAzureStorage(
                    Global.AzureTableStorageEndPoint,
                    Global.AzureStorageAccount,
                    Global.AzureStorageToken,
                    Global.ProxyAddress);

            /// <summary>
            /// Initializes static members of the StorageSingleton class.
            /// </summary>
            static StorageSingleton()
            {
                return;
            }
        }

        /// <summary>
        /// Helper class for input parameter validation.
        /// </summary>
        private class ParameterValidator
        {
            /// <summary>
            /// The maximum length of a game session identifier. 
            /// </summary>
            private const int MaxSessionIdLength = 64;

            /// <summary>
            /// Validate the format of the NotificationId. 
            /// </summary>
            /// <param name="id">The provided notification Id</param>
            /// <returns>The notification id if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static string ValidateNotificationId(string id)
            {
                // the id has to parts {0:19}-{1}, the second part is a guid
                if (id.Length != Notification.IdLength)
                {
                    RejectInput("notificationId lenght is invalid");
                }

                try
                {
                    ulong ticks = ulong.Parse(id.Substring(0, Notification.IdTicksLength));
                    Guid myguid = new Guid(id.Substring(Notification.IdTicksLength + 1, Notification.IdGuidLength));
                }
                catch
                {
                    RejectInput("notificationId is invalid");
                }

                return id;
            }

            /// <summary>
            /// Validate the length of a session identifier. 
            /// </summary>
            /// <param name="sessionId">The provided session Id</param>
            /// <returns>The session id if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static string ValidateSessionId(string sessionId)
            {
                if (sessionId.Length >= MaxSessionIdLength)
                {
                    RejectInput("Session ID is invalid");
                }

                return sessionId;
            }

            /// <summary>
            /// Validate game identifier. 
            /// </summary>
            /// <param name="gameIdString">The provided game Id string.</param>
            /// <returns>The game id if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static uint ValidateGameId(string gameIdString)
            {
                uint gameId = 0;
                if (uint.TryParse(gameIdString, out gameId) == false)
                {
                    RejectInput("Game ID is invalid");
                }

                return gameId;
            }

            /// <summary>
            /// Validate input value against some enumeration type. 
            /// </summary>
            /// <typeparam name="T">An enum type.</typeparam>
            /// <param name="valueString">The provided enum value string.</param>
            /// <returns>The matching enum value if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static T ValidateEnumType<T>(string valueString)
            {
                T value = default(T);

                try
                {
                    value = (T)Enum.Parse(typeof(T), valueString, true);
                }
                catch
                {
                    RejectInput(valueString + " is not a valid value for enum type: " + typeof(T).Name);
                }

                if (Enum.IsDefined(typeof(T), value) == false)
                {
                    RejectInput(valueString + " is not a valid value for enum type: " + typeof(T).Name);
                }

                return value;
            }

            /// <summary>
            /// A helper method to throw bad request exception. 
            /// </summary>
            /// <param name="msg">The reason of the reject. </param>
            public static void RejectInput(string msg)
            {
                throw new LIVEnException(
                        NotificationEvents.Events,
                        NotificationEvents.InvalidArgument,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        msg);
            }

            /// <summary>
            /// Parses the invite data sessionId.
            /// </summary>
            /// <param name="inviteSessionIdString">The input string passed as sessionId in the invitation.</param>
            /// <param name="sessionId">The parsed sessionId.</param>
            /// <param name="variant">The parsed game variant.</param>
            /// <param name="isGameVariantKnown">Was the game variant found in the input string.</param>
            public static void ParseInviteData(string inviteSessionIdString, out string sessionId, out uint variant, out bool isGameVariantKnown)
            {
                char[] delimiter = new char[] { ':' };
                string[] splitResult = inviteSessionIdString.Split(delimiter);

                // Initialize the default values.
                sessionId = string.Empty;
                variant = 0;
                isGameVariantKnown = false;

                if (splitResult.Length == 1)
                {
                    sessionId = inviteSessionIdString;
                }
                else if (splitResult.Length == 2)
                {
                    sessionId = splitResult[0];
                    if (!uint.TryParse(splitResult[1], out variant))
                    {
                        RejectInput("SessionId: " + inviteSessionIdString + " in the input is not valid, it must be in the format: <sessionId> or <sessionId>:<variantId>");
                    }
                    else
                    {
                        isGameVariantKnown = true;
                    }

                }
                else
                {
                    RejectInput("SessionId: " + inviteSessionIdString + " in the input is not valid, it must be in the format: <sessionId> or <sessionId>:<variantId>");
                }

                ValidateSessionId(sessionId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\V1\ISubscribe.cs ===

using AsyncMultiplayer.NotificationService;

namespace NotificationServiceFrontEnd.V1
{
    using System.ServiceModel;
    using System.ServiceModel.Web;

     /// <summary>
    /// Subscription End point contract definitions
    /// </summary>
    [ServiceContract]
    public interface ISubscription
    {
        /// <summary>
        /// Update the push subscription information for the user
        /// </summary>
        /// <param name="url"> The Push Url for the user</param>
        /// <param name="subTypes">Subscrption for notifications (e.g., = "*" or "YourTurn,Outcome,Invite"). Currently only "*" is supported</param>
        [WebInvoke(Method = "PUT", UriTemplate = "Push?gamertag={gt}&key={key}")]
        [OperationContract]
        void UpdatePushSubscription(PushSubscription subscription,string gt,string key);

        /// <summary>
        /// Delete push subscription for the user
        /// </summary>
        [WebInvoke(Method = "DELETE", UriTemplate = "Push?gamertag={gt}&key={key}")]
        [OperationContract]
        void DeletePushSubscription(string gt,string key);

        /// <summary>
        /// Get existing subscription information
        /// </summary>
        [WebInvoke(Method = "GET", UriTemplate = "Push?gamertag={gt}&key={key}")]
        [OperationContract]
        PushSubscription GetPushSubscription(string gt, string key);
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd\V1\subscribe.svc.cs ===
using System.ServiceModel.Web;
using Microsoft.ServiceModel.Web;

namespace NotificationServiceFrontEnd.V1
{
    using System;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using AsyncMultiplayer.NotificationService;
    using AsyncMultiplayer.NotificationService.FrontEnd;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Live.Livecache.DataAccess;
    using LIVEN.Common.Diagnostics;


    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public class Subscribe : ISubscription
    {
        /// </summary>
        internal static readonly UserDataAzureStorage UserDataStorage =
            new UserDataAzureStorage(
                Global.AzureTableStorageEndPoint,
                Global.AzureStorageAccount,
                Global.AzureStorageToken,
                Global.ProxyAddress);

        private const int MaxKeyLength = 64;

        #region Helper Functions
        /// <summary>
        /// Validate that the submittmed Push subscription information is syntactically valid
        /// </summary>
        /// <param name="subType"></param>
        /// <param name="key"></param>
        internal static void ValidatePushSubscription(PushSubscription sub, string key)
        {
            if ((key.Length > MaxKeyLength) || (key.Length < 1))
            {
                throw (new LIVEnException(
                  NotificationEvents.Events,
                  NotificationEvents.InvalidArgument,
                  HttpStatusCode.BadRequest,
                  null,
                  "ValidatePushSubscription",
                  false,
                  "Key mising or too long"));
            }
           
            if (sub == null)
            {
                throw (new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.InvalidArgument,
                    HttpStatusCode.BadRequest,
                    null,
                    "ValidatePushSubscription",
                    false,
                    "Subscription was not specified"));
            }
            if (sub.SubTypes != "*")
            {
                throw (new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.InvalidArgument,
                    HttpStatusCode.BadRequest,
                    null,
                    "ValidatePushSubscription",
                    false,
                    "SubType:"+ sub.SubTypes+" not allowed"));
            }
            if (String.IsNullOrEmpty(key))
            {
                throw (new LIVEnException(
                   NotificationEvents.Events,
                   NotificationEvents.InvalidArgument,
                   HttpStatusCode.BadRequest,
                   null,
                   "ValidatePushSubscription",
                   false,
                   "Key:"+key+" not allowed"));

            }
            Uri resultUri;
            if (!Uri.TryCreate(sub.Url,UriKind.Absolute,out resultUri))
            {
                throw (new LIVEnException(
                   NotificationEvents.Events,
                   NotificationEvents.InvalidArgument,
                   HttpStatusCode.BadRequest,
                   null,
                   "ValidatePushSubscription",
                   false,
                   "Url:"+sub.Url+" not valid"));

            }
        }

        /// <summary>
        /// Authenticate the user
        /// </summary>
        /// <param name="gamertag"></param>
        /// <returns>Xuid for the user</returns>
        internal static ulong Authenticate(string gamertag)
        {

            if (String.IsNullOrEmpty(gamertag))
            {
                throw (new LIVEnException(
                     NotificationEvents.Events,
                     NotificationEvents.InvalidArgument,
                     HttpStatusCode.BadRequest,
                     null,
                     "Authenticate",
                     false,
                     "Gamertag is invalid"));
            }
            var authManager = Container.Instance.GetComponent<IAuthenticationManager>();

            if (!authManager.IsAuthenticated)
            {
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AuthenticationFailure,
                    HttpStatusCode.Unauthorized);
            }

            var xcache = Container.Instance.GetComponent<IXCacheDataAccess>();
            ulong xuid;
            xcache.GetPuidByGamerTag(gamertag, out xuid);
            if (xuid != authManager.CurrentUser.Xuid)
            {
                throw new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.AuthenticationFailure,
                    HttpStatusCode.Unauthorized,null,string.Empty,false,"Gamertag:"+ gamertag+" does not match authentication token");
            }
            return authManager.CurrentUser.Xuid;

        }

        #endregion

        # region UpdatePushSubscription
        /// <summary>
        /// Update Push Subscription for the user. User Token in http header is used to 
        /// authenticate the user. 
        /// </summary>
        /// <param name="subscription">Subscription</param>
        /// <param name="gt">gamertag of the targe user. We only allow user to update his own subscription</param>
        /// <param name="key">subscription key<</param>
        public void UpdatePushSubscription(PushSubscription subscription, string gt,string key)
        {
            try
            {
                ValidatePushSubscription(subscription, key);
                UpdatePushSubscription(subscription, key, Authenticate(gt));
            }
            catch (LIVEnException le)
            {
                le.ThrowWebProtocolException();
            }

        }
        
        /// <summary>
        /// Update Push subscription for the user
        /// </summary>
        /// <param name="subscription">Subscription</param>
        /// <param name="key">subscription key</param>
        /// <param name="xuid">user to update</param>
        private static void UpdatePushSubscription(PushSubscription subscription,string key,ulong xuid)
        {
            // Find the locale of the caller. Default to "en-US" if not found.
            string locale = (WebOperationContext.Current != null) ? WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XLocale] : null;
            if (string.IsNullOrEmpty(locale))
            {
                throw (new LIVEnException(
                NotificationEvents.Events,
                NotificationEvents.InvalidArgument,
                HttpStatusCode.BadRequest,
                null,
                "UpdatePushSubscription",
                false,
                "X-Locale missing"));
            }
            try
            {
                string userXuid = xuid.ToString();
                UserData userData = UserDataStorage.GetUserData(userXuid);

                if (userData == null)
                {
                    userData = new UserData(userXuid);
                }

                userData.Push.Url = subscription.Url;
                userData.Push.UrlKey = key;
                userData.Push.SubTypes = subscription.SubTypes;
                userData.Push.Locale = locale;

                UserDataStorage.UpdateUserData(userData);
            }
            catch (LIVEnException e)
            {
                e.ThrowWebProtocolException();
            }
        }

        #endregion

        #region Delete Push Subscription
        /// <summary>
        /// Delete the subscription specified by the key
        /// </summary>
        /// <param name="gt"></param>
        /// <param name="key"></param>
        public void DeletePushSubscription(string gt,string key)
        {
            try
            {
                DeletePushSubscription(key, Authenticate(gt));
            }
            catch (LIVEnException le)
            {
                le.ThrowWebProtocolException();
            }
           
        }
       
        internal void DeletePushSubscription(string key,ulong xuid)
        {
            if ((key.Length > MaxKeyLength) || (key.Length < 1))
            {
                throw (new LIVEnException(
                  NotificationEvents.Events,
                  NotificationEvents.InvalidArgument,
                  HttpStatusCode.BadRequest,
                  null,
                  "DeletePushSubscription",
                  false,
                  "Key mising or too long"));
            }
           
            try
            {
                string userXuid= xuid.ToString();
                UserData userData = UserDataStorage.GetUserData(userXuid);

                if (userData != null)
                {
                    if (userData.Push.UrlKey == key)
                    {
                        userData.Push.Url = string.Empty;
                        userData.Push.UrlKey = string.Empty;
                        userData.Push.SubTypes = string.Empty;
                    }
                    else
                    {
                        throw (new LIVEnException(
                            NotificationEvents.Events,
                            NotificationEvents.InvalidArgument,
                            HttpStatusCode.NotFound,
                            null,
                            "DeletePushSubscription",
                            false,
                            "Key specified:"+key+" does not match "+ userData.Push.UrlKey+" for the user"));

                    }
                    UserDataStorage.UpdateUserData(userData);
                }
            }
            catch (LIVEnException le)
            {
                le.ThrowWebProtocolException();
            }
        }

        #endregion


        #region Get Push Subscription
        /// <summary>
        /// Get the Push subscription for the user specified for gamertag and the key for subscription
        /// </summary>
        /// <param name="gt"></param>
        /// <param name="key"></param>
        /// <returns></returns>
        public PushSubscription GetPushSubscription(string gt, string key)
        {
            var subscription = new PushSubscription();
            try
            {
                subscription=GetPushSubscription(key, Authenticate(gt));
            }
            catch (LIVEnException le)
            {
                le.ThrowWebProtocolException();
            }

            return subscription;
        }

        /// <summary>
        /// Get the exisiting Push Subscription
        /// </summary>
        /// <param name="key"></param>
        /// <param name="xuid"></param>
        /// <returns>Push Subscription associated with given key</returns>
        internal static PushSubscription GetPushSubscription(string key, ulong xuid)
        {
            var subscription = new PushSubscription();
            string userXuid = xuid.ToString();
            UserData userData = null;

            try
            {
                userData = UserDataStorage.GetUserData(userXuid);
                if ((userData == null) || (userData.Push.UrlKey != key))
                {

                    throw new WebProtocolException(
                        HttpStatusCode.NotFound,
                        string.Empty,
                        new ServiceErrorMessage()
                            {
                                ApiName = "GetPushSubscription",
                                ErrorMessage =
                                    "Key specified:" + key + " does not match " +
                                    (userData == null ? "null" : userData.Push.UrlKey)
                            },
                        null);
                }
                subscription.Url = userData.Push.Url;
                subscription.SubTypes = userData.Push.SubTypes;
            }
            catch (LIVEnException e)
            {
                e.ThrowWebProtocolException();
            }
            return subscription;
        }

        #endregion
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd.Test\Properties\AssemblyInfo.cs ===
//-------------------------------------------------------------------
// <copyright file="AssemblyInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Assembly information
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("NotificationServiceFrontEnd.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("8f185491-4837-418e-ae16-c7734b5d3fc5")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd.Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="zhangxu">
//     Zhangwei Xu
// </author>
//
// <summary>
//  Main cs file
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="08/25/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.NotificationServiceFrontEnd.Test
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.IO;
    using System.Linq;
    using System.Text;
    using System.Xml.Serialization;
    using Microsoft.Http;

    /// <summary>
    /// Main class for notification service front end test application.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main function.
        /// </summary>
        /// <param name="args">Parameters of the commandline</param>
        public static void Main(string[] args)
        {
            string serverUrl = ConfigurationSettings.AppSettings["ServerUrl"].ToString();
            var client = new HttpClient(serverUrl);

            // Publish a notificaiton by calling into NotificationStub which
            // will create a notificaiton message
            // TODO: After we have the queue, insert into the queue directly
            
            // Retrieve all notificaitons
            Console.WriteLine("Calling: " + serverUrl);
            HttpResponseMessage response = client.Get(string.Empty);
            Console.WriteLine(response.Content.ReadAsString());
            Console.ReadLine();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal.Setup\makefile.inc ===
# this is a slight modification of the makefile.def target that skips ComVisible since it's specified per project.

$(OBJ_PATH)\$O\_generated.cs: $(SOURCES_USED)
    -$(_DEL)
    set createfile=<<$@.temp
!if defined(LANGUAGE_SPECIFIC_MANAGED_RESOURCES) && "$(MUI)" == "1" && "$(URT_VER)" == "2.0"
[assembly:System.Resources.NeutralResourcesLanguage("en")]
!endif
[assembly:System.Reflection.AssemblyVersion("$(ASSEMBLY_IDENTITY_VERSION)")]
!ifdef VER_PRODUCTNAME_STR
[assembly:System.Reflection.AssemblyProduct("$(VER_PRODUCTNAME_STR)")]
!endif
!ifdef VER_LEGALCOPYRIGHT_STR
[assembly:System.Reflection.AssemblyCopyright("$(VER_LEGALCOPYRIGHT_STR)")]
!endif
!ifdef VER_COMPANYNAME_STR
[assembly:System.Reflection.AssemblyCompany("$(VER_COMPANYNAME_STR)")]
!endif
!ifdef VER_PRODUCTVERSION_STR
[assembly:System.Reflection.AssemblyFileVersion("$(VER_PRODUCTVERSION_STR)")]
!endif
<<KEEP
!if defined(_ASSEMBLY_IDENTITY) \
        && "$(_ASSEMBLY_IDENTITY_PUBLIC_KEY_NAME_LOWERCASE)" != "none" \
        && "$(_ASSEMBLY_IDENTITY:\=)" == "$(_ASSEMBLY_IDENTITY)" \
        && !defined(_MANAGED_CXX_LIBRARY) \
        && "$(MANAGED_TARGET_TYPE)" != "module"
    asmIdToAttribs.cmd "$(_ASSEMBLY_IDENTITY)" $@.temp csharp
!endif
    $(_MOVE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal\NotificationServiceInstall.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationServiceInstall.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The ProjectInstaller class. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/29/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.Internal
{
    using System;
    using System.ComponentModel; 
    using System.Configuration.Install; 
    using System.ServiceModel;
    using System.ServiceProcess;
   
    /// <summary>
    /// Defines the project installer class. This is used to install the service. 
    /// </summary>
    [RunInstaller(true)]
    public class ProjectInstaller : Installer
    {
        /// <summary>
        /// The ServiceProcessInstaller object. 
        /// </summary>
        private ServiceProcessInstaller process;

        /// <summary>
        /// The ServiceInstaller service object. 
        /// </summary>
        private ServiceInstaller service;

        /// <summary>
        /// Initializes a new instance of the ProjectInstaller class. 
        /// </summary>
        public ProjectInstaller()
        {
            this.process = new ServiceProcessInstaller();
            this.process.Account = ServiceAccount.LocalSystem;
            this.service = new ServiceInstaller();
            this.service.ServiceName = "AsyncMultiplayer Notification Service";
            Installers.Add(this.process);
            Installers.Add(this.service);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal\NotificationService.cs ===
using System.Data.SqlClient;

namespace AsyncMultiplayer.NotificationService.Internal
{
    using System;
    using System.Configuration;
    using System.Threading;
    using AsyncMultiplayer.NotificationService;
    using Common.AzureStorage;
    using Leet.Identity;
    using LIVEN.Common.Diagnostics;
    using Wgx.Services.Monitoring;
    using Leet.Health.Common;
    using Leet.Core.Diagnostics;
    using NotificationCommon;
    using Leet.Core.Configuration;


    /// <summary>
    /// The main Notification service.
    /// </summary>
    public partial class NotificationService : System.ServiceProcess.ServiceBase
    {
        private static void Main(string[] args)
        {
            // Use -debug mode to run in debugger rather than as a hosted service
            if (args.Length > 0 && string.Compare(args[0], "-debug") == 0)
            {
                string[] argArr = new string[args.Length - 1];

                if (args.Length - 1 > 0)
                {
                    Array.Copy(args, 1, argArr, 0, args.Length - 1);
                }

                NotificationService notificationService = new NotificationService();
                notificationService.Run(argArr);
            }
            else
            {
                System.ServiceProcess.ServiceBase[] ServicesToRun;

                ServicesToRun = new System.ServiceProcess.ServiceBase[] 
                { 
                    new NotificationService() 
                };

                System.ServiceProcess.ServiceBase.Run(ServicesToRun);
            }
        }

        protected override void OnStart(string[] args)
        {
            try
            {
                ConfigInstance = new ServiceConfigs();
                ConfigInstance.Initialize();

                Logging.TraceInformation("{0}: {1}",
                    ComponentName,
                    "Starting NotificationServce.");

                string serviceConfigName = ConfigurationManager.AppSettings["ServiceConfigName"];
                NotificationEvents.Initialize(serviceConfigName);

                // Set the default directory to current.Service will use system32 by default. 
                // this is required in case any of the file path uses relative path. 
                System.IO.Directory.SetCurrentDirectory(System.AppDomain.CurrentDomain.BaseDirectory);

                IdentityManager.RegisterWithIocContainer(Leet.Core.IoCCo.Container.Instance);

                StorageClientPerfCounters.Counters =
                    PerformanceCounters.GetPerformanceCounters(typeof(StorageClientPerfCounters), ComponentName);


                connectionString = ConfigInstance.NotificationRequestQueueConnectionString;
                // Warm the thread pool to prevent spin-up thrash at start time
                ThreadPool.SetMinThreads(ConfigInstance.MaxThreadCount, ConfigInstance.MaxThreadCount);

                // Init health listener
                try
                {
                    string healthCheckPort = ConfigurationManager.AppSettings["HealthCheck_HighPort"]; ;
                    // invoke the health listner only when port can be found in NotificationService.exe.config
                    if (String.IsNullOrEmpty(healthCheckPort))
                    {
                        Logging.TraceError("{0}: {1}",
                            ComponentName,
                            "healthCheckPort is empty in the NotificationService.exe.config file.");
                    }
                    else
                    {
                        ushort listnerPort = UInt16.Parse(healthCheckPort);
                        HealthListener.InitializeHealthListener(serviceConfigName, listnerPort);
                    }
                }
                catch (Exception ex)
                {
                    // we should let the Notification Service run
                    // any exception caught here can only be due to bad configuration which should not happen
                    Logging.TraceException(ex, "{0}: {1}",
                        ComponentName,
                        "Caught exception initializing health blocks.");
                }

                Logging.TraceInformation("{0}: {1}",
                    ComponentName,
                    "NotificationService started.");

                NotificationEvents.Events.TraceEvent(
                    NotificationEvents.ServiceStarted,
                    "\r\nNotification Service Started Successfully");

                // Queue up the first worker thread to begin processing messages.  Additional thread pool threads will
                // be appropriated by ProcessMessage()
                ThreadPool.QueueUserWorkItem(new WaitCallback(this.ProcessMessage));
            }
            catch (Exception e)
            {
                Logging.TraceException(e, "{0}: {1}",
                    ComponentName,
                    "Exception caught during NotificationService start up. See event log for the details.");

                NotificationEvents.Events.TraceEvent(
                    NotificationEvents.ServiceFailedToStart,
                    "\r\nUnexpceted exception happened when starting notification NT service.",
                    e.ToString());

                throw; // throw the exception if anything gone awry on service start.
            }
        }

        protected override void OnStop()
        {
            Logging.TraceInformation("{0}: {1}",
                ComponentName,
                "Stopping NotificationService.");

            shutdownEvent.Reset();
            doShutdown = true;
            shutdownEvent.WaitOne();

            Logging.TraceInformation("{0}: {1}",
                ComponentName,
                "NotificationService stopped.");

            NotificationEvents.Events.TraceEvent(
                NotificationEvents.ServiceStopped,
                "NotificationService Stopped Successfully");

        }

        /// <summary>
        /// Top level worker function.  This will spawn thread pool threads to process messages from
        /// the NotificationProcessingQueue .
        /// </summary>
        /// <param name="state">Any state from the top level application that can be passed in</param>
        private void ProcessMessage(Object state)
        {
            MessageReceiver receiver = null;
            bool resetDelay = true;

            try
            {
                try
                {
                    receiver = new MessageReceiver(connectionString);
                }
                catch (Exception ex)
                {
                    UpdateDelay();
                    resetDelay = false;
                    if (typeof(SqlException) == ex.GetType())
                    {
                        HandleSqlException("ProcessMessage()",(SqlException)ex);
                    }
                    else
                    {
                        Logging.TraceException(ex, "Failed to construct a MessageReceiver instance");
                    }
                }

                if (receiver == null)
                {
                    // failed to fetch a message, so fire up another attempt
                    DispatchProcessorThread();
                }
                else
                {
                    //** Retrieve and process a message **//
                    
                    IConfigurationProvider configSettings = Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>();
                    // Note that this attribute is ThreadStatic, so each thread will have its own value
                    NotificationAuditLog.IsEnabled = configSettings.GetBoolSetting(Settings.NotificationInternal_AuditingEnabled);

                    NotificationRequest notificationRequest = null;
                    bool gotMessage = false;

                    try
                    {
                        gotMessage = receiver.TryReceiveOneMessage(out notificationRequest);
                    }
                    catch (Exception ex)
                    {
                        if (typeof (SqlException) == ex.GetType())
                        {
                            HandleSqlException("ProcessMessage()", (SqlException) ex);
                        }
                        UpdateDelay();
                        resetDelay = false;
                    }
                    finally
                    {
                        // TODO:  Determine if we need this to throttle max workers for perf reasons
                        //while (this.messagesProcessing > maxConcurrentThreads - 1)
                        //{
                        //    Thread.Sleep(10);
                        //}
                        DispatchProcessorThread();
                    }

                    if (gotMessage)
                    {
                        Interlocked.Increment(ref messagesProcessing);
                        // pre-increment timers and counters
                        try
                        {
                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.RequestsExecuting);
                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.TotalRequests);
                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.RequestsPerSecond);
                            long elapsedTime = System.Diagnostics.Stopwatch.GetTimestamp();

                            NotificationProviderCoordinator coordinator = new NotificationProviderCoordinator();
                            coordinator.Initialize(); // do this with every thread?

                            coordinator.ProcessNotificationRequest(notificationRequest);

                            receiver.EndConversationWithSuccess(notificationRequest);

                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.TotalSucceeded);
                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.SucceededRequestsPerSecond);
                            elapsedTime = System.Diagnostics.Stopwatch.GetTimestamp() - elapsedTime;
                            NotificationNTServiceCounterCategory.Counters.SafeIncrementBy(NotificationNTServiceCounterCategory.AverageExecutionTime, elapsedTime);
                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.AverageExecutionTimeBase);

                            if (resetDelay)
                            {
                                delay = 0;
                                nextVal = 1;
                            }
                        }
                        catch (Exception ex)
                        {
                            // We've just blown up in an unexpected way somewhere down low in the message processors
                            // At this point, we've logged the problem and we'll drop the message and save the queue from being 
                            // poisoned by multiple rollbacks.
                            receiver.EndConversationWithError(notificationRequest);

                            Logging.WriteEvent(new ErrorProcessingNotification(), ex, "DROPPING NOTIFICATION : {0}", notificationRequest.RequestData);

                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.TotalFailures);
                            NotificationNTServiceCounterCategory.Counters.SafeIncrement(NotificationNTServiceCounterCategory.FailuresPerSecond);
                        }
                        finally
                        {
                            Interlocked.Decrement(ref messagesProcessing);

                            NotificationNTServiceCounterCategory.Counters.SafeDecrement(NotificationNTServiceCounterCategory.RequestsExecuting);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                // We should never, ever get here...but just in case...
                Logging.TraceException(ex);
            }
            finally
            {
                if (doShutdown && messagesProcessing == 0)
                {
                    shutdownEvent.Set();
                }

                if (receiver != null)
                {
                    receiver.Dispose();
                }
            }

        }


        private void DispatchProcessorThread()
        {
            if (delay > 0)
            {
                int whatsLeft = delay;

                while (whatsLeft > 0)
                {
                    int sleepVal;

                    sleepVal = whatsLeft > 15 ? 15 : whatsLeft;

                    if (doShutdown) break;

                    if (sleepVal > 0) Thread.Sleep(sleepVal * 1000);

                    whatsLeft = whatsLeft - 15;
                }
            }

            if (!doShutdown)
            {
                ThreadPool.QueueUserWorkItem(new WaitCallback(this.ProcessMessage));
            }
        }

        private void UpdateDelay()
        {
            Logging.TraceInformation("Delay increasing to {0} seconds", delay);
            if (delay < 120)
            {
                int tmp = nextVal;
                nextVal = delay + nextVal;
                delay = tmp;
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceFrontEnd.V1.Test\SubscribeTest.cs ===
using NotificationServiceFrontEnd.V1;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Microsoft.VisualStudio.TestTools.UnitTesting.Web;
using AsyncMultiplayer.NotificationService;

namespace NotificationServiceFrontEnd.V1.Test
{
    
    
    /// <summary>
    ///This is a test class for SubscribeTest and is intended
    ///to contain all SubscribeTest Unit Tests
    ///</summary>
    [TestClass()]
    public class SubscribeTest
    {


        private TestContext testContextInstance;

        /// <summary>
        ///Gets or sets the test context which provides
        ///information about and functionality for the current test run.
        ///</summary>
        public TestContext TestContext
        {
            get
            {
                return testContextInstance;
            }
            set
            {
                testContextInstance = value;
            }
        }

        #region Additional test attributes
        // 
        //You can use the following additional attributes as you write your tests:
        //
        //Use ClassInitialize to run code before running the first test in the class
        //[ClassInitialize()]
        //public static void MyClassInitialize(TestContext testContext)
        //{
        //}
        //
        //Use ClassCleanup to run code after all tests in a class have run
        //[ClassCleanup()]
        //public static void MyClassCleanup()
        //{
        //}
        //
        //Use TestInitialize to run code before running each test
        //[TestInitialize()]
        //public void MyTestInitialize()
        //{
        //}
        //
        //Use TestCleanup to run code after each test has run
        //[TestCleanup()]
        //public void MyTestCleanup()
        //{
        //}
        //
        #endregion


        /// <summary>
        ///A test for UpdatePushSubscription
        ///</summary>
        // TODO: Ensure that the UrlToTest attribute specifies a URL to an ASP.NET page (for example,
        // http://.../Default.aspx). This is necessary for the unit test to be executed on the web server,
        // whether you are testing a page, web service, or a WCF service.
        [TestMethod()]
        [HostType("ASP.NET")]
        [AspNetDevelopmentServerHost("E:\\LEST\\MAIN_DEV\\product\\Source\\Multiplayer\\AsyncMultiplayer\\NotificationService\\NotificationServiceFrontEnd", "/")]
        [UrlToTest("http://localhost:25767/")]
        public void UpdatePushSubscriptionTest()
        {
            Subscribe target = new Subscribe(); // TODO: Initialize to an appropriate value
            PushSubscription subscription = null; // TODO: Initialize to an appropriate value
            target.UpdatePushSubscription(subscription,"","");
            Assert.Inconclusive("A method that does not return a value cannot be verified.");
        }

        /// <summary>
        ///A test for DeletePushSubscription
        ///</summary>
        // TODO: Ensure that the UrlToTest attribute specifies a URL to an ASP.NET page (for example,
        // http://.../Default.aspx). This is necessary for the unit test to be executed on the web server,
        // whether you are testing a page, web service, or a WCF service.
        [TestMethod()]
        [HostType("ASP.NET")]
        [AspNetDevelopmentServerHost("E:\\LEST\\MAIN_DEV\\product\\Source\\Multiplayer\\AsyncMultiplayer\\NotificationService\\NotificationServiceFrontEnd", "/")]
        [UrlToTest("http://localhost:25767/")]
        public void DeletePushSubscriptionTest()
        {
            Subscribe target = new Subscribe(); // TODO: Initialize to an appropriate value
            target.DeletePushSubscription("", "");
            Assert.Inconclusive("A method that does not return a value cannot be verified.");
        }

        /// <summary>
        ///A test for GetPushSubscription
        ///</summary>
        // TODO: Ensure that the UrlToTest attribute specifies a URL to an ASP.NET page (for example,
        // http://.../Default.aspx). This is necessary for the unit test to be executed on the web server,
        // whether you are testing a page, web service, or a WCF service.
        [TestMethod()]
        [HostType("ASP.NET")]
        [AspNetDevelopmentServerHost("E:\\LEST\\MAIN_DEV\\product\\Source\\Multiplayer\\AsyncMultiplayer\\NotificationService\\NotificationServiceFrontEnd", "/")]
        [UrlToTest("http://localhost:25767/")]
        public void GetPushSubscriptionTest()
        {
            Subscribe target = new Subscribe(); // TODO: Initialize to an appropriate value
            PushSubscription expected = null; // TODO: Initialize to an appropriate value
            PushSubscription actual;
            actual = target.GetPushSubscription("", "");
            Assert.AreEqual(expected, actual);
            Assert.Inconclusive("Verify the correctness of this test method.");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal\MessageReceiver.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Data;
using Leet.Core.Diagnostics;
using NotificationCommon;

namespace AsyncMultiplayer.NotificationService.Internal
{
    sealed class MessageReceiver : IDisposable
    {
        private SqlConnection sqlConnection;
        private SqlCommand sqlCommand;
        private Guid conversationHandle = Guid.Empty;
        private const string EndDialogMsgType = "http://schemas.microsoft.com/SQL/ServiceBroker/EndDialog";
        private const string ErrorMsgType = "http://schemas.microsoft.com/SQL/ServiceBroker/Error";

        public MessageReceiver(string connectionString)
        {
            if (string.IsNullOrEmpty(connectionString))
            {
                throw new ArgumentException("String is null or empty", "connectionString");
            }

            sqlConnection = new SqlConnection(connectionString);
            sqlConnection.Open();
        }

        public bool TryReceiveOneMessage(out NotificationRequest notificationRequest)
        {
            const string receiveMessageSproc = "NotificationSchema.p_ReceiveNotificationToProcess";
            const int commandTimeout = 30;

            notificationRequest = null;

            sqlCommand = sqlConnection.CreateCommand();
            sqlCommand.CommandType = CommandType.StoredProcedure;
            sqlCommand.CommandText = receiveMessageSproc;

            sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
            sqlCommand.Parameters.Add("@ConversationGroup", SqlDbType.UniqueIdentifier);
            sqlCommand.Parameters.Add("@MessageBody", SqlDbType.NVarChar, -1);
            sqlCommand.Parameters.Add("@MessageTypeName", SqlDbType.NVarChar, 128);

            sqlCommand.Parameters["@ConversationHandle"].Direction = ParameterDirection.Output;
            sqlCommand.Parameters["@ConversationGroup"].Direction = ParameterDirection.Output;
            sqlCommand.Parameters["@MessageTypeName"].Direction = ParameterDirection.Output;
            sqlCommand.Parameters["@MessageBody"].Direction = ParameterDirection.Output;

            sqlCommand.CommandTimeout = commandTimeout;

            // Attempt to pull a message off the queue
            int rowsReceived = 0;
           
                sqlCommand.Transaction = sqlConnection.BeginTransaction();
                rowsReceived = sqlCommand.ExecuteNonQuery();

                if (rowsReceived > 0)
                {
                    string messageType = sqlCommand.Parameters["@MessageTypeName"].Value.ToString();
                    string messageBody = sqlCommand.Parameters["@MessageBody"].Value.ToString();
                    conversationHandle = new Guid(sqlCommand.Parameters["@ConversationHandle"].Value.ToString());

                    if (messageType == EndDialogMsgType || messageType == ErrorMsgType)
                    {
                        sqlCommand.CommandText = "NotificationSchema.p_EndConversation";
                        sqlCommand.Parameters["@ConversationHandle"].Direction = ParameterDirection.Input;

                        try
                        {
                            // End the conversation and commit the transaction
                            sqlCommand.ExecuteNonQuery();
                            sqlCommand.Transaction.Commit();
                        }
                        catch (SqlException sqlEx)
                        {
                            Logging.TraceException(sqlEx, "SQL Exception: Failed to end conversation");
                            notificationRequest = null;
                        }

                        return false;
                    }
                    else
                    {
                        try
                        {
                            notificationRequest = Notification.DeserializeFromString<NotificationRequest>(messageBody);
                        }
                        catch (InvalidOperationException ex)
                        {
                            Logging.TraceException(ex, "Deserialization Exception:  Failed to deserialize a message");
                            notificationRequest = null;
                            return false;
                        }

                        // Log the audit trace
                        NotificationAuditLog.UpdateTrackingState(NotificationAuditState.ReceivedFromQueue,
                                                                 notificationRequest);

                        // Return the notification to the caller for processing
                        return true;
                    }
                }


            // No messages received, so rollback the RECEIVE sproc
            try
            {
                sqlCommand.Transaction.Rollback();
            }
            catch (SqlException ex)
            {
                Logging.TraceException(ex, "Failed to roll back message RECEIVE action");
            }
            
            return false;
        }

        public void EndConversationWithSuccess(NotificationRequest notificationRequest)
        {
            this.EndConversation(notificationRequest, NotificationAuditState.ProcessingCompleted);
        }

        public void EndConversationWithError(NotificationRequest notificationRequest)
        {
            this.EndConversation(notificationRequest, NotificationAuditState.Error);
        }

        /// <summary>
        /// Ends a Service Broker conversation by rolling back the outermost transaction and 
        /// returning the message to the queue.  Calling this 5 times on a single message will
        /// result in the queue being disabled.
        /// </summary>
        public void RollbackConversation()
        {
            try
            {
                if (sqlCommand.Transaction != null)
                {
                    sqlCommand.Transaction.Rollback();
                }
            }
            catch (InvalidOperationException ex)
            {
                Logging.WriteEvent(new ErrorProcessingNotification(), ex, "Failed to ROLLBACK message transaction on @ch={0}.  WARNING:  Queue may become disabled!",
                    conversationHandle.ToString());
            }
        }

        public void Dispose()
        {
            if (sqlCommand != null)
            {
                sqlCommand.Dispose();
            }

            if (sqlConnection != null)
            {
                sqlConnection.Dispose();
            }

            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Ends a Service Broker conversation by commiting the transaction
        /// </summary>
        private void EndConversation(NotificationRequest notificationRequest, NotificationAuditState messageState)
        {
            if (notificationRequest == null)
            {
                throw new ArgumentNullException("notificationRequest");
            }

            string sender = "Unknown";
            string requestId = "Unknown";

            try
            {
                if (notificationRequest.SenderInfo != null)
                {
                    if (!String.IsNullOrEmpty(notificationRequest.SenderInfo.GamerTag))
                    {
                        sender = notificationRequest.SenderInfo.GamerTag;
                    }
                    else if (!String.IsNullOrEmpty(notificationRequest.SenderInfo.EmailAddress))
                    {
                        sender = notificationRequest.SenderInfo.EmailAddress;
                    }
                }

                if (!String.IsNullOrEmpty(notificationRequest.RequestId))
                {
                    requestId = notificationRequest.RequestId;
                }

                string responseXml = String.Format("<response><id>{0}</id><type>{1}</type><sender>{2}</sender><state>{3}</state></response>",
                    requestId,
                    notificationRequest.RequestDataType,
                    sender,
                    (int)messageState);

                // Calls the sproc to send the response message, end the conversation, and commit the transaction
                sqlCommand.CommandText = "NotificationSchema.p_SendNotificationResponse";

                sqlCommand.Parameters.Clear();
                sqlCommand.Parameters.Add("@ConversationHandle", SqlDbType.UniqueIdentifier);
                sqlCommand.Parameters.Add("@MessageBody", SqlDbType.NVarChar, -1);

                sqlCommand.Parameters["@ConversationHandle"].Direction = ParameterDirection.Input;
                sqlCommand.Parameters["@MessageBody"].Direction = ParameterDirection.Input;

                sqlCommand.Parameters["@ConversationHandle"].Value = conversationHandle;
                sqlCommand.Parameters["@MessageBody"].Value = responseXml;

                sqlCommand.ExecuteNonQuery();

                if (sqlCommand.Transaction != null)
                {
                    sqlCommand.Transaction.Commit();
                }
            }
            catch (SqlException sqlEx)
            {
                Logging.TraceException(sqlEx, "Failed to END CONVERSATION @ch={0}.  This conversation is still active.", conversationHandle.ToString());
            }
            catch (InvalidOperationException ex)
            {
                Logging.TraceException(ex, "Failed to END CONVERSATION @ch={0}.  This conversation is still active.", conversationHandle.ToString());
            }
            catch (Exception ex)
            {
                Logging.TraceException(ex, "Failed to END CONVERSATION @ch={0}.  This conversation is still active.", conversationHandle.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal\NotificationNTServiceCounters.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationNTServiceCounters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  The performance counters for internal notification NT service. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/21/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.Internal
{
    using System.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// This class implements "Notification NT Service" PerfCounter Category
    /// </summary>
    [PerformanceCategory(CategoryName = "Notification NT Service", CategoryType = PerformanceCounterCategoryType.SingleInstance)]
    public sealed class NotificationNTServiceCounterCategory
    {
        /// <summary>
        /// Performance counter for tracking the heartbeat of notification NT service
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "Heartbeats", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Heartbeats for the notification NT service")]
        public static int Heartbeats;

        /// <summary>
        /// Performance counter for tracking incoming request from SSB Async notification queue
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "TotalRequests", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total requests for async notifications")]
        public static int TotalRequests;

        /// <summary>
        /// Performance counter for tracking requests succeeded
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "TotalSucceeded", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total requests succeeded")]
        public static int TotalSucceeded;

        /// <summary>
        /// Performance counter for tracking requests failed to be processed
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "TotalFailures", CounterType = PerformanceCounterType.NumberOfItems64,
            CounterDescription = "Total failures for async notifications")]
        public static int TotalFailures;

        /// <summary>
        /// Performance counter for tracking requests being processed
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "RequestsExecuting", CounterType = PerformanceCounterType.NumberOfItems32,
            CounterDescription = "Number of requests being processed concurrently")]
        public static int RequestsExecuting;

        /// <summary>
        /// Performance counter for tracking incoming request rate
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "RequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Notification requests per second")]
        public static int RequestsPerSecond;

        /// <summary>
        /// Performance counter for tracking incoming request rate
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "SucceededRequestsPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Succeeded notification requests per second")]
        public static int SucceededRequestsPerSecond;

        /// <summary>
        /// Performance counter for tracking the rate of failed requests
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "FailuresPerSecond", CounterType = PerformanceCounterType.RateOfCountsPerSecond64,
            CounterDescription = "Notification failures per second")]
        public static int FailuresPerSecond;

        /// <summary>
        /// Performance counter base for tracking the average processing time for incoming requests
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "AverageExecutionTimeBase", CounterType = PerformanceCounterType.AverageBase,
            CounterDescription = "Average execution base for processing a notification")]
        public static int AverageExecutionTimeBase;

        /// <summary>
        /// Performance counter for tracking the average processing time for incoming requests
        /// </summary>
        [PerformanceCounterAttribute(CounterName = "AverageExecutionTime", CounterType = PerformanceCounterType.AverageTimer32,
            CounterDescription = "Average execution time for processing a notification", BasePropertyName = "AverageExecutionTimeBase")]
        public static int AverageExecutionTime;

        /// <summary>
        /// Internal container for counters in the category.
        /// </summary>
        private static PerformanceCounterCollection counters;

        /// <summary>
        /// Internal synchronization object for counter initialization.
        /// </summary>
        private static object lockObject = new object();

        /// <summary>
        /// Prevents a default instance of the NotificationNTServiceCounterCategory class from being created.
        /// </summary>
        private NotificationNTServiceCounterCategory()
        {
        }

        /// <summary>
        /// Gets the the perf counters in the category.
        /// </summary>
        public static PerformanceCounterCollection Counters
        {
            get
            {
                if (counters == null)
                {
                    lock (lockObject)
                    {
                        if (counters == null)
                        {
                            counters = PerformanceCounters.GetPerformanceCounters(typeof(NotificationNTServiceCounterCategory));
                        }
                    }
                }

                return counters;
            }
        }

        /// <summary>
        /// Gets the name of the perf counter category.
        /// </summary>
        public static string Name
        {
            get
            {
                return "Notification NT Service";
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal\ServiceConfigs.cs ===
//-------------------------------------------------------------------
// <copyright file="ServiceConfigs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Notification Service Internal Related Configurations. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/23/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.Internal
{
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Data;
    using Leet.Core.Configuration;
    using Leet.Core.IO;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Profile;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// Service configuration class. 
    /// </summary>
    public class ServiceConfigs
    {
        /// <summary>
        /// Gets the max thread count of the service. 
        /// </summary>
        public int MaxThreadCount
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationInternal_MaxThreadCount);
            }
        }

        /// <summary>
        /// Gets the throttle time for SQL fatal error events. 
        /// </summary>
        public int SqlErrorEventsThrottleTimeInMinutes
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationInternal_SqlErrorEventsThrottleTimeInMinutes);
            }
        }

        /// <summary>
        /// Gets the application display name for the service. This is not necessary the same as Component
        /// name. 
        /// </summary>
        public string AppName
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetSetting(Settings.NotificationInternal_AppName);
            }
        }

        /// <summary>
        /// Gets the connection string to notification request queue. 
        /// </summary>
        public string NotificationRequestQueueConnectionString
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                string connstring = configSettings.GetConnectionString(ConfigurationManager.AppSettings["DatabaseInterface"]);

                // HACK: before we figureout why it doesn't work except for under IIS. 
                return connstring.Replace("Connect Timeout=0;", "Connect Timeout=120;");
            }
        }

        /// <summary>
        /// Initialize the settings. 
        /// </summary>
        public void Initialize()
        {
            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>();
            Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();

            string serviceConfigName = ConfigurationManager.AppSettings["ServiceConfigName"];
            ConfigurationSelector.RegisterProvider(serviceConfigName, "LEET");
            ((NpdbConfigurationProvider)Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", serviceConfigName);
            // all the providers will have to register its own depending interfaces. 

            Leet.Core.IoCCo.Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Leet.Core.IoCCo.Container.Instance.AddService<ILogging, Logging>();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\NotificationServiceInternal\NotificationServiceInternal.cs ===
//-------------------------------------------------------------------
// <copyright file="NotificationServiceInternal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The main thread of the internal Notification Service
//  This file contains the methods and properties that are not related to System.ServiceProcess.ServiceBase
//  If you want to debug any issues, it is easier to use NotificationServiceInternal.cs NotificationTest.cs and
//  remove NotificationService.cs NotificationServiceInstall.cs from the project. This way you can launch the exe
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/29/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.NotificationService.Internal
{
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Data.SqlClient;
    using System.ServiceModel;
    using System.ServiceProcess;
    using System.Threading;
    using System.Timers;
    using AsyncMultiplayer.NotificationService;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// The main Notification service.
    /// </summary>
    public partial class NotificationService
    {
        private int delay = 0;
        private int nextVal = 0;
        private bool doShutdown = false;
        private int messagesProcessing = 0;
        private ManualResetEvent shutdownEvent;
        private static string connectionString;

        /// <summary>
        /// The error level we treated as fatal. 
        /// </summary>
        public const int SqlFatalErrorLevel = 11;

        /// <summary>
        /// Componenet name of NotificationService.
        /// </summary>
        public const string ComponentName = "NotificationService";

        /// <summary>
        /// Last fatal SQl exception happened for error event throttling.
        /// </summary>
        private static SqlException lastFatalSqlException;

        /// <summary>
        /// The time last fatal SQl exception happened for error event throttling.
        /// </summary>
        private static DateTime lastFatalSqlExceptionTime;

        /// <summary>
        /// A lock object for synchronization of event throttling.
        /// </summary>
        private static object lockObject = new object();


        /// <summary>
        /// Gets or sets service configuration instance. 
        /// </summary>
        public static ServiceConfigs ConfigInstance { get; set; }


        /// <summary>
        /// Main application entry point
        /// </summary>
        /// <param name="args">Input arguments.  Currently -debug is the only one used.</param>
        internal void Run(string[] args)
        {
            OnStart(args);

            // Put the main thread to sleep while the workers process msgs
            while (true)
            {
                Thread.Sleep(1000);
            }
        }

        public NotificationService()
        {
            // Used to 
            shutdownEvent = new ManualResetEvent(false);

            CanStop = true;
            CanShutdown = true;
            doShutdown = false;
            messagesProcessing = 0;

            // Used to manage worker thread idle time
            delay = 0;
            nextVal = 1;
        }

        /// <summary>
        /// A common utility Exception handler for SQL exceptions. 
        /// </summary>
        /// <param name="displayName">The component display name. </param>
        /// <param name="sqlex">The sql exception. </param>
        public static void HandleSqlException(string displayName, SqlException sqlex)
        {
            // SQL exceptions are handled outside the inner most loop. If there are exceptions, we either have to stop the service
            // or put this thread to sleep
            Logging.TraceError("{0} {1}",
                       displayName,
                       string.Format("SqlException happened. Details: Class {0}, Number {1}, message:{2}", sqlex.Class, sqlex.Number, sqlex.ToString()));

            if (sqlex.Message.Contains("Timeout"))
            {
                Logging.TraceError("{0} {1}",
                       displayName,
                       "Ignored the timeout Sqlexception.");
            }
            else if (sqlex.Class >= NotificationService.SqlFatalErrorLevel)
            {
                // check if we have run into this error already.
                if ((NotificationService.lastFatalSqlException == null) ||
                    (NotificationService.lastFatalSqlException.Number != sqlex.Number))
                {
                    lock (NotificationService.lockObject)
                    {
                        NotificationService.lastFatalSqlException = sqlex;
                        NotificationService.lastFatalSqlExceptionTime = DateTime.UtcNow;
                    }

                    // log a system event for the new exception, to be monitored by a MOM pack
                    NotificationEvents.Events.TraceEvent(
                        NotificationEvents.SqlException, 
                        "\nThis is the first occurrence at: " + NotificationService.lastFatalSqlExceptionTime.ToString(),
                        sqlex.ToString());
                }
                else
                {
                    int throttleTimeInMinutes = 60; // default to every 60 minutes
                    try
                    {
                        throttleTimeInMinutes = ConfigInstance.SqlErrorEventsThrottleTimeInMinutes;
                    }
                    // catch all exceptions since we are in a SQL exception handler already.
                    catch (Exception ex)
                    {
                        // log an error message
                        Logging.TraceException(ex, "{0} {1}",
                            ComponentName,
                            "Exception caught while getting NPDB settings: NotificationInternal_SqlErrorEventsThrottleTimeInMinutes");
                    }

                    if (DateTime.UtcNow > NotificationService.lastFatalSqlExceptionTime.AddMinutes(throttleTimeInMinutes))
                    {
                        lock (NotificationService.lockObject)
                        {
                            NotificationService.lastFatalSqlExceptionTime = DateTime.UtcNow;
                        }

                        // log a duplicate system event after the throttle time, to be monitored by a MOM pack
                        NotificationEvents.Events.TraceEvent(
                            NotificationEvents.SqlException,
                            "\nThis is the Nth occurrence at: "  + NotificationService.lastFatalSqlExceptionTime.ToString(),
                            sqlex.ToString());
                    }
                    else
                    {
                        Logging.TraceError("{0} {1} {2}", displayName, "SqlException happened again and ignored:\n", sqlex.ToString());
                    }
                }
            }
            else
            {
                // the sqlexception is very like just random failure. Put this thread to sleep
                // and hopefully the exception will go away.
                Logging.TraceError("{0} {1} {2}",
                       displayName,
                       "Sqlexception ignored:\n ",
                       sqlex.ToString());
            }
        }

        /// <summary>
        /// This eventlogs the exception.
        /// to the client.
        /// </summary>
        /// <param name="methodName">Name of the web method from which
        /// exception is thrown.
        /// </param>
        /// <param name="ex">Exception object.</param>
        private static void HandleException(string methodName, Exception ex)
        {
            NotificationEvents.Events.TraceEvent(
                NotificationEvents.UnexpectedFailure,
                "\r\nUnexpceted exception happened in: " + methodName + ".\r\n",
                ex.ToString());

            throw ex; // throw the exception if anything gone awry during service start/stop.
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService\IPartnerService.cs ===
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.Serialization;
using System.ServiceModel;
using System.ServiceModel.Activation;
using System.ServiceModel.Web;
using AsyncMultiplayer.PartnerService.DataContracts;
using Microsoft.ServiceModel.Web;
using Microsoft.ServiceModel.Web.SpecializedServices;


namespace AsyncMultiplayer.PartnerService
{
    /// <summary>
    /// Interface exposed by Partner service front end.
    /// </summary>
    [ServiceContract]
    interface IPartnerService
    {
        /// <summary>
        /// Send a notification to a list of recipients.
        /// </summary>
        [WebHelp(Comment = "Send a notification to a list of recipients.")]
        [WebInvoke(Method = "POST", UriTemplate = "notification")]
        [OperationContract]
        void SendNotification(PartnerNotificationRequest sendRequest);

        /// <summary>
        /// This method deletes all notifications of the given session.
        /// </summary>
        /// <param name="gameIdString">Game id of the request in string format. </param>
        /// <param name="sessionId">Session Id.</param>
        /// <param name="gamertags">A list of gamertags delimited by ";".</param>
        [WebHelp(Comment = "Delete notifications of the given session.")]
        [WebInvoke(Method = "POST", UriTemplate = "deletenotifications")]
        [OperationContract]
        void DeleteNotificationBySession(PartnerDeleteRequest deleteRequest);

        /// <summary>
        /// Post game results to rewards service.
        /// </summary>
        /// <param name="gameResults">List of GameResult. </param>
        [WebHelp(Comment = "Post game results to rewards service.")]
        [WebInvoke(Method = "POST", UriTemplate = "gameresults")]
        [OperationContract]
        void PostGameResults(List<PartnerCompositeGameResult> gameResults);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService\Global.asax.cs ===
//-------------------------------------------------------------------
// <copyright file="Global.asax.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Partner Service Global application
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="04/14/2010">
//     Class created
// </history>
//-------------------------------------------------------------------
using System;
using System.Collections;
using System.Configuration;
using System.Data;
using System.IO;
using System.Web;
using System.Web.Security;
using System.Web.SessionState;
using System.Xml;
using System.Xml.XPath;
using AsyncMultiplayer.NotificationService;
using GameMetadata.Client;
using GameMetadata.Common;
using Gds.DataAccess.Rewards;
using Leet.Core.Caching;
using Leet.Core.Configuration;
using Leet.Core.Diagnostics;
using Leet.Core.IO;
using Leet.Core.IoCCo;
using Leet.Core.Utils;
using Leet.Live.Livecache;
using Leet.Live.Livecache.Providers;
using Leet.Utils;
using Leet.Identity;
using LIVEN.Common.Diagnostics;


namespace AsyncMultiplayer.PartnerService
{
    

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class Global : System.Web.HttpApplication
    {
        /// <summary>
        /// Component Name.
        /// </summary>
        private const string ComponentName = "PartnerServiceGlobal";

        /// <summary>
        /// The name used in the NPDB configuration. 
        /// </summary>
        private const string ServiceConfigName = "partner_service";

        /// <summary>
        /// The interface of the database. 
        /// </summary>
        private const string DatabaseInterface = "lest_AsyncNotification_db";

        /// <summary>
        /// The Serivce name space. 
        /// </summary>
        private string serviceNamespace = typeof(PartnerService).Namespace;

        /// <summary>
        /// Gets the maximum allowed invites request per hour. 
        /// </summary>
        public static int InviteQuotaPerHour
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationFE_InviteQuotaPerHour);
            }
        }

        /// <summary>
        /// Gets the maximum characters the data blob can carry in a InviteRequest. 
        /// </summary>
        public static int DataBlobMaxCchLength
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetIntSetting(Settings.NotificationFE_DataBlobMaxCchLength);
            }
        }

        /// <summary>
        /// Gets or sets the static instance of SendRequestUtils. 
        /// </summary>
        public static INotificationRequest SendRequestUtil { get; set; }

        /// <summary>
        /// Gets the connection string to send notification requests. 
        /// </summary>
        private static string RequestQueueConnectionString
        {
            get
            {
                IConfigurationProvider configSettings = Container.Instance.GetComponent<IConfigurationProvider>();
                return configSettings.GetConnectionString(DatabaseInterface);
            }
        }

        /// <summary>
        /// Application OnStart event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_Start(object sender, EventArgs e)
        {

            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            NotificationEvents.Initialize("notification_front_end");

            // register the configuration providers
            Container.Instance.AddService<IRegistryProvider, RegistryProvider>();
            Container.Instance.AddService<IFileSystem, FileSystem>(); 

            ConfigurationSelector.RegisterProvider(ServiceConfigName, "LEET");


            // Register locale helper
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            // Register Cache Provider
            Container.Instance.AddService<ICacheProvider, AspNetCacheAdapter>();

            // Register game client for validating game results
            GameMetadataClient.RegisterContainerServices();

            // Register Rewards for posting game results.
            CSubmitGameResult.RegisterInterfaces(Container.Instance);

            // Register LiveCache Client.
            Container.Instance.AddEmulatableService<IWebRequestClientIdentifierProvider, LiveNWebRequestClientIdentifierProvider>();
            LeetLivecacheClient.RegisterWebInterfacesAndInitialize(ServiceConfigName);

            SendRequestUtil = new NotificationRequestUtils(RequestQueueConnectionString);

            Logging.TraceInformation("{0}: {1}",
                ComponentName,
                "Service Application Started.");

            Logging.TraceInformation("{0}: {1} {2}",
                ComponentName,
                "Connection string to Send Notification request is ",
                RequestQueueConnectionString);
        }

        /// <summary>
        /// Application OnEnd event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_End(object sender, EventArgs e)
        {
        }

        /// <summary>
        /// Application BeginRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_BeginRequest(object sender, EventArgs e)
        {
            // TODO: add performance counter start 
        }

        /// <summary>
        /// Application EndRequest event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_EndRequest(object sender, EventArgs e)
        {
            HttpContext.Current.Response.Headers["Cache-Control"] = "no-cache";
            HttpContext.Current.Response.Headers["Pragma"] = "no-cache";
        }

        /// <summary>
        /// Application error handler. 
        /// </summary>
        /// <param name="sender">Sender object. </param>
        /// <param name="e">The event arguments. </param>
        protected void Application_Error(object sender, EventArgs e)
        {
            Exception ex = Server.GetLastError().GetBaseException();
            Logging.TraceException(ex,
                ComponentName);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService\PartnerServiceHostFactory.cs ===
//-------------------------------------------------------------------
// <copyright file="PartnerServiceHostFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Partner service host factory for multiple HTTP binding support.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/15/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.PartnerService
{
    using System;
    using Leet.Utils;

    /// <summary>
    /// Partner service host factory for multiple HTTP binding support.
    /// </summary>
    internal class AppServiceHostFactory : MultipleHTTPBindingsServiceHostFactory<IPartnerService>
    {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PartnerService")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6c4344f6-01a0-4ab2-852d-c7feb084bf9e")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService\PartnerNotificationFactory.cs ===
//-------------------------------------------------------------------
// <copyright file="PartnerNotificationFactory.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PartnerNotificationFactory class for creating notifications for partner requests
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="04/20/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.PartnerService
{
    using System;
    using System.Net;
    using AsyncMultiplayer.NotificationService;
    using AsyncMultiplayer.PartnerService.DataContracts;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// Public class factory to create notifications for partner requests.
    /// </summary>
    public class PartnerNotificationFactory
    {
        /// <summary>
        /// Creates notifications based on partner requests.
        /// </summary>
        /// <param name="type">The type of the notification.</param>
        /// <param name="request">The Partner request.</param>
        /// <returns>The notification asked to create.</returns>
        public static Notification CreateNotification(Notification.NotificationType type, PartnerNotificationRequest request)
        {
            Notification notification = null;

            switch (type)
            {
                case Notification.NotificationType.Invitation:
                    notification = CreateInvitationNotification(request);
                    break;
                case Notification.NotificationType.GameOver:
                    notification = new GameOverNotification();
                    break;
                case Notification.NotificationType.GameTie:
                    notification = new GameTieNotification();
                    break;
                case Notification.NotificationType.YouWin:
                    notification = new YouWinNotification();
                    break;
                case Notification.NotificationType.YouLose:
                    notification = new YouLoseNotification();
                    break;
                case Notification.NotificationType.YourTurn:
                    notification = new YourTurnNotification();
                    break;
                case Notification.NotificationType.Nudge:
                    notification = new NudgeNotification();
                    break;
                case Notification.NotificationType.Message:
                    notification = new MessageNotification();
                    break;
                default:
                    break;
            }

            notification.GameId = request.GameId;
            notification.SessionId = request.SessionId;

            // fill in the sender information if not already
            if (String.IsNullOrEmpty(notification.From))
            {
                notification.From = PartnerService.GamertagToXuid(request.From).ToString();
            }

            // add additional properties from the property bag
            AddOptionalProperties(request, notification);

            return notification;
        }

        /// <summary>
        /// Adds optional notification properties passed in by partner requests.
        /// </summary>
        /// <param name="request">The request with additional notification properties.</param>
        /// <param name="notification">The notification.</param>
        private static void AddOptionalProperties(PartnerNotificationRequest request, Notification notification)
        {
            if (request.NotificationProperties != null)
            {
                PartnerNotificationRequest.PropertyDictionary propertyBag = request.NotificationProperties;

                // Check if data blob present
                if (propertyBag.ContainsKey(NotificationProperty.DataBlob))
                {
                    string dataBlob = propertyBag[NotificationProperty.DataBlob];
                    if (!String.IsNullOrEmpty(dataBlob) && dataBlob.Length > Global.DataBlobMaxCchLength)
                    {
                        PartnerService.ParameterValidator.RejectInput("DataBlob is too big for a notification.");
                    }

                    notification.DataBlob = dataBlob;
                }

                // Check if expiration present
                if (propertyBag.ContainsKey(NotificationProperty.ExpirationTime))
                {
                    DateTime expirationTime = DateTime.MaxValue;

                    if (DateTime.TryParse(propertyBag[NotificationProperty.ExpirationTime], out expirationTime))
                    {
                        notification.ExpirationTime = expirationTime;
                    }
                    else
                    {
                        PartnerService.ParameterValidator.RejectInput("ExpirationTime is not valid.");
                    }
                }

                // Check if Variant present
                if (propertyBag.ContainsKey(NotificationProperty.Variant))
                {
                    uint variant = 0;
                    if (uint.TryParse(propertyBag[NotificationProperty.Variant], out variant))
                    {
                        notification.Variant = variant;
                    }
                    else
                    {
                        PartnerService.ParameterValidator.RejectInput("Game Variant is not valid.");
                    }
                }
            }
        }

        /// <summary>
        /// Creates InvitationNotification based on partner requests.
        /// </summary>
        /// <param name="request">The Partner request.</param>
        /// <returns>an InvitationNotification.</returns>
        private static Notification CreateInvitationNotification(PartnerNotificationRequest request)
        {
            UserInfo senderInfo = new UserInfo(0);
            senderInfo.DisplayName = string.Empty;
            senderInfo.GamerTag = request.From;

            InvitationNotification invite = new InvitationNotification();
            invite.From = Notification.SerializeToString(senderInfo);
            invite.GameId = request.GameId;
            invite.SessionId = request.SessionId;

            if (request.NotificationProperties != null)
            {
                if (request.NotificationProperties.ContainsKey(NotificationProperty.FriendRequest))
                {
                    if (String.CompareOrdinal(request.NotificationProperties[NotificationProperty.FriendRequest], "true") == 0)
                    {
                        invite.FriendRequest = true;
                    }
                }
            }

            return invite;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService\PartnerService.svc.cs ===
//-------------------------------------------------------------------
// <copyright file="PartnerService.svc.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Partner service.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="04/14/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.PartnerService
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Globalization;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using System.Text;
    using System.Web;
    using System.Xml.Linq;
    using AsyncMultiplayer.NotificationService;
    using AsyncMultiplayer.PartnerService.DataContracts;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Leet.Core;
    using Leet.Core.Caching;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Core.Utils;
    using Leet.Live.Livecache.DataAccess;
    using Leet.Utils;
    using Leet.Core.Diagnostics;
    using LIVEN.Common.Diagnostics;
    using Microsoft.ServiceModel.Web;
    using Microsoft.ServiceModel.Web.SpecializedServices;

    /// <summary>
    /// Partner service class which handles all requests from partners.
    /// </summary>
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class PartnerService : IPartnerService
    {
        /// <summary>
        /// Component Name.
        /// </summary>
        private const string ComponentName = "PartnerService";

        /// <summary>
        /// The default locale if X-locale is not present. 
        /// </summary>
        private const string DefaultLocale = "en-US";

        /// <summary>
        /// The sender XUID of system notifications. 
        /// </summary>
        private const string SystemSenderXuid = "0";

        /// <summary>
        /// The delimiter characters. 
        /// </summary>
        private static readonly string[] userDelimitor = new string[] { ";" };

        /// <summary>
        /// Initializes a new instance of the PartnerService class.
        /// </summary>
        public PartnerService()
        {
        }

        /// <summary>
        /// Send a notification to a list of recipients.
        /// </summary>
        /// <param name="sendRequest">Partner request carries the notification to send. </param>
        public void SendNotification(PartnerNotificationRequest sendRequest)
        {
            try
            {
                Notification.NotificationType type = 0;

                // Validate client input.
                if (string.IsNullOrEmpty(sendRequest.SessionId))
                {
                    ParameterValidator.RejectInput("sessionId is null or empty.");
                }

                if (string.IsNullOrEmpty(sendRequest.Recipients))
                {
                    ParameterValidator.RejectInput("receipients list is null or empty.");
                }

                if (string.IsNullOrEmpty(sendRequest.NotificationType))
                {
                    ParameterValidator.RejectInput("NotificationType is null or empty.");
                }
                else
                {
                    type = ParameterValidator.ValidateEnumType<Notification.NotificationType>(sendRequest.NotificationType);
                }

                Notification notification = PartnerNotificationFactory.CreateNotification(type, sendRequest);

                // create a request and submit to internal Notification Queues
                NotificationRequest request = new NotificationRequest();
                request.From = notification.From;
                if (type == Notification.NotificationType.Invitation)
                {
                    request.To = PrefixGamertagIdentifier(sendRequest.Recipients);
                }
                else
                {
                    request.To = GamertagsToXuids(sendRequest.Recipients);
                }

                request.Action = NotificationRequest.ActionType.Create;
                request.Command = request.Action.ToString();
                request.GameId = sendRequest.GameId;
                request.SessionId = sendRequest.SessionId;
                request.RequestDataType = (int)notification.Type;
                request.RequestData = Notification.SerializeToString(notification);
                request.RequestLocale = WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XLocale];
                if (string.IsNullOrEmpty(request.RequestLocale))
                {
                    request.RequestLocale = DefaultLocale;
                }

                Global.SendRequestUtil.SendNotificationRequest(request);
            }
            catch (Exception ex)
            {
                HandleException("SendNotifications", ex);
            }
        }

        /// <summary>
        /// This method deletes all notifications of the given session.
        /// </summary>
        /// <param name="deleteRequest">Partner request specifies the notifications to delete. </param>
        public void DeleteNotificationBySession(PartnerDeleteRequest deleteRequest)
        {
            try
            {
                // Validate client input.
                if (string.IsNullOrEmpty(deleteRequest.SessionId))
                {
                    ParameterValidator.RejectInput("SessionId is null or empty.");
                }

                if (string.IsNullOrEmpty(deleteRequest.Players))
                {
                    ParameterValidator.RejectInput("player gamertags string is null or empty.");
                }

                NotificationQueryParameter query = new NotificationQueryParameter();
                query.SessionId = ParameterValidator.ValidateSessionId(deleteRequest.SessionId);
                query.GameId = deleteRequest.GameId;

                // convert gamertags string to Xuids string (still separated by ";"
                string playerXuids = GamertagsToXuids(deleteRequest.Players);

                // create a delete requests
                NotificationRequest request = new NotificationRequest();
                request.From = SystemSenderXuid;
                request.Action = NotificationRequest.ActionType.Delete;
                request.Command = request.Action.ToString();
                request.To = playerXuids;
                request.GameId = query.GameId ?? 0;
                request.SessionId = query.SessionId;
                request.RequestDataType = 0; // Request Data is always NotificationQueryParameter
                request.RequestData = Notification.SerializeToString(query);
                request.RequestLocale = WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XLocale];
                if (string.IsNullOrEmpty(request.RequestLocale))
                {
                    request.RequestLocale = DefaultLocale;
                }

                Global.SendRequestUtil.SendNotificationRequest(request);
            }
            catch (Exception ex)
            {
                HandleException("DeleteNotificationBySession", ex);
            }
        }

        /// <summary>
        /// Post game results to rewards service.
        /// </summary>
        /// <param name="gameResults">List of PartnerCompositeGameResult. </param>
        public void PostGameResults(List<PartnerCompositeGameResult> gameResults)
        {
            try
            {
                Logging.TraceVerbose("{0}: {1}",
                    ComponentName,
                    "Verifying client accees to PostGameResult...");

                // TODO: Validate the client is authorized to access this API
                //// TODO: Integrate with XBL

                // Sanity check on client input
                if ((gameResults == null) || (gameResults.Count == 0))
                {
                    ParameterValidator.RejectInput("gameResults is null or empty.");
                }

                // Submit posted results to Rewards.
                ISubmitGameResult submitGameResult = Container.Instance.GetComponent<ISubmitGameResult>();

                var compositeGameResults = gameResults.Select(r => new CompositeGameResult
                                                        {
                                                            GameResult = r.GameResult,
                                                            Locale = r.Locale,
                                                            PlatformType = r.PlatformType,
                                                            Xuid = GamertagToXuid(r.Gamertag)
                                                        }).ToList();

                try
                {
                    Logging.TraceVerbose("{0}: {1}",
                        ComponentName,
                        "Submitting CompositeGameResults to Rewards Queue.");

                    submitGameResult.SubmitBatch(compositeGameResults, GameResultSubmissionEnum.MultiplayerServiceSubmission);
                }
                catch (RewardsDataAccessValidationException ex)
                {
                    // convert RewardsDataAccessValidationException to LIVEnException
                    Logging.TraceVerbose("{0}: {1} {2}",
                        ComponentName,
                        "Failed to submit CompositeGameResults to Rewards Queue.\r\n",
                        ex.ToString());

                    ParameterValidator.RejectInput("The submitted composite game results failed validation.");
                }
            }
            catch (Exception ex)
            {
                HandleException("PostGameResults", ex);
            }
        }

        /// <summary>
        /// This method queries livecache to get the XUID of the specified gamertag.
        /// </summary>
        /// <param name="gamertag">Gamertag to look up for XUID.</param>
        /// <returns>The XUID of the specified gamertag.</returns>
        internal static ulong GamertagToXuid(string gamertag)
        {
            // if we don't have a cached Xuid for this gamertag, call XCache to get it and cache
            ICacheProvider cache = Container.Instance.GetComponent<ICacheProvider>();
            ulong? cachedXuid = (ulong?)cache.GetObject(gamertag);
            if (cachedXuid == null)
            {
                var xcache = Container.Instance.GetComponent<IXCacheDataAccess>();
                ulong xuid = 0;
                if (xcache.GetPuidByGamerTag(gamertag, out xuid) == false)
                {
                    ParameterValidator.RejectInput("Gamertag, " + HttpUtility.HtmlEncode(gamertag) + ", is invalid.");
                }

                cachedXuid = xuid;
                cache.Insert(gamertag, xuid, System.Web.Caching.Cache.NoAbsoluteExpiration);
            }

            return cachedXuid.Value;
        }

        /// <summary>
        /// This method converts a string of gamertags to XUIDs.
        /// </summary>
        /// <param name="gamertags">Gamertags separated by ";".</param>
        /// <returns>The XUIDs of the gamertags separated by ";".</returns>
        internal static string GamertagsToXuids(string gamertags)
        {
            // convert gamertags string to Xuids string (still separated by ";")
            string playerXuids = string.Empty;
            try
            {
                playerXuids = gamertags.Split(UserInfo.UserDelimitor, StringSplitOptions.RemoveEmptyEntries).
                                  Select(t => GamertagToXuid(t).ToString()).
                                  Aggregate((xuids, next) => xuids + UserInfo.UserDelimitor[0] + next);
            }
            catch (System.ArgumentNullException)
            {
                ParameterValidator.RejectInput("String gamertags does not contain valid gamertags.");
            }

            return playerXuids;
        }

        /// <summary>
        /// This method adds a Gamertag prefix to each and every recipients.
        /// </summary>
        /// <param name="gamertags">A list of gamertags separated by ";".</param>
        /// <returns>A new list of recipients prefixed with gamertag.</returns>
        private static string PrefixGamertagIdentifier(string gamertags)
        {
            string[] gamertagList = gamertags.Split(UserInfo.UserDelimitor, StringSplitOptions.RemoveEmptyEntries);

            StringBuilder sb = new StringBuilder();
            foreach (string gamertag in gamertagList)
            {
                sb.Append(UserInfo.GamertagPrefix + gamertag.Trim() + userDelimitor[0]);
            }

            return sb.ToString();
        }

        /// <summary>
        /// This eventlogs the exception and throws the WebProtocol exception
        /// to the client.
        /// </summary>
        /// <param name="methodName">
        /// name of the web method from which exception is thrown.
        /// </param>
        /// <param name="ex">exception object.</param>
        private static void HandleException(string methodName, Exception ex)
        {
            Logging.TraceException(ex,
                ComponentName,
                "Exception caught in method: ",
                methodName);

            LIVEnException le = ex as LIVEnException;
            if (le == null)
            {
                le = new LIVEnException(
                    NotificationEvents.Events,
                    NotificationEvents.UnexpectedFailure,
                    HttpStatusCode.InternalServerError,
                    ex,
                    methodName,
                    true,
                    ex.ToString());
            }

            le.ThrowWebProtocolException();
        }

        /// <summary>
        /// Helper class for input parameter validation.
        /// </summary>
        public class ParameterValidator
        {
            /// <summary>
            /// The maximum length of a game session identifier. 
            /// </summary>
            private const int MaxSessionIdLength = 64;

            /// <summary>
            /// Validate the length of a session identifier. 
            /// </summary>
            /// <param name="sessionId">The provided session Id</param>
            /// <returns>The session id if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static string ValidateSessionId(string sessionId)
            {
                if (sessionId.Length >= MaxSessionIdLength)
                {
                    RejectInput("Session ID is invalid");
                }

                return sessionId;
            }

            /// <summary>
            /// Validate game identifier. 
            /// </summary>
            /// <param name="gameIdString">The provided game Id string.</param>
            /// <returns>The game id if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static uint ValidateGameId(string gameIdString)
            {
                uint gameId = 0;
                if (uint.TryParse(gameIdString, out gameId) == false)
                {
                    RejectInput("Game ID is invalid");
                }

                return gameId;
            }

            /// <summary>
            /// Validate input value against some enumeration type. 
            /// </summary>
            /// <typeparam name="T">An enum type.</typeparam>
            /// <param name="valueString">The provided enum value string.</param>
            /// <returns>The matching enum value if valid.</returns>
            /// <exception>LIVEnException if invalid.</exception>
            public static T ValidateEnumType<T>(string valueString)
            {
                T value = default(T);

                try
                {
                    value = (T)Enum.Parse(typeof(T), valueString, true);
                    if (Enum.IsDefined(typeof(T), value) == false)
                    {
                        throw new System.ArgumentException();
                    }
                }
                catch
                {
                    RejectInput(valueString + " is not a valid value for enum type: " + typeof(T).Name);
                }

                return value;
            }

            /// <summary>
            /// A helper method to throw bad request exception. 
            /// </summary>
            /// <param name="msg">The reason of the reject. </param>
            public static void RejectInput(string msg)
            {
                throw new LIVEnException(
                        NotificationEvents.Events,
                        NotificationEvents.InvalidArgument,
                        HttpStatusCode.BadRequest,
                        null,
                        false,
                        msg);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService.DataContracts\PartnerDeleteRequest.cs ===
//-------------------------------------------------------------------
// <copyright file="PartnerDeleteRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PartnerDeleteRequest class for deleting notifications by session
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="05/17/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.PartnerService.DataContracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// Class to carry input data for deleting notifications by session.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [Serializable]
    [DataContract(Name = "PartnerDeleteRequest")]
    public class PartnerDeleteRequest
    {
        /// <summary>
        /// Initializes a new instance of the PartnerDeleteRequest class. 
        /// </summary>
        public PartnerDeleteRequest()
        {
        }

        /// <summary>
        /// Gets or sets the game id of the notifications. 
        /// </summary>
        [DataMember(Name = "GameId", Order = 1, IsRequired = true)]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the session id of the notifications. 
        /// </summary>
        [DataMember(Name = "SessionId", Order = 2, IsRequired = true)]
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets the recipients, a list of gamertags dilimited by ";"
        /// </summary>
        [DataMember(Name = "Players", Order = 3, IsRequired = true)]
        public string Players { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService.DataContracts\PartnerCompositeGameResult.cs ===
//-------------------------------------------------------------------
// <copyright file="PartnerCompositeGameResult.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PartnerCompositeGameResult class for posting game results.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="04/14/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.PartnerService.DataContracts
{
    using System;
    using System.Runtime.Serialization;
    using Gds.Contracts;

    /// <summary>
    /// Class to carry input data for sending out notifications.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [Serializable]
    [DataContract(Name = "PartnerCompositeGameResult")]
    public class PartnerCompositeGameResult
    {
        /// <summary>
        /// Initializes a new instance of the PartnerCompositeGameResult class. 
        /// </summary>
        public PartnerCompositeGameResult()
        {
        }

        /// <summary>
        /// Gets or sets the gamertag of the game. 
        /// </summary>
        [DataMember(Name = "Gamertag", Order = 1, IsRequired = true)]
        public string Gamertag { get; set; }

        /// <summary>
        /// Gets or sets the game result. 
        /// </summary>
        [DataMember(Name = "GameResult", Order = 2, IsRequired = true)]
        public GameResult GameResult { get; set; }

        /// <summary>
        /// Gets or sets the gamer's locale. 
        /// </summary>
        [DataMember(Name = "Locale", Order = 3, IsRequired = true)]
        public string Locale { get; set; }

        /// <summary>
        /// Gets or sets the gamer's platform. 
        /// </summary>
        [DataMember(Name = "PlatformType", Order = 4, IsRequired = true)]
        public string PlatformType { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService.DataContracts\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PartnerService.DataContracts")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("032a2cd9-dd9a-4411-8f1c-1b622b75ad90")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService.DataContracts\PartnerNotificationRequest.cs ===
//-------------------------------------------------------------------
// <copyright file="PartnerNotificationRequest.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  PartnerNotificationRequest class for sending notifications
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="04/14/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.PartnerService.DataContracts
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.Serialization;

    /// <summary>
    /// The names of various notification properties: MUST be serialized to literal strings, not integer values.
    /// </summary>
    public enum NotificationProperty
    {
        /// <summary>
        /// uint: specifies the variant of the game.
        /// </summary>
        Variant,

        /// <summary>
        /// DateTime: specifies when the notification expires.
        /// </summary>
        ExpirationTime,

        /// <summary>
        /// string: contained in a notification carrying any data up-to-a maximum length (1000 chars)
        /// </summary>
        DataBlob,

        /// <summary>
        /// bool: contained in a Invite notification indicating whether to send a friendrequest to recipients or not.
        /// </summary>
        FriendRequest,
    }

    /// <summary>
    /// Class to carry input data for sending out notifications.
    /// </summary>
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.Xml.Serialization.XmlTypeAttribute(AnonymousType = true)]
    [Serializable]
    [DataContract(Name = "PartnerNotificationRequest")]
    public class PartnerNotificationRequest
    {
        /// <summary>
        /// Initializes a new instance of the PartnerNotificationRequest class. 
        /// </summary>
        public PartnerNotificationRequest()
        {
        }

        /// <summary>
        /// Gets or sets the game id of the notifications. 
        /// </summary>
        [DataMember(Name = "GameId", Order = 1, IsRequired = true)]
        public uint GameId { get; set; }

        /// <summary>
        /// Gets or sets the session id of the notifications. 
        /// </summary>
        [DataMember(Name = "SessionId", Order = 2, IsRequired = true)]
        public string SessionId { get; set; }

        /// <summary>
        /// Gets or sets the sender gamertag
        /// </summary>
        [DataMember(Name = "From", Order = 3, IsRequired = true)]
        public string From { get; set; }

        /// <summary>
        /// Gets or sets the recipients, a list of gamertags dilimited by ";"
        /// </summary>
        [DataMember(Name = "Recipients", Order = 4, IsRequired = true)]
        public string Recipients { get; set; }

        /// <summary>
        /// Gets or sets notification type: TODO: May need to expose Notification.NotificationType 
        /// </summary>
        [DataMember(Name = "NotificationType", Order = 5, IsRequired = true)]
        public string NotificationType { get; set; }

        /// <summary>
        /// Gets or sets the optional notification parameters.
        /// </summary>
        [DataMember(Name = "NotificationProperties", Order = 6, IsRequired = false)]
        public PropertyDictionary NotificationProperties { get; set; }

        /// <summary>
        /// Container class for notification pproperties.
        /// </summary>
        [CollectionDataContract(Name = "PropertyDictionary", ItemName = "Entry", KeyName = "Name", ValueName = "Value")]
        public class PropertyDictionary : Dictionary<NotificationProperty, string>
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerBasedService\Service.cs ===
//-------------------------------------------------------------------
// <copyright file="Service.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The main thread of the timer based service
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/11/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService
{
    using System;
    using System.Collections.Generic;
    using System.Configuration;
    using System.Threading;
    using AsyncMultiplayer.TimerBasedService.Common;
    using Leet.Core.Configuration;
    using Leet.Core.Diagnostics;
    using Leet.Core.IO;
    using Leet.Core.Utils;
    using Leet.Health.Common;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// The main Notification service.
    /// </summary>
    public partial class TimerBasedService : System.ServiceProcess.ServiceBase
    {
        /// <summary>
        /// The maximum allowed timer based plugins.
        /// </summary>
        private const int MaxAllowedPlugins = 5;

        /// <summary>
        /// The service base. This pointer is used for stopping the service gracefully. 
        /// </summary>
        private static System.ServiceProcess.ServiceBase serviceBase = null;

        /// <summary>
        /// Gets or sets the service base of TimerBasedService. 
        /// </summary>
        public static System.ServiceProcess.ServiceBase ServiceBase
        {
            get { return TimerBasedService.serviceBase; }
            set { TimerBasedService.serviceBase = value; }
        }

        /// <summary>
        /// Provide a way to gracefully stop the service. 
        /// </summary>
        public static void StopService()
        {
            TimerBasedService.ServiceBase.Stop();
        }

        /// <summary>
        /// The overrided onStart method. Enable the timer. Init the queue object.
        /// </summary>
        /// <param name="args">Argument lists. It is not used by this override method. </param>
        protected override void OnStart(string[] args)
        {
            try
            {
                GarbageCollectorServiceEvents.Initialize(ComponentName);

                Logging.TraceInformation(
                    "{0} Starting TimerBasedService",
                      ComponentName);

                // Set the default directory to current.Service will use system32 by default. 
                // this is required in case any of the file path uses relative path. 
                System.IO.Directory.SetCurrentDirectory(System.AppDomain.CurrentDomain.BaseDirectory);

                TimerBasedService.ServiceIsStopping = false;

                // initialize the health listner
                try
                {
                    string healthCheckPort = ConfigurationManager.AppSettings["HealthCheck_HighPort"];

                    // invoke the health listner only when port can be found in TimerBasedService.exe.config
                    if (String.IsNullOrEmpty(healthCheckPort))
                    {
                        Logging.TraceError(
                            "{0}: {1}",
                            ComponentName,
                            "healthCheckPort is empty in the TimerBasedService.exe.config file.");
                    }
                    else
                    {
                        ushort listnerPort = UInt16.Parse(healthCheckPort);
                        HealthListener.InitializeHealthListener(ComponentName, listnerPort);
                    }
                }
                catch (Exception ex)
                {
                    // we should let the Timer Based Service run
                    // any exception caught here can only be due to bad configuration which should not happen
                    Logging.TraceException(
                        ex,
                        "{0}: {1}",
                        ComponentName,
                        "Caught exception initializing health blocks.");
                }

                this.InitializePlugins();

                Logging.TraceInformation(
                    "{0}: {1}", 
                    ComponentName,
                    "TimerBasedService started.");
            }
            catch (Exception e)
            {
                Logging.TraceException(e, "{0}: Exception caught during TimerBasedService start up.", ComponentName);
                HandleException("OnStart", e);
            }
        }

        /// <summary>
        /// The overrided onStop method. Close the queue object.
        /// </summary>
        protected override void OnStop()
        {
            try
            {
                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Stoping TimerBasedService.");

                // Set the flag to indicate the service is stopping.
                // This is used to control the while loop of TimerBasedServiceWorker
                TimerBasedService.ServiceIsStopping = true;

                // Clean up all the timers
                foreach (System.Threading.Timer serviceTimer in this.serviceTimers)
                {
                    serviceTimer.Dispose();
                }

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "TimerBasedService stopped.");
            }
            catch (Exception e)
            {
                Logging.TraceException(e, "{0}:{1}", ComponentName, "Exception caught during TimerBasedService shut down.");

                HandleException("OnStop", e);
            }
        }

        /// <summary>
        /// The entry point of the service.
        /// </summary>
        private static void Main()
        {
            try
            {
                Leet.Core.IoCCo.Container.Instance.AddService<ILogFormatter, LogFormatter>();
                Leet.Core.IoCCo.Container.Instance.AddService<ILogging, Logging>();

                Leet.Core.IoCCo.Container.Instance.AddService<IRegistryProvider, RegistryProvider>();

                Leet.Core.IoCCo.Container.Instance.AddService<IConfigurationProvider, NpdbConfigurationProvider>();
                ((NpdbConfigurationProvider)Leet.Core.IoCCo.Container.Instance.GetComponent<IConfigurationProvider>()).Initialize("LEET", ComponentName);

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Enter Main()");

                System.ServiceProcess.ServiceBase[] servicesToRun;

                // More than one user service may run within the same process. To add
                // another service to this process, change the following line to
                // create a second service object. For example,
                //
                // ServicesToRun = new System.ServiceProcess.ServiceBase[]
                // {new Service1(), new MySecondUserService()};

                // Save a pointer to service base so other threads can access it
                TimerBasedService.ServiceBase = new TimerBasedService();
                servicesToRun = new System.ServiceProcess.ServiceBase[] { TimerBasedService.ServiceBase };

                System.ServiceProcess.ServiceBase.Run(servicesToRun);

                Logging.TraceInformation(
                    "{0}: {1}",
                    ComponentName,
                    "Leave Main()");
            }
            catch (Exception e)
            {
                Logging.TraceException(e, "{0}:{1}", ComponentName, "Exception caught in TimerBasedService.Main().");
                TimerBasedService.HandleException("Main()", e);
            }
        }

        /// <summary>
        /// Load and initialize the timer plugins. 
        /// </summary>
        private void InitializePlugins()
        {
            List<TimerPluginDescription> plugins = (List<TimerPluginDescription>)System.Configuration.ConfigurationManager.GetSection("TimerPlugins");
            if (plugins.Count == 0)
            {
                throw new LIVEnException("No plugins are specified in the cofiguration file ");
            }

            if (plugins.Count > MaxAllowedPlugins)
            {
                throw new LIVEnException("There are too many plugins specified in the config file. ");
            }

            foreach (TimerPluginDescription plugin in plugins)
            {
                Type type = Type.GetType((string)plugin.Type);
                ITimerPlugin timerPlugin = Activator.CreateInstance(type) as ITimerPlugin;
                TimerCallback timerDelegate = new TimerCallback(timerPlugin.DoWork);

                // if frequency is 0, which means the timer is not repetitive. just fire it once. 
                int period = plugin.Frequency == 0 ? Timeout.Infinite : (int)plugin.Frequency * 1000;
                System.Threading.Timer timer = new System.Threading.Timer(timerDelegate, null, plugin.Due * 1000, period);
                this.serviceTimers.Add(timer);

                timerPlugin.Initialize(timer, plugin, ComponentName);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService.Test\Properties\AssemblyInfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PartnerService.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("0b086baf-2d5a-4a83-9193-9df01e222b8b")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerBasedService\PluginConfigurationSection.cs ===
//-----------------------------------------------------------------------------
// <copyright file="PluginConfigurationSection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//     This file contains the class for retrieving custom-defined plugins
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/11/2010">
//     Class Created
// </history>
//-----------------------------------------------------------------------------
namespace AsyncMultiplayer.TimerBasedService
{
    using System;
    using System.Collections.Generic; 
    using System.Configuration;
    using System.Xml;
    using AsyncMultiplayer.TimerBasedService.Common; 
    using Leet.Core.Utils; 

    /// <summary>
    /// Custom Handler to access the custom-defined Configuration Section.
    /// </summary>
    public class PluginConfigSectionHandler : IConfigurationSectionHandler
    {
        /// <summary>
        /// Creates a custom-defined object that contains the custom-defined settings.
        /// </summary>
        /// <param name="parent">Parent object in web.config.</param>
        /// <param name="configContext">Configuration context object.</param>
        /// <param name="section">Specified Section XML node.</param>
        /// <returns>The object created by the handler.</returns>
        object IConfigurationSectionHandler.Create(
          object parent, object configContext, XmlNode section)
        {
            List<TimerPluginDescription> configObject = new List<TimerPluginDescription>(); 
            foreach (XmlNode child in section.SelectNodes("add"))
            {
                if (XmlNodeType.Element == child.NodeType)
                {
                    try
                    {
                        uint due = uint.Parse(child.Attributes["due"].Value); 
                        uint frequency = uint.Parse(child.Attributes["frequency"].Value);
                        configObject.Add(new TimerPluginDescription(
                                                    child.Attributes["name"].Value,
                                                    child.Attributes["type"].Value,
                                                    due,
                                                    frequency,
                                                    child.Attributes["option"].Value));
                    }
                    catch (Exception)
                    {
                        throw new LIVEnException("Invalid configuration entry " + child.ToString());
                    }
                }
            }

            return configObject;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerBasedService\ServiceInstall.cs ===
//-------------------------------------------------------------------
// <copyright file="ServiceInstall.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  The ProjectInstaller class. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/29/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService.Internal
{
    using System.ComponentModel; 
    using System.Configuration.Install;
    using System.ServiceProcess;
   
    /// <summary>
    /// Defines the project installer class. This is used to install the service. 
    /// </summary>
    [RunInstaller(true)]
    public class ProjectInstaller : Installer
    {
        /// <summary>
        /// The ServiceProcessInstaller object. 
        /// </summary>
        private ServiceProcessInstaller process;

        /// <summary>
        /// The ServiceInstaller service object. 
        /// </summary>
        private ServiceInstaller service;

        /// <summary>
        /// Initializes a new instance of the ProjectInstaller class. 
        /// </summary>
        public ProjectInstaller()
        {
            this.process = new ServiceProcessInstaller();
            this.process.Account = ServiceAccount.LocalSystem;
            this.service = new ServiceInstaller();
            this.service.ServiceName = "AsyncMultiplayer TimerBasedService Service";
            Installers.Add(this.process);
            Installers.Add(this.service);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerBasedService\ServiceInternal.cs ===
//-------------------------------------------------------------------
// <copyright file="ServiceInternal.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
// The main thread of timer based service. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="09/29/2009">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService
{
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// The main Notification service.
    /// </summary>
    public partial class TimerBasedService
    {
        /// <summary>
        /// The display name of the component. 
        /// </summary>
        public const string ComponentName = "garbage_collector_service";

        /// <summary>
        /// A flag to indicate whether the Notification service is stopping.
        /// </summary>
        private static bool serviceIsStopping;

        /// <summary>
        /// The scheduled timers.
        /// </summary>
        private List<System.Threading.Timer> serviceTimers;

        /// <summary>
        /// The timer delegates. One for each timer.
        /// </summary>
        private List<TimerCallback> timerDelegates;

        /// <summary>
        /// Initializes a new instance of the TimerBasedService class. 
        /// </summary>
        public TimerBasedService()
        {
            this.serviceTimers = new List<System.Threading.Timer>();
            this.timerDelegates = new List<TimerCallback>(); 
        }

        /// <summary>
        /// Gets or sets a value indicating whether the service is stopping.
        /// </summary>
        public static bool ServiceIsStopping
        {
            get { return TimerBasedService.serviceIsStopping; }
            set { TimerBasedService.serviceIsStopping = value; }
        }

        /// <summary>
        /// This eventlogs the exception.
        /// to the client.
        /// </summary>
        /// <param name="methodName">Name of the web method from which
        /// exception is thrown.
        /// </param>
        /// <param name="ex">Exception object.</param>
        private static void HandleException(string methodName, Exception ex)
        {
            GarbageCollectorServiceEvents.Events.TraceEvent(
                GarbageCollectorServiceEvents.UnexpectedExceptionInService,
                "\r\nUnexpected exception happened in: " + methodName + ".\r\n",
                ex.ToString());

            throw ex;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\PartnerService.Test\Program.cs ===
//-------------------------------------------------------------------
// <copyright file="Program.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <summary>
//  Test class for partner API testing.
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="04/14/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace PartnerService.Test
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using AsyncMultiplayer.PartnerService.DataContracts;

    /// <summary>
    /// Class to test partner service APIs.
    /// </summary>
    public class Program
    {
        /// <summary>
        /// Main entry.
        /// </summary>
        public static void Main()
        {
            TestSendNotification();
            TestDeleteNotifications();
            TestPostGameResults();
        }

        /// <summary>
        /// Test method for SendNotification API.
        /// </summary>
        public static void TestSendNotification()
        {
            // initialize the WebRequest request
            //string url = "http://partners.dev.xboxlive.com/PartnerService.svc/notification";
            //string url = "http://10.195.100.164:62621/PartnerService.svc/notification";
            string url = "http://le-xblob-test01:443/PartnerService.svc/notification";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "text/xml";
            request.Method = "POST";
            request.Headers.Add("X-Locale", "en-US");

            // initialize the request body
            PartnerNotificationRequest requestBody = new PartnerNotificationRequest();
            requestBody.From = "mpdev1";
            requestBody.GameId = 4294967295;
            requestBody.SessionId = "00000000-ed57-4617-962d-bb743edd0cb5";
            requestBody.Recipients = "mpdev2;mpdev3";
            requestBody.NotificationType = "Invitation";
            requestBody.NotificationProperties = new PartnerNotificationRequest.PropertyDictionary();
            requestBody.NotificationProperties.Add(NotificationProperty.ExpirationTime, DateTime.UtcNow.AddDays(10).ToString());
            requestBody.NotificationProperties.Add(NotificationProperty.DataBlob, "<html><head><title>Object moved</title></head><body><h2>Object moved to <a href=\"http://www.microsoft.com/atwork/community/rss.xml\">here</a>.</h2></body></html>");

            Stream stream = request.GetRequestStream();
            DataContractSerializer dcs = new DataContractSerializer(typeof(PartnerNotificationRequest));
            dcs.WriteObject(stream, requestBody);
            stream.Close();

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }

        /// <summary>
        /// Test method for DeleteNotifications API.
        /// </summary>
        public static void TestDeleteNotifications()
        {
            // initialize the WebRequest request
            //string url = "http://partners.dev.xboxlive.com/PartnerService.svc/deletenotifications";
            string url = "http://le-xblob-test01:443/PartnerService.svc/deletenotifications";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "text/xml";
            request.Method = "POST";
            request.Headers.Add("X-Locale", "en-US");

            // initialize the request body
            PartnerDeleteRequest requestBody = new PartnerDeleteRequest();
            requestBody.GameId = 4294967295;
            requestBody.SessionId = "00000000-ed57-4617-962d-bb743edd0cb5";
            requestBody.Players = "mpdev1;;;;mpdev2;mpdev3";

            Stream stream = request.GetRequestStream();
            DataContractSerializer dcs = new DataContractSerializer(typeof(PartnerDeleteRequest));
            dcs.WriteObject(stream, requestBody);
            stream.Close();

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }

        /// <summary>
        /// Test method for PostGameResults API.
        /// </summary>
        public static void TestPostGameResults()
        {
            // initialize the WebRequest request
            //string url = "http://partners.dev.xboxlive.com/PartnerService.svc/gameresults";
            string url = "http://le-xblob-test01:443/PartnerService.svc/gameresults";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.ContentType = "text/xml";
            request.Method = "POST";
            request.Headers.Add("X-Locale", "en-US");

            // initialize the request body
            List<PartnerCompositeGameResult> resultList = new List<PartnerCompositeGameResult>();
            PartnerCompositeGameResult result = new PartnerCompositeGameResult();
            result.PlatformType = "5";
            result.Locale = "en-US";
            result.Gamertag = "mpdev1";
            result.GameResult = new Gds.Contracts.GameResult();
            result.GameResult.GameId = 7777;
            result.GameResult.GameResultId = Guid.NewGuid();
            result.GameResult.Outcome = "Win";
            resultList.Add(result);

            Stream stream = request.GetRequestStream();
            DataContractSerializer dcs = new DataContractSerializer(typeof(List<PartnerCompositeGameResult>));
            dcs.WriteObject(stream, resultList);
            stream.Close();

            WebResponse response = null;
            try
            {
                response = request.GetResponse();
            }
            finally
            {
                if (response == null)
                {
                    Console.WriteLine("No Response");
                }
                else
                {
                    using (StreamReader sr = new StreamReader(response.GetResponseStream()))
                    {
                        Console.WriteLine(sr.ReadToEnd().Trim());
                    }

                    response.Close();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerPluginCommon\ITimerService.cs ===
//-------------------------------------------------------------------
// <copyright file="ITimerService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Internal interface definition for Time based service. 
//  This interface defines some methods that the plugins can access. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService.Common
{
    using System;

    /// <summary>
    /// The ITimerService defines the interface that
    /// handles and processes notification request internally.
    /// </summary>
    public interface ITimerService
    {
        /// <summary>
        /// Get the containing service. 
        /// </summary>
        /// <returns>A reference to the timer service.</returns>
        ITimerService GetContainerService(); 

        /// <summary>
        /// Check if the service is stopping. 
        /// </summary>
        /// <returns>bool to indicate if the service is stopping</returns>
        bool IsServiceStopping(); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerPluginCommon\TimerPluginDescription.cs ===
//-------------------------------------------------------------------
// <copyright file="TimerPluginDescription.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Defines the properties of a timer plugin configuration. 
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService.Common
{
    using System;

    /// <summary>
    /// The class defines the description properties of a timer plugin. 
    /// these fields should be 
    /// </summary>
    public class TimerPluginDescription
    {
        /// <summary>
        /// Initializes a new instance of the TimerPluginDescription class. 
        /// </summary>
        /// <param name="name">The name of the plugin. </param>
        /// <param name="type">The provider type string name. </param>
        /// <param name="due">The due time of the service. </param>
        /// <param name="frequency">The desired frequency. </param>
        /// <param name="option">The options for initialize the plugin. </param>
        public TimerPluginDescription(string name, string type, uint due, uint frequency, string option)
        {
            this.DisplayName = name;
            this.Type = type;
            this.Due = due; 
            this.Frequency = frequency;
            this.Options = option;
        }

        /// <summary>
        /// Gets or sets the display name of the plugin
        /// </summary>
        public string DisplayName { get; set; }

        /// <summary>
        /// Gets or sets the type name of the plugin
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Gets or sets the due time of the timer. 
        /// </summary>
        public uint Due { get; set; }

        /// <summary>
        /// Gets or sets the frequency in seconds. This tells how often the plugin should be invoked in seconds
        /// </summary>
        public uint Frequency { get; set; }

        /// <summary>
        /// Gets or sets the options to create the plugin. The string should be in xml. 
        /// </summary>
        public string Options { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerPluginCommon\ITimerPlugin.cs ===
//-------------------------------------------------------------------
// <copyright file="ITimerPlugin.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Internal interface definition for handling timer plugin
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService.Common
{
    using System;

    /// <summary>
    /// The ITimerPlugin defines the interface that
    /// handles and processes notification request internally.
    /// </summary>
    public interface ITimerPlugin
    {
        /// <summary>
        /// The entry point of the plugin
        /// </summary>
        /// <param name="state">The state passed to the work method.</param>
        void
        DoWork(object state);

        /// <summary>
        /// This method initializes the plugin. 
        /// </summary>
        /// <param name="timer">The timer associate with this plugin</param>
        /// <param name="description">The description of the timer. </param>
        /// <param name="componentName">The calling service component name.</param>
        void
        Initialize(System.Threading.Timer timer, TimerPluginDescription description, string componentName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\NotificationService\TimerPluginCommon\SampleTimer.cs ===
//-------------------------------------------------------------------
// <copyright file="SampleTimer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  This is a sample implementation of ITimerPlugin interface
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="01/12/2010">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.TimerBasedService.Common
{
    using System.Threading;
    using Leet.Core.Diagnostics;

    /// <summary>
    /// The ITimerPlugin defines the interface that
    /// handles and processes notification request internally.
    /// </summary>
    public class SampleTimer : ITimerPlugin
    {
        /// <summary>
        /// Save a reference to the associated timer. 
        /// </summary>
        private System.Threading.Timer timer;

        /// <summary>
        /// Save a reference to the associated description. 
        /// </summary>
        private TimerPluginDescription description; 

        /// <summary>
        /// The entry point of the plugin
        /// </summary>
        /// <param name="state">The state passed to the work method.</param>
        public void DoWork(object state)
        {
            // first disable the timer
            this.timer.Change(Timeout.Infinite, 0);

            Logging.TraceInformation(
                    "{0}: {1}",
                   this.description.DisplayName,
                   "Timer fired.");

            // re-enable the timer
            if (this.description.Frequency > 0)
            {
                this.timer.Change(this.description.Frequency * 1000, Timeout.Infinite);
            }
        }

        /// <summary>
        /// This method initializes the plugin. 
        /// </summary>
        /// <param name="timer">The timer associated with this plugin</param>
        /// <param name="description">The description of the plugin. </param>
        /// /// <param name="componentName">The calling service component name.</param>
        public void Initialize(System.Threading.Timer timer, TimerPluginDescription description, string componentName)
        {
            // option is ignored in this sample. It can be an xml string with 
            // optional arguments. 
            this.timer = timer;
            this.description = description; 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\PassThruGameLogicModule\PassThruGameLogicModule.cs ===
// <copyright file="PassThruGameLogicModule.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the class definition for PassThruGameLogicModule class.</summary>
namespace AsyncMultiplayer.PassThruGameLogicModule
{
    using System.Collections.Generic;
    using System.IO;
    using System.Net;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using SessionCommon;

    /// <summary>
    /// This class provides the pass-through server game logic module implementation.
    /// </summary>
    public class PassThruGameLogicModule : IGameLogicModule
    {
        /// <summary>
        /// Default name of the fileName to be used.
        /// </summary>
        public const string DefaultFileName = "0";

        /// <summary>
        /// Used to define the version number for the module.
        /// </summary>
        private const int Version = 1;

        /// <summary>
        /// Maximum number of players supported by the passthru module.
        /// </summary>
        private const int MaxPassThruPlayers = 16;

        /// <summary>
        /// This field is used to store the reference to a IGameStateStorage implementation.
        /// </summary>
        private readonly IGameStateStorage stateStorage;

        /// <summary>
        /// This field is used to store the reference to a ISessionStorage implementation.
        /// </summary>
        private readonly ISessionStorage sessionStorage;

        /// <summary>
        /// Initializes a new instance of the PassThruGameLogicModule class.
        /// </summary>
        /// <param name="stateStorage">Implementation of the state storage to use.</param>
        /// <param name="sessionStorage">Implementation of the session storage to use.</param>
        public PassThruGameLogicModule(IGameStateStorage stateStorage, ISessionStorage sessionStorage)
        {
            this.stateStorage = stateStorage;
            this.sessionStorage = sessionStorage;
        }

        /// <summary>
        /// Assign an owner for the session, used to assign an owner when a passthru session has no owner.
        /// </summary>
        /// <param name="sessionState">The current session state.</param>
        /// <param name="sessionStorageImpl">The session storage implementation to use.</param>
        /// <returns>The assigned owner's seat.</returns>
        public static SeatInfo AssignOwner(SessionState sessionState, ISessionStorage sessionStorageImpl)
        {
            // In case of passthru server, if the owner has left just make the next player the session owner.
            int nextOwnerSeatIndex = -1;
            foreach (var seat in sessionState.Seats)
            {
                if (nextOwnerSeatIndex == -1 || seat.Index < nextOwnerSeatIndex)
                {
                    nextOwnerSeatIndex = seat.Index;
                }
            }

            SeatInfo nextOwnerSeat = null;
            if (nextOwnerSeatIndex == -1)
            {
                // This means that there are no more players in the session.
                // Don't assign a new owner, let the session be garbage collected.
            }
            else
            {
                OpaqueSessionStorageObject storageObject;
                sessionStorageImpl.QuerySession(sessionState.SessionID, sessionState.GameID, out storageObject);

                sessionState.OwnerSeatIndex = nextOwnerSeatIndex;
                ModuleModifiableState moduleModifiableState = new ModuleModifiableState
                {
                    OwnerSeatIndex = sessionState.OwnerSeatIndex
                };

                // Make the next owner the person responsible for this action.
                IdentityToken nextOwnerIdentity = null;
                foreach (var seat in sessionState.Seats)
                {
                    if (seat.Index == nextOwnerSeatIndex)
                    {
                        nextOwnerIdentity = seat.Profile;
                        nextOwnerSeat = seat;
                        break;
                    }
                }

                sessionStorageImpl.ModifySession(storageObject, moduleModifiableState, nextOwnerIdentity);
            }

            return nextOwnerSeat;
        }

        /// <summary>
        /// Gets the version of the Game Logic Module.
        /// </summary>
        /// <returns>The version of the Game Logic Module.</returns>
        public int GetVersion()
        {
            return PassThruGameLogicModule.Version;
        }

        /// <summary>
        /// Gets the information about the Game Logic Module.
        /// </summary>
        /// <returns>Information about the Game Logic Module.</returns>
        public ModuleInfo GetModuleInfo()
        {
            ModuleInfo info = new ModuleInfo();
            info.IsPassThruModule = true;
            info.VariantMaxPlayersMap = new Dictionary<int, int>();
            info.VariantMaxPlayersMap[0] = PassThruGameLogicModule.MaxPassThruPlayers;

            return info;
        }

        /// <summary>
        /// Fired when a new session is created.
        /// </summary>
        /// <param name="sessionState">The session state of the created session.</param>
        /// /// <param name="creationData">Data used for creation of the session</param>
        public void OnCreateSession(SessionState sessionState, CreationData creationData)
        {
            MemoryStream saveStream;

            // If session parameters are specified, set the initial game state to session parameters array.
            if (sessionState.SessionParameters != null && sessionState.SessionParameters.Length > 0)
            {
                saveStream = new MemoryStream(sessionState.SessionParameters);
            }
            else
            {
                saveStream = new MemoryStream();
            }

            try
            {
                this.stateStorage.ProvisionStorage(sessionState.SessionID, sessionState.GameID);
                this.stateStorage.Save(sessionState.SessionID, sessionState.GameID, PassThruGameLogicModule.DefaultFileName, saveStream);
            }
            finally
            {
                saveStream.Close();
            }
        }

        /// <summary>
        /// Fired when a session is modified.
        /// </summary>
        /// <param name="modifiedSessionState">The session state of the modified session.</param>
        /// /// <param name="modificationData">Data used for modification of the session.</param>
        public void OnModifySession(SessionState modifiedSessionState, ModificationData modificationData)
        {
            // No action needs to be taken in case of passthru server.
        }

        /// <summary>
        /// Fired when a player joins a session.
        /// </summary>
        /// <param name="joinedSessionState">The state of the session after the join.</param>
        /// <param name="joinData">The data received while joining.</param>
        public void OnJoinSession(SessionState joinedSessionState, JoinData joinData)
        {
            // No action needs to be taken in case of passthru server.
        }

        /// <summary>
        /// Fired when a player leaves a session.
        /// </summary>
        /// <param name="leftSessionState">Session state after leave.</param>
        /// <param name="ownerLeft">Did the session owner leave?</param>
        /// <param name="userWhoLeft">The seat information of the user who left.</param>
        public void OnLeaveSession(SessionState leftSessionState, bool ownerLeft, SeatInfo userWhoLeft)
        {
            if (ownerLeft)
            {
                PassThruGameLogicModule.AssignOwner(leftSessionState, this.sessionStorage);
            }
        }

        /// <summary>
        /// Fired when a user tries to get the game state.
        /// </summary>
        /// <param name="sessionState">Session state.</param>
        /// <param name="actorSeatIndex">The user trying to get game state.</param>
        /// <returns>The full game state view</returns>
        public FullGameState OnGetGameState(SessionState sessionState, int actorSeatIndex)
        {
            GameStateFile gameStateFile = null;
            FullGameState fullGameState = new FullGameState();

            using (gameStateFile = this.stateStorage.Load(
                                       sessionState.SessionID,
                                       sessionState.GameID,
                                       DefaultFileName))
            {
                fullGameState.GameStateInfo = sessionState.State;

                // Data stream length is limited by validations.
                using (MemoryStream stream = new MemoryStream())
                {
                    CopyStream(gameStateFile.DataStream, stream);
                    fullGameState.GameData = stream.ToArray();
                }
            }

            return fullGameState;
        }

        /// <summary>
        /// Fired when a user tries to submit a game action.
        /// </summary>
        /// <param name="curSessionState">Current state of the session.</param>
        /// <param name="action">The action submitted by the user.</param>
        /// <param name="actorSeatIndex">The user trying to submit game action.</param>
        /// <param name="storageObject">Opaque storage to be used as a param for ISessionStorage.Modify().</param>
        public void OnSubmitGameAction(SessionState curSessionState, GameAction action, int actorSeatIndex, OpaqueSessionStorageObject storageObject)
        {
            if (action.ActionType == GameActionType.GameSpecific)
            {
                // There is no need of implementing this,as passthru games do not support game specific actions.
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.OnSubmitGameActionNotImplementedInPassthru,
                    HttpStatusCode.NotImplemented,
                    null,
                    false,
                    curSessionState.SessionID,
                    curSessionState.GameID.ToString());
            }
        }

        /// <summary>
        /// Copies from one stream to another
        /// </summary>
        /// <param name="sourceStream">The stream to copy from</param>
        /// <param name="destinationStream">The stream to copy to</param>
        /// <returns> Total bytes copied.</returns>
        internal static long CopyStream(Stream sourceStream, Stream destinationStream)
        {
            const int BufferSize = 0x10000;
            byte[] buffer = new byte[BufferSize];
            int n = 0;
            long totalRead = 0;
            do
            {
                n = sourceStream.Read(buffer, 0, BufferSize);
                if (n > 0)
                {
                    totalRead += n;
                    destinationStream.Write(buffer, 0, n);
                }
            }
            while (n > 0);
            return totalRead;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\PassThruGameLogicModule\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the assembly information for the PassThruGameLogicModule assembly.</summary>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("PassThruGameLogicModule")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("3fd4ca2e-036f-466a-a0fe-b2957480640b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\AzureSessionStorageObject.cs ===
// <copyright file="AzureSessionStorageObject.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the class definition for AzureSessionStorageObject.</summary>
namespace AsyncMultiplayer.SessionAzureStorage
{
    /// <summary>
    /// This class models an AzureSessionStorageObject,
    /// a reference of this object is meant to be used as OpaqueSessionStorageObject.Object's value.
    /// </summary>
    internal class AzureSessionStorageObject
    {
        /// <summary>
        /// Gets or sets the session table entity.
        /// </summary>
        public SessionAzureTableEntity SessionTableEntity
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the session data service context.
        /// </summary>
        public SessionDataServiceContext SessionDataContext
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionAzureGarbageCollector.cs ===
// <copyright file="SessionAzureGarbageCollector.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-05-13</date>
// <summary>Contains the class definition for SessionAzureGarbageCollector class.</summary>

namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization.Formatters.Binary;
    using Common.AzureStorage;
    using Leet.Core.Diagnostics;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationService;
    using SessionCommon;

    /// <summary>
    /// Implements the session garbage collector for Azure storage.
    /// </summary>
    public class SessionAzureGarbageCollector
    {
        /// <summary>
        /// Gets or sets the storage account information.
        /// </summary>
        /// <value>The account value itself.</value>
        private readonly StorageAccountInfo account;

        /// <summary>
        /// Gets or sets the proxy setting of the environment. 
        /// </summary>
        private readonly string proxyAddress;

        /// <summary>
        /// The Notification storage implementation to use.
        /// </summary>
        private readonly INotificationStorage notificationStorage;

        /// <summary>
        /// The Game state storage implementation to use.
        /// </summary>
        private readonly IGameStateStorage gameStateStorage;

        /// <summary>
        /// In Test mode, how many seconds to wait after a warning to delete a session.
        /// </summary>
        private readonly uint secondsToWaitInTestMode;

        /// <summary>
        /// Maximum number of times to retry updating the session count for a user 
        /// </summary>
        private const int MaxRetryCount = 3;

        /// <summary>
        /// Initializes a new instance of the SessionAzureGarbageCollector class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        /// <param name="proxyAddress">The proxy setting for the environment. </param>
        /// <param name="notificationStorage">The Notification storage implementation to use.</param>
        /// <param name="gameStateStorage">The Game state storage implementation to use.</param>
        /// <param name="secondsToWaitInTestMode">In Test mode, how many seconds to wait after a warning to delete a session.</param>
        public SessionAzureGarbageCollector(
            StorageAccountInfo account, string proxyAddress, INotificationStorage notificationStorage, IGameStateStorage gameStateStorage, uint secondsToWaitInTestMode)
        {
            this.account = account;

            if (!string.IsNullOrEmpty(proxyAddress))
            {
                this.proxyAddress = proxyAddress;
            }

            this.notificationStorage = notificationStorage;
            this.gameStateStorage = gameStateStorage;
            this.secondsToWaitInTestMode = secondsToWaitInTestMode;
        }

        /// <summary>
        /// Gets the name of the component.
        /// </summary>
        private static string ComponentName
        {
            get
            {
                return "SessionAzureGarbageCollector";
            }
        }

        /// <summary>
        /// Deletes a session from the storage. It also deletes the associated notifications and game state.
        /// Only sessions that are completed or already warned are deleted.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to be deleted.</param>
        /// <param name="gameID">The gameID of the session to be deleted.</param>
        /// <param name="sessionIndexPartitionKey">The partition key for the session index.</param> 
        /// <param name="sessionIndexRowKey">The row key for the session index.</param>
        /// <param name="warnedSeatIndex">Which seat index was warned, -1 if no seat was warned.</param>
        /// <param name="warnedSessionState">In case a player on a seat was warned, what was the sessionState? null if no player was warned.</param>
        /// <param name="runInTestMode">Run the logic in test mode, makes sure that the session was warned secondsToWaitInTestMode seconds ago instead of 1 day before deleting it.</param>
        /// <returns>Whether the session was deleted.</returns>
        public bool DeleteSession(string sessionID, uint gameID, string sessionIndexPartitionKey, string sessionIndexRowKey, out int warnedSeatIndex, out SessionState warnedSessionState, bool runInTestMode)
        {
            const string MethodName = "DeleteSession";
            bool sessionDeleted = false;
            warnedSeatIndex = -1;
            warnedSessionState = null;

            SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.account);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = this.proxyAddress;

            IEnumerable<SessionAzureTableEntity> result = SessionAzureStorage.GetSessionEntityList(sessionContext, sessionID, (int)gameID);
            SessionAzureTableEntity sessionTableEntity = null;
            try
            {
                sessionTableEntity = result.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                OperationResponse response = ex.Response;

                // Do not throw in cases of session entity not found.
                if (response.StatusCode != (int)HttpStatusCode.NotFound)
                {
                    throw;
                }
            }

            if (sessionTableEntity != null)
            {
                SeatInfo[] seatInfos = null;
                MemoryStream memStream = new MemoryStream(sessionTableEntity.SeatsInfos); // Expandable memory stream.
                BinaryFormatter formatter = new BinaryFormatter();
                try
                {
                    seatInfos = (SeatInfo[])formatter.Deserialize(memStream);
                }
                catch (Exception ex)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.DeserializationErrorWhileDeleting,
                        HttpStatusCode.InternalServerError,
                        ex,
                        false,
                        sessionID,
                        gameID.ToString());
                }
                finally
                {
                    memStream.Close();
                }

                SeatInfo activeSeat = null;
                SeatInfo ownerSeat = null;
                foreach (var seat in seatInfos)
                {
                    if (seat.Index == sessionTableEntity.ActiveSeatIndex)
                    {
                        activeSeat = seat;
                    }

                    if (seat.Index == sessionTableEntity.OwnerSeatIndex)
                    {
                        ownerSeat = seat;
                    }

                    // Break if all interesting seats have been found.
                    if (activeSeat != null && ownerSeat != null)
                    {
                        break;
                    }
                }

                // If the session is not complete/warned, try to warn for the session.
                if (!sessionTableEntity.IsComplete && !sessionTableEntity.IsInactivityWarningSent)
                {
                    // If the active seat is filled, warn the active user.
                    if (activeSeat != null)
                    {
                        warnedSeatIndex = activeSeat.Index;
                    }
                    else
                    {
                        // If the active seat is empty, warn the owner, if present.
                        if (ownerSeat != null)
                        {
                            warnedSeatIndex = ownerSeat.Index;
                        }
                        else
                        {
                            // Check if there are any players in the session, there shouldn't be.
                            // We will delete the session immediately without warning - warning won't help as
                            // none of the users have any power to take a meaningful action.
                            if (seatInfos.Length != 0)
                            {
                                Logging.TraceInformation(
                                    "{0}: , While deleting, found that the session has no active player or owner, but it still has other players: SessionID: {1} GameID: {2}",
                                    MethodName,
                                    sessionID,
                                    gameID.ToString());
                            }
                        }
                    }
                }

                // Warn if possible, else delete the session.
                if (warnedSeatIndex >= 0)
                {
                    sessionTableEntity.IsInactivityWarningSent = true;
                    sessionTableEntity.InactivityWarningSentTime = DateTime.UtcNow;
                    warnedSessionState = sessionTableEntity.GetSessionState();
                    sessionContext.UpdateObject(sessionTableEntity);
                    sessionContext.SaveChangesWithRetries();
                }
                else
                {
                    // Don't delete the session if the warning was sent less than 1 day ago.
                    // If we are in test mode, don't delete if warning was sent less than secondsToWaitInTestMode seconds ago.
                    DateTime warningExpiryTime;
                    if (runInTestMode)
                    {
                        warningExpiryTime = DateTime.UtcNow.AddSeconds(-1 * this.secondsToWaitInTestMode);
                    }
                    else
                    {
                        warningExpiryTime = DateTime.UtcNow.AddDays(-1);
                    }

                    if (sessionTableEntity.IsInactivityWarningSent && (warningExpiryTime < sessionTableEntity.InactivityWarningSentTime))
                    {
                        if (runInTestMode)
                        {
                            Logging.TraceVerbose(
                                "{0} {1} {2} {3} {4}",
                                MethodName,
                                "Did not delete the session as it was warned less than " + this.secondsToWaitInTestMode + " seconds ago: SessionID:",
                                sessionID,
                                " GameID:",
                                gameID.ToString());
                        }
                        else
                        {
                            Logging.TraceVerbose(
                                "{0} {1} {2} {3} {4}",
                                MethodName,
                                "Did not delete the session as it was warned less than 1 day ago: SessionID:",
                                sessionID,
                                " GameID:",
                                gameID.ToString());
                        }
                    }
                    else
                    {
                        // First decrement the count of sessions for the original creator of the session.
                        if (sessionTableEntity.SessionCreatorIdentity != null)
                        {
                            this.DecrementUserSessionCount(new IdentityToken(sessionTableEntity.SessionCreatorIdentity));
                        }

                        // Delete the associated notifications
                        this.DeleteSessionNotifications(sessionID, gameID, seatInfos);

                        // Delete SessionEntry data
                        this.DeleteSessionEntries(sessionID, gameID, seatInfos);

                        // Delete Session data
                        sessionContext.DeleteObject(sessionTableEntity);
                        sessionContext.SaveChangesWithRetries();

                        // Delete the game state associated with the session.
                        this.gameStateStorage.DeprovisionStorage(sessionID, gameID);

                        // Delete SessionIndex data
                        this.DeleteSessionIndex(sessionIndexPartitionKey, sessionIndexRowKey);

                        sessionDeleted = true;
                    }
                }
            }
            else
            {
                // Delete any game state data still associated with the session.
                this.gameStateStorage.DeprovisionStorage(sessionID, gameID);

                // There is a sessionIndex entity without a session entity, delete it.
                this.DeleteSessionIndex(sessionIndexPartitionKey, sessionIndexRowKey);

                sessionDeleted = true;
            }

            return sessionDeleted;
        }

        /// <summary>
        /// Gets a list of session index Azure Table entities based on the criteria supplied.
        /// </summary>
        /// <param name="sessionIndexContext">The data service context for the query.</param>
        /// <param name="partitionKey">Partition key for the session index table.</param>
        /// <param name="rowKey">Row key for the session index table.</param>
        /// <returns>All session index Azure Table entities with the row key and the partition key specified.</returns>
        private static IEnumerable<SessionIndexAzureTableEntity> GetSessionIndexEntityList(
            SessionIndexDataServiceContext sessionIndexContext, string partitionKey, string rowKey)
        {
            var query = from c in sessionIndexContext.SessionIndexTable
                        where c.PartitionKey.Equals(partitionKey) &&
                            c.RowKey.Equals(rowKey)
                        select c;

            TableStorageDataServiceQuery<SessionIndexAzureTableEntity> sessionIndexQuery =
                new TableStorageDataServiceQuery<SessionIndexAzureTableEntity>(
                    query as DataServiceQuery<SessionIndexAzureTableEntity>,
                    sessionIndexContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionIndexAzureTableEntity> res = sessionIndexQuery.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// Decrement the a user's session count..
        /// </summary>
        /// <param name="userIdentity">The user for which to decrement the session count. </param>
        private void DecrementUserSessionCount(IdentityToken userIdentity)
        {
            bool retrySessionTableUpdate;
            int retryCount = 0;
            do
            {
                // By default,  we do not retry
                retrySessionTableUpdate = false;

                SessionCountDataServiceContext sessionCountContext = new SessionCountDataServiceContext(this.account);
                sessionCountContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
                sessionCountContext.ProxyAddress = this.proxyAddress;
                SessionCountAzureTableEntity sessionCountEntity = SessionAzureStorage.GetSessionCountEntityForUser(userIdentity, sessionCountContext);

                if (sessionCountEntity != null && sessionCountEntity.UserCreatedSessionCount > 0)
                {
                    sessionCountEntity.UserCreatedSessionCount--;
                    sessionCountContext.UpdateObject(sessionCountEntity);
                    try
                    {
                        sessionCountContext.SaveChangesWithRetries();
                    }
                    catch (DataServiceRequestException)
                    {
                        // Probably another thread has updated the player session count, retry.
                        if (retryCount < SessionAzureGarbageCollector.MaxRetryCount)
                        {
                            retryCount++;
                            retrySessionTableUpdate = true;
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
            }
            while (retrySessionTableUpdate);
        }

        /// <summary>
        /// Delete session entry data. Deletes the data from SessionEntryTable.
        /// </summary>
        /// <param name="sessionID">SessionID for which to delete data.</param>
        /// <param name="gameID">GameID for whihc to delete the data.</param>
        /// <param name="seatInfos">List of seats associated with the session.</param>
        private void DeleteSessionEntries(string sessionID, uint gameID, SeatInfo[] seatInfos)
        {
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.proxyAddress;

            foreach (var seatInfo in seatInfos)
            {
                IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = null;
                try
                {
                    sessionEntryResult = SessionAzureStorage.GetSessionEntryEntityList(sessionEntryContext, seatInfo.Profile.ToString(), sessionID, (int)gameID);
                    SessionEntryAzureTableEntity entity = sessionEntryResult.FirstOrDefault();

                    if (entity != null)
                    {
                        sessionEntryContext.DeleteObject(entity);
                        sessionEntryContext.SaveChangesWithRetries();
                    }
                }
                catch (DataServiceQueryException dataException)
                {
                    OperationResponse response = dataException.Response;

                    // In case the session enrty is not present, ignore.
                    if (response.StatusCode == (int)HttpStatusCode.NotFound)
                    {
                        continue;
                    }
                    else
                    {
                        throw;
                    }
                }
                catch (Exception ex)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.ErrorWhileTryingToDeleteSessionEntries,
                        HttpStatusCode.InternalServerError,
                        ex,
                        false,
                        sessionID,
                        gameID.ToString());
                }
            }
        }

        /// <summary>
        /// Delete the notifications accociated with the session.
        /// </summary>
        /// <param name="sessionID">SessionID for which to delete data.</param>
        /// <param name="gameID">GameID for which to delete the data.</param>
        /// <param name="seatInfos">List of seats associated with the session.</param>
        private void DeleteSessionNotifications(string sessionID, uint gameID, SeatInfo[] seatInfos)
        {
            foreach (var seatInfo in seatInfos)
            {
                ulong xuid;
                if (ulong.TryParse(seatInfo.Profile.Token, out xuid))
                {
                    string userID = xuid.ToString(); // Make sure that Token is a xuid,and remove any prefix of 0s.
                    try
                    {
                        this.notificationStorage.DeleteNotificationBySession(userID, gameID, sessionID);
                    }
                    catch (System.Data.Services.Client.DataServiceQueryException dataException)
                    {
                        // Ignore this exception. This exception is probably due to no notifications being found.
                        Logging.TraceVerbose(
                            "{0}: {1} {2} {3} {4} {5} {6}",
                            SessionAzureGarbageCollector.ComponentName,
                            "Ignoring exception which occured while trying to delete Notifications, SessionID: ",
                            sessionID,
                            " GameID: ",
                            gameID.ToString(),
                            " Exception Details: ",
                            dataException.ToString());
                    }
                }
            }
        }

        /// <summary>
        /// Deletes the sessionIndex data for the given parameters.
        /// </summary>
        /// <param name="partitionKey">The partition key for the session index.</param>
        /// <param name="rowKey">The row key for the session index.</param>
        private void DeleteSessionIndex(string partitionKey, string rowKey)
        {
            SessionIndexDataServiceContext sessionIndexContext = new SessionIndexDataServiceContext(this.account);
            sessionIndexContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionIndexContext.ProxyAddress = this.proxyAddress;

            IEnumerable<SessionIndexAzureTableEntity> result = SessionAzureGarbageCollector.GetSessionIndexEntityList(
                sessionIndexContext, partitionKey, rowKey);

            SessionIndexAzureTableEntity indexEntity;
            try
            {
                indexEntity = result.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                OperationResponse response = ex.Response;

                // In case the session index is not present, ignore the exception.
                if (response.StatusCode == (int)HttpStatusCode.NotFound)
                {
                    return;
                }
                else
                {
                    throw;
                }
            }

            if (indexEntity != null)
            {
                sessionIndexContext.DeleteObject(indexEntity);
                sessionIndexContext.SaveChangesWithRetries();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionAzureTableEntity.cs ===
// <copyright file="SessionAzureTableEntity.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionAzureTableEntity class.</summary>
namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Common;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using Common.AzureStorage;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics; 
    using SessionCommon;

    /// <summary>
    /// The wrapper class of Session for using Azure Table Storage.
    /// The concatenation of PartitionKey and RowKey has to be unique.
    /// The natural choice for PartitionKey is the GameID.
    /// RowKey is SessionID.
    /// </summary>
    [DataServiceKey("PartitionKey", "RowKey")]
    public class SessionAzureTableEntity : TableStorageEntity
    {
        /// <summary>
        /// Initializes a new instance of the SessionAzureTableEntity class.
        /// </summary>
        public SessionAzureTableEntity()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SessionAzureTableEntity class based on a SessionState.
        /// </summary>
        /// <param name="sessionState">The Session State object. </param>
        public SessionAzureTableEntity(SessionState sessionState)
        {
            this.PartitionKey = ((int)sessionState.GameID).ToString();
            this.RowKey = sessionState.SessionID;

            // Need to find a better way to do this.
            this.GameID = (int)sessionState.GameID;
            this.Variant = sessionState.Variant;
            this.SessionID = sessionState.SessionID;
            this.DisplayName = sessionState.DisplayName;
            this.SeatsAvailable = sessionState.SeatsAvailable;
            this.OwnerSeatIndex = sessionState.OwnerSeatIndex;
            this.SessionParameters = sessionState.SessionParameters;
            this.CreationTime = sessionState.CreationTime;

            // Flattening InactivityWarningAction into the Azure Entity Columns
            this.InactivityWarningAction = (int)sessionState.InactivityWarning.Action;
            this.Interval = sessionState.InactivityWarning.Interval;
            this.MaxNumberOfNudges = sessionState.InactivityWarning.MaxNumberOfNudges;
            this.NumberOfNudgesSent = sessionState.NumberOfNudgesSent;
           
            this.IsInactivityWarningSent = sessionState.IsInactivityWarningSent;
            this.InactivityWarningSentTime = new DateTime(2001, 1, 1); // Cannot use DateTime.MinValue, because Azure supports dates from January 1, 1601 A.D. (C.E.), UTC
            this.IsClosed = sessionState.IsClosed;
            this.CanRemoveEmptySeats = sessionState.CanRemoveEmptySeats;

            // Binary Serialize SeatInfo array into a blob
            MemoryStream memStream = new MemoryStream(); // Expandable memory stream.
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                formatter.Serialize(memStream, sessionState.Seats);
                byte[] streamBuffer = memStream.ToArray();
                byte[] buffer = new byte[streamBuffer.Length];
                Array.Copy(streamBuffer, buffer, buffer.Length);
                this.SeatsInfos = buffer;
            }
            catch (SerializationException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UnableToSerializeSeatInfo,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionState.SessionID,
                    sessionState.GameID.ToString());
            }
            finally
            {
                memStream.Close();
            }
            
            // Flattening GameState into the Azure Entity Columns
            this.IsComplete = sessionState.State.IsComplete;
            this.LastModified = sessionState.State.LastModified;
            this.SequenceNumber = sessionState.State.SequenceNumber;
            this.ActiveSeatIndex = sessionState.State.ActiveSeatIndex;

            this.WasActiveSeatUserNudged = sessionState.WasActiveSeatUserNudged;
            this.LeavePolicy = (int)sessionState.LeavePolicy;

            // Since this method is used only on session creation, we can assume that Seats[0] has the creator
            this.SessionCreatorIdentity = sessionState.Seats[0].Profile.ToString();
        }

        /// <summary>
        /// Gets or sets the name of this component.
        /// </summary>
        /// <value>The name of this component.</value>
        public string ComponentName
        {
            get { return "SessionAzureTableEntity"; }
            set { }
        }

        /// <summary>
        /// Gets or sets the GameID.
        /// </summary>
        /// <value>The GameID for the session.</value>
        public int GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the game Variant.
        /// </summary>
        /// <value>The game variant for the session.</value>
        public int Variant
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID.
        /// </summary>
        /// <value>The sessionID for the session.</value>
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayName for the session.
        /// </summary>
        /// <value>The display name for the session.</value>
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SeatsAvailable for the session.
        /// </summary>
        /// <value>The available number of seats for the session.</value>
        public int SeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets this reserved field.
        /// </summary>
        public int ReservedSeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets this reserved field.
        /// </summary>
        public int Category
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the index of the session owner's seat.
        /// </summary>
        /// <value>The index of the session owner's seat.</value>
        public int OwnerSeatIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the session parameters for the session.
        /// </summary>
        /// <value>The session parameters for the session.</value>
        public byte[] SessionParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the creation time for the session.
        /// </summary>
        /// <value>The creation time for the session.</value>
        public DateTime CreationTime
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the InactivityWarningAction for the session.
        /// </summary>
        /// <value>The InactivityWarningAction for the session.</value>
        public int InactivityWarningAction
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the inactivity Interval for the session.
        /// </summary>
        /// <value>The inactivity Interval for the session.</value>
        public int Interval
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether this reserved field is set.
        /// </summary>
        public bool IsWarningSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the MaxNumberOfNudges for the session.
        /// </summary>
        /// <value>The MaxNumberOfNudges for the session.</value>
        public int MaxNumberOfNudges
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the NumberOfNudgesSent  for the session.
        /// </summary>
        /// <value>The NumberOfNudgesSent for the session.</value>
        public int NumberOfNudgesSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether an inactivity warning has been sent for the session.
        /// </summary>
        /// <value>The IsInactivityWarningSent value for the session.</value>
        public bool IsInactivityWarningSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets when an inactivity warning was sent for the session.
        /// </summary>
        /// <value>The InactivityWarningSentTime value for the session.</value>
        public DateTime InactivityWarningSentTime
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether an inactivity warning has been sent for the session.
        /// </summary>
        /// <value>The IsInactivityWarningSent value for the session.</value>
        public bool IsClosed
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the owner can remove seats for the session.
        /// </summary>
        /// <value>The CanRemoveEmptySeats value for the session.</value>
        public bool CanRemoveEmptySeats
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the InvitationURL for the session.
        /// </summary>
        /// <value>The InvitationURL for the session.</value>
        public string InvitationURL
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SeatsInfo array for the session.
        /// </summary>
        /// <value>The SeatsInfo array for the session.</value>
        public byte[] SeatsInfos
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the session is complete.
        /// </summary>
        /// <value>The IsComplete value for the session.</value>
        public bool IsComplete
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModified value for the session.
        /// </summary>
        /// <value>The LastModified value for the session.</value>
        public DateTime LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModified value for the session.
        /// </summary>
        /// <value>The LastModified value for the session.</value>
        public int SequenceNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the ActiveSeatIndex for the session.
        /// </summary>
        /// <value>The ActiveSeatIndex value for the session.</value>
        public int ActiveSeatIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the active seat has been sent a user nudge.
        /// </summary>
        /// <value>A value indicating whether the active seat has been sent a user nudge.</value>
        public bool WasActiveSeatUserNudged
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the session creator's identity.
        /// </summary>
        /// <value>The session creator's identity.</value>
        public string SessionCreatorIdentity
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the session leave policy for the session.
        /// </summary>
        /// <value>The session leave policy for the session.</value>
        public int LeavePolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the session state object that corresponds to the data in this entity object.
        /// This is a helper method to help data transfer from Azure entity to C# object.
        /// </summary>
        /// <returns>SessionState that corresponds to the data in this entity object.</returns>
        public SessionState GetSessionState()
        {
            SessionState sessionState = new SessionState();

            // Need to find a better way to do this.
            sessionState.GameID = (uint)this.GameID;
            sessionState.Variant = this.Variant;
            sessionState.SessionID = this.SessionID;
            sessionState.DisplayName = this.DisplayName;
            sessionState.SeatsAvailable = this.SeatsAvailable;
            sessionState.OwnerSeatIndex = this.OwnerSeatIndex;
            sessionState.SessionParameters = this.SessionParameters;
            sessionState.CreationTime = this.CreationTime;

            // Creating InactivityWarningAction from the Azure Entity Columns
            sessionState.InactivityWarning = new InactivityWarningBehavior();
            sessionState.InactivityWarning.Action = (InactivityWarningAction)this.InactivityWarningAction;
            sessionState.InactivityWarning.Interval = this.Interval;
            sessionState.InactivityWarning.MaxNumberOfNudges = this.MaxNumberOfNudges;
            sessionState.NumberOfNudgesSent = this.NumberOfNudgesSent;

            sessionState.IsInactivityWarningSent = this.IsInactivityWarningSent;
            sessionState.IsClosed = this.IsClosed;
            sessionState.CanRemoveEmptySeats = this.CanRemoveEmptySeats;

            // Binary Deserialize SeatInfo blob into an array
            MemoryStream memStream = new MemoryStream(this.SeatsInfos); // Expandable memory stream.
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                sessionState.Seats = (SeatInfo[])formatter.Deserialize(memStream);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UnableToDeSerializeSeatInfo,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionState.SessionID,
                    sessionState.GameID.ToString());
            }
            finally
            {
                memStream.Close();
            }

            // Creating GameState from the Azure Entity Columns
            sessionState.State = new GameState();
            sessionState.State.IsComplete = this.IsComplete;
            sessionState.State.LastModified = this.LastModified;
            sessionState.State.SequenceNumber = this.SequenceNumber;
            sessionState.State.ActiveSeatIndex = this.ActiveSeatIndex;
            sessionState.State.GameID = (uint)this.GameID;
            sessionState.State.SessionID = this.SessionID;
            sessionState.State.Variant = this.Variant;

            sessionState.WasActiveSeatUserNudged = this.WasActiveSeatUserNudged;
            sessionState.LeavePolicy = (SessionLeavePolicy)this.LeavePolicy;

            return sessionState;
        }

        /// <summary>
        /// Modifies the entity based on the modification data passed in parameters.
        /// </summary>
        /// <param name="modificationData">Modification data.</param>
        public void Modify(ModificationData modificationData)
        {
            this.CanRemoveEmptySeats = modificationData.CanRemoveEmptySeats;
            this.DisplayName = modificationData.DisplayName;
            this.InactivityWarningAction = (int)modificationData.InactivityWarning.Action;
            this.Interval = modificationData.InactivityWarning.Interval;
            this.MaxNumberOfNudges = modificationData.InactivityWarning.MaxNumberOfNudges;
            this.SessionParameters = modificationData.SessionParameters;
            this.SeatsAvailable = modificationData.TotalSeatsAvailable;
        }

        /// <summary>
        /// Modifies the entity based on the ModuleModifiableState data passed in parameter.
        /// </summary>
        /// <param name="modifiableState">Part of the state modifyable by the game logic module.</param>
        public void Modify(ModuleModifiableState modifiableState)
        {
            if (modifiableState.ActiveSeatIndex.HasValue)
            {
                this.ActiveSeatIndex = modifiableState.ActiveSeatIndex.Value;
            }

            if (modifiableState.IsComplete.HasValue)
            {
                this.IsComplete = modifiableState.IsComplete.Value;
            }

            if (modifiableState.IsClosed.HasValue)
            {
                this.IsClosed = modifiableState.IsClosed.Value;
            }

            if (modifiableState.LastModified.HasValue)
            {
                this.LastModified = modifiableState.LastModified.Value;
            }

            if (modifiableState.OwnerSeatIndex.HasValue)
            {
                this.OwnerSeatIndex = modifiableState.OwnerSeatIndex.Value;
            }

            if (modifiableState.SequenceNumber.HasValue)
            {
                this.SequenceNumber = modifiableState.SequenceNumber.Value;
            }

            if (modifiableState.IsInactivityWarningSent.HasValue)
            {
                this.IsInactivityWarningSent = modifiableState.IsInactivityWarningSent.Value;
            }

            if (modifiableState.NumberOfNudgesSent.HasValue)
            {
                this.NumberOfNudgesSent = modifiableState.NumberOfNudgesSent.Value;
            }

            if (modifiableState.WasActiveSeatUserNudged.HasValue)
            {
                this.WasActiveSeatUserNudged = modifiableState.WasActiveSeatUserNudged.Value;
            }
        }

        /// <summary>
        /// Modifies the entity based on the data passed in parameters.
        /// </summary>
        /// <param name="nudgesSentIncremented">Increment the nudges sent.</param>
        public void Modify(bool nudgesSentIncremented)
        {
            if (nudgesSentIncremented)
            {
                this.NumberOfNudgesSent++;
            }

            // Refresh the last modified DateTime, so that another immediate call to the Nudge & Warning manager
            // does not cause progression in the Nudge->Warn->Kick sequence.
            this.LastModified = DateTime.UtcNow;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionCountAzureTableEntity.cs ===
// <copyright file="SessionCountAzureTableEntity.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-07-28</date>
// <summary>Contains the class definition for SessionCountAzureTableEntity class.</summary>
namespace AsyncMultiplayer.SessionAzureStorage
{
    using System.Data.Services.Common;
    using Common.AzureStorage;
    using SessionCommon;

    /// <summary>
    /// The Azure table entity class for user session count.
    /// The concatenation of PartitionKey and RowKey has to be unique.
    /// Both the PartitionKey and the RowKey is the UserID.
    /// </summary>
    [DataServiceKey("PartitionKey", "RowKey")]
    public class SessionCountAzureTableEntity : TableStorageEntity
    {
        /// <summary>
        /// Initializes a new instance of the SessionCountAzureTableEntity class.
        /// </summary>
        public SessionCountAzureTableEntity()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SessionCountAzureTableEntity class based on a SessionState.
        /// </summary>
        /// <param name="sessionState">The Session State object.</param>
        /// <param name="userSessionCount">The number of sessions created by the user.</param>
        public SessionCountAzureTableEntity(SessionState sessionState, int userSessionCount)
        {
            this.PartitionKey = sessionState.Seats[0].Profile.ToString();
            this.RowKey = this.PartitionKey;

            this.UserCreatedSessionCount = userSessionCount;
        }

        /// <summary>
        /// Gets or sets the UserCreatedSessionCount.
        /// </summary>
        /// <value>The number of sessions created by the user.</value>
        public int UserCreatedSessionCount
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionCountDataServiceContext.cs ===
// <copyright file="SessionCountDataServiceContext.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-07-28</date>
// <summary>Contains the class definition for SessionCountDataServiceContext class.</summary>

namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Client;
    using System.Linq;
    using System.Net;
    using AsyncMultiplayer.Common.AzureStorage;

    /// <summary>
    /// DataServiceContext for Azure Table Storage Access. This is a helper class mostly used 
    /// To get SessionCountTable.
    /// </summary>
    public class SessionCountDataServiceContext : TableStorageDataServiceContext
    {
        /// <summary>
        /// The table name used to get the user's session count.
        /// </summary>
        public const string SessionCountTableName = "SessionCountTable";

        /// <summary>
        /// Initializes a new instance of the SessionCountDataServiceContext class based on the accountInfo.
        /// </summary>
        /// <param name="accountInfo">The account information.</param>
        public SessionCountDataServiceContext(StorageAccountInfo accountInfo)
            : base(accountInfo)
        {
            SendingRequest += new EventHandler<SendingRequestEventArgs>(this.SetProxy);
            this.ResolveType = this.ResolveEntityType;
        }

        /// <summary>
        /// Gets or sets the proxy address of the context. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Gets SessionCountTable object list.
        /// </summary>
        /// <value>IQueryable object that allows queries on SessionCountAzureTableEntity.</value>
        public IQueryable<SessionCountAzureTableEntity> SessionCountTable
        {
            get
            {
                return this.CreateQuery<SessionCountAzureTableEntity>(SessionCountTableName);
            }
        }

        /// <summary>
        /// Delegate to return entity type for more efficient handling than default by reflection. 
        /// </summary>
        /// <param name="name">The qualified name of the table. </param>
        /// <returns>The type of an entity in the table.</returns>
        public Type ResolveEntityType(string name)
        {
            return typeof(SessionCountAzureTableEntity);
        }

        /// <summary>
        /// Callback method called whenever a request is sent to the table service. This 
        /// is where the signing of the request takes place. This method is chained with 
        /// whatever is set in base class. 
        /// </summary>
        /// <param name="sender">The sender of the callback method. </param>
        /// <param name="e">The callback args. </param>
        private void SetProxy(object sender, SendingRequestEventArgs e)
        {
            if (!string.IsNullOrEmpty(this.ProxyAddress))
            {
                HttpWebRequest request = e.Request as HttpWebRequest;
                request.Proxy = new WebProxy(this.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionDataServiceContext.cs ===
// <copyright file="SessionDataServiceContext.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionDataServiceContext class.</summary>

namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Client;
    using System.Data.Services.Common;
    using System.Linq;
    using System.Net; 
    using AsyncMultiplayer.Common.AzureStorage;

    /// <summary>
    /// DataServiceContext for Azure Table Storage Access. This is a helper class mostly used 
    /// To get SessionTable.
    /// </summary>
    public class SessionDataServiceContext : TableStorageDataServiceContext
    {
        /// <summary>
        /// The table name used to save the sessions in Azure Table.
        /// </summary>
        public const string SessionTableName = "SessionTable";

        /// <summary>
        /// Initializes a new instance of the SessionDataServiceContext class based on the accountInfo.
        /// </summary>
        /// <param name="accountInfo">The account information.</param>
        public SessionDataServiceContext(StorageAccountInfo accountInfo)
            : base(accountInfo)
        {
            SendingRequest += new EventHandler<SendingRequestEventArgs>(this.SetProxy);
            this.ResolveType = this.ResolveEntityType;
        }

        /// <summary>
        /// Gets or sets the proxy address of the context. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Gets SessionTable object list.
        /// </summary>
        /// <value>IQueryable object that alllows queries on SessionAzureTableEntity.</value>
        public IQueryable<SessionAzureTableEntity> SessionTable
        {
            get
            {
                return this.CreateQuery<SessionAzureTableEntity>(SessionTableName);
            }
        }

        /// <summary>
        /// Delegate to return entity type for more efficient handling than default by reflection. 
        /// </summary>
        /// <param name="name">The qualified name of the table. </param>
        /// <returns>The type of an entity in the table.</returns>
        public Type ResolveEntityType(string name)
        {
            return typeof(SessionAzureTableEntity);
        }

        /// <summary>
        /// Callback method called whenever a request is sent to the table service. This 
        /// is where the signing of the request takes place. This method is chained with 
        /// whatever is set in base class. 
        /// </summary>
        /// <param name="sender">The sender of the callback method. </param>
        /// <param name="e">The callback args. </param>
        private void SetProxy(object sender, SendingRequestEventArgs e)
        {
            if (!string.IsNullOrEmpty(this.ProxyAddress))
            {
                HttpWebRequest request = e.Request as HttpWebRequest;
                request.Proxy = new WebProxy(this.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionEntryAzureTableEntity.cs ===
// <copyright file="SessionEntryAzureTableEntity.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionEntryAzureTableEntity class.</summary>

namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Common;
    using System.IO;
    using System.Net;
    using System.Runtime.Serialization.Formatters.Binary;
    using Common.AzureStorage;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics; 
    using SessionCommon;

    /// <summary>
    /// The wrapper class of SessionEntry for using Azure Table Storage.
    /// The concatenation of PartitionKey and RowKey has to be unique.
    /// The natural choice for PartitionKey is the UserID.
    /// RowKey is GameID+RowKeyDelimiter+SessionID.
    /// </summary>
    [DataServiceKey("PartitionKey", "RowKey")]
    public class SessionEntryAzureTableEntity : TableStorageEntity
    {
        /// <summary>
        /// The delimiter separating the constituents of the row key.
        /// </summary>
        public const string RowKeyDelimiter = "|";

        /// <summary>
        /// Initializes a new instance of the SessionEntryAzureTableEntity class based on a SessionEntry object.
        /// </summary>
        /// <param name="sessionEntry">The Session Entry object.</param>
        /// <param name="userID">The userID for this session entry.</param>
        public SessionEntryAzureTableEntity(SessionEntry sessionEntry, string userID)
        {
            this.PartitionKey = userID;
            this.RowKey = ((int)sessionEntry.GameID) + RowKeyDelimiter + sessionEntry.SessionID;

            // Fill in the rest of the attributes.
            this.DisplayName = sessionEntry.DisplayName;
            this.GameID = (int)sessionEntry.GameID;
            this.LastModified = sessionEntry.LastModified;
            this.SessionID = sessionEntry.SessionID;
            this.SessionParameters = sessionEntry.SessionParameters;
            this.CreationDate = sessionEntry.CreationDate;
            this.LastModifiedBy = SessionEntryAzureTableEntity.SerializeSeatInfo(sessionEntry.LastModifiedBy);
            this.IsComplete = sessionEntry.IsComplete;
            this.Variant = sessionEntry.Variant;
        }

        /// <summary>
        /// Initializes a new instance of the SessionEntryAzureTableEntity class.
        /// </summary>
        public SessionEntryAzureTableEntity()
        {
        }

        /// <summary>
        /// Gets or sets the DisplayName for the session entry entity.
        /// </summary>
        /// <value>The DisplayName for the session entry entity.</value>
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the GameID for the session entry entity.
        /// </summary>
        /// <value>The GameID for the session entry entity.</value>
        public int GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModified DateTime for the session entry entity.
        /// </summary>
        /// <value>The LastModified value for the session entry entity.</value>
        public DateTime LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID for the session entry entity.
        /// </summary>
        /// <value>The SessionID value for the session entry entity.</value>
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionParameters for the session entry entity.
        /// </summary>
        /// <value>The SessionParameters value for the session entry entity.</value>
        public byte[] SessionParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the CreationDate for the session entry entity.
        /// </summary>
        /// <value>The CreationDate for the session entry entity.</value>
        public DateTime CreationDate
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModifiedBy information for the session entry entity.
        ///  This is the serialized SeatInfo of the player who last modified the session.
        /// </summary>
        /// <value>The LastModifiedBy information for the session entry entity.</value>
        public byte[] LastModifiedBy
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the session is complete.
        /// </summary>
        /// <value>A value indicationg whether the session is complete.</value>
        public bool IsComplete
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the game Variant for the session entry entity.
        /// </summary>
        /// <value>The game Variant value for the session entry entity.</value>
        public int Variant
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the SessionEntry corresponding to the this entity object.
        /// </summary>
        /// <returns>The SessionEntry corresponding to the this entity object.</returns>
        public SessionEntry GetSessionEntry()
        {
            SessionEntry sessionEntry = new SessionEntry();

            // Fill in the rest of the attributes.
            sessionEntry.DisplayName = this.DisplayName;
            sessionEntry.GameID = (uint)this.GameID;
            sessionEntry.LastModified = this.LastModified;
            sessionEntry.SessionID = this.SessionID;
            sessionEntry.SessionParameters = this.SessionParameters;
            sessionEntry.CreationDate = this.CreationDate;

            // Binary Deserialize SeatInfo blob into an object
            MemoryStream memStream = new MemoryStream(this.LastModifiedBy);
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                sessionEntry.LastModifiedBy = (SeatInfo)formatter.Deserialize(memStream);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UnableToDeSerializeSeatInfoObject,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    this.SessionID,
                    this.GameID.ToString());
            }
            finally
            {
                memStream.Close();
            }

            sessionEntry.IsComplete = this.IsComplete;
            sessionEntry.Variant = this.Variant;

            return sessionEntry;
        }

        /// <summary>
        /// Modifies this entity object based on the passed in modification data.
        /// </summary>
        /// <param name="modificationData">Modification data.</param>
        /// <param name="modifiedBySeat">Seat that modified the session information.</param>
        public void Modify(ModificationData modificationData, SeatInfo modifiedBySeat)
        {
            this.DisplayName = modificationData.DisplayName;
            this.SessionParameters = modificationData.SessionParameters;
            this.LastModifiedBy = SessionEntryAzureTableEntity.SerializeSeatInfo(modifiedBySeat);
            this.LastModified = DateTime.UtcNow;
        }

        /// <summary>
        /// Modifies the completion status of the session entry.
        /// </summary>
        /// <param name="isComplete">The completion status of the session entry.</param>
        /// <param name="modifiedBySeat">Seat that modified the session information</param>
        public void Modify(bool isComplete, SeatInfo modifiedBySeat)
        {
            this.IsComplete = isComplete;
            this.LastModifiedBy = SessionEntryAzureTableEntity.SerializeSeatInfo(modifiedBySeat);
            this.LastModified = DateTime.UtcNow;
        }

        /// <summary>
        /// Modifies the last modified by seat and time for the session entry.
        /// </summary>
        /// <param name="modifiedBySeat">Seat that modified the session information</param>
        public void Modify(SeatInfo modifiedBySeat)
        {
            this.LastModifiedBy = SessionEntryAzureTableEntity.SerializeSeatInfo(modifiedBySeat);
            this.LastModified = DateTime.UtcNow;
        }

        /// <summary>
        /// Modifies the last modified time for the session entry.
        /// </summary>
        public void Modify()
        {
            this.LastModified = DateTime.UtcNow;
        }

        /// <summary>
        /// Serializes a SeatInfo object.
        /// </summary>
        /// <param name="seatInfo">The SeatInfo object to be serialized.</param>
        /// <returns>SeatInfo object in serialized form.</returns>
        private static byte[] SerializeSeatInfo(SeatInfo seatInfo)
        {
            MemoryStream memStream = new MemoryStream(); // Expandable memory stream.
            BinaryFormatter formatter = new BinaryFormatter();
            byte[] result;
            try
            {
                formatter.Serialize(memStream, seatInfo);
                byte[] streamBuffer = memStream.ToArray();
                byte[] buffer = new byte[streamBuffer.Length];
                Array.Copy(streamBuffer, buffer, buffer.Length);
                result = buffer;
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileSerializingSeatInfoObject,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true);
            }
            finally
            {
                memStream.Close();
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionAzureStorage.cs ===
// <copyright file="SessionAzureStorage.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for GameAction class.</summary>
namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Data.Services.Client;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using Common.AzureStorage;
    using Leet.Core.Diagnostics;
    using Leet.Core.Platforms;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using SessionCommon;

    /// <summary>
    /// This class implements the ISessionStorage with an Azure backend.
    /// </summary>
    public class SessionAzureStorage : ISessionStorage
    {
        /// <summary>
        /// Maximum number of session entries to retrieve by default.
        /// </summary>
        private const int DefaultMaxSessionsSummariesRetrieved = 20;

        /// <summary>
        /// Initializes a new instance of the SessionAzureStorage class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        public SessionAzureStorage(StorageAccountInfo account)
        {
            this.Account = account;
        }

        /// <summary>
        /// Initializes a new instance of the SessionAzureStorage class.
        /// </summary>
        /// <param name="account">The account used for accessing the azure storage. </param>
        /// <param name="proxyAddress">The proxy setting for the environment. </param>
        public SessionAzureStorage(StorageAccountInfo account, string proxyAddress)
            : this(account)
        {
            this.ProxyAddress = proxyAddress;
        }

        /// <summary>
        /// Gets or sets the proxy setting of the environment. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Gets or sets the storage account information.
        /// </summary>
        /// <value>The account value itself.</value>
        public StorageAccountInfo Account { get; set; }

        /// <summary>
        /// Gets the Maximum number of times an update will be retried in case of a Etag mismatch error.
        /// </summary>
        /// <value>Maximum number of times an update will be retried in case of a Etag mismatch error.</value>
        protected static int MaxUpdateRetryCount
        {
            get { return 3; }
        }

        /// <summary>
        /// Gets the session count entity for the user.
        /// </summary>
        /// <param name="userIdentityToken">The user for which to get the session count entity.</param>
        /// <param name="sessionCountDataSvcContext">The data service context to use.</param>
        /// <returns>The session count entity for the user.</returns>
        public static SessionCountAzureTableEntity GetSessionCountEntityForUser(IdentityToken userIdentityToken, SessionCountDataServiceContext sessionCountDataSvcContext)
        {
            var queryResult = from c in sessionCountDataSvcContext.SessionCountTable
                              where c.PartitionKey == userIdentityToken.ToString() &&
                                c.RowKey == userIdentityToken.ToString()
                              select c;

            TableStorageDataServiceQuery<SessionCountAzureTableEntity> query =
                new TableStorageDataServiceQuery<SessionCountAzureTableEntity>(queryResult as DataServiceQuery<SessionCountAzureTableEntity>, sessionCountDataSvcContext.RetryPolicy);

            try
            {
                IEnumerable<SessionCountAzureTableEntity> results = query.ExecuteWithRetries();
                return results.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                OperationResponse response = ex.Response;
                if (response.StatusCode == (int)HttpStatusCode.NotFound)
                {
                    return null;
                }
                else
                {
                    throw;
                }
            }
        }

        /// <summary>
        /// Initializes the storage for the first time use. 
        /// </summary>
        public void InitializeStorage()
        {
            TableStorage.CreateTablesFromModel(typeof(SessionDataServiceContext), this.Account);
            TableStorage.CreateTablesFromModel(typeof(SessionEntryDataServiceContext), this.Account);
            TableStorage.CreateTablesFromModel(typeof(SessionIndexDataServiceContext), this.Account);
            TableStorage.CreateTablesFromModel(typeof(SessionCountDataServiceContext), this.Account);
        }

        /// <summary>
        /// Add a session to the Azure storage backend.
        /// </summary>
        /// <param name="sessionState">The state of the session to be added.</param>
        /// <param name="maxCreateSessionsAllowedPerUser">Maximum sessions aloowed to be created by a user.</param>
        public void AddSession(SessionState sessionState, int maxCreateSessionsAllowedPerUser)
        {
            // First check if the user has hit the maximum number of sessions allowed to be created.
            SessionCountDataServiceContext sessionCountContext = new SessionCountDataServiceContext(this.Account);
            sessionCountContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionCountContext.ProxyAddress = this.ProxyAddress;
            SessionCountAzureTableEntity sessionCountEntity = SessionAzureStorage.GetSessionCountEntityForUser(sessionState.Seats[0].Profile, sessionCountContext);
            bool insertSessionCount = false;
            if (sessionCountEntity == null)
            {
                sessionCountEntity = new SessionCountAzureTableEntity(sessionState, 0);
                insertSessionCount = true;
            }

            if (sessionCountEntity.UserCreatedSessionCount >= maxCreateSessionsAllowedPerUser)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.TooManySessionsCreatedByTheUser,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionCountEntity.UserCreatedSessionCount.ToString(),
                    maxCreateSessionsAllowedPerUser.ToString());
            }

            // Then add index of the session to the session index table.
            SessionIndexAzureTableEntity sessionIndexEntity = new SessionIndexAzureTableEntity(sessionState);
            SessionIndexDataServiceContext sessionIndexContext = new SessionIndexDataServiceContext(this.Account);
            sessionIndexContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionIndexContext.ProxyAddress = this.ProxyAddress;

            sessionIndexContext.AddObject(SessionIndexDataServiceContext.SessionIndexTableName, sessionIndexEntity);
            sessionIndexContext.SaveChangesWithRetries();

            // Next save the SessionTable entity
            SessionAzureTableEntity sessionEntity = new SessionAzureTableEntity(sessionState);
            SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.Account);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = this.ProxyAddress; 

            sessionContext.AddObject(SessionDataServiceContext.SessionTableName, sessionEntity);
            sessionContext.SaveChangesWithRetries();

            // Now create and save the SessionEntity entity
            SessionEntry sessionEntry = new SessionEntry();
            sessionEntry.DisplayName = sessionState.DisplayName;
            sessionEntry.GameID = sessionState.GameID;
            sessionEntry.LastModified = sessionState.CreationTime;
            sessionEntry.LastModifiedBy = sessionState.Seats[0];
            sessionEntry.SessionID = sessionState.SessionID;
            sessionEntry.SessionParameters = sessionState.SessionParameters;
            sessionEntry.Variant = sessionState.Variant;
            sessionEntry.CreationDate = sessionState.CreationTime;

            SessionEntryAzureTableEntity sessionEntryEntity =
                new SessionEntryAzureTableEntity(sessionEntry, sessionState.Seats[0].Profile.ToString());
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.Account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.ProxyAddress;

            sessionEntryContext.AddObject(SessionEntryDataServiceContext.SessionEntryTableName, sessionEntryEntity);
            sessionEntryContext.SaveChangesWithRetries();

            // Increment the session count for the user.
            bool retrySessionTableUpdate;
            int retryCount = 0;
            do
            {
                retrySessionTableUpdate = false;

                sessionCountEntity.UserCreatedSessionCount++;
                if (insertSessionCount)
                {
                    sessionCountContext.AddObject(SessionCountDataServiceContext.SessionCountTableName, sessionCountEntity);
                }
                else
                {
                    sessionCountContext.UpdateObject(sessionCountEntity);
                }

                try
                {
                    sessionCountContext.SaveChangesWithRetries();
                }
                catch (DataServiceRequestException)
                {
                    // Probably another thread has updated the player session count, retry.
                    if (retryCount < MaxUpdateRetryCount)
                    {
                        retryCount++;
                        retrySessionTableUpdate = true;

                        // Refresh the session count entity before retrying.
                        sessionCountContext.Detach(sessionCountEntity);
                        sessionCountEntity = SessionAzureStorage.GetSessionCountEntityForUser(sessionState.Seats[0].Profile, sessionCountContext);
                        insertSessionCount = false;
                        if (sessionCountEntity == null)
                        {
                            sessionCountEntity = new SessionCountAzureTableEntity(sessionState, 0);
                            insertSessionCount = true;
                        }
                    }
                    else
                    {
                        throw;
                    }
                }
            }
            while (retrySessionTableUpdate);
        }

        /// <summary>
        /// Modify a session in the Azure storage.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to be modified.</param>
        /// <param name="gameID">The gameID of the session to be modified.</param>
        /// <param name="modificationData">Data to be used for modification.</param>
        /// <param name="actorIdentity">Identity of the actor(user) trying to modify the session.</param>
        /// <returns>The modified session state.</returns>
        public SessionState ModifySession(
            string sessionID, uint gameID, ModificationData modificationData, IdentityToken actorIdentity)
        {
            SessionState modifiedSessionState = null;
            SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.Account);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = this.ProxyAddress;

            SeatInfo ownerSeat = null;
            SessionAzureTableEntity entity = GetSessionAzureTableEntity(sessionContext, sessionID, gameID);
            SessionAzureStorage.ValidateSessionEntityNotComplete(entity);

            SeatInfo[] seatInfos = null;
            MemoryStream memStream = new MemoryStream(entity.SeatsInfos); // Expandable memory stream.
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                seatInfos = (SeatInfo[])formatter.Deserialize(memStream);
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.DeserializationErrorWhileModifying,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString());
            }
            finally
            {
                memStream.Close();
            }

            List<IdentityToken> userIdentities = new List<IdentityToken>(seatInfos.Length);
            foreach (var seat in seatInfos)
            {
                // Add to the list of user identities in the session.
                userIdentities.Add(seat.Profile);

                if (seat.Index == entity.OwnerSeatIndex)
                {
                    ownerSeat = seat;
                }
            }

            // For error and authorization failure.
            if (ownerSeat == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.NoOwnerFoundCannotModifySession,
                    HttpStatusCode.InternalServerError,
                    null,
                    false,
                    sessionID,
                    gameID.ToString());
            }
            else if (!ownerSeat.Profile.Equals(actorIdentity))
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UserNotAllowedToModifySession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionID,
                    gameID.ToString());
            }

            if (entity.SessionID.Equals(sessionID) && entity.GameID == (int)gameID && ownerSeat.Profile.Equals(actorIdentity))
            {
                entity.Modify(modificationData);
                sessionContext.UpdateObject(entity);
                sessionContext.SaveChangesWithRetries();
                modifiedSessionState = entity.GetSessionState();
            }

            // Now Update the SessionEntry Table
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.Account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.ProxyAddress;

            foreach (var userIdentity in userIdentities)
            {
                IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult =
                    SessionAzureStorage.GetSessionEntryEntityList(sessionEntryContext, userIdentity, sessionID, (int)gameID);

                SessionEntryAzureTableEntity sessionEntryEntity = null;
                try
                {
                    sessionEntryEntity = sessionEntryResult.FirstOrDefault();
                }
                catch (DataServiceQueryException ex)
                {
                    OperationResponse response = ex.Response;
                    if (response.StatusCode != (int)HttpStatusCode.NotFound)
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.ErrorWhileTryingToGetSessionEntriesInModify,
                            HttpStatusCode.InternalServerError,
                            ex,
                            false,
                            sessionID,
                            gameID.ToString());
                    }
                }

                // Ignore any session entries not found.
                if (sessionEntryEntity == null)
                {
                    continue;
                }

                // The owner is the only seat that can modify the session, so use the owner seat as the actor seat.
                sessionEntryEntity.Modify(modificationData, ownerSeat);
                sessionEntryContext.UpdateObject(sessionEntryEntity);
            }

            // Save changes to all session entries.
            sessionEntryContext.SaveChangesWithRetries();

            return modifiedSessionState;
        }

        /// <summary>
        /// Modifies the session in the storage. Meant to be used by the game logic module.
        /// </summary>
        /// <param name="storageObject">An opaque session storage object for the session to be modified.</param>
        /// <param name="modifiableState">The modifiable portion of the state.</param>
        /// <param name="actorIdentity">The actor who is modifying the session.</param>
        /// <returns>The modified session state.</returns>
        public SessionState ModifySession(OpaqueSessionStorageObject storageObject, ModuleModifiableState modifiableState, IdentityToken actorIdentity)
        {
            SessionState newSessionState = null;
            AzureSessionStorageObject azureStorageObject = null;
            try
            {
                azureStorageObject = (AzureSessionStorageObject)storageObject.Object;
            }
            catch (InvalidCastException ex)
            {
                throw new LIVEnException(
                SessionServiceEvents.Events,
                SessionServiceEvents.StorageObjectPassedForModifyIsInvalid,
                HttpStatusCode.InternalServerError,
                ex,
                true);
            }

            SessionAzureTableEntity sessionEntity = azureStorageObject.SessionTableEntity;
            SessionDataServiceContext sessionContext = azureStorageObject.SessionDataContext;
            DateTime originalModificationTime = sessionEntity.LastModified;

            if (sessionEntity.SessionID.Equals(storageObject.SessionID) && sessionEntity.GameID == (int)storageObject.GameID)
            {
                sessionEntity.Modify(modifiableState);
                newSessionState = sessionEntity.GetSessionState();
                sessionContext.UpdateObject(sessionEntity);
                sessionContext.SaveChangesWithRetries();
            }
            else
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.SessionToBeModifiedNotFound,
                    HttpStatusCode.InternalServerError,
                    null,
                    false,
                    sessionEntity.SessionID,
                    sessionEntity.GameID.ToString());
            }

            // Update SessionEntries for this session
            SeatInfo seatWhichIsUpdating = null;
            foreach (var seat in newSessionState.Seats)
            {
                if (seat.Profile.Equals(actorIdentity))
                {
                    seatWhichIsUpdating = seat;
                    break;
                }
            }

            if (seatWhichIsUpdating == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.CannotFindTheActorInTheSessionWhileModifying,
                    HttpStatusCode.InternalServerError,
                    null,
                    true,
                    newSessionState.SessionID,
                    newSessionState.GameID.ToString());
            }

            // Update the SessionEntry & SessionIndex table if lastModified has some value (i.e. which should happen if the GameState has changed)
            if (modifiableState.LastModified.HasValue)
            {
                this.UpdateSessionEntries(newSessionState, seatWhichIsUpdating);
                this.UpdateSessionIndex(newSessionState, originalModificationTime);
            }

            return newSessionState;
        }

        /// <summary>
        /// Modifies the session in the storage.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to be modified.</param>
        /// <param name="gameID">The gameID of the session to be modified.</param>
        /// <param name="nudgesSentIncremented">Were nudges incremented?</param>
        public void ModifySession(string sessionID, uint gameID, bool nudgesSentIncremented)
        {
            SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.Account);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = this.ProxyAddress;
            SessionAzureTableEntity entity = GetSessionAzureTableEntity(sessionContext, sessionID, gameID);

            DateTime originalModificationTime = entity.LastModified;
            if (entity.SessionID.Equals(sessionID) && entity.GameID == (int)gameID)
            {
                entity.Modify(nudgesSentIncremented);
                sessionContext.UpdateObject(entity);
                sessionContext.SaveChangesWithRetries();
            }

            SessionState newSessionState = entity.GetSessionState();
            this.UpdateSessionEntries(newSessionState, null);
            this.UpdateSessionIndex(newSessionState, originalModificationTime);
        }

        /// <summary>
        /// Modify the seats info array for a session.
        /// </summary>
        /// <param name="storageObject">An opaque session storage object for the session to be modified.</param>
        /// <param name="seats">The seats info array to be updated.</param>
        public void ModifySession(OpaqueSessionStorageObject storageObject, SeatInfo[] seats)
        {
            AzureSessionStorageObject azureStorageObject;
            try
            {
                azureStorageObject = (AzureSessionStorageObject)storageObject.Object;
            }
            catch (InvalidCastException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.StorageObjectPassedForModifyIsInvalid,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true);
            }

            // Binary Serialize SeatInfo array into a blob
            MemoryStream memStream = new MemoryStream(); // Expandable memory stream.
            BinaryFormatter formatter = new BinaryFormatter();
            try
            {
                formatter.Serialize(memStream, seats);
                byte[] streamBuffer = memStream.ToArray();
                byte[] buffer = new byte[streamBuffer.Length];
                Array.Copy(streamBuffer, buffer, buffer.Length);
                azureStorageObject.SessionTableEntity.SeatsInfos = buffer;
            }
            catch (SerializationException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.UnableToSerializeSeatInfo,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    azureStorageObject.SessionTableEntity.SessionID,
                    azureStorageObject.SessionTableEntity.GameID.ToString());
            }
            finally
            {
                memStream.Close();
            }

            azureStorageObject.SessionDataContext.UpdateObject(azureStorageObject.SessionTableEntity);
            azureStorageObject.SessionDataContext.SaveChangesWithRetries();
        }

        /// <summary>
        /// Query a session in Azure storage based on the sessionID.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session being queried.</param>
        /// <param name="gameID">The gameID of the session being queried.</param>
        /// <param name="storageObject">Out paramter, this is an opaque object to be used by ModifySession.</param>
        /// <returns>The session state.</returns>
        public SessionState QuerySession(string sessionID, uint gameID, out OpaqueSessionStorageObject storageObject)
        {
            SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.Account);
            sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionContext.ProxyAddress = this.ProxyAddress;
            SessionAzureTableEntity sessionEntity = GetSessionAzureTableEntity(sessionContext, sessionID, gameID);

            SessionState sessionState = sessionEntity.GetSessionState();
            storageObject = new OpaqueSessionStorageObject();
            storageObject.SessionID = sessionID;
            storageObject.GameID = gameID;
            AzureSessionStorageObject azureStorageObject = new AzureSessionStorageObject();
            azureStorageObject.SessionTableEntity = sessionEntity;
            azureStorageObject.SessionDataContext = sessionContext;
            storageObject.Object = azureStorageObject;

            return sessionState;
        }

        /// <summary>
        /// Gets the summary of all the sessions that a user is participating in.
        /// </summary>
        /// <param name="actorIdentity">Identity of the actor(user) for which to get the session summary.</param>
        /// /// <param name="queryParameters">Query parameters for the method, used to filter the results.</param>
        /// <returns>Array of session entries.</returns>
        public SessionEntry[] QuerySessions(IdentityToken actorIdentity, SessionQueryParameters queryParameters)
        {
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.Account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.ProxyAddress;

            IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = null;
            try
            {
                sessionEntryResult = SessionAzureStorage.GetSessionEntryEntityList(
                                        sessionEntryContext, actorIdentity.ToString(), queryParameters);
            }
            catch (ArgumentException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.ErrorWhileTryingToQuerySessions,
                    HttpStatusCode.Forbidden,
                    ex,
                    true,
                    actorIdentity.ToString());
            }

            int sessionEntriesRetrieved = 0;
            List<SessionEntry> sessionEntryList = new List<SessionEntry>();
            foreach (SessionEntryAzureTableEntity entity in sessionEntryResult)
            {
                sessionEntryList.Add(entity.GetSessionEntry());
                sessionEntriesRetrieved++;

                if (queryParameters.MaxSessions.HasValue)
                {
                    if (sessionEntriesRetrieved == queryParameters.MaxSessions)
                    {
                        break;
                    }
                }
                else
                {
                    if (sessionEntriesRetrieved == SessionAzureStorage.DefaultMaxSessionsSummariesRetrieved)
                    {
                        break;
                    }
                }
            }

            return sessionEntryList.ToArray();
        }

        /// <summary>
        /// Add a player to a session in the Azure storage backend.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to which the player is to be added.</param>
        /// <param name="joinData">Data required for joining a session.</param>
        /// <param name="actorIdentity">Identity of the actor(user) to be added to the session.</param>
        /// <param name="locale">The locale of the actor.</param>
        /// <param name="platformType">The platform type for the actor's client.</param>
        /// <returns>The session state of the session.</returns>
        public SessionState AddPlayer(string sessionID, JoinData joinData, IdentityToken actorIdentity, string locale, PlatformType platformType)
        {
            // Retry the update of the SessionTable entity in case it is dirtied
            // before we get a chance to write it.
            bool retrySessionTableUpdate;
            int retryCount = 0;
            SessionState sessionState;
            SeatInfo newSeat = null;
            do
            {
                // By default,  we do not retry
                retrySessionTableUpdate = false;

                SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.Account);
                sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
                sessionContext.ProxyAddress = this.ProxyAddress;

                SessionAzureTableEntity sessionEntity = GetSessionAzureTableEntity(sessionContext, sessionID, joinData.GameID);
                SessionAzureStorage.ValidateSessionEntityNotComplete(sessionEntity);

                SeatInfo[] seatInfos = sessionEntity.GetSessionState().Seats;

                // Generate the new SeatInfo array.
                List<SeatInfo> seatInfoList = new List<SeatInfo>(seatInfos);

                int numTotalSeats = sessionEntity.SeatsAvailable + seatInfos.Length;
                if (joinData.SeatIndex >= numTotalSeats)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.InvalidSeatIndex,
                        HttpStatusCode.Forbidden,
                        null,
                        false,
                        sessionID,
                        joinData.GameID.ToString());
                }

                bool[] isSeatOccupiedArray = new bool[numTotalSeats];
                bool playerAlreadyInSession = false;
                foreach (var seat in seatInfoList)
                {
                    // Check if there is anyone sitting on the seat requested.
                    if (joinData.SeatIndex != 0 && seat.Index == joinData.SeatIndex && !seat.Profile.Equals(actorIdentity))
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.SeatAlreadyTaken,
                            HttpStatusCode.Forbidden,
                            null,
                            false,
                            sessionID,
                            joinData.GameID.ToString());
                    }

                    // Player is already in the session.
                    if (seat.Profile.Equals(actorIdentity))
                    {
                        playerAlreadyInSession = true;
                        newSeat = seat;
                        break;
                    }

                    try
                    {
                        isSeatOccupiedArray[seat.Index] = true;
                    }
                    catch (IndexOutOfRangeException ex)
                    {
                        string message = "There is a seat with seat index:" + seat.Index +
                                         " which is greater than number of total seats: " + numTotalSeats +
                                         " in a session with SessionID: " + sessionID +
                                         " and gameID: " + joinData.GameID;
                        throw new IndexOutOfRangeException(message, ex);
                    }
                }

                // If the player has already joined the session, do not modify the session entity.
                if (playerAlreadyInSession)
                {
                    sessionState = sessionEntity.GetSessionState();
                    break;
                }

                if (sessionEntity.SeatsAvailable == 0)
                {
                    throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.NoMoreSeatsInSession,
                        HttpStatusCode.Forbidden,
                        null,
                        false,
                        sessionID,
                        joinData.GameID.ToString());
                }

                newSeat = new SeatInfo();
                newSeat.Profile = actorIdentity;
                newSeat.IsAI = false;
                newSeat.Index = (joinData.SeatIndex != 0) ? joinData.SeatIndex : GetFirstEmptySeatIndex(isSeatOccupiedArray);
                newSeat.Locale = locale;
                newSeat.PlatformType = platformType;
                seatInfoList.Add(newSeat);

                SeatInfo[] newSeatInfos = seatInfoList.ToArray();

                if (sessionEntity.SessionID.Equals(sessionID))
                {
                    sessionEntity.SeatsAvailable--;

                    try
                    {
                        // Binary Serialize new SeatInfo array into a blob
                        sessionEntity.SeatsInfos = SessionAzureStorage.SerializeSeatInfoArray(newSeatInfos);
                    }
                    catch (SerializationException ex)
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.ErrorWhileSerializingSeatInfo,
                            HttpStatusCode.InternalServerError,
                            ex,
                            true,
                            sessionID,
                            joinData.GameID.ToString());
                    }

                    // Make this player the owner if there is no one else in the session.
                    if (newSeatInfos.Length == 1)
                    {
                        sessionEntity.OwnerSeatIndex = newSeat.Index;
                    }

                    sessionContext.UpdateObject(sessionEntity);
                    try
                    {
                        sessionContext.SaveChangesWithRetries();
                    }
                    catch (DataServiceRequestException dataServiceException)
                    {
                        // Probably another player joined, causing the sessionEntity to be out of date.
                        // We shall retry the get entity & update entity operations.
                        if (retryCount < SessionAzureStorage.MaxUpdateRetryCount)
                        {
                            retryCount++;
                            retrySessionTableUpdate = true;
                        }
                        else
                        {
                            throw new LIVEnException(
                                SessionServiceEvents.Events,
                                SessionServiceEvents.ErrorWhileTryingToAddPlayerInAzure,
                                HttpStatusCode.InternalServerError,
                                dataServiceException,
                                true,
                                sessionID,
                                joinData.GameID.ToString());
                        }
                    }
                }

                sessionState = sessionEntity.GetSessionState();
            }
            while (retrySessionTableUpdate);

            // Now create and save the SessionEntity entity
            SessionEntry sessionEntry = new SessionEntry();
            sessionEntry.DisplayName = sessionState.DisplayName;
            sessionEntry.GameID = sessionState.GameID;
            sessionEntry.LastModified = DateTime.UtcNow;
            sessionEntry.LastModifiedBy = newSeat;
            sessionEntry.SessionID = sessionState.SessionID;
            sessionEntry.SessionParameters = sessionState.SessionParameters;
            sessionEntry.Variant = sessionState.Variant;
            sessionEntry.CreationDate = sessionState.CreationTime;

            SessionEntryAzureTableEntity sessionEntryEntity = new SessionEntryAzureTableEntity(sessionEntry, actorIdentity.ToString());
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.Account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.ProxyAddress;

            sessionEntryContext.AddObject(SessionEntryDataServiceContext.SessionEntryTableName, sessionEntryEntity);
            try
            {
                sessionEntryContext.SaveChangesWithRetries();
            }
            catch (DataServiceRequestException ex)
            {
                // In case the entity exists, ignore the exception
                OperationResponse response = ex.Response.FirstOrDefault();
                if (response.StatusCode != (int)HttpStatusCode.Conflict)
                {
                    throw;
                }
            }

            return sessionState;
        }

        /// <summary>
        /// Remove the player from the session in Azure storage backend.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session from which the player is to be removed.</param>
        /// <param name="gameID">The gameID of the session from which the player is to be removed.</param>
        /// <param name="actorIdentity">Identity of the actor(user) to be removed from the session.</param>
        /// <param name="leavingPlayerSeat">The seat of the leaving player.</param>
        /// <param name="ownerLeft">Did the owner leave?</param>
        /// <returns>The new state of the session.</returns>
        public SessionState RemovePlayer(string sessionID, uint gameID, IdentityToken actorIdentity, out SeatInfo leavingPlayerSeat, out bool ownerLeft)
        {
            SessionState newSessionState = null;

            // Retry the update of the SessionTable entity in case it is dirtied
            // before we get a chance to write it.
            bool retrySessionTableUpdate;
            int retryCount = 0;
            bool actorFound = false;
            do
            {
                // By default,  we do not retry
                retrySessionTableUpdate = false;

                SessionDataServiceContext sessionContext = new SessionDataServiceContext(this.Account);
                sessionContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
                sessionContext.ProxyAddress = this.ProxyAddress;
                SessionAzureTableEntity sessionEntity = GetSessionAzureTableEntity(sessionContext, sessionID, gameID);

                SeatInfo[] seatInfos = sessionEntity.GetSessionState().Seats;
                SeatInfo[] newSeatInfos = null;

                // Create the new SeatInfo array.
                List<SeatInfo> seatInfoList = new List<SeatInfo>(seatInfos);

                // Remove the actor from the session.
                leavingPlayerSeat = null;
                ownerLeft = false;
                foreach (var seat in seatInfoList)
                {
                    if (seat.Profile.Equals(actorIdentity))
                    {
                        actorFound = true;
                        seatInfoList.Remove(seat);
                        leavingPlayerSeat = seat;

                        // Session owner left.
                        if (seat.Index == sessionEntity.OwnerSeatIndex)
                        {
                            ownerLeft = true;
                        }

                        break;
                    }
                }

                // The actor was not found, no need to update the session entity.
                if (actorFound == false)
                {
                    newSessionState = sessionEntity.GetSessionState();
                    continue;
                }

                newSeatInfos = seatInfoList.ToArray();

                if (sessionEntity.SessionID.Equals(sessionID) && sessionEntity.GameID == (int)gameID)
                {
                    sessionEntity.SeatsAvailable++;

                    try
                    {
                        // Binary Serialize new SeatInfo array into a blob
                        sessionEntity.SeatsInfos = SessionAzureStorage.SerializeSeatInfoArray(newSeatInfos);
                    }
                    catch (SerializationException ex)
                    {
                        throw new LIVEnException(
                            SessionServiceEvents.Events,
                            SessionServiceEvents.ErrorWhileSerializingSeatInfoWhileRemove,
                            HttpStatusCode.InternalServerError,
                            ex,
                            true,
                            sessionID,
                            gameID.ToString());
                    }

                    sessionContext.UpdateObject(sessionEntity);
                    newSessionState = sessionEntity.GetSessionState();

                    try
                    {
                        sessionContext.SaveChangesWithRetries();
                    }
                    catch (DataServiceRequestException dataServiceException)
                    {
                        // Probably another player joined/left, causing the sessionEntity to be out of date.
                        // We shall retry the get entity & update entity operations.
                        if (retryCount < SessionAzureStorage.MaxUpdateRetryCount)
                        {
                            retryCount++;
                            retrySessionTableUpdate = true;
                        }
                        else
                        {
                            throw new LIVEnException(
                                SessionServiceEvents.Events,
                                SessionServiceEvents.AzureErrorWhileRemovingPlayer,
                                HttpStatusCode.InternalServerError,
                                dataServiceException,
                                true,
                                sessionID,
                                gameID.ToString());
                        }
                    }
                }
            }
            while (retrySessionTableUpdate);

            if (newSessionState == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.NewSessionStateNotFoundWhileRemovingPlayer,
                    HttpStatusCode.InternalServerError,
                    null,
                    true,
                    sessionID,
                    gameID.ToString());
            }

            // Now delete from the SessionEntry Table
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.Account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.ProxyAddress; 

            IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = null;
            try
            {
                sessionEntryResult =
                    SessionAzureStorage.GetSessionEntryEntityList(
                    sessionEntryContext, actorIdentity.ToString(), sessionID, (int)gameID);
            }
            catch (ArgumentException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.AzureErrorWhileDeletingSessionEntry,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionID,
                    gameID.ToString());
            }

            SessionEntryAzureTableEntity entity = null;
            try
            {
                entity = sessionEntryResult.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                // In case the entity is not found, ignore the exception
                OperationResponse response = ex.Response;
                if (response.StatusCode != (int)HttpStatusCode.NotFound)
                {
                    throw;
                }
            }
            
            if (entity != null)
            {
                sessionEntryContext.DeleteObject(entity);
                sessionEntryContext.SaveChangesWithRetries();
            }
            else if (!actorFound)
            {
                // No session entity or session entry entity was found for the user, so throw!
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.PlayerIsNotInSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionID,
                    gameID.ToString());
            }

            return newSessionState;
        }

        /// <summary>
        /// Gets a list of session index Azure Table entities based on a sessionID/GameID and last modified time.
        /// The length of the list should be exactly 1.
        /// </summary>
        /// <param name="sessionIndexContext">The data service context for the query.</param>
        /// <param name="sessionID">SessionID for which to get the session index entities.</param>
        /// <param name="gameID">GameID for which to get the session index entities.</param>
        /// <param name="lastModified">The last modified date of the session index.</param>
        /// <returns>List of session index Azure Table entities based on the parameters.</returns>
        internal static IEnumerable<SessionIndexAzureTableEntity> GetSessionIndexEntityList(
            SessionIndexDataServiceContext sessionIndexContext, string sessionID, int gameID, DateTime lastModified)
        {
            var query = from c in sessionIndexContext.SessionIndexTable
                        where c.PartitionKey.Equals(lastModified.ToString(SessionIndexAzureTableEntity.GetPartitionKeyFormat())) &&
                        c.RowKey.Equals(SessionIndexAzureTableEntity.GetRowKey(lastModified, (uint)gameID, sessionID))
                        select c;

            TableStorageDataServiceQuery<SessionIndexAzureTableEntity> sessionIndexQuery =
                new TableStorageDataServiceQuery<SessionIndexAzureTableEntity>(
                    query as DataServiceQuery<SessionIndexAzureTableEntity>,
                    sessionIndexContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionIndexAzureTableEntity> res = sessionIndexQuery.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// Gets a list of session Azure Table entities based on a sessionID.
        /// </summary>
        /// <param name="sessionContext">The data service context for the query.</param>
        /// <param name="sessionID">SessionID for which to get the session entities.</param>
        /// <param name="gameID">GameID for which to get the session entities.</param>
        /// <returns>List of session Azure Table entities based on a sessionID.</returns>
        internal static IEnumerable<SessionAzureTableEntity> GetSessionEntityList(
            SessionDataServiceContext sessionContext, string sessionID, int gameID)
        {
            var query = from c in sessionContext.SessionTable
                        where c.PartitionKey.Equals(gameID.ToString()) &&
                        c.RowKey.Equals(sessionID)
                        select c;

            TableStorageDataServiceQuery<SessionAzureTableEntity> sessionQuery =
                new TableStorageDataServiceQuery<SessionAzureTableEntity>(
                    query as DataServiceQuery<SessionAzureTableEntity>,
                    sessionContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionAzureTableEntity> res = sessionQuery.ExecuteAllWithRetries();
            return res;
        }

        /// <summary>
        /// Gets a list of session entry Azure Table entities based on a userID, sessionID and gameID.
        /// </summary>
        /// <param name="sessionEntryContext">The data service context for the query.</param>
        /// <param name="userID">UserID for which to get the session entry entities.</param>
        /// <param name="sessionID">SessionID for which to get the session entry entities.</param>
        /// <param name="gameID">GameID for which to get the session entry entities.</param>
        /// <returns>List of session entry Azure Table entities based on a userID, sessionID and gameID.</returns>
        internal static IEnumerable<SessionEntryAzureTableEntity> GetSessionEntryEntityList(
            SessionEntryDataServiceContext sessionEntryContext, string userID, string sessionID, int gameID)
        {
            IQueryable<SessionEntryAzureTableEntity> entryQuery =
                from c in sessionEntryContext.SessionEntryTable
                where c.PartitionKey.Equals(userID) &&
                      c.RowKey.Equals(gameID + SessionEntryAzureTableEntity.RowKeyDelimiter + sessionID)
                select c;

            TableStorageDataServiceQuery<SessionEntryAzureTableEntity> sessionEntryQuery =
                new TableStorageDataServiceQuery<SessionEntryAzureTableEntity>(
                    entryQuery as DataServiceQuery<SessionEntryAzureTableEntity>,
                    sessionEntryContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = sessionEntryQuery.ExecuteAllWithRetries();
            return sessionEntryResult;
        }

        /// <summary>
        /// Checks if the session entity is complete, if it is complete, throws an exception.
        /// </summary>
        /// <param name="sessionAzureTableEntity">The session entity to validate.</param>
        private static void ValidateSessionEntityNotComplete(SessionAzureTableEntity sessionAzureTableEntity)
        {
            if (sessionAzureTableEntity.IsComplete)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.OperationNotAllowedForCompleteSession,
                    HttpStatusCode.Forbidden,
                    null,
                    false,
                    sessionAzureTableEntity.SessionID,
                    sessionAzureTableEntity.GameID.ToString());
            }
        }

        /// <summary>
        /// Gets a list of session entry Azure Table entities based on a userID and query parameters.
        /// </summary>
        /// <param name="sessionEntryContext">The data service context for the query.</param>
        /// <param name="userID">UserID for which to get the session entry entities.</param>
        /// <param name="queryParameters">Query parameters based on which to get the session entry entities.</param>
        /// <returns>List of session entry Azure Table entities based on a userID and query parameters.</returns>
        private static IEnumerable<SessionEntryAzureTableEntity> GetSessionEntryEntityList(
            SessionEntryDataServiceContext sessionEntryContext, string userID, SessionQueryParameters queryParameters)
        {
            IQueryable<SessionEntryAzureTableEntity> entryQuery =
                                    from c in sessionEntryContext.SessionEntryTable
                                    where c.PartitionKey.Equals(userID)
                                    select c;

            // Add additional parameters based on the parameters
            if (queryParameters.GameID.HasValue)
            {
                entryQuery =
                    from c in entryQuery
                    where c.RowKey.CompareTo(queryParameters.GameID.Value + SessionEntryAzureTableEntity.RowKeyDelimiter) >= 0
                        && c.RowKey.CompareTo((queryParameters.GameID.Value + 1) + SessionEntryAzureTableEntity.RowKeyDelimiter) < 0
                    select c;
            }

            if (!string.IsNullOrEmpty(queryParameters.LastSessionID) && queryParameters.GameID.HasValue)
            {
                entryQuery =
                    from c in entryQuery
                    where c.RowKey.CompareTo(queryParameters.GameID.Value + SessionEntryAzureTableEntity.RowKeyDelimiter + queryParameters.LastSessionID) > 0
                    select c;
            }

            if (queryParameters.Variant.HasValue)
            {
                entryQuery =
                    from c in entryQuery
                    where c.Variant == queryParameters.Variant.Value
                    select c;
            }

            if (queryParameters.ShowSessionType.HasValue && queryParameters.ShowSessionType != ShowSessionType.All)
            {
                bool isCompleteValue = (queryParameters.ShowSessionType.Value == ShowSessionType.Active) ? false : true;
                entryQuery =
                    from c in entryQuery
                    where c.IsComplete == isCompleteValue
                    select c;
            }

            // Get only the number of records wanted.
            if (queryParameters.MaxSessions.HasValue)
            {
                entryQuery =
                    (from c in entryQuery
                    select c).Take(queryParameters.MaxSessions.Value);
            }
            else
            {
                entryQuery =
                    (from c in entryQuery
                     select c).Take(SessionAzureStorage.DefaultMaxSessionsSummariesRetrieved);
            }

            TableStorageDataServiceQuery<SessionEntryAzureTableEntity> sessionEntryQuery =
                new TableStorageDataServiceQuery<SessionEntryAzureTableEntity>(
                    entryQuery as DataServiceQuery<SessionEntryAzureTableEntity>,
                    sessionEntryContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = sessionEntryQuery.ExecuteAllWithRetries();
            return sessionEntryResult;
        }

        /// <summary>
        /// Gets a list of session entry Azure Table entities based on sessionID and gameID for a user.
        /// </summary>
        /// <param name="sessionEntryContext">The data service context for the query.</param>
        /// <param name="userIdentity">The user for which to get session entries.</param>
        /// <param name="sessionID">SessionID for which to get the session entry entities.</param>
        /// <param name="gameID">GameID for which to get the session entry entities.</param>
        /// <returns>List of session entry Azure Table entities based on sessionID and gameID.</returns>
        private static IEnumerable<SessionEntryAzureTableEntity> GetSessionEntryEntityList(
            SessionEntryDataServiceContext sessionEntryContext, IdentityToken userIdentity, string sessionID, int gameID)
        {
            IQueryable<SessionEntryAzureTableEntity> entryQuery =
                from c in sessionEntryContext.SessionEntryTable
                where c.PartitionKey.Equals(userIdentity.ToString()) &&
                    c.RowKey.Equals(gameID + SessionEntryAzureTableEntity.RowKeyDelimiter + sessionID)
                select c;

            TableStorageDataServiceQuery<SessionEntryAzureTableEntity> sessionEntryQuery =
                new TableStorageDataServiceQuery<SessionEntryAzureTableEntity>(
                    entryQuery as DataServiceQuery<SessionEntryAzureTableEntity>,
                    sessionEntryContext.RetryPolicy);

            // note: TableStorageDataServiceQuery.ExecuteAllWithRetries() will return all the results and 
            //       hide the complexity of continuation. This method doesn't call Execute() immediately. It will wait
            //       until the results are enumerated!
            IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = sessionEntryQuery.ExecuteAllWithRetries();
            return sessionEntryResult;
        }

        /// <summary>
        /// Serializes a SeatInfo array.
        /// </summary>
        /// <param name="newSeatInfos">The SeatInfo array to be serialized.</param>
        /// <returns>SeatInfo array in serialized form.</returns>
        private static byte[] SerializeSeatInfoArray(SeatInfo[] newSeatInfos)
        {
            MemoryStream memStream = new MemoryStream(); // Expandable memory stream.
            BinaryFormatter formatter = new BinaryFormatter();
            byte[] result;
            try
            {
                formatter.Serialize(memStream, newSeatInfos);
                byte[] streamBuffer = memStream.ToArray();
                byte[] buffer = new byte[streamBuffer.Length];
                Array.Copy(streamBuffer, buffer, buffer.Length);
                result = buffer;
            }
            finally
            {
                memStream.Close();
            }

            return result;
        }

        /// <summary>
        /// Gets the first empty seat index, read the argument array and return the first index which has value "false".
        /// </summary>
        /// <param name="isSeatOccupiedArray">The array which has whether a seat is occupied indexed by seat index.</param>
        /// <returns>The seat index of the the first empty seat, -1 if not empty seat is found.</returns>
        private static int GetFirstEmptySeatIndex(bool[] isSeatOccupiedArray)
        {
            for (int i = 0; i < isSeatOccupiedArray.Length; i++)
            {
                if (!isSeatOccupiedArray[i])
                {
                    return i;
                }
            }

            // If we reach here, it means that we did not find an empty seat.
            throw new InvalidOperationException("No empty seat found.");
        }

        /// <summary>
        /// Get the Session Azure entity corresponding to the parameters.
        /// </summary>
        /// <param name="sessionContext">The data service context to use.</param>
        /// <param name="sessionID">The sessionID for the entity.</param>
        /// <param name="gameID">The gameID for the entity.</param>
        /// <returns>The Session Azure entity corresponding to the parameters.</returns>
        private static SessionAzureTableEntity GetSessionAzureTableEntity(SessionDataServiceContext sessionContext, string sessionID, uint gameID)
        {
            IEnumerable<SessionAzureTableEntity> result = SessionAzureStorage.GetSessionEntityList(sessionContext, sessionID, (int)gameID);

            SessionAzureTableEntity sessionEntity = null;
            try
            {
                sessionEntity = result.FirstOrDefault();
            }
            catch (DataServiceQueryException ex)
            {
                OperationResponse response = ex.Response;
                if (response.StatusCode != (int)HttpStatusCode.NotFound)
                {
                    throw;
                }

                SessionAzureStorage.ThrowSessionNotFound(ex, sessionID, gameID);
            }

            if (sessionEntity == null)
            {
                SessionAzureStorage.ThrowSessionNotFound(null, sessionID, gameID);
            }

            return sessionEntity;
        }

        /// <summary>
        /// Throw a session not found exception.
        /// </summary>
        /// <param name="ex">The inner exception.</param>
        /// <param name="sessionID">The sessionID for the session.</param>
        /// <param name="gameID">The gameID for the session.</param>
        private static void ThrowSessionNotFound(Exception ex, string sessionID, uint gameID)
        {
            throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.SessionNotFoundInAzureStore,
                    HttpStatusCode.NotFound,
                    ex,
                    false,
                    sessionID,
                    gameID.ToString());
        }

        /// <summary>
        /// Update the session entries for this session.
        /// </summary>
        /// <param name="sessionState">The new session state to be reflected in session entries.</param>
        /// <param name="seatWhichIsUpdating">Seat which is updating the session.</param>
        private void UpdateSessionEntries(SessionState sessionState, SeatInfo seatWhichIsUpdating)
        {
            SessionEntryDataServiceContext sessionEntryContext = new SessionEntryDataServiceContext(this.Account);
            sessionEntryContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionEntryContext.ProxyAddress = this.ProxyAddress;

            IEnumerable<SessionEntryAzureTableEntity> sessionEntryResult = null;
            try
            {
                // Update the session entries of all players in the session.
                foreach (var seat in sessionState.Seats)
                {
                    sessionEntryResult = SessionAzureStorage.GetSessionEntryEntityList(
                        sessionEntryContext, seat.Profile.ToString(), sessionState.SessionID, (int)sessionState.GameID);

                    SessionEntryAzureTableEntity sessionEntryEntity = null;
                    try
                    {
                        sessionEntryEntity = sessionEntryResult.FirstOrDefault();
                    }
                    catch (DataServiceQueryException ex)
                    {
                        OperationResponse response = ex.Response;
                        if (response.StatusCode != (int) HttpStatusCode.NotFound)
                        {
                            throw;
                        }
                    }

                    // Ignore any session entry entities that are missing.
                    if (sessionEntryEntity == null)
                    {
                        continue;
                    }

                    // If the seat which is updating is null, just update the lastModified time.
                    if (seatWhichIsUpdating == null)
                    {
                        sessionEntryEntity.Modify();
                    }
                    else
                    {
                        if (sessionState.State.IsComplete)
                        {
                            sessionEntryEntity.Modify(true, seatWhichIsUpdating);
                        }
                        else
                        {
                            sessionEntryEntity.Modify(seatWhichIsUpdating);
                        }
                    }

                    sessionEntryContext.UpdateObject(sessionEntryEntity);
                    sessionEntryContext.SaveChangesWithRetries();
                }
            }
            catch (Exception ex)
            {
                throw new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.ErrorWhileTryingToGetAndUpdateSessionEntries,
                        HttpStatusCode.InternalServerError,
                        ex,
                        true,
                        sessionState.SessionID,
                        sessionState.GameID.ToString());
            }
        }

        /// <summary>
        /// Updates the session index table by deleting the original session index entry and adding a new one.
        /// </summary>
        /// <param name="newSessionState">The new session state.</param>
        /// <param name="originalModificationTime">The time when this session was orginally modified.</param>
        private void UpdateSessionIndex(SessionState newSessionState, DateTime originalModificationTime)
        {
            SessionIndexDataServiceContext sessionIndexContext = new SessionIndexDataServiceContext(this.Account);
            sessionIndexContext.RetryPolicy = RetryPolicies.RetryN(3, TimeSpan.FromSeconds(1));
            sessionIndexContext.ProxyAddress = this.ProxyAddress;

            // We will first create the new entry so that there is an index to the session at all times.
            SessionIndexAzureTableEntity newIndexEntry = new SessionIndexAzureTableEntity(newSessionState);
            sessionIndexContext.AddObject(SessionIndexDataServiceContext.SessionIndexTableName, newIndexEntry);
            sessionIndexContext.SaveChangesWithRetries();
            sessionIndexContext.Detach(newIndexEntry);

            // Delete the old index.
            IEnumerable<SessionIndexAzureTableEntity> result = SessionAzureStorage.GetSessionIndexEntityList(
                sessionIndexContext, newSessionState.SessionID, (int) newSessionState.GameID, originalModificationTime);

            SessionIndexAzureTableEntity indexEntity = null;
            try
            {
                indexEntity = result.FirstOrDefault();
            }
            catch (System.Data.Services.Client.DataServiceQueryException ex)
            {
                // In case the session index entity is not present, we get an exception. Ignore it.
                // This is probably due to a PutGameState etc which succeeded partially in updating the various tables.
                Logging.TraceVerbose(
                    "UpdateSessionIndex: Ignoring an exception while trying to get the session index entity: SessionID: {0} GameID: {1}  Exception Details: \n",
                    newSessionState.SessionID,
                    newSessionState.GameID.ToString(),
                    ex.ToString());
            }

            // Delete the older session index entity.
            if (indexEntity != null)
            {
                sessionIndexContext.DeleteObject(indexEntity);
                sessionIndexContext.SaveChangesWithRetries();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionIndexAzureTableEntity.cs ===
// <copyright file="SessionIndexAzureTableEntity.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-13</date>
// <summary>Contains the class definition for SessionIndexAzureTableEntity class.</summary>
namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Common;
    using System.Text;
    using Common.AzureStorage;
    using SessionCommon;

    /// <summary>
    /// The Azure table entity class for session table index.
    /// The concatenation of PartitionKey and RowKey has to be unique.
    /// The PartitionKey is the Session creation DateTime in format: yyyyMMddHHmm.
    /// RowKey is of the format: ssfff_GameID_SessionID where ss is seconds and fff is milliseconds.
    /// </summary>
    [DataServiceKey("PartitionKey", "RowKey")]
    public class SessionIndexAzureTableEntity : TableStorageEntity
    {
        /// <summary>
        /// Initializes a new instance of the SessionIndexAzureTableEntity class.
        /// </summary>
        public SessionIndexAzureTableEntity()
        {
        }

        /// <summary>
        /// Initializes a new instance of the SessionIndexAzureTableEntity class based on a SessionState.
        /// </summary>
        /// <param name="sessionState">The Session State object.</param>
        public SessionIndexAzureTableEntity(SessionState sessionState)
        {
            this.PartitionKey = sessionState.State.LastModified.ToString(SessionIndexAzureTableEntity.GetPartitionKeyFormat());
            this.RowKey = SessionIndexAzureTableEntity.GetRowKey(sessionState.State.LastModified, sessionState.GameID, sessionState.SessionID);

            // Need to find a better way to do this.
            this.GameID = (int)sessionState.GameID;
            this.SessionID = sessionState.SessionID;
        }

        /// <summary>
        /// Gets or sets the GameID.
        /// </summary>
        /// <value>The GameID for the session.</value>
        public int GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID.
        /// </summary>
        /// <value>The sessionID for the session.</value>
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the format of the partition key.
        /// </summary>
        /// <returns>The format of the partion key as a Standard Date and Time Format String.</returns>
        public static string GetPartitionKeyFormat()
        {
            return "yyyyMMddHHmm";
        }

        /// <summary>
        /// Gets the row key given the last modified DateTime, gameID and sessionID.
        /// </summary>
        /// <param name="lastModified">Last modified DateTime for which to get row key.</param>
        /// <param name="gameID">GameID for which to get row key.</param>
        /// <param name="sessionID">SessionID for which to get row key.</param>
        /// <returns>The row key for the Azure table.</returns>
        internal static string GetRowKey(DateTime lastModified, uint gameID, string sessionID)
        {
            StringBuilder stringBuilder = new StringBuilder(lastModified.ToString("ssfff"));
            stringBuilder.AppendFormat("_{0}_{1}", gameID.ToString(), sessionID);
            return stringBuilder.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionEntryDataServiceContext.cs ===
// <copyright file="SessionEntryDataServiceContext.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionEntryDataServiceContext class.</summary>
namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Client;
    using System.Data.Services.Common;
    using System.Linq;
    using System.Net; 
    using Common.AzureStorage;

    /// <summary>
    /// DataServiceContext for Azure Table Storage Access. This is a helper class mostly used 
    /// To get SessionEntryTable.
    /// </summary>
    public class SessionEntryDataServiceContext : TableStorageDataServiceContext
    {
        /// <summary>
        /// The table name used to save the sessions entries in Azure Table.
        /// </summary>
        public const string SessionEntryTableName = "SessionEntryTable";

        /// <summary>
        /// Initializes a new instance of the SessionEntryDataServiceContext class based on the accountInfo.
        /// </summary>
        /// <param name="accountInfo">The account information.</param>
        public SessionEntryDataServiceContext(StorageAccountInfo accountInfo)
            : base(accountInfo)
        {
            SendingRequest += new EventHandler<SendingRequestEventArgs>(this.SetProxy);
            this.ResolveType = this.ResolveEntityType;
        }

        /// <summary>
        /// Gets or sets the proxy address of the context. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Gets SessionEntryTable object list.
        /// </summary>
        /// <value>IQueryable object that can enumerate SessionEntryAzureTableEntity objects.</value>
        public IQueryable<SessionEntryAzureTableEntity> SessionEntryTable
        {
            get
            {
                return this.CreateQuery<SessionEntryAzureTableEntity>(SessionEntryTableName);
            }
        }

        /// <summary>
        /// Delegate to return entity type for more efficient handling than default by reflection. 
        /// </summary>
        /// <param name="name">The qualified name of the table. </param>
        /// <returns>The type of an entity in the table.</returns>
        public Type ResolveEntityType(string name)
        {
            return typeof(SessionEntryAzureTableEntity);
        }

        /// <summary>
        /// Callback method called whenever a request is sent to the table service. This 
        /// is where the signing of the request takes place. This method is chained with 
        /// whatever is set in base class. 
        /// </summary>
        /// <param name="sender">The sender of the callback method. </param>
        /// <param name="e">The callback args. </param>
        private void SetProxy(object sender, SendingRequestEventArgs e)
        {
            if (!string.IsNullOrEmpty(this.ProxyAddress))
            {
                HttpWebRequest request = e.Request as HttpWebRequest;
                request.Proxy = new WebProxy(this.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\GameAction.cs ===
// <copyright file="GameAction.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-08-06</date>
// <summary>Contains the class definition for GameAction.</summary>

namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Defines the type of GameAction.
    /// </summary>
    public enum GameActionType
    {
        /// <summary>
        /// For game specific game actions.
        /// </summary>
        GameSpecific,

        /// <summary>
        /// For user nudges.
        /// </summary>
        UserNudge
    }

    /// <summary>
    /// This class models an action made in a game.
    /// </summary>
    [DataContract]
    public class GameAction
    {
        /// <summary>
        /// Gets or sets the action data.
        /// </summary>
        /// <value>The data which describes the action.</value>
        [DataMember]
        public byte[] ActionData
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the sequence number.
        /// </summary>
        /// <value>Sequence number for the game state when this action was taken.</value>
        [DataMember]
        public int SequenceNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the action time.
        /// </summary>
        /// <value>The time when this action was taken.</value>
        [DataMember]
        public DateTime ActionTime
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the action type.
        /// </summary>
        /// <value>The data which defines the type of the game action.</value>
        [DataMember]
        public GameActionType ActionType
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the Assembly Information for SessionAzureStorage.</summary>
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionAzureStorage")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("54ccddb8-8d47-4b60-ad05-8f0c93b87ab3")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionAzureStorage\SessionIndexDataServiceContext.cs ===
// <copyright file="SessionIndexDataServiceContext.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-01-13</date>
// <summary>Contains the class definition for SessionIndexDataServiceContext class.</summary>

namespace AsyncMultiplayer.SessionAzureStorage
{
    using System;
    using System.Data.Services.Client;
    using System.Linq;
    using System.Net;
    using AsyncMultiplayer.Common.AzureStorage;

    /// <summary>
    /// DataServiceContext for Azure Table Storage Access. This is a helper class mostly used 
    /// To get SessionIndexTable.
    /// </summary>
    public class SessionIndexDataServiceContext : TableStorageDataServiceContext
    {
        /// <summary>
        /// The table name used to get the session index in Azure Session Table.
        /// </summary>
        public const string SessionIndexTableName = "SessionIndexTable";

        /// <summary>
        /// Initializes a new instance of the SessionIndexDataServiceContext class based on the accountInfo.
        /// </summary>
        /// <param name="accountInfo">The account information.</param>
        public SessionIndexDataServiceContext(StorageAccountInfo accountInfo)
            : base(accountInfo)
        {
            SendingRequest += new EventHandler<SendingRequestEventArgs>(this.SetProxy);
            this.ResolveType = this.ResolveEntityType;
        }

        /// <summary>
        /// Gets or sets the proxy address of the context. 
        /// </summary>
        public string ProxyAddress { get; set; }

        /// <summary>
        /// Gets SessionIndexTable object list.
        /// </summary>
        /// <value>IQueryable object that alllows queries on SessionIndexAzureTableEntity.</value>
        public IQueryable<SessionIndexAzureTableEntity> SessionIndexTable
        {
            get
            {
                return this.CreateQuery<SessionIndexAzureTableEntity>(SessionIndexTableName);
            }
        }

        /// <summary>
        /// Delegate to return entity type for more efficient handling than default by reflection. 
        /// </summary>
        /// <param name="name">The qualified name of the table. </param>
        /// <returns>The type of an entity in the table.</returns>
        public Type ResolveEntityType(string name)
        {
            return typeof(SessionIndexAzureTableEntity);
        }

        /// <summary>
        /// Callback method called whenever a request is sent to the table service. This 
        /// is where the signing of the request takes place. This method is chained with 
        /// whatever is set in base class. 
        /// </summary>
        /// <param name="sender">The sender of the callback method. </param>
        /// <param name="e">The callback args. </param>
        private void SetProxy(object sender, SendingRequestEventArgs e)
        {
            if (!string.IsNullOrEmpty(this.ProxyAddress))
            {
                HttpWebRequest request = e.Request as HttpWebRequest;
                request.Proxy = new WebProxy(this.ProxyAddress);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\CreationData.cs ===
// <copyright file="CreationData.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for CreationData class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Defines the policy executed when a player in the session leaves or is kicked out.
    /// </summary>
    public enum SessionLeavePolicy
    {
        /// <summary>
        /// User leaving the session receives a loss and the session is not marked complete.
        /// </summary>
        LeavingUserLoses = 0,

        /// <summary>
        /// User leaving the session receives a loss and everyone else wins. The session is marked complete.
        /// </summary>
        LeavingUserLosesOpponentsWin = 1,

        /// <summary>
        /// Nothing special happens when a user leaves a session.
        /// </summary>
        None = 2
    }

    /// <summary>
    /// This class models the creation data passed during session creation.
    /// </summary>
    [DataContract]
    public class CreationData
    {
        /// <summary>
        /// Gets or sets the GameID for creation data.
        /// </summary>
        /// <value>The GameID for creation data.</value>
        [DataMember]
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the GameID for creation data.
        /// </summary>
        /// <value>The GameID for creation data.</value>
        [DataMember]
        public int Variant
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the TotalSeatsAvailable for creation data.
        /// </summary>
        /// <value>The TotalSeatsAvailable for creation data.</value>
        [DataMember]
        public int TotalSeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets this reserved field.
        /// </summary>
        [DataMember]
        public int ReservedSeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionParameters for creation data.
        /// </summary>
        /// <value>The SessionParameters for creation data.</value>
        [DataMember]
        public byte[] SessionParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the InactivityWarningBehavior for creation data.
        /// </summary>
        /// <value>The InactivityWarningBehavior for creation data.</value>
        [DataMember]
        public InactivityWarningBehavior InactivityWarning
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the empty seats can be removed from the session.
        /// </summary>
        /// <value>The CanRemoveEmptySeats for creation data.</value>
        [DataMember]
        public bool CanRemoveEmptySeats
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayName for creation data.
        /// </summary>
        /// <value>The DisplayName for creation data.</value>
        [DataMember]
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the session leave policy for creation data.
        /// </summary>
        /// <value>The session leave policy for creation data.</value>
        [DataMember]
        public SessionLeavePolicy LeavePolicy
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\FullGameState.cs ===
// <copyright file="FullGameState.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-19</date>
// <summary>Contains the class definition for FullGameState class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// This class models the complete Game State in the session.
    /// </summary>
    [DataContract]
    public class FullGameState
    {
        /// <summary>
        /// Gets or sets the GameStateInfo for the GameState.
        /// </summary>
        /// <value>The GameStateInfo for the GameState.</value>
        [DataMember]
        public GameState GameStateInfo
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the GameData for the GameState.
        /// </summary>
        /// <value>The GameData for the GameState.</value>
        [DataMember]
        public byte[] GameData
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\GameResults.cs ===
// <copyright file="GameResults.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-12</date>
// <summary>Contains the class definition for GameResults.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System.Collections.Generic;
    using System.Runtime.Serialization;
    using Gds.Contracts;

    /// <summary>
    /// This class models the game results at the end of a game.
    /// </summary>
    [DataContract]
    public class GameResults
    {
        /// <summary>
        /// Gets or sets the array of winning seat Indexes.
        /// </summary>
        [DataMember]
        public int[] WinningSeatIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the array of losing seat Indexes.
        /// </summary>
        [DataMember]
        public int[] LosingSeatIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the array of tie seat Indexes.
        /// </summary>
        [DataMember]
        public int[] TierSeatIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the array of game over seat indexes.
        /// </summary>
        [DataMember]
        public int[] GameOverSeatIndexes
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a dictionary of game results.
        /// The key in the dictionary is the seat index.
        /// </summary>
        [DataMember]
        public Dictionary<int, GameResult> Results
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\GameStateFileInfo.cs ===
// <copyright file="GameStateFileInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-09</date>
// <summary>Contains the class definition for GameStateFileInfo.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;

    /// <summary>
    /// Models a game state file information.
    /// </summary>
    public class GameStateFileInfo
    {
        /// <summary>
        /// Gets or sets Name of the blob.
        /// </summary>
        /// <value>Name of the blob.</value>
        public string Name { get; set; }

        /// <summary>
        /// Gets or sets Content encoding of the file if it set, null otherwise.
        /// </summary>
        /// <value>Content encoding of the file.</value>
        public string ContentEncoding { get; set; }

        /// <summary>
        /// Gets or sets Content Type of the file if it is set, null otherwise.
        /// </summary>
        /// <value>Content Type of the file.</value>
        public string ContentType { get; set; }

        /// <summary>
        /// Gets or sets Content Language of the file if it is set, null otherwise.
        /// </summary>
        /// <value>Content Language of the file.</value>
        public string ContentLanguage { get; set; }

        /// <summary>
        /// Gets or sets the length of the file content, null otherwise.
        /// </summary>
        /// <value>The length of the file content.</value>
        public long ContentLength { get; set; }

        /// <summary>
        /// Gets or sets the last modified time for the file.
        /// </summary>
        /// <value>The last modified time for the file.</value>
        public DateTime LastModifiedTime { get; set; }

        /// <summary>
        /// Gets or sets the ETag of the file. This is an identifier assigned to the file by the storage service
        /// and is used to distinguish contents of two files (or versions of the same files).
        /// </summary>
        /// <value>The ETag of the file.</value>
        public string ETag { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\IdentityToken.cs ===
// <copyright file="IdentityToken.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for IdentityToken class and associated enums.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;

    /// <summary>
    /// This enum defines the types supported by the identity service.
    /// </summary>
    public enum IdentityServiceType
    {
        /// <summary>
        /// Represents a XUID.
        /// </summary>
        XUID
    }

    /// <summary>
    /// This class models the identity token supplied by the identity service.
    /// </summary>
    [Serializable]
    public class IdentityToken
    {
        /// <summary>
        /// Separator for IdentityServiceType and Token in the string representation of the object.
        /// </summary>
        private const string Separator = ":";

        /// <summary>
        /// Initializes a new instance of the IdentityToken class.
        /// </summary>
        public IdentityToken()
        {
        }

        /// <summary>
        /// Initializes a new instance of the IdentityToken class using the supplied
        /// IdentityServiceType, token and public token.
        /// </summary>
        /// <param name="type">IdentityServiceType for the IdentityToken.</param>
        /// <param name="token">The token for the IdentityToken.</param>
        /// <param name="publicToken">The public token for the IdentityToken.</param>
        public IdentityToken(IdentityServiceType type, string token, string publicToken)
        {
            this.ServiceType = type;
            this.Token = token;
            this.PublicToken = publicToken;
        }

        /// <summary>
        /// Initializes a new instance of the IdentityToken class using a Xuid and gamerTag.
        /// </summary>
        /// <param name="xuid">The xuid for which to create the identity token.</param>
        /// <param name="gamerTag">The gamerTag for which to create the identity token.</param>
        public IdentityToken(ulong xuid, string gamerTag)
        {
            this.ServiceType = IdentityServiceType.XUID;

            // Mandate 20 digits for Xuid, any missing digits will be padded by 0s.
            // Encode Xuid string as UTF8.
            string xuidString = xuid.ToString("D20");
            this.Token = xuidString;
            this.PublicToken = gamerTag;
        }

        /// <summary>
        /// Initializes a new instance of the IdentityToken class using the string representation of identityToken.
        /// </summary>
        /// <param name="identityTokenAsString">The string representation of identityToken, this must be the same as returned by IdentityToken.ToString() method.</param>
        public IdentityToken(string identityTokenAsString)
        {
            try
            {
                if (identityTokenAsString == null)
                {
                    throw new ArgumentNullException();
                }

                string[] identitySplinters = identityTokenAsString.Split(Separator.ToCharArray());
                if (identitySplinters.Length == 2)
                {
                    this.ServiceType = (IdentityServiceType)Enum.Parse(typeof(IdentityServiceType), identitySplinters[0], true);
                    this.Token = identitySplinters[1];
                }
                else
                {
                    throw new ArgumentException("Argument cannot be split into exactly 2 pieces.");
                }
            }
            catch (ArgumentException ex)
            {
                string message =
                    "Argument is not in the expected format, expected format: IdentityServiceType:Token e.g.: XUID:00002600292641994140, actual: " +
                    (identityTokenAsString ?? "null");
                throw new ArgumentException(message, ex);
            }
        }

        /// <summary>
        /// Gets or sets the IdentityServiceType for the IdentityToken.
        /// </summary>
        /// <value>The IdentityServiceType for the IdentityToken.</value>
        public IdentityServiceType ServiceType
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Token for the IdentityToken.
        /// </summary>
        /// <value>The Token value for the IdentityToken.</value>
        public string Token
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the public token for the IdentityToken.
        /// </summary>
        /// <value>The public token for the IdentityToken.</value>
        public string PublicToken
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the string representation for the IdentityToken.
        /// </summary>
        /// <returns>The string representation for the IdentityToken.</returns>
        public new string ToString()
        {
            System.Text.Encoding encoding = new System.Text.UTF8Encoding();
            string identityTokenStr = this.ServiceType.ToString() + Separator + this.Token;
            return identityTokenStr;
        }

        /// <summary>
        /// Evaluates whether another IdentityToken object represents the same user.
        /// </summary>
        /// <param name="anotherIdentity">IdentityToken to be compared.</param>
        /// <returns>Whether the passed identity is the same as this identity.</returns>
        public bool Equals(IdentityToken anotherIdentity)
        {
            bool result;
            if (anotherIdentity.ServiceType == this.ServiceType && this.Token.Equals(anotherIdentity.Token))
            {
                result = true;
            }
            else
            {
                result = false;
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\GameStateFile.cs ===
// <copyright file="GameStateFile.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-09</date>
// <summary>Contains the class definition for GameStateFile.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.IO;

    /// <summary>
    /// Models a game state file.
    /// </summary>
    public class GameStateFile : IDisposable
    {
        /// <summary>
        /// Gets or sets the information about the game state file.
        /// </summary>
        /// <value>The information about the game state file.</value>
        public GameStateFileInfo Info { get; set; }

        /// <summary>
        /// Gets or sets the game state data stream itself.
        /// </summary>
        /// <value>The game state data stream itself.</value>
        public Stream DataStream { get; set; }

        /// <summary>
        /// Implementation of Dispose. Dispose() calls Dispose(true).
        /// </summary>
        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Used by the GC and our code, GC calls with Dispose(false). The bulk of the clean-up code is implemented in Dispose(bool).
        /// </summary>
        /// <param name="disposing">Whether the user code is disposing the object explicitly.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Free managed resources
                if (this.DataStream != null)
                {
                    this.DataStream.Dispose();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\IGameLogicModule.cs ===
// <copyright file="IGameLogicModule.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the interface definition for the IGameLogicModule interface.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    /// <summary>
    /// This interface defines the methods to be implemented by all server game logic modules.
    /// </summary>
    public interface IGameLogicModule
    {
        /// <summary>
        /// Gets the version of the Game Logic Module.
        /// </summary>
        /// <returns>The version of the Game Logic Module.</returns>
        int GetVersion();

        /// <summary>
        /// Gets the information about the Game Logic Module.
        /// </summary>
        /// <returns>Information about the Game Logic Module.</returns>
        ModuleInfo GetModuleInfo();

        /// <summary>
        /// Fired when a new session is created.
        /// </summary>
        /// <param name="sessionState">The session state of the created session.</param>
        /// <param name="creationData">Data used for creation of the session</param>
        void OnCreateSession(SessionState sessionState, CreationData creationData);

        /// <summary>
        /// Fired when a session is modified.
        /// </summary>
        /// <param name="modifiedSessionState">The session state of the modified session.</param>
        /// <param name="modificationData">Data used for modification of the session.</param>
        void OnModifySession(SessionState modifiedSessionState, ModificationData modificationData);

        /// <summary>
        /// Fired when a player joins a session.
        /// </summary>
        /// <param name="joinedSessionState">The state of the session after the join.</param>
        /// <param name="joinData">The data received while joining.</param>
        void OnJoinSession(SessionState joinedSessionState, JoinData joinData);

        /// <summary>
        /// Fired when a player leaves a session.
        /// </summary>
        /// <param name="leftSessionState">Session state after leave.</param>
        /// <param name="ownerLeft">Did the session owner leave?</param>
        /// <param name="userWhoLeft">The seat information of the user who left.</param>
        void OnLeaveSession(SessionState leftSessionState, bool ownerLeft, SeatInfo userWhoLeft);

        /// <summary>
        /// Fired when a user tries to get the game state.
        /// </summary>
        /// <param name="sessionState">Session state.</param>
        /// <param name="actorSeatIndex">The user trying to get game state.</param>
        /// <returns>The full game state view</returns>
        FullGameState OnGetGameState(SessionState sessionState, int actorSeatIndex);

        /// <summary>
        /// Fired whene a user tries to submit a game action.
        /// </summary>
        /// <param name="curSessionState">Current state of the session.</param>
        /// <param name="action">The action submitted by the user.</param>
        /// <param name="actorSeatIndex">The user trying to submit game action.</param>
        /// <param name="storageObject">Opaque storage to be used as a param for ISessionStorage.Modify().</param>
        void OnSubmitGameAction(SessionState curSessionState, GameAction action, int actorSeatIndex, OpaqueSessionStorageObject storageObject);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\GameState.cs ===
// <copyright file="GameState.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for GameState class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// This class models the Game State in the session.
    /// </summary>
    [DataContract]
    public class GameState
    {
        /// <summary>
        /// Gets or sets the GameID for the GameState.
        /// </summary>
        /// <value>The GameID for the GameState.</value>
        [DataMember]
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the game Variant for the GameState.
        /// </summary>
        /// <value>The game Variant for the GameState.</value>
        [DataMember]
        public int Variant
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID for the GameState.
        /// </summary>
        /// <value>The SessionID for the GameState.</value>
        [DataMember]
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the GameState is complete.
        /// </summary>
        /// <value>Indicates whether the GameState is complete.</value>
        [DataMember]
        public bool IsComplete
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModified value for the GameState.
        /// </summary>
        /// <value>The LastModified value for the GameState.</value>
        [DataMember]
        public DateTime LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SequenceNumber for the GameState.
        /// </summary>
        /// <value>The SequenceNumber for the GameState.</value>
        [DataMember]
        public int SequenceNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the ActiveSeatIndex for the GameState.
        /// </summary>
        /// <value>The ActiveSeatIndex for the GameState.</value>
        [DataMember]
        public int ActiveSeatIndex
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\IGameStateStorage.cs ===
// <copyright file="IGameStateStorage.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-09</date>
// <summary>Contains the interface definition for the IGameStateStorage interface.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System.IO;

    /// <summary>
    /// This interface defines the methods provided by the Game State Storage providers.
    /// </summary>
    public interface IGameStateStorage
    {
        /// <summary>
        /// Provision state storage for a particular session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to provision storage.</param>
        /// <param name="gameID">The gameID of the session for which to provision storage.</param>
        void ProvisionStorage(string sessionID, uint gameID);

        /// <summary>
        /// Deprovision game storage for a particular session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to deprovision storage.</param>
        /// <param name="gameID">The gameID of the session for which to deprovision storage.</param>
        void DeprovisionStorage(string sessionID, uint gameID);

        /// <summary>
        /// Get the contents of a file.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to get the data.</param>
        /// <param name="gameID">The gameID of the session for which to get the data.</param>
        /// <param name="fileName">The name of the file to be retrieved.</param>
        /// <returns>The game state file.</returns>
        GameStateFile Load(string sessionID, uint gameID, string fileName);

        /// <summary>
        /// Save the contents to a backend file.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to save the data file.</param>
        /// <param name="gameID">The gameID of the session for which to save the data file.</param>
        /// <param name="fileName">The name of the file to be saved.</param>
        /// <param name="saveStream">Data Stream to be saved into the backend file.</param>
        void Save(string sessionID, uint gameID, string fileName, Stream saveStream);

        /// <summary>
        /// Enumerate storage files for a particular session.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session for which to enumerate the files.</param>
        /// <param name="gameID">The gameID of the session for which to enumerate the files.</param>
        /// <returns>The information about the files.</returns>
        GameStateFileInfo[] EnumerateFiles(string sessionID, uint gameID);

        /// <summary>
        /// Get the information about a particular file.
        /// </summary>
        /// <param name="sessionID">The sessionID corresponding to the file for which to get the file info.</param>
        /// <param name="gameID">The gameID corresponding to the file for which to get the file info.</param>
        /// <param name="fileName">The fileName corresponding to the file for which to get the file info.</param>
        /// <returns>The information about a game state file.</returns>
        GameStateFileInfo QueryFileInfo(string sessionID, uint gameID, string fileName);

        /// <summary>
        /// Delete a particular file.
        /// </summary>
        /// <param name="sessionID">The sessionID corresponding to the file to be deleted.</param>
        /// <param name="gameID">The gameID corresponding to the file to be deleted.</param>
        /// <param name="fileName">The fileName corresponding to the file to be deleted.</param>
        void DeleteFile(string sessionID, uint gameID, string fileName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\InactivityWarningBehavior.cs ===
// <copyright file="InactivityWarningBehavior.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for InactivityWarningBehavior class and associated enums.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    /// <summary>
    /// Defines the types of actions that can be taken on an inactivity warning.
    /// </summary>
    public enum InactivityWarningAction
    {
        /// <summary>
        /// Represents an action of doing nothing.
        /// </summary>
        None,

        /// <summary>
        /// Represents an action of warning the inactive user.
        /// </summary>
        WarnOnly,

        /// <summary>
        /// Represents an action of kicking the inactive user out of the session.
        /// </summary>
        Kick
    }

    /// <summary>
    /// This class models the inactivity warning behavior.
    /// </summary>
    public class InactivityWarningBehavior
    {
        /// <summary>
        /// Gets or sets the InactivityWarningAction for the InactivityWarningBehavior.
        /// </summary>
        /// <value>The InactivityWarningAction for the InactivityWarningBehavior.</value>
        public InactivityWarningAction Action
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Interval for the InactivityWarningBehavior.
        /// </summary>
        /// <value>The Interval for the InactivityWarningBehavior.</value>
        public int Interval
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the MaxNumberOfNudges after which a warning will be sent.
        /// </summary>
        /// <value>The MaxNumberOfNudges for the InactivityWarningBehavior.</value>
        public int MaxNumberOfNudges
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\JoinData.cs ===
// <copyright file="JoinData.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for JoinData.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Models the JoinData.
    /// </summary>
    [DataContract]
    public class JoinData
    {
        /// <summary>
        /// Gets or sets the GameID for the JoinData.
        /// </summary>
        /// <value>The GameID for the JoinData.</value>
        [DataMember]
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID for the JoinData.
        /// </summary>
        /// <value>The SessionID for the JoinData.</value>
        [DataMember]
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SeatIndex for the JoinData.
        /// </summary>
        /// <value>The SeatIndex for the JoinData.</value>
        [DataMember]
        public int SeatIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SeatParameters for the JoinData.
        /// </summary>
        /// <value>The SeatParameters for the JoinData.</value>
        [DataMember]
        public byte[] SeatParameters
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\ModuleInfo.cs ===
// <copyright file="ModuleInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the class definition for ModuleInfo class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System.Collections.Generic;

    /// <summary>
    /// This class models the information that can be queried from a game module.
    /// </summary>
    public class ModuleInfo
    {
        /// <summary>
        /// Gets or sets the GameID for the game logic module.
        /// </summary>
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the maximum number of players supported by each variant of the game.
        /// </summary>
        public Dictionary<int, int> VariantMaxPlayersMap
        {
            get;
            set;
        }

        /// <summary>
        ///  Gets or sets a value indicating whether module is a passthrough game logic module.
        /// This will be false for all implementations except the passthrough implementation.
        /// </summary>
        public bool IsPassThruModule
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\ModificationData.cs ===
// <copyright file="ModificationData.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition and related enums for ModificationData.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System.Runtime.Serialization;

    /// <summary>
    /// Models the modification data.
    /// </summary>
    [DataContract]
    public class ModificationData
    {
        /// <summary>
        /// Gets or sets a value indicating whether empty seats can be removed from the session.
        /// </summary>
        /// <value>The CanRemoveEmptySeats value for this ModificationData.</value>
        [DataMember]
        public bool CanRemoveEmptySeats
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayName for this ModificationData.
        /// </summary>
        /// <value>The DisplayName for this ModificationData.</value>
        [DataMember]
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the InactivityWarningBehavior for this ModificationData.
        /// </summary>
        /// <value>The InactivityWarningBehavior for this ModificationData.</value>
        [DataMember]
        public InactivityWarningBehavior InactivityWarning
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether this reserved field is true or false.
        /// </summary>
        [DataMember]
        public bool IsFriendsOnly
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets this reserved field.
        /// </summary>
        [DataMember]
        public int ReservedSeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionParameters for this ModificationData.
        /// </summary>
        /// <value>The SessionParameters for this ModificationData.</value>
        [DataMember]
        public byte[] SessionParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the TotalSeatsAvailable for this ModificationData.
        /// </summary>
        /// <value>The TotalSeatsAvailable for this ModificationData.</value>
        [DataMember]
        public int TotalSeatsAvailable
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\ModifiableGameState.cs ===
// <copyright file="ModifiableGameState.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-19</date>
// <summary>Contains the class definition for ModifiableGameState class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// This class models the Modifiable Game State,
    /// (parts of the game state that can be modified by pass thru client).
    /// </summary>
    [DataContract]
    public class ModifiableGameState
    {
        /// <summary>
        /// Gets or sets the GameData for the GameState.
        /// </summary>
        /// <value>The GameData for the GameState.</value>
        [DataMember]
        public byte[] GameData
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the ActiveSeatIndex for the GameState.
        /// </summary>
        /// <value>The ActiveSeatIndex for the GameState.</value>
        [DataMember]
        public int ActiveSeatIndex
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\ISessionStorage.cs ===
// <copyright file="ISessionStorage.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the interface definition for the ISessionStorage interface.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using Leet.Core.Platforms;

    /// <summary>
    /// This interface defines the methods provided by the Session Storage providers.
    /// </summary>
    public interface ISessionStorage
    {
        /// <summary>
        /// Add a session to the storage.
        /// </summary>
        /// <param name="sessionState">The state of the session to be added.</param>
        /// <param name="maxCreateSessionsAllowedPerUser">Maximum sessions aloowed to be created by a user.</param>
        void AddSession(SessionState sessionState, int maxCreateSessionsAllowedPerUser);

        /// <summary>
        /// Modifies a session in the storage.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to be modified.</param>
        /// /// <param name="gameID">GameID of the session to be modified.</param>
        /// <param name="modificationData">Modification data.</param>
        /// <param name="actorIdentity">Identity of the actor(user) modifying the session.</param>
        /// <returns>The modified session state.</returns>
        SessionState ModifySession(string sessionID, uint gameID, ModificationData modificationData, IdentityToken actorIdentity);

        /// <summary>
        /// Modifies the session in the storage. Meant to be used by the game logic module.
        /// </summary>
        /// <param name="storageObject">An opaque session storage object for the session to be modified.</param>
        /// <param name="modifiableState">The modifiable portion of the state.</param>
        /// <param name="actorIdentity">The actor who is modifying the session.</param>
        /// <returns>The modified session state.</returns>
        SessionState ModifySession(OpaqueSessionStorageObject storageObject, ModuleModifiableState modifiableState, IdentityToken actorIdentity);

        /// <summary>
        /// Modifies the session in the storage.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session to be modified.</param>
        /// <param name="gameID">The gameID of the session to be modified.</param>
        /// <param name="nudgesSentIncremented">Were nudges incremented?</param>
        void ModifySession(string sessionID, uint gameID, bool nudgesSentIncremented);

        /// <summary>
        /// Modify the seats info array for a session.
        /// </summary>
        /// <param name="storageObject">An opaque session storage object for the session to be modified.</param>
        /// <param name="seats">The seats info array to be updated.</param>
        void ModifySession(OpaqueSessionStorageObject storageObject, SeatInfo[] seats);

        /// <summary>
        /// Query a session in Azure storage based on the sessionID.
        /// </summary>
        /// <param name="sessionID">The sessionID of the session being queried.</param>
        /// <param name="gameID">The gameID of the session being queried.</param>
        /// <param name="storageObject">Out paramter, this is an opaque object to be used by ModifySession.</param>
        /// <returns>The session state.</returns>
        SessionState QuerySession(string sessionID, uint gameID, out OpaqueSessionStorageObject storageObject);

        /// <summary>
        /// Queries the sessions for a particular user.
        /// </summary>
        /// <param name="actorIdentity">Identity of the actor(user) querying the session.</param>
        /// <param name="queryParameters">Query parameters for the method, used to filter the results.</param>
        /// <returns>Array of session entries.</returns>
        SessionEntry[] QuerySessions(IdentityToken actorIdentity, SessionQueryParameters queryParameters);

        /// <summary>
        /// Adds a player to the session in storage.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to be added to.</param>
        /// <param name="joinData">Data required for adding the player.</param>
        /// <param name="actorIdentity">Identity of the actor(user) being added the session.</param>
        /// <param name="locale">The locale of the actor.</param>
        /// <param name="platformType">The platform type for the actor's client.</param>
        /// <returns>The session state.</returns>
        SessionState AddPlayer(string sessionID, JoinData joinData, IdentityToken actorIdentity, string locale, PlatformType platformType);

        /// <summary>
        /// Removes a player from a specific session.
        /// </summary>
        /// <param name="sessionID">SessionID of the session to be removed from.</param>
        /// <param name="gameID">GameID of the session to be removed from.</param>
        /// <param name="actorIdentity">Identity of the actor(user) being removed from the session.</param>
        /// <param name="leavingPlayerSeat">The seat of the leaving player.</param>
        /// <param name="ownerLeft">Did the owner leave?</param>
        /// <returns>The new state of the session.</returns>
        SessionState RemovePlayer(string sessionID, uint gameID, IdentityToken actorIdentity, out SeatInfo leavingPlayerSeat, out bool ownerLeft);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\ModuleModifiableState.cs ===
// <copyright file="ModuleModifiableState.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the class definition for ModuleModifiableState class.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;

    /// <summary>
    /// This class models the ModuleModifiableState Game State,
    /// (parts of the game state that can be modified by game logic module).
    /// </summary>
    public class ModuleModifiableState
    {
        /// <summary>
        /// Gets or sets a value indicating whether the GameState is complete.
        /// </summary>
        /// <value>Indicates whether the GameState is complete.</value>
        public bool? IsComplete
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the ActiveSeatIndex for the GameState.
        /// </summary>
        /// <value>The ActiveSeatIndex for the GameState.</value>
        public int? ActiveSeatIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModified value for the GameState.
        /// </summary>
        /// <value>The LastModified value for the GameState.</value>
        public DateTime? LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SequenceNumber for the GameState.
        /// </summary>
        /// <value>The SequenceNumber for the GameState.</value>
        public int? SequenceNumber
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the OwnerSeatIndex for the session.
        /// </summary>
        /// <value>The OwnerSeatIndex for the session.</value>
        public int? OwnerSeatIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether this session is closed for joining.
        /// </summary>
        /// <value>The IsClosed value for the session.</value>
        public bool? IsClosed
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether inactivity warning has been sent.
        /// </summary>
        /// <value>The IsInactivityWarningSent value.</value>
        public bool? IsInactivityWarningSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the number of nudges sent.
        /// </summary>
        /// <value>The NumberOfNudgesSent.</value>
        public int? NumberOfNudgesSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the active seat has been sent a user nudge.
        /// </summary>
        /// <value>A value indicating whether the active seat has been sent a user nudge.</value>
        public bool? WasActiveSeatUserNudged
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\OpaqueSessionStorageObject.cs ===
// <copyright file="OpaqueSessionStorageObject.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-23</date>
// <summary>Contains the class definition for OpaqueSessionStorageObject.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    /// <summary>
    /// This class models an opaque session storage object.
    /// This is meant to boost performance by avoiding multiple queries to the storage backend.
    /// </summary>
    public class OpaqueSessionStorageObject
    {
        /// <summary>
        /// Gets or sets the sessionID.
        /// </summary>
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the GameID.
        /// </summary>
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the opaque object within the class.
        /// </summary>
        public object Object
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the assembly information for the SessionCommon assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionCommon")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("c164d957-4e7a-4a24-88b3-122bb410f8dd")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\SeatInfo.cs ===
// <copyright file="SeatInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SeatInfo.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;
    using Leet.Core.Platforms;

    /// <summary>
    /// Models the information for a seat.
    /// </summary>
    [DataContract]
    [Serializable]
    public class SeatInfo
    {
        /// <summary>
        /// Gets or sets the Locale for the seat.
        /// </summary>
        /// <value>The Locale for the seat.</value>
        [DataMember]
        public string Locale
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the PlatformType for the seat.
        /// </summary>
        /// <value>The PlatformType for the seat.</value>
        [DataMember]
        public PlatformType PlatformType
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayName for the seat.
        /// </summary>
        /// <value>The DisplayName for the seat.</value>
        [DataMember]
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayPicURL for the seat.
        /// </summary>
        /// <value>The DisplayPicURL for the seat.</value>
        [DataMember]
        public string DisplayPicURL
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayPicSmallURL for the seat.
        /// </summary>
        /// <value>The DisplayPicSmallURL for the seat.</value>
        [DataMember]
        public string DisplayPicSmallURL
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Index for the seat.
        /// </summary>
        /// <value>The Index for the seat.</value>
        [DataMember]
        public int Index
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether AI is sitting on the seat.
        /// </summary>
        /// <value>The IsAI value for the seat.</value>
        [DataMember]
        public bool IsAI
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Profile for the seat.
        /// </summary>
        /// <value>The Profile for the seat.</value>
        [DataMember]
        public IdentityToken Profile
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the session notifications for the user were cleaned after the game ended.
        /// </summary>
        public bool NotificationsCleaned
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\SessionEntry.cs ===
// <copyright file="SessionEntry.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionEntry.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Runtime.Serialization;

    /// <summary>
    /// Models the session entries in a session summary.
    /// </summary>
    [DataContract]
    public class SessionEntry
    {
        /// <summary>
        /// Gets or sets the DisplayName for the session entry.
        /// </summary>
        /// <value>The DisplayName for the session entry.</value>
        [DataMember]
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the GameID for the session entry.
        /// </summary>
        /// <value>The GameID for the session entry.</value>
        [DataMember]
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModified DateTime for the session entry.
        /// </summary>
        /// <value>The LastModified LastModified for the session entry.</value>
        [DataMember]
        public DateTime LastModified
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID for the session entry.
        /// </summary>
        /// <value>The SessionID for the session entry.</value>
        [DataMember]
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionParameters for the session entry.
        /// </summary>
        /// <value>The SessionParameters for the session entry.</value>
        [DataMember]
        public byte[] SessionParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the CreationDate for the session entry.
        /// </summary>
        /// <value>The CreationDate for the session entry.</value>
        [DataMember]
        public DateTime CreationDate
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the LastModifiedBy information for the session entry.
        /// </summary>
        /// <value>The LastModifiedBy information for the session entry.</value>
        [DataMember]
        public SeatInfo LastModifiedBy
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the session is complete.
        /// </summary>
        /// <value>A value indicationg whether the session is complete.</value>
        [DataMember]
        public bool IsComplete
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the Variant for the session entry.
        /// </summary>
        /// <value>The Variant for the session entry.</value>
        [DataMember]
        public int Variant
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\SessionQueryParameters.cs ===
// <copyright file="SessionQueryParameters.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-10-08</date>
// <summary>Contains the class definition for SessionQueryParameters class and associated enums.</summary>

namespace AsyncMultiplayer.SessionCommon
{
    /// <summary>
    /// Defines the session types.
    /// </summary>
    public enum ShowSessionType
    {
        /// <summary>
        /// Shows All sessions.
        /// </summary>
        All = 0,

        /// <summary>
        /// Shows the Active sessions only.
        /// </summary>
        Active = 1,

        /// <summary>
        /// Shows the InActive sessions only.
        /// </summary>
        InActive = 2
    }

    /// <summary>
    /// This class models the query parameters for QuerySessions.
    /// </summary>
    public class SessionQueryParameters
    {
        /// <summary>
        /// Gets or sets the GameID of the sessions to retrieve.
        /// </summary>
        public uint? GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the game variant of the sessions to retrieve.
        /// </summary>
        public int? Variant
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the last sessionID retrieved in a previous call to QuerySessions.
        /// </summary>
        public string LastSessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the maximum number of sessions to retrieve.
        /// </summary>
        public int? MaxSessions
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the type of sessions to retrieve.
        /// </summary>
        public ShowSessionType? ShowSessionType
        {
            get;
            set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionCommon\SessionState.cs ===
// <copyright file="SessionState.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-09-23</date>
// <summary>Contains the class definition for SessionState and related enums.</summary>
namespace AsyncMultiplayer.SessionCommon
{
    using System;
    using System.Net;
    using System.Runtime.Serialization;
    using Leet.Core.Platforms;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;

    /// <summary>
    /// Defines the various types of a session.
    /// </summary>
    public enum SessionType
    {
        /// <summary>
        /// Represents a seesion with all seats available to general public.
        /// </summary>
        AllPublic,
        
        /// <summary>
        /// Represents a seesion with all seats available to only invitees.
        /// </summary>
        AllReserved,

        /// <summary>
        /// Represents a seesion with all seats available to only friends.
        /// </summary>
        FriendsOnly,

        /// <summary>
        /// Represents a seesion with some seats available to invitees and some to public.
        /// </summary>
        Mixed
    }

    /// <summary>
    /// Models the state of a session.
    /// </summary>
    [DataContract]
    public class SessionState
    {
        /// <summary>
        /// Initializes a new instance of the SessionState class using the creation data.
        /// </summary>
        /// <param name="creationData">The creation data used to initilize the class.</param>
        /// <param name="creatorIdentity">The identity of the session creator.</param>
        /// <param name="locale">The locale for the session creator.</param>
        /// <param name="platformType">The platformtype for the session creator.</param>
        public SessionState(CreationData creationData, IdentityToken creatorIdentity, string locale, PlatformType platformType)
        {
            this.GameID = creationData.GameID;
            this.Variant = creationData.Variant;
            this.SessionID = Guid.NewGuid().ToString();
            this.DisplayName = creationData.DisplayName;
            this.SeatsAvailable = creationData.TotalSeatsAvailable - 1;
            this.OwnerSeatIndex = 0;
            this.SessionParameters = creationData.SessionParameters;
            this.CreationTime = DateTime.UtcNow;
            this.InactivityWarning = creationData.InactivityWarning;
            this.IsInactivityWarningSent = false;
            this.IsClosed = false;
            this.CanRemoveEmptySeats = creationData.CanRemoveEmptySeats;

            // Put in the SeatInfo for the user who created the session.
            SeatInfo seatInfo = new SeatInfo();
            seatInfo.Index = 0; // Creator always sits on seat 0.
            seatInfo.IsAI = false;
            seatInfo.Profile = creatorIdentity;
            seatInfo.Locale = locale;
            seatInfo.PlatformType = platformType;
            this.Seats = new SeatInfo[1];
            this.Seats[0] = seatInfo;

            // Create the initial game state
            this.State = new GameState();
            this.State.GameID = creationData.GameID;
            this.State.Variant = creationData.Variant;
            this.State.SessionID = this.SessionID;
            this.State.IsComplete = false;
            this.State.LastModified = this.CreationTime;
            this.State.SequenceNumber = 0;
            this.State.ActiveSeatIndex = 0;

            this.LeavePolicy = creationData.LeavePolicy;
        }

        /// <summary>
        /// Initializes a new instance of the SessionState class.
        /// </summary>
        public SessionState()
        {
        }

        /// <summary>
        /// Gets or sets the GameID for the session.
        /// </summary>
        /// <value>The GameID for the session.</value>
        [DataMember]
        public uint GameID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the game Variant for the session.
        /// </summary>
        /// <value>The game Variant for the session.</value>
        [DataMember]
        public int Variant
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionID for the session.
        /// </summary>
        /// <value>The SessionID for the session.</value>
        [DataMember]
        public string SessionID
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the DisplayName for the session.
        /// </summary>
        /// <value>The DisplayName for the session.</value>
        [DataMember]
        public string DisplayName
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SeatsAvailable for the session.
        /// </summary>
        /// <value>The SeatsAvailable for the session.</value>
        [DataMember]
        public int SeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets this reserved field.
        /// </summary>
        [DataMember]
        public int ReservedSeatsAvailable
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets this reserved field.
        /// </summary>
        [DataMember]
        public SessionType Category
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the OwnerSeatIndex for the session.
        /// </summary>
        /// <value>The OwnerSeatIndex for the session.</value>
        [DataMember]
        public int OwnerSeatIndex
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SessionParameters for the session.
        /// </summary>
        /// <value>The SessionParameters for the session.</value>
        [DataMember]
        public byte[] SessionParameters
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the CreationTime for the session.
        /// </summary>
        /// <value>The CreationTime for the session.</value>
        [DataMember]
        public DateTime CreationTime
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the InactivityWarningBehavior for the session.
        /// </summary>
        /// <value>The InactivityWarningBehavior for the session.</value>
        [DataMember]
        public InactivityWarningBehavior InactivityWarning
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether inactivity warning has been sent for this session.
        /// </summary>
        /// <value>The IsInactivityWarningSent value for the session.</value>
        [DataMember]
        public bool IsInactivityWarningSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether this reserved field is set.
        /// </summary>
        [DataMember]
        public bool IsWarningSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the number of nudges sent for far for the session.
        /// </summary>
        /// <value>The NumberOfNudgesSent for the session.</value>
        [DataMember]
        public int NumberOfNudgesSent
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether this session is closed for joining.
        /// </summary>
        /// <value>The IsClosed value for the session.</value>
        [DataMember]
        public bool IsClosed
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether empty seats can be removed for this session.
        /// </summary>
        /// <value>The CanRemoveEmptySeats value for the session.</value>
        [DataMember]
        public bool CanRemoveEmptySeats
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the SeatInfo array for the session.
        /// </summary>
        /// <value>The SeatInfo array for the session.</value>
        [DataMember]
        public SeatInfo[] Seats
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the actor's seat in the Seats array.
        /// Actor is someone e.g. who is viewing the session state.
        /// </summary>
        /// <value>The actor's seat in the Seats array.</value>
        [DataMember]
        public int? ActorSeat
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the GameState for the session.
        /// </summary>
        /// <value>The GameState for the session.</value>
        [DataMember]
        public GameState State
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets a value indicating whether the active seat has been sent a user nudge.
        /// NOTE: This property is not exposed to clients, hence no DataMember attribute has been applied to this property.
        /// </summary>
        /// <value>A value indicating whether the active seat has been sent a user nudge.</value>
        public bool WasActiveSeatUserNudged
        {
            get;
            set;
        }

        /// <summary>
        /// Gets or sets the session leave policy for the session.
        /// NOTE: This property is not exposed to clients, hence no DataMember attribute has been applied to this property.
        /// </summary>
        /// <value>The session leave policy for the session.</value>
        public SessionLeavePolicy LeavePolicy
        {
            get;
            set;
        }

        /// <summary>
        /// Gets the locale of the session owner.
        /// </summary>
        /// <returns>The locale of the session owner.</returns>
        public string GetOwnerLocale()
        {
            string ownerLocale = null;
            foreach (var seat in this.Seats)
            {
                if (seat.Index == this.OwnerSeatIndex)
                {
                    ownerLocale = seat.Locale;
                    break;
                }
            }

            if (ownerLocale == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.OwnerNotFoundForTheSession,
                    HttpStatusCode.InternalServerError,
                    null,
                    false,
                    this.SessionID,
                    this.GameID.ToString());
            }

            return ownerLocale;
        }

        /// <summary>
        /// Gets the locale of the player.
        /// </summary>
        /// <param name="playerIdentity">The player for which to get the locale.</param>
        /// <returns>The locale of the player.</returns>
        public string GetPlayerLocale(IdentityToken playerIdentity)
        {
            string playerLocale = null;
            foreach (var seat in this.Seats)
            {
                if (seat.Profile.Equals(playerIdentity))
                {
                    playerLocale = seat.Locale;
                    break;
                }
            }

            if (playerLocale == null)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.PlayerNotFoundInTheSession,
                    HttpStatusCode.InternalServerError,
                    null,
                    false,
                    playerIdentity.PublicToken,
                    this.SessionID,
                    this.GameID.ToString());
            }

            return playerLocale;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionMaintenance.Test\NudgeAndWarningManagerTests.cs ===
// <copyright file="NudgeAndWarningManagerTests.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-10</date>
// <summary>Contains the class definition for NudgeAndWarningManagerTests.cs class.</summary>
namespace AsyncMultiplayer.SessionMaintenance.Test
{
    using System;
    using System.Collections;
    using System.Configuration;
    using System.Threading;
    using Common.AzureStorage;
    using Common.UnitTestUtilities;
    using GameMetadata.Client;
    using GameStateAzureStorage;
    using Gds.DataAccess.Rewards;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Platforms;
    using Leet.Profile;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics; 
    using Microsoft.VisualStudio.TestTools.UnitTesting;
    using NotificationService;
    using PassThruGameLogicModule;
    using SessionCommon;
    using SessionManagementService;
    using SessionManagementServiceTests.Test;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Tests the NudgeAndWarningManaget.
    /// </summary>
    [TestClass]
    public class NudgeAndWarningManagerTests
    {
        /// <summary>
        /// Used to store the installation state for perf counters.
        /// </summary>
        private static readonly IDictionary SavedState = new Hashtable();

        /// <summary>
        /// Reference to the storage implementation.
        /// </summary>
        private readonly ISessionStorage sessionStorage;

        /// <summary>
        /// This field is used to store the reference to a IGameStateStorage implementation.
        /// </summary>
        private readonly IGameStateStorage stateStorage;

        /// <summary>
        /// This field has the reference to the INotificationRequest implementation.
        /// </summary>
        private readonly INotificationRequest notificationRequest;

        /// <summary>
        /// This field is used to store the reference to a IGameLogicModule implementation.
        /// </summary>
        private readonly IGameLogicModule gameLogicModule;

        /// <summary>
        /// The session management class to be tested.
        /// </summary>
        private readonly SessionManagementService sessionService;

        /// <summary>
        /// The game state class to be tested.
        /// </summary>
        private readonly GameStateService stateService;

        /// <summary>
        /// The creation data to be used for creation of test sessions.
        /// </summary>
        private readonly CreationData creationData;

        /// <summary>
        /// The identity of the player1.
        /// </summary>
        private readonly IdentityToken testPlayer1Identity;

        /// <summary>
        /// The identity of player2.
        /// </summary>
        private readonly IdentityToken testPlayer2Identity;

        /// <summary>
        /// The gameID for which to store state.
        /// </summary>
        private readonly uint gameID;

        /// <summary>
        /// Locale to be used for all users.
        /// </summary>
        private readonly string locale;

        /// <summary>
        /// Platform type to be used for all users.
        /// </summary>
        private readonly PlatformType platformType;

        /// <summary>
        /// The instance of the tets context used by the test cases in this class.
        /// </summary>
        private TestContext testContextInstance;

        /// <summary>
        /// Initializes a new instance of the NudgeAndWarningManagerTests class.
        /// </summary>
        public NudgeAndWarningManagerTests()
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            ServiceConfigs.Initialize();

            StorageAccountInfo account = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureTableStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            StorageAccountInfo blobAccount = new StorageAccountInfo(
                new Uri(ServiceConfigs.AzureBlobStorageEndPoint),
                null,
                ServiceConfigs.AzureStorageAccount,
                ServiceConfigs.AzureStorageToken,
                false);

            // NOTE: HACK!!! Use a Factory pattern to assign an implementation and remove dependency
            // on SessionAzureStorage/NotificationRequestUtils etc.
            this.sessionStorage = new SessionAzureStorage.SessionAzureStorage(account);
            this.stateStorage = new GameStateAzureStorage(blobAccount);
            this.gameLogicModule = new PassThruGameLogicModule(this.stateStorage, this.sessionStorage);
            this.notificationRequest =
                new NotificationRequestUtils(ConfigurationManager.ConnectionStrings["lest_AsyncNotification_db"].ConnectionString);

            this.gameID = 7777;

            // Register Fake IGameMetadataService.
            Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();

            // Register Fake IProfileProvider.
            Container.Instance.AddService<IProfileProvider, FakeProfileProvider>();

            // Register interfaces used by rewards.
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();
            Container.Instance.AddService<IRewardsQueueWriter, InMemoryRewardsQueueWriter>();
            Container.Instance.AddService<ISubmitGameResult, CSubmitGameResult>();
            Container.Instance.AddService<IIdempotencyFilter, InMemoryBasicIdempotencyFilter>();

            this.sessionService = new SessionManagementService();
            this.stateService = new GameStateService();

            // Initialize creationData
            // Note: set the inactivity behaviour before using.
            this.creationData = new CreationData();
            this.creationData.GameID = this.gameID;
            this.creationData.CanRemoveEmptySeats = true;
            this.creationData.DisplayName = "TestNudgeSession";
            this.creationData.TotalSeatsAvailable = 3;
            this.creationData.SessionParameters = new byte[] { 1, 2, 3 };
            this.creationData.Variant = 0;

            // Initalize testPlayer1Identity
            string token1 = "2600292641994140";
            string publicToken1 = "testPlayer1";
            this.testPlayer1Identity = new IdentityToken(IdentityServiceType.XUID, token1, publicToken1);

            // Initalize testPlayer2Identity
            string token2 = "3600292641994140";
            string publicToken2 = "testPlayer1";
            this.testPlayer2Identity = new IdentityToken(IdentityServiceType.XUID, token2, publicToken2);

            // Initialize locale & platformType
            this.locale = "en-US";
            this.platformType = PlatformType.Mobile;

            // Initialize event system.
            SessionMaintenanceEvents.Initialize("SessionMaintenanceEvents.Test");
            SessionServiceEvents.Initialize("SessionMaintenanceEvents.Test");

            // Initialize perfcounters
            StorageClientPerfCounters.Counters = PerformanceCounters.GetPerformanceCounters(
                                                    typeof(StorageClientPerfCounters), "NudgeAndWarningManagerTests");
        }

        /// <summary>
        /// Gets or sets the test context which provides
        /// information about and functionality for the current test run.
        /// </summary>
        /// <value>The test context.</value>
        public TestContext TestContext
        {
            get
            {
                return this.testContextInstance;
            }

            set
            {
                this.testContextInstance = value;
            }
        }

        /// <summary>
        /// Initilize the test class.
        /// </summary>
        /// <param name="context">The TestContext for this test class.</param>
        [ClassInitialize]
        public static void TestClassInitialize(TestContext context)
        {
            // Install the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Install(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Cleanup after the run.
        /// </summary>
        [ClassCleanup]
        public static void TestClassCleanup()
        {
            // Uninstall the required perf counters.
            PerformanceCountersInstaller perfCountersInstaller = new PerformanceCountersInstaller();
            perfCountersInstaller.Uninstall(typeof(StorageClientPerfCounters).Assembly, SavedState);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings.
        /// The idea is to get the system to send 1 nudge to the player.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsWarnOnly()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.WarnOnly;
            this.creationData.InactivityWarning.Interval = 1;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep so that a nudge will be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(sessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, true, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n Nudged Session with SessionID: " + sessionState.SessionID);

            // Sleep. Since this is a warn only session, nothing should happen.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(nudgedSessionState);

            SessionState postWarnedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, true, this.locale);

            Assert.IsTrue(
                postWarnedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.NumberOfNudgesSent + ") of nudges sent!");

            Assert.IsTrue(
                postWarnedSessionState.SeatsAvailable == 1,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.SeatsAvailable + ") of seats available!");
            
            Console.WriteLine("\n After final nudge, the player has NOT been kicked from Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings when the move is made in time.
        /// The idea is to get the system to not send any nudges to the player.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsWhenMoveIsMadeInTime()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.WarnOnly;
            this.creationData.InactivityWarning.Interval = 5;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep and check if a nudge is sent.
            Thread.Sleep(waitDuration);
            ModifiableGameState gameState = new ModifiableGameState()
                                                {
                                                    GameData = new byte[] { 1, 2, 3 },
                                                    ActiveSeatIndex = 1
                                                };
            this.stateService.SetGameStateInternal(sessionState.SessionID, sessionState.GameID.ToString(), gameState, this.testPlayer1Identity);
            SessionState preNudgeSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, true, this.locale);
            manager.SendNudgesAndWarnings(preNudgeSessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, true, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n Did not nudge Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings.
        /// The idea is to get the system to send 1 nudge to the player.
        /// And when the player makes no move, system should kick the player out.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsKick()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.Kick;
            this.creationData.InactivityWarning.Interval = 1;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep so that a nudge will be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(sessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, false, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n Nudged Session with SessionID: " + sessionState.SessionID);

            // Sleep. Since this is a kick session, the player 1 should be kicked out.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(nudgedSessionState);

            SessionState postWarnedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, true, this.locale);

            Assert.IsTrue(
                postWarnedSessionState.SeatsAvailable == 2,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.SeatsAvailable + ") of seats available!");
            Assert.IsTrue(
                postWarnedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n The player has been kicked from Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings.
        /// The idea is to get the system to send 1 nudge to the player.
        /// And when the player makes no move, system should kick the player out.
        /// Since the leave policy in this case is that the opponents win, the session should be complete after the kick.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsKickOpponentsWin()
        {
            // Initialize creationData
            CreationData opponentsWinCreationData = new CreationData();
            opponentsWinCreationData.GameID = this.gameID;
            opponentsWinCreationData.CanRemoveEmptySeats = true;
            opponentsWinCreationData.DisplayName = "TestSession with different policy";
            opponentsWinCreationData.TotalSeatsAvailable = 3;
            opponentsWinCreationData.SessionParameters = new byte[] { 1, 2, 3 };
            opponentsWinCreationData.Variant = 0;
            opponentsWinCreationData.LeavePolicy = SessionLeavePolicy.LeavingUserLosesOpponentsWin;

            // Set up the inactivity warning behaviour
            opponentsWinCreationData.InactivityWarning = new InactivityWarningBehavior();
            opponentsWinCreationData.InactivityWarning.Action = InactivityWarningAction.Kick;
            opponentsWinCreationData.InactivityWarning.Interval = 1;
            opponentsWinCreationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), opponentsWinCreationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = opponentsWinCreationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (opponentsWinCreationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep so that a nudge will be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(sessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, false, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n Nudged Session with SessionID: " + sessionState.SessionID);

            // Sleep. Since this is a kick session, the player 1 should be kicked out.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(nudgedSessionState);

            SessionState kickedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, true, this.locale);

            Assert.IsTrue(
                kickedSessionState.SeatsAvailable == 2,
                "Error: session: " + kickedSessionState.SessionID + " has unexpected number(" + kickedSessionState.SeatsAvailable + ") of seats available!");
            Assert.IsTrue(
                kickedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + kickedSessionState.SessionID + " has unexpected number(" + kickedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Assert.IsTrue(kickedSessionState.State.IsComplete);
            Assert.IsTrue(kickedSessionState.State.LastModified > nudgedSessionState.State.LastModified);

            DateTime lastModifiedAfterKick;
            SeatInfo lastModifiedByAfterKick;
            SessionEntry sessionEntryAfterKick = SessionManagementServiceTests.GetLastModifiedDataForSession(
                this.testPlayer2Identity, kickedSessionState.SessionID, kickedSessionState.GameID, out lastModifiedAfterKick, out lastModifiedByAfterKick, this.sessionService);
            Assert.IsTrue(sessionEntryAfterKick.IsComplete);
            Assert.IsTrue(sessionEntryAfterKick.LastModified > nudgedSessionState.State.LastModified);

            Console.WriteLine("\n The player has been kicked from Session with SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings on a completed session.
        /// Verify that the system ignores a completed session.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsKickCompletedSession()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.Kick;
            this.creationData.InactivityWarning.Interval = 1;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            // Set the session to completed state.
            GameResults gameResults = new GameResults();
            this.stateService.PostGameEndInternal(newSessionState.SessionID, newSessionState.GameID.ToString(), gameResults, this.testPlayer1Identity, string.Empty);
            SessionState completedSessionState = 
                this.sessionService.ViewSessionInternal(sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, false, this.locale);

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep so that a nudge might be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(completedSessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, false, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");

            // Sleep. Since this is a kick session, the player 1 might be kicked out.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(nudgedSessionState);

            SessionState postWarnedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, true, this.locale);

            Assert.IsTrue(
                postWarnedSessionState.SeatsAvailable == 1,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.SeatsAvailable + ") of seats available!");
            Assert.IsTrue(
                postWarnedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n After 2 intervals, a completed session was ignored, SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings with an empty active seat.
        /// Verify that the system does not send nudges/kicks.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsKickEmptyActiveSeat()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.Kick;
            this.creationData.InactivityWarning.Interval = 1;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            // Player 1 leaves the session now.
            this.sessionService.LeaveSessionInternal(newSessionState.SessionID, newSessionState.GameID.ToString(), this.testPlayer1Identity);
            SessionState leftSessionState = 
                this.sessionService.ViewSessionInternal(sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, false, this.locale);

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep so that a nudge might be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(leftSessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, false, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");

            // Sleep. Since this is a kick session, the player 2 might be kicked out.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(nudgedSessionState);

            SessionState postWarnedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, true, this.locale);

            Assert.IsTrue(
                postWarnedSessionState.SeatsAvailable == 2,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.SeatsAvailable + ") of seats available!");
            Assert.IsTrue(
                postWarnedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n After 3 intervals, a completed session was ignored, SessionID: " + sessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings when the owner leaves and another player is seated at the same seat.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsWhenOwnerLeaves()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.Kick;
            this.creationData.InactivityWarning.Interval = 1;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep so that a nudge might be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(sessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
               sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, false, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");

            // Player 1 leaves the session now.
            this.sessionService.LeaveSessionInternal(newSessionState.SessionID, newSessionState.GameID.ToString(), this.testPlayer1Identity);
            SessionState leftSessionState =
                this.sessionService.ViewSessionInternal(sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, false, this.locale);

            // Sleep so that a nudge/warning might be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(leftSessionState);

            SessionState afterLeaveSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, false, this.locale);

            Assert.IsTrue(
                afterLeaveSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + afterLeaveSessionState.SessionID + " has unexpected number(" + afterLeaveSessionState.NumberOfNudgesSent + ") of nudges sent!");

            // Player 3 joins the session now at the default seat.
            IdentityToken testPlayer3Identity = new IdentityToken(5000, "testplayer3");
            joinData.SeatIndex = 0;
            this.sessionService.JoinSessionInternal(
                                newSessionState.SessionID,
                                joinData,
                                testPlayer3Identity,
                                this.locale,
                                this.platformType);

            SessionState sessionStateAfterThirdPlayerJoined = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), testPlayer3Identity, false, this.locale);

            Assert.IsTrue(
                sessionStateAfterThirdPlayerJoined.ActorSeat == 0,
                "Player is not in the expected seat (0), players's seat is: " + sessionStateAfterThirdPlayerJoined.ActorSeat);

            // Sleep, the player should be kicked.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(sessionStateAfterThirdPlayerJoined);

            SessionState postKickSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer2Identity, true, this.locale);

            Assert.IsTrue(
                postKickSessionState.SeatsAvailable == 2,
                "Error: session: " + postKickSessionState.SessionID + " has unexpected number(" + postKickSessionState.SeatsAvailable + ") of seats available!");
            Assert.IsTrue(
                postKickSessionState.NumberOfNudgesSent == 1,
                "Error: session: " + postKickSessionState.SessionID + " has unexpected number(" + postKickSessionState.NumberOfNudgesSent + ") of nudges sent!");

            Console.WriteLine("\n Kicked the new user sitting on the stalling seat in the session with SessionID: " + postKickSessionState.SessionID);
        }

        /// <summary>
        /// Test SendNudgesAndWarnings.
        /// The idea is to get the system to not send any nudges or warnings.
        /// </summary>
        [TestMethod]
        public void TestSendNudgesAndWarningsNoAction()
        {
            // Set up the inactivity warning behaviour
            this.creationData.InactivityWarning = new InactivityWarningBehavior();
            this.creationData.InactivityWarning.Action = InactivityWarningAction.None;
            this.creationData.InactivityWarning.Interval = 1;
            this.creationData.InactivityWarning.MaxNumberOfNudges = 1;

            SessionState newSessionState = this.sessionService.CreateSessionInternal(
                    this.gameID.ToString(), this.creationData, this.testPlayer1Identity, this.locale, this.platformType);
            Console.WriteLine("\n Added Session with SessionID: " + newSessionState.SessionID);

            // Add a player to the session.
            JoinData joinData = new JoinData();
            joinData.GameID = this.creationData.GameID;
            joinData.SeatIndex = 1;
            joinData.SeatParameters = new byte[] { 4, 5, 6 };
            joinData.SessionID = newSessionState.SessionID;
            SessionState sessionState = this.sessionService.JoinSessionInternal(
                                            newSessionState.SessionID,
                                            joinData,
                                            this.testPlayer2Identity,
                                            this.locale,
                                            this.platformType);

            Assert.IsTrue(sessionState.NumberOfNudgesSent == 0, "Error: session: " + sessionState.SessionID + " already has nudges sent!");

            NudgeAndWarningManager manager = new NudgeAndWarningManager(
                                                this.sessionStorage,
                                                this.notificationRequest,
                                                this.gameLogicModule,
                                                true);

            // Wait for more than the InactivityWarning.Interval.
            int waitDuration = (this.creationData.InactivityWarning.Interval * 1000) + 100;

            // Sleep see if a nudge will be sent.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(sessionState);

            SessionState nudgedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, true, this.locale);

            Assert.IsTrue(
                nudgedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + nudgedSessionState.SessionID + " has unexpected number(" + nudgedSessionState.NumberOfNudgesSent + ") of nudges sent!");
            Console.WriteLine("\n NOT Nudged Session with SessionID: " + sessionState.SessionID);

            // Sleep. Since this is a no action session, nothing should happen.
            Thread.Sleep(waitDuration);
            manager.SendNudgesAndWarnings(nudgedSessionState);

            SessionState postWarnedSessionState = this.sessionService.ViewSessionInternal(
                sessionState.SessionID, sessionState.GameID.ToString(), this.testPlayer1Identity, true, this.locale);

            Assert.IsTrue(
                postWarnedSessionState.NumberOfNudgesSent == 0,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.NumberOfNudgesSent + ") of nudges sent!");

            Assert.IsTrue(
                postWarnedSessionState.SeatsAvailable == 1,
                "Error: session: " + postWarnedSessionState.SessionID + " has unexpected number(" + postWarnedSessionState.SeatsAvailable + ") of seats available!");

            Console.WriteLine("\n After 2 intervals, no nudges/no kicks for Session with SessionID: " + sessionState.SessionID);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionMaintenance\NudgeAndWarningManager.cs ===
// <copyright file="NudgeAndWarningManager.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-08</date>
// <summary>Contains the class definition for NudgeAndWarningManager class.</summary>
namespace AsyncMultiplayer.SessionMaintenance
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Net;
    using Common.AzureStorage;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationSender;
    using NotificationService;
    using SessionCommon;

    /// <summary>
    /// This class manages nudges and warnings sent on behalf of the multiplayer system.
    /// </summary>
    public class NudgeAndWarningManager
    {
        /// <summary>
        /// Reference to the storage implementation.
        /// </summary>
        private readonly ISessionStorage sessionStorage;

        /// <summary>
        /// This field has the reference to the INotificationRequest implementation.
        /// </summary>
        private readonly INotificationRequest notificationRequest;

        /// <summary>
        /// This field is used to store the reference to a IGameLogicModule implementation.
        /// </summary>
        private readonly IGameLogicModule gameLogicModule;

        /// <summary>
        /// Run the manager in test mode. In Test mode InactivityWarning.Interval is interpreted as seconds instead of days.
        /// </summary>
        private readonly bool runInTestMode;

        /// <summary>
        /// Initializes a new instance of the NudgeAndWarningManager class.
        /// </summary>
        /// <param name="sessionStorage">The session storage implementation to use for accessing the session store.</param>
        /// <param name="notificationRequest">The notification implementation to use for sending notifications.</param>
        /// <param name="gameLogicModule">The game logic module implementation to use for firing events on game.</param>
        /// <param name="runInTestMode">Run the manager in test mode. In Test mode InactivityWarning.Interval is interpreted as seconds instead of days.</param>
        public NudgeAndWarningManager(ISessionStorage sessionStorage, INotificationRequest notificationRequest, IGameLogicModule gameLogicModule, bool runInTestMode)
        {
            this.sessionStorage = sessionStorage;
            this.notificationRequest = notificationRequest;
            this.gameLogicModule = gameLogicModule;
            this.runInTestMode = runInTestMode;
        }

        /// <summary>
        /// Sends nudges and warnings for the session.
        /// </summary>
        /// <param name="sessionState">The state of the session for which to send out nudges and warnings.</param>
        public void SendNudgesAndWarnings(SessionState sessionState)
        {
            // Ignore completed sessions
            if (sessionState.State.IsComplete)
            {
                return;
            }

            NotificationSender notificationSender = new NotificationSender(this.notificationRequest);

            switch (sessionState.InactivityWarning.Action)
            {
                case InactivityWarningAction.Kick:
                    //// Falling through.

                case InactivityWarningAction.WarnOnly:
                    DateTime allowedInactiveTime = this.runInTestMode ? sessionState.State.LastModified.AddSeconds(sessionState.InactivityWarning.Interval) :
                                                                        sessionState.State.LastModified.AddDays(sessionState.InactivityWarning.Interval);

                    // Get the active seat.
                    SeatInfo activeSeat = null;
                    foreach (var seat in sessionState.Seats)
                    {
                        if (seat.Index == sessionState.State.ActiveSeatIndex)
                        {
                            activeSeat = seat;
                            break;
                        }
                    }

                    if (DateTime.UtcNow.CompareTo(allowedInactiveTime) > 0 && (activeSeat != null))
                    {
                        if (sessionState.NumberOfNudgesSent < sessionState.InactivityWarning.MaxNumberOfNudges)
                        {
                            sessionState.NumberOfNudgesSent++;

                            // If there are only two people in the session, send the nudge from the other user in the session, else send from the owner.
                            IdentityToken senderIdentity = null;
                            if (sessionState.Seats.Length == 2)
                            {
                                foreach (SeatInfo seat in sessionState.Seats)
                                {
                                    if (seat.Index != activeSeat.Index)
                                    {
                                        senderIdentity = seat.Profile;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                foreach (SeatInfo seat in sessionState.Seats)
                                {
                                    if (seat.Index == sessionState.OwnerSeatIndex)
                                    {
                                        senderIdentity = seat.Profile;
                                        break;
                                    }
                                }
                            }

                            // Send the nudge from the above computed user, else send it from the system user.
                            if (senderIdentity != null)
                            {
                                notificationSender.SendNudgeNotification(sessionState, activeSeat.Profile, senderIdentity);
                            }
                            else
                            {
                                notificationSender.SendNudgeNotification(sessionState, activeSeat.Profile);
                            }

                            this.sessionStorage.ModifySession(sessionState.SessionID, sessionState.GameID, true);
                        }
                        else
                        {
                            // Handle the fall through from case InactivityWarningAction.Kick
                            if (sessionState.InactivityWarning.Action == InactivityWarningAction.Kick)
                            {
                                SeatInfo leavingPlayerSeat;
                                bool ownerLeft;
                                SessionState newSessionState = this.sessionStorage.RemovePlayer(
                                    sessionState.SessionID,
                                    sessionState.GameID,
                                    activeSeat.Profile,
                                    out leavingPlayerSeat,
                                    out ownerLeft);

                                this.gameLogicModule.OnLeaveSession(newSessionState, ownerLeft, activeSeat);
                                SessionUtils.ApplyLeavePolicyAndManageNotifications(newSessionState, activeSeat, this.notificationRequest, this.sessionStorage);
                            }
                        }
                    }

                    break;

                default:
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionMaintenance\SessionUtils.cs ===
// <copyright file="SessionUtils.cs" company="Microsoft">Copyright (c) 2010 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2010-12-00</date>
// <summary>Contains the class definition for SessionUtils class.</summary>
namespace AsyncMultiplayer.SessionMaintenance
{
    using System;
    using System.Collections.Generic;
    using System.Net;
    using Gds.Contracts;
    using Gds.DataAccess.Rewards;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using NotificationSender;
    using NotificationService;
    using SessionCommon;

    /// <summary>
    /// This class provides utilities for helping in session maintenance.
    /// </summary>
    public class SessionUtils
    {
        /// <summary>
        /// Applies the session leave policy and manages the notifications when a player leaves a session.
        /// </summary>
        /// <param name="leftSessionState">Session state after leave.</param>
        /// <param name="userWhoLeft">The seat information of the user who left.</param>
        /// <param name="notificationRequest">The notification request object to use.</param>
        /// <param name="sessionStorage">Implementation of session storage to use.</param>
        public static void ApplyLeavePolicyAndManageNotifications(SessionState leftSessionState, SeatInfo userWhoLeft, INotificationRequest notificationRequest, ISessionStorage sessionStorage)
        {
            NotificationSender notificationSender = new NotificationSender(notificationRequest);

            // Apply the session leave policy if the session is not complete & there is someone left in the session.
            if ((leftSessionState.Seats.Length > 0) && (!leftSessionState.State.IsComplete))
            {
                IList<CompositeGameResult> compositeGameResults = new List<CompositeGameResult>();
                GameResult userWhoLeftGameResult = new GameResult()
                {
                    GameId = leftSessionState.GameID,
                    GameResultId = Guid.NewGuid(),
                    Outcome = GameResultOutcome.Loss.ToString(),
                    TimeStamp = DateTime.UtcNow,
                    Variant = (uint)leftSessionState.Variant
                };

                CompositeGameResult newGameResult = new CompositeGameResult()
                {
                    GameResult = userWhoLeftGameResult,
                    Locale = userWhoLeft.Locale,
                    PlatformType = ((uint)userWhoLeft.PlatformType).ToString(),
                    Xuid = ulong.Parse(userWhoLeft.Profile.Token)
                };

                compositeGameResults.Add(newGameResult);

                switch (leftSessionState.LeavePolicy)
                {
                    case SessionLeavePolicy.LeavingUserLoses:
                        SubmitResult(leftSessionState, compositeGameResults);
                        NudgeOnActivePlayerLeaving(leftSessionState, userWhoLeft, notificationSender);
                        break;

                    case SessionLeavePolicy.LeavingUserLosesOpponentsWin:
                        // Delete "Your Turn"/"Nudge" notification for all the remaining players in this session.
                        List<IdentityToken> winnerList = new List<IdentityToken>();
                        foreach (SeatInfo seat in leftSessionState.Seats)
                        {
                            notificationSender.DeleteYourTurnNotification(leftSessionState, seat.Profile);
                            notificationSender.DeleteNudgeNotification(leftSessionState, seat.Profile);
                            winnerList.Add(seat.Profile);
                        }

                        // Send "You Win" notifications to the remaining players.
                        notificationSender.SendYouWinNotification(leftSessionState, winnerList);

                        IdentityToken ownerIdentity = null;
                        foreach (SeatInfo seat in leftSessionState.Seats)
                        {
                            GameResult otherUserGameResult = new GameResult()
                            {
                                GameId = leftSessionState.GameID,
                                GameResultId = Guid.NewGuid(),
                                Outcome = GameResultOutcome.Win.ToString(),
                                TimeStamp = DateTime.UtcNow,
                                Variant = (uint)leftSessionState.Variant
                            };

                            CompositeGameResult otherUserCompositeGameResult = new CompositeGameResult()
                            {
                                GameResult = otherUserGameResult,
                                Locale = seat.Locale,
                                PlatformType = ((uint)seat.PlatformType).ToString(),
                                Xuid = ulong.Parse(seat.Profile.Token)
                            };

                            compositeGameResults.Add(otherUserCompositeGameResult);

                            if (seat.Index == leftSessionState.OwnerSeatIndex)
                            {
                                ownerIdentity = seat.Profile;
                            }
                        }

                        SubmitResult(leftSessionState, compositeGameResults);

                        // Set the session as completed.
                        ModuleModifiableState moduleModifiableState = new ModuleModifiableState() { IsComplete = true, LastModified = DateTime.UtcNow };
                        OpaqueSessionStorageObject storageObject;
                        sessionStorage.QuerySession(leftSessionState.SessionID, leftSessionState.GameID, out storageObject);
                        sessionStorage.ModifySession(storageObject, moduleModifiableState, ownerIdentity);
                        break;

                    case SessionLeavePolicy.None:
                        NudgeOnActivePlayerLeaving(leftSessionState, userWhoLeft, notificationSender);
                        break;

                    default:
                        break;
                }
            }

            // Delete all notifications received for this session for the user who left.
            notificationSender.DeleteAllNotificationsForSession(leftSessionState, userWhoLeft.Profile);
        }

        /// <summary>
        /// Nudge the owner if the active player has left.
        /// </summary>
        /// <param name="leftSessionState">Session state after leave.</param>
        /// <param name="userWhoLeft">The seat information of the user who left.</param>
        /// <param name="notificationSender">The notification sender reference to use.</param>
        private static void NudgeOnActivePlayerLeaving(SessionState leftSessionState, SeatInfo userWhoLeft, NotificationSender notificationSender)
        {
            // Send a nudge to the owner if the player on the active seat left.
            if (leftSessionState.State.ActiveSeatIndex == userWhoLeft.Index)
            {
                notificationSender.SendNudgeNotification(leftSessionState, leftSessionState.OwnerSeatIndex);
            }
        }

        /// <summary>
        /// Submit the game result for the session.
        /// </summary>
        /// <param name="sessionState">The session to submit game results for.</param>
        /// <param name="compositeGameResults">The results to submit.</param>
        private static void SubmitResult(SessionState sessionState, IList<CompositeGameResult> compositeGameResults)
        {
            ISubmitGameResult submitGameResult = Container.Instance.GetComponent<ISubmitGameResult>();

            try
            {
                submitGameResult.SubmitBatch(compositeGameResults, GameResultSubmissionEnum.MultiplayerServiceSubmission);
            }
            catch (RewardsDataAccessException ex)
            {
                throw new LIVEnException(
                    SessionServiceEvents.Events,
                    SessionServiceEvents.RewardsErrorWhileProcessingGameResults,
                    HttpStatusCode.InternalServerError,
                    ex,
                    true,
                    sessionState.SessionID,
                    sessionState.GameID.ToString());
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionMaintenance\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-10</date>
// <summary>Contains the assembly information for the SessionMaintenance assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionMaintenance")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("f8a3f29a-d1b0-4fea-925a-b41dbec1987a")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers 
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionMaintenance.Test\Properties\AssemblyInfo.cs ===
// <copyright file="AssemblyInfo.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-11-10</date>
// <summary>Contains the assembly information for the SessionMaintenance.Test assembly.</summary>

using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("SessionMaintenance.Test")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM componenets.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("b3539354-2196-411d-834d-3110d32d5ddd")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\GameState.svc.cs ===
// <copyright file="GameState.svc.cs" company="Microsoft">Copyright (c) 2009 All Right Reserved
// </copyright>
// <author>Amit Dhar</author>
// <email>amitdhar@microsoft.com</email>
// <date>2009-10-19</date>
// <summary>Contains the partial class definition for GameStateService class.</summary>
namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using System.Net;
    using System.ServiceModel;
    using System.ServiceModel.Activation;
    using System.ServiceModel.Web;
    using Leet.Core.Diagnostics;
    using Leet.Core.Utils;
    using LIVEN.Common.Diagnostics;
    using SessionCommon;

    /// <summary>
    /// Game State service class which handles all game state related requests.
    /// </summary>
    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]
    [AspNetCompatibilityRequirements(RequirementsMode = AspNetCompatibilityRequirementsMode.Allowed)]
    public partial class GameStateService : IGameStateService
    {
        /// <summary>
        /// Gets the component name.
        /// </summary>
        public string ComponentName
        {
            get
            {
                return "GameStateService";
            }
        }

        /// <summary>
        /// Gets the game state for the given session for a particular game in Xml format.
        /// </summary>
        /// <param name="sessionID">SessionID for which to get the game state.</param>
        /// <param name="gameID">GameID for which to get the game state.</param>
        /// <returns>The Full GameState for a session.</returns>
        public FullGameState GetGameStateInXml(string sessionID, string gameID)
        {
            const string MethodName = "GetGameStateInXml";
            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Entered method: ", MethodName);

            FullGameState fullGameState = null;
            try
            {
                fullGameState = this.GetGameStateInternal(
                    sessionID, gameID, IdentityHelper.GetIdentity(gameID));
            }
            catch (Exception ex)
            {
                this.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Exiting method: ", MethodName);
            return fullGameState;
        }

        /// <summary>
        /// Sets the game state for the given session for a particular game.
        /// </summary>
        /// <param name="sessionID">SessionID for which to set the game state.</param>
        /// <param name="gameID">GameID for which to set the game state.</param>
        /// <param name="modGameState">The GameState to be put.</param>
        public void PutGameState(string sessionID, string gameID, ModifiableGameState modGameState)
        {
            const string MethodName = "PutGameState";
            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Entered method: ", MethodName);

            try
            {
                this.SetGameStateInternal(
                    sessionID, gameID, modGameState, IdentityHelper.GetIdentity(gameID));
            }
            catch (Exception ex)
            {
                this.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Entered method: ", MethodName);
        }

        /// <summary>
        /// Ends a particular passthrough game.
        /// </summary>
        /// <param name="sessionID">SessionID to end.</param>
        /// <param name="gameID">GameID to end.</param>
        /// <param name="gameResults">The win/loss/tie results of the game.</param>
        public void PostGameEnd(string sessionID, string gameID, GameResults gameResults)
        {
            const string MethodName = "PostGameEnd";
            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Entered method: ", MethodName);

            try
            {
                string platformType = WebOperationContext.Current.IncomingRequest.Headers[CustomWebHeaderNames.XPlatformType];
                this.PostGameEndInternal(
                    sessionID, gameID, gameResults, IdentityHelper.GetIdentity(gameID), platformType);
            }
            catch (Exception ex)
            {
                this.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Exiting method: ", MethodName);
        }

        /// <summary>
        /// Submits a new game action for a particular game session.
        /// </summary>
        /// <param name="sessionID">SessionID for which to submit a new game action.</param>
        /// <param name="gameID">GameID for which to submit a new game action.</param>
        /// <param name="gameAction">The GameAction to be submitted.</param>
        public void PostGameAction(string sessionID, string gameID, GameAction gameAction)
        {
            const string MethodName = "PostGameAction";
            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Entered method: ", MethodName);

            try
            {
                this.PostGameActionInternal(
                    sessionID, gameID, gameAction, IdentityHelper.GetIdentity(gameID));
            }
            catch (Exception ex)
            {
                this.HandleException(MethodName, ex);
            }

            Logging.TraceVerbose("{0}: {1} {2}", this.ComponentName, "Exiting method: ", MethodName);
        }

        /// <summary>
        /// Handle any unexpected exceptions.
        /// </summary>
        /// <param name="methodName">The method in which exception was caught.</param>
        /// <param name="exception">The unexpected exception.</param>
        private void HandleException(string methodName, Exception exception)
        {
            LIVEnException livEnException = exception as LIVEnException;

            Logging.TraceException(
                exception,
                "{0}: {1} {2}",
                this.ComponentName,
                "Exception caught in method: ",
                methodName);

            if (livEnException == null)
            {
                livEnException =
                    new LIVEnException(
                        SessionServiceEvents.Events,
                        SessionServiceEvents.UnexpectedExceptionInGameStateService,
                        HttpStatusCode.InternalServerError,
                        exception,
                        true,
                        methodName);
            }

            livEnException.ThrowWebProtocolException();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\product\Source\Multiplayer\AsyncMultiplayer\SessionManagementService\Global.asax.cs ===
//-------------------------------------------------------------------
// <copyright file="Global.asax.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//
// <author email="fgao">
//     Feng Gao
// </author>
//
// <summary>
//  Session Management Service FrontEnd Global application
// </summary>
//
// <remarks/>
//
// <disclaimer/>
//
// <history date="10/21/2008">
//     Class created
// </history>
//-------------------------------------------------------------------

namespace AsyncMultiplayer.SessionManagementService
{
    using System;
    using System.Configuration;
    using System.Web;
    using Common.AzureStorage;
    using GameMetadata.Client;
    using Gds.DataAccess.Rewards;
    using Leet.Core.BI;
    using Leet.Core.Diagnostics;
    using Leet.Core.IoCCo;
    using Leet.Core.Utils;
    using Leet.Identity;
    using Leet.Live.Livecache;
    using Leet.Live.Livecache.Providers;
    using Leet.Profile;
    using Leet.Utils;
    using LIVEN.Common.Diagnostics;
    using Wgx.Services.Monitoring;

    /// <summary>
    /// Global Application Class.
    /// </summary>
    public class Global : System.Web.HttpApplication
    {
        /// <summary>
        /// Name associated with the service.
        /// </summary>
        public static readonly string ServiceName = "session_management_service";

        /// <summary>
        /// Application OnStart event handler.
        /// </summary>
        /// <param name="sender">Sender object.</param>
        /// <param name="e">Event arguments.</param>
        protected void Application_Start(object sender, EventArgs e)
        {
            Container.Instance.AddService<ILogFormatter, LogFormatter>();
            Container.Instance.AddService<ILogging, Logging>();

            // register the configuration providers.
            ServiceConfigs.Initialize();

            SessionServiceEvents.Initialize(Global.ServiceName);
            NotificationEvents.Initialize(Global.ServiceName);
            Logging.TraceInformation(
                "{0}: {1}",
                Global.ServiceName,
                "Service Application Starting.");

            // Register ILocaleHelper
            Container.Instance.AddService<ILocaleHelper, LocaleHelperProvider>();

            string useFakeClientVal = ConfigurationManager.AppSettings["UseFakeClient"];
            if (string.IsNullOrEmpty(useFakeClientVal))
            {
                useFakeClientVal = "false";
            }

            // Register GameMetadataClient
            if (Boolean.Parse(useFakeClientVal.Trim().ToLower()))
            {
                Container.Instance.AddService<IGameMetadataClient, FakeGameMetadataClient>();
            }
            else
            {
                GameMetadataClient.RegisterContainerServices();
            }

            // Register Partner Token Identity capability.
            Container.Instance.AddEmulatableService<IAudienceUriProvider, SessionServiceA